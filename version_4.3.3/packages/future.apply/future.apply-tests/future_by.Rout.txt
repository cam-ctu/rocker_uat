
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[13:33:40.520] plan(): Setting new future strategy stack:
[13:33:40.520] List of future strategies:
[13:33:40.520] 1. sequential:
[13:33:40.520]    - args: function (..., envir = parent.frame())
[13:33:40.520]    - tweaked: FALSE
[13:33:40.520]    - call: future::plan("sequential")
[13:33:40.534] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> all_equal_but_call <- function(target, current, ...) {
+   attr(target, "call") <- NULL
+   attr(current, "call") <- NULL
+   all.equal(target = target, current = current, ...)
+ }
> 
> message("*** future_by() ...")
*** future_by() ...
> 
> ## ---------------------------------------------------------
> ## by()
> ## ---------------------------------------------------------
> if (require("datasets") && require("stats")) { ## warpbreaks & lm()
+   ## Use a local variable to test that it is properly exported, because
+   ## 'warpbreaks' is available in all R sessions
+   data <- warpbreaks
+   
+   y0 <- by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+   y1 <- by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+   y2 <- by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+     lm(breaks ~ wool, data = x, ...)
+   }, singular.ok = FALSE)
+   
+   ## now suppose we want to extract the coefficients by group
+   tmp <- with(data, by(data, INDICES = tension, FUN = function(x) {
+     lm(breaks ~ wool, data = x)
+   }))
+   y3 <- sapply(tmp, coef)
+ 
+   ## Source: {r-source}/tests/reg-tests-1d.R
+   by2 <- function(data, INDICES, FUN) {
+     by(data, INDICES = INDICES, FUN = FUN)
+   }
+   future_by2 <- function(data, INDICES, FUN) {
+     future_by(data, INDICES = INDICES, FUN = FUN)
+   }
+   y4 <- by2(data, INDICES = data[,"tension"], FUN = summary)
+ 
+   for (cores in 1:availCores) {
+     message(sprintf("Testing with %d cores ...", cores))
+     options(mc.cores = cores)
+     strategies <- supportedStrategies(cores)
+   
+     for (strategy in supportedStrategies()) {
+       message(sprintf("- plan('%s') ...", strategy))
+       plan(strategy)
+     
+       y0f <- future_by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y0f, y0, check.attributes = FALSE))
+       
+       y1f <- future_by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+       stopifnot(all_equal_but_call(y1f, y1))
+       
+       y2f <- future_by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+         lm(breaks ~ wool, data = x, ...)
+       }, singular.ok = FALSE)
+       stopifnot(all_equal_but_call(y2f, y2))
+       
+       ## now suppose we want to extract the coefficients by group
+       tmp <- with(data, future_by(data, INDICES = tension, FUN = function(x) {
+         lm(breaks ~ wool, data = x)
+       }))
+       y3f <- sapply(tmp, coef)
+       stopifnot(all_equal_but_call(y3f, y3))
+       
+       y4f <- future_by2(data, INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y4f, y4))
+ 
+       ## Deprecated /HB 2022-10-24
+       y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       stopifnot(all_equal_but_call(y4f2, y4))
+ 
+       res <- tryCatch({
+         y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       }, warning = identity)
+       stopifnot(inherits(res, "warning"))
+       if (getRversion() >= "3.6.0") {
+         stopifnot(inherits(res, "deprecatedWarning"))
+       }
+     } ## for (strategy ...)
+     
+     message(sprintf("Testing with %d cores ... DONE", cores))
+   } ## for (cores ...)
+ } ## if (require("stats"))
Testing with 1 cores ...
- plan('sequential') ...
[13:33:40.587] plan(): Setting new future strategy stack:
[13:33:40.587] List of future strategies:
[13:33:40.587] 1. sequential:
[13:33:40.587]    - args: function (..., envir = parent.frame())
[13:33:40.587]    - tweaked: FALSE
[13:33:40.587]    - call: plan(strategy)
[13:33:40.598] plan(): nbrOfWorkers() = 1
[13:33:40.599] future_by_internal() ...
[13:33:40.599] future_lapply() ...
[13:33:40.603] Number of chunks: 1
[13:33:40.604] getGlobalsAndPackagesXApply() ...
[13:33:40.604]  - future.globals: TRUE
[13:33:40.604] getGlobalsAndPackages() ...
[13:33:40.605] Searching for globals...
[13:33:40.607] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:40.607] Searching for globals ... DONE
[13:33:40.607] Resolving globals: FALSE
[13:33:40.608] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:40.608] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:40.609] - globals: [1] ‘FUN’
[13:33:40.609] 
[13:33:40.609] getGlobalsAndPackages() ... DONE
[13:33:40.609]  - globals found/used: [n=1] ‘FUN’
[13:33:40.609]  - needed namespaces: [n=0] 
[13:33:40.609] Finding globals ... DONE
[13:33:40.609]  - use_args: TRUE
[13:33:40.609]  - Getting '...' globals ...
[13:33:40.610] resolve() on list ...
[13:33:40.610]  recursive: 0
[13:33:40.610]  length: 1
[13:33:40.610]  elements: ‘...’
[13:33:40.611]  length: 0 (resolved future 1)
[13:33:40.611] resolve() on list ... DONE
[13:33:40.611]    - '...' content: [n=0] 
[13:33:40.611] List of 1
[13:33:40.611]  $ ...: list()
[13:33:40.611]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.611]  - attr(*, "where")=List of 1
[13:33:40.611]   ..$ ...:<environment: 0x55cb80d80908> 
[13:33:40.611]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.611]  - attr(*, "resolved")= logi TRUE
[13:33:40.611]  - attr(*, "total_size")= num NA
[13:33:40.615]  - Getting '...' globals ... DONE
[13:33:40.615] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:40.616] List of 2
[13:33:40.616]  $ ...future.FUN:function (object, ...)  
[13:33:40.616]  $ ...          : list()
[13:33:40.616]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.616]  - attr(*, "where")=List of 2
[13:33:40.616]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:40.616]   ..$ ...          :<environment: 0x55cb80d80908> 
[13:33:40.616]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.616]  - attr(*, "resolved")= logi FALSE
[13:33:40.616]  - attr(*, "total_size")= num 1240
[13:33:40.618] Packages to be attached in all futures: [n=0] 
[13:33:40.618] getGlobalsAndPackagesXApply() ... DONE
[13:33:40.618] Number of futures (= number of chunks): 1
[13:33:40.619] Launching 1 futures (chunks) ...
[13:33:40.619] Chunk #1 of 1 ...
[13:33:40.619]  - Finding globals in 'X' for chunk #1 ...
[13:33:40.619] getGlobalsAndPackages() ...
[13:33:40.619] Searching for globals...
[13:33:40.620] 
[13:33:40.620] Searching for globals ... DONE
[13:33:40.620] - globals: [0] <none>
[13:33:40.620] getGlobalsAndPackages() ... DONE
[13:33:40.620]    + additional globals found: [n=0] 
[13:33:40.620]    + additional namespaces needed: [n=0] 
[13:33:40.620]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:40.620]  - seeds: <none>
[13:33:40.620]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.621] getGlobalsAndPackages() ...
[13:33:40.621] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.621] Resolving globals: FALSE
[13:33:40.621] Tweak future expression to call with '...' arguments ...
[13:33:40.621] {
[13:33:40.621]     do.call(function(...) {
[13:33:40.621]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.621]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:40.621]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.621]             on.exit(options(oopts), add = TRUE)
[13:33:40.621]         }
[13:33:40.621]         {
[13:33:40.621]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:40.621]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.621]                 ...future.FUN(...future.X_jj, ...)
[13:33:40.621]             })
[13:33:40.621]         }
[13:33:40.621]     }, args = future.call.arguments)
[13:33:40.621] }
[13:33:40.621] Tweak future expression to call with '...' arguments ... DONE
[13:33:40.622] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.622] 
[13:33:40.622] getGlobalsAndPackages() ... DONE
[13:33:40.622] run() for ‘Future’ ...
[13:33:40.623] - state: ‘created’
[13:33:40.623] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:33:40.623] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:40.623] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:40.623]   - Field: ‘label’
[13:33:40.623]   - Field: ‘local’
[13:33:40.625]   - Field: ‘owner’
[13:33:40.625]   - Field: ‘envir’
[13:33:40.625]   - Field: ‘packages’
[13:33:40.626]   - Field: ‘gc’
[13:33:40.626]   - Field: ‘conditions’
[13:33:40.626]   - Field: ‘expr’
[13:33:40.626]   - Field: ‘uuid’
[13:33:40.626]   - Field: ‘seed’
[13:33:40.626]   - Field: ‘version’
[13:33:40.626]   - Field: ‘result’
[13:33:40.626]   - Field: ‘asynchronous’
[13:33:40.626]   - Field: ‘calls’
[13:33:40.626]   - Field: ‘globals’
[13:33:40.627]   - Field: ‘stdout’
[13:33:40.627]   - Field: ‘earlySignal’
[13:33:40.627]   - Field: ‘lazy’
[13:33:40.627]   - Field: ‘state’
[13:33:40.627] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:40.627] - Launch lazy future ...
[13:33:40.628] Packages needed by the future expression (n = 0): <none>
[13:33:40.628] Packages needed by future strategies (n = 0): <none>
[13:33:40.629] {
[13:33:40.629]     {
[13:33:40.629]         {
[13:33:40.629]             ...future.startTime <- base::Sys.time()
[13:33:40.629]             {
[13:33:40.629]                 {
[13:33:40.629]                   {
[13:33:40.629]                     base::local({
[13:33:40.629]                       has_future <- base::requireNamespace("future", 
[13:33:40.629]                         quietly = TRUE)
[13:33:40.629]                       if (has_future) {
[13:33:40.629]                         ns <- base::getNamespace("future")
[13:33:40.629]                         version <- ns[[".package"]][["version"]]
[13:33:40.629]                         if (is.null(version)) 
[13:33:40.629]                           version <- utils::packageVersion("future")
[13:33:40.629]                       }
[13:33:40.629]                       else {
[13:33:40.629]                         version <- NULL
[13:33:40.629]                       }
[13:33:40.629]                       if (!has_future || version < "1.8.0") {
[13:33:40.629]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:40.629]                           "", base::R.version$version.string), 
[13:33:40.629]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:40.629]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:40.629]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:40.629]                             "release", "version")], collapse = " "), 
[13:33:40.629]                           hostname = base::Sys.info()[["nodename"]])
[13:33:40.629]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:40.629]                           info)
[13:33:40.629]                         info <- base::paste(info, collapse = "; ")
[13:33:40.629]                         if (!has_future) {
[13:33:40.629]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:40.629]                             info)
[13:33:40.629]                         }
[13:33:40.629]                         else {
[13:33:40.629]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:40.629]                             info, version)
[13:33:40.629]                         }
[13:33:40.629]                         base::stop(msg)
[13:33:40.629]                       }
[13:33:40.629]                     })
[13:33:40.629]                   }
[13:33:40.629]                   ...future.strategy.old <- future::plan("list")
[13:33:40.629]                   options(future.plan = NULL)
[13:33:40.629]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:40.629]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:40.629]                 }
[13:33:40.629]                 ...future.workdir <- getwd()
[13:33:40.629]             }
[13:33:40.629]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:40.629]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:40.629]         }
[13:33:40.629]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:40.629]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:40.629]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:40.629]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:40.629]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:40.629]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:40.629]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:40.629]             base::names(...future.oldOptions))
[13:33:40.629]     }
[13:33:40.629]     if (FALSE) {
[13:33:40.629]     }
[13:33:40.629]     else {
[13:33:40.629]         if (TRUE) {
[13:33:40.629]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:40.629]                 open = "w")
[13:33:40.629]         }
[13:33:40.629]         else {
[13:33:40.629]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:40.629]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:40.629]         }
[13:33:40.629]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:40.629]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:40.629]             base::sink(type = "output", split = FALSE)
[13:33:40.629]             base::close(...future.stdout)
[13:33:40.629]         }, add = TRUE)
[13:33:40.629]     }
[13:33:40.629]     ...future.frame <- base::sys.nframe()
[13:33:40.629]     ...future.conditions <- base::list()
[13:33:40.629]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:40.629]     if (FALSE) {
[13:33:40.629]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:40.629]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:40.629]     }
[13:33:40.629]     ...future.result <- base::tryCatch({
[13:33:40.629]         base::withCallingHandlers({
[13:33:40.629]             ...future.value <- base::withVisible(base::local({
[13:33:40.629]                 do.call(function(...) {
[13:33:40.629]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.629]                   if (!identical(...future.globals.maxSize.org, 
[13:33:40.629]                     ...future.globals.maxSize)) {
[13:33:40.629]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.629]                     on.exit(options(oopts), add = TRUE)
[13:33:40.629]                   }
[13:33:40.629]                   {
[13:33:40.629]                     lapply(seq_along(...future.elements_ii), 
[13:33:40.629]                       FUN = function(jj) {
[13:33:40.629]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.629]                         ...future.FUN(...future.X_jj, ...)
[13:33:40.629]                       })
[13:33:40.629]                   }
[13:33:40.629]                 }, args = future.call.arguments)
[13:33:40.629]             }))
[13:33:40.629]             future::FutureResult(value = ...future.value$value, 
[13:33:40.629]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:40.629]                   ...future.rng), globalenv = if (FALSE) 
[13:33:40.629]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:40.629]                     ...future.globalenv.names))
[13:33:40.629]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:40.629]         }, condition = base::local({
[13:33:40.629]             c <- base::c
[13:33:40.629]             inherits <- base::inherits
[13:33:40.629]             invokeRestart <- base::invokeRestart
[13:33:40.629]             length <- base::length
[13:33:40.629]             list <- base::list
[13:33:40.629]             seq.int <- base::seq.int
[13:33:40.629]             signalCondition <- base::signalCondition
[13:33:40.629]             sys.calls <- base::sys.calls
[13:33:40.629]             `[[` <- base::`[[`
[13:33:40.629]             `+` <- base::`+`
[13:33:40.629]             `<<-` <- base::`<<-`
[13:33:40.629]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:40.629]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:40.629]                   3L)]
[13:33:40.629]             }
[13:33:40.629]             function(cond) {
[13:33:40.629]                 is_error <- inherits(cond, "error")
[13:33:40.629]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:40.629]                   NULL)
[13:33:40.629]                 if (is_error) {
[13:33:40.629]                   sessionInformation <- function() {
[13:33:40.629]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:40.629]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:40.629]                       search = base::search(), system = base::Sys.info())
[13:33:40.629]                   }
[13:33:40.629]                   ...future.conditions[[length(...future.conditions) + 
[13:33:40.629]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:40.629]                     cond$call), session = sessionInformation(), 
[13:33:40.629]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:40.629]                   signalCondition(cond)
[13:33:40.629]                 }
[13:33:40.629]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:40.629]                 "immediateCondition"))) {
[13:33:40.629]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:40.629]                   ...future.conditions[[length(...future.conditions) + 
[13:33:40.629]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:40.629]                   if (TRUE && !signal) {
[13:33:40.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:40.629]                     {
[13:33:40.629]                       inherits <- base::inherits
[13:33:40.629]                       invokeRestart <- base::invokeRestart
[13:33:40.629]                       is.null <- base::is.null
[13:33:40.629]                       muffled <- FALSE
[13:33:40.629]                       if (inherits(cond, "message")) {
[13:33:40.629]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:40.629]                         if (muffled) 
[13:33:40.629]                           invokeRestart("muffleMessage")
[13:33:40.629]                       }
[13:33:40.629]                       else if (inherits(cond, "warning")) {
[13:33:40.629]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:40.629]                         if (muffled) 
[13:33:40.629]                           invokeRestart("muffleWarning")
[13:33:40.629]                       }
[13:33:40.629]                       else if (inherits(cond, "condition")) {
[13:33:40.629]                         if (!is.null(pattern)) {
[13:33:40.629]                           computeRestarts <- base::computeRestarts
[13:33:40.629]                           grepl <- base::grepl
[13:33:40.629]                           restarts <- computeRestarts(cond)
[13:33:40.629]                           for (restart in restarts) {
[13:33:40.629]                             name <- restart$name
[13:33:40.629]                             if (is.null(name)) 
[13:33:40.629]                               next
[13:33:40.629]                             if (!grepl(pattern, name)) 
[13:33:40.629]                               next
[13:33:40.629]                             invokeRestart(restart)
[13:33:40.629]                             muffled <- TRUE
[13:33:40.629]                             break
[13:33:40.629]                           }
[13:33:40.629]                         }
[13:33:40.629]                       }
[13:33:40.629]                       invisible(muffled)
[13:33:40.629]                     }
[13:33:40.629]                     muffleCondition(cond, pattern = "^muffle")
[13:33:40.629]                   }
[13:33:40.629]                 }
[13:33:40.629]                 else {
[13:33:40.629]                   if (TRUE) {
[13:33:40.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:40.629]                     {
[13:33:40.629]                       inherits <- base::inherits
[13:33:40.629]                       invokeRestart <- base::invokeRestart
[13:33:40.629]                       is.null <- base::is.null
[13:33:40.629]                       muffled <- FALSE
[13:33:40.629]                       if (inherits(cond, "message")) {
[13:33:40.629]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:40.629]                         if (muffled) 
[13:33:40.629]                           invokeRestart("muffleMessage")
[13:33:40.629]                       }
[13:33:40.629]                       else if (inherits(cond, "warning")) {
[13:33:40.629]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:40.629]                         if (muffled) 
[13:33:40.629]                           invokeRestart("muffleWarning")
[13:33:40.629]                       }
[13:33:40.629]                       else if (inherits(cond, "condition")) {
[13:33:40.629]                         if (!is.null(pattern)) {
[13:33:40.629]                           computeRestarts <- base::computeRestarts
[13:33:40.629]                           grepl <- base::grepl
[13:33:40.629]                           restarts <- computeRestarts(cond)
[13:33:40.629]                           for (restart in restarts) {
[13:33:40.629]                             name <- restart$name
[13:33:40.629]                             if (is.null(name)) 
[13:33:40.629]                               next
[13:33:40.629]                             if (!grepl(pattern, name)) 
[13:33:40.629]                               next
[13:33:40.629]                             invokeRestart(restart)
[13:33:40.629]                             muffled <- TRUE
[13:33:40.629]                             break
[13:33:40.629]                           }
[13:33:40.629]                         }
[13:33:40.629]                       }
[13:33:40.629]                       invisible(muffled)
[13:33:40.629]                     }
[13:33:40.629]                     muffleCondition(cond, pattern = "^muffle")
[13:33:40.629]                   }
[13:33:40.629]                 }
[13:33:40.629]             }
[13:33:40.629]         }))
[13:33:40.629]     }, error = function(ex) {
[13:33:40.629]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:40.629]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:40.629]                 ...future.rng), started = ...future.startTime, 
[13:33:40.629]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:40.629]             version = "1.8"), class = "FutureResult")
[13:33:40.629]     }, finally = {
[13:33:40.629]         if (!identical(...future.workdir, getwd())) 
[13:33:40.629]             setwd(...future.workdir)
[13:33:40.629]         {
[13:33:40.629]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:40.629]                 ...future.oldOptions$nwarnings <- NULL
[13:33:40.629]             }
[13:33:40.629]             base::options(...future.oldOptions)
[13:33:40.629]             if (.Platform$OS.type == "windows") {
[13:33:40.629]                 old_names <- names(...future.oldEnvVars)
[13:33:40.629]                 envs <- base::Sys.getenv()
[13:33:40.629]                 names <- names(envs)
[13:33:40.629]                 common <- intersect(names, old_names)
[13:33:40.629]                 added <- setdiff(names, old_names)
[13:33:40.629]                 removed <- setdiff(old_names, names)
[13:33:40.629]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:40.629]                   envs[common]]
[13:33:40.629]                 NAMES <- toupper(changed)
[13:33:40.629]                 args <- list()
[13:33:40.629]                 for (kk in seq_along(NAMES)) {
[13:33:40.629]                   name <- changed[[kk]]
[13:33:40.629]                   NAME <- NAMES[[kk]]
[13:33:40.629]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.629]                     next
[13:33:40.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:40.629]                 }
[13:33:40.629]                 NAMES <- toupper(added)
[13:33:40.629]                 for (kk in seq_along(NAMES)) {
[13:33:40.629]                   name <- added[[kk]]
[13:33:40.629]                   NAME <- NAMES[[kk]]
[13:33:40.629]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.629]                     next
[13:33:40.629]                   args[[name]] <- ""
[13:33:40.629]                 }
[13:33:40.629]                 NAMES <- toupper(removed)
[13:33:40.629]                 for (kk in seq_along(NAMES)) {
[13:33:40.629]                   name <- removed[[kk]]
[13:33:40.629]                   NAME <- NAMES[[kk]]
[13:33:40.629]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.629]                     next
[13:33:40.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:40.629]                 }
[13:33:40.629]                 if (length(args) > 0) 
[13:33:40.629]                   base::do.call(base::Sys.setenv, args = args)
[13:33:40.629]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:40.629]             }
[13:33:40.629]             else {
[13:33:40.629]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:40.629]             }
[13:33:40.629]             {
[13:33:40.629]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:40.629]                   0L) {
[13:33:40.629]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:40.629]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:40.629]                   base::options(opts)
[13:33:40.629]                 }
[13:33:40.629]                 {
[13:33:40.629]                   {
[13:33:40.629]                     NULL
[13:33:40.629]                     RNGkind("Mersenne-Twister")
[13:33:40.629]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:40.629]                       inherits = FALSE)
[13:33:40.629]                   }
[13:33:40.629]                   options(future.plan = NULL)
[13:33:40.629]                   if (is.na(NA_character_)) 
[13:33:40.629]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:40.629]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:40.629]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:40.629]                     .init = FALSE)
[13:33:40.629]                 }
[13:33:40.629]             }
[13:33:40.629]         }
[13:33:40.629]     })
[13:33:40.629]     if (TRUE) {
[13:33:40.629]         base::sink(type = "output", split = FALSE)
[13:33:40.629]         if (TRUE) {
[13:33:40.629]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:40.629]         }
[13:33:40.629]         else {
[13:33:40.629]             ...future.result["stdout"] <- base::list(NULL)
[13:33:40.629]         }
[13:33:40.629]         base::close(...future.stdout)
[13:33:40.629]         ...future.stdout <- NULL
[13:33:40.629]     }
[13:33:40.629]     ...future.result$conditions <- ...future.conditions
[13:33:40.629]     ...future.result$finished <- base::Sys.time()
[13:33:40.629]     ...future.result
[13:33:40.629] }
[13:33:40.631] assign_globals() ...
[13:33:40.631] List of 5
[13:33:40.631]  $ ...future.FUN            :function (object, ...)  
[13:33:40.631]  $ future.call.arguments    : list()
[13:33:40.631]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.631]  $ ...future.elements_ii    :List of 3
[13:33:40.631]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:33:40.631]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:33:40.631]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:40.631]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:33:40.631]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:33:40.631]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:40.631]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:33:40.631]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:33:40.631]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:40.631]  $ ...future.seeds_ii       : NULL
[13:33:40.631]  $ ...future.globals.maxSize: NULL
[13:33:40.631]  - attr(*, "where")=List of 5
[13:33:40.631]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:40.631]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:40.631]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:40.631]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:40.631]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:40.631]  - attr(*, "resolved")= logi FALSE
[13:33:40.631]  - attr(*, "total_size")= num 1240
[13:33:40.631]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.631]  - attr(*, "already-done")= logi TRUE
[13:33:40.638] - copied ‘...future.FUN’ to environment
[13:33:40.638] - copied ‘future.call.arguments’ to environment
[13:33:40.638] - copied ‘...future.elements_ii’ to environment
[13:33:40.638] - copied ‘...future.seeds_ii’ to environment
[13:33:40.638] - copied ‘...future.globals.maxSize’ to environment
[13:33:40.638] assign_globals() ... done
[13:33:40.639] plan(): Setting new future strategy stack:
[13:33:40.639] List of future strategies:
[13:33:40.639] 1. sequential:
[13:33:40.639]    - args: function (..., envir = parent.frame())
[13:33:40.639]    - tweaked: FALSE
[13:33:40.639]    - call: NULL
[13:33:40.639] plan(): nbrOfWorkers() = 1
[13:33:40.641] plan(): Setting new future strategy stack:
[13:33:40.641] List of future strategies:
[13:33:40.641] 1. sequential:
[13:33:40.641]    - args: function (..., envir = parent.frame())
[13:33:40.641]    - tweaked: FALSE
[13:33:40.641]    - call: plan(strategy)
[13:33:40.642] plan(): nbrOfWorkers() = 1
[13:33:40.642] SequentialFuture started (and completed)
[13:33:40.642] - Launch lazy future ... done
[13:33:40.642] run() for ‘SequentialFuture’ ... done
[13:33:40.643] Created future:
[13:33:40.643] SequentialFuture:
[13:33:40.643] Label: ‘future_by-1’
[13:33:40.643] Expression:
[13:33:40.643] {
[13:33:40.643]     do.call(function(...) {
[13:33:40.643]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.643]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:40.643]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.643]             on.exit(options(oopts), add = TRUE)
[13:33:40.643]         }
[13:33:40.643]         {
[13:33:40.643]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:40.643]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.643]                 ...future.FUN(...future.X_jj, ...)
[13:33:40.643]             })
[13:33:40.643]         }
[13:33:40.643]     }, args = future.call.arguments)
[13:33:40.643] }
[13:33:40.643] Lazy evaluation: FALSE
[13:33:40.643] Asynchronous evaluation: FALSE
[13:33:40.643] Local evaluation: TRUE
[13:33:40.643] Environment: R_GlobalEnv
[13:33:40.643] Capture standard output: TRUE
[13:33:40.643] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:40.643] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:40.643] Packages: <none>
[13:33:40.643] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:40.643] Resolved: TRUE
[13:33:40.643] Value: 4.62 KiB of class ‘list’
[13:33:40.643] Early signaling: FALSE
[13:33:40.643] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:40.643] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:40.644] Chunk #1 of 1 ... DONE
[13:33:40.644] Launching 1 futures (chunks) ... DONE
[13:33:40.644] Resolving 1 futures (chunks) ...
[13:33:40.645] resolve() on list ...
[13:33:40.645]  recursive: 0
[13:33:40.645]  length: 1
[13:33:40.645] 
[13:33:40.645] resolved() for ‘SequentialFuture’ ...
[13:33:40.645] - state: ‘finished’
[13:33:40.645] - run: TRUE
[13:33:40.645] - result: ‘FutureResult’
[13:33:40.645] resolved() for ‘SequentialFuture’ ... done
[13:33:40.645] Future #1
[13:33:40.646] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:40.646] - nx: 1
[13:33:40.646] - relay: TRUE
[13:33:40.646] - stdout: TRUE
[13:33:40.646] - signal: TRUE
[13:33:40.646] - resignal: FALSE
[13:33:40.646] - force: TRUE
[13:33:40.646] - relayed: [n=1] FALSE
[13:33:40.647] - queued futures: [n=1] FALSE
[13:33:40.647]  - until=1
[13:33:40.647]  - relaying element #1
[13:33:40.647] - relayed: [n=1] TRUE
[13:33:40.647] - queued futures: [n=1] TRUE
[13:33:40.647] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:40.647]  length: 0 (resolved future 1)
[13:33:40.647] Relaying remaining futures
[13:33:40.648] signalConditionsASAP(NULL, pos=0) ...
[13:33:40.648] - nx: 1
[13:33:40.648] - relay: TRUE
[13:33:40.648] - stdout: TRUE
[13:33:40.648] - signal: TRUE
[13:33:40.648] - resignal: FALSE
[13:33:40.648] - force: TRUE
[13:33:40.648] - relayed: [n=1] TRUE
[13:33:40.648] - queued futures: [n=1] TRUE
 - flush all
[13:33:40.648] - relayed: [n=1] TRUE
[13:33:40.648] - queued futures: [n=1] TRUE
[13:33:40.649] signalConditionsASAP(NULL, pos=0) ... done
[13:33:40.649] resolve() on list ... DONE
[13:33:40.649]  - Number of value chunks collected: 1
[13:33:40.649] Resolving 1 futures (chunks) ... DONE
[13:33:40.649] Reducing values from 1 chunks ...
[13:33:40.649]  - Number of values collected after concatenation: 3
[13:33:40.649]  - Number of values expected: 3
[13:33:40.649] Reducing values from 1 chunks ... DONE
[13:33:40.651] future_lapply() ... DONE
[13:33:40.651] future_by_internal() ... DONE
[13:33:40.651] future_by_internal() ...
[13:33:40.652] future_lapply() ...
[13:33:40.652] Number of chunks: 1
[13:33:40.652] getGlobalsAndPackagesXApply() ...
[13:33:40.652]  - future.globals: TRUE
[13:33:40.652] getGlobalsAndPackages() ...
[13:33:40.653] Searching for globals...
[13:33:40.654] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:40.654] Searching for globals ... DONE
[13:33:40.654] Resolving globals: FALSE
[13:33:40.654] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:40.654] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:40.655] - globals: [1] ‘FUN’
[13:33:40.655] 
[13:33:40.655] getGlobalsAndPackages() ... DONE
[13:33:40.655]  - globals found/used: [n=1] ‘FUN’
[13:33:40.655]  - needed namespaces: [n=0] 
[13:33:40.655] Finding globals ... DONE
[13:33:40.655]  - use_args: TRUE
[13:33:40.655]  - Getting '...' globals ...
[13:33:40.655] resolve() on list ...
[13:33:40.656]  recursive: 0
[13:33:40.656]  length: 1
[13:33:40.656]  elements: ‘...’
[13:33:40.656]  length: 0 (resolved future 1)
[13:33:40.656] resolve() on list ... DONE
[13:33:40.656]    - '...' content: [n=1] ‘digits’
[13:33:40.656] List of 1
[13:33:40.656]  $ ...:List of 1
[13:33:40.656]   ..$ digits: int 2
[13:33:40.656]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.656]  - attr(*, "where")=List of 1
[13:33:40.656]   ..$ ...:<environment: 0x55cb8182ddd0> 
[13:33:40.656]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.656]  - attr(*, "resolved")= logi TRUE
[13:33:40.656]  - attr(*, "total_size")= num NA
[13:33:40.659]  - Getting '...' globals ... DONE
[13:33:40.659] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:40.659] List of 2
[13:33:40.659]  $ ...future.FUN:function (object, ...)  
[13:33:40.659]  $ ...          :List of 1
[13:33:40.659]   ..$ digits: int 2
[13:33:40.659]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.659]  - attr(*, "where")=List of 2
[13:33:40.659]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:40.659]   ..$ ...          :<environment: 0x55cb8182ddd0> 
[13:33:40.659]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.659]  - attr(*, "resolved")= logi FALSE
[13:33:40.659]  - attr(*, "total_size")= num 1296
[13:33:40.662] Packages to be attached in all futures: [n=0] 
[13:33:40.662] getGlobalsAndPackagesXApply() ... DONE
[13:33:40.662] Number of futures (= number of chunks): 1
[13:33:40.662] Launching 1 futures (chunks) ...
[13:33:40.662] Chunk #1 of 1 ...
[13:33:40.662]  - Finding globals in 'X' for chunk #1 ...
[13:33:40.663] getGlobalsAndPackages() ...
[13:33:40.663] Searching for globals...
[13:33:40.663] 
[13:33:40.663] Searching for globals ... DONE
[13:33:40.663] - globals: [0] <none>
[13:33:40.663] getGlobalsAndPackages() ... DONE
[13:33:40.663]    + additional globals found: [n=0] 
[13:33:40.663]    + additional namespaces needed: [n=0] 
[13:33:40.663]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:40.663]  - seeds: <none>
[13:33:40.664]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.664] getGlobalsAndPackages() ...
[13:33:40.664] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.664] Resolving globals: FALSE
[13:33:40.664] Tweak future expression to call with '...' arguments ...
[13:33:40.664] {
[13:33:40.664]     do.call(function(...) {
[13:33:40.664]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.664]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:40.664]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.664]             on.exit(options(oopts), add = TRUE)
[13:33:40.664]         }
[13:33:40.664]         {
[13:33:40.664]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:40.664]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.664]                 ...future.FUN(...future.X_jj, ...)
[13:33:40.664]             })
[13:33:40.664]         }
[13:33:40.664]     }, args = future.call.arguments)
[13:33:40.664] }
[13:33:40.664] Tweak future expression to call with '...' arguments ... DONE
[13:33:40.665] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.665] 
[13:33:40.665] getGlobalsAndPackages() ... DONE
[13:33:40.665] run() for ‘Future’ ...
[13:33:40.665] - state: ‘created’
[13:33:40.665] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:33:40.666] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:40.666] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:40.666]   - Field: ‘label’
[13:33:40.666]   - Field: ‘local’
[13:33:40.666]   - Field: ‘owner’
[13:33:40.666]   - Field: ‘envir’
[13:33:40.666]   - Field: ‘packages’
[13:33:40.666]   - Field: ‘gc’
[13:33:40.666]   - Field: ‘conditions’
[13:33:40.666]   - Field: ‘expr’
[13:33:40.666]   - Field: ‘uuid’
[13:33:40.667]   - Field: ‘seed’
[13:33:40.667]   - Field: ‘version’
[13:33:40.667]   - Field: ‘result’
[13:33:40.667]   - Field: ‘asynchronous’
[13:33:40.667]   - Field: ‘calls’
[13:33:40.667]   - Field: ‘globals’
[13:33:40.667]   - Field: ‘stdout’
[13:33:40.667]   - Field: ‘earlySignal’
[13:33:40.667]   - Field: ‘lazy’
[13:33:40.667]   - Field: ‘state’
[13:33:40.667] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:40.667] - Launch lazy future ...
[13:33:40.668] Packages needed by the future expression (n = 0): <none>
[13:33:40.668] Packages needed by future strategies (n = 0): <none>
[13:33:40.668] {
[13:33:40.668]     {
[13:33:40.668]         {
[13:33:40.668]             ...future.startTime <- base::Sys.time()
[13:33:40.668]             {
[13:33:40.668]                 {
[13:33:40.668]                   {
[13:33:40.668]                     base::local({
[13:33:40.668]                       has_future <- base::requireNamespace("future", 
[13:33:40.668]                         quietly = TRUE)
[13:33:40.668]                       if (has_future) {
[13:33:40.668]                         ns <- base::getNamespace("future")
[13:33:40.668]                         version <- ns[[".package"]][["version"]]
[13:33:40.668]                         if (is.null(version)) 
[13:33:40.668]                           version <- utils::packageVersion("future")
[13:33:40.668]                       }
[13:33:40.668]                       else {
[13:33:40.668]                         version <- NULL
[13:33:40.668]                       }
[13:33:40.668]                       if (!has_future || version < "1.8.0") {
[13:33:40.668]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:40.668]                           "", base::R.version$version.string), 
[13:33:40.668]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:40.668]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:40.668]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:40.668]                             "release", "version")], collapse = " "), 
[13:33:40.668]                           hostname = base::Sys.info()[["nodename"]])
[13:33:40.668]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:40.668]                           info)
[13:33:40.668]                         info <- base::paste(info, collapse = "; ")
[13:33:40.668]                         if (!has_future) {
[13:33:40.668]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:40.668]                             info)
[13:33:40.668]                         }
[13:33:40.668]                         else {
[13:33:40.668]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:40.668]                             info, version)
[13:33:40.668]                         }
[13:33:40.668]                         base::stop(msg)
[13:33:40.668]                       }
[13:33:40.668]                     })
[13:33:40.668]                   }
[13:33:40.668]                   ...future.strategy.old <- future::plan("list")
[13:33:40.668]                   options(future.plan = NULL)
[13:33:40.668]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:40.668]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:40.668]                 }
[13:33:40.668]                 ...future.workdir <- getwd()
[13:33:40.668]             }
[13:33:40.668]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:40.668]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:40.668]         }
[13:33:40.668]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:40.668]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:40.668]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:40.668]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:40.668]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:40.668]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:40.668]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:40.668]             base::names(...future.oldOptions))
[13:33:40.668]     }
[13:33:40.668]     if (FALSE) {
[13:33:40.668]     }
[13:33:40.668]     else {
[13:33:40.668]         if (TRUE) {
[13:33:40.668]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:40.668]                 open = "w")
[13:33:40.668]         }
[13:33:40.668]         else {
[13:33:40.668]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:40.668]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:40.668]         }
[13:33:40.668]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:40.668]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:40.668]             base::sink(type = "output", split = FALSE)
[13:33:40.668]             base::close(...future.stdout)
[13:33:40.668]         }, add = TRUE)
[13:33:40.668]     }
[13:33:40.668]     ...future.frame <- base::sys.nframe()
[13:33:40.668]     ...future.conditions <- base::list()
[13:33:40.668]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:40.668]     if (FALSE) {
[13:33:40.668]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:40.668]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:40.668]     }
[13:33:40.668]     ...future.result <- base::tryCatch({
[13:33:40.668]         base::withCallingHandlers({
[13:33:40.668]             ...future.value <- base::withVisible(base::local({
[13:33:40.668]                 do.call(function(...) {
[13:33:40.668]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.668]                   if (!identical(...future.globals.maxSize.org, 
[13:33:40.668]                     ...future.globals.maxSize)) {
[13:33:40.668]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.668]                     on.exit(options(oopts), add = TRUE)
[13:33:40.668]                   }
[13:33:40.668]                   {
[13:33:40.668]                     lapply(seq_along(...future.elements_ii), 
[13:33:40.668]                       FUN = function(jj) {
[13:33:40.668]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.668]                         ...future.FUN(...future.X_jj, ...)
[13:33:40.668]                       })
[13:33:40.668]                   }
[13:33:40.668]                 }, args = future.call.arguments)
[13:33:40.668]             }))
[13:33:40.668]             future::FutureResult(value = ...future.value$value, 
[13:33:40.668]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:40.668]                   ...future.rng), globalenv = if (FALSE) 
[13:33:40.668]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:40.668]                     ...future.globalenv.names))
[13:33:40.668]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:40.668]         }, condition = base::local({
[13:33:40.668]             c <- base::c
[13:33:40.668]             inherits <- base::inherits
[13:33:40.668]             invokeRestart <- base::invokeRestart
[13:33:40.668]             length <- base::length
[13:33:40.668]             list <- base::list
[13:33:40.668]             seq.int <- base::seq.int
[13:33:40.668]             signalCondition <- base::signalCondition
[13:33:40.668]             sys.calls <- base::sys.calls
[13:33:40.668]             `[[` <- base::`[[`
[13:33:40.668]             `+` <- base::`+`
[13:33:40.668]             `<<-` <- base::`<<-`
[13:33:40.668]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:40.668]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:40.668]                   3L)]
[13:33:40.668]             }
[13:33:40.668]             function(cond) {
[13:33:40.668]                 is_error <- inherits(cond, "error")
[13:33:40.668]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:40.668]                   NULL)
[13:33:40.668]                 if (is_error) {
[13:33:40.668]                   sessionInformation <- function() {
[13:33:40.668]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:40.668]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:40.668]                       search = base::search(), system = base::Sys.info())
[13:33:40.668]                   }
[13:33:40.668]                   ...future.conditions[[length(...future.conditions) + 
[13:33:40.668]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:40.668]                     cond$call), session = sessionInformation(), 
[13:33:40.668]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:40.668]                   signalCondition(cond)
[13:33:40.668]                 }
[13:33:40.668]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:40.668]                 "immediateCondition"))) {
[13:33:40.668]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:40.668]                   ...future.conditions[[length(...future.conditions) + 
[13:33:40.668]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:40.668]                   if (TRUE && !signal) {
[13:33:40.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:40.668]                     {
[13:33:40.668]                       inherits <- base::inherits
[13:33:40.668]                       invokeRestart <- base::invokeRestart
[13:33:40.668]                       is.null <- base::is.null
[13:33:40.668]                       muffled <- FALSE
[13:33:40.668]                       if (inherits(cond, "message")) {
[13:33:40.668]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:40.668]                         if (muffled) 
[13:33:40.668]                           invokeRestart("muffleMessage")
[13:33:40.668]                       }
[13:33:40.668]                       else if (inherits(cond, "warning")) {
[13:33:40.668]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:40.668]                         if (muffled) 
[13:33:40.668]                           invokeRestart("muffleWarning")
[13:33:40.668]                       }
[13:33:40.668]                       else if (inherits(cond, "condition")) {
[13:33:40.668]                         if (!is.null(pattern)) {
[13:33:40.668]                           computeRestarts <- base::computeRestarts
[13:33:40.668]                           grepl <- base::grepl
[13:33:40.668]                           restarts <- computeRestarts(cond)
[13:33:40.668]                           for (restart in restarts) {
[13:33:40.668]                             name <- restart$name
[13:33:40.668]                             if (is.null(name)) 
[13:33:40.668]                               next
[13:33:40.668]                             if (!grepl(pattern, name)) 
[13:33:40.668]                               next
[13:33:40.668]                             invokeRestart(restart)
[13:33:40.668]                             muffled <- TRUE
[13:33:40.668]                             break
[13:33:40.668]                           }
[13:33:40.668]                         }
[13:33:40.668]                       }
[13:33:40.668]                       invisible(muffled)
[13:33:40.668]                     }
[13:33:40.668]                     muffleCondition(cond, pattern = "^muffle")
[13:33:40.668]                   }
[13:33:40.668]                 }
[13:33:40.668]                 else {
[13:33:40.668]                   if (TRUE) {
[13:33:40.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:40.668]                     {
[13:33:40.668]                       inherits <- base::inherits
[13:33:40.668]                       invokeRestart <- base::invokeRestart
[13:33:40.668]                       is.null <- base::is.null
[13:33:40.668]                       muffled <- FALSE
[13:33:40.668]                       if (inherits(cond, "message")) {
[13:33:40.668]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:40.668]                         if (muffled) 
[13:33:40.668]                           invokeRestart("muffleMessage")
[13:33:40.668]                       }
[13:33:40.668]                       else if (inherits(cond, "warning")) {
[13:33:40.668]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:40.668]                         if (muffled) 
[13:33:40.668]                           invokeRestart("muffleWarning")
[13:33:40.668]                       }
[13:33:40.668]                       else if (inherits(cond, "condition")) {
[13:33:40.668]                         if (!is.null(pattern)) {
[13:33:40.668]                           computeRestarts <- base::computeRestarts
[13:33:40.668]                           grepl <- base::grepl
[13:33:40.668]                           restarts <- computeRestarts(cond)
[13:33:40.668]                           for (restart in restarts) {
[13:33:40.668]                             name <- restart$name
[13:33:40.668]                             if (is.null(name)) 
[13:33:40.668]                               next
[13:33:40.668]                             if (!grepl(pattern, name)) 
[13:33:40.668]                               next
[13:33:40.668]                             invokeRestart(restart)
[13:33:40.668]                             muffled <- TRUE
[13:33:40.668]                             break
[13:33:40.668]                           }
[13:33:40.668]                         }
[13:33:40.668]                       }
[13:33:40.668]                       invisible(muffled)
[13:33:40.668]                     }
[13:33:40.668]                     muffleCondition(cond, pattern = "^muffle")
[13:33:40.668]                   }
[13:33:40.668]                 }
[13:33:40.668]             }
[13:33:40.668]         }))
[13:33:40.668]     }, error = function(ex) {
[13:33:40.668]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:40.668]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:40.668]                 ...future.rng), started = ...future.startTime, 
[13:33:40.668]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:40.668]             version = "1.8"), class = "FutureResult")
[13:33:40.668]     }, finally = {
[13:33:40.668]         if (!identical(...future.workdir, getwd())) 
[13:33:40.668]             setwd(...future.workdir)
[13:33:40.668]         {
[13:33:40.668]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:40.668]                 ...future.oldOptions$nwarnings <- NULL
[13:33:40.668]             }
[13:33:40.668]             base::options(...future.oldOptions)
[13:33:40.668]             if (.Platform$OS.type == "windows") {
[13:33:40.668]                 old_names <- names(...future.oldEnvVars)
[13:33:40.668]                 envs <- base::Sys.getenv()
[13:33:40.668]                 names <- names(envs)
[13:33:40.668]                 common <- intersect(names, old_names)
[13:33:40.668]                 added <- setdiff(names, old_names)
[13:33:40.668]                 removed <- setdiff(old_names, names)
[13:33:40.668]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:40.668]                   envs[common]]
[13:33:40.668]                 NAMES <- toupper(changed)
[13:33:40.668]                 args <- list()
[13:33:40.668]                 for (kk in seq_along(NAMES)) {
[13:33:40.668]                   name <- changed[[kk]]
[13:33:40.668]                   NAME <- NAMES[[kk]]
[13:33:40.668]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.668]                     next
[13:33:40.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:40.668]                 }
[13:33:40.668]                 NAMES <- toupper(added)
[13:33:40.668]                 for (kk in seq_along(NAMES)) {
[13:33:40.668]                   name <- added[[kk]]
[13:33:40.668]                   NAME <- NAMES[[kk]]
[13:33:40.668]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.668]                     next
[13:33:40.668]                   args[[name]] <- ""
[13:33:40.668]                 }
[13:33:40.668]                 NAMES <- toupper(removed)
[13:33:40.668]                 for (kk in seq_along(NAMES)) {
[13:33:40.668]                   name <- removed[[kk]]
[13:33:40.668]                   NAME <- NAMES[[kk]]
[13:33:40.668]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.668]                     next
[13:33:40.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:40.668]                 }
[13:33:40.668]                 if (length(args) > 0) 
[13:33:40.668]                   base::do.call(base::Sys.setenv, args = args)
[13:33:40.668]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:40.668]             }
[13:33:40.668]             else {
[13:33:40.668]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:40.668]             }
[13:33:40.668]             {
[13:33:40.668]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:40.668]                   0L) {
[13:33:40.668]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:40.668]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:40.668]                   base::options(opts)
[13:33:40.668]                 }
[13:33:40.668]                 {
[13:33:40.668]                   {
[13:33:40.668]                     NULL
[13:33:40.668]                     RNGkind("Mersenne-Twister")
[13:33:40.668]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:40.668]                       inherits = FALSE)
[13:33:40.668]                   }
[13:33:40.668]                   options(future.plan = NULL)
[13:33:40.668]                   if (is.na(NA_character_)) 
[13:33:40.668]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:40.668]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:40.668]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:40.668]                     .init = FALSE)
[13:33:40.668]                 }
[13:33:40.668]             }
[13:33:40.668]         }
[13:33:40.668]     })
[13:33:40.668]     if (TRUE) {
[13:33:40.668]         base::sink(type = "output", split = FALSE)
[13:33:40.668]         if (TRUE) {
[13:33:40.668]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:40.668]         }
[13:33:40.668]         else {
[13:33:40.668]             ...future.result["stdout"] <- base::list(NULL)
[13:33:40.668]         }
[13:33:40.668]         base::close(...future.stdout)
[13:33:40.668]         ...future.stdout <- NULL
[13:33:40.668]     }
[13:33:40.668]     ...future.result$conditions <- ...future.conditions
[13:33:40.668]     ...future.result$finished <- base::Sys.time()
[13:33:40.668]     ...future.result
[13:33:40.668] }
[13:33:40.670] assign_globals() ...
[13:33:40.670] List of 5
[13:33:40.670]  $ ...future.FUN            :function (object, ...)  
[13:33:40.670]  $ future.call.arguments    :List of 1
[13:33:40.670]   ..$ digits: int 2
[13:33:40.670]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.670]  $ ...future.elements_ii    :List of 6
[13:33:40.670]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[13:33:40.670]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[13:33:40.670]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[13:33:40.670]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[13:33:40.670]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[13:33:40.670]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[13:33:40.670]  $ ...future.seeds_ii       : NULL
[13:33:40.670]  $ ...future.globals.maxSize: NULL
[13:33:40.670]  - attr(*, "where")=List of 5
[13:33:40.670]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:40.670]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:40.670]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:40.670]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:40.670]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:40.670]  - attr(*, "resolved")= logi FALSE
[13:33:40.670]  - attr(*, "total_size")= num 1296
[13:33:40.670]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.670]  - attr(*, "already-done")= logi TRUE
[13:33:40.677] - copied ‘...future.FUN’ to environment
[13:33:40.677] - copied ‘future.call.arguments’ to environment
[13:33:40.677] - copied ‘...future.elements_ii’ to environment
[13:33:40.677] - copied ‘...future.seeds_ii’ to environment
[13:33:40.677] - copied ‘...future.globals.maxSize’ to environment
[13:33:40.677] assign_globals() ... done
[13:33:40.677] plan(): Setting new future strategy stack:
[13:33:40.678] List of future strategies:
[13:33:40.678] 1. sequential:
[13:33:40.678]    - args: function (..., envir = parent.frame())
[13:33:40.678]    - tweaked: FALSE
[13:33:40.678]    - call: NULL
[13:33:40.678] plan(): nbrOfWorkers() = 1
[13:33:40.679] plan(): Setting new future strategy stack:
[13:33:40.679] List of future strategies:
[13:33:40.679] 1. sequential:
[13:33:40.679]    - args: function (..., envir = parent.frame())
[13:33:40.679]    - tweaked: FALSE
[13:33:40.679]    - call: plan(strategy)
[13:33:40.680] plan(): nbrOfWorkers() = 1
[13:33:40.680] SequentialFuture started (and completed)
[13:33:40.680] - Launch lazy future ... done
[13:33:40.680] run() for ‘SequentialFuture’ ... done
[13:33:40.680] Created future:
[13:33:40.680] SequentialFuture:
[13:33:40.680] Label: ‘future_by-1’
[13:33:40.680] Expression:
[13:33:40.680] {
[13:33:40.680]     do.call(function(...) {
[13:33:40.680]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.680]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:40.680]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.680]             on.exit(options(oopts), add = TRUE)
[13:33:40.680]         }
[13:33:40.680]         {
[13:33:40.680]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:40.680]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.680]                 ...future.FUN(...future.X_jj, ...)
[13:33:40.680]             })
[13:33:40.680]         }
[13:33:40.680]     }, args = future.call.arguments)
[13:33:40.680] }
[13:33:40.680] Lazy evaluation: FALSE
[13:33:40.680] Asynchronous evaluation: FALSE
[13:33:40.680] Local evaluation: TRUE
[13:33:40.680] Environment: R_GlobalEnv
[13:33:40.680] Capture standard output: TRUE
[13:33:40.680] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:40.680] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:40.680] Packages: <none>
[13:33:40.680] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:40.680] Resolved: TRUE
[13:33:40.680] Value: 5.48 KiB of class ‘list’
[13:33:40.680] Early signaling: FALSE
[13:33:40.680] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:40.680] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:40.681] Chunk #1 of 1 ... DONE
[13:33:40.681] Launching 1 futures (chunks) ... DONE
[13:33:40.681] Resolving 1 futures (chunks) ...
[13:33:40.681] resolve() on list ...
[13:33:40.681]  recursive: 0
[13:33:40.681]  length: 1
[13:33:40.682] 
[13:33:40.682] resolved() for ‘SequentialFuture’ ...
[13:33:40.682] - state: ‘finished’
[13:33:40.682] - run: TRUE
[13:33:40.682] - result: ‘FutureResult’
[13:33:40.682] resolved() for ‘SequentialFuture’ ... done
[13:33:40.682] Future #1
[13:33:40.682] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:40.682] - nx: 1
[13:33:40.682] - relay: TRUE
[13:33:40.682] - stdout: TRUE
[13:33:40.683] - signal: TRUE
[13:33:40.683] - resignal: FALSE
[13:33:40.683] - force: TRUE
[13:33:40.683] - relayed: [n=1] FALSE
[13:33:40.683] - queued futures: [n=1] FALSE
[13:33:40.683]  - until=1
[13:33:40.683]  - relaying element #1
[13:33:40.683] - relayed: [n=1] TRUE
[13:33:40.683] - queued futures: [n=1] TRUE
[13:33:40.683] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:40.684]  length: 0 (resolved future 1)
[13:33:40.684] Relaying remaining futures
[13:33:40.684] signalConditionsASAP(NULL, pos=0) ...
[13:33:40.684] - nx: 1
[13:33:40.684] - relay: TRUE
[13:33:40.684] - stdout: TRUE
[13:33:40.684] - signal: TRUE
[13:33:40.684] - resignal: FALSE
[13:33:40.684] - force: TRUE
[13:33:40.684] - relayed: [n=1] TRUE
[13:33:40.684] - queued futures: [n=1] TRUE
 - flush all
[13:33:40.684] - relayed: [n=1] TRUE
[13:33:40.684] - queued futures: [n=1] TRUE
[13:33:40.685] signalConditionsASAP(NULL, pos=0) ... done
[13:33:40.685] resolve() on list ... DONE
[13:33:40.685]  - Number of value chunks collected: 1
[13:33:40.685] Resolving 1 futures (chunks) ... DONE
[13:33:40.685] Reducing values from 1 chunks ...
[13:33:40.685]  - Number of values collected after concatenation: 6
[13:33:40.685]  - Number of values expected: 6
[13:33:40.685] Reducing values from 1 chunks ... DONE
[13:33:40.685] future_lapply() ... DONE
[13:33:40.685] future_by_internal() ... DONE
[13:33:40.688] future_by_internal() ...
[13:33:40.689] future_lapply() ...
[13:33:40.689] Number of chunks: 1
[13:33:40.690] getGlobalsAndPackagesXApply() ...
[13:33:40.690]  - future.globals: TRUE
[13:33:40.690] getGlobalsAndPackages() ...
[13:33:40.691] Searching for globals...
[13:33:40.692] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:33:40.692] Searching for globals ... DONE
[13:33:40.692] Resolving globals: FALSE
[13:33:40.693] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[13:33:40.693] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[13:33:40.693] - globals: [1] ‘FUN’
[13:33:40.693] - packages: [1] ‘stats’
[13:33:40.693] getGlobalsAndPackages() ... DONE
[13:33:40.693]  - globals found/used: [n=1] ‘FUN’
[13:33:40.693]  - needed namespaces: [n=1] ‘stats’
[13:33:40.694] Finding globals ... DONE
[13:33:40.694]  - use_args: TRUE
[13:33:40.694]  - Getting '...' globals ...
[13:33:40.694] resolve() on list ...
[13:33:40.694]  recursive: 0
[13:33:40.694]  length: 1
[13:33:40.694]  elements: ‘...’
[13:33:40.694]  length: 0 (resolved future 1)
[13:33:40.694] resolve() on list ... DONE
[13:33:40.695]    - '...' content: [n=1] ‘singular.ok’
[13:33:40.695] List of 1
[13:33:40.695]  $ ...:List of 1
[13:33:40.695]   ..$ singular.ok: logi FALSE
[13:33:40.695]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.695]  - attr(*, "where")=List of 1
[13:33:40.695]   ..$ ...:<environment: 0x55cb82918fb8> 
[13:33:40.695]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.695]  - attr(*, "resolved")= logi TRUE
[13:33:40.695]  - attr(*, "total_size")= num NA
[13:33:40.697]  - Getting '...' globals ... DONE
[13:33:40.697] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:40.698] List of 2
[13:33:40.698]  $ ...future.FUN:function (x, ...)  
[13:33:40.698]  $ ...          :List of 1
[13:33:40.698]   ..$ singular.ok: logi FALSE
[13:33:40.698]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.698]  - attr(*, "where")=List of 2
[13:33:40.698]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:40.698]   ..$ ...          :<environment: 0x55cb82918fb8> 
[13:33:40.698]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.698]  - attr(*, "resolved")= logi FALSE
[13:33:40.698]  - attr(*, "total_size")= num 5384
[13:33:40.700] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:40.700] getGlobalsAndPackagesXApply() ... DONE
[13:33:40.701] Number of futures (= number of chunks): 1
[13:33:40.701] Launching 1 futures (chunks) ...
[13:33:40.701] Chunk #1 of 1 ...
[13:33:40.701]  - Finding globals in 'X' for chunk #1 ...
[13:33:40.701] getGlobalsAndPackages() ...
[13:33:40.701] Searching for globals...
[13:33:40.702] 
[13:33:40.702] Searching for globals ... DONE
[13:33:40.702] - globals: [0] <none>
[13:33:40.702] getGlobalsAndPackages() ... DONE
[13:33:40.702]    + additional globals found: [n=0] 
[13:33:40.702]    + additional namespaces needed: [n=0] 
[13:33:40.702]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:40.702]  - seeds: <none>
[13:33:40.702]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.702] getGlobalsAndPackages() ...
[13:33:40.702] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.703] Resolving globals: FALSE
[13:33:40.703] Tweak future expression to call with '...' arguments ...
[13:33:40.703] {
[13:33:40.703]     do.call(function(...) {
[13:33:40.703]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.703]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:40.703]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.703]             on.exit(options(oopts), add = TRUE)
[13:33:40.703]         }
[13:33:40.703]         {
[13:33:40.703]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:40.703]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.703]                 ...future.FUN(...future.X_jj, ...)
[13:33:40.703]             })
[13:33:40.703]         }
[13:33:40.703]     }, args = future.call.arguments)
[13:33:40.703] }
[13:33:40.703] Tweak future expression to call with '...' arguments ... DONE
[13:33:40.703] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.703] 
[13:33:40.703] getGlobalsAndPackages() ... DONE
[13:33:40.704] run() for ‘Future’ ...
[13:33:40.704] - state: ‘created’
[13:33:40.704] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:33:40.704] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:40.704] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:40.704]   - Field: ‘label’
[13:33:40.704]   - Field: ‘local’
[13:33:40.705]   - Field: ‘owner’
[13:33:40.705]   - Field: ‘envir’
[13:33:40.705]   - Field: ‘packages’
[13:33:40.705]   - Field: ‘gc’
[13:33:40.705]   - Field: ‘conditions’
[13:33:40.705]   - Field: ‘expr’
[13:33:40.705]   - Field: ‘uuid’
[13:33:40.705]   - Field: ‘seed’
[13:33:40.705]   - Field: ‘version’
[13:33:40.705]   - Field: ‘result’
[13:33:40.705]   - Field: ‘asynchronous’
[13:33:40.705]   - Field: ‘calls’
[13:33:40.706]   - Field: ‘globals’
[13:33:40.706]   - Field: ‘stdout’
[13:33:40.706]   - Field: ‘earlySignal’
[13:33:40.706]   - Field: ‘lazy’
[13:33:40.706]   - Field: ‘state’
[13:33:40.706] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:40.706] - Launch lazy future ...
[13:33:40.706] Packages needed by the future expression (n = 1): ‘stats’
[13:33:40.706] Packages needed by future strategies (n = 0): <none>
[13:33:40.707] {
[13:33:40.707]     {
[13:33:40.707]         {
[13:33:40.707]             ...future.startTime <- base::Sys.time()
[13:33:40.707]             {
[13:33:40.707]                 {
[13:33:40.707]                   {
[13:33:40.707]                     {
[13:33:40.707]                       base::local({
[13:33:40.707]                         has_future <- base::requireNamespace("future", 
[13:33:40.707]                           quietly = TRUE)
[13:33:40.707]                         if (has_future) {
[13:33:40.707]                           ns <- base::getNamespace("future")
[13:33:40.707]                           version <- ns[[".package"]][["version"]]
[13:33:40.707]                           if (is.null(version)) 
[13:33:40.707]                             version <- utils::packageVersion("future")
[13:33:40.707]                         }
[13:33:40.707]                         else {
[13:33:40.707]                           version <- NULL
[13:33:40.707]                         }
[13:33:40.707]                         if (!has_future || version < "1.8.0") {
[13:33:40.707]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:40.707]                             "", base::R.version$version.string), 
[13:33:40.707]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:40.707]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:40.707]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:40.707]                               "release", "version")], collapse = " "), 
[13:33:40.707]                             hostname = base::Sys.info()[["nodename"]])
[13:33:40.707]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:40.707]                             info)
[13:33:40.707]                           info <- base::paste(info, collapse = "; ")
[13:33:40.707]                           if (!has_future) {
[13:33:40.707]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:40.707]                               info)
[13:33:40.707]                           }
[13:33:40.707]                           else {
[13:33:40.707]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:40.707]                               info, version)
[13:33:40.707]                           }
[13:33:40.707]                           base::stop(msg)
[13:33:40.707]                         }
[13:33:40.707]                       })
[13:33:40.707]                     }
[13:33:40.707]                     base::local({
[13:33:40.707]                       for (pkg in "stats") {
[13:33:40.707]                         base::loadNamespace(pkg)
[13:33:40.707]                         base::library(pkg, character.only = TRUE)
[13:33:40.707]                       }
[13:33:40.707]                     })
[13:33:40.707]                   }
[13:33:40.707]                   ...future.strategy.old <- future::plan("list")
[13:33:40.707]                   options(future.plan = NULL)
[13:33:40.707]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:40.707]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:40.707]                 }
[13:33:40.707]                 ...future.workdir <- getwd()
[13:33:40.707]             }
[13:33:40.707]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:40.707]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:40.707]         }
[13:33:40.707]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:40.707]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:40.707]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:40.707]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:40.707]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:40.707]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:40.707]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:40.707]             base::names(...future.oldOptions))
[13:33:40.707]     }
[13:33:40.707]     if (FALSE) {
[13:33:40.707]     }
[13:33:40.707]     else {
[13:33:40.707]         if (TRUE) {
[13:33:40.707]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:40.707]                 open = "w")
[13:33:40.707]         }
[13:33:40.707]         else {
[13:33:40.707]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:40.707]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:40.707]         }
[13:33:40.707]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:40.707]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:40.707]             base::sink(type = "output", split = FALSE)
[13:33:40.707]             base::close(...future.stdout)
[13:33:40.707]         }, add = TRUE)
[13:33:40.707]     }
[13:33:40.707]     ...future.frame <- base::sys.nframe()
[13:33:40.707]     ...future.conditions <- base::list()
[13:33:40.707]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:40.707]     if (FALSE) {
[13:33:40.707]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:40.707]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:40.707]     }
[13:33:40.707]     ...future.result <- base::tryCatch({
[13:33:40.707]         base::withCallingHandlers({
[13:33:40.707]             ...future.value <- base::withVisible(base::local({
[13:33:40.707]                 do.call(function(...) {
[13:33:40.707]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.707]                   if (!identical(...future.globals.maxSize.org, 
[13:33:40.707]                     ...future.globals.maxSize)) {
[13:33:40.707]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.707]                     on.exit(options(oopts), add = TRUE)
[13:33:40.707]                   }
[13:33:40.707]                   {
[13:33:40.707]                     lapply(seq_along(...future.elements_ii), 
[13:33:40.707]                       FUN = function(jj) {
[13:33:40.707]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.707]                         ...future.FUN(...future.X_jj, ...)
[13:33:40.707]                       })
[13:33:40.707]                   }
[13:33:40.707]                 }, args = future.call.arguments)
[13:33:40.707]             }))
[13:33:40.707]             future::FutureResult(value = ...future.value$value, 
[13:33:40.707]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:40.707]                   ...future.rng), globalenv = if (FALSE) 
[13:33:40.707]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:40.707]                     ...future.globalenv.names))
[13:33:40.707]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:40.707]         }, condition = base::local({
[13:33:40.707]             c <- base::c
[13:33:40.707]             inherits <- base::inherits
[13:33:40.707]             invokeRestart <- base::invokeRestart
[13:33:40.707]             length <- base::length
[13:33:40.707]             list <- base::list
[13:33:40.707]             seq.int <- base::seq.int
[13:33:40.707]             signalCondition <- base::signalCondition
[13:33:40.707]             sys.calls <- base::sys.calls
[13:33:40.707]             `[[` <- base::`[[`
[13:33:40.707]             `+` <- base::`+`
[13:33:40.707]             `<<-` <- base::`<<-`
[13:33:40.707]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:40.707]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:40.707]                   3L)]
[13:33:40.707]             }
[13:33:40.707]             function(cond) {
[13:33:40.707]                 is_error <- inherits(cond, "error")
[13:33:40.707]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:40.707]                   NULL)
[13:33:40.707]                 if (is_error) {
[13:33:40.707]                   sessionInformation <- function() {
[13:33:40.707]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:40.707]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:40.707]                       search = base::search(), system = base::Sys.info())
[13:33:40.707]                   }
[13:33:40.707]                   ...future.conditions[[length(...future.conditions) + 
[13:33:40.707]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:40.707]                     cond$call), session = sessionInformation(), 
[13:33:40.707]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:40.707]                   signalCondition(cond)
[13:33:40.707]                 }
[13:33:40.707]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:40.707]                 "immediateCondition"))) {
[13:33:40.707]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:40.707]                   ...future.conditions[[length(...future.conditions) + 
[13:33:40.707]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:40.707]                   if (TRUE && !signal) {
[13:33:40.707]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:40.707]                     {
[13:33:40.707]                       inherits <- base::inherits
[13:33:40.707]                       invokeRestart <- base::invokeRestart
[13:33:40.707]                       is.null <- base::is.null
[13:33:40.707]                       muffled <- FALSE
[13:33:40.707]                       if (inherits(cond, "message")) {
[13:33:40.707]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:40.707]                         if (muffled) 
[13:33:40.707]                           invokeRestart("muffleMessage")
[13:33:40.707]                       }
[13:33:40.707]                       else if (inherits(cond, "warning")) {
[13:33:40.707]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:40.707]                         if (muffled) 
[13:33:40.707]                           invokeRestart("muffleWarning")
[13:33:40.707]                       }
[13:33:40.707]                       else if (inherits(cond, "condition")) {
[13:33:40.707]                         if (!is.null(pattern)) {
[13:33:40.707]                           computeRestarts <- base::computeRestarts
[13:33:40.707]                           grepl <- base::grepl
[13:33:40.707]                           restarts <- computeRestarts(cond)
[13:33:40.707]                           for (restart in restarts) {
[13:33:40.707]                             name <- restart$name
[13:33:40.707]                             if (is.null(name)) 
[13:33:40.707]                               next
[13:33:40.707]                             if (!grepl(pattern, name)) 
[13:33:40.707]                               next
[13:33:40.707]                             invokeRestart(restart)
[13:33:40.707]                             muffled <- TRUE
[13:33:40.707]                             break
[13:33:40.707]                           }
[13:33:40.707]                         }
[13:33:40.707]                       }
[13:33:40.707]                       invisible(muffled)
[13:33:40.707]                     }
[13:33:40.707]                     muffleCondition(cond, pattern = "^muffle")
[13:33:40.707]                   }
[13:33:40.707]                 }
[13:33:40.707]                 else {
[13:33:40.707]                   if (TRUE) {
[13:33:40.707]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:40.707]                     {
[13:33:40.707]                       inherits <- base::inherits
[13:33:40.707]                       invokeRestart <- base::invokeRestart
[13:33:40.707]                       is.null <- base::is.null
[13:33:40.707]                       muffled <- FALSE
[13:33:40.707]                       if (inherits(cond, "message")) {
[13:33:40.707]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:40.707]                         if (muffled) 
[13:33:40.707]                           invokeRestart("muffleMessage")
[13:33:40.707]                       }
[13:33:40.707]                       else if (inherits(cond, "warning")) {
[13:33:40.707]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:40.707]                         if (muffled) 
[13:33:40.707]                           invokeRestart("muffleWarning")
[13:33:40.707]                       }
[13:33:40.707]                       else if (inherits(cond, "condition")) {
[13:33:40.707]                         if (!is.null(pattern)) {
[13:33:40.707]                           computeRestarts <- base::computeRestarts
[13:33:40.707]                           grepl <- base::grepl
[13:33:40.707]                           restarts <- computeRestarts(cond)
[13:33:40.707]                           for (restart in restarts) {
[13:33:40.707]                             name <- restart$name
[13:33:40.707]                             if (is.null(name)) 
[13:33:40.707]                               next
[13:33:40.707]                             if (!grepl(pattern, name)) 
[13:33:40.707]                               next
[13:33:40.707]                             invokeRestart(restart)
[13:33:40.707]                             muffled <- TRUE
[13:33:40.707]                             break
[13:33:40.707]                           }
[13:33:40.707]                         }
[13:33:40.707]                       }
[13:33:40.707]                       invisible(muffled)
[13:33:40.707]                     }
[13:33:40.707]                     muffleCondition(cond, pattern = "^muffle")
[13:33:40.707]                   }
[13:33:40.707]                 }
[13:33:40.707]             }
[13:33:40.707]         }))
[13:33:40.707]     }, error = function(ex) {
[13:33:40.707]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:40.707]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:40.707]                 ...future.rng), started = ...future.startTime, 
[13:33:40.707]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:40.707]             version = "1.8"), class = "FutureResult")
[13:33:40.707]     }, finally = {
[13:33:40.707]         if (!identical(...future.workdir, getwd())) 
[13:33:40.707]             setwd(...future.workdir)
[13:33:40.707]         {
[13:33:40.707]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:40.707]                 ...future.oldOptions$nwarnings <- NULL
[13:33:40.707]             }
[13:33:40.707]             base::options(...future.oldOptions)
[13:33:40.707]             if (.Platform$OS.type == "windows") {
[13:33:40.707]                 old_names <- names(...future.oldEnvVars)
[13:33:40.707]                 envs <- base::Sys.getenv()
[13:33:40.707]                 names <- names(envs)
[13:33:40.707]                 common <- intersect(names, old_names)
[13:33:40.707]                 added <- setdiff(names, old_names)
[13:33:40.707]                 removed <- setdiff(old_names, names)
[13:33:40.707]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:40.707]                   envs[common]]
[13:33:40.707]                 NAMES <- toupper(changed)
[13:33:40.707]                 args <- list()
[13:33:40.707]                 for (kk in seq_along(NAMES)) {
[13:33:40.707]                   name <- changed[[kk]]
[13:33:40.707]                   NAME <- NAMES[[kk]]
[13:33:40.707]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.707]                     next
[13:33:40.707]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:40.707]                 }
[13:33:40.707]                 NAMES <- toupper(added)
[13:33:40.707]                 for (kk in seq_along(NAMES)) {
[13:33:40.707]                   name <- added[[kk]]
[13:33:40.707]                   NAME <- NAMES[[kk]]
[13:33:40.707]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.707]                     next
[13:33:40.707]                   args[[name]] <- ""
[13:33:40.707]                 }
[13:33:40.707]                 NAMES <- toupper(removed)
[13:33:40.707]                 for (kk in seq_along(NAMES)) {
[13:33:40.707]                   name <- removed[[kk]]
[13:33:40.707]                   NAME <- NAMES[[kk]]
[13:33:40.707]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.707]                     next
[13:33:40.707]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:40.707]                 }
[13:33:40.707]                 if (length(args) > 0) 
[13:33:40.707]                   base::do.call(base::Sys.setenv, args = args)
[13:33:40.707]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:40.707]             }
[13:33:40.707]             else {
[13:33:40.707]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:40.707]             }
[13:33:40.707]             {
[13:33:40.707]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:40.707]                   0L) {
[13:33:40.707]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:40.707]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:40.707]                   base::options(opts)
[13:33:40.707]                 }
[13:33:40.707]                 {
[13:33:40.707]                   {
[13:33:40.707]                     NULL
[13:33:40.707]                     RNGkind("Mersenne-Twister")
[13:33:40.707]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:40.707]                       inherits = FALSE)
[13:33:40.707]                   }
[13:33:40.707]                   options(future.plan = NULL)
[13:33:40.707]                   if (is.na(NA_character_)) 
[13:33:40.707]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:40.707]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:40.707]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:40.707]                     .init = FALSE)
[13:33:40.707]                 }
[13:33:40.707]             }
[13:33:40.707]         }
[13:33:40.707]     })
[13:33:40.707]     if (TRUE) {
[13:33:40.707]         base::sink(type = "output", split = FALSE)
[13:33:40.707]         if (TRUE) {
[13:33:40.707]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:40.707]         }
[13:33:40.707]         else {
[13:33:40.707]             ...future.result["stdout"] <- base::list(NULL)
[13:33:40.707]         }
[13:33:40.707]         base::close(...future.stdout)
[13:33:40.707]         ...future.stdout <- NULL
[13:33:40.707]     }
[13:33:40.707]     ...future.result$conditions <- ...future.conditions
[13:33:40.707]     ...future.result$finished <- base::Sys.time()
[13:33:40.707]     ...future.result
[13:33:40.707] }
[13:33:40.708] assign_globals() ...
[13:33:40.709] List of 5
[13:33:40.709]  $ ...future.FUN            :function (x, ...)  
[13:33:40.709]  $ future.call.arguments    :List of 1
[13:33:40.709]   ..$ singular.ok: logi FALSE
[13:33:40.709]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.709]  $ ...future.elements_ii    :List of 3
[13:33:40.709]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:40.709]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:33:40.709]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:40.709]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:40.709]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:40.709]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:33:40.709]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:40.709]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:33:40.709]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:40.709]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:33:40.709]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:40.709]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:33:40.709]  $ ...future.seeds_ii       : NULL
[13:33:40.709]  $ ...future.globals.maxSize: NULL
[13:33:40.709]  - attr(*, "where")=List of 5
[13:33:40.709]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:40.709]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:40.709]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:40.709]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:40.709]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:40.709]  - attr(*, "resolved")= logi FALSE
[13:33:40.709]  - attr(*, "total_size")= num 5384
[13:33:40.709]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.709]  - attr(*, "already-done")= logi TRUE
[13:33:40.718] - reassign environment for ‘...future.FUN’
[13:33:40.718] - copied ‘...future.FUN’ to environment
[13:33:40.718] - copied ‘future.call.arguments’ to environment
[13:33:40.718] - copied ‘...future.elements_ii’ to environment
[13:33:40.718] - copied ‘...future.seeds_ii’ to environment
[13:33:40.718] - copied ‘...future.globals.maxSize’ to environment
[13:33:40.718] assign_globals() ... done
[13:33:40.719] plan(): Setting new future strategy stack:
[13:33:40.719] List of future strategies:
[13:33:40.719] 1. sequential:
[13:33:40.719]    - args: function (..., envir = parent.frame())
[13:33:40.719]    - tweaked: FALSE
[13:33:40.719]    - call: NULL
[13:33:40.719] plan(): nbrOfWorkers() = 1
[13:33:40.721] plan(): Setting new future strategy stack:
[13:33:40.722] List of future strategies:
[13:33:40.722] 1. sequential:
[13:33:40.722]    - args: function (..., envir = parent.frame())
[13:33:40.722]    - tweaked: FALSE
[13:33:40.722]    - call: plan(strategy)
[13:33:40.722] plan(): nbrOfWorkers() = 1
[13:33:40.722] SequentialFuture started (and completed)
[13:33:40.722] - Launch lazy future ... done
[13:33:40.722] run() for ‘SequentialFuture’ ... done
[13:33:40.722] Created future:
[13:33:40.722] SequentialFuture:
[13:33:40.722] Label: ‘future_by-1’
[13:33:40.722] Expression:
[13:33:40.722] {
[13:33:40.722]     do.call(function(...) {
[13:33:40.722]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.722]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:40.722]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.722]             on.exit(options(oopts), add = TRUE)
[13:33:40.722]         }
[13:33:40.722]         {
[13:33:40.722]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:40.722]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.722]                 ...future.FUN(...future.X_jj, ...)
[13:33:40.722]             })
[13:33:40.722]         }
[13:33:40.722]     }, args = future.call.arguments)
[13:33:40.722] }
[13:33:40.722] Lazy evaluation: FALSE
[13:33:40.722] Asynchronous evaluation: FALSE
[13:33:40.722] Local evaluation: TRUE
[13:33:40.722] Environment: R_GlobalEnv
[13:33:40.722] Capture standard output: TRUE
[13:33:40.722] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:40.722] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:40.722] Packages: 1 packages (‘stats’)
[13:33:40.722] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:40.722] Resolved: TRUE
[13:33:40.722] Value: 26.06 KiB of class ‘list’
[13:33:40.722] Early signaling: FALSE
[13:33:40.722] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:40.722] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:40.724] Chunk #1 of 1 ... DONE
[13:33:40.724] Launching 1 futures (chunks) ... DONE
[13:33:40.724] Resolving 1 futures (chunks) ...
[13:33:40.724] resolve() on list ...
[13:33:40.724]  recursive: 0
[13:33:40.724]  length: 1
[13:33:40.724] 
[13:33:40.724] resolved() for ‘SequentialFuture’ ...
[13:33:40.724] - state: ‘finished’
[13:33:40.725] - run: TRUE
[13:33:40.725] - result: ‘FutureResult’
[13:33:40.725] resolved() for ‘SequentialFuture’ ... done
[13:33:40.725] Future #1
[13:33:40.725] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:40.725] - nx: 1
[13:33:40.725] - relay: TRUE
[13:33:40.725] - stdout: TRUE
[13:33:40.725] - signal: TRUE
[13:33:40.725] - resignal: FALSE
[13:33:40.725] - force: TRUE
[13:33:40.726] - relayed: [n=1] FALSE
[13:33:40.726] - queued futures: [n=1] FALSE
[13:33:40.726]  - until=1
[13:33:40.726]  - relaying element #1
[13:33:40.726] - relayed: [n=1] TRUE
[13:33:40.726] - queued futures: [n=1] TRUE
[13:33:40.726] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:40.726]  length: 0 (resolved future 1)
[13:33:40.726] Relaying remaining futures
[13:33:40.726] signalConditionsASAP(NULL, pos=0) ...
[13:33:40.726] - nx: 1
[13:33:40.727] - relay: TRUE
[13:33:40.727] - stdout: TRUE
[13:33:40.727] - signal: TRUE
[13:33:40.727] - resignal: FALSE
[13:33:40.727] - force: TRUE
[13:33:40.727] - relayed: [n=1] TRUE
[13:33:40.727] - queued futures: [n=1] TRUE
 - flush all
[13:33:40.727] - relayed: [n=1] TRUE
[13:33:40.727] - queued futures: [n=1] TRUE
[13:33:40.727] signalConditionsASAP(NULL, pos=0) ... done
[13:33:40.727] resolve() on list ... DONE
[13:33:40.728]  - Number of value chunks collected: 1
[13:33:40.728] Resolving 1 futures (chunks) ... DONE
[13:33:40.728] Reducing values from 1 chunks ...
[13:33:40.728]  - Number of values collected after concatenation: 3
[13:33:40.728]  - Number of values expected: 3
[13:33:40.728] Reducing values from 1 chunks ... DONE
[13:33:40.729] future_lapply() ... DONE
[13:33:40.729] future_by_internal() ... DONE
[13:33:40.733] future_by_internal() ...
[13:33:40.733] future_lapply() ...
[13:33:40.734] Number of chunks: 1
[13:33:40.734] getGlobalsAndPackagesXApply() ...
[13:33:40.734]  - future.globals: TRUE
[13:33:40.734] getGlobalsAndPackages() ...
[13:33:40.734] Searching for globals...
[13:33:40.736] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:33:40.736] Searching for globals ... DONE
[13:33:40.736] Resolving globals: FALSE
[13:33:40.736] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[13:33:40.737] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[13:33:40.737] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[13:33:40.737] - packages: [1] ‘stats’
[13:33:40.737] getGlobalsAndPackages() ... DONE
[13:33:40.737]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[13:33:40.737]  - needed namespaces: [n=1] ‘stats’
[13:33:40.737] Finding globals ... DONE
[13:33:40.737]  - use_args: TRUE
[13:33:40.737]  - Getting '...' globals ...
[13:33:40.738] resolve() on list ...
[13:33:40.738]  recursive: 0
[13:33:40.738]  length: 1
[13:33:40.738]  elements: ‘...’
[13:33:40.738]  length: 0 (resolved future 1)
[13:33:40.738] resolve() on list ... DONE
[13:33:40.738]    - '...' content: [n=0] 
[13:33:40.738] List of 1
[13:33:40.738]  $ ...: list()
[13:33:40.738]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.738]  - attr(*, "where")=List of 1
[13:33:40.738]   ..$ ...:<environment: 0x55cb803e3d60> 
[13:33:40.738]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.738]  - attr(*, "resolved")= logi TRUE
[13:33:40.738]  - attr(*, "total_size")= num NA
[13:33:40.741]  - Getting '...' globals ... DONE
[13:33:40.741] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[13:33:40.741] List of 4
[13:33:40.741]  $ ...future.FUN:function (x)  
[13:33:40.741]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:33:40.741]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:40.741]  $ ...          : list()
[13:33:40.741]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.741]  - attr(*, "where")=List of 4
[13:33:40.741]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:40.741]   ..$ breaks       :<environment: R_EmptyEnv> 
[13:33:40.741]   ..$ wool         :<environment: R_EmptyEnv> 
[13:33:40.741]   ..$ ...          :<environment: 0x55cb803e3d60> 
[13:33:40.741]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.741]  - attr(*, "resolved")= logi FALSE
[13:33:40.741]  - attr(*, "total_size")= num 2320
[13:33:40.745] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:40.745] getGlobalsAndPackagesXApply() ... DONE
[13:33:40.745] Number of futures (= number of chunks): 1
[13:33:40.745] Launching 1 futures (chunks) ...
[13:33:40.745] Chunk #1 of 1 ...
[13:33:40.746]  - Finding globals in 'X' for chunk #1 ...
[13:33:40.746] getGlobalsAndPackages() ...
[13:33:40.746] Searching for globals...
[13:33:40.746] 
[13:33:40.746] Searching for globals ... DONE
[13:33:40.746] - globals: [0] <none>
[13:33:40.747] getGlobalsAndPackages() ... DONE
[13:33:40.747]    + additional globals found: [n=0] 
[13:33:40.747]    + additional namespaces needed: [n=0] 
[13:33:40.747]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:40.747]  - seeds: <none>
[13:33:40.747]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.747] getGlobalsAndPackages() ...
[13:33:40.747] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.747] Resolving globals: FALSE
[13:33:40.747] Tweak future expression to call with '...' arguments ...
[13:33:40.747] {
[13:33:40.747]     do.call(function(...) {
[13:33:40.747]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.747]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:40.747]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.747]             on.exit(options(oopts), add = TRUE)
[13:33:40.747]         }
[13:33:40.747]         {
[13:33:40.747]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:40.747]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.747]                 ...future.FUN(...future.X_jj, ...)
[13:33:40.747]             })
[13:33:40.747]         }
[13:33:40.747]     }, args = future.call.arguments)
[13:33:40.747] }
[13:33:40.748] Tweak future expression to call with '...' arguments ... DONE
[13:33:40.748] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.748] 
[13:33:40.748] getGlobalsAndPackages() ... DONE
[13:33:40.749] run() for ‘Future’ ...
[13:33:40.749] - state: ‘created’
[13:33:40.749] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:33:40.749] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:40.749] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:40.749]   - Field: ‘label’
[13:33:40.749]   - Field: ‘local’
[13:33:40.749]   - Field: ‘owner’
[13:33:40.749]   - Field: ‘envir’
[13:33:40.750]   - Field: ‘packages’
[13:33:40.750]   - Field: ‘gc’
[13:33:40.750]   - Field: ‘conditions’
[13:33:40.750]   - Field: ‘expr’
[13:33:40.750]   - Field: ‘uuid’
[13:33:40.750]   - Field: ‘seed’
[13:33:40.750]   - Field: ‘version’
[13:33:40.750]   - Field: ‘result’
[13:33:40.750]   - Field: ‘asynchronous’
[13:33:40.750]   - Field: ‘calls’
[13:33:40.750]   - Field: ‘globals’
[13:33:40.751]   - Field: ‘stdout’
[13:33:40.751]   - Field: ‘earlySignal’
[13:33:40.751]   - Field: ‘lazy’
[13:33:40.751]   - Field: ‘state’
[13:33:40.751] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:40.751] - Launch lazy future ...
[13:33:40.751] Packages needed by the future expression (n = 1): ‘stats’
[13:33:40.751] Packages needed by future strategies (n = 0): <none>
[13:33:40.752] {
[13:33:40.752]     {
[13:33:40.752]         {
[13:33:40.752]             ...future.startTime <- base::Sys.time()
[13:33:40.752]             {
[13:33:40.752]                 {
[13:33:40.752]                   {
[13:33:40.752]                     {
[13:33:40.752]                       base::local({
[13:33:40.752]                         has_future <- base::requireNamespace("future", 
[13:33:40.752]                           quietly = TRUE)
[13:33:40.752]                         if (has_future) {
[13:33:40.752]                           ns <- base::getNamespace("future")
[13:33:40.752]                           version <- ns[[".package"]][["version"]]
[13:33:40.752]                           if (is.null(version)) 
[13:33:40.752]                             version <- utils::packageVersion("future")
[13:33:40.752]                         }
[13:33:40.752]                         else {
[13:33:40.752]                           version <- NULL
[13:33:40.752]                         }
[13:33:40.752]                         if (!has_future || version < "1.8.0") {
[13:33:40.752]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:40.752]                             "", base::R.version$version.string), 
[13:33:40.752]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:40.752]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:40.752]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:40.752]                               "release", "version")], collapse = " "), 
[13:33:40.752]                             hostname = base::Sys.info()[["nodename"]])
[13:33:40.752]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:40.752]                             info)
[13:33:40.752]                           info <- base::paste(info, collapse = "; ")
[13:33:40.752]                           if (!has_future) {
[13:33:40.752]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:40.752]                               info)
[13:33:40.752]                           }
[13:33:40.752]                           else {
[13:33:40.752]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:40.752]                               info, version)
[13:33:40.752]                           }
[13:33:40.752]                           base::stop(msg)
[13:33:40.752]                         }
[13:33:40.752]                       })
[13:33:40.752]                     }
[13:33:40.752]                     base::local({
[13:33:40.752]                       for (pkg in "stats") {
[13:33:40.752]                         base::loadNamespace(pkg)
[13:33:40.752]                         base::library(pkg, character.only = TRUE)
[13:33:40.752]                       }
[13:33:40.752]                     })
[13:33:40.752]                   }
[13:33:40.752]                   ...future.strategy.old <- future::plan("list")
[13:33:40.752]                   options(future.plan = NULL)
[13:33:40.752]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:40.752]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:40.752]                 }
[13:33:40.752]                 ...future.workdir <- getwd()
[13:33:40.752]             }
[13:33:40.752]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:40.752]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:40.752]         }
[13:33:40.752]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:40.752]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:40.752]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:40.752]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:40.752]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:40.752]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:40.752]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:40.752]             base::names(...future.oldOptions))
[13:33:40.752]     }
[13:33:40.752]     if (FALSE) {
[13:33:40.752]     }
[13:33:40.752]     else {
[13:33:40.752]         if (TRUE) {
[13:33:40.752]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:40.752]                 open = "w")
[13:33:40.752]         }
[13:33:40.752]         else {
[13:33:40.752]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:40.752]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:40.752]         }
[13:33:40.752]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:40.752]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:40.752]             base::sink(type = "output", split = FALSE)
[13:33:40.752]             base::close(...future.stdout)
[13:33:40.752]         }, add = TRUE)
[13:33:40.752]     }
[13:33:40.752]     ...future.frame <- base::sys.nframe()
[13:33:40.752]     ...future.conditions <- base::list()
[13:33:40.752]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:40.752]     if (FALSE) {
[13:33:40.752]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:40.752]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:40.752]     }
[13:33:40.752]     ...future.result <- base::tryCatch({
[13:33:40.752]         base::withCallingHandlers({
[13:33:40.752]             ...future.value <- base::withVisible(base::local({
[13:33:40.752]                 do.call(function(...) {
[13:33:40.752]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.752]                   if (!identical(...future.globals.maxSize.org, 
[13:33:40.752]                     ...future.globals.maxSize)) {
[13:33:40.752]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.752]                     on.exit(options(oopts), add = TRUE)
[13:33:40.752]                   }
[13:33:40.752]                   {
[13:33:40.752]                     lapply(seq_along(...future.elements_ii), 
[13:33:40.752]                       FUN = function(jj) {
[13:33:40.752]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.752]                         ...future.FUN(...future.X_jj, ...)
[13:33:40.752]                       })
[13:33:40.752]                   }
[13:33:40.752]                 }, args = future.call.arguments)
[13:33:40.752]             }))
[13:33:40.752]             future::FutureResult(value = ...future.value$value, 
[13:33:40.752]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:40.752]                   ...future.rng), globalenv = if (FALSE) 
[13:33:40.752]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:40.752]                     ...future.globalenv.names))
[13:33:40.752]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:40.752]         }, condition = base::local({
[13:33:40.752]             c <- base::c
[13:33:40.752]             inherits <- base::inherits
[13:33:40.752]             invokeRestart <- base::invokeRestart
[13:33:40.752]             length <- base::length
[13:33:40.752]             list <- base::list
[13:33:40.752]             seq.int <- base::seq.int
[13:33:40.752]             signalCondition <- base::signalCondition
[13:33:40.752]             sys.calls <- base::sys.calls
[13:33:40.752]             `[[` <- base::`[[`
[13:33:40.752]             `+` <- base::`+`
[13:33:40.752]             `<<-` <- base::`<<-`
[13:33:40.752]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:40.752]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:40.752]                   3L)]
[13:33:40.752]             }
[13:33:40.752]             function(cond) {
[13:33:40.752]                 is_error <- inherits(cond, "error")
[13:33:40.752]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:40.752]                   NULL)
[13:33:40.752]                 if (is_error) {
[13:33:40.752]                   sessionInformation <- function() {
[13:33:40.752]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:40.752]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:40.752]                       search = base::search(), system = base::Sys.info())
[13:33:40.752]                   }
[13:33:40.752]                   ...future.conditions[[length(...future.conditions) + 
[13:33:40.752]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:40.752]                     cond$call), session = sessionInformation(), 
[13:33:40.752]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:40.752]                   signalCondition(cond)
[13:33:40.752]                 }
[13:33:40.752]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:40.752]                 "immediateCondition"))) {
[13:33:40.752]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:40.752]                   ...future.conditions[[length(...future.conditions) + 
[13:33:40.752]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:40.752]                   if (TRUE && !signal) {
[13:33:40.752]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:40.752]                     {
[13:33:40.752]                       inherits <- base::inherits
[13:33:40.752]                       invokeRestart <- base::invokeRestart
[13:33:40.752]                       is.null <- base::is.null
[13:33:40.752]                       muffled <- FALSE
[13:33:40.752]                       if (inherits(cond, "message")) {
[13:33:40.752]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:40.752]                         if (muffled) 
[13:33:40.752]                           invokeRestart("muffleMessage")
[13:33:40.752]                       }
[13:33:40.752]                       else if (inherits(cond, "warning")) {
[13:33:40.752]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:40.752]                         if (muffled) 
[13:33:40.752]                           invokeRestart("muffleWarning")
[13:33:40.752]                       }
[13:33:40.752]                       else if (inherits(cond, "condition")) {
[13:33:40.752]                         if (!is.null(pattern)) {
[13:33:40.752]                           computeRestarts <- base::computeRestarts
[13:33:40.752]                           grepl <- base::grepl
[13:33:40.752]                           restarts <- computeRestarts(cond)
[13:33:40.752]                           for (restart in restarts) {
[13:33:40.752]                             name <- restart$name
[13:33:40.752]                             if (is.null(name)) 
[13:33:40.752]                               next
[13:33:40.752]                             if (!grepl(pattern, name)) 
[13:33:40.752]                               next
[13:33:40.752]                             invokeRestart(restart)
[13:33:40.752]                             muffled <- TRUE
[13:33:40.752]                             break
[13:33:40.752]                           }
[13:33:40.752]                         }
[13:33:40.752]                       }
[13:33:40.752]                       invisible(muffled)
[13:33:40.752]                     }
[13:33:40.752]                     muffleCondition(cond, pattern = "^muffle")
[13:33:40.752]                   }
[13:33:40.752]                 }
[13:33:40.752]                 else {
[13:33:40.752]                   if (TRUE) {
[13:33:40.752]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:40.752]                     {
[13:33:40.752]                       inherits <- base::inherits
[13:33:40.752]                       invokeRestart <- base::invokeRestart
[13:33:40.752]                       is.null <- base::is.null
[13:33:40.752]                       muffled <- FALSE
[13:33:40.752]                       if (inherits(cond, "message")) {
[13:33:40.752]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:40.752]                         if (muffled) 
[13:33:40.752]                           invokeRestart("muffleMessage")
[13:33:40.752]                       }
[13:33:40.752]                       else if (inherits(cond, "warning")) {
[13:33:40.752]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:40.752]                         if (muffled) 
[13:33:40.752]                           invokeRestart("muffleWarning")
[13:33:40.752]                       }
[13:33:40.752]                       else if (inherits(cond, "condition")) {
[13:33:40.752]                         if (!is.null(pattern)) {
[13:33:40.752]                           computeRestarts <- base::computeRestarts
[13:33:40.752]                           grepl <- base::grepl
[13:33:40.752]                           restarts <- computeRestarts(cond)
[13:33:40.752]                           for (restart in restarts) {
[13:33:40.752]                             name <- restart$name
[13:33:40.752]                             if (is.null(name)) 
[13:33:40.752]                               next
[13:33:40.752]                             if (!grepl(pattern, name)) 
[13:33:40.752]                               next
[13:33:40.752]                             invokeRestart(restart)
[13:33:40.752]                             muffled <- TRUE
[13:33:40.752]                             break
[13:33:40.752]                           }
[13:33:40.752]                         }
[13:33:40.752]                       }
[13:33:40.752]                       invisible(muffled)
[13:33:40.752]                     }
[13:33:40.752]                     muffleCondition(cond, pattern = "^muffle")
[13:33:40.752]                   }
[13:33:40.752]                 }
[13:33:40.752]             }
[13:33:40.752]         }))
[13:33:40.752]     }, error = function(ex) {
[13:33:40.752]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:40.752]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:40.752]                 ...future.rng), started = ...future.startTime, 
[13:33:40.752]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:40.752]             version = "1.8"), class = "FutureResult")
[13:33:40.752]     }, finally = {
[13:33:40.752]         if (!identical(...future.workdir, getwd())) 
[13:33:40.752]             setwd(...future.workdir)
[13:33:40.752]         {
[13:33:40.752]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:40.752]                 ...future.oldOptions$nwarnings <- NULL
[13:33:40.752]             }
[13:33:40.752]             base::options(...future.oldOptions)
[13:33:40.752]             if (.Platform$OS.type == "windows") {
[13:33:40.752]                 old_names <- names(...future.oldEnvVars)
[13:33:40.752]                 envs <- base::Sys.getenv()
[13:33:40.752]                 names <- names(envs)
[13:33:40.752]                 common <- intersect(names, old_names)
[13:33:40.752]                 added <- setdiff(names, old_names)
[13:33:40.752]                 removed <- setdiff(old_names, names)
[13:33:40.752]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:40.752]                   envs[common]]
[13:33:40.752]                 NAMES <- toupper(changed)
[13:33:40.752]                 args <- list()
[13:33:40.752]                 for (kk in seq_along(NAMES)) {
[13:33:40.752]                   name <- changed[[kk]]
[13:33:40.752]                   NAME <- NAMES[[kk]]
[13:33:40.752]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.752]                     next
[13:33:40.752]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:40.752]                 }
[13:33:40.752]                 NAMES <- toupper(added)
[13:33:40.752]                 for (kk in seq_along(NAMES)) {
[13:33:40.752]                   name <- added[[kk]]
[13:33:40.752]                   NAME <- NAMES[[kk]]
[13:33:40.752]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.752]                     next
[13:33:40.752]                   args[[name]] <- ""
[13:33:40.752]                 }
[13:33:40.752]                 NAMES <- toupper(removed)
[13:33:40.752]                 for (kk in seq_along(NAMES)) {
[13:33:40.752]                   name <- removed[[kk]]
[13:33:40.752]                   NAME <- NAMES[[kk]]
[13:33:40.752]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.752]                     next
[13:33:40.752]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:40.752]                 }
[13:33:40.752]                 if (length(args) > 0) 
[13:33:40.752]                   base::do.call(base::Sys.setenv, args = args)
[13:33:40.752]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:40.752]             }
[13:33:40.752]             else {
[13:33:40.752]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:40.752]             }
[13:33:40.752]             {
[13:33:40.752]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:40.752]                   0L) {
[13:33:40.752]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:40.752]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:40.752]                   base::options(opts)
[13:33:40.752]                 }
[13:33:40.752]                 {
[13:33:40.752]                   {
[13:33:40.752]                     NULL
[13:33:40.752]                     RNGkind("Mersenne-Twister")
[13:33:40.752]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:40.752]                       inherits = FALSE)
[13:33:40.752]                   }
[13:33:40.752]                   options(future.plan = NULL)
[13:33:40.752]                   if (is.na(NA_character_)) 
[13:33:40.752]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:40.752]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:40.752]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:40.752]                     .init = FALSE)
[13:33:40.752]                 }
[13:33:40.752]             }
[13:33:40.752]         }
[13:33:40.752]     })
[13:33:40.752]     if (TRUE) {
[13:33:40.752]         base::sink(type = "output", split = FALSE)
[13:33:40.752]         if (TRUE) {
[13:33:40.752]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:40.752]         }
[13:33:40.752]         else {
[13:33:40.752]             ...future.result["stdout"] <- base::list(NULL)
[13:33:40.752]         }
[13:33:40.752]         base::close(...future.stdout)
[13:33:40.752]         ...future.stdout <- NULL
[13:33:40.752]     }
[13:33:40.752]     ...future.result$conditions <- ...future.conditions
[13:33:40.752]     ...future.result$finished <- base::Sys.time()
[13:33:40.752]     ...future.result
[13:33:40.752] }
[13:33:40.753] assign_globals() ...
[13:33:40.753] List of 7
[13:33:40.753]  $ ...future.FUN            :function (x)  
[13:33:40.753]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:33:40.753]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:40.753]  $ future.call.arguments    : list()
[13:33:40.753]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.753]  $ ...future.elements_ii    :List of 3
[13:33:40.753]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:40.753]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:33:40.753]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:40.753]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:40.753]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:40.753]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:33:40.753]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:40.753]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:33:40.753]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:40.753]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:33:40.753]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:40.753]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:33:40.753]  $ ...future.seeds_ii       : NULL
[13:33:40.753]  $ ...future.globals.maxSize: NULL
[13:33:40.753]  - attr(*, "where")=List of 7
[13:33:40.753]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:40.753]   ..$ breaks                   :<environment: R_EmptyEnv> 
[13:33:40.753]   ..$ wool                     :<environment: R_EmptyEnv> 
[13:33:40.753]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:40.753]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:40.753]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:40.753]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:40.753]  - attr(*, "resolved")= logi FALSE
[13:33:40.753]  - attr(*, "total_size")= num 2320
[13:33:40.753]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.753]  - attr(*, "already-done")= logi TRUE
[13:33:40.762] - reassign environment for ‘...future.FUN’
[13:33:40.762] - copied ‘...future.FUN’ to environment
[13:33:40.762] - copied ‘breaks’ to environment
[13:33:40.762] - copied ‘wool’ to environment
[13:33:40.763] - copied ‘future.call.arguments’ to environment
[13:33:40.763] - copied ‘...future.elements_ii’ to environment
[13:33:40.763] - copied ‘...future.seeds_ii’ to environment
[13:33:40.763] - copied ‘...future.globals.maxSize’ to environment
[13:33:40.763] assign_globals() ... done
[13:33:40.763] plan(): Setting new future strategy stack:
[13:33:40.763] List of future strategies:
[13:33:40.763] 1. sequential:
[13:33:40.763]    - args: function (..., envir = parent.frame())
[13:33:40.763]    - tweaked: FALSE
[13:33:40.763]    - call: NULL
[13:33:40.764] plan(): nbrOfWorkers() = 1
[13:33:40.767] plan(): Setting new future strategy stack:
[13:33:40.767] List of future strategies:
[13:33:40.767] 1. sequential:
[13:33:40.767]    - args: function (..., envir = parent.frame())
[13:33:40.767]    - tweaked: FALSE
[13:33:40.767]    - call: plan(strategy)
[13:33:40.767] plan(): nbrOfWorkers() = 1
[13:33:40.767] SequentialFuture started (and completed)
[13:33:40.768] - Launch lazy future ... done
[13:33:40.768] run() for ‘SequentialFuture’ ... done
[13:33:40.768] Created future:
[13:33:40.768] SequentialFuture:
[13:33:40.768] Label: ‘future_by-1’
[13:33:40.768] Expression:
[13:33:40.768] {
[13:33:40.768]     do.call(function(...) {
[13:33:40.768]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.768]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:40.768]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.768]             on.exit(options(oopts), add = TRUE)
[13:33:40.768]         }
[13:33:40.768]         {
[13:33:40.768]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:40.768]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.768]                 ...future.FUN(...future.X_jj, ...)
[13:33:40.768]             })
[13:33:40.768]         }
[13:33:40.768]     }, args = future.call.arguments)
[13:33:40.768] }
[13:33:40.768] Lazy evaluation: FALSE
[13:33:40.768] Asynchronous evaluation: FALSE
[13:33:40.768] Local evaluation: TRUE
[13:33:40.768] Environment: 0x55cb801ce488
[13:33:40.768] Capture standard output: TRUE
[13:33:40.768] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:40.768] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[13:33:40.768] Packages: 1 packages (‘stats’)
[13:33:40.768] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:40.768] Resolved: TRUE
[13:33:40.768] Value: 25.57 KiB of class ‘list’
[13:33:40.768] Early signaling: FALSE
[13:33:40.768] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:40.768] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:40.769] Chunk #1 of 1 ... DONE
[13:33:40.769] Launching 1 futures (chunks) ... DONE
[13:33:40.769] Resolving 1 futures (chunks) ...
[13:33:40.770] resolve() on list ...
[13:33:40.770]  recursive: 0
[13:33:40.770]  length: 1
[13:33:40.770] 
[13:33:40.770] resolved() for ‘SequentialFuture’ ...
[13:33:40.770] - state: ‘finished’
[13:33:40.770] - run: TRUE
[13:33:40.770] - result: ‘FutureResult’
[13:33:40.770] resolved() for ‘SequentialFuture’ ... done
[13:33:40.770] Future #1
[13:33:40.770] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:40.771] - nx: 1
[13:33:40.771] - relay: TRUE
[13:33:40.771] - stdout: TRUE
[13:33:40.771] - signal: TRUE
[13:33:40.771] - resignal: FALSE
[13:33:40.771] - force: TRUE
[13:33:40.771] - relayed: [n=1] FALSE
[13:33:40.771] - queued futures: [n=1] FALSE
[13:33:40.771]  - until=1
[13:33:40.771]  - relaying element #1
[13:33:40.771] - relayed: [n=1] TRUE
[13:33:40.772] - queued futures: [n=1] TRUE
[13:33:40.772] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:40.772]  length: 0 (resolved future 1)
[13:33:40.772] Relaying remaining futures
[13:33:40.772] signalConditionsASAP(NULL, pos=0) ...
[13:33:40.772] - nx: 1
[13:33:40.772] - relay: TRUE
[13:33:40.772] - stdout: TRUE
[13:33:40.772] - signal: TRUE
[13:33:40.772] - resignal: FALSE
[13:33:40.772] - force: TRUE
[13:33:40.772] - relayed: [n=1] TRUE
[13:33:40.772] - queued futures: [n=1] TRUE
 - flush all
[13:33:40.773] - relayed: [n=1] TRUE
[13:33:40.773] - queued futures: [n=1] TRUE
[13:33:40.773] signalConditionsASAP(NULL, pos=0) ... done
[13:33:40.773] resolve() on list ... DONE
[13:33:40.773]  - Number of value chunks collected: 1
[13:33:40.773] Resolving 1 futures (chunks) ... DONE
[13:33:40.773] Reducing values from 1 chunks ...
[13:33:40.773]  - Number of values collected after concatenation: 3
[13:33:40.773]  - Number of values expected: 3
[13:33:40.773] Reducing values from 1 chunks ... DONE
[13:33:40.773] future_lapply() ... DONE
[13:33:40.774] future_by_internal() ... DONE
[13:33:40.774] future_by_internal() ...
[13:33:40.774] future_lapply() ...
[13:33:40.775] Number of chunks: 1
[13:33:40.775] getGlobalsAndPackagesXApply() ...
[13:33:40.775]  - future.globals: TRUE
[13:33:40.775] getGlobalsAndPackages() ...
[13:33:40.775] Searching for globals...
[13:33:40.776] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:40.776] Searching for globals ... DONE
[13:33:40.776] Resolving globals: FALSE
[13:33:40.776] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:40.777] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:40.777] - globals: [1] ‘FUN’
[13:33:40.777] 
[13:33:40.777] getGlobalsAndPackages() ... DONE
[13:33:40.777]  - globals found/used: [n=1] ‘FUN’
[13:33:40.777]  - needed namespaces: [n=0] 
[13:33:40.777] Finding globals ... DONE
[13:33:40.777]  - use_args: TRUE
[13:33:40.777]  - Getting '...' globals ...
[13:33:40.778] resolve() on list ...
[13:33:40.778]  recursive: 0
[13:33:40.778]  length: 1
[13:33:40.778]  elements: ‘...’
[13:33:40.778]  length: 0 (resolved future 1)
[13:33:40.778] resolve() on list ... DONE
[13:33:40.778]    - '...' content: [n=0] 
[13:33:40.778] List of 1
[13:33:40.778]  $ ...: list()
[13:33:40.778]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.778]  - attr(*, "where")=List of 1
[13:33:40.778]   ..$ ...:<environment: 0x55cb823050d0> 
[13:33:40.778]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.778]  - attr(*, "resolved")= logi TRUE
[13:33:40.778]  - attr(*, "total_size")= num NA
[13:33:40.781]  - Getting '...' globals ... DONE
[13:33:40.781] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:40.781] List of 2
[13:33:40.781]  $ ...future.FUN:function (object, ...)  
[13:33:40.781]  $ ...          : list()
[13:33:40.781]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.781]  - attr(*, "where")=List of 2
[13:33:40.781]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:40.781]   ..$ ...          :<environment: 0x55cb823050d0> 
[13:33:40.781]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.781]  - attr(*, "resolved")= logi FALSE
[13:33:40.781]  - attr(*, "total_size")= num 1240
[13:33:40.784] Packages to be attached in all futures: [n=0] 
[13:33:40.784] getGlobalsAndPackagesXApply() ... DONE
[13:33:40.785] Number of futures (= number of chunks): 1
[13:33:40.785] Launching 1 futures (chunks) ...
[13:33:40.785] Chunk #1 of 1 ...
[13:33:40.785]  - Finding globals in 'X' for chunk #1 ...
[13:33:40.785] getGlobalsAndPackages() ...
[13:33:40.785] Searching for globals...
[13:33:40.785] 
[13:33:40.786] Searching for globals ... DONE
[13:33:40.786] - globals: [0] <none>
[13:33:40.786] getGlobalsAndPackages() ... DONE
[13:33:40.786]    + additional globals found: [n=0] 
[13:33:40.786]    + additional namespaces needed: [n=0] 
[13:33:40.786]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:40.786]  - seeds: <none>
[13:33:40.786]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.786] getGlobalsAndPackages() ...
[13:33:40.786] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.786] Resolving globals: FALSE
[13:33:40.787] Tweak future expression to call with '...' arguments ...
[13:33:40.787] {
[13:33:40.787]     do.call(function(...) {
[13:33:40.787]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.787]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:40.787]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.787]             on.exit(options(oopts), add = TRUE)
[13:33:40.787]         }
[13:33:40.787]         {
[13:33:40.787]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:40.787]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.787]                 ...future.FUN(...future.X_jj, ...)
[13:33:40.787]             })
[13:33:40.787]         }
[13:33:40.787]     }, args = future.call.arguments)
[13:33:40.787] }
[13:33:40.787] Tweak future expression to call with '...' arguments ... DONE
[13:33:40.787] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.787] 
[13:33:40.787] getGlobalsAndPackages() ... DONE
[13:33:40.788] run() for ‘Future’ ...
[13:33:40.788] - state: ‘created’
[13:33:40.788] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:33:40.788] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:40.788] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:40.788]   - Field: ‘label’
[13:33:40.788]   - Field: ‘local’
[13:33:40.788]   - Field: ‘owner’
[13:33:40.789]   - Field: ‘envir’
[13:33:40.789]   - Field: ‘packages’
[13:33:40.789]   - Field: ‘gc’
[13:33:40.789]   - Field: ‘conditions’
[13:33:40.789]   - Field: ‘expr’
[13:33:40.789]   - Field: ‘uuid’
[13:33:40.789]   - Field: ‘seed’
[13:33:40.789]   - Field: ‘version’
[13:33:40.789]   - Field: ‘result’
[13:33:40.789]   - Field: ‘asynchronous’
[13:33:40.789]   - Field: ‘calls’
[13:33:40.789]   - Field: ‘globals’
[13:33:40.790]   - Field: ‘stdout’
[13:33:40.790]   - Field: ‘earlySignal’
[13:33:40.790]   - Field: ‘lazy’
[13:33:40.790]   - Field: ‘state’
[13:33:40.790] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:40.790] - Launch lazy future ...
[13:33:40.790] Packages needed by the future expression (n = 0): <none>
[13:33:40.790] Packages needed by future strategies (n = 0): <none>
[13:33:40.791] {
[13:33:40.791]     {
[13:33:40.791]         {
[13:33:40.791]             ...future.startTime <- base::Sys.time()
[13:33:40.791]             {
[13:33:40.791]                 {
[13:33:40.791]                   {
[13:33:40.791]                     base::local({
[13:33:40.791]                       has_future <- base::requireNamespace("future", 
[13:33:40.791]                         quietly = TRUE)
[13:33:40.791]                       if (has_future) {
[13:33:40.791]                         ns <- base::getNamespace("future")
[13:33:40.791]                         version <- ns[[".package"]][["version"]]
[13:33:40.791]                         if (is.null(version)) 
[13:33:40.791]                           version <- utils::packageVersion("future")
[13:33:40.791]                       }
[13:33:40.791]                       else {
[13:33:40.791]                         version <- NULL
[13:33:40.791]                       }
[13:33:40.791]                       if (!has_future || version < "1.8.0") {
[13:33:40.791]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:40.791]                           "", base::R.version$version.string), 
[13:33:40.791]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:40.791]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:40.791]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:40.791]                             "release", "version")], collapse = " "), 
[13:33:40.791]                           hostname = base::Sys.info()[["nodename"]])
[13:33:40.791]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:40.791]                           info)
[13:33:40.791]                         info <- base::paste(info, collapse = "; ")
[13:33:40.791]                         if (!has_future) {
[13:33:40.791]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:40.791]                             info)
[13:33:40.791]                         }
[13:33:40.791]                         else {
[13:33:40.791]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:40.791]                             info, version)
[13:33:40.791]                         }
[13:33:40.791]                         base::stop(msg)
[13:33:40.791]                       }
[13:33:40.791]                     })
[13:33:40.791]                   }
[13:33:40.791]                   ...future.strategy.old <- future::plan("list")
[13:33:40.791]                   options(future.plan = NULL)
[13:33:40.791]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:40.791]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:40.791]                 }
[13:33:40.791]                 ...future.workdir <- getwd()
[13:33:40.791]             }
[13:33:40.791]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:40.791]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:40.791]         }
[13:33:40.791]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:40.791]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:40.791]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:40.791]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:40.791]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:40.791]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:40.791]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:40.791]             base::names(...future.oldOptions))
[13:33:40.791]     }
[13:33:40.791]     if (FALSE) {
[13:33:40.791]     }
[13:33:40.791]     else {
[13:33:40.791]         if (TRUE) {
[13:33:40.791]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:40.791]                 open = "w")
[13:33:40.791]         }
[13:33:40.791]         else {
[13:33:40.791]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:40.791]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:40.791]         }
[13:33:40.791]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:40.791]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:40.791]             base::sink(type = "output", split = FALSE)
[13:33:40.791]             base::close(...future.stdout)
[13:33:40.791]         }, add = TRUE)
[13:33:40.791]     }
[13:33:40.791]     ...future.frame <- base::sys.nframe()
[13:33:40.791]     ...future.conditions <- base::list()
[13:33:40.791]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:40.791]     if (FALSE) {
[13:33:40.791]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:40.791]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:40.791]     }
[13:33:40.791]     ...future.result <- base::tryCatch({
[13:33:40.791]         base::withCallingHandlers({
[13:33:40.791]             ...future.value <- base::withVisible(base::local({
[13:33:40.791]                 do.call(function(...) {
[13:33:40.791]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.791]                   if (!identical(...future.globals.maxSize.org, 
[13:33:40.791]                     ...future.globals.maxSize)) {
[13:33:40.791]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.791]                     on.exit(options(oopts), add = TRUE)
[13:33:40.791]                   }
[13:33:40.791]                   {
[13:33:40.791]                     lapply(seq_along(...future.elements_ii), 
[13:33:40.791]                       FUN = function(jj) {
[13:33:40.791]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.791]                         ...future.FUN(...future.X_jj, ...)
[13:33:40.791]                       })
[13:33:40.791]                   }
[13:33:40.791]                 }, args = future.call.arguments)
[13:33:40.791]             }))
[13:33:40.791]             future::FutureResult(value = ...future.value$value, 
[13:33:40.791]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:40.791]                   ...future.rng), globalenv = if (FALSE) 
[13:33:40.791]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:40.791]                     ...future.globalenv.names))
[13:33:40.791]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:40.791]         }, condition = base::local({
[13:33:40.791]             c <- base::c
[13:33:40.791]             inherits <- base::inherits
[13:33:40.791]             invokeRestart <- base::invokeRestart
[13:33:40.791]             length <- base::length
[13:33:40.791]             list <- base::list
[13:33:40.791]             seq.int <- base::seq.int
[13:33:40.791]             signalCondition <- base::signalCondition
[13:33:40.791]             sys.calls <- base::sys.calls
[13:33:40.791]             `[[` <- base::`[[`
[13:33:40.791]             `+` <- base::`+`
[13:33:40.791]             `<<-` <- base::`<<-`
[13:33:40.791]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:40.791]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:40.791]                   3L)]
[13:33:40.791]             }
[13:33:40.791]             function(cond) {
[13:33:40.791]                 is_error <- inherits(cond, "error")
[13:33:40.791]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:40.791]                   NULL)
[13:33:40.791]                 if (is_error) {
[13:33:40.791]                   sessionInformation <- function() {
[13:33:40.791]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:40.791]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:40.791]                       search = base::search(), system = base::Sys.info())
[13:33:40.791]                   }
[13:33:40.791]                   ...future.conditions[[length(...future.conditions) + 
[13:33:40.791]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:40.791]                     cond$call), session = sessionInformation(), 
[13:33:40.791]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:40.791]                   signalCondition(cond)
[13:33:40.791]                 }
[13:33:40.791]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:40.791]                 "immediateCondition"))) {
[13:33:40.791]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:40.791]                   ...future.conditions[[length(...future.conditions) + 
[13:33:40.791]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:40.791]                   if (TRUE && !signal) {
[13:33:40.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:40.791]                     {
[13:33:40.791]                       inherits <- base::inherits
[13:33:40.791]                       invokeRestart <- base::invokeRestart
[13:33:40.791]                       is.null <- base::is.null
[13:33:40.791]                       muffled <- FALSE
[13:33:40.791]                       if (inherits(cond, "message")) {
[13:33:40.791]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:40.791]                         if (muffled) 
[13:33:40.791]                           invokeRestart("muffleMessage")
[13:33:40.791]                       }
[13:33:40.791]                       else if (inherits(cond, "warning")) {
[13:33:40.791]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:40.791]                         if (muffled) 
[13:33:40.791]                           invokeRestart("muffleWarning")
[13:33:40.791]                       }
[13:33:40.791]                       else if (inherits(cond, "condition")) {
[13:33:40.791]                         if (!is.null(pattern)) {
[13:33:40.791]                           computeRestarts <- base::computeRestarts
[13:33:40.791]                           grepl <- base::grepl
[13:33:40.791]                           restarts <- computeRestarts(cond)
[13:33:40.791]                           for (restart in restarts) {
[13:33:40.791]                             name <- restart$name
[13:33:40.791]                             if (is.null(name)) 
[13:33:40.791]                               next
[13:33:40.791]                             if (!grepl(pattern, name)) 
[13:33:40.791]                               next
[13:33:40.791]                             invokeRestart(restart)
[13:33:40.791]                             muffled <- TRUE
[13:33:40.791]                             break
[13:33:40.791]                           }
[13:33:40.791]                         }
[13:33:40.791]                       }
[13:33:40.791]                       invisible(muffled)
[13:33:40.791]                     }
[13:33:40.791]                     muffleCondition(cond, pattern = "^muffle")
[13:33:40.791]                   }
[13:33:40.791]                 }
[13:33:40.791]                 else {
[13:33:40.791]                   if (TRUE) {
[13:33:40.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:40.791]                     {
[13:33:40.791]                       inherits <- base::inherits
[13:33:40.791]                       invokeRestart <- base::invokeRestart
[13:33:40.791]                       is.null <- base::is.null
[13:33:40.791]                       muffled <- FALSE
[13:33:40.791]                       if (inherits(cond, "message")) {
[13:33:40.791]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:40.791]                         if (muffled) 
[13:33:40.791]                           invokeRestart("muffleMessage")
[13:33:40.791]                       }
[13:33:40.791]                       else if (inherits(cond, "warning")) {
[13:33:40.791]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:40.791]                         if (muffled) 
[13:33:40.791]                           invokeRestart("muffleWarning")
[13:33:40.791]                       }
[13:33:40.791]                       else if (inherits(cond, "condition")) {
[13:33:40.791]                         if (!is.null(pattern)) {
[13:33:40.791]                           computeRestarts <- base::computeRestarts
[13:33:40.791]                           grepl <- base::grepl
[13:33:40.791]                           restarts <- computeRestarts(cond)
[13:33:40.791]                           for (restart in restarts) {
[13:33:40.791]                             name <- restart$name
[13:33:40.791]                             if (is.null(name)) 
[13:33:40.791]                               next
[13:33:40.791]                             if (!grepl(pattern, name)) 
[13:33:40.791]                               next
[13:33:40.791]                             invokeRestart(restart)
[13:33:40.791]                             muffled <- TRUE
[13:33:40.791]                             break
[13:33:40.791]                           }
[13:33:40.791]                         }
[13:33:40.791]                       }
[13:33:40.791]                       invisible(muffled)
[13:33:40.791]                     }
[13:33:40.791]                     muffleCondition(cond, pattern = "^muffle")
[13:33:40.791]                   }
[13:33:40.791]                 }
[13:33:40.791]             }
[13:33:40.791]         }))
[13:33:40.791]     }, error = function(ex) {
[13:33:40.791]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:40.791]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:40.791]                 ...future.rng), started = ...future.startTime, 
[13:33:40.791]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:40.791]             version = "1.8"), class = "FutureResult")
[13:33:40.791]     }, finally = {
[13:33:40.791]         if (!identical(...future.workdir, getwd())) 
[13:33:40.791]             setwd(...future.workdir)
[13:33:40.791]         {
[13:33:40.791]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:40.791]                 ...future.oldOptions$nwarnings <- NULL
[13:33:40.791]             }
[13:33:40.791]             base::options(...future.oldOptions)
[13:33:40.791]             if (.Platform$OS.type == "windows") {
[13:33:40.791]                 old_names <- names(...future.oldEnvVars)
[13:33:40.791]                 envs <- base::Sys.getenv()
[13:33:40.791]                 names <- names(envs)
[13:33:40.791]                 common <- intersect(names, old_names)
[13:33:40.791]                 added <- setdiff(names, old_names)
[13:33:40.791]                 removed <- setdiff(old_names, names)
[13:33:40.791]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:40.791]                   envs[common]]
[13:33:40.791]                 NAMES <- toupper(changed)
[13:33:40.791]                 args <- list()
[13:33:40.791]                 for (kk in seq_along(NAMES)) {
[13:33:40.791]                   name <- changed[[kk]]
[13:33:40.791]                   NAME <- NAMES[[kk]]
[13:33:40.791]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.791]                     next
[13:33:40.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:40.791]                 }
[13:33:40.791]                 NAMES <- toupper(added)
[13:33:40.791]                 for (kk in seq_along(NAMES)) {
[13:33:40.791]                   name <- added[[kk]]
[13:33:40.791]                   NAME <- NAMES[[kk]]
[13:33:40.791]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.791]                     next
[13:33:40.791]                   args[[name]] <- ""
[13:33:40.791]                 }
[13:33:40.791]                 NAMES <- toupper(removed)
[13:33:40.791]                 for (kk in seq_along(NAMES)) {
[13:33:40.791]                   name <- removed[[kk]]
[13:33:40.791]                   NAME <- NAMES[[kk]]
[13:33:40.791]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.791]                     next
[13:33:40.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:40.791]                 }
[13:33:40.791]                 if (length(args) > 0) 
[13:33:40.791]                   base::do.call(base::Sys.setenv, args = args)
[13:33:40.791]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:40.791]             }
[13:33:40.791]             else {
[13:33:40.791]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:40.791]             }
[13:33:40.791]             {
[13:33:40.791]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:40.791]                   0L) {
[13:33:40.791]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:40.791]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:40.791]                   base::options(opts)
[13:33:40.791]                 }
[13:33:40.791]                 {
[13:33:40.791]                   {
[13:33:40.791]                     NULL
[13:33:40.791]                     RNGkind("Mersenne-Twister")
[13:33:40.791]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:40.791]                       inherits = FALSE)
[13:33:40.791]                   }
[13:33:40.791]                   options(future.plan = NULL)
[13:33:40.791]                   if (is.na(NA_character_)) 
[13:33:40.791]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:40.791]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:40.791]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:40.791]                     .init = FALSE)
[13:33:40.791]                 }
[13:33:40.791]             }
[13:33:40.791]         }
[13:33:40.791]     })
[13:33:40.791]     if (TRUE) {
[13:33:40.791]         base::sink(type = "output", split = FALSE)
[13:33:40.791]         if (TRUE) {
[13:33:40.791]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:40.791]         }
[13:33:40.791]         else {
[13:33:40.791]             ...future.result["stdout"] <- base::list(NULL)
[13:33:40.791]         }
[13:33:40.791]         base::close(...future.stdout)
[13:33:40.791]         ...future.stdout <- NULL
[13:33:40.791]     }
[13:33:40.791]     ...future.result$conditions <- ...future.conditions
[13:33:40.791]     ...future.result$finished <- base::Sys.time()
[13:33:40.791]     ...future.result
[13:33:40.791] }
[13:33:40.792] assign_globals() ...
[13:33:40.792] List of 5
[13:33:40.792]  $ ...future.FUN            :function (object, ...)  
[13:33:40.792]  $ future.call.arguments    : list()
[13:33:40.792]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.792]  $ ...future.elements_ii    :List of 3
[13:33:40.792]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:40.792]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:33:40.792]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:40.792]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:40.792]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:40.792]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:33:40.792]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:40.792]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:33:40.792]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:40.792]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:33:40.792]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:40.792]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:33:40.792]  $ ...future.seeds_ii       : NULL
[13:33:40.792]  $ ...future.globals.maxSize: NULL
[13:33:40.792]  - attr(*, "where")=List of 5
[13:33:40.792]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:40.792]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:40.792]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:40.792]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:40.792]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:40.792]  - attr(*, "resolved")= logi FALSE
[13:33:40.792]  - attr(*, "total_size")= num 1240
[13:33:40.792]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.792]  - attr(*, "already-done")= logi TRUE
[13:33:40.800] - copied ‘...future.FUN’ to environment
[13:33:40.800] - copied ‘future.call.arguments’ to environment
[13:33:40.800] - copied ‘...future.elements_ii’ to environment
[13:33:40.800] - copied ‘...future.seeds_ii’ to environment
[13:33:40.800] - copied ‘...future.globals.maxSize’ to environment
[13:33:40.801] assign_globals() ... done
[13:33:40.801] plan(): Setting new future strategy stack:
[13:33:40.802] List of future strategies:
[13:33:40.802] 1. sequential:
[13:33:40.802]    - args: function (..., envir = parent.frame())
[13:33:40.802]    - tweaked: FALSE
[13:33:40.802]    - call: NULL
[13:33:40.802] plan(): nbrOfWorkers() = 1
[13:33:40.804] plan(): Setting new future strategy stack:
[13:33:40.804] List of future strategies:
[13:33:40.804] 1. sequential:
[13:33:40.804]    - args: function (..., envir = parent.frame())
[13:33:40.804]    - tweaked: FALSE
[13:33:40.804]    - call: plan(strategy)
[13:33:40.804] plan(): nbrOfWorkers() = 1
[13:33:40.804] SequentialFuture started (and completed)
[13:33:40.805] - Launch lazy future ... done
[13:33:40.805] run() for ‘SequentialFuture’ ... done
[13:33:40.805] Created future:
[13:33:40.805] SequentialFuture:
[13:33:40.805] Label: ‘future_by-1’
[13:33:40.805] Expression:
[13:33:40.805] {
[13:33:40.805]     do.call(function(...) {
[13:33:40.805]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.805]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:40.805]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.805]             on.exit(options(oopts), add = TRUE)
[13:33:40.805]         }
[13:33:40.805]         {
[13:33:40.805]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:40.805]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.805]                 ...future.FUN(...future.X_jj, ...)
[13:33:40.805]             })
[13:33:40.805]         }
[13:33:40.805]     }, args = future.call.arguments)
[13:33:40.805] }
[13:33:40.805] Lazy evaluation: FALSE
[13:33:40.805] Asynchronous evaluation: FALSE
[13:33:40.805] Local evaluation: TRUE
[13:33:40.805] Environment: 0x55cb822d6348
[13:33:40.805] Capture standard output: TRUE
[13:33:40.805] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:40.805] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:40.805] Packages: <none>
[13:33:40.805] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:40.805] Resolved: TRUE
[13:33:40.805] Value: 5.37 KiB of class ‘list’
[13:33:40.805] Early signaling: FALSE
[13:33:40.805] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:40.805] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:40.806] Chunk #1 of 1 ... DONE
[13:33:40.806] Launching 1 futures (chunks) ... DONE
[13:33:40.806] Resolving 1 futures (chunks) ...
[13:33:40.806] resolve() on list ...
[13:33:40.806]  recursive: 0
[13:33:40.806]  length: 1
[13:33:40.806] 
[13:33:40.807] resolved() for ‘SequentialFuture’ ...
[13:33:40.807] - state: ‘finished’
[13:33:40.807] - run: TRUE
[13:33:40.807] - result: ‘FutureResult’
[13:33:40.807] resolved() for ‘SequentialFuture’ ... done
[13:33:40.807] Future #1
[13:33:40.807] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:40.807] - nx: 1
[13:33:40.807] - relay: TRUE
[13:33:40.807] - stdout: TRUE
[13:33:40.807] - signal: TRUE
[13:33:40.808] - resignal: FALSE
[13:33:40.808] - force: TRUE
[13:33:40.808] - relayed: [n=1] FALSE
[13:33:40.808] - queued futures: [n=1] FALSE
[13:33:40.808]  - until=1
[13:33:40.808]  - relaying element #1
[13:33:40.808] - relayed: [n=1] TRUE
[13:33:40.808] - queued futures: [n=1] TRUE
[13:33:40.808] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:40.808]  length: 0 (resolved future 1)
[13:33:40.808] Relaying remaining futures
[13:33:40.809] signalConditionsASAP(NULL, pos=0) ...
[13:33:40.809] - nx: 1
[13:33:40.809] - relay: TRUE
[13:33:40.809] - stdout: TRUE
[13:33:40.809] - signal: TRUE
[13:33:40.809] - resignal: FALSE
[13:33:40.809] - force: TRUE
[13:33:40.809] - relayed: [n=1] TRUE
[13:33:40.809] - queued futures: [n=1] TRUE
 - flush all
[13:33:40.809] - relayed: [n=1] TRUE
[13:33:40.809] - queued futures: [n=1] TRUE
[13:33:40.809] signalConditionsASAP(NULL, pos=0) ... done
[13:33:40.810] resolve() on list ... DONE
[13:33:40.810]  - Number of value chunks collected: 1
[13:33:40.810] Resolving 1 futures (chunks) ... DONE
[13:33:40.810] Reducing values from 1 chunks ...
[13:33:40.810]  - Number of values collected after concatenation: 3
[13:33:40.810]  - Number of values expected: 3
[13:33:40.810] Reducing values from 1 chunks ... DONE
[13:33:40.810] future_lapply() ... DONE
[13:33:40.810] future_by_internal() ... DONE
[13:33:40.812] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[13:33:40.813] future_lapply() ...
[13:33:40.813] Number of chunks: 1
[13:33:40.813] getGlobalsAndPackagesXApply() ...
[13:33:40.813]  - future.globals: TRUE
[13:33:40.813] getGlobalsAndPackages() ...
[13:33:40.813] Searching for globals...
[13:33:40.814] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:40.814] Searching for globals ... DONE
[13:33:40.814] Resolving globals: FALSE
[13:33:40.815] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:40.815] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:40.815] - globals: [1] ‘FUN’
[13:33:40.815] 
[13:33:40.815] getGlobalsAndPackages() ... DONE
[13:33:40.815]  - globals found/used: [n=1] ‘FUN’
[13:33:40.816]  - needed namespaces: [n=0] 
[13:33:40.816] Finding globals ... DONE
[13:33:40.816]  - use_args: TRUE
[13:33:40.816]  - Getting '...' globals ...
[13:33:40.816] resolve() on list ...
[13:33:40.816]  recursive: 0
[13:33:40.816]  length: 1
[13:33:40.816]  elements: ‘...’
[13:33:40.816]  length: 0 (resolved future 1)
[13:33:40.817] resolve() on list ... DONE
[13:33:40.817]    - '...' content: [n=0] 
[13:33:40.817] List of 1
[13:33:40.817]  $ ...: list()
[13:33:40.817]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.817]  - attr(*, "where")=List of 1
[13:33:40.817]   ..$ ...:<environment: 0x55cb82482278> 
[13:33:40.817]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.817]  - attr(*, "resolved")= logi TRUE
[13:33:40.817]  - attr(*, "total_size")= num NA
[13:33:40.820]  - Getting '...' globals ... DONE
[13:33:40.820] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:40.820] List of 2
[13:33:40.820]  $ ...future.FUN:function (object, ...)  
[13:33:40.820]  $ ...          : list()
[13:33:40.820]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.820]  - attr(*, "where")=List of 2
[13:33:40.820]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:40.820]   ..$ ...          :<environment: 0x55cb82482278> 
[13:33:40.820]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.820]  - attr(*, "resolved")= logi FALSE
[13:33:40.820]  - attr(*, "total_size")= num 1240
[13:33:40.823] Packages to be attached in all futures: [n=0] 
[13:33:40.823] getGlobalsAndPackagesXApply() ... DONE
[13:33:40.823] Number of futures (= number of chunks): 1
[13:33:40.823] Launching 1 futures (chunks) ...
[13:33:40.823] Chunk #1 of 1 ...
[13:33:40.823]  - Finding globals in 'X' for chunk #1 ...
[13:33:40.823] getGlobalsAndPackages() ...
[13:33:40.823] Searching for globals...
[13:33:40.824] 
[13:33:40.824] Searching for globals ... DONE
[13:33:40.824] - globals: [0] <none>
[13:33:40.824] getGlobalsAndPackages() ... DONE
[13:33:40.824]    + additional globals found: [n=0] 
[13:33:40.824]    + additional namespaces needed: [n=0] 
[13:33:40.824]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:40.824]  - seeds: <none>
[13:33:40.824]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.825] getGlobalsAndPackages() ...
[13:33:40.825] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.825] Resolving globals: FALSE
[13:33:40.825] Tweak future expression to call with '...' arguments ...
[13:33:40.825] {
[13:33:40.825]     do.call(function(...) {
[13:33:40.825]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.825]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:40.825]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.825]             on.exit(options(oopts), add = TRUE)
[13:33:40.825]         }
[13:33:40.825]         {
[13:33:40.825]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:40.825]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.825]                 ...future.FUN(...future.X_jj, ...)
[13:33:40.825]             })
[13:33:40.825]         }
[13:33:40.825]     }, args = future.call.arguments)
[13:33:40.825] }
[13:33:40.825] Tweak future expression to call with '...' arguments ... DONE
[13:33:40.825] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.826] 
[13:33:40.826] getGlobalsAndPackages() ... DONE
[13:33:40.826] run() for ‘Future’ ...
[13:33:40.826] - state: ‘created’
[13:33:40.826] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:33:40.826] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:40.826] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:40.827]   - Field: ‘label’
[13:33:40.827]   - Field: ‘local’
[13:33:40.827]   - Field: ‘owner’
[13:33:40.827]   - Field: ‘envir’
[13:33:40.827]   - Field: ‘packages’
[13:33:40.827]   - Field: ‘gc’
[13:33:40.827]   - Field: ‘conditions’
[13:33:40.827]   - Field: ‘expr’
[13:33:40.827]   - Field: ‘uuid’
[13:33:40.827]   - Field: ‘seed’
[13:33:40.827]   - Field: ‘version’
[13:33:40.828]   - Field: ‘result’
[13:33:40.828]   - Field: ‘asynchronous’
[13:33:40.828]   - Field: ‘calls’
[13:33:40.828]   - Field: ‘globals’
[13:33:40.828]   - Field: ‘stdout’
[13:33:40.828]   - Field: ‘earlySignal’
[13:33:40.828]   - Field: ‘lazy’
[13:33:40.828]   - Field: ‘state’
[13:33:40.828] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:40.828] - Launch lazy future ...
[13:33:40.828] Packages needed by the future expression (n = 0): <none>
[13:33:40.829] Packages needed by future strategies (n = 0): <none>
[13:33:40.829] {
[13:33:40.829]     {
[13:33:40.829]         {
[13:33:40.829]             ...future.startTime <- base::Sys.time()
[13:33:40.829]             {
[13:33:40.829]                 {
[13:33:40.829]                   {
[13:33:40.829]                     base::local({
[13:33:40.829]                       has_future <- base::requireNamespace("future", 
[13:33:40.829]                         quietly = TRUE)
[13:33:40.829]                       if (has_future) {
[13:33:40.829]                         ns <- base::getNamespace("future")
[13:33:40.829]                         version <- ns[[".package"]][["version"]]
[13:33:40.829]                         if (is.null(version)) 
[13:33:40.829]                           version <- utils::packageVersion("future")
[13:33:40.829]                       }
[13:33:40.829]                       else {
[13:33:40.829]                         version <- NULL
[13:33:40.829]                       }
[13:33:40.829]                       if (!has_future || version < "1.8.0") {
[13:33:40.829]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:40.829]                           "", base::R.version$version.string), 
[13:33:40.829]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:40.829]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:40.829]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:40.829]                             "release", "version")], collapse = " "), 
[13:33:40.829]                           hostname = base::Sys.info()[["nodename"]])
[13:33:40.829]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:40.829]                           info)
[13:33:40.829]                         info <- base::paste(info, collapse = "; ")
[13:33:40.829]                         if (!has_future) {
[13:33:40.829]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:40.829]                             info)
[13:33:40.829]                         }
[13:33:40.829]                         else {
[13:33:40.829]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:40.829]                             info, version)
[13:33:40.829]                         }
[13:33:40.829]                         base::stop(msg)
[13:33:40.829]                       }
[13:33:40.829]                     })
[13:33:40.829]                   }
[13:33:40.829]                   ...future.strategy.old <- future::plan("list")
[13:33:40.829]                   options(future.plan = NULL)
[13:33:40.829]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:40.829]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:40.829]                 }
[13:33:40.829]                 ...future.workdir <- getwd()
[13:33:40.829]             }
[13:33:40.829]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:40.829]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:40.829]         }
[13:33:40.829]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:40.829]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:40.829]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:40.829]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:40.829]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:40.829]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:40.829]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:40.829]             base::names(...future.oldOptions))
[13:33:40.829]     }
[13:33:40.829]     if (FALSE) {
[13:33:40.829]     }
[13:33:40.829]     else {
[13:33:40.829]         if (TRUE) {
[13:33:40.829]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:40.829]                 open = "w")
[13:33:40.829]         }
[13:33:40.829]         else {
[13:33:40.829]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:40.829]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:40.829]         }
[13:33:40.829]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:40.829]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:40.829]             base::sink(type = "output", split = FALSE)
[13:33:40.829]             base::close(...future.stdout)
[13:33:40.829]         }, add = TRUE)
[13:33:40.829]     }
[13:33:40.829]     ...future.frame <- base::sys.nframe()
[13:33:40.829]     ...future.conditions <- base::list()
[13:33:40.829]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:40.829]     if (FALSE) {
[13:33:40.829]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:40.829]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:40.829]     }
[13:33:40.829]     ...future.result <- base::tryCatch({
[13:33:40.829]         base::withCallingHandlers({
[13:33:40.829]             ...future.value <- base::withVisible(base::local({
[13:33:40.829]                 do.call(function(...) {
[13:33:40.829]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.829]                   if (!identical(...future.globals.maxSize.org, 
[13:33:40.829]                     ...future.globals.maxSize)) {
[13:33:40.829]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.829]                     on.exit(options(oopts), add = TRUE)
[13:33:40.829]                   }
[13:33:40.829]                   {
[13:33:40.829]                     lapply(seq_along(...future.elements_ii), 
[13:33:40.829]                       FUN = function(jj) {
[13:33:40.829]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.829]                         ...future.FUN(...future.X_jj, ...)
[13:33:40.829]                       })
[13:33:40.829]                   }
[13:33:40.829]                 }, args = future.call.arguments)
[13:33:40.829]             }))
[13:33:40.829]             future::FutureResult(value = ...future.value$value, 
[13:33:40.829]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:40.829]                   ...future.rng), globalenv = if (FALSE) 
[13:33:40.829]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:40.829]                     ...future.globalenv.names))
[13:33:40.829]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:40.829]         }, condition = base::local({
[13:33:40.829]             c <- base::c
[13:33:40.829]             inherits <- base::inherits
[13:33:40.829]             invokeRestart <- base::invokeRestart
[13:33:40.829]             length <- base::length
[13:33:40.829]             list <- base::list
[13:33:40.829]             seq.int <- base::seq.int
[13:33:40.829]             signalCondition <- base::signalCondition
[13:33:40.829]             sys.calls <- base::sys.calls
[13:33:40.829]             `[[` <- base::`[[`
[13:33:40.829]             `+` <- base::`+`
[13:33:40.829]             `<<-` <- base::`<<-`
[13:33:40.829]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:40.829]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:40.829]                   3L)]
[13:33:40.829]             }
[13:33:40.829]             function(cond) {
[13:33:40.829]                 is_error <- inherits(cond, "error")
[13:33:40.829]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:40.829]                   NULL)
[13:33:40.829]                 if (is_error) {
[13:33:40.829]                   sessionInformation <- function() {
[13:33:40.829]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:40.829]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:40.829]                       search = base::search(), system = base::Sys.info())
[13:33:40.829]                   }
[13:33:40.829]                   ...future.conditions[[length(...future.conditions) + 
[13:33:40.829]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:40.829]                     cond$call), session = sessionInformation(), 
[13:33:40.829]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:40.829]                   signalCondition(cond)
[13:33:40.829]                 }
[13:33:40.829]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:40.829]                 "immediateCondition"))) {
[13:33:40.829]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:40.829]                   ...future.conditions[[length(...future.conditions) + 
[13:33:40.829]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:40.829]                   if (TRUE && !signal) {
[13:33:40.829]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:40.829]                     {
[13:33:40.829]                       inherits <- base::inherits
[13:33:40.829]                       invokeRestart <- base::invokeRestart
[13:33:40.829]                       is.null <- base::is.null
[13:33:40.829]                       muffled <- FALSE
[13:33:40.829]                       if (inherits(cond, "message")) {
[13:33:40.829]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:40.829]                         if (muffled) 
[13:33:40.829]                           invokeRestart("muffleMessage")
[13:33:40.829]                       }
[13:33:40.829]                       else if (inherits(cond, "warning")) {
[13:33:40.829]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:40.829]                         if (muffled) 
[13:33:40.829]                           invokeRestart("muffleWarning")
[13:33:40.829]                       }
[13:33:40.829]                       else if (inherits(cond, "condition")) {
[13:33:40.829]                         if (!is.null(pattern)) {
[13:33:40.829]                           computeRestarts <- base::computeRestarts
[13:33:40.829]                           grepl <- base::grepl
[13:33:40.829]                           restarts <- computeRestarts(cond)
[13:33:40.829]                           for (restart in restarts) {
[13:33:40.829]                             name <- restart$name
[13:33:40.829]                             if (is.null(name)) 
[13:33:40.829]                               next
[13:33:40.829]                             if (!grepl(pattern, name)) 
[13:33:40.829]                               next
[13:33:40.829]                             invokeRestart(restart)
[13:33:40.829]                             muffled <- TRUE
[13:33:40.829]                             break
[13:33:40.829]                           }
[13:33:40.829]                         }
[13:33:40.829]                       }
[13:33:40.829]                       invisible(muffled)
[13:33:40.829]                     }
[13:33:40.829]                     muffleCondition(cond, pattern = "^muffle")
[13:33:40.829]                   }
[13:33:40.829]                 }
[13:33:40.829]                 else {
[13:33:40.829]                   if (TRUE) {
[13:33:40.829]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:40.829]                     {
[13:33:40.829]                       inherits <- base::inherits
[13:33:40.829]                       invokeRestart <- base::invokeRestart
[13:33:40.829]                       is.null <- base::is.null
[13:33:40.829]                       muffled <- FALSE
[13:33:40.829]                       if (inherits(cond, "message")) {
[13:33:40.829]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:40.829]                         if (muffled) 
[13:33:40.829]                           invokeRestart("muffleMessage")
[13:33:40.829]                       }
[13:33:40.829]                       else if (inherits(cond, "warning")) {
[13:33:40.829]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:40.829]                         if (muffled) 
[13:33:40.829]                           invokeRestart("muffleWarning")
[13:33:40.829]                       }
[13:33:40.829]                       else if (inherits(cond, "condition")) {
[13:33:40.829]                         if (!is.null(pattern)) {
[13:33:40.829]                           computeRestarts <- base::computeRestarts
[13:33:40.829]                           grepl <- base::grepl
[13:33:40.829]                           restarts <- computeRestarts(cond)
[13:33:40.829]                           for (restart in restarts) {
[13:33:40.829]                             name <- restart$name
[13:33:40.829]                             if (is.null(name)) 
[13:33:40.829]                               next
[13:33:40.829]                             if (!grepl(pattern, name)) 
[13:33:40.829]                               next
[13:33:40.829]                             invokeRestart(restart)
[13:33:40.829]                             muffled <- TRUE
[13:33:40.829]                             break
[13:33:40.829]                           }
[13:33:40.829]                         }
[13:33:40.829]                       }
[13:33:40.829]                       invisible(muffled)
[13:33:40.829]                     }
[13:33:40.829]                     muffleCondition(cond, pattern = "^muffle")
[13:33:40.829]                   }
[13:33:40.829]                 }
[13:33:40.829]             }
[13:33:40.829]         }))
[13:33:40.829]     }, error = function(ex) {
[13:33:40.829]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:40.829]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:40.829]                 ...future.rng), started = ...future.startTime, 
[13:33:40.829]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:40.829]             version = "1.8"), class = "FutureResult")
[13:33:40.829]     }, finally = {
[13:33:40.829]         if (!identical(...future.workdir, getwd())) 
[13:33:40.829]             setwd(...future.workdir)
[13:33:40.829]         {
[13:33:40.829]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:40.829]                 ...future.oldOptions$nwarnings <- NULL
[13:33:40.829]             }
[13:33:40.829]             base::options(...future.oldOptions)
[13:33:40.829]             if (.Platform$OS.type == "windows") {
[13:33:40.829]                 old_names <- names(...future.oldEnvVars)
[13:33:40.829]                 envs <- base::Sys.getenv()
[13:33:40.829]                 names <- names(envs)
[13:33:40.829]                 common <- intersect(names, old_names)
[13:33:40.829]                 added <- setdiff(names, old_names)
[13:33:40.829]                 removed <- setdiff(old_names, names)
[13:33:40.829]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:40.829]                   envs[common]]
[13:33:40.829]                 NAMES <- toupper(changed)
[13:33:40.829]                 args <- list()
[13:33:40.829]                 for (kk in seq_along(NAMES)) {
[13:33:40.829]                   name <- changed[[kk]]
[13:33:40.829]                   NAME <- NAMES[[kk]]
[13:33:40.829]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.829]                     next
[13:33:40.829]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:40.829]                 }
[13:33:40.829]                 NAMES <- toupper(added)
[13:33:40.829]                 for (kk in seq_along(NAMES)) {
[13:33:40.829]                   name <- added[[kk]]
[13:33:40.829]                   NAME <- NAMES[[kk]]
[13:33:40.829]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.829]                     next
[13:33:40.829]                   args[[name]] <- ""
[13:33:40.829]                 }
[13:33:40.829]                 NAMES <- toupper(removed)
[13:33:40.829]                 for (kk in seq_along(NAMES)) {
[13:33:40.829]                   name <- removed[[kk]]
[13:33:40.829]                   NAME <- NAMES[[kk]]
[13:33:40.829]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.829]                     next
[13:33:40.829]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:40.829]                 }
[13:33:40.829]                 if (length(args) > 0) 
[13:33:40.829]                   base::do.call(base::Sys.setenv, args = args)
[13:33:40.829]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:40.829]             }
[13:33:40.829]             else {
[13:33:40.829]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:40.829]             }
[13:33:40.829]             {
[13:33:40.829]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:40.829]                   0L) {
[13:33:40.829]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:40.829]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:40.829]                   base::options(opts)
[13:33:40.829]                 }
[13:33:40.829]                 {
[13:33:40.829]                   {
[13:33:40.829]                     NULL
[13:33:40.829]                     RNGkind("Mersenne-Twister")
[13:33:40.829]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:40.829]                       inherits = FALSE)
[13:33:40.829]                   }
[13:33:40.829]                   options(future.plan = NULL)
[13:33:40.829]                   if (is.na(NA_character_)) 
[13:33:40.829]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:40.829]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:40.829]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:40.829]                     .init = FALSE)
[13:33:40.829]                 }
[13:33:40.829]             }
[13:33:40.829]         }
[13:33:40.829]     })
[13:33:40.829]     if (TRUE) {
[13:33:40.829]         base::sink(type = "output", split = FALSE)
[13:33:40.829]         if (TRUE) {
[13:33:40.829]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:40.829]         }
[13:33:40.829]         else {
[13:33:40.829]             ...future.result["stdout"] <- base::list(NULL)
[13:33:40.829]         }
[13:33:40.829]         base::close(...future.stdout)
[13:33:40.829]         ...future.stdout <- NULL
[13:33:40.829]     }
[13:33:40.829]     ...future.result$conditions <- ...future.conditions
[13:33:40.829]     ...future.result$finished <- base::Sys.time()
[13:33:40.829]     ...future.result
[13:33:40.829] }
[13:33:40.831] assign_globals() ...
[13:33:40.831] List of 5
[13:33:40.831]  $ ...future.FUN            :function (object, ...)  
[13:33:40.831]  $ future.call.arguments    : list()
[13:33:40.831]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.831]  $ ...future.elements_ii    :List of 3
[13:33:40.831]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:40.831]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:33:40.831]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:40.831]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:40.831]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:40.831]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:33:40.831]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:40.831]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:33:40.831]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:40.831]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:33:40.831]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:40.831]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:33:40.831]  $ ...future.seeds_ii       : NULL
[13:33:40.831]  $ ...future.globals.maxSize: NULL
[13:33:40.831]  - attr(*, "where")=List of 5
[13:33:40.831]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:40.831]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:40.831]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:40.831]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:40.831]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:40.831]  - attr(*, "resolved")= logi FALSE
[13:33:40.831]  - attr(*, "total_size")= num 1240
[13:33:40.831]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.831]  - attr(*, "already-done")= logi TRUE
[13:33:40.839] - copied ‘...future.FUN’ to environment
[13:33:40.839] - copied ‘future.call.arguments’ to environment
[13:33:40.839] - copied ‘...future.elements_ii’ to environment
[13:33:40.840] - copied ‘...future.seeds_ii’ to environment
[13:33:40.840] - copied ‘...future.globals.maxSize’ to environment
[13:33:40.840] assign_globals() ... done
[13:33:40.840] plan(): Setting new future strategy stack:
[13:33:40.840] List of future strategies:
[13:33:40.840] 1. sequential:
[13:33:40.840]    - args: function (..., envir = parent.frame())
[13:33:40.840]    - tweaked: FALSE
[13:33:40.840]    - call: NULL
[13:33:40.840] plan(): nbrOfWorkers() = 1
[13:33:40.842] plan(): Setting new future strategy stack:
[13:33:40.842] List of future strategies:
[13:33:40.842] 1. sequential:
[13:33:40.842]    - args: function (..., envir = parent.frame())
[13:33:40.842]    - tweaked: FALSE
[13:33:40.842]    - call: plan(strategy)
[13:33:40.843] plan(): nbrOfWorkers() = 1
[13:33:40.843] SequentialFuture started (and completed)
[13:33:40.843] - Launch lazy future ... done
[13:33:40.843] run() for ‘SequentialFuture’ ... done
[13:33:40.843] Created future:
[13:33:40.843] SequentialFuture:
[13:33:40.843] Label: ‘future_by-1’
[13:33:40.843] Expression:
[13:33:40.843] {
[13:33:40.843]     do.call(function(...) {
[13:33:40.843]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.843]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:40.843]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.843]             on.exit(options(oopts), add = TRUE)
[13:33:40.843]         }
[13:33:40.843]         {
[13:33:40.843]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:40.843]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.843]                 ...future.FUN(...future.X_jj, ...)
[13:33:40.843]             })
[13:33:40.843]         }
[13:33:40.843]     }, args = future.call.arguments)
[13:33:40.843] }
[13:33:40.843] Lazy evaluation: FALSE
[13:33:40.843] Asynchronous evaluation: FALSE
[13:33:40.843] Local evaluation: TRUE
[13:33:40.843] Environment: 0x55cb822e3fc8
[13:33:40.843] Capture standard output: TRUE
[13:33:40.843] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:40.843] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:40.843] Packages: <none>
[13:33:40.843] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:40.843] Resolved: TRUE
[13:33:40.843] Value: 5.37 KiB of class ‘list’
[13:33:40.843] Early signaling: FALSE
[13:33:40.843] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:40.843] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:40.844] Chunk #1 of 1 ... DONE
[13:33:40.845] Launching 1 futures (chunks) ... DONE
[13:33:40.845] Resolving 1 futures (chunks) ...
[13:33:40.845] resolve() on list ...
[13:33:40.845]  recursive: 0
[13:33:40.845]  length: 1
[13:33:40.845] 
[13:33:40.845] resolved() for ‘SequentialFuture’ ...
[13:33:40.845] - state: ‘finished’
[13:33:40.845] - run: TRUE
[13:33:40.845] - result: ‘FutureResult’
[13:33:40.845] resolved() for ‘SequentialFuture’ ... done
[13:33:40.846] Future #1
[13:33:40.846] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:40.846] - nx: 1
[13:33:40.846] - relay: TRUE
[13:33:40.846] - stdout: TRUE
[13:33:40.846] - signal: TRUE
[13:33:40.846] - resignal: FALSE
[13:33:40.846] - force: TRUE
[13:33:40.846] - relayed: [n=1] FALSE
[13:33:40.846] - queued futures: [n=1] FALSE
[13:33:40.846]  - until=1
[13:33:40.847]  - relaying element #1
[13:33:40.847] - relayed: [n=1] TRUE
[13:33:40.847] - queued futures: [n=1] TRUE
[13:33:40.847] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:40.847]  length: 0 (resolved future 1)
[13:33:40.847] Relaying remaining futures
[13:33:40.847] signalConditionsASAP(NULL, pos=0) ...
[13:33:40.847] - nx: 1
[13:33:40.847] - relay: TRUE
[13:33:40.847] - stdout: TRUE
[13:33:40.847] - signal: TRUE
[13:33:40.847] - resignal: FALSE
[13:33:40.848] - force: TRUE
[13:33:40.848] - relayed: [n=1] TRUE
[13:33:40.848] - queued futures: [n=1] TRUE
 - flush all
[13:33:40.848] - relayed: [n=1] TRUE
[13:33:40.848] - queued futures: [n=1] TRUE
[13:33:40.848] signalConditionsASAP(NULL, pos=0) ... done
[13:33:40.848] resolve() on list ... DONE
[13:33:40.848]  - Number of value chunks collected: 1
[13:33:40.848] Resolving 1 futures (chunks) ... DONE
[13:33:40.848] Reducing values from 1 chunks ...
[13:33:40.848]  - Number of values collected after concatenation: 3
[13:33:40.849]  - Number of values expected: 3
[13:33:40.849] Reducing values from 1 chunks ... DONE
[13:33:40.849] future_lapply() ... DONE
[13:33:40.849] future_by_internal() ... DONE
[13:33:40.850] future_by_internal() ...
- plan('multicore') ...
[13:33:40.850] plan(): Setting new future strategy stack:
[13:33:40.850] List of future strategies:
[13:33:40.850] 1. multicore:
[13:33:40.850]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:40.850]    - tweaked: FALSE
[13:33:40.850]    - call: plan(strategy)
[13:33:40.854] plan(): nbrOfWorkers() = 1
[13:33:40.854] future_by_internal() ...
[13:33:40.854] future_lapply() ...
[13:33:40.858] Number of chunks: 1
[13:33:40.858] getGlobalsAndPackagesXApply() ...
[13:33:40.858]  - future.globals: TRUE
[13:33:40.858] getGlobalsAndPackages() ...
[13:33:40.858] Searching for globals...
[13:33:40.859] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:40.859] Searching for globals ... DONE
[13:33:40.860] Resolving globals: FALSE
[13:33:40.860] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:40.861] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:40.861] - globals: [1] ‘FUN’
[13:33:40.861] 
[13:33:40.862] getGlobalsAndPackages() ... DONE
[13:33:40.862]  - globals found/used: [n=1] ‘FUN’
[13:33:40.862]  - needed namespaces: [n=0] 
[13:33:40.862] Finding globals ... DONE
[13:33:40.862]  - use_args: TRUE
[13:33:40.862]  - Getting '...' globals ...
[13:33:40.862] resolve() on list ...
[13:33:40.862]  recursive: 0
[13:33:40.862]  length: 1
[13:33:40.863]  elements: ‘...’
[13:33:40.863]  length: 0 (resolved future 1)
[13:33:40.863] resolve() on list ... DONE
[13:33:40.863]    - '...' content: [n=0] 
[13:33:40.863] List of 1
[13:33:40.863]  $ ...: list()
[13:33:40.863]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.863]  - attr(*, "where")=List of 1
[13:33:40.863]   ..$ ...:<environment: 0x55cb8262a3d0> 
[13:33:40.863]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.863]  - attr(*, "resolved")= logi TRUE
[13:33:40.863]  - attr(*, "total_size")= num NA
[13:33:40.865]  - Getting '...' globals ... DONE
[13:33:40.865] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:40.865] List of 2
[13:33:40.865]  $ ...future.FUN:function (object, ...)  
[13:33:40.865]  $ ...          : list()
[13:33:40.865]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.865]  - attr(*, "where")=List of 2
[13:33:40.865]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:40.865]   ..$ ...          :<environment: 0x55cb8262a3d0> 
[13:33:40.865]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.865]  - attr(*, "resolved")= logi FALSE
[13:33:40.865]  - attr(*, "total_size")= num 1240
[13:33:40.868] Packages to be attached in all futures: [n=0] 
[13:33:40.868] getGlobalsAndPackagesXApply() ... DONE
[13:33:40.868] Number of futures (= number of chunks): 1
[13:33:40.868] Launching 1 futures (chunks) ...
[13:33:40.868] Chunk #1 of 1 ...
[13:33:40.869]  - Finding globals in 'X' for chunk #1 ...
[13:33:40.869] getGlobalsAndPackages() ...
[13:33:40.869] Searching for globals...
[13:33:40.869] 
[13:33:40.869] Searching for globals ... DONE
[13:33:40.869] - globals: [0] <none>
[13:33:40.869] getGlobalsAndPackages() ... DONE
[13:33:40.869]    + additional globals found: [n=0] 
[13:33:40.870]    + additional namespaces needed: [n=0] 
[13:33:40.870]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:40.870]  - seeds: <none>
[13:33:40.870]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.870] getGlobalsAndPackages() ...
[13:33:40.870] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.870] Resolving globals: FALSE
[13:33:40.870] Tweak future expression to call with '...' arguments ...
[13:33:40.870] {
[13:33:40.870]     do.call(function(...) {
[13:33:40.870]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.870]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:40.870]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.870]             on.exit(options(oopts), add = TRUE)
[13:33:40.870]         }
[13:33:40.870]         {
[13:33:40.870]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:40.870]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.870]                 ...future.FUN(...future.X_jj, ...)
[13:33:40.870]             })
[13:33:40.870]         }
[13:33:40.870]     }, args = future.call.arguments)
[13:33:40.870] }
[13:33:40.871] Tweak future expression to call with '...' arguments ... DONE
[13:33:40.871] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.871] 
[13:33:40.871] getGlobalsAndPackages() ... DONE
[13:33:40.871] run() for ‘Future’ ...
[13:33:40.871] - state: ‘created’
[13:33:40.872] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:40.875] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:40.875] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:40.875]   - Field: ‘label’
[13:33:40.875]   - Field: ‘local’
[13:33:40.875]   - Field: ‘owner’
[13:33:40.875]   - Field: ‘envir’
[13:33:40.875]   - Field: ‘packages’
[13:33:40.875]   - Field: ‘gc’
[13:33:40.876]   - Field: ‘conditions’
[13:33:40.876]   - Field: ‘expr’
[13:33:40.876]   - Field: ‘uuid’
[13:33:40.876]   - Field: ‘seed’
[13:33:40.876]   - Field: ‘version’
[13:33:40.876]   - Field: ‘result’
[13:33:40.876]   - Field: ‘asynchronous’
[13:33:40.876]   - Field: ‘calls’
[13:33:40.876]   - Field: ‘globals’
[13:33:40.876]   - Field: ‘stdout’
[13:33:40.876]   - Field: ‘earlySignal’
[13:33:40.877]   - Field: ‘lazy’
[13:33:40.877]   - Field: ‘state’
[13:33:40.877] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:40.877] - Launch lazy future ...
[13:33:40.877] Packages needed by the future expression (n = 0): <none>
[13:33:40.877] Packages needed by future strategies (n = 0): <none>
[13:33:40.878] {
[13:33:40.878]     {
[13:33:40.878]         {
[13:33:40.878]             ...future.startTime <- base::Sys.time()
[13:33:40.878]             {
[13:33:40.878]                 {
[13:33:40.878]                   {
[13:33:40.878]                     base::local({
[13:33:40.878]                       has_future <- base::requireNamespace("future", 
[13:33:40.878]                         quietly = TRUE)
[13:33:40.878]                       if (has_future) {
[13:33:40.878]                         ns <- base::getNamespace("future")
[13:33:40.878]                         version <- ns[[".package"]][["version"]]
[13:33:40.878]                         if (is.null(version)) 
[13:33:40.878]                           version <- utils::packageVersion("future")
[13:33:40.878]                       }
[13:33:40.878]                       else {
[13:33:40.878]                         version <- NULL
[13:33:40.878]                       }
[13:33:40.878]                       if (!has_future || version < "1.8.0") {
[13:33:40.878]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:40.878]                           "", base::R.version$version.string), 
[13:33:40.878]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:40.878]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:40.878]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:40.878]                             "release", "version")], collapse = " "), 
[13:33:40.878]                           hostname = base::Sys.info()[["nodename"]])
[13:33:40.878]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:40.878]                           info)
[13:33:40.878]                         info <- base::paste(info, collapse = "; ")
[13:33:40.878]                         if (!has_future) {
[13:33:40.878]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:40.878]                             info)
[13:33:40.878]                         }
[13:33:40.878]                         else {
[13:33:40.878]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:40.878]                             info, version)
[13:33:40.878]                         }
[13:33:40.878]                         base::stop(msg)
[13:33:40.878]                       }
[13:33:40.878]                     })
[13:33:40.878]                   }
[13:33:40.878]                   ...future.strategy.old <- future::plan("list")
[13:33:40.878]                   options(future.plan = NULL)
[13:33:40.878]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:40.878]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:40.878]                 }
[13:33:40.878]                 ...future.workdir <- getwd()
[13:33:40.878]             }
[13:33:40.878]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:40.878]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:40.878]         }
[13:33:40.878]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:40.878]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:40.878]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:40.878]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:40.878]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:40.878]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:40.878]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:40.878]             base::names(...future.oldOptions))
[13:33:40.878]     }
[13:33:40.878]     if (FALSE) {
[13:33:40.878]     }
[13:33:40.878]     else {
[13:33:40.878]         if (TRUE) {
[13:33:40.878]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:40.878]                 open = "w")
[13:33:40.878]         }
[13:33:40.878]         else {
[13:33:40.878]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:40.878]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:40.878]         }
[13:33:40.878]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:40.878]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:40.878]             base::sink(type = "output", split = FALSE)
[13:33:40.878]             base::close(...future.stdout)
[13:33:40.878]         }, add = TRUE)
[13:33:40.878]     }
[13:33:40.878]     ...future.frame <- base::sys.nframe()
[13:33:40.878]     ...future.conditions <- base::list()
[13:33:40.878]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:40.878]     if (FALSE) {
[13:33:40.878]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:40.878]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:40.878]     }
[13:33:40.878]     ...future.result <- base::tryCatch({
[13:33:40.878]         base::withCallingHandlers({
[13:33:40.878]             ...future.value <- base::withVisible(base::local({
[13:33:40.878]                 do.call(function(...) {
[13:33:40.878]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.878]                   if (!identical(...future.globals.maxSize.org, 
[13:33:40.878]                     ...future.globals.maxSize)) {
[13:33:40.878]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.878]                     on.exit(options(oopts), add = TRUE)
[13:33:40.878]                   }
[13:33:40.878]                   {
[13:33:40.878]                     lapply(seq_along(...future.elements_ii), 
[13:33:40.878]                       FUN = function(jj) {
[13:33:40.878]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.878]                         ...future.FUN(...future.X_jj, ...)
[13:33:40.878]                       })
[13:33:40.878]                   }
[13:33:40.878]                 }, args = future.call.arguments)
[13:33:40.878]             }))
[13:33:40.878]             future::FutureResult(value = ...future.value$value, 
[13:33:40.878]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:40.878]                   ...future.rng), globalenv = if (FALSE) 
[13:33:40.878]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:40.878]                     ...future.globalenv.names))
[13:33:40.878]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:40.878]         }, condition = base::local({
[13:33:40.878]             c <- base::c
[13:33:40.878]             inherits <- base::inherits
[13:33:40.878]             invokeRestart <- base::invokeRestart
[13:33:40.878]             length <- base::length
[13:33:40.878]             list <- base::list
[13:33:40.878]             seq.int <- base::seq.int
[13:33:40.878]             signalCondition <- base::signalCondition
[13:33:40.878]             sys.calls <- base::sys.calls
[13:33:40.878]             `[[` <- base::`[[`
[13:33:40.878]             `+` <- base::`+`
[13:33:40.878]             `<<-` <- base::`<<-`
[13:33:40.878]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:40.878]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:40.878]                   3L)]
[13:33:40.878]             }
[13:33:40.878]             function(cond) {
[13:33:40.878]                 is_error <- inherits(cond, "error")
[13:33:40.878]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:40.878]                   NULL)
[13:33:40.878]                 if (is_error) {
[13:33:40.878]                   sessionInformation <- function() {
[13:33:40.878]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:40.878]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:40.878]                       search = base::search(), system = base::Sys.info())
[13:33:40.878]                   }
[13:33:40.878]                   ...future.conditions[[length(...future.conditions) + 
[13:33:40.878]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:40.878]                     cond$call), session = sessionInformation(), 
[13:33:40.878]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:40.878]                   signalCondition(cond)
[13:33:40.878]                 }
[13:33:40.878]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:40.878]                 "immediateCondition"))) {
[13:33:40.878]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:40.878]                   ...future.conditions[[length(...future.conditions) + 
[13:33:40.878]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:40.878]                   if (TRUE && !signal) {
[13:33:40.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:40.878]                     {
[13:33:40.878]                       inherits <- base::inherits
[13:33:40.878]                       invokeRestart <- base::invokeRestart
[13:33:40.878]                       is.null <- base::is.null
[13:33:40.878]                       muffled <- FALSE
[13:33:40.878]                       if (inherits(cond, "message")) {
[13:33:40.878]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:40.878]                         if (muffled) 
[13:33:40.878]                           invokeRestart("muffleMessage")
[13:33:40.878]                       }
[13:33:40.878]                       else if (inherits(cond, "warning")) {
[13:33:40.878]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:40.878]                         if (muffled) 
[13:33:40.878]                           invokeRestart("muffleWarning")
[13:33:40.878]                       }
[13:33:40.878]                       else if (inherits(cond, "condition")) {
[13:33:40.878]                         if (!is.null(pattern)) {
[13:33:40.878]                           computeRestarts <- base::computeRestarts
[13:33:40.878]                           grepl <- base::grepl
[13:33:40.878]                           restarts <- computeRestarts(cond)
[13:33:40.878]                           for (restart in restarts) {
[13:33:40.878]                             name <- restart$name
[13:33:40.878]                             if (is.null(name)) 
[13:33:40.878]                               next
[13:33:40.878]                             if (!grepl(pattern, name)) 
[13:33:40.878]                               next
[13:33:40.878]                             invokeRestart(restart)
[13:33:40.878]                             muffled <- TRUE
[13:33:40.878]                             break
[13:33:40.878]                           }
[13:33:40.878]                         }
[13:33:40.878]                       }
[13:33:40.878]                       invisible(muffled)
[13:33:40.878]                     }
[13:33:40.878]                     muffleCondition(cond, pattern = "^muffle")
[13:33:40.878]                   }
[13:33:40.878]                 }
[13:33:40.878]                 else {
[13:33:40.878]                   if (TRUE) {
[13:33:40.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:40.878]                     {
[13:33:40.878]                       inherits <- base::inherits
[13:33:40.878]                       invokeRestart <- base::invokeRestart
[13:33:40.878]                       is.null <- base::is.null
[13:33:40.878]                       muffled <- FALSE
[13:33:40.878]                       if (inherits(cond, "message")) {
[13:33:40.878]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:40.878]                         if (muffled) 
[13:33:40.878]                           invokeRestart("muffleMessage")
[13:33:40.878]                       }
[13:33:40.878]                       else if (inherits(cond, "warning")) {
[13:33:40.878]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:40.878]                         if (muffled) 
[13:33:40.878]                           invokeRestart("muffleWarning")
[13:33:40.878]                       }
[13:33:40.878]                       else if (inherits(cond, "condition")) {
[13:33:40.878]                         if (!is.null(pattern)) {
[13:33:40.878]                           computeRestarts <- base::computeRestarts
[13:33:40.878]                           grepl <- base::grepl
[13:33:40.878]                           restarts <- computeRestarts(cond)
[13:33:40.878]                           for (restart in restarts) {
[13:33:40.878]                             name <- restart$name
[13:33:40.878]                             if (is.null(name)) 
[13:33:40.878]                               next
[13:33:40.878]                             if (!grepl(pattern, name)) 
[13:33:40.878]                               next
[13:33:40.878]                             invokeRestart(restart)
[13:33:40.878]                             muffled <- TRUE
[13:33:40.878]                             break
[13:33:40.878]                           }
[13:33:40.878]                         }
[13:33:40.878]                       }
[13:33:40.878]                       invisible(muffled)
[13:33:40.878]                     }
[13:33:40.878]                     muffleCondition(cond, pattern = "^muffle")
[13:33:40.878]                   }
[13:33:40.878]                 }
[13:33:40.878]             }
[13:33:40.878]         }))
[13:33:40.878]     }, error = function(ex) {
[13:33:40.878]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:40.878]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:40.878]                 ...future.rng), started = ...future.startTime, 
[13:33:40.878]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:40.878]             version = "1.8"), class = "FutureResult")
[13:33:40.878]     }, finally = {
[13:33:40.878]         if (!identical(...future.workdir, getwd())) 
[13:33:40.878]             setwd(...future.workdir)
[13:33:40.878]         {
[13:33:40.878]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:40.878]                 ...future.oldOptions$nwarnings <- NULL
[13:33:40.878]             }
[13:33:40.878]             base::options(...future.oldOptions)
[13:33:40.878]             if (.Platform$OS.type == "windows") {
[13:33:40.878]                 old_names <- names(...future.oldEnvVars)
[13:33:40.878]                 envs <- base::Sys.getenv()
[13:33:40.878]                 names <- names(envs)
[13:33:40.878]                 common <- intersect(names, old_names)
[13:33:40.878]                 added <- setdiff(names, old_names)
[13:33:40.878]                 removed <- setdiff(old_names, names)
[13:33:40.878]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:40.878]                   envs[common]]
[13:33:40.878]                 NAMES <- toupper(changed)
[13:33:40.878]                 args <- list()
[13:33:40.878]                 for (kk in seq_along(NAMES)) {
[13:33:40.878]                   name <- changed[[kk]]
[13:33:40.878]                   NAME <- NAMES[[kk]]
[13:33:40.878]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.878]                     next
[13:33:40.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:40.878]                 }
[13:33:40.878]                 NAMES <- toupper(added)
[13:33:40.878]                 for (kk in seq_along(NAMES)) {
[13:33:40.878]                   name <- added[[kk]]
[13:33:40.878]                   NAME <- NAMES[[kk]]
[13:33:40.878]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.878]                     next
[13:33:40.878]                   args[[name]] <- ""
[13:33:40.878]                 }
[13:33:40.878]                 NAMES <- toupper(removed)
[13:33:40.878]                 for (kk in seq_along(NAMES)) {
[13:33:40.878]                   name <- removed[[kk]]
[13:33:40.878]                   NAME <- NAMES[[kk]]
[13:33:40.878]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.878]                     next
[13:33:40.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:40.878]                 }
[13:33:40.878]                 if (length(args) > 0) 
[13:33:40.878]                   base::do.call(base::Sys.setenv, args = args)
[13:33:40.878]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:40.878]             }
[13:33:40.878]             else {
[13:33:40.878]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:40.878]             }
[13:33:40.878]             {
[13:33:40.878]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:40.878]                   0L) {
[13:33:40.878]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:40.878]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:40.878]                   base::options(opts)
[13:33:40.878]                 }
[13:33:40.878]                 {
[13:33:40.878]                   {
[13:33:40.878]                     NULL
[13:33:40.878]                     RNGkind("Mersenne-Twister")
[13:33:40.878]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:40.878]                       inherits = FALSE)
[13:33:40.878]                   }
[13:33:40.878]                   options(future.plan = NULL)
[13:33:40.878]                   if (is.na(NA_character_)) 
[13:33:40.878]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:40.878]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:40.878]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:40.878]                     .init = FALSE)
[13:33:40.878]                 }
[13:33:40.878]             }
[13:33:40.878]         }
[13:33:40.878]     })
[13:33:40.878]     if (TRUE) {
[13:33:40.878]         base::sink(type = "output", split = FALSE)
[13:33:40.878]         if (TRUE) {
[13:33:40.878]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:40.878]         }
[13:33:40.878]         else {
[13:33:40.878]             ...future.result["stdout"] <- base::list(NULL)
[13:33:40.878]         }
[13:33:40.878]         base::close(...future.stdout)
[13:33:40.878]         ...future.stdout <- NULL
[13:33:40.878]     }
[13:33:40.878]     ...future.result$conditions <- ...future.conditions
[13:33:40.878]     ...future.result$finished <- base::Sys.time()
[13:33:40.878]     ...future.result
[13:33:40.878] }
[13:33:40.879] assign_globals() ...
[13:33:40.879] List of 5
[13:33:40.879]  $ ...future.FUN            :function (object, ...)  
[13:33:40.879]  $ future.call.arguments    : list()
[13:33:40.879]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.879]  $ ...future.elements_ii    :List of 3
[13:33:40.879]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:33:40.879]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:33:40.879]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:40.879]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:33:40.879]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:33:40.879]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:40.879]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:33:40.879]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:33:40.879]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:40.879]  $ ...future.seeds_ii       : NULL
[13:33:40.879]  $ ...future.globals.maxSize: NULL
[13:33:40.879]  - attr(*, "where")=List of 5
[13:33:40.879]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:40.879]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:40.879]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:40.879]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:40.879]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:40.879]  - attr(*, "resolved")= logi FALSE
[13:33:40.879]  - attr(*, "total_size")= num 1240
[13:33:40.879]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.879]  - attr(*, "already-done")= logi TRUE
[13:33:40.887] - copied ‘...future.FUN’ to environment
[13:33:40.887] - copied ‘future.call.arguments’ to environment
[13:33:40.887] - copied ‘...future.elements_ii’ to environment
[13:33:40.887] - copied ‘...future.seeds_ii’ to environment
[13:33:40.888] - copied ‘...future.globals.maxSize’ to environment
[13:33:40.888] assign_globals() ... done
[13:33:40.888] plan(): Setting new future strategy stack:
[13:33:40.888] List of future strategies:
[13:33:40.888] 1. sequential:
[13:33:40.888]    - args: function (..., envir = parent.frame())
[13:33:40.888]    - tweaked: FALSE
[13:33:40.888]    - call: NULL
[13:33:40.888] plan(): nbrOfWorkers() = 1
[13:33:40.890] plan(): Setting new future strategy stack:
[13:33:40.890] List of future strategies:
[13:33:40.890] 1. multicore:
[13:33:40.890]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:40.890]    - tweaked: FALSE
[13:33:40.890]    - call: plan(strategy)
[13:33:40.893] plan(): nbrOfWorkers() = 1
[13:33:40.893] SequentialFuture started (and completed)
[13:33:40.894] - Launch lazy future ... done
[13:33:40.894] run() for ‘SequentialFuture’ ... done
[13:33:40.894] Created future:
[13:33:40.894] SequentialFuture:
[13:33:40.894] Label: ‘future_by-1’
[13:33:40.894] Expression:
[13:33:40.894] {
[13:33:40.894]     do.call(function(...) {
[13:33:40.894]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.894]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:40.894]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.894]             on.exit(options(oopts), add = TRUE)
[13:33:40.894]         }
[13:33:40.894]         {
[13:33:40.894]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:40.894]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.894]                 ...future.FUN(...future.X_jj, ...)
[13:33:40.894]             })
[13:33:40.894]         }
[13:33:40.894]     }, args = future.call.arguments)
[13:33:40.894] }
[13:33:40.894] Lazy evaluation: FALSE
[13:33:40.894] Asynchronous evaluation: FALSE
[13:33:40.894] Local evaluation: TRUE
[13:33:40.894] Environment: R_GlobalEnv
[13:33:40.894] Capture standard output: TRUE
[13:33:40.894] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:40.894] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:40.894] Packages: <none>
[13:33:40.894] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:40.894] Resolved: TRUE
[13:33:40.894] Value: 4.62 KiB of class ‘list’
[13:33:40.894] Early signaling: FALSE
[13:33:40.894] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:40.894] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:40.895] Chunk #1 of 1 ... DONE
[13:33:40.895] Launching 1 futures (chunks) ... DONE
[13:33:40.895] Resolving 1 futures (chunks) ...
[13:33:40.895] resolve() on list ...
[13:33:40.895]  recursive: 0
[13:33:40.895]  length: 1
[13:33:40.895] 
[13:33:40.896] resolved() for ‘SequentialFuture’ ...
[13:33:40.896] - state: ‘finished’
[13:33:40.896] - run: TRUE
[13:33:40.896] - result: ‘FutureResult’
[13:33:40.896] resolved() for ‘SequentialFuture’ ... done
[13:33:40.896] Future #1
[13:33:40.896] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:40.896] - nx: 1
[13:33:40.896] - relay: TRUE
[13:33:40.896] - stdout: TRUE
[13:33:40.896] - signal: TRUE
[13:33:40.897] - resignal: FALSE
[13:33:40.897] - force: TRUE
[13:33:40.897] - relayed: [n=1] FALSE
[13:33:40.897] - queued futures: [n=1] FALSE
[13:33:40.897]  - until=1
[13:33:40.897]  - relaying element #1
[13:33:40.897] - relayed: [n=1] TRUE
[13:33:40.897] - queued futures: [n=1] TRUE
[13:33:40.897] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:40.897]  length: 0 (resolved future 1)
[13:33:40.897] Relaying remaining futures
[13:33:40.898] signalConditionsASAP(NULL, pos=0) ...
[13:33:40.898] - nx: 1
[13:33:40.898] - relay: TRUE
[13:33:40.898] - stdout: TRUE
[13:33:40.898] - signal: TRUE
[13:33:40.898] - resignal: FALSE
[13:33:40.898] - force: TRUE
[13:33:40.898] - relayed: [n=1] TRUE
[13:33:40.898] - queued futures: [n=1] TRUE
 - flush all
[13:33:40.898] - relayed: [n=1] TRUE
[13:33:40.898] - queued futures: [n=1] TRUE
[13:33:40.898] signalConditionsASAP(NULL, pos=0) ... done
[13:33:40.899] resolve() on list ... DONE
[13:33:40.899]  - Number of value chunks collected: 1
[13:33:40.899] Resolving 1 futures (chunks) ... DONE
[13:33:40.899] Reducing values from 1 chunks ...
[13:33:40.899]  - Number of values collected after concatenation: 3
[13:33:40.899]  - Number of values expected: 3
[13:33:40.899] Reducing values from 1 chunks ... DONE
[13:33:40.899] future_lapply() ... DONE
[13:33:40.899] future_by_internal() ... DONE
[13:33:40.900] future_by_internal() ...
[13:33:40.900] future_lapply() ...
[13:33:40.903] Number of chunks: 1
[13:33:40.903] getGlobalsAndPackagesXApply() ...
[13:33:40.904]  - future.globals: TRUE
[13:33:40.904] getGlobalsAndPackages() ...
[13:33:40.904] Searching for globals...
[13:33:40.905] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:40.906] Searching for globals ... DONE
[13:33:40.906] Resolving globals: FALSE
[13:33:40.906] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:40.906] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:40.906] - globals: [1] ‘FUN’
[13:33:40.907] 
[13:33:40.907] getGlobalsAndPackages() ... DONE
[13:33:40.907]  - globals found/used: [n=1] ‘FUN’
[13:33:40.907]  - needed namespaces: [n=0] 
[13:33:40.907] Finding globals ... DONE
[13:33:40.907]  - use_args: TRUE
[13:33:40.907]  - Getting '...' globals ...
[13:33:40.907] resolve() on list ...
[13:33:40.907]  recursive: 0
[13:33:40.908]  length: 1
[13:33:40.908]  elements: ‘...’
[13:33:40.908]  length: 0 (resolved future 1)
[13:33:40.908] resolve() on list ... DONE
[13:33:40.908]    - '...' content: [n=1] ‘digits’
[13:33:40.908] List of 1
[13:33:40.908]  $ ...:List of 1
[13:33:40.908]   ..$ digits: int 2
[13:33:40.908]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.908]  - attr(*, "where")=List of 1
[13:33:40.908]   ..$ ...:<environment: 0x55cb827b31c8> 
[13:33:40.908]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.908]  - attr(*, "resolved")= logi TRUE
[13:33:40.908]  - attr(*, "total_size")= num NA
[13:33:40.911]  - Getting '...' globals ... DONE
[13:33:40.911] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:40.911] List of 2
[13:33:40.911]  $ ...future.FUN:function (object, ...)  
[13:33:40.911]  $ ...          :List of 1
[13:33:40.911]   ..$ digits: int 2
[13:33:40.911]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.911]  - attr(*, "where")=List of 2
[13:33:40.911]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:40.911]   ..$ ...          :<environment: 0x55cb827b31c8> 
[13:33:40.911]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.911]  - attr(*, "resolved")= logi FALSE
[13:33:40.911]  - attr(*, "total_size")= num 1296
[13:33:40.914] Packages to be attached in all futures: [n=0] 
[13:33:40.914] getGlobalsAndPackagesXApply() ... DONE
[13:33:40.914] Number of futures (= number of chunks): 1
[13:33:40.914] Launching 1 futures (chunks) ...
[13:33:40.914] Chunk #1 of 1 ...
[13:33:40.914]  - Finding globals in 'X' for chunk #1 ...
[13:33:40.914] getGlobalsAndPackages() ...
[13:33:40.915] Searching for globals...
[13:33:40.915] 
[13:33:40.915] Searching for globals ... DONE
[13:33:40.915] - globals: [0] <none>
[13:33:40.915] getGlobalsAndPackages() ... DONE
[13:33:40.915]    + additional globals found: [n=0] 
[13:33:40.915]    + additional namespaces needed: [n=0] 
[13:33:40.915]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:40.915]  - seeds: <none>
[13:33:40.915]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.915] getGlobalsAndPackages() ...
[13:33:40.916] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.916] Resolving globals: FALSE
[13:33:40.916] Tweak future expression to call with '...' arguments ...
[13:33:40.916] {
[13:33:40.916]     do.call(function(...) {
[13:33:40.916]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.916]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:40.916]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.916]             on.exit(options(oopts), add = TRUE)
[13:33:40.916]         }
[13:33:40.916]         {
[13:33:40.916]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:40.916]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.916]                 ...future.FUN(...future.X_jj, ...)
[13:33:40.916]             })
[13:33:40.916]         }
[13:33:40.916]     }, args = future.call.arguments)
[13:33:40.916] }
[13:33:40.916] Tweak future expression to call with '...' arguments ... DONE
[13:33:40.916] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.917] 
[13:33:40.917] getGlobalsAndPackages() ... DONE
[13:33:40.917] run() for ‘Future’ ...
[13:33:40.917] - state: ‘created’
[13:33:40.917] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:40.920] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:40.921] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:40.921]   - Field: ‘label’
[13:33:40.921]   - Field: ‘local’
[13:33:40.921]   - Field: ‘owner’
[13:33:40.921]   - Field: ‘envir’
[13:33:40.921]   - Field: ‘packages’
[13:33:40.921]   - Field: ‘gc’
[13:33:40.921]   - Field: ‘conditions’
[13:33:40.921]   - Field: ‘expr’
[13:33:40.921]   - Field: ‘uuid’
[13:33:40.921]   - Field: ‘seed’
[13:33:40.922]   - Field: ‘version’
[13:33:40.922]   - Field: ‘result’
[13:33:40.922]   - Field: ‘asynchronous’
[13:33:40.922]   - Field: ‘calls’
[13:33:40.922]   - Field: ‘globals’
[13:33:40.922]   - Field: ‘stdout’
[13:33:40.922]   - Field: ‘earlySignal’
[13:33:40.922]   - Field: ‘lazy’
[13:33:40.922]   - Field: ‘state’
[13:33:40.922] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:40.922] - Launch lazy future ...
[13:33:40.923] Packages needed by the future expression (n = 0): <none>
[13:33:40.923] Packages needed by future strategies (n = 0): <none>
[13:33:40.924] {
[13:33:40.924]     {
[13:33:40.924]         {
[13:33:40.924]             ...future.startTime <- base::Sys.time()
[13:33:40.924]             {
[13:33:40.924]                 {
[13:33:40.924]                   {
[13:33:40.924]                     base::local({
[13:33:40.924]                       has_future <- base::requireNamespace("future", 
[13:33:40.924]                         quietly = TRUE)
[13:33:40.924]                       if (has_future) {
[13:33:40.924]                         ns <- base::getNamespace("future")
[13:33:40.924]                         version <- ns[[".package"]][["version"]]
[13:33:40.924]                         if (is.null(version)) 
[13:33:40.924]                           version <- utils::packageVersion("future")
[13:33:40.924]                       }
[13:33:40.924]                       else {
[13:33:40.924]                         version <- NULL
[13:33:40.924]                       }
[13:33:40.924]                       if (!has_future || version < "1.8.0") {
[13:33:40.924]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:40.924]                           "", base::R.version$version.string), 
[13:33:40.924]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:40.924]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:40.924]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:40.924]                             "release", "version")], collapse = " "), 
[13:33:40.924]                           hostname = base::Sys.info()[["nodename"]])
[13:33:40.924]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:40.924]                           info)
[13:33:40.924]                         info <- base::paste(info, collapse = "; ")
[13:33:40.924]                         if (!has_future) {
[13:33:40.924]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:40.924]                             info)
[13:33:40.924]                         }
[13:33:40.924]                         else {
[13:33:40.924]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:40.924]                             info, version)
[13:33:40.924]                         }
[13:33:40.924]                         base::stop(msg)
[13:33:40.924]                       }
[13:33:40.924]                     })
[13:33:40.924]                   }
[13:33:40.924]                   ...future.strategy.old <- future::plan("list")
[13:33:40.924]                   options(future.plan = NULL)
[13:33:40.924]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:40.924]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:40.924]                 }
[13:33:40.924]                 ...future.workdir <- getwd()
[13:33:40.924]             }
[13:33:40.924]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:40.924]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:40.924]         }
[13:33:40.924]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:40.924]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:40.924]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:40.924]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:40.924]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:40.924]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:40.924]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:40.924]             base::names(...future.oldOptions))
[13:33:40.924]     }
[13:33:40.924]     if (FALSE) {
[13:33:40.924]     }
[13:33:40.924]     else {
[13:33:40.924]         if (TRUE) {
[13:33:40.924]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:40.924]                 open = "w")
[13:33:40.924]         }
[13:33:40.924]         else {
[13:33:40.924]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:40.924]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:40.924]         }
[13:33:40.924]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:40.924]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:40.924]             base::sink(type = "output", split = FALSE)
[13:33:40.924]             base::close(...future.stdout)
[13:33:40.924]         }, add = TRUE)
[13:33:40.924]     }
[13:33:40.924]     ...future.frame <- base::sys.nframe()
[13:33:40.924]     ...future.conditions <- base::list()
[13:33:40.924]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:40.924]     if (FALSE) {
[13:33:40.924]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:40.924]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:40.924]     }
[13:33:40.924]     ...future.result <- base::tryCatch({
[13:33:40.924]         base::withCallingHandlers({
[13:33:40.924]             ...future.value <- base::withVisible(base::local({
[13:33:40.924]                 do.call(function(...) {
[13:33:40.924]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.924]                   if (!identical(...future.globals.maxSize.org, 
[13:33:40.924]                     ...future.globals.maxSize)) {
[13:33:40.924]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.924]                     on.exit(options(oopts), add = TRUE)
[13:33:40.924]                   }
[13:33:40.924]                   {
[13:33:40.924]                     lapply(seq_along(...future.elements_ii), 
[13:33:40.924]                       FUN = function(jj) {
[13:33:40.924]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.924]                         ...future.FUN(...future.X_jj, ...)
[13:33:40.924]                       })
[13:33:40.924]                   }
[13:33:40.924]                 }, args = future.call.arguments)
[13:33:40.924]             }))
[13:33:40.924]             future::FutureResult(value = ...future.value$value, 
[13:33:40.924]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:40.924]                   ...future.rng), globalenv = if (FALSE) 
[13:33:40.924]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:40.924]                     ...future.globalenv.names))
[13:33:40.924]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:40.924]         }, condition = base::local({
[13:33:40.924]             c <- base::c
[13:33:40.924]             inherits <- base::inherits
[13:33:40.924]             invokeRestart <- base::invokeRestart
[13:33:40.924]             length <- base::length
[13:33:40.924]             list <- base::list
[13:33:40.924]             seq.int <- base::seq.int
[13:33:40.924]             signalCondition <- base::signalCondition
[13:33:40.924]             sys.calls <- base::sys.calls
[13:33:40.924]             `[[` <- base::`[[`
[13:33:40.924]             `+` <- base::`+`
[13:33:40.924]             `<<-` <- base::`<<-`
[13:33:40.924]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:40.924]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:40.924]                   3L)]
[13:33:40.924]             }
[13:33:40.924]             function(cond) {
[13:33:40.924]                 is_error <- inherits(cond, "error")
[13:33:40.924]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:40.924]                   NULL)
[13:33:40.924]                 if (is_error) {
[13:33:40.924]                   sessionInformation <- function() {
[13:33:40.924]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:40.924]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:40.924]                       search = base::search(), system = base::Sys.info())
[13:33:40.924]                   }
[13:33:40.924]                   ...future.conditions[[length(...future.conditions) + 
[13:33:40.924]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:40.924]                     cond$call), session = sessionInformation(), 
[13:33:40.924]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:40.924]                   signalCondition(cond)
[13:33:40.924]                 }
[13:33:40.924]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:40.924]                 "immediateCondition"))) {
[13:33:40.924]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:40.924]                   ...future.conditions[[length(...future.conditions) + 
[13:33:40.924]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:40.924]                   if (TRUE && !signal) {
[13:33:40.924]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:40.924]                     {
[13:33:40.924]                       inherits <- base::inherits
[13:33:40.924]                       invokeRestart <- base::invokeRestart
[13:33:40.924]                       is.null <- base::is.null
[13:33:40.924]                       muffled <- FALSE
[13:33:40.924]                       if (inherits(cond, "message")) {
[13:33:40.924]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:40.924]                         if (muffled) 
[13:33:40.924]                           invokeRestart("muffleMessage")
[13:33:40.924]                       }
[13:33:40.924]                       else if (inherits(cond, "warning")) {
[13:33:40.924]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:40.924]                         if (muffled) 
[13:33:40.924]                           invokeRestart("muffleWarning")
[13:33:40.924]                       }
[13:33:40.924]                       else if (inherits(cond, "condition")) {
[13:33:40.924]                         if (!is.null(pattern)) {
[13:33:40.924]                           computeRestarts <- base::computeRestarts
[13:33:40.924]                           grepl <- base::grepl
[13:33:40.924]                           restarts <- computeRestarts(cond)
[13:33:40.924]                           for (restart in restarts) {
[13:33:40.924]                             name <- restart$name
[13:33:40.924]                             if (is.null(name)) 
[13:33:40.924]                               next
[13:33:40.924]                             if (!grepl(pattern, name)) 
[13:33:40.924]                               next
[13:33:40.924]                             invokeRestart(restart)
[13:33:40.924]                             muffled <- TRUE
[13:33:40.924]                             break
[13:33:40.924]                           }
[13:33:40.924]                         }
[13:33:40.924]                       }
[13:33:40.924]                       invisible(muffled)
[13:33:40.924]                     }
[13:33:40.924]                     muffleCondition(cond, pattern = "^muffle")
[13:33:40.924]                   }
[13:33:40.924]                 }
[13:33:40.924]                 else {
[13:33:40.924]                   if (TRUE) {
[13:33:40.924]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:40.924]                     {
[13:33:40.924]                       inherits <- base::inherits
[13:33:40.924]                       invokeRestart <- base::invokeRestart
[13:33:40.924]                       is.null <- base::is.null
[13:33:40.924]                       muffled <- FALSE
[13:33:40.924]                       if (inherits(cond, "message")) {
[13:33:40.924]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:40.924]                         if (muffled) 
[13:33:40.924]                           invokeRestart("muffleMessage")
[13:33:40.924]                       }
[13:33:40.924]                       else if (inherits(cond, "warning")) {
[13:33:40.924]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:40.924]                         if (muffled) 
[13:33:40.924]                           invokeRestart("muffleWarning")
[13:33:40.924]                       }
[13:33:40.924]                       else if (inherits(cond, "condition")) {
[13:33:40.924]                         if (!is.null(pattern)) {
[13:33:40.924]                           computeRestarts <- base::computeRestarts
[13:33:40.924]                           grepl <- base::grepl
[13:33:40.924]                           restarts <- computeRestarts(cond)
[13:33:40.924]                           for (restart in restarts) {
[13:33:40.924]                             name <- restart$name
[13:33:40.924]                             if (is.null(name)) 
[13:33:40.924]                               next
[13:33:40.924]                             if (!grepl(pattern, name)) 
[13:33:40.924]                               next
[13:33:40.924]                             invokeRestart(restart)
[13:33:40.924]                             muffled <- TRUE
[13:33:40.924]                             break
[13:33:40.924]                           }
[13:33:40.924]                         }
[13:33:40.924]                       }
[13:33:40.924]                       invisible(muffled)
[13:33:40.924]                     }
[13:33:40.924]                     muffleCondition(cond, pattern = "^muffle")
[13:33:40.924]                   }
[13:33:40.924]                 }
[13:33:40.924]             }
[13:33:40.924]         }))
[13:33:40.924]     }, error = function(ex) {
[13:33:40.924]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:40.924]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:40.924]                 ...future.rng), started = ...future.startTime, 
[13:33:40.924]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:40.924]             version = "1.8"), class = "FutureResult")
[13:33:40.924]     }, finally = {
[13:33:40.924]         if (!identical(...future.workdir, getwd())) 
[13:33:40.924]             setwd(...future.workdir)
[13:33:40.924]         {
[13:33:40.924]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:40.924]                 ...future.oldOptions$nwarnings <- NULL
[13:33:40.924]             }
[13:33:40.924]             base::options(...future.oldOptions)
[13:33:40.924]             if (.Platform$OS.type == "windows") {
[13:33:40.924]                 old_names <- names(...future.oldEnvVars)
[13:33:40.924]                 envs <- base::Sys.getenv()
[13:33:40.924]                 names <- names(envs)
[13:33:40.924]                 common <- intersect(names, old_names)
[13:33:40.924]                 added <- setdiff(names, old_names)
[13:33:40.924]                 removed <- setdiff(old_names, names)
[13:33:40.924]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:40.924]                   envs[common]]
[13:33:40.924]                 NAMES <- toupper(changed)
[13:33:40.924]                 args <- list()
[13:33:40.924]                 for (kk in seq_along(NAMES)) {
[13:33:40.924]                   name <- changed[[kk]]
[13:33:40.924]                   NAME <- NAMES[[kk]]
[13:33:40.924]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.924]                     next
[13:33:40.924]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:40.924]                 }
[13:33:40.924]                 NAMES <- toupper(added)
[13:33:40.924]                 for (kk in seq_along(NAMES)) {
[13:33:40.924]                   name <- added[[kk]]
[13:33:40.924]                   NAME <- NAMES[[kk]]
[13:33:40.924]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.924]                     next
[13:33:40.924]                   args[[name]] <- ""
[13:33:40.924]                 }
[13:33:40.924]                 NAMES <- toupper(removed)
[13:33:40.924]                 for (kk in seq_along(NAMES)) {
[13:33:40.924]                   name <- removed[[kk]]
[13:33:40.924]                   NAME <- NAMES[[kk]]
[13:33:40.924]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.924]                     next
[13:33:40.924]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:40.924]                 }
[13:33:40.924]                 if (length(args) > 0) 
[13:33:40.924]                   base::do.call(base::Sys.setenv, args = args)
[13:33:40.924]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:40.924]             }
[13:33:40.924]             else {
[13:33:40.924]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:40.924]             }
[13:33:40.924]             {
[13:33:40.924]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:40.924]                   0L) {
[13:33:40.924]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:40.924]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:40.924]                   base::options(opts)
[13:33:40.924]                 }
[13:33:40.924]                 {
[13:33:40.924]                   {
[13:33:40.924]                     NULL
[13:33:40.924]                     RNGkind("Mersenne-Twister")
[13:33:40.924]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:40.924]                       inherits = FALSE)
[13:33:40.924]                   }
[13:33:40.924]                   options(future.plan = NULL)
[13:33:40.924]                   if (is.na(NA_character_)) 
[13:33:40.924]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:40.924]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:40.924]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:40.924]                     .init = FALSE)
[13:33:40.924]                 }
[13:33:40.924]             }
[13:33:40.924]         }
[13:33:40.924]     })
[13:33:40.924]     if (TRUE) {
[13:33:40.924]         base::sink(type = "output", split = FALSE)
[13:33:40.924]         if (TRUE) {
[13:33:40.924]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:40.924]         }
[13:33:40.924]         else {
[13:33:40.924]             ...future.result["stdout"] <- base::list(NULL)
[13:33:40.924]         }
[13:33:40.924]         base::close(...future.stdout)
[13:33:40.924]         ...future.stdout <- NULL
[13:33:40.924]     }
[13:33:40.924]     ...future.result$conditions <- ...future.conditions
[13:33:40.924]     ...future.result$finished <- base::Sys.time()
[13:33:40.924]     ...future.result
[13:33:40.924] }
[13:33:40.926] assign_globals() ...
[13:33:40.926] List of 5
[13:33:40.926]  $ ...future.FUN            :function (object, ...)  
[13:33:40.926]  $ future.call.arguments    :List of 1
[13:33:40.926]   ..$ digits: int 2
[13:33:40.926]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.926]  $ ...future.elements_ii    :List of 6
[13:33:40.926]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[13:33:40.926]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[13:33:40.926]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[13:33:40.926]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[13:33:40.926]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[13:33:40.926]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[13:33:40.926]  $ ...future.seeds_ii       : NULL
[13:33:40.926]  $ ...future.globals.maxSize: NULL
[13:33:40.926]  - attr(*, "where")=List of 5
[13:33:40.926]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:40.926]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:40.926]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:40.926]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:40.926]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:40.926]  - attr(*, "resolved")= logi FALSE
[13:33:40.926]  - attr(*, "total_size")= num 1296
[13:33:40.926]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.926]  - attr(*, "already-done")= logi TRUE
[13:33:40.932] - copied ‘...future.FUN’ to environment
[13:33:40.932] - copied ‘future.call.arguments’ to environment
[13:33:40.932] - copied ‘...future.elements_ii’ to environment
[13:33:40.932] - copied ‘...future.seeds_ii’ to environment
[13:33:40.932] - copied ‘...future.globals.maxSize’ to environment
[13:33:40.932] assign_globals() ... done
[13:33:40.932] plan(): Setting new future strategy stack:
[13:33:40.932] List of future strategies:
[13:33:40.932] 1. sequential:
[13:33:40.932]    - args: function (..., envir = parent.frame())
[13:33:40.932]    - tweaked: FALSE
[13:33:40.932]    - call: NULL
[13:33:40.933] plan(): nbrOfWorkers() = 1
[13:33:40.934] plan(): Setting new future strategy stack:
[13:33:40.934] List of future strategies:
[13:33:40.934] 1. multicore:
[13:33:40.934]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:40.934]    - tweaked: FALSE
[13:33:40.934]    - call: plan(strategy)
[13:33:40.937] plan(): nbrOfWorkers() = 1
[13:33:40.937] SequentialFuture started (and completed)
[13:33:40.938] - Launch lazy future ... done
[13:33:40.938] run() for ‘SequentialFuture’ ... done
[13:33:40.938] Created future:
[13:33:40.938] SequentialFuture:
[13:33:40.938] Label: ‘future_by-1’
[13:33:40.938] Expression:
[13:33:40.938] {
[13:33:40.938]     do.call(function(...) {
[13:33:40.938]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.938]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:40.938]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.938]             on.exit(options(oopts), add = TRUE)
[13:33:40.938]         }
[13:33:40.938]         {
[13:33:40.938]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:40.938]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.938]                 ...future.FUN(...future.X_jj, ...)
[13:33:40.938]             })
[13:33:40.938]         }
[13:33:40.938]     }, args = future.call.arguments)
[13:33:40.938] }
[13:33:40.938] Lazy evaluation: FALSE
[13:33:40.938] Asynchronous evaluation: FALSE
[13:33:40.938] Local evaluation: TRUE
[13:33:40.938] Environment: R_GlobalEnv
[13:33:40.938] Capture standard output: TRUE
[13:33:40.938] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:40.938] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:40.938] Packages: <none>
[13:33:40.938] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:40.938] Resolved: TRUE
[13:33:40.938] Value: 5.48 KiB of class ‘list’
[13:33:40.938] Early signaling: FALSE
[13:33:40.938] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:40.938] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:40.939] Chunk #1 of 1 ... DONE
[13:33:40.939] Launching 1 futures (chunks) ... DONE
[13:33:40.939] Resolving 1 futures (chunks) ...
[13:33:40.939] resolve() on list ...
[13:33:40.939]  recursive: 0
[13:33:40.939]  length: 1
[13:33:40.939] 
[13:33:40.940] resolved() for ‘SequentialFuture’ ...
[13:33:40.940] - state: ‘finished’
[13:33:40.940] - run: TRUE
[13:33:40.940] - result: ‘FutureResult’
[13:33:40.940] resolved() for ‘SequentialFuture’ ... done
[13:33:40.940] Future #1
[13:33:40.940] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:40.940] - nx: 1
[13:33:40.940] - relay: TRUE
[13:33:40.940] - stdout: TRUE
[13:33:40.940] - signal: TRUE
[13:33:40.940] - resignal: FALSE
[13:33:40.941] - force: TRUE
[13:33:40.941] - relayed: [n=1] FALSE
[13:33:40.941] - queued futures: [n=1] FALSE
[13:33:40.941]  - until=1
[13:33:40.941]  - relaying element #1
[13:33:40.941] - relayed: [n=1] TRUE
[13:33:40.941] - queued futures: [n=1] TRUE
[13:33:40.941] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:40.941]  length: 0 (resolved future 1)
[13:33:40.941] Relaying remaining futures
[13:33:40.941] signalConditionsASAP(NULL, pos=0) ...
[13:33:40.942] - nx: 1
[13:33:40.942] - relay: TRUE
[13:33:40.942] - stdout: TRUE
[13:33:40.942] - signal: TRUE
[13:33:40.942] - resignal: FALSE
[13:33:40.942] - force: TRUE
[13:33:40.942] - relayed: [n=1] TRUE
[13:33:40.942] - queued futures: [n=1] TRUE
 - flush all
[13:33:40.942] - relayed: [n=1] TRUE
[13:33:40.942] - queued futures: [n=1] TRUE
[13:33:40.942] signalConditionsASAP(NULL, pos=0) ... done
[13:33:40.942] resolve() on list ... DONE
[13:33:40.943]  - Number of value chunks collected: 1
[13:33:40.943] Resolving 1 futures (chunks) ... DONE
[13:33:40.943] Reducing values from 1 chunks ...
[13:33:40.943]  - Number of values collected after concatenation: 6
[13:33:40.943]  - Number of values expected: 6
[13:33:40.943] Reducing values from 1 chunks ... DONE
[13:33:40.943] future_lapply() ... DONE
[13:33:40.943] future_by_internal() ... DONE
[13:33:40.970] future_by_internal() ...
[13:33:40.970] future_lapply() ...
[13:33:40.975] Number of chunks: 1
[13:33:40.975] getGlobalsAndPackagesXApply() ...
[13:33:40.975]  - future.globals: TRUE
[13:33:40.975] getGlobalsAndPackages() ...
[13:33:40.975] Searching for globals...
[13:33:40.977] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:33:40.977] Searching for globals ... DONE
[13:33:40.977] Resolving globals: FALSE
[13:33:40.977] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[13:33:40.978] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[13:33:40.978] - globals: [1] ‘FUN’
[13:33:40.978] - packages: [1] ‘stats’
[13:33:40.978] getGlobalsAndPackages() ... DONE
[13:33:40.978]  - globals found/used: [n=1] ‘FUN’
[13:33:40.978]  - needed namespaces: [n=1] ‘stats’
[13:33:40.978] Finding globals ... DONE
[13:33:40.978]  - use_args: TRUE
[13:33:40.979]  - Getting '...' globals ...
[13:33:40.979] resolve() on list ...
[13:33:40.979]  recursive: 0
[13:33:40.979]  length: 1
[13:33:40.979]  elements: ‘...’
[13:33:40.979]  length: 0 (resolved future 1)
[13:33:40.979] resolve() on list ... DONE
[13:33:40.979]    - '...' content: [n=1] ‘singular.ok’
[13:33:40.980] List of 1
[13:33:40.980]  $ ...:List of 1
[13:33:40.980]   ..$ singular.ok: logi FALSE
[13:33:40.980]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.980]  - attr(*, "where")=List of 1
[13:33:40.980]   ..$ ...:<environment: 0x55cb8026b598> 
[13:33:40.980]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.980]  - attr(*, "resolved")= logi TRUE
[13:33:40.980]  - attr(*, "total_size")= num NA
[13:33:40.983]  - Getting '...' globals ... DONE
[13:33:40.983] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:40.983] List of 2
[13:33:40.983]  $ ...future.FUN:function (x, ...)  
[13:33:40.983]  $ ...          :List of 1
[13:33:40.983]   ..$ singular.ok: logi FALSE
[13:33:40.983]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.983]  - attr(*, "where")=List of 2
[13:33:40.983]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:40.983]   ..$ ...          :<environment: 0x55cb8026b598> 
[13:33:40.983]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.983]  - attr(*, "resolved")= logi FALSE
[13:33:40.983]  - attr(*, "total_size")= num 5384
[13:33:40.986] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:40.986] getGlobalsAndPackagesXApply() ... DONE
[13:33:40.986] Number of futures (= number of chunks): 1
[13:33:40.986] Launching 1 futures (chunks) ...
[13:33:40.986] Chunk #1 of 1 ...
[13:33:40.987]  - Finding globals in 'X' for chunk #1 ...
[13:33:40.987] getGlobalsAndPackages() ...
[13:33:40.987] Searching for globals...
[13:33:40.987] 
[13:33:40.987] Searching for globals ... DONE
[13:33:40.987] - globals: [0] <none>
[13:33:40.987] getGlobalsAndPackages() ... DONE
[13:33:40.988]    + additional globals found: [n=0] 
[13:33:40.988]    + additional namespaces needed: [n=0] 
[13:33:40.988]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:40.988]  - seeds: <none>
[13:33:40.988]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.988] getGlobalsAndPackages() ...
[13:33:40.988] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.988] Resolving globals: FALSE
[13:33:40.988] Tweak future expression to call with '...' arguments ...
[13:33:40.988] {
[13:33:40.988]     do.call(function(...) {
[13:33:40.988]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.988]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:40.988]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.988]             on.exit(options(oopts), add = TRUE)
[13:33:40.988]         }
[13:33:40.988]         {
[13:33:40.988]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:40.988]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.988]                 ...future.FUN(...future.X_jj, ...)
[13:33:40.988]             })
[13:33:40.988]         }
[13:33:40.988]     }, args = future.call.arguments)
[13:33:40.988] }
[13:33:40.989] Tweak future expression to call with '...' arguments ... DONE
[13:33:40.989] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:40.989] 
[13:33:40.989] getGlobalsAndPackages() ... DONE
[13:33:40.989] run() for ‘Future’ ...
[13:33:40.990] - state: ‘created’
[13:33:40.990] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:40.993] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:40.993] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:40.993]   - Field: ‘label’
[13:33:40.994]   - Field: ‘local’
[13:33:40.994]   - Field: ‘owner’
[13:33:40.994]   - Field: ‘envir’
[13:33:40.994]   - Field: ‘packages’
[13:33:40.994]   - Field: ‘gc’
[13:33:40.994]   - Field: ‘conditions’
[13:33:40.994]   - Field: ‘expr’
[13:33:40.994]   - Field: ‘uuid’
[13:33:40.994]   - Field: ‘seed’
[13:33:40.995]   - Field: ‘version’
[13:33:40.996]   - Field: ‘result’
[13:33:40.996]   - Field: ‘asynchronous’
[13:33:40.996]   - Field: ‘calls’
[13:33:40.996]   - Field: ‘globals’
[13:33:40.996]   - Field: ‘stdout’
[13:33:40.996]   - Field: ‘earlySignal’
[13:33:40.996]   - Field: ‘lazy’
[13:33:40.996]   - Field: ‘state’
[13:33:40.996] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:40.997] - Launch lazy future ...
[13:33:40.997] Packages needed by the future expression (n = 1): ‘stats’
[13:33:40.997] Packages needed by future strategies (n = 0): <none>
[13:33:40.997] {
[13:33:40.997]     {
[13:33:40.997]         {
[13:33:40.997]             ...future.startTime <- base::Sys.time()
[13:33:40.997]             {
[13:33:40.997]                 {
[13:33:40.997]                   {
[13:33:40.997]                     {
[13:33:40.997]                       base::local({
[13:33:40.997]                         has_future <- base::requireNamespace("future", 
[13:33:40.997]                           quietly = TRUE)
[13:33:40.997]                         if (has_future) {
[13:33:40.997]                           ns <- base::getNamespace("future")
[13:33:40.997]                           version <- ns[[".package"]][["version"]]
[13:33:40.997]                           if (is.null(version)) 
[13:33:40.997]                             version <- utils::packageVersion("future")
[13:33:40.997]                         }
[13:33:40.997]                         else {
[13:33:40.997]                           version <- NULL
[13:33:40.997]                         }
[13:33:40.997]                         if (!has_future || version < "1.8.0") {
[13:33:40.997]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:40.997]                             "", base::R.version$version.string), 
[13:33:40.997]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:40.997]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:40.997]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:40.997]                               "release", "version")], collapse = " "), 
[13:33:40.997]                             hostname = base::Sys.info()[["nodename"]])
[13:33:40.997]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:40.997]                             info)
[13:33:40.997]                           info <- base::paste(info, collapse = "; ")
[13:33:40.997]                           if (!has_future) {
[13:33:40.997]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:40.997]                               info)
[13:33:40.997]                           }
[13:33:40.997]                           else {
[13:33:40.997]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:40.997]                               info, version)
[13:33:40.997]                           }
[13:33:40.997]                           base::stop(msg)
[13:33:40.997]                         }
[13:33:40.997]                       })
[13:33:40.997]                     }
[13:33:40.997]                     base::local({
[13:33:40.997]                       for (pkg in "stats") {
[13:33:40.997]                         base::loadNamespace(pkg)
[13:33:40.997]                         base::library(pkg, character.only = TRUE)
[13:33:40.997]                       }
[13:33:40.997]                     })
[13:33:40.997]                   }
[13:33:40.997]                   ...future.strategy.old <- future::plan("list")
[13:33:40.997]                   options(future.plan = NULL)
[13:33:40.997]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:40.997]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:40.997]                 }
[13:33:40.997]                 ...future.workdir <- getwd()
[13:33:40.997]             }
[13:33:40.997]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:40.997]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:40.997]         }
[13:33:40.997]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:40.997]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:40.997]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:40.997]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:40.997]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:40.997]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:40.997]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:40.997]             base::names(...future.oldOptions))
[13:33:40.997]     }
[13:33:40.997]     if (FALSE) {
[13:33:40.997]     }
[13:33:40.997]     else {
[13:33:40.997]         if (TRUE) {
[13:33:40.997]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:40.997]                 open = "w")
[13:33:40.997]         }
[13:33:40.997]         else {
[13:33:40.997]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:40.997]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:40.997]         }
[13:33:40.997]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:40.997]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:40.997]             base::sink(type = "output", split = FALSE)
[13:33:40.997]             base::close(...future.stdout)
[13:33:40.997]         }, add = TRUE)
[13:33:40.997]     }
[13:33:40.997]     ...future.frame <- base::sys.nframe()
[13:33:40.997]     ...future.conditions <- base::list()
[13:33:40.997]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:40.997]     if (FALSE) {
[13:33:40.997]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:40.997]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:40.997]     }
[13:33:40.997]     ...future.result <- base::tryCatch({
[13:33:40.997]         base::withCallingHandlers({
[13:33:40.997]             ...future.value <- base::withVisible(base::local({
[13:33:40.997]                 do.call(function(...) {
[13:33:40.997]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:40.997]                   if (!identical(...future.globals.maxSize.org, 
[13:33:40.997]                     ...future.globals.maxSize)) {
[13:33:40.997]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:40.997]                     on.exit(options(oopts), add = TRUE)
[13:33:40.997]                   }
[13:33:40.997]                   {
[13:33:40.997]                     lapply(seq_along(...future.elements_ii), 
[13:33:40.997]                       FUN = function(jj) {
[13:33:40.997]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:40.997]                         ...future.FUN(...future.X_jj, ...)
[13:33:40.997]                       })
[13:33:40.997]                   }
[13:33:40.997]                 }, args = future.call.arguments)
[13:33:40.997]             }))
[13:33:40.997]             future::FutureResult(value = ...future.value$value, 
[13:33:40.997]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:40.997]                   ...future.rng), globalenv = if (FALSE) 
[13:33:40.997]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:40.997]                     ...future.globalenv.names))
[13:33:40.997]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:40.997]         }, condition = base::local({
[13:33:40.997]             c <- base::c
[13:33:40.997]             inherits <- base::inherits
[13:33:40.997]             invokeRestart <- base::invokeRestart
[13:33:40.997]             length <- base::length
[13:33:40.997]             list <- base::list
[13:33:40.997]             seq.int <- base::seq.int
[13:33:40.997]             signalCondition <- base::signalCondition
[13:33:40.997]             sys.calls <- base::sys.calls
[13:33:40.997]             `[[` <- base::`[[`
[13:33:40.997]             `+` <- base::`+`
[13:33:40.997]             `<<-` <- base::`<<-`
[13:33:40.997]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:40.997]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:40.997]                   3L)]
[13:33:40.997]             }
[13:33:40.997]             function(cond) {
[13:33:40.997]                 is_error <- inherits(cond, "error")
[13:33:40.997]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:40.997]                   NULL)
[13:33:40.997]                 if (is_error) {
[13:33:40.997]                   sessionInformation <- function() {
[13:33:40.997]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:40.997]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:40.997]                       search = base::search(), system = base::Sys.info())
[13:33:40.997]                   }
[13:33:40.997]                   ...future.conditions[[length(...future.conditions) + 
[13:33:40.997]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:40.997]                     cond$call), session = sessionInformation(), 
[13:33:40.997]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:40.997]                   signalCondition(cond)
[13:33:40.997]                 }
[13:33:40.997]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:40.997]                 "immediateCondition"))) {
[13:33:40.997]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:40.997]                   ...future.conditions[[length(...future.conditions) + 
[13:33:40.997]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:40.997]                   if (TRUE && !signal) {
[13:33:40.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:40.997]                     {
[13:33:40.997]                       inherits <- base::inherits
[13:33:40.997]                       invokeRestart <- base::invokeRestart
[13:33:40.997]                       is.null <- base::is.null
[13:33:40.997]                       muffled <- FALSE
[13:33:40.997]                       if (inherits(cond, "message")) {
[13:33:40.997]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:40.997]                         if (muffled) 
[13:33:40.997]                           invokeRestart("muffleMessage")
[13:33:40.997]                       }
[13:33:40.997]                       else if (inherits(cond, "warning")) {
[13:33:40.997]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:40.997]                         if (muffled) 
[13:33:40.997]                           invokeRestart("muffleWarning")
[13:33:40.997]                       }
[13:33:40.997]                       else if (inherits(cond, "condition")) {
[13:33:40.997]                         if (!is.null(pattern)) {
[13:33:40.997]                           computeRestarts <- base::computeRestarts
[13:33:40.997]                           grepl <- base::grepl
[13:33:40.997]                           restarts <- computeRestarts(cond)
[13:33:40.997]                           for (restart in restarts) {
[13:33:40.997]                             name <- restart$name
[13:33:40.997]                             if (is.null(name)) 
[13:33:40.997]                               next
[13:33:40.997]                             if (!grepl(pattern, name)) 
[13:33:40.997]                               next
[13:33:40.997]                             invokeRestart(restart)
[13:33:40.997]                             muffled <- TRUE
[13:33:40.997]                             break
[13:33:40.997]                           }
[13:33:40.997]                         }
[13:33:40.997]                       }
[13:33:40.997]                       invisible(muffled)
[13:33:40.997]                     }
[13:33:40.997]                     muffleCondition(cond, pattern = "^muffle")
[13:33:40.997]                   }
[13:33:40.997]                 }
[13:33:40.997]                 else {
[13:33:40.997]                   if (TRUE) {
[13:33:40.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:40.997]                     {
[13:33:40.997]                       inherits <- base::inherits
[13:33:40.997]                       invokeRestart <- base::invokeRestart
[13:33:40.997]                       is.null <- base::is.null
[13:33:40.997]                       muffled <- FALSE
[13:33:40.997]                       if (inherits(cond, "message")) {
[13:33:40.997]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:40.997]                         if (muffled) 
[13:33:40.997]                           invokeRestart("muffleMessage")
[13:33:40.997]                       }
[13:33:40.997]                       else if (inherits(cond, "warning")) {
[13:33:40.997]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:40.997]                         if (muffled) 
[13:33:40.997]                           invokeRestart("muffleWarning")
[13:33:40.997]                       }
[13:33:40.997]                       else if (inherits(cond, "condition")) {
[13:33:40.997]                         if (!is.null(pattern)) {
[13:33:40.997]                           computeRestarts <- base::computeRestarts
[13:33:40.997]                           grepl <- base::grepl
[13:33:40.997]                           restarts <- computeRestarts(cond)
[13:33:40.997]                           for (restart in restarts) {
[13:33:40.997]                             name <- restart$name
[13:33:40.997]                             if (is.null(name)) 
[13:33:40.997]                               next
[13:33:40.997]                             if (!grepl(pattern, name)) 
[13:33:40.997]                               next
[13:33:40.997]                             invokeRestart(restart)
[13:33:40.997]                             muffled <- TRUE
[13:33:40.997]                             break
[13:33:40.997]                           }
[13:33:40.997]                         }
[13:33:40.997]                       }
[13:33:40.997]                       invisible(muffled)
[13:33:40.997]                     }
[13:33:40.997]                     muffleCondition(cond, pattern = "^muffle")
[13:33:40.997]                   }
[13:33:40.997]                 }
[13:33:40.997]             }
[13:33:40.997]         }))
[13:33:40.997]     }, error = function(ex) {
[13:33:40.997]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:40.997]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:40.997]                 ...future.rng), started = ...future.startTime, 
[13:33:40.997]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:40.997]             version = "1.8"), class = "FutureResult")
[13:33:40.997]     }, finally = {
[13:33:40.997]         if (!identical(...future.workdir, getwd())) 
[13:33:40.997]             setwd(...future.workdir)
[13:33:40.997]         {
[13:33:40.997]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:40.997]                 ...future.oldOptions$nwarnings <- NULL
[13:33:40.997]             }
[13:33:40.997]             base::options(...future.oldOptions)
[13:33:40.997]             if (.Platform$OS.type == "windows") {
[13:33:40.997]                 old_names <- names(...future.oldEnvVars)
[13:33:40.997]                 envs <- base::Sys.getenv()
[13:33:40.997]                 names <- names(envs)
[13:33:40.997]                 common <- intersect(names, old_names)
[13:33:40.997]                 added <- setdiff(names, old_names)
[13:33:40.997]                 removed <- setdiff(old_names, names)
[13:33:40.997]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:40.997]                   envs[common]]
[13:33:40.997]                 NAMES <- toupper(changed)
[13:33:40.997]                 args <- list()
[13:33:40.997]                 for (kk in seq_along(NAMES)) {
[13:33:40.997]                   name <- changed[[kk]]
[13:33:40.997]                   NAME <- NAMES[[kk]]
[13:33:40.997]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.997]                     next
[13:33:40.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:40.997]                 }
[13:33:40.997]                 NAMES <- toupper(added)
[13:33:40.997]                 for (kk in seq_along(NAMES)) {
[13:33:40.997]                   name <- added[[kk]]
[13:33:40.997]                   NAME <- NAMES[[kk]]
[13:33:40.997]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.997]                     next
[13:33:40.997]                   args[[name]] <- ""
[13:33:40.997]                 }
[13:33:40.997]                 NAMES <- toupper(removed)
[13:33:40.997]                 for (kk in seq_along(NAMES)) {
[13:33:40.997]                   name <- removed[[kk]]
[13:33:40.997]                   NAME <- NAMES[[kk]]
[13:33:40.997]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:40.997]                     next
[13:33:40.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:40.997]                 }
[13:33:40.997]                 if (length(args) > 0) 
[13:33:40.997]                   base::do.call(base::Sys.setenv, args = args)
[13:33:40.997]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:40.997]             }
[13:33:40.997]             else {
[13:33:40.997]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:40.997]             }
[13:33:40.997]             {
[13:33:40.997]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:40.997]                   0L) {
[13:33:40.997]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:40.997]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:40.997]                   base::options(opts)
[13:33:40.997]                 }
[13:33:40.997]                 {
[13:33:40.997]                   {
[13:33:40.997]                     NULL
[13:33:40.997]                     RNGkind("Mersenne-Twister")
[13:33:40.997]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:40.997]                       inherits = FALSE)
[13:33:40.997]                   }
[13:33:40.997]                   options(future.plan = NULL)
[13:33:40.997]                   if (is.na(NA_character_)) 
[13:33:40.997]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:40.997]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:40.997]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:40.997]                     .init = FALSE)
[13:33:40.997]                 }
[13:33:40.997]             }
[13:33:40.997]         }
[13:33:40.997]     })
[13:33:40.997]     if (TRUE) {
[13:33:40.997]         base::sink(type = "output", split = FALSE)
[13:33:40.997]         if (TRUE) {
[13:33:40.997]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:40.997]         }
[13:33:40.997]         else {
[13:33:40.997]             ...future.result["stdout"] <- base::list(NULL)
[13:33:40.997]         }
[13:33:40.997]         base::close(...future.stdout)
[13:33:40.997]         ...future.stdout <- NULL
[13:33:40.997]     }
[13:33:40.997]     ...future.result$conditions <- ...future.conditions
[13:33:40.997]     ...future.result$finished <- base::Sys.time()
[13:33:40.997]     ...future.result
[13:33:40.997] }
[13:33:40.999] assign_globals() ...
[13:33:40.999] List of 5
[13:33:40.999]  $ ...future.FUN            :function (x, ...)  
[13:33:40.999]  $ future.call.arguments    :List of 1
[13:33:40.999]   ..$ singular.ok: logi FALSE
[13:33:40.999]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:40.999]  $ ...future.elements_ii    :List of 3
[13:33:40.999]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:40.999]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:33:40.999]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:40.999]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:40.999]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:40.999]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:33:40.999]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:40.999]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:33:40.999]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:40.999]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:33:40.999]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:40.999]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:33:40.999]  $ ...future.seeds_ii       : NULL
[13:33:40.999]  $ ...future.globals.maxSize: NULL
[13:33:40.999]  - attr(*, "where")=List of 5
[13:33:40.999]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:40.999]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:40.999]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:40.999]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:40.999]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:40.999]  - attr(*, "resolved")= logi FALSE
[13:33:40.999]  - attr(*, "total_size")= num 5384
[13:33:40.999]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:40.999]  - attr(*, "already-done")= logi TRUE
[13:33:41.008] - reassign environment for ‘...future.FUN’
[13:33:41.008] - copied ‘...future.FUN’ to environment
[13:33:41.008] - copied ‘future.call.arguments’ to environment
[13:33:41.008] - copied ‘...future.elements_ii’ to environment
[13:33:41.008] - copied ‘...future.seeds_ii’ to environment
[13:33:41.008] - copied ‘...future.globals.maxSize’ to environment
[13:33:41.008] assign_globals() ... done
[13:33:41.009] plan(): Setting new future strategy stack:
[13:33:41.009] List of future strategies:
[13:33:41.009] 1. sequential:
[13:33:41.009]    - args: function (..., envir = parent.frame())
[13:33:41.009]    - tweaked: FALSE
[13:33:41.009]    - call: NULL
[13:33:41.009] plan(): nbrOfWorkers() = 1
[13:33:41.012] plan(): Setting new future strategy stack:
[13:33:41.012] List of future strategies:
[13:33:41.012] 1. multicore:
[13:33:41.012]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:41.012]    - tweaked: FALSE
[13:33:41.012]    - call: plan(strategy)
[13:33:41.015] plan(): nbrOfWorkers() = 1
[13:33:41.015] SequentialFuture started (and completed)
[13:33:41.015] - Launch lazy future ... done
[13:33:41.016] run() for ‘SequentialFuture’ ... done
[13:33:41.016] Created future:
[13:33:41.016] SequentialFuture:
[13:33:41.016] Label: ‘future_by-1’
[13:33:41.016] Expression:
[13:33:41.016] {
[13:33:41.016]     do.call(function(...) {
[13:33:41.016]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.016]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.016]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.016]             on.exit(options(oopts), add = TRUE)
[13:33:41.016]         }
[13:33:41.016]         {
[13:33:41.016]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.016]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.016]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.016]             })
[13:33:41.016]         }
[13:33:41.016]     }, args = future.call.arguments)
[13:33:41.016] }
[13:33:41.016] Lazy evaluation: FALSE
[13:33:41.016] Asynchronous evaluation: FALSE
[13:33:41.016] Local evaluation: TRUE
[13:33:41.016] Environment: R_GlobalEnv
[13:33:41.016] Capture standard output: TRUE
[13:33:41.016] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:41.016] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:41.016] Packages: 1 packages (‘stats’)
[13:33:41.016] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:41.016] Resolved: TRUE
[13:33:41.016] Value: 26.06 KiB of class ‘list’
[13:33:41.016] Early signaling: FALSE
[13:33:41.016] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:41.016] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.017] Chunk #1 of 1 ... DONE
[13:33:41.017] Launching 1 futures (chunks) ... DONE
[13:33:41.017] Resolving 1 futures (chunks) ...
[13:33:41.017] resolve() on list ...
[13:33:41.017]  recursive: 0
[13:33:41.018]  length: 1
[13:33:41.018] 
[13:33:41.018] resolved() for ‘SequentialFuture’ ...
[13:33:41.018] - state: ‘finished’
[13:33:41.018] - run: TRUE
[13:33:41.018] - result: ‘FutureResult’
[13:33:41.018] resolved() for ‘SequentialFuture’ ... done
[13:33:41.018] Future #1
[13:33:41.018] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:41.018] - nx: 1
[13:33:41.019] - relay: TRUE
[13:33:41.019] - stdout: TRUE
[13:33:41.019] - signal: TRUE
[13:33:41.020] - resignal: FALSE
[13:33:41.020] - force: TRUE
[13:33:41.020] - relayed: [n=1] FALSE
[13:33:41.020] - queued futures: [n=1] FALSE
[13:33:41.020]  - until=1
[13:33:41.020]  - relaying element #1
[13:33:41.020] - relayed: [n=1] TRUE
[13:33:41.020] - queued futures: [n=1] TRUE
[13:33:41.020] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:41.020]  length: 0 (resolved future 1)
[13:33:41.021] Relaying remaining futures
[13:33:41.021] signalConditionsASAP(NULL, pos=0) ...
[13:33:41.021] - nx: 1
[13:33:41.021] - relay: TRUE
[13:33:41.021] - stdout: TRUE
[13:33:41.021] - signal: TRUE
[13:33:41.021] - resignal: FALSE
[13:33:41.021] - force: TRUE
[13:33:41.021] - relayed: [n=1] TRUE
[13:33:41.021] - queued futures: [n=1] TRUE
 - flush all
[13:33:41.021] - relayed: [n=1] TRUE
[13:33:41.022] - queued futures: [n=1] TRUE
[13:33:41.022] signalConditionsASAP(NULL, pos=0) ... done
[13:33:41.022] resolve() on list ... DONE
[13:33:41.022]  - Number of value chunks collected: 1
[13:33:41.022] Resolving 1 futures (chunks) ... DONE
[13:33:41.022] Reducing values from 1 chunks ...
[13:33:41.022]  - Number of values collected after concatenation: 3
[13:33:41.022]  - Number of values expected: 3
[13:33:41.022] Reducing values from 1 chunks ... DONE
[13:33:41.022] future_lapply() ... DONE
[13:33:41.022] future_by_internal() ... DONE
[13:33:41.026] future_by_internal() ...
[13:33:41.027] future_lapply() ...
[13:33:41.030] Number of chunks: 1
[13:33:41.030] getGlobalsAndPackagesXApply() ...
[13:33:41.030]  - future.globals: TRUE
[13:33:41.030] getGlobalsAndPackages() ...
[13:33:41.031] Searching for globals...
[13:33:41.032] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:33:41.032] Searching for globals ... DONE
[13:33:41.032] Resolving globals: FALSE
[13:33:41.033] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[13:33:41.033] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[13:33:41.033] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[13:33:41.033] - packages: [1] ‘stats’
[13:33:41.033] getGlobalsAndPackages() ... DONE
[13:33:41.034]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[13:33:41.034]  - needed namespaces: [n=1] ‘stats’
[13:33:41.034] Finding globals ... DONE
[13:33:41.034]  - use_args: TRUE
[13:33:41.034]  - Getting '...' globals ...
[13:33:41.034] resolve() on list ...
[13:33:41.034]  recursive: 0
[13:33:41.034]  length: 1
[13:33:41.035]  elements: ‘...’
[13:33:41.035]  length: 0 (resolved future 1)
[13:33:41.035] resolve() on list ... DONE
[13:33:41.035]    - '...' content: [n=0] 
[13:33:41.035] List of 1
[13:33:41.035]  $ ...: list()
[13:33:41.035]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.035]  - attr(*, "where")=List of 1
[13:33:41.035]   ..$ ...:<environment: 0x55cb81c5e958> 
[13:33:41.035]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.035]  - attr(*, "resolved")= logi TRUE
[13:33:41.035]  - attr(*, "total_size")= num NA
[13:33:41.037]  - Getting '...' globals ... DONE
[13:33:41.037] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[13:33:41.037] List of 4
[13:33:41.037]  $ ...future.FUN:function (x)  
[13:33:41.037]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:33:41.037]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:41.037]  $ ...          : list()
[13:33:41.037]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.037]  - attr(*, "where")=List of 4
[13:33:41.037]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:41.037]   ..$ breaks       :<environment: R_EmptyEnv> 
[13:33:41.037]   ..$ wool         :<environment: R_EmptyEnv> 
[13:33:41.037]   ..$ ...          :<environment: 0x55cb81c5e958> 
[13:33:41.037]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.037]  - attr(*, "resolved")= logi FALSE
[13:33:41.037]  - attr(*, "total_size")= num 2320
[13:33:41.042] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:41.042] getGlobalsAndPackagesXApply() ... DONE
[13:33:41.042] Number of futures (= number of chunks): 1
[13:33:41.042] Launching 1 futures (chunks) ...
[13:33:41.042] Chunk #1 of 1 ...
[13:33:41.043]  - Finding globals in 'X' for chunk #1 ...
[13:33:41.043] getGlobalsAndPackages() ...
[13:33:41.043] Searching for globals...
[13:33:41.043] 
[13:33:41.043] Searching for globals ... DONE
[13:33:41.043] - globals: [0] <none>
[13:33:41.043] getGlobalsAndPackages() ... DONE
[13:33:41.044]    + additional globals found: [n=0] 
[13:33:41.044]    + additional namespaces needed: [n=0] 
[13:33:41.044]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:41.044]  - seeds: <none>
[13:33:41.044]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.044] getGlobalsAndPackages() ...
[13:33:41.044] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.044] Resolving globals: FALSE
[13:33:41.044] Tweak future expression to call with '...' arguments ...
[13:33:41.044] {
[13:33:41.044]     do.call(function(...) {
[13:33:41.044]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.044]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.044]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.044]             on.exit(options(oopts), add = TRUE)
[13:33:41.044]         }
[13:33:41.044]         {
[13:33:41.044]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.044]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.044]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.044]             })
[13:33:41.044]         }
[13:33:41.044]     }, args = future.call.arguments)
[13:33:41.044] }
[13:33:41.045] Tweak future expression to call with '...' arguments ... DONE
[13:33:41.045] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.045] 
[13:33:41.045] getGlobalsAndPackages() ... DONE
[13:33:41.045] run() for ‘Future’ ...
[13:33:41.046] - state: ‘created’
[13:33:41.046] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:41.049] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.049] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:41.049]   - Field: ‘label’
[13:33:41.049]   - Field: ‘local’
[13:33:41.049]   - Field: ‘owner’
[13:33:41.050]   - Field: ‘envir’
[13:33:41.050]   - Field: ‘packages’
[13:33:41.050]   - Field: ‘gc’
[13:33:41.050]   - Field: ‘conditions’
[13:33:41.050]   - Field: ‘expr’
[13:33:41.050]   - Field: ‘uuid’
[13:33:41.050]   - Field: ‘seed’
[13:33:41.050]   - Field: ‘version’
[13:33:41.050]   - Field: ‘result’
[13:33:41.050]   - Field: ‘asynchronous’
[13:33:41.050]   - Field: ‘calls’
[13:33:41.051]   - Field: ‘globals’
[13:33:41.051]   - Field: ‘stdout’
[13:33:41.051]   - Field: ‘earlySignal’
[13:33:41.051]   - Field: ‘lazy’
[13:33:41.051]   - Field: ‘state’
[13:33:41.051] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:41.051] - Launch lazy future ...
[13:33:41.051] Packages needed by the future expression (n = 1): ‘stats’
[13:33:41.051] Packages needed by future strategies (n = 0): <none>
[13:33:41.052] {
[13:33:41.052]     {
[13:33:41.052]         {
[13:33:41.052]             ...future.startTime <- base::Sys.time()
[13:33:41.052]             {
[13:33:41.052]                 {
[13:33:41.052]                   {
[13:33:41.052]                     {
[13:33:41.052]                       base::local({
[13:33:41.052]                         has_future <- base::requireNamespace("future", 
[13:33:41.052]                           quietly = TRUE)
[13:33:41.052]                         if (has_future) {
[13:33:41.052]                           ns <- base::getNamespace("future")
[13:33:41.052]                           version <- ns[[".package"]][["version"]]
[13:33:41.052]                           if (is.null(version)) 
[13:33:41.052]                             version <- utils::packageVersion("future")
[13:33:41.052]                         }
[13:33:41.052]                         else {
[13:33:41.052]                           version <- NULL
[13:33:41.052]                         }
[13:33:41.052]                         if (!has_future || version < "1.8.0") {
[13:33:41.052]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:41.052]                             "", base::R.version$version.string), 
[13:33:41.052]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:41.052]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:41.052]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:41.052]                               "release", "version")], collapse = " "), 
[13:33:41.052]                             hostname = base::Sys.info()[["nodename"]])
[13:33:41.052]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:41.052]                             info)
[13:33:41.052]                           info <- base::paste(info, collapse = "; ")
[13:33:41.052]                           if (!has_future) {
[13:33:41.052]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:41.052]                               info)
[13:33:41.052]                           }
[13:33:41.052]                           else {
[13:33:41.052]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:41.052]                               info, version)
[13:33:41.052]                           }
[13:33:41.052]                           base::stop(msg)
[13:33:41.052]                         }
[13:33:41.052]                       })
[13:33:41.052]                     }
[13:33:41.052]                     base::local({
[13:33:41.052]                       for (pkg in "stats") {
[13:33:41.052]                         base::loadNamespace(pkg)
[13:33:41.052]                         base::library(pkg, character.only = TRUE)
[13:33:41.052]                       }
[13:33:41.052]                     })
[13:33:41.052]                   }
[13:33:41.052]                   ...future.strategy.old <- future::plan("list")
[13:33:41.052]                   options(future.plan = NULL)
[13:33:41.052]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.052]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:41.052]                 }
[13:33:41.052]                 ...future.workdir <- getwd()
[13:33:41.052]             }
[13:33:41.052]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:41.052]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:41.052]         }
[13:33:41.052]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:41.052]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:41.052]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:41.052]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:41.052]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:41.052]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:41.052]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:41.052]             base::names(...future.oldOptions))
[13:33:41.052]     }
[13:33:41.052]     if (FALSE) {
[13:33:41.052]     }
[13:33:41.052]     else {
[13:33:41.052]         if (TRUE) {
[13:33:41.052]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:41.052]                 open = "w")
[13:33:41.052]         }
[13:33:41.052]         else {
[13:33:41.052]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:41.052]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:41.052]         }
[13:33:41.052]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:41.052]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:41.052]             base::sink(type = "output", split = FALSE)
[13:33:41.052]             base::close(...future.stdout)
[13:33:41.052]         }, add = TRUE)
[13:33:41.052]     }
[13:33:41.052]     ...future.frame <- base::sys.nframe()
[13:33:41.052]     ...future.conditions <- base::list()
[13:33:41.052]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:41.052]     if (FALSE) {
[13:33:41.052]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:41.052]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:41.052]     }
[13:33:41.052]     ...future.result <- base::tryCatch({
[13:33:41.052]         base::withCallingHandlers({
[13:33:41.052]             ...future.value <- base::withVisible(base::local({
[13:33:41.052]                 do.call(function(...) {
[13:33:41.052]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.052]                   if (!identical(...future.globals.maxSize.org, 
[13:33:41.052]                     ...future.globals.maxSize)) {
[13:33:41.052]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.052]                     on.exit(options(oopts), add = TRUE)
[13:33:41.052]                   }
[13:33:41.052]                   {
[13:33:41.052]                     lapply(seq_along(...future.elements_ii), 
[13:33:41.052]                       FUN = function(jj) {
[13:33:41.052]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.052]                         ...future.FUN(...future.X_jj, ...)
[13:33:41.052]                       })
[13:33:41.052]                   }
[13:33:41.052]                 }, args = future.call.arguments)
[13:33:41.052]             }))
[13:33:41.052]             future::FutureResult(value = ...future.value$value, 
[13:33:41.052]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.052]                   ...future.rng), globalenv = if (FALSE) 
[13:33:41.052]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:41.052]                     ...future.globalenv.names))
[13:33:41.052]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:41.052]         }, condition = base::local({
[13:33:41.052]             c <- base::c
[13:33:41.052]             inherits <- base::inherits
[13:33:41.052]             invokeRestart <- base::invokeRestart
[13:33:41.052]             length <- base::length
[13:33:41.052]             list <- base::list
[13:33:41.052]             seq.int <- base::seq.int
[13:33:41.052]             signalCondition <- base::signalCondition
[13:33:41.052]             sys.calls <- base::sys.calls
[13:33:41.052]             `[[` <- base::`[[`
[13:33:41.052]             `+` <- base::`+`
[13:33:41.052]             `<<-` <- base::`<<-`
[13:33:41.052]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:41.052]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:41.052]                   3L)]
[13:33:41.052]             }
[13:33:41.052]             function(cond) {
[13:33:41.052]                 is_error <- inherits(cond, "error")
[13:33:41.052]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:41.052]                   NULL)
[13:33:41.052]                 if (is_error) {
[13:33:41.052]                   sessionInformation <- function() {
[13:33:41.052]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:41.052]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:41.052]                       search = base::search(), system = base::Sys.info())
[13:33:41.052]                   }
[13:33:41.052]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.052]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:41.052]                     cond$call), session = sessionInformation(), 
[13:33:41.052]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:41.052]                   signalCondition(cond)
[13:33:41.052]                 }
[13:33:41.052]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:41.052]                 "immediateCondition"))) {
[13:33:41.052]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:41.052]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.052]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:41.052]                   if (TRUE && !signal) {
[13:33:41.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.052]                     {
[13:33:41.052]                       inherits <- base::inherits
[13:33:41.052]                       invokeRestart <- base::invokeRestart
[13:33:41.052]                       is.null <- base::is.null
[13:33:41.052]                       muffled <- FALSE
[13:33:41.052]                       if (inherits(cond, "message")) {
[13:33:41.052]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.052]                         if (muffled) 
[13:33:41.052]                           invokeRestart("muffleMessage")
[13:33:41.052]                       }
[13:33:41.052]                       else if (inherits(cond, "warning")) {
[13:33:41.052]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.052]                         if (muffled) 
[13:33:41.052]                           invokeRestart("muffleWarning")
[13:33:41.052]                       }
[13:33:41.052]                       else if (inherits(cond, "condition")) {
[13:33:41.052]                         if (!is.null(pattern)) {
[13:33:41.052]                           computeRestarts <- base::computeRestarts
[13:33:41.052]                           grepl <- base::grepl
[13:33:41.052]                           restarts <- computeRestarts(cond)
[13:33:41.052]                           for (restart in restarts) {
[13:33:41.052]                             name <- restart$name
[13:33:41.052]                             if (is.null(name)) 
[13:33:41.052]                               next
[13:33:41.052]                             if (!grepl(pattern, name)) 
[13:33:41.052]                               next
[13:33:41.052]                             invokeRestart(restart)
[13:33:41.052]                             muffled <- TRUE
[13:33:41.052]                             break
[13:33:41.052]                           }
[13:33:41.052]                         }
[13:33:41.052]                       }
[13:33:41.052]                       invisible(muffled)
[13:33:41.052]                     }
[13:33:41.052]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.052]                   }
[13:33:41.052]                 }
[13:33:41.052]                 else {
[13:33:41.052]                   if (TRUE) {
[13:33:41.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.052]                     {
[13:33:41.052]                       inherits <- base::inherits
[13:33:41.052]                       invokeRestart <- base::invokeRestart
[13:33:41.052]                       is.null <- base::is.null
[13:33:41.052]                       muffled <- FALSE
[13:33:41.052]                       if (inherits(cond, "message")) {
[13:33:41.052]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.052]                         if (muffled) 
[13:33:41.052]                           invokeRestart("muffleMessage")
[13:33:41.052]                       }
[13:33:41.052]                       else if (inherits(cond, "warning")) {
[13:33:41.052]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.052]                         if (muffled) 
[13:33:41.052]                           invokeRestart("muffleWarning")
[13:33:41.052]                       }
[13:33:41.052]                       else if (inherits(cond, "condition")) {
[13:33:41.052]                         if (!is.null(pattern)) {
[13:33:41.052]                           computeRestarts <- base::computeRestarts
[13:33:41.052]                           grepl <- base::grepl
[13:33:41.052]                           restarts <- computeRestarts(cond)
[13:33:41.052]                           for (restart in restarts) {
[13:33:41.052]                             name <- restart$name
[13:33:41.052]                             if (is.null(name)) 
[13:33:41.052]                               next
[13:33:41.052]                             if (!grepl(pattern, name)) 
[13:33:41.052]                               next
[13:33:41.052]                             invokeRestart(restart)
[13:33:41.052]                             muffled <- TRUE
[13:33:41.052]                             break
[13:33:41.052]                           }
[13:33:41.052]                         }
[13:33:41.052]                       }
[13:33:41.052]                       invisible(muffled)
[13:33:41.052]                     }
[13:33:41.052]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.052]                   }
[13:33:41.052]                 }
[13:33:41.052]             }
[13:33:41.052]         }))
[13:33:41.052]     }, error = function(ex) {
[13:33:41.052]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:41.052]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.052]                 ...future.rng), started = ...future.startTime, 
[13:33:41.052]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:41.052]             version = "1.8"), class = "FutureResult")
[13:33:41.052]     }, finally = {
[13:33:41.052]         if (!identical(...future.workdir, getwd())) 
[13:33:41.052]             setwd(...future.workdir)
[13:33:41.052]         {
[13:33:41.052]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:41.052]                 ...future.oldOptions$nwarnings <- NULL
[13:33:41.052]             }
[13:33:41.052]             base::options(...future.oldOptions)
[13:33:41.052]             if (.Platform$OS.type == "windows") {
[13:33:41.052]                 old_names <- names(...future.oldEnvVars)
[13:33:41.052]                 envs <- base::Sys.getenv()
[13:33:41.052]                 names <- names(envs)
[13:33:41.052]                 common <- intersect(names, old_names)
[13:33:41.052]                 added <- setdiff(names, old_names)
[13:33:41.052]                 removed <- setdiff(old_names, names)
[13:33:41.052]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:41.052]                   envs[common]]
[13:33:41.052]                 NAMES <- toupper(changed)
[13:33:41.052]                 args <- list()
[13:33:41.052]                 for (kk in seq_along(NAMES)) {
[13:33:41.052]                   name <- changed[[kk]]
[13:33:41.052]                   NAME <- NAMES[[kk]]
[13:33:41.052]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.052]                     next
[13:33:41.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.052]                 }
[13:33:41.052]                 NAMES <- toupper(added)
[13:33:41.052]                 for (kk in seq_along(NAMES)) {
[13:33:41.052]                   name <- added[[kk]]
[13:33:41.052]                   NAME <- NAMES[[kk]]
[13:33:41.052]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.052]                     next
[13:33:41.052]                   args[[name]] <- ""
[13:33:41.052]                 }
[13:33:41.052]                 NAMES <- toupper(removed)
[13:33:41.052]                 for (kk in seq_along(NAMES)) {
[13:33:41.052]                   name <- removed[[kk]]
[13:33:41.052]                   NAME <- NAMES[[kk]]
[13:33:41.052]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.052]                     next
[13:33:41.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.052]                 }
[13:33:41.052]                 if (length(args) > 0) 
[13:33:41.052]                   base::do.call(base::Sys.setenv, args = args)
[13:33:41.052]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:41.052]             }
[13:33:41.052]             else {
[13:33:41.052]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:41.052]             }
[13:33:41.052]             {
[13:33:41.052]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:41.052]                   0L) {
[13:33:41.052]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:41.052]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:41.052]                   base::options(opts)
[13:33:41.052]                 }
[13:33:41.052]                 {
[13:33:41.052]                   {
[13:33:41.052]                     NULL
[13:33:41.052]                     RNGkind("Mersenne-Twister")
[13:33:41.052]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:41.052]                       inherits = FALSE)
[13:33:41.052]                   }
[13:33:41.052]                   options(future.plan = NULL)
[13:33:41.052]                   if (is.na(NA_character_)) 
[13:33:41.052]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.052]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:41.052]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:41.052]                     .init = FALSE)
[13:33:41.052]                 }
[13:33:41.052]             }
[13:33:41.052]         }
[13:33:41.052]     })
[13:33:41.052]     if (TRUE) {
[13:33:41.052]         base::sink(type = "output", split = FALSE)
[13:33:41.052]         if (TRUE) {
[13:33:41.052]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:41.052]         }
[13:33:41.052]         else {
[13:33:41.052]             ...future.result["stdout"] <- base::list(NULL)
[13:33:41.052]         }
[13:33:41.052]         base::close(...future.stdout)
[13:33:41.052]         ...future.stdout <- NULL
[13:33:41.052]     }
[13:33:41.052]     ...future.result$conditions <- ...future.conditions
[13:33:41.052]     ...future.result$finished <- base::Sys.time()
[13:33:41.052]     ...future.result
[13:33:41.052] }
[13:33:41.053] assign_globals() ...
[13:33:41.054] List of 7
[13:33:41.054]  $ ...future.FUN            :function (x)  
[13:33:41.054]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:33:41.054]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:41.054]  $ future.call.arguments    : list()
[13:33:41.054]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.054]  $ ...future.elements_ii    :List of 3
[13:33:41.054]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.054]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:33:41.054]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.054]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:41.054]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.054]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:33:41.054]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.054]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:33:41.054]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.054]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:33:41.054]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.054]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:33:41.054]  $ ...future.seeds_ii       : NULL
[13:33:41.054]  $ ...future.globals.maxSize: NULL
[13:33:41.054]  - attr(*, "where")=List of 7
[13:33:41.054]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:41.054]   ..$ breaks                   :<environment: R_EmptyEnv> 
[13:33:41.054]   ..$ wool                     :<environment: R_EmptyEnv> 
[13:33:41.054]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:41.054]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:41.054]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:41.054]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:41.054]  - attr(*, "resolved")= logi FALSE
[13:33:41.054]  - attr(*, "total_size")= num 2320
[13:33:41.054]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.054]  - attr(*, "already-done")= logi TRUE
[13:33:41.063] - reassign environment for ‘...future.FUN’
[13:33:41.064] - copied ‘...future.FUN’ to environment
[13:33:41.064] - copied ‘breaks’ to environment
[13:33:41.064] - copied ‘wool’ to environment
[13:33:41.064] - copied ‘future.call.arguments’ to environment
[13:33:41.064] - copied ‘...future.elements_ii’ to environment
[13:33:41.064] - copied ‘...future.seeds_ii’ to environment
[13:33:41.064] - copied ‘...future.globals.maxSize’ to environment
[13:33:41.064] assign_globals() ... done
[13:33:41.065] plan(): Setting new future strategy stack:
[13:33:41.065] List of future strategies:
[13:33:41.065] 1. sequential:
[13:33:41.065]    - args: function (..., envir = parent.frame())
[13:33:41.065]    - tweaked: FALSE
[13:33:41.065]    - call: NULL
[13:33:41.065] plan(): nbrOfWorkers() = 1
[13:33:41.068] plan(): Setting new future strategy stack:
[13:33:41.068] List of future strategies:
[13:33:41.068] 1. multicore:
[13:33:41.068]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:41.068]    - tweaked: FALSE
[13:33:41.068]    - call: plan(strategy)
[13:33:41.071] plan(): nbrOfWorkers() = 1
[13:33:41.071] SequentialFuture started (and completed)
[13:33:41.071] - Launch lazy future ... done
[13:33:41.071] run() for ‘SequentialFuture’ ... done
[13:33:41.071] Created future:
[13:33:41.072] SequentialFuture:
[13:33:41.072] Label: ‘future_by-1’
[13:33:41.072] Expression:
[13:33:41.072] {
[13:33:41.072]     do.call(function(...) {
[13:33:41.072]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.072]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.072]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.072]             on.exit(options(oopts), add = TRUE)
[13:33:41.072]         }
[13:33:41.072]         {
[13:33:41.072]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.072]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.072]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.072]             })
[13:33:41.072]         }
[13:33:41.072]     }, args = future.call.arguments)
[13:33:41.072] }
[13:33:41.072] Lazy evaluation: FALSE
[13:33:41.072] Asynchronous evaluation: FALSE
[13:33:41.072] Local evaluation: TRUE
[13:33:41.072] Environment: 0x55cb81bc22a8
[13:33:41.072] Capture standard output: TRUE
[13:33:41.072] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:41.072] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[13:33:41.072] Packages: 1 packages (‘stats’)
[13:33:41.072] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:41.072] Resolved: TRUE
[13:33:41.072] Value: 25.57 KiB of class ‘list’
[13:33:41.072] Early signaling: FALSE
[13:33:41.072] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:41.072] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.073] Chunk #1 of 1 ... DONE
[13:33:41.073] Launching 1 futures (chunks) ... DONE
[13:33:41.073] Resolving 1 futures (chunks) ...
[13:33:41.073] resolve() on list ...
[13:33:41.073]  recursive: 0
[13:33:41.074]  length: 1
[13:33:41.074] 
[13:33:41.074] resolved() for ‘SequentialFuture’ ...
[13:33:41.074] - state: ‘finished’
[13:33:41.074] - run: TRUE
[13:33:41.074] - result: ‘FutureResult’
[13:33:41.074] resolved() for ‘SequentialFuture’ ... done
[13:33:41.074] Future #1
[13:33:41.074] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:41.074] - nx: 1
[13:33:41.074] - relay: TRUE
[13:33:41.075] - stdout: TRUE
[13:33:41.075] - signal: TRUE
[13:33:41.075] - resignal: FALSE
[13:33:41.075] - force: TRUE
[13:33:41.075] - relayed: [n=1] FALSE
[13:33:41.075] - queued futures: [n=1] FALSE
[13:33:41.075]  - until=1
[13:33:41.075]  - relaying element #1
[13:33:41.075] - relayed: [n=1] TRUE
[13:33:41.075] - queued futures: [n=1] TRUE
[13:33:41.075] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:41.076]  length: 0 (resolved future 1)
[13:33:41.076] Relaying remaining futures
[13:33:41.076] signalConditionsASAP(NULL, pos=0) ...
[13:33:41.076] - nx: 1
[13:33:41.076] - relay: TRUE
[13:33:41.076] - stdout: TRUE
[13:33:41.076] - signal: TRUE
[13:33:41.076] - resignal: FALSE
[13:33:41.076] - force: TRUE
[13:33:41.076] - relayed: [n=1] TRUE
[13:33:41.076] - queued futures: [n=1] TRUE
 - flush all
[13:33:41.076] - relayed: [n=1] TRUE
[13:33:41.077] - queued futures: [n=1] TRUE
[13:33:41.077] signalConditionsASAP(NULL, pos=0) ... done
[13:33:41.077] resolve() on list ... DONE
[13:33:41.077]  - Number of value chunks collected: 1
[13:33:41.077] Resolving 1 futures (chunks) ... DONE
[13:33:41.077] Reducing values from 1 chunks ...
[13:33:41.077]  - Number of values collected after concatenation: 3
[13:33:41.077]  - Number of values expected: 3
[13:33:41.077] Reducing values from 1 chunks ... DONE
[13:33:41.077] future_lapply() ... DONE
[13:33:41.077] future_by_internal() ... DONE
[13:33:41.078] future_by_internal() ...
[13:33:41.078] future_lapply() ...
[13:33:41.081] Number of chunks: 1
[13:33:41.082] getGlobalsAndPackagesXApply() ...
[13:33:41.082]  - future.globals: TRUE
[13:33:41.082] getGlobalsAndPackages() ...
[13:33:41.082] Searching for globals...
[13:33:41.083] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:41.083] Searching for globals ... DONE
[13:33:41.083] Resolving globals: FALSE
[13:33:41.083] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:41.084] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:41.084] - globals: [1] ‘FUN’
[13:33:41.084] 
[13:33:41.084] getGlobalsAndPackages() ... DONE
[13:33:41.084]  - globals found/used: [n=1] ‘FUN’
[13:33:41.084]  - needed namespaces: [n=0] 
[13:33:41.084] Finding globals ... DONE
[13:33:41.084]  - use_args: TRUE
[13:33:41.084]  - Getting '...' globals ...
[13:33:41.085] resolve() on list ...
[13:33:41.085]  recursive: 0
[13:33:41.085]  length: 1
[13:33:41.085]  elements: ‘...’
[13:33:41.085]  length: 0 (resolved future 1)
[13:33:41.085] resolve() on list ... DONE
[13:33:41.085]    - '...' content: [n=0] 
[13:33:41.085] List of 1
[13:33:41.085]  $ ...: list()
[13:33:41.085]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.085]  - attr(*, "where")=List of 1
[13:33:41.085]   ..$ ...:<environment: 0x55cb824b49f8> 
[13:33:41.085]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.085]  - attr(*, "resolved")= logi TRUE
[13:33:41.085]  - attr(*, "total_size")= num NA
[13:33:41.088]  - Getting '...' globals ... DONE
[13:33:41.089] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:41.089] List of 2
[13:33:41.089]  $ ...future.FUN:function (object, ...)  
[13:33:41.089]  $ ...          : list()
[13:33:41.089]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.089]  - attr(*, "where")=List of 2
[13:33:41.089]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:41.089]   ..$ ...          :<environment: 0x55cb824b49f8> 
[13:33:41.089]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.089]  - attr(*, "resolved")= logi FALSE
[13:33:41.089]  - attr(*, "total_size")= num 1240
[13:33:41.091] Packages to be attached in all futures: [n=0] 
[13:33:41.091] getGlobalsAndPackagesXApply() ... DONE
[13:33:41.092] Number of futures (= number of chunks): 1
[13:33:41.092] Launching 1 futures (chunks) ...
[13:33:41.092] Chunk #1 of 1 ...
[13:33:41.092]  - Finding globals in 'X' for chunk #1 ...
[13:33:41.092] getGlobalsAndPackages() ...
[13:33:41.092] Searching for globals...
[13:33:41.092] 
[13:33:41.093] Searching for globals ... DONE
[13:33:41.093] - globals: [0] <none>
[13:33:41.093] getGlobalsAndPackages() ... DONE
[13:33:41.093]    + additional globals found: [n=0] 
[13:33:41.093]    + additional namespaces needed: [n=0] 
[13:33:41.093]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:41.093]  - seeds: <none>
[13:33:41.093]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.093] getGlobalsAndPackages() ...
[13:33:41.093] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.093] Resolving globals: FALSE
[13:33:41.094] Tweak future expression to call with '...' arguments ...
[13:33:41.094] {
[13:33:41.094]     do.call(function(...) {
[13:33:41.094]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.094]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.094]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.094]             on.exit(options(oopts), add = TRUE)
[13:33:41.094]         }
[13:33:41.094]         {
[13:33:41.094]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.094]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.094]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.094]             })
[13:33:41.094]         }
[13:33:41.094]     }, args = future.call.arguments)
[13:33:41.094] }
[13:33:41.094] Tweak future expression to call with '...' arguments ... DONE
[13:33:41.094] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.094] 
[13:33:41.094] getGlobalsAndPackages() ... DONE
[13:33:41.095] run() for ‘Future’ ...
[13:33:41.095] - state: ‘created’
[13:33:41.095] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:41.098] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.098] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:41.098]   - Field: ‘label’
[13:33:41.099]   - Field: ‘local’
[13:33:41.099]   - Field: ‘owner’
[13:33:41.099]   - Field: ‘envir’
[13:33:41.099]   - Field: ‘packages’
[13:33:41.099]   - Field: ‘gc’
[13:33:41.099]   - Field: ‘conditions’
[13:33:41.099]   - Field: ‘expr’
[13:33:41.099]   - Field: ‘uuid’
[13:33:41.099]   - Field: ‘seed’
[13:33:41.099]   - Field: ‘version’
[13:33:41.099]   - Field: ‘result’
[13:33:41.099]   - Field: ‘asynchronous’
[13:33:41.100]   - Field: ‘calls’
[13:33:41.100]   - Field: ‘globals’
[13:33:41.100]   - Field: ‘stdout’
[13:33:41.100]   - Field: ‘earlySignal’
[13:33:41.100]   - Field: ‘lazy’
[13:33:41.100]   - Field: ‘state’
[13:33:41.100] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:41.100] - Launch lazy future ...
[13:33:41.100] Packages needed by the future expression (n = 0): <none>
[13:33:41.100] Packages needed by future strategies (n = 0): <none>
[13:33:41.101] {
[13:33:41.101]     {
[13:33:41.101]         {
[13:33:41.101]             ...future.startTime <- base::Sys.time()
[13:33:41.101]             {
[13:33:41.101]                 {
[13:33:41.101]                   {
[13:33:41.101]                     base::local({
[13:33:41.101]                       has_future <- base::requireNamespace("future", 
[13:33:41.101]                         quietly = TRUE)
[13:33:41.101]                       if (has_future) {
[13:33:41.101]                         ns <- base::getNamespace("future")
[13:33:41.101]                         version <- ns[[".package"]][["version"]]
[13:33:41.101]                         if (is.null(version)) 
[13:33:41.101]                           version <- utils::packageVersion("future")
[13:33:41.101]                       }
[13:33:41.101]                       else {
[13:33:41.101]                         version <- NULL
[13:33:41.101]                       }
[13:33:41.101]                       if (!has_future || version < "1.8.0") {
[13:33:41.101]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:41.101]                           "", base::R.version$version.string), 
[13:33:41.101]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:41.101]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:41.101]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:41.101]                             "release", "version")], collapse = " "), 
[13:33:41.101]                           hostname = base::Sys.info()[["nodename"]])
[13:33:41.101]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:41.101]                           info)
[13:33:41.101]                         info <- base::paste(info, collapse = "; ")
[13:33:41.101]                         if (!has_future) {
[13:33:41.101]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:41.101]                             info)
[13:33:41.101]                         }
[13:33:41.101]                         else {
[13:33:41.101]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:41.101]                             info, version)
[13:33:41.101]                         }
[13:33:41.101]                         base::stop(msg)
[13:33:41.101]                       }
[13:33:41.101]                     })
[13:33:41.101]                   }
[13:33:41.101]                   ...future.strategy.old <- future::plan("list")
[13:33:41.101]                   options(future.plan = NULL)
[13:33:41.101]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.101]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:41.101]                 }
[13:33:41.101]                 ...future.workdir <- getwd()
[13:33:41.101]             }
[13:33:41.101]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:41.101]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:41.101]         }
[13:33:41.101]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:41.101]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:41.101]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:41.101]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:41.101]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:41.101]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:41.101]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:41.101]             base::names(...future.oldOptions))
[13:33:41.101]     }
[13:33:41.101]     if (FALSE) {
[13:33:41.101]     }
[13:33:41.101]     else {
[13:33:41.101]         if (TRUE) {
[13:33:41.101]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:41.101]                 open = "w")
[13:33:41.101]         }
[13:33:41.101]         else {
[13:33:41.101]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:41.101]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:41.101]         }
[13:33:41.101]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:41.101]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:41.101]             base::sink(type = "output", split = FALSE)
[13:33:41.101]             base::close(...future.stdout)
[13:33:41.101]         }, add = TRUE)
[13:33:41.101]     }
[13:33:41.101]     ...future.frame <- base::sys.nframe()
[13:33:41.101]     ...future.conditions <- base::list()
[13:33:41.101]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:41.101]     if (FALSE) {
[13:33:41.101]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:41.101]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:41.101]     }
[13:33:41.101]     ...future.result <- base::tryCatch({
[13:33:41.101]         base::withCallingHandlers({
[13:33:41.101]             ...future.value <- base::withVisible(base::local({
[13:33:41.101]                 do.call(function(...) {
[13:33:41.101]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.101]                   if (!identical(...future.globals.maxSize.org, 
[13:33:41.101]                     ...future.globals.maxSize)) {
[13:33:41.101]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.101]                     on.exit(options(oopts), add = TRUE)
[13:33:41.101]                   }
[13:33:41.101]                   {
[13:33:41.101]                     lapply(seq_along(...future.elements_ii), 
[13:33:41.101]                       FUN = function(jj) {
[13:33:41.101]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.101]                         ...future.FUN(...future.X_jj, ...)
[13:33:41.101]                       })
[13:33:41.101]                   }
[13:33:41.101]                 }, args = future.call.arguments)
[13:33:41.101]             }))
[13:33:41.101]             future::FutureResult(value = ...future.value$value, 
[13:33:41.101]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.101]                   ...future.rng), globalenv = if (FALSE) 
[13:33:41.101]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:41.101]                     ...future.globalenv.names))
[13:33:41.101]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:41.101]         }, condition = base::local({
[13:33:41.101]             c <- base::c
[13:33:41.101]             inherits <- base::inherits
[13:33:41.101]             invokeRestart <- base::invokeRestart
[13:33:41.101]             length <- base::length
[13:33:41.101]             list <- base::list
[13:33:41.101]             seq.int <- base::seq.int
[13:33:41.101]             signalCondition <- base::signalCondition
[13:33:41.101]             sys.calls <- base::sys.calls
[13:33:41.101]             `[[` <- base::`[[`
[13:33:41.101]             `+` <- base::`+`
[13:33:41.101]             `<<-` <- base::`<<-`
[13:33:41.101]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:41.101]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:41.101]                   3L)]
[13:33:41.101]             }
[13:33:41.101]             function(cond) {
[13:33:41.101]                 is_error <- inherits(cond, "error")
[13:33:41.101]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:41.101]                   NULL)
[13:33:41.101]                 if (is_error) {
[13:33:41.101]                   sessionInformation <- function() {
[13:33:41.101]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:41.101]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:41.101]                       search = base::search(), system = base::Sys.info())
[13:33:41.101]                   }
[13:33:41.101]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.101]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:41.101]                     cond$call), session = sessionInformation(), 
[13:33:41.101]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:41.101]                   signalCondition(cond)
[13:33:41.101]                 }
[13:33:41.101]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:41.101]                 "immediateCondition"))) {
[13:33:41.101]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:41.101]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.101]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:41.101]                   if (TRUE && !signal) {
[13:33:41.101]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.101]                     {
[13:33:41.101]                       inherits <- base::inherits
[13:33:41.101]                       invokeRestart <- base::invokeRestart
[13:33:41.101]                       is.null <- base::is.null
[13:33:41.101]                       muffled <- FALSE
[13:33:41.101]                       if (inherits(cond, "message")) {
[13:33:41.101]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.101]                         if (muffled) 
[13:33:41.101]                           invokeRestart("muffleMessage")
[13:33:41.101]                       }
[13:33:41.101]                       else if (inherits(cond, "warning")) {
[13:33:41.101]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.101]                         if (muffled) 
[13:33:41.101]                           invokeRestart("muffleWarning")
[13:33:41.101]                       }
[13:33:41.101]                       else if (inherits(cond, "condition")) {
[13:33:41.101]                         if (!is.null(pattern)) {
[13:33:41.101]                           computeRestarts <- base::computeRestarts
[13:33:41.101]                           grepl <- base::grepl
[13:33:41.101]                           restarts <- computeRestarts(cond)
[13:33:41.101]                           for (restart in restarts) {
[13:33:41.101]                             name <- restart$name
[13:33:41.101]                             if (is.null(name)) 
[13:33:41.101]                               next
[13:33:41.101]                             if (!grepl(pattern, name)) 
[13:33:41.101]                               next
[13:33:41.101]                             invokeRestart(restart)
[13:33:41.101]                             muffled <- TRUE
[13:33:41.101]                             break
[13:33:41.101]                           }
[13:33:41.101]                         }
[13:33:41.101]                       }
[13:33:41.101]                       invisible(muffled)
[13:33:41.101]                     }
[13:33:41.101]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.101]                   }
[13:33:41.101]                 }
[13:33:41.101]                 else {
[13:33:41.101]                   if (TRUE) {
[13:33:41.101]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.101]                     {
[13:33:41.101]                       inherits <- base::inherits
[13:33:41.101]                       invokeRestart <- base::invokeRestart
[13:33:41.101]                       is.null <- base::is.null
[13:33:41.101]                       muffled <- FALSE
[13:33:41.101]                       if (inherits(cond, "message")) {
[13:33:41.101]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.101]                         if (muffled) 
[13:33:41.101]                           invokeRestart("muffleMessage")
[13:33:41.101]                       }
[13:33:41.101]                       else if (inherits(cond, "warning")) {
[13:33:41.101]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.101]                         if (muffled) 
[13:33:41.101]                           invokeRestart("muffleWarning")
[13:33:41.101]                       }
[13:33:41.101]                       else if (inherits(cond, "condition")) {
[13:33:41.101]                         if (!is.null(pattern)) {
[13:33:41.101]                           computeRestarts <- base::computeRestarts
[13:33:41.101]                           grepl <- base::grepl
[13:33:41.101]                           restarts <- computeRestarts(cond)
[13:33:41.101]                           for (restart in restarts) {
[13:33:41.101]                             name <- restart$name
[13:33:41.101]                             if (is.null(name)) 
[13:33:41.101]                               next
[13:33:41.101]                             if (!grepl(pattern, name)) 
[13:33:41.101]                               next
[13:33:41.101]                             invokeRestart(restart)
[13:33:41.101]                             muffled <- TRUE
[13:33:41.101]                             break
[13:33:41.101]                           }
[13:33:41.101]                         }
[13:33:41.101]                       }
[13:33:41.101]                       invisible(muffled)
[13:33:41.101]                     }
[13:33:41.101]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.101]                   }
[13:33:41.101]                 }
[13:33:41.101]             }
[13:33:41.101]         }))
[13:33:41.101]     }, error = function(ex) {
[13:33:41.101]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:41.101]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.101]                 ...future.rng), started = ...future.startTime, 
[13:33:41.101]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:41.101]             version = "1.8"), class = "FutureResult")
[13:33:41.101]     }, finally = {
[13:33:41.101]         if (!identical(...future.workdir, getwd())) 
[13:33:41.101]             setwd(...future.workdir)
[13:33:41.101]         {
[13:33:41.101]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:41.101]                 ...future.oldOptions$nwarnings <- NULL
[13:33:41.101]             }
[13:33:41.101]             base::options(...future.oldOptions)
[13:33:41.101]             if (.Platform$OS.type == "windows") {
[13:33:41.101]                 old_names <- names(...future.oldEnvVars)
[13:33:41.101]                 envs <- base::Sys.getenv()
[13:33:41.101]                 names <- names(envs)
[13:33:41.101]                 common <- intersect(names, old_names)
[13:33:41.101]                 added <- setdiff(names, old_names)
[13:33:41.101]                 removed <- setdiff(old_names, names)
[13:33:41.101]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:41.101]                   envs[common]]
[13:33:41.101]                 NAMES <- toupper(changed)
[13:33:41.101]                 args <- list()
[13:33:41.101]                 for (kk in seq_along(NAMES)) {
[13:33:41.101]                   name <- changed[[kk]]
[13:33:41.101]                   NAME <- NAMES[[kk]]
[13:33:41.101]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.101]                     next
[13:33:41.101]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.101]                 }
[13:33:41.101]                 NAMES <- toupper(added)
[13:33:41.101]                 for (kk in seq_along(NAMES)) {
[13:33:41.101]                   name <- added[[kk]]
[13:33:41.101]                   NAME <- NAMES[[kk]]
[13:33:41.101]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.101]                     next
[13:33:41.101]                   args[[name]] <- ""
[13:33:41.101]                 }
[13:33:41.101]                 NAMES <- toupper(removed)
[13:33:41.101]                 for (kk in seq_along(NAMES)) {
[13:33:41.101]                   name <- removed[[kk]]
[13:33:41.101]                   NAME <- NAMES[[kk]]
[13:33:41.101]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.101]                     next
[13:33:41.101]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.101]                 }
[13:33:41.101]                 if (length(args) > 0) 
[13:33:41.101]                   base::do.call(base::Sys.setenv, args = args)
[13:33:41.101]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:41.101]             }
[13:33:41.101]             else {
[13:33:41.101]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:41.101]             }
[13:33:41.101]             {
[13:33:41.101]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:41.101]                   0L) {
[13:33:41.101]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:41.101]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:41.101]                   base::options(opts)
[13:33:41.101]                 }
[13:33:41.101]                 {
[13:33:41.101]                   {
[13:33:41.101]                     NULL
[13:33:41.101]                     RNGkind("Mersenne-Twister")
[13:33:41.101]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:41.101]                       inherits = FALSE)
[13:33:41.101]                   }
[13:33:41.101]                   options(future.plan = NULL)
[13:33:41.101]                   if (is.na(NA_character_)) 
[13:33:41.101]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.101]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:41.101]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:41.101]                     .init = FALSE)
[13:33:41.101]                 }
[13:33:41.101]             }
[13:33:41.101]         }
[13:33:41.101]     })
[13:33:41.101]     if (TRUE) {
[13:33:41.101]         base::sink(type = "output", split = FALSE)
[13:33:41.101]         if (TRUE) {
[13:33:41.101]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:41.101]         }
[13:33:41.101]         else {
[13:33:41.101]             ...future.result["stdout"] <- base::list(NULL)
[13:33:41.101]         }
[13:33:41.101]         base::close(...future.stdout)
[13:33:41.101]         ...future.stdout <- NULL
[13:33:41.101]     }
[13:33:41.101]     ...future.result$conditions <- ...future.conditions
[13:33:41.101]     ...future.result$finished <- base::Sys.time()
[13:33:41.101]     ...future.result
[13:33:41.101] }
[13:33:41.102] assign_globals() ...
[13:33:41.103] List of 5
[13:33:41.103]  $ ...future.FUN            :function (object, ...)  
[13:33:41.103]  $ future.call.arguments    : list()
[13:33:41.103]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.103]  $ ...future.elements_ii    :List of 3
[13:33:41.103]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.103]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:33:41.103]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.103]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:41.103]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.103]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:33:41.103]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.103]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:33:41.103]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.103]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:33:41.103]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.103]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:33:41.103]  $ ...future.seeds_ii       : NULL
[13:33:41.103]  $ ...future.globals.maxSize: NULL
[13:33:41.103]  - attr(*, "where")=List of 5
[13:33:41.103]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:41.103]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:41.103]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:41.103]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:41.103]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:41.103]  - attr(*, "resolved")= logi FALSE
[13:33:41.103]  - attr(*, "total_size")= num 1240
[13:33:41.103]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.103]  - attr(*, "already-done")= logi TRUE
[13:33:41.112] - copied ‘...future.FUN’ to environment
[13:33:41.112] - copied ‘future.call.arguments’ to environment
[13:33:41.112] - copied ‘...future.elements_ii’ to environment
[13:33:41.112] - copied ‘...future.seeds_ii’ to environment
[13:33:41.112] - copied ‘...future.globals.maxSize’ to environment
[13:33:41.112] assign_globals() ... done
[13:33:41.112] plan(): Setting new future strategy stack:
[13:33:41.113] List of future strategies:
[13:33:41.113] 1. sequential:
[13:33:41.113]    - args: function (..., envir = parent.frame())
[13:33:41.113]    - tweaked: FALSE
[13:33:41.113]    - call: NULL
[13:33:41.113] plan(): nbrOfWorkers() = 1
[13:33:41.115] plan(): Setting new future strategy stack:
[13:33:41.115] List of future strategies:
[13:33:41.115] 1. multicore:
[13:33:41.115]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:41.115]    - tweaked: FALSE
[13:33:41.115]    - call: plan(strategy)
[13:33:41.119] plan(): nbrOfWorkers() = 1
[13:33:41.119] SequentialFuture started (and completed)
[13:33:41.119] - Launch lazy future ... done
[13:33:41.119] run() for ‘SequentialFuture’ ... done
[13:33:41.119] Created future:
[13:33:41.119] SequentialFuture:
[13:33:41.119] Label: ‘future_by-1’
[13:33:41.119] Expression:
[13:33:41.119] {
[13:33:41.119]     do.call(function(...) {
[13:33:41.119]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.119]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.119]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.119]             on.exit(options(oopts), add = TRUE)
[13:33:41.119]         }
[13:33:41.119]         {
[13:33:41.119]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.119]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.119]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.119]             })
[13:33:41.119]         }
[13:33:41.119]     }, args = future.call.arguments)
[13:33:41.119] }
[13:33:41.119] Lazy evaluation: FALSE
[13:33:41.119] Asynchronous evaluation: FALSE
[13:33:41.119] Local evaluation: TRUE
[13:33:41.119] Environment: 0x55cb82483da8
[13:33:41.119] Capture standard output: TRUE
[13:33:41.119] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:41.119] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:41.119] Packages: <none>
[13:33:41.119] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:41.119] Resolved: TRUE
[13:33:41.119] Value: 5.37 KiB of class ‘list’
[13:33:41.119] Early signaling: FALSE
[13:33:41.119] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:41.119] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.120] Chunk #1 of 1 ... DONE
[13:33:41.120] Launching 1 futures (chunks) ... DONE
[13:33:41.121] Resolving 1 futures (chunks) ...
[13:33:41.121] resolve() on list ...
[13:33:41.121]  recursive: 0
[13:33:41.121]  length: 1
[13:33:41.121] 
[13:33:41.121] resolved() for ‘SequentialFuture’ ...
[13:33:41.121] - state: ‘finished’
[13:33:41.121] - run: TRUE
[13:33:41.121] - result: ‘FutureResult’
[13:33:41.121] resolved() for ‘SequentialFuture’ ... done
[13:33:41.121] Future #1
[13:33:41.122] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:41.122] - nx: 1
[13:33:41.122] - relay: TRUE
[13:33:41.122] - stdout: TRUE
[13:33:41.122] - signal: TRUE
[13:33:41.122] - resignal: FALSE
[13:33:41.122] - force: TRUE
[13:33:41.122] - relayed: [n=1] FALSE
[13:33:41.122] - queued futures: [n=1] FALSE
[13:33:41.122]  - until=1
[13:33:41.122]  - relaying element #1
[13:33:41.123] - relayed: [n=1] TRUE
[13:33:41.123] - queued futures: [n=1] TRUE
[13:33:41.123] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:41.123]  length: 0 (resolved future 1)
[13:33:41.123] Relaying remaining futures
[13:33:41.123] signalConditionsASAP(NULL, pos=0) ...
[13:33:41.123] - nx: 1
[13:33:41.123] - relay: TRUE
[13:33:41.123] - stdout: TRUE
[13:33:41.123] - signal: TRUE
[13:33:41.123] - resignal: FALSE
[13:33:41.124] - force: TRUE
[13:33:41.124] - relayed: [n=1] TRUE
[13:33:41.124] - queued futures: [n=1] TRUE
 - flush all
[13:33:41.124] - relayed: [n=1] TRUE
[13:33:41.124] - queued futures: [n=1] TRUE
[13:33:41.124] signalConditionsASAP(NULL, pos=0) ... done
[13:33:41.124] resolve() on list ... DONE
[13:33:41.124]  - Number of value chunks collected: 1
[13:33:41.124] Resolving 1 futures (chunks) ... DONE
[13:33:41.124] Reducing values from 1 chunks ...
[13:33:41.124]  - Number of values collected after concatenation: 3
[13:33:41.125]  - Number of values expected: 3
[13:33:41.125] Reducing values from 1 chunks ... DONE
[13:33:41.125] future_lapply() ... DONE
[13:33:41.125] future_by_internal() ... DONE
[13:33:41.126] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[13:33:41.126] future_lapply() ...
[13:33:41.129] Number of chunks: 1
[13:33:41.129] getGlobalsAndPackagesXApply() ...
[13:33:41.130]  - future.globals: TRUE
[13:33:41.130] getGlobalsAndPackages() ...
[13:33:41.130] Searching for globals...
[13:33:41.131] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:41.131] Searching for globals ... DONE
[13:33:41.131] Resolving globals: FALSE
[13:33:41.131] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:41.132] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:41.132] - globals: [1] ‘FUN’
[13:33:41.132] 
[13:33:41.132] getGlobalsAndPackages() ... DONE
[13:33:41.132]  - globals found/used: [n=1] ‘FUN’
[13:33:41.132]  - needed namespaces: [n=0] 
[13:33:41.132] Finding globals ... DONE
[13:33:41.132]  - use_args: TRUE
[13:33:41.132]  - Getting '...' globals ...
[13:33:41.133] resolve() on list ...
[13:33:41.133]  recursive: 0
[13:33:41.134]  length: 1
[13:33:41.134]  elements: ‘...’
[13:33:41.134]  length: 0 (resolved future 1)
[13:33:41.134] resolve() on list ... DONE
[13:33:41.134]    - '...' content: [n=0] 
[13:33:41.134] List of 1
[13:33:41.134]  $ ...: list()
[13:33:41.134]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.134]  - attr(*, "where")=List of 1
[13:33:41.134]   ..$ ...:<environment: 0x55cb82514b70> 
[13:33:41.134]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.134]  - attr(*, "resolved")= logi TRUE
[13:33:41.134]  - attr(*, "total_size")= num NA
[13:33:41.137]  - Getting '...' globals ... DONE
[13:33:41.137] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:41.137] List of 2
[13:33:41.137]  $ ...future.FUN:function (object, ...)  
[13:33:41.137]  $ ...          : list()
[13:33:41.137]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.137]  - attr(*, "where")=List of 2
[13:33:41.137]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:41.137]   ..$ ...          :<environment: 0x55cb82514b70> 
[13:33:41.137]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.137]  - attr(*, "resolved")= logi FALSE
[13:33:41.137]  - attr(*, "total_size")= num 1240
[13:33:41.139] Packages to be attached in all futures: [n=0] 
[13:33:41.140] getGlobalsAndPackagesXApply() ... DONE
[13:33:41.140] Number of futures (= number of chunks): 1
[13:33:41.140] Launching 1 futures (chunks) ...
[13:33:41.140] Chunk #1 of 1 ...
[13:33:41.140]  - Finding globals in 'X' for chunk #1 ...
[13:33:41.140] getGlobalsAndPackages() ...
[13:33:41.140] Searching for globals...
[13:33:41.141] 
[13:33:41.141] Searching for globals ... DONE
[13:33:41.141] - globals: [0] <none>
[13:33:41.141] getGlobalsAndPackages() ... DONE
[13:33:41.141]    + additional globals found: [n=0] 
[13:33:41.141]    + additional namespaces needed: [n=0] 
[13:33:41.141]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:41.141]  - seeds: <none>
[13:33:41.141]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.141] getGlobalsAndPackages() ...
[13:33:41.142] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.142] Resolving globals: FALSE
[13:33:41.142] Tweak future expression to call with '...' arguments ...
[13:33:41.142] {
[13:33:41.142]     do.call(function(...) {
[13:33:41.142]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.142]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.142]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.142]             on.exit(options(oopts), add = TRUE)
[13:33:41.142]         }
[13:33:41.142]         {
[13:33:41.142]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.142]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.142]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.142]             })
[13:33:41.142]         }
[13:33:41.142]     }, args = future.call.arguments)
[13:33:41.142] }
[13:33:41.142] Tweak future expression to call with '...' arguments ... DONE
[13:33:41.142] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.143] 
[13:33:41.143] getGlobalsAndPackages() ... DONE
[13:33:41.143] run() for ‘Future’ ...
[13:33:41.143] - state: ‘created’
[13:33:41.143] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:41.146] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.146] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:41.147]   - Field: ‘label’
[13:33:41.147]   - Field: ‘local’
[13:33:41.147]   - Field: ‘owner’
[13:33:41.147]   - Field: ‘envir’
[13:33:41.147]   - Field: ‘packages’
[13:33:41.147]   - Field: ‘gc’
[13:33:41.147]   - Field: ‘conditions’
[13:33:41.147]   - Field: ‘expr’
[13:33:41.147]   - Field: ‘uuid’
[13:33:41.147]   - Field: ‘seed’
[13:33:41.147]   - Field: ‘version’
[13:33:41.148]   - Field: ‘result’
[13:33:41.148]   - Field: ‘asynchronous’
[13:33:41.148]   - Field: ‘calls’
[13:33:41.148]   - Field: ‘globals’
[13:33:41.148]   - Field: ‘stdout’
[13:33:41.148]   - Field: ‘earlySignal’
[13:33:41.148]   - Field: ‘lazy’
[13:33:41.148]   - Field: ‘state’
[13:33:41.148] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:41.148] - Launch lazy future ...
[13:33:41.148] Packages needed by the future expression (n = 0): <none>
[13:33:41.149] Packages needed by future strategies (n = 0): <none>
[13:33:41.149] {
[13:33:41.149]     {
[13:33:41.149]         {
[13:33:41.149]             ...future.startTime <- base::Sys.time()
[13:33:41.149]             {
[13:33:41.149]                 {
[13:33:41.149]                   {
[13:33:41.149]                     base::local({
[13:33:41.149]                       has_future <- base::requireNamespace("future", 
[13:33:41.149]                         quietly = TRUE)
[13:33:41.149]                       if (has_future) {
[13:33:41.149]                         ns <- base::getNamespace("future")
[13:33:41.149]                         version <- ns[[".package"]][["version"]]
[13:33:41.149]                         if (is.null(version)) 
[13:33:41.149]                           version <- utils::packageVersion("future")
[13:33:41.149]                       }
[13:33:41.149]                       else {
[13:33:41.149]                         version <- NULL
[13:33:41.149]                       }
[13:33:41.149]                       if (!has_future || version < "1.8.0") {
[13:33:41.149]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:41.149]                           "", base::R.version$version.string), 
[13:33:41.149]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:41.149]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:41.149]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:41.149]                             "release", "version")], collapse = " "), 
[13:33:41.149]                           hostname = base::Sys.info()[["nodename"]])
[13:33:41.149]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:41.149]                           info)
[13:33:41.149]                         info <- base::paste(info, collapse = "; ")
[13:33:41.149]                         if (!has_future) {
[13:33:41.149]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:41.149]                             info)
[13:33:41.149]                         }
[13:33:41.149]                         else {
[13:33:41.149]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:41.149]                             info, version)
[13:33:41.149]                         }
[13:33:41.149]                         base::stop(msg)
[13:33:41.149]                       }
[13:33:41.149]                     })
[13:33:41.149]                   }
[13:33:41.149]                   ...future.strategy.old <- future::plan("list")
[13:33:41.149]                   options(future.plan = NULL)
[13:33:41.149]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.149]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:41.149]                 }
[13:33:41.149]                 ...future.workdir <- getwd()
[13:33:41.149]             }
[13:33:41.149]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:41.149]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:41.149]         }
[13:33:41.149]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:41.149]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:41.149]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:41.149]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:41.149]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:41.149]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:41.149]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:41.149]             base::names(...future.oldOptions))
[13:33:41.149]     }
[13:33:41.149]     if (FALSE) {
[13:33:41.149]     }
[13:33:41.149]     else {
[13:33:41.149]         if (TRUE) {
[13:33:41.149]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:41.149]                 open = "w")
[13:33:41.149]         }
[13:33:41.149]         else {
[13:33:41.149]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:41.149]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:41.149]         }
[13:33:41.149]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:41.149]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:41.149]             base::sink(type = "output", split = FALSE)
[13:33:41.149]             base::close(...future.stdout)
[13:33:41.149]         }, add = TRUE)
[13:33:41.149]     }
[13:33:41.149]     ...future.frame <- base::sys.nframe()
[13:33:41.149]     ...future.conditions <- base::list()
[13:33:41.149]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:41.149]     if (FALSE) {
[13:33:41.149]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:41.149]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:41.149]     }
[13:33:41.149]     ...future.result <- base::tryCatch({
[13:33:41.149]         base::withCallingHandlers({
[13:33:41.149]             ...future.value <- base::withVisible(base::local({
[13:33:41.149]                 do.call(function(...) {
[13:33:41.149]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.149]                   if (!identical(...future.globals.maxSize.org, 
[13:33:41.149]                     ...future.globals.maxSize)) {
[13:33:41.149]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.149]                     on.exit(options(oopts), add = TRUE)
[13:33:41.149]                   }
[13:33:41.149]                   {
[13:33:41.149]                     lapply(seq_along(...future.elements_ii), 
[13:33:41.149]                       FUN = function(jj) {
[13:33:41.149]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.149]                         ...future.FUN(...future.X_jj, ...)
[13:33:41.149]                       })
[13:33:41.149]                   }
[13:33:41.149]                 }, args = future.call.arguments)
[13:33:41.149]             }))
[13:33:41.149]             future::FutureResult(value = ...future.value$value, 
[13:33:41.149]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.149]                   ...future.rng), globalenv = if (FALSE) 
[13:33:41.149]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:41.149]                     ...future.globalenv.names))
[13:33:41.149]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:41.149]         }, condition = base::local({
[13:33:41.149]             c <- base::c
[13:33:41.149]             inherits <- base::inherits
[13:33:41.149]             invokeRestart <- base::invokeRestart
[13:33:41.149]             length <- base::length
[13:33:41.149]             list <- base::list
[13:33:41.149]             seq.int <- base::seq.int
[13:33:41.149]             signalCondition <- base::signalCondition
[13:33:41.149]             sys.calls <- base::sys.calls
[13:33:41.149]             `[[` <- base::`[[`
[13:33:41.149]             `+` <- base::`+`
[13:33:41.149]             `<<-` <- base::`<<-`
[13:33:41.149]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:41.149]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:41.149]                   3L)]
[13:33:41.149]             }
[13:33:41.149]             function(cond) {
[13:33:41.149]                 is_error <- inherits(cond, "error")
[13:33:41.149]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:41.149]                   NULL)
[13:33:41.149]                 if (is_error) {
[13:33:41.149]                   sessionInformation <- function() {
[13:33:41.149]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:41.149]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:41.149]                       search = base::search(), system = base::Sys.info())
[13:33:41.149]                   }
[13:33:41.149]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.149]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:41.149]                     cond$call), session = sessionInformation(), 
[13:33:41.149]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:41.149]                   signalCondition(cond)
[13:33:41.149]                 }
[13:33:41.149]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:41.149]                 "immediateCondition"))) {
[13:33:41.149]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:41.149]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.149]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:41.149]                   if (TRUE && !signal) {
[13:33:41.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.149]                     {
[13:33:41.149]                       inherits <- base::inherits
[13:33:41.149]                       invokeRestart <- base::invokeRestart
[13:33:41.149]                       is.null <- base::is.null
[13:33:41.149]                       muffled <- FALSE
[13:33:41.149]                       if (inherits(cond, "message")) {
[13:33:41.149]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.149]                         if (muffled) 
[13:33:41.149]                           invokeRestart("muffleMessage")
[13:33:41.149]                       }
[13:33:41.149]                       else if (inherits(cond, "warning")) {
[13:33:41.149]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.149]                         if (muffled) 
[13:33:41.149]                           invokeRestart("muffleWarning")
[13:33:41.149]                       }
[13:33:41.149]                       else if (inherits(cond, "condition")) {
[13:33:41.149]                         if (!is.null(pattern)) {
[13:33:41.149]                           computeRestarts <- base::computeRestarts
[13:33:41.149]                           grepl <- base::grepl
[13:33:41.149]                           restarts <- computeRestarts(cond)
[13:33:41.149]                           for (restart in restarts) {
[13:33:41.149]                             name <- restart$name
[13:33:41.149]                             if (is.null(name)) 
[13:33:41.149]                               next
[13:33:41.149]                             if (!grepl(pattern, name)) 
[13:33:41.149]                               next
[13:33:41.149]                             invokeRestart(restart)
[13:33:41.149]                             muffled <- TRUE
[13:33:41.149]                             break
[13:33:41.149]                           }
[13:33:41.149]                         }
[13:33:41.149]                       }
[13:33:41.149]                       invisible(muffled)
[13:33:41.149]                     }
[13:33:41.149]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.149]                   }
[13:33:41.149]                 }
[13:33:41.149]                 else {
[13:33:41.149]                   if (TRUE) {
[13:33:41.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.149]                     {
[13:33:41.149]                       inherits <- base::inherits
[13:33:41.149]                       invokeRestart <- base::invokeRestart
[13:33:41.149]                       is.null <- base::is.null
[13:33:41.149]                       muffled <- FALSE
[13:33:41.149]                       if (inherits(cond, "message")) {
[13:33:41.149]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.149]                         if (muffled) 
[13:33:41.149]                           invokeRestart("muffleMessage")
[13:33:41.149]                       }
[13:33:41.149]                       else if (inherits(cond, "warning")) {
[13:33:41.149]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.149]                         if (muffled) 
[13:33:41.149]                           invokeRestart("muffleWarning")
[13:33:41.149]                       }
[13:33:41.149]                       else if (inherits(cond, "condition")) {
[13:33:41.149]                         if (!is.null(pattern)) {
[13:33:41.149]                           computeRestarts <- base::computeRestarts
[13:33:41.149]                           grepl <- base::grepl
[13:33:41.149]                           restarts <- computeRestarts(cond)
[13:33:41.149]                           for (restart in restarts) {
[13:33:41.149]                             name <- restart$name
[13:33:41.149]                             if (is.null(name)) 
[13:33:41.149]                               next
[13:33:41.149]                             if (!grepl(pattern, name)) 
[13:33:41.149]                               next
[13:33:41.149]                             invokeRestart(restart)
[13:33:41.149]                             muffled <- TRUE
[13:33:41.149]                             break
[13:33:41.149]                           }
[13:33:41.149]                         }
[13:33:41.149]                       }
[13:33:41.149]                       invisible(muffled)
[13:33:41.149]                     }
[13:33:41.149]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.149]                   }
[13:33:41.149]                 }
[13:33:41.149]             }
[13:33:41.149]         }))
[13:33:41.149]     }, error = function(ex) {
[13:33:41.149]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:41.149]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.149]                 ...future.rng), started = ...future.startTime, 
[13:33:41.149]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:41.149]             version = "1.8"), class = "FutureResult")
[13:33:41.149]     }, finally = {
[13:33:41.149]         if (!identical(...future.workdir, getwd())) 
[13:33:41.149]             setwd(...future.workdir)
[13:33:41.149]         {
[13:33:41.149]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:41.149]                 ...future.oldOptions$nwarnings <- NULL
[13:33:41.149]             }
[13:33:41.149]             base::options(...future.oldOptions)
[13:33:41.149]             if (.Platform$OS.type == "windows") {
[13:33:41.149]                 old_names <- names(...future.oldEnvVars)
[13:33:41.149]                 envs <- base::Sys.getenv()
[13:33:41.149]                 names <- names(envs)
[13:33:41.149]                 common <- intersect(names, old_names)
[13:33:41.149]                 added <- setdiff(names, old_names)
[13:33:41.149]                 removed <- setdiff(old_names, names)
[13:33:41.149]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:41.149]                   envs[common]]
[13:33:41.149]                 NAMES <- toupper(changed)
[13:33:41.149]                 args <- list()
[13:33:41.149]                 for (kk in seq_along(NAMES)) {
[13:33:41.149]                   name <- changed[[kk]]
[13:33:41.149]                   NAME <- NAMES[[kk]]
[13:33:41.149]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.149]                     next
[13:33:41.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.149]                 }
[13:33:41.149]                 NAMES <- toupper(added)
[13:33:41.149]                 for (kk in seq_along(NAMES)) {
[13:33:41.149]                   name <- added[[kk]]
[13:33:41.149]                   NAME <- NAMES[[kk]]
[13:33:41.149]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.149]                     next
[13:33:41.149]                   args[[name]] <- ""
[13:33:41.149]                 }
[13:33:41.149]                 NAMES <- toupper(removed)
[13:33:41.149]                 for (kk in seq_along(NAMES)) {
[13:33:41.149]                   name <- removed[[kk]]
[13:33:41.149]                   NAME <- NAMES[[kk]]
[13:33:41.149]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.149]                     next
[13:33:41.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.149]                 }
[13:33:41.149]                 if (length(args) > 0) 
[13:33:41.149]                   base::do.call(base::Sys.setenv, args = args)
[13:33:41.149]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:41.149]             }
[13:33:41.149]             else {
[13:33:41.149]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:41.149]             }
[13:33:41.149]             {
[13:33:41.149]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:41.149]                   0L) {
[13:33:41.149]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:41.149]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:41.149]                   base::options(opts)
[13:33:41.149]                 }
[13:33:41.149]                 {
[13:33:41.149]                   {
[13:33:41.149]                     NULL
[13:33:41.149]                     RNGkind("Mersenne-Twister")
[13:33:41.149]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:41.149]                       inherits = FALSE)
[13:33:41.149]                   }
[13:33:41.149]                   options(future.plan = NULL)
[13:33:41.149]                   if (is.na(NA_character_)) 
[13:33:41.149]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.149]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:41.149]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:41.149]                     .init = FALSE)
[13:33:41.149]                 }
[13:33:41.149]             }
[13:33:41.149]         }
[13:33:41.149]     })
[13:33:41.149]     if (TRUE) {
[13:33:41.149]         base::sink(type = "output", split = FALSE)
[13:33:41.149]         if (TRUE) {
[13:33:41.149]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:41.149]         }
[13:33:41.149]         else {
[13:33:41.149]             ...future.result["stdout"] <- base::list(NULL)
[13:33:41.149]         }
[13:33:41.149]         base::close(...future.stdout)
[13:33:41.149]         ...future.stdout <- NULL
[13:33:41.149]     }
[13:33:41.149]     ...future.result$conditions <- ...future.conditions
[13:33:41.149]     ...future.result$finished <- base::Sys.time()
[13:33:41.149]     ...future.result
[13:33:41.149] }
[13:33:41.151] assign_globals() ...
[13:33:41.151] List of 5
[13:33:41.151]  $ ...future.FUN            :function (object, ...)  
[13:33:41.151]  $ future.call.arguments    : list()
[13:33:41.151]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.151]  $ ...future.elements_ii    :List of 3
[13:33:41.151]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.151]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:33:41.151]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.151]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:41.151]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.151]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:33:41.151]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.151]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:33:41.151]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.151]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:33:41.151]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.151]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:33:41.151]  $ ...future.seeds_ii       : NULL
[13:33:41.151]  $ ...future.globals.maxSize: NULL
[13:33:41.151]  - attr(*, "where")=List of 5
[13:33:41.151]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:41.151]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:41.151]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:41.151]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:41.151]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:41.151]  - attr(*, "resolved")= logi FALSE
[13:33:41.151]  - attr(*, "total_size")= num 1240
[13:33:41.151]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.151]  - attr(*, "already-done")= logi TRUE
[13:33:41.160] - copied ‘...future.FUN’ to environment
[13:33:41.160] - copied ‘future.call.arguments’ to environment
[13:33:41.160] - copied ‘...future.elements_ii’ to environment
[13:33:41.160] - copied ‘...future.seeds_ii’ to environment
[13:33:41.160] - copied ‘...future.globals.maxSize’ to environment
[13:33:41.160] assign_globals() ... done
[13:33:41.161] plan(): Setting new future strategy stack:
[13:33:41.161] List of future strategies:
[13:33:41.161] 1. sequential:
[13:33:41.161]    - args: function (..., envir = parent.frame())
[13:33:41.161]    - tweaked: FALSE
[13:33:41.161]    - call: NULL
[13:33:41.161] plan(): nbrOfWorkers() = 1
[13:33:41.163] plan(): Setting new future strategy stack:
[13:33:41.163] List of future strategies:
[13:33:41.163] 1. multicore:
[13:33:41.163]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:41.163]    - tweaked: FALSE
[13:33:41.163]    - call: plan(strategy)
[13:33:41.166] plan(): nbrOfWorkers() = 1
[13:33:41.167] SequentialFuture started (and completed)
[13:33:41.167] - Launch lazy future ... done
[13:33:41.167] run() for ‘SequentialFuture’ ... done
[13:33:41.167] Created future:
[13:33:41.167] SequentialFuture:
[13:33:41.167] Label: ‘future_by-1’
[13:33:41.167] Expression:
[13:33:41.167] {
[13:33:41.167]     do.call(function(...) {
[13:33:41.167]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.167]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.167]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.167]             on.exit(options(oopts), add = TRUE)
[13:33:41.167]         }
[13:33:41.167]         {
[13:33:41.167]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.167]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.167]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.167]             })
[13:33:41.167]         }
[13:33:41.167]     }, args = future.call.arguments)
[13:33:41.167] }
[13:33:41.167] Lazy evaluation: FALSE
[13:33:41.167] Asynchronous evaluation: FALSE
[13:33:41.167] Local evaluation: TRUE
[13:33:41.167] Environment: 0x55cb824db8b0
[13:33:41.167] Capture standard output: TRUE
[13:33:41.167] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:41.167] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:41.167] Packages: <none>
[13:33:41.167] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:41.167] Resolved: TRUE
[13:33:41.167] Value: 5.37 KiB of class ‘list’
[13:33:41.167] Early signaling: FALSE
[13:33:41.167] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:41.167] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.168] Chunk #1 of 1 ... DONE
[13:33:41.168] Launching 1 futures (chunks) ... DONE
[13:33:41.168] Resolving 1 futures (chunks) ...
[13:33:41.168] resolve() on list ...
[13:33:41.169]  recursive: 0
[13:33:41.169]  length: 1
[13:33:41.169] 
[13:33:41.169] resolved() for ‘SequentialFuture’ ...
[13:33:41.169] - state: ‘finished’
[13:33:41.169] - run: TRUE
[13:33:41.169] - result: ‘FutureResult’
[13:33:41.169] resolved() for ‘SequentialFuture’ ... done
[13:33:41.169] Future #1
[13:33:41.169] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:41.169] - nx: 1
[13:33:41.170] - relay: TRUE
[13:33:41.170] - stdout: TRUE
[13:33:41.170] - signal: TRUE
[13:33:41.170] - resignal: FALSE
[13:33:41.170] - force: TRUE
[13:33:41.170] - relayed: [n=1] FALSE
[13:33:41.170] - queued futures: [n=1] FALSE
[13:33:41.170]  - until=1
[13:33:41.170]  - relaying element #1
[13:33:41.170] - relayed: [n=1] TRUE
[13:33:41.171] - queued futures: [n=1] TRUE
[13:33:41.171] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:41.171]  length: 0 (resolved future 1)
[13:33:41.171] Relaying remaining futures
[13:33:41.171] signalConditionsASAP(NULL, pos=0) ...
[13:33:41.171] - nx: 1
[13:33:41.171] - relay: TRUE
[13:33:41.171] - stdout: TRUE
[13:33:41.171] - signal: TRUE
[13:33:41.171] - resignal: FALSE
[13:33:41.171] - force: TRUE
[13:33:41.171] - relayed: [n=1] TRUE
[13:33:41.172] - queued futures: [n=1] TRUE
 - flush all
[13:33:41.172] - relayed: [n=1] TRUE
[13:33:41.172] - queued futures: [n=1] TRUE
[13:33:41.172] signalConditionsASAP(NULL, pos=0) ... done
[13:33:41.172] resolve() on list ... DONE
[13:33:41.172]  - Number of value chunks collected: 1
[13:33:41.172] Resolving 1 futures (chunks) ... DONE
[13:33:41.172] Reducing values from 1 chunks ...
[13:33:41.172]  - Number of values collected after concatenation: 3
[13:33:41.172]  - Number of values expected: 3
[13:33:41.172] Reducing values from 1 chunks ... DONE
[13:33:41.173] future_lapply() ... DONE
[13:33:41.173] future_by_internal() ... DONE
[13:33:41.173] future_by_internal() ...
- plan('multisession') ...
[13:33:41.174] plan(): Setting new future strategy stack:
[13:33:41.174] List of future strategies:
[13:33:41.174] 1. multisession:
[13:33:41.174]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:33:41.174]    - tweaked: FALSE
[13:33:41.174]    - call: plan(strategy)
[13:33:41.174] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:33:41.175] multisession:
[13:33:41.175] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:33:41.175] - tweaked: FALSE
[13:33:41.175] - call: plan(strategy)
[13:33:41.178] getGlobalsAndPackages() ...
[13:33:41.178] Not searching for globals
[13:33:41.178] - globals: [0] <none>
[13:33:41.178] getGlobalsAndPackages() ... DONE
[13:33:41.179] Packages needed by the future expression (n = 0): <none>
[13:33:41.179] Packages needed by future strategies (n = 0): <none>
[13:33:41.179] {
[13:33:41.179]     {
[13:33:41.179]         {
[13:33:41.179]             ...future.startTime <- base::Sys.time()
[13:33:41.179]             {
[13:33:41.179]                 {
[13:33:41.179]                   {
[13:33:41.179]                     base::local({
[13:33:41.179]                       has_future <- base::requireNamespace("future", 
[13:33:41.179]                         quietly = TRUE)
[13:33:41.179]                       if (has_future) {
[13:33:41.179]                         ns <- base::getNamespace("future")
[13:33:41.179]                         version <- ns[[".package"]][["version"]]
[13:33:41.179]                         if (is.null(version)) 
[13:33:41.179]                           version <- utils::packageVersion("future")
[13:33:41.179]                       }
[13:33:41.179]                       else {
[13:33:41.179]                         version <- NULL
[13:33:41.179]                       }
[13:33:41.179]                       if (!has_future || version < "1.8.0") {
[13:33:41.179]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:41.179]                           "", base::R.version$version.string), 
[13:33:41.179]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:41.179]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:41.179]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:41.179]                             "release", "version")], collapse = " "), 
[13:33:41.179]                           hostname = base::Sys.info()[["nodename"]])
[13:33:41.179]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:41.179]                           info)
[13:33:41.179]                         info <- base::paste(info, collapse = "; ")
[13:33:41.179]                         if (!has_future) {
[13:33:41.179]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:41.179]                             info)
[13:33:41.179]                         }
[13:33:41.179]                         else {
[13:33:41.179]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:41.179]                             info, version)
[13:33:41.179]                         }
[13:33:41.179]                         base::stop(msg)
[13:33:41.179]                       }
[13:33:41.179]                     })
[13:33:41.179]                   }
[13:33:41.179]                   ...future.strategy.old <- future::plan("list")
[13:33:41.179]                   options(future.plan = NULL)
[13:33:41.179]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.179]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:41.179]                 }
[13:33:41.179]                 ...future.workdir <- getwd()
[13:33:41.179]             }
[13:33:41.179]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:41.179]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:41.179]         }
[13:33:41.179]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:41.179]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:41.179]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:41.179]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:41.179]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:41.179]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:41.179]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:41.179]             base::names(...future.oldOptions))
[13:33:41.179]     }
[13:33:41.179]     if (FALSE) {
[13:33:41.179]     }
[13:33:41.179]     else {
[13:33:41.179]         if (TRUE) {
[13:33:41.179]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:41.179]                 open = "w")
[13:33:41.179]         }
[13:33:41.179]         else {
[13:33:41.179]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:41.179]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:41.179]         }
[13:33:41.179]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:41.179]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:41.179]             base::sink(type = "output", split = FALSE)
[13:33:41.179]             base::close(...future.stdout)
[13:33:41.179]         }, add = TRUE)
[13:33:41.179]     }
[13:33:41.179]     ...future.frame <- base::sys.nframe()
[13:33:41.179]     ...future.conditions <- base::list()
[13:33:41.179]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:41.179]     if (FALSE) {
[13:33:41.179]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:41.179]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:41.179]     }
[13:33:41.179]     ...future.result <- base::tryCatch({
[13:33:41.179]         base::withCallingHandlers({
[13:33:41.179]             ...future.value <- base::withVisible(base::local(NA))
[13:33:41.179]             future::FutureResult(value = ...future.value$value, 
[13:33:41.179]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.179]                   ...future.rng), globalenv = if (FALSE) 
[13:33:41.179]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:41.179]                     ...future.globalenv.names))
[13:33:41.179]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:41.179]         }, condition = base::local({
[13:33:41.179]             c <- base::c
[13:33:41.179]             inherits <- base::inherits
[13:33:41.179]             invokeRestart <- base::invokeRestart
[13:33:41.179]             length <- base::length
[13:33:41.179]             list <- base::list
[13:33:41.179]             seq.int <- base::seq.int
[13:33:41.179]             signalCondition <- base::signalCondition
[13:33:41.179]             sys.calls <- base::sys.calls
[13:33:41.179]             `[[` <- base::`[[`
[13:33:41.179]             `+` <- base::`+`
[13:33:41.179]             `<<-` <- base::`<<-`
[13:33:41.179]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:41.179]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:41.179]                   3L)]
[13:33:41.179]             }
[13:33:41.179]             function(cond) {
[13:33:41.179]                 is_error <- inherits(cond, "error")
[13:33:41.179]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:41.179]                   NULL)
[13:33:41.179]                 if (is_error) {
[13:33:41.179]                   sessionInformation <- function() {
[13:33:41.179]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:41.179]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:41.179]                       search = base::search(), system = base::Sys.info())
[13:33:41.179]                   }
[13:33:41.179]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.179]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:41.179]                     cond$call), session = sessionInformation(), 
[13:33:41.179]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:41.179]                   signalCondition(cond)
[13:33:41.179]                 }
[13:33:41.179]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:41.179]                 "immediateCondition"))) {
[13:33:41.179]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:41.179]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.179]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:41.179]                   if (TRUE && !signal) {
[13:33:41.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.179]                     {
[13:33:41.179]                       inherits <- base::inherits
[13:33:41.179]                       invokeRestart <- base::invokeRestart
[13:33:41.179]                       is.null <- base::is.null
[13:33:41.179]                       muffled <- FALSE
[13:33:41.179]                       if (inherits(cond, "message")) {
[13:33:41.179]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.179]                         if (muffled) 
[13:33:41.179]                           invokeRestart("muffleMessage")
[13:33:41.179]                       }
[13:33:41.179]                       else if (inherits(cond, "warning")) {
[13:33:41.179]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.179]                         if (muffled) 
[13:33:41.179]                           invokeRestart("muffleWarning")
[13:33:41.179]                       }
[13:33:41.179]                       else if (inherits(cond, "condition")) {
[13:33:41.179]                         if (!is.null(pattern)) {
[13:33:41.179]                           computeRestarts <- base::computeRestarts
[13:33:41.179]                           grepl <- base::grepl
[13:33:41.179]                           restarts <- computeRestarts(cond)
[13:33:41.179]                           for (restart in restarts) {
[13:33:41.179]                             name <- restart$name
[13:33:41.179]                             if (is.null(name)) 
[13:33:41.179]                               next
[13:33:41.179]                             if (!grepl(pattern, name)) 
[13:33:41.179]                               next
[13:33:41.179]                             invokeRestart(restart)
[13:33:41.179]                             muffled <- TRUE
[13:33:41.179]                             break
[13:33:41.179]                           }
[13:33:41.179]                         }
[13:33:41.179]                       }
[13:33:41.179]                       invisible(muffled)
[13:33:41.179]                     }
[13:33:41.179]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.179]                   }
[13:33:41.179]                 }
[13:33:41.179]                 else {
[13:33:41.179]                   if (TRUE) {
[13:33:41.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.179]                     {
[13:33:41.179]                       inherits <- base::inherits
[13:33:41.179]                       invokeRestart <- base::invokeRestart
[13:33:41.179]                       is.null <- base::is.null
[13:33:41.179]                       muffled <- FALSE
[13:33:41.179]                       if (inherits(cond, "message")) {
[13:33:41.179]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.179]                         if (muffled) 
[13:33:41.179]                           invokeRestart("muffleMessage")
[13:33:41.179]                       }
[13:33:41.179]                       else if (inherits(cond, "warning")) {
[13:33:41.179]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.179]                         if (muffled) 
[13:33:41.179]                           invokeRestart("muffleWarning")
[13:33:41.179]                       }
[13:33:41.179]                       else if (inherits(cond, "condition")) {
[13:33:41.179]                         if (!is.null(pattern)) {
[13:33:41.179]                           computeRestarts <- base::computeRestarts
[13:33:41.179]                           grepl <- base::grepl
[13:33:41.179]                           restarts <- computeRestarts(cond)
[13:33:41.179]                           for (restart in restarts) {
[13:33:41.179]                             name <- restart$name
[13:33:41.179]                             if (is.null(name)) 
[13:33:41.179]                               next
[13:33:41.179]                             if (!grepl(pattern, name)) 
[13:33:41.179]                               next
[13:33:41.179]                             invokeRestart(restart)
[13:33:41.179]                             muffled <- TRUE
[13:33:41.179]                             break
[13:33:41.179]                           }
[13:33:41.179]                         }
[13:33:41.179]                       }
[13:33:41.179]                       invisible(muffled)
[13:33:41.179]                     }
[13:33:41.179]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.179]                   }
[13:33:41.179]                 }
[13:33:41.179]             }
[13:33:41.179]         }))
[13:33:41.179]     }, error = function(ex) {
[13:33:41.179]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:41.179]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.179]                 ...future.rng), started = ...future.startTime, 
[13:33:41.179]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:41.179]             version = "1.8"), class = "FutureResult")
[13:33:41.179]     }, finally = {
[13:33:41.179]         if (!identical(...future.workdir, getwd())) 
[13:33:41.179]             setwd(...future.workdir)
[13:33:41.179]         {
[13:33:41.179]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:41.179]                 ...future.oldOptions$nwarnings <- NULL
[13:33:41.179]             }
[13:33:41.179]             base::options(...future.oldOptions)
[13:33:41.179]             if (.Platform$OS.type == "windows") {
[13:33:41.179]                 old_names <- names(...future.oldEnvVars)
[13:33:41.179]                 envs <- base::Sys.getenv()
[13:33:41.179]                 names <- names(envs)
[13:33:41.179]                 common <- intersect(names, old_names)
[13:33:41.179]                 added <- setdiff(names, old_names)
[13:33:41.179]                 removed <- setdiff(old_names, names)
[13:33:41.179]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:41.179]                   envs[common]]
[13:33:41.179]                 NAMES <- toupper(changed)
[13:33:41.179]                 args <- list()
[13:33:41.179]                 for (kk in seq_along(NAMES)) {
[13:33:41.179]                   name <- changed[[kk]]
[13:33:41.179]                   NAME <- NAMES[[kk]]
[13:33:41.179]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.179]                     next
[13:33:41.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.179]                 }
[13:33:41.179]                 NAMES <- toupper(added)
[13:33:41.179]                 for (kk in seq_along(NAMES)) {
[13:33:41.179]                   name <- added[[kk]]
[13:33:41.179]                   NAME <- NAMES[[kk]]
[13:33:41.179]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.179]                     next
[13:33:41.179]                   args[[name]] <- ""
[13:33:41.179]                 }
[13:33:41.179]                 NAMES <- toupper(removed)
[13:33:41.179]                 for (kk in seq_along(NAMES)) {
[13:33:41.179]                   name <- removed[[kk]]
[13:33:41.179]                   NAME <- NAMES[[kk]]
[13:33:41.179]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.179]                     next
[13:33:41.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.179]                 }
[13:33:41.179]                 if (length(args) > 0) 
[13:33:41.179]                   base::do.call(base::Sys.setenv, args = args)
[13:33:41.179]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:41.179]             }
[13:33:41.179]             else {
[13:33:41.179]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:41.179]             }
[13:33:41.179]             {
[13:33:41.179]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:41.179]                   0L) {
[13:33:41.179]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:41.179]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:41.179]                   base::options(opts)
[13:33:41.179]                 }
[13:33:41.179]                 {
[13:33:41.179]                   {
[13:33:41.179]                     NULL
[13:33:41.179]                     RNGkind("Mersenne-Twister")
[13:33:41.179]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:41.179]                       inherits = FALSE)
[13:33:41.179]                   }
[13:33:41.179]                   options(future.plan = NULL)
[13:33:41.179]                   if (is.na(NA_character_)) 
[13:33:41.179]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.179]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:41.179]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:41.179]                     .init = FALSE)
[13:33:41.179]                 }
[13:33:41.179]             }
[13:33:41.179]         }
[13:33:41.179]     })
[13:33:41.179]     if (TRUE) {
[13:33:41.179]         base::sink(type = "output", split = FALSE)
[13:33:41.179]         if (TRUE) {
[13:33:41.179]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:41.179]         }
[13:33:41.179]         else {
[13:33:41.179]             ...future.result["stdout"] <- base::list(NULL)
[13:33:41.179]         }
[13:33:41.179]         base::close(...future.stdout)
[13:33:41.179]         ...future.stdout <- NULL
[13:33:41.179]     }
[13:33:41.179]     ...future.result$conditions <- ...future.conditions
[13:33:41.179]     ...future.result$finished <- base::Sys.time()
[13:33:41.179]     ...future.result
[13:33:41.179] }
[13:33:41.182] plan(): Setting new future strategy stack:
[13:33:41.182] List of future strategies:
[13:33:41.182] 1. sequential:
[13:33:41.182]    - args: function (..., envir = parent.frame())
[13:33:41.182]    - tweaked: FALSE
[13:33:41.182]    - call: NULL
[13:33:41.182] plan(): nbrOfWorkers() = 1
[13:33:41.183] plan(): Setting new future strategy stack:
[13:33:41.183] List of future strategies:
[13:33:41.183] 1. multisession:
[13:33:41.183]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:33:41.183]    - tweaked: FALSE
[13:33:41.183]    - call: plan(strategy)
[13:33:41.187] plan(): nbrOfWorkers() = 1
[13:33:41.187] SequentialFuture started (and completed)
[13:33:41.187] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:33:41.190] plan(): nbrOfWorkers() = 1
[13:33:41.190] future_by_internal() ...
[13:33:41.190] future_lapply() ...
[13:33:41.194] Number of chunks: 1
[13:33:41.194] getGlobalsAndPackagesXApply() ...
[13:33:41.194]  - future.globals: TRUE
[13:33:41.194] getGlobalsAndPackages() ...
[13:33:41.194] Searching for globals...
[13:33:41.195] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:41.195] Searching for globals ... DONE
[13:33:41.195] Resolving globals: FALSE
[13:33:41.196] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:41.196] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:41.196] - globals: [1] ‘FUN’
[13:33:41.196] 
[13:33:41.196] getGlobalsAndPackages() ... DONE
[13:33:41.196]  - globals found/used: [n=1] ‘FUN’
[13:33:41.197]  - needed namespaces: [n=0] 
[13:33:41.197] Finding globals ... DONE
[13:33:41.197]  - use_args: TRUE
[13:33:41.197]  - Getting '...' globals ...
[13:33:41.197] resolve() on list ...
[13:33:41.197]  recursive: 0
[13:33:41.197]  length: 1
[13:33:41.197]  elements: ‘...’
[13:33:41.197]  length: 0 (resolved future 1)
[13:33:41.198] resolve() on list ... DONE
[13:33:41.198]    - '...' content: [n=0] 
[13:33:41.198] List of 1
[13:33:41.198]  $ ...: list()
[13:33:41.198]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.198]  - attr(*, "where")=List of 1
[13:33:41.198]   ..$ ...:<environment: 0x55cb80e1fd00> 
[13:33:41.198]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.198]  - attr(*, "resolved")= logi TRUE
[13:33:41.198]  - attr(*, "total_size")= num NA
[13:33:41.200]  - Getting '...' globals ... DONE
[13:33:41.200] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:41.200] List of 2
[13:33:41.200]  $ ...future.FUN:function (object, ...)  
[13:33:41.200]  $ ...          : list()
[13:33:41.200]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.200]  - attr(*, "where")=List of 2
[13:33:41.200]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:41.200]   ..$ ...          :<environment: 0x55cb80e1fd00> 
[13:33:41.200]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.200]  - attr(*, "resolved")= logi FALSE
[13:33:41.200]  - attr(*, "total_size")= num 1240
[13:33:41.203] Packages to be attached in all futures: [n=0] 
[13:33:41.203] getGlobalsAndPackagesXApply() ... DONE
[13:33:41.203] Number of futures (= number of chunks): 1
[13:33:41.203] Launching 1 futures (chunks) ...
[13:33:41.204] Chunk #1 of 1 ...
[13:33:41.204]  - Finding globals in 'X' for chunk #1 ...
[13:33:41.204] getGlobalsAndPackages() ...
[13:33:41.204] Searching for globals...
[13:33:41.204] 
[13:33:41.204] Searching for globals ... DONE
[13:33:41.204] - globals: [0] <none>
[13:33:41.205] getGlobalsAndPackages() ... DONE
[13:33:41.205]    + additional globals found: [n=0] 
[13:33:41.205]    + additional namespaces needed: [n=0] 
[13:33:41.205]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:41.205]  - seeds: <none>
[13:33:41.205]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.205] getGlobalsAndPackages() ...
[13:33:41.205] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.205] Resolving globals: FALSE
[13:33:41.205] Tweak future expression to call with '...' arguments ...
[13:33:41.206] {
[13:33:41.206]     do.call(function(...) {
[13:33:41.206]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.206]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.206]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.206]             on.exit(options(oopts), add = TRUE)
[13:33:41.206]         }
[13:33:41.206]         {
[13:33:41.206]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.206]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.206]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.206]             })
[13:33:41.206]         }
[13:33:41.206]     }, args = future.call.arguments)
[13:33:41.206] }
[13:33:41.206] Tweak future expression to call with '...' arguments ... DONE
[13:33:41.206] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.206] 
[13:33:41.206] getGlobalsAndPackages() ... DONE
[13:33:41.207] run() for ‘Future’ ...
[13:33:41.207] - state: ‘created’
[13:33:41.207] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:41.211] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.212] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:41.212]   - Field: ‘label’
[13:33:41.212]   - Field: ‘local’
[13:33:41.212]   - Field: ‘owner’
[13:33:41.212]   - Field: ‘envir’
[13:33:41.212]   - Field: ‘packages’
[13:33:41.212]   - Field: ‘gc’
[13:33:41.212]   - Field: ‘conditions’
[13:33:41.212]   - Field: ‘expr’
[13:33:41.212]   - Field: ‘uuid’
[13:33:41.213]   - Field: ‘seed’
[13:33:41.213]   - Field: ‘version’
[13:33:41.213]   - Field: ‘result’
[13:33:41.213]   - Field: ‘asynchronous’
[13:33:41.213]   - Field: ‘calls’
[13:33:41.213]   - Field: ‘globals’
[13:33:41.213]   - Field: ‘stdout’
[13:33:41.213]   - Field: ‘earlySignal’
[13:33:41.213]   - Field: ‘lazy’
[13:33:41.213]   - Field: ‘state’
[13:33:41.213] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:41.213] - Launch lazy future ...
[13:33:41.214] Packages needed by the future expression (n = 0): <none>
[13:33:41.214] Packages needed by future strategies (n = 0): <none>
[13:33:41.214] {
[13:33:41.214]     {
[13:33:41.214]         {
[13:33:41.214]             ...future.startTime <- base::Sys.time()
[13:33:41.214]             {
[13:33:41.214]                 {
[13:33:41.214]                   {
[13:33:41.214]                     base::local({
[13:33:41.214]                       has_future <- base::requireNamespace("future", 
[13:33:41.214]                         quietly = TRUE)
[13:33:41.214]                       if (has_future) {
[13:33:41.214]                         ns <- base::getNamespace("future")
[13:33:41.214]                         version <- ns[[".package"]][["version"]]
[13:33:41.214]                         if (is.null(version)) 
[13:33:41.214]                           version <- utils::packageVersion("future")
[13:33:41.214]                       }
[13:33:41.214]                       else {
[13:33:41.214]                         version <- NULL
[13:33:41.214]                       }
[13:33:41.214]                       if (!has_future || version < "1.8.0") {
[13:33:41.214]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:41.214]                           "", base::R.version$version.string), 
[13:33:41.214]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:41.214]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:41.214]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:41.214]                             "release", "version")], collapse = " "), 
[13:33:41.214]                           hostname = base::Sys.info()[["nodename"]])
[13:33:41.214]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:41.214]                           info)
[13:33:41.214]                         info <- base::paste(info, collapse = "; ")
[13:33:41.214]                         if (!has_future) {
[13:33:41.214]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:41.214]                             info)
[13:33:41.214]                         }
[13:33:41.214]                         else {
[13:33:41.214]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:41.214]                             info, version)
[13:33:41.214]                         }
[13:33:41.214]                         base::stop(msg)
[13:33:41.214]                       }
[13:33:41.214]                     })
[13:33:41.214]                   }
[13:33:41.214]                   ...future.strategy.old <- future::plan("list")
[13:33:41.214]                   options(future.plan = NULL)
[13:33:41.214]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.214]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:41.214]                 }
[13:33:41.214]                 ...future.workdir <- getwd()
[13:33:41.214]             }
[13:33:41.214]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:41.214]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:41.214]         }
[13:33:41.214]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:41.214]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:41.214]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:41.214]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:41.214]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:41.214]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:41.214]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:41.214]             base::names(...future.oldOptions))
[13:33:41.214]     }
[13:33:41.214]     if (FALSE) {
[13:33:41.214]     }
[13:33:41.214]     else {
[13:33:41.214]         if (TRUE) {
[13:33:41.214]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:41.214]                 open = "w")
[13:33:41.214]         }
[13:33:41.214]         else {
[13:33:41.214]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:41.214]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:41.214]         }
[13:33:41.214]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:41.214]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:41.214]             base::sink(type = "output", split = FALSE)
[13:33:41.214]             base::close(...future.stdout)
[13:33:41.214]         }, add = TRUE)
[13:33:41.214]     }
[13:33:41.214]     ...future.frame <- base::sys.nframe()
[13:33:41.214]     ...future.conditions <- base::list()
[13:33:41.214]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:41.214]     if (FALSE) {
[13:33:41.214]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:41.214]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:41.214]     }
[13:33:41.214]     ...future.result <- base::tryCatch({
[13:33:41.214]         base::withCallingHandlers({
[13:33:41.214]             ...future.value <- base::withVisible(base::local({
[13:33:41.214]                 do.call(function(...) {
[13:33:41.214]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.214]                   if (!identical(...future.globals.maxSize.org, 
[13:33:41.214]                     ...future.globals.maxSize)) {
[13:33:41.214]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.214]                     on.exit(options(oopts), add = TRUE)
[13:33:41.214]                   }
[13:33:41.214]                   {
[13:33:41.214]                     lapply(seq_along(...future.elements_ii), 
[13:33:41.214]                       FUN = function(jj) {
[13:33:41.214]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.214]                         ...future.FUN(...future.X_jj, ...)
[13:33:41.214]                       })
[13:33:41.214]                   }
[13:33:41.214]                 }, args = future.call.arguments)
[13:33:41.214]             }))
[13:33:41.214]             future::FutureResult(value = ...future.value$value, 
[13:33:41.214]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.214]                   ...future.rng), globalenv = if (FALSE) 
[13:33:41.214]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:41.214]                     ...future.globalenv.names))
[13:33:41.214]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:41.214]         }, condition = base::local({
[13:33:41.214]             c <- base::c
[13:33:41.214]             inherits <- base::inherits
[13:33:41.214]             invokeRestart <- base::invokeRestart
[13:33:41.214]             length <- base::length
[13:33:41.214]             list <- base::list
[13:33:41.214]             seq.int <- base::seq.int
[13:33:41.214]             signalCondition <- base::signalCondition
[13:33:41.214]             sys.calls <- base::sys.calls
[13:33:41.214]             `[[` <- base::`[[`
[13:33:41.214]             `+` <- base::`+`
[13:33:41.214]             `<<-` <- base::`<<-`
[13:33:41.214]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:41.214]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:41.214]                   3L)]
[13:33:41.214]             }
[13:33:41.214]             function(cond) {
[13:33:41.214]                 is_error <- inherits(cond, "error")
[13:33:41.214]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:41.214]                   NULL)
[13:33:41.214]                 if (is_error) {
[13:33:41.214]                   sessionInformation <- function() {
[13:33:41.214]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:41.214]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:41.214]                       search = base::search(), system = base::Sys.info())
[13:33:41.214]                   }
[13:33:41.214]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.214]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:41.214]                     cond$call), session = sessionInformation(), 
[13:33:41.214]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:41.214]                   signalCondition(cond)
[13:33:41.214]                 }
[13:33:41.214]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:41.214]                 "immediateCondition"))) {
[13:33:41.214]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:41.214]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.214]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:41.214]                   if (TRUE && !signal) {
[13:33:41.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.214]                     {
[13:33:41.214]                       inherits <- base::inherits
[13:33:41.214]                       invokeRestart <- base::invokeRestart
[13:33:41.214]                       is.null <- base::is.null
[13:33:41.214]                       muffled <- FALSE
[13:33:41.214]                       if (inherits(cond, "message")) {
[13:33:41.214]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.214]                         if (muffled) 
[13:33:41.214]                           invokeRestart("muffleMessage")
[13:33:41.214]                       }
[13:33:41.214]                       else if (inherits(cond, "warning")) {
[13:33:41.214]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.214]                         if (muffled) 
[13:33:41.214]                           invokeRestart("muffleWarning")
[13:33:41.214]                       }
[13:33:41.214]                       else if (inherits(cond, "condition")) {
[13:33:41.214]                         if (!is.null(pattern)) {
[13:33:41.214]                           computeRestarts <- base::computeRestarts
[13:33:41.214]                           grepl <- base::grepl
[13:33:41.214]                           restarts <- computeRestarts(cond)
[13:33:41.214]                           for (restart in restarts) {
[13:33:41.214]                             name <- restart$name
[13:33:41.214]                             if (is.null(name)) 
[13:33:41.214]                               next
[13:33:41.214]                             if (!grepl(pattern, name)) 
[13:33:41.214]                               next
[13:33:41.214]                             invokeRestart(restart)
[13:33:41.214]                             muffled <- TRUE
[13:33:41.214]                             break
[13:33:41.214]                           }
[13:33:41.214]                         }
[13:33:41.214]                       }
[13:33:41.214]                       invisible(muffled)
[13:33:41.214]                     }
[13:33:41.214]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.214]                   }
[13:33:41.214]                 }
[13:33:41.214]                 else {
[13:33:41.214]                   if (TRUE) {
[13:33:41.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.214]                     {
[13:33:41.214]                       inherits <- base::inherits
[13:33:41.214]                       invokeRestart <- base::invokeRestart
[13:33:41.214]                       is.null <- base::is.null
[13:33:41.214]                       muffled <- FALSE
[13:33:41.214]                       if (inherits(cond, "message")) {
[13:33:41.214]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.214]                         if (muffled) 
[13:33:41.214]                           invokeRestart("muffleMessage")
[13:33:41.214]                       }
[13:33:41.214]                       else if (inherits(cond, "warning")) {
[13:33:41.214]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.214]                         if (muffled) 
[13:33:41.214]                           invokeRestart("muffleWarning")
[13:33:41.214]                       }
[13:33:41.214]                       else if (inherits(cond, "condition")) {
[13:33:41.214]                         if (!is.null(pattern)) {
[13:33:41.214]                           computeRestarts <- base::computeRestarts
[13:33:41.214]                           grepl <- base::grepl
[13:33:41.214]                           restarts <- computeRestarts(cond)
[13:33:41.214]                           for (restart in restarts) {
[13:33:41.214]                             name <- restart$name
[13:33:41.214]                             if (is.null(name)) 
[13:33:41.214]                               next
[13:33:41.214]                             if (!grepl(pattern, name)) 
[13:33:41.214]                               next
[13:33:41.214]                             invokeRestart(restart)
[13:33:41.214]                             muffled <- TRUE
[13:33:41.214]                             break
[13:33:41.214]                           }
[13:33:41.214]                         }
[13:33:41.214]                       }
[13:33:41.214]                       invisible(muffled)
[13:33:41.214]                     }
[13:33:41.214]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.214]                   }
[13:33:41.214]                 }
[13:33:41.214]             }
[13:33:41.214]         }))
[13:33:41.214]     }, error = function(ex) {
[13:33:41.214]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:41.214]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.214]                 ...future.rng), started = ...future.startTime, 
[13:33:41.214]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:41.214]             version = "1.8"), class = "FutureResult")
[13:33:41.214]     }, finally = {
[13:33:41.214]         if (!identical(...future.workdir, getwd())) 
[13:33:41.214]             setwd(...future.workdir)
[13:33:41.214]         {
[13:33:41.214]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:41.214]                 ...future.oldOptions$nwarnings <- NULL
[13:33:41.214]             }
[13:33:41.214]             base::options(...future.oldOptions)
[13:33:41.214]             if (.Platform$OS.type == "windows") {
[13:33:41.214]                 old_names <- names(...future.oldEnvVars)
[13:33:41.214]                 envs <- base::Sys.getenv()
[13:33:41.214]                 names <- names(envs)
[13:33:41.214]                 common <- intersect(names, old_names)
[13:33:41.214]                 added <- setdiff(names, old_names)
[13:33:41.214]                 removed <- setdiff(old_names, names)
[13:33:41.214]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:41.214]                   envs[common]]
[13:33:41.214]                 NAMES <- toupper(changed)
[13:33:41.214]                 args <- list()
[13:33:41.214]                 for (kk in seq_along(NAMES)) {
[13:33:41.214]                   name <- changed[[kk]]
[13:33:41.214]                   NAME <- NAMES[[kk]]
[13:33:41.214]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.214]                     next
[13:33:41.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.214]                 }
[13:33:41.214]                 NAMES <- toupper(added)
[13:33:41.214]                 for (kk in seq_along(NAMES)) {
[13:33:41.214]                   name <- added[[kk]]
[13:33:41.214]                   NAME <- NAMES[[kk]]
[13:33:41.214]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.214]                     next
[13:33:41.214]                   args[[name]] <- ""
[13:33:41.214]                 }
[13:33:41.214]                 NAMES <- toupper(removed)
[13:33:41.214]                 for (kk in seq_along(NAMES)) {
[13:33:41.214]                   name <- removed[[kk]]
[13:33:41.214]                   NAME <- NAMES[[kk]]
[13:33:41.214]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.214]                     next
[13:33:41.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.214]                 }
[13:33:41.214]                 if (length(args) > 0) 
[13:33:41.214]                   base::do.call(base::Sys.setenv, args = args)
[13:33:41.214]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:41.214]             }
[13:33:41.214]             else {
[13:33:41.214]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:41.214]             }
[13:33:41.214]             {
[13:33:41.214]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:41.214]                   0L) {
[13:33:41.214]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:41.214]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:41.214]                   base::options(opts)
[13:33:41.214]                 }
[13:33:41.214]                 {
[13:33:41.214]                   {
[13:33:41.214]                     NULL
[13:33:41.214]                     RNGkind("Mersenne-Twister")
[13:33:41.214]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:41.214]                       inherits = FALSE)
[13:33:41.214]                   }
[13:33:41.214]                   options(future.plan = NULL)
[13:33:41.214]                   if (is.na(NA_character_)) 
[13:33:41.214]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.214]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:41.214]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:41.214]                     .init = FALSE)
[13:33:41.214]                 }
[13:33:41.214]             }
[13:33:41.214]         }
[13:33:41.214]     })
[13:33:41.214]     if (TRUE) {
[13:33:41.214]         base::sink(type = "output", split = FALSE)
[13:33:41.214]         if (TRUE) {
[13:33:41.214]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:41.214]         }
[13:33:41.214]         else {
[13:33:41.214]             ...future.result["stdout"] <- base::list(NULL)
[13:33:41.214]         }
[13:33:41.214]         base::close(...future.stdout)
[13:33:41.214]         ...future.stdout <- NULL
[13:33:41.214]     }
[13:33:41.214]     ...future.result$conditions <- ...future.conditions
[13:33:41.214]     ...future.result$finished <- base::Sys.time()
[13:33:41.214]     ...future.result
[13:33:41.214] }
[13:33:41.216] assign_globals() ...
[13:33:41.216] List of 5
[13:33:41.216]  $ ...future.FUN            :function (object, ...)  
[13:33:41.216]  $ future.call.arguments    : list()
[13:33:41.216]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.216]  $ ...future.elements_ii    :List of 3
[13:33:41.216]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:33:41.216]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:33:41.216]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.216]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:33:41.216]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:33:41.216]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.216]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:33:41.216]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:33:41.216]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.216]  $ ...future.seeds_ii       : NULL
[13:33:41.216]  $ ...future.globals.maxSize: NULL
[13:33:41.216]  - attr(*, "where")=List of 5
[13:33:41.216]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:41.216]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:41.216]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:41.216]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:41.216]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:41.216]  - attr(*, "resolved")= logi FALSE
[13:33:41.216]  - attr(*, "total_size")= num 1240
[13:33:41.216]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.216]  - attr(*, "already-done")= logi TRUE
[13:33:41.223] - copied ‘...future.FUN’ to environment
[13:33:41.223] - copied ‘future.call.arguments’ to environment
[13:33:41.223] - copied ‘...future.elements_ii’ to environment
[13:33:41.223] - copied ‘...future.seeds_ii’ to environment
[13:33:41.223] - copied ‘...future.globals.maxSize’ to environment
[13:33:41.223] assign_globals() ... done
[13:33:41.224] plan(): Setting new future strategy stack:
[13:33:41.224] List of future strategies:
[13:33:41.224] 1. sequential:
[13:33:41.224]    - args: function (..., envir = parent.frame())
[13:33:41.224]    - tweaked: FALSE
[13:33:41.224]    - call: NULL
[13:33:41.224] plan(): nbrOfWorkers() = 1
[13:33:41.226] plan(): Setting new future strategy stack:
[13:33:41.226] List of future strategies:
[13:33:41.226] 1. multisession:
[13:33:41.226]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:33:41.226]    - tweaked: FALSE
[13:33:41.226]    - call: plan(strategy)
[13:33:41.229] plan(): nbrOfWorkers() = 1
[13:33:41.229] SequentialFuture started (and completed)
[13:33:41.230] - Launch lazy future ... done
[13:33:41.230] run() for ‘SequentialFuture’ ... done
[13:33:41.230] Created future:
[13:33:41.230] SequentialFuture:
[13:33:41.230] Label: ‘future_by-1’
[13:33:41.230] Expression:
[13:33:41.230] {
[13:33:41.230]     do.call(function(...) {
[13:33:41.230]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.230]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.230]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.230]             on.exit(options(oopts), add = TRUE)
[13:33:41.230]         }
[13:33:41.230]         {
[13:33:41.230]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.230]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.230]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.230]             })
[13:33:41.230]         }
[13:33:41.230]     }, args = future.call.arguments)
[13:33:41.230] }
[13:33:41.230] Lazy evaluation: FALSE
[13:33:41.230] Asynchronous evaluation: FALSE
[13:33:41.230] Local evaluation: TRUE
[13:33:41.230] Environment: R_GlobalEnv
[13:33:41.230] Capture standard output: TRUE
[13:33:41.230] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:41.230] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:41.230] Packages: <none>
[13:33:41.230] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:41.230] Resolved: TRUE
[13:33:41.230] Value: 4.62 KiB of class ‘list’
[13:33:41.230] Early signaling: FALSE
[13:33:41.230] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:41.230] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.231] Chunk #1 of 1 ... DONE
[13:33:41.231] Launching 1 futures (chunks) ... DONE
[13:33:41.231] Resolving 1 futures (chunks) ...
[13:33:41.231] resolve() on list ...
[13:33:41.231]  recursive: 0
[13:33:41.231]  length: 1
[13:33:41.232] 
[13:33:41.232] resolved() for ‘SequentialFuture’ ...
[13:33:41.232] - state: ‘finished’
[13:33:41.232] - run: TRUE
[13:33:41.232] - result: ‘FutureResult’
[13:33:41.232] resolved() for ‘SequentialFuture’ ... done
[13:33:41.232] Future #1
[13:33:41.232] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:41.233] - nx: 1
[13:33:41.233] - relay: TRUE
[13:33:41.233] - stdout: TRUE
[13:33:41.233] - signal: TRUE
[13:33:41.234] - resignal: FALSE
[13:33:41.234] - force: TRUE
[13:33:41.234] - relayed: [n=1] FALSE
[13:33:41.234] - queued futures: [n=1] FALSE
[13:33:41.234]  - until=1
[13:33:41.234]  - relaying element #1
[13:33:41.234] - relayed: [n=1] TRUE
[13:33:41.234] - queued futures: [n=1] TRUE
[13:33:41.234] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:41.234]  length: 0 (resolved future 1)
[13:33:41.235] Relaying remaining futures
[13:33:41.235] signalConditionsASAP(NULL, pos=0) ...
[13:33:41.235] - nx: 1
[13:33:41.235] - relay: TRUE
[13:33:41.235] - stdout: TRUE
[13:33:41.235] - signal: TRUE
[13:33:41.235] - resignal: FALSE
[13:33:41.235] - force: TRUE
[13:33:41.235] - relayed: [n=1] TRUE
[13:33:41.235] - queued futures: [n=1] TRUE
 - flush all
[13:33:41.235] - relayed: [n=1] TRUE
[13:33:41.236] - queued futures: [n=1] TRUE
[13:33:41.236] signalConditionsASAP(NULL, pos=0) ... done
[13:33:41.236] resolve() on list ... DONE
[13:33:41.236]  - Number of value chunks collected: 1
[13:33:41.236] Resolving 1 futures (chunks) ... DONE
[13:33:41.236] Reducing values from 1 chunks ...
[13:33:41.236]  - Number of values collected after concatenation: 3
[13:33:41.236]  - Number of values expected: 3
[13:33:41.236] Reducing values from 1 chunks ... DONE
[13:33:41.236] future_lapply() ... DONE
[13:33:41.236] future_by_internal() ... DONE
[13:33:41.237] future_by_internal() ...
[13:33:41.237] future_lapply() ...
[13:33:41.240] Number of chunks: 1
[13:33:41.240] getGlobalsAndPackagesXApply() ...
[13:33:41.241]  - future.globals: TRUE
[13:33:41.241] getGlobalsAndPackages() ...
[13:33:41.241] Searching for globals...
[13:33:41.242] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:41.242] Searching for globals ... DONE
[13:33:41.242] Resolving globals: FALSE
[13:33:41.242] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:41.243] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:41.243] - globals: [1] ‘FUN’
[13:33:41.243] 
[13:33:41.243] getGlobalsAndPackages() ... DONE
[13:33:41.243]  - globals found/used: [n=1] ‘FUN’
[13:33:41.243]  - needed namespaces: [n=0] 
[13:33:41.243] Finding globals ... DONE
[13:33:41.243]  - use_args: TRUE
[13:33:41.243]  - Getting '...' globals ...
[13:33:41.244] resolve() on list ...
[13:33:41.244]  recursive: 0
[13:33:41.244]  length: 1
[13:33:41.244]  elements: ‘...’
[13:33:41.244]  length: 0 (resolved future 1)
[13:33:41.244] resolve() on list ... DONE
[13:33:41.244]    - '...' content: [n=1] ‘digits’
[13:33:41.244] List of 1
[13:33:41.244]  $ ...:List of 1
[13:33:41.244]   ..$ digits: int 2
[13:33:41.244]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.244]  - attr(*, "where")=List of 1
[13:33:41.244]   ..$ ...:<environment: 0x55cb80e16098> 
[13:33:41.244]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.244]  - attr(*, "resolved")= logi TRUE
[13:33:41.244]  - attr(*, "total_size")= num NA
[13:33:41.247]  - Getting '...' globals ... DONE
[13:33:41.247] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:41.247] List of 2
[13:33:41.247]  $ ...future.FUN:function (object, ...)  
[13:33:41.247]  $ ...          :List of 1
[13:33:41.247]   ..$ digits: int 2
[13:33:41.247]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.247]  - attr(*, "where")=List of 2
[13:33:41.247]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:41.247]   ..$ ...          :<environment: 0x55cb80e16098> 
[13:33:41.247]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.247]  - attr(*, "resolved")= logi FALSE
[13:33:41.247]  - attr(*, "total_size")= num 1296
[13:33:41.250] Packages to be attached in all futures: [n=0] 
[13:33:41.250] getGlobalsAndPackagesXApply() ... DONE
[13:33:41.250] Number of futures (= number of chunks): 1
[13:33:41.250] Launching 1 futures (chunks) ...
[13:33:41.250] Chunk #1 of 1 ...
[13:33:41.251]  - Finding globals in 'X' for chunk #1 ...
[13:33:41.251] getGlobalsAndPackages() ...
[13:33:41.251] Searching for globals...
[13:33:41.251] 
[13:33:41.251] Searching for globals ... DONE
[13:33:41.251] - globals: [0] <none>
[13:33:41.251] getGlobalsAndPackages() ... DONE
[13:33:41.251]    + additional globals found: [n=0] 
[13:33:41.251]    + additional namespaces needed: [n=0] 
[13:33:41.251]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:41.252]  - seeds: <none>
[13:33:41.252]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.252] getGlobalsAndPackages() ...
[13:33:41.252] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.252] Resolving globals: FALSE
[13:33:41.252] Tweak future expression to call with '...' arguments ...
[13:33:41.252] {
[13:33:41.252]     do.call(function(...) {
[13:33:41.252]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.252]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.252]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.252]             on.exit(options(oopts), add = TRUE)
[13:33:41.252]         }
[13:33:41.252]         {
[13:33:41.252]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.252]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.252]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.252]             })
[13:33:41.252]         }
[13:33:41.252]     }, args = future.call.arguments)
[13:33:41.252] }
[13:33:41.252] Tweak future expression to call with '...' arguments ... DONE
[13:33:41.253] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.253] 
[13:33:41.254] getGlobalsAndPackages() ... DONE
[13:33:41.254] run() for ‘Future’ ...
[13:33:41.254] - state: ‘created’
[13:33:41.254] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:41.257] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.257] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:41.258]   - Field: ‘label’
[13:33:41.258]   - Field: ‘local’
[13:33:41.258]   - Field: ‘owner’
[13:33:41.258]   - Field: ‘envir’
[13:33:41.258]   - Field: ‘packages’
[13:33:41.258]   - Field: ‘gc’
[13:33:41.258]   - Field: ‘conditions’
[13:33:41.258]   - Field: ‘expr’
[13:33:41.258]   - Field: ‘uuid’
[13:33:41.258]   - Field: ‘seed’
[13:33:41.258]   - Field: ‘version’
[13:33:41.259]   - Field: ‘result’
[13:33:41.259]   - Field: ‘asynchronous’
[13:33:41.259]   - Field: ‘calls’
[13:33:41.259]   - Field: ‘globals’
[13:33:41.259]   - Field: ‘stdout’
[13:33:41.259]   - Field: ‘earlySignal’
[13:33:41.259]   - Field: ‘lazy’
[13:33:41.259]   - Field: ‘state’
[13:33:41.259] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:41.259] - Launch lazy future ...
[13:33:41.260] Packages needed by the future expression (n = 0): <none>
[13:33:41.260] Packages needed by future strategies (n = 0): <none>
[13:33:41.260] {
[13:33:41.260]     {
[13:33:41.260]         {
[13:33:41.260]             ...future.startTime <- base::Sys.time()
[13:33:41.260]             {
[13:33:41.260]                 {
[13:33:41.260]                   {
[13:33:41.260]                     base::local({
[13:33:41.260]                       has_future <- base::requireNamespace("future", 
[13:33:41.260]                         quietly = TRUE)
[13:33:41.260]                       if (has_future) {
[13:33:41.260]                         ns <- base::getNamespace("future")
[13:33:41.260]                         version <- ns[[".package"]][["version"]]
[13:33:41.260]                         if (is.null(version)) 
[13:33:41.260]                           version <- utils::packageVersion("future")
[13:33:41.260]                       }
[13:33:41.260]                       else {
[13:33:41.260]                         version <- NULL
[13:33:41.260]                       }
[13:33:41.260]                       if (!has_future || version < "1.8.0") {
[13:33:41.260]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:41.260]                           "", base::R.version$version.string), 
[13:33:41.260]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:41.260]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:41.260]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:41.260]                             "release", "version")], collapse = " "), 
[13:33:41.260]                           hostname = base::Sys.info()[["nodename"]])
[13:33:41.260]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:41.260]                           info)
[13:33:41.260]                         info <- base::paste(info, collapse = "; ")
[13:33:41.260]                         if (!has_future) {
[13:33:41.260]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:41.260]                             info)
[13:33:41.260]                         }
[13:33:41.260]                         else {
[13:33:41.260]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:41.260]                             info, version)
[13:33:41.260]                         }
[13:33:41.260]                         base::stop(msg)
[13:33:41.260]                       }
[13:33:41.260]                     })
[13:33:41.260]                   }
[13:33:41.260]                   ...future.strategy.old <- future::plan("list")
[13:33:41.260]                   options(future.plan = NULL)
[13:33:41.260]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.260]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:41.260]                 }
[13:33:41.260]                 ...future.workdir <- getwd()
[13:33:41.260]             }
[13:33:41.260]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:41.260]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:41.260]         }
[13:33:41.260]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:41.260]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:41.260]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:41.260]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:41.260]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:41.260]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:41.260]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:41.260]             base::names(...future.oldOptions))
[13:33:41.260]     }
[13:33:41.260]     if (FALSE) {
[13:33:41.260]     }
[13:33:41.260]     else {
[13:33:41.260]         if (TRUE) {
[13:33:41.260]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:41.260]                 open = "w")
[13:33:41.260]         }
[13:33:41.260]         else {
[13:33:41.260]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:41.260]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:41.260]         }
[13:33:41.260]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:41.260]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:41.260]             base::sink(type = "output", split = FALSE)
[13:33:41.260]             base::close(...future.stdout)
[13:33:41.260]         }, add = TRUE)
[13:33:41.260]     }
[13:33:41.260]     ...future.frame <- base::sys.nframe()
[13:33:41.260]     ...future.conditions <- base::list()
[13:33:41.260]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:41.260]     if (FALSE) {
[13:33:41.260]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:41.260]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:41.260]     }
[13:33:41.260]     ...future.result <- base::tryCatch({
[13:33:41.260]         base::withCallingHandlers({
[13:33:41.260]             ...future.value <- base::withVisible(base::local({
[13:33:41.260]                 do.call(function(...) {
[13:33:41.260]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.260]                   if (!identical(...future.globals.maxSize.org, 
[13:33:41.260]                     ...future.globals.maxSize)) {
[13:33:41.260]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.260]                     on.exit(options(oopts), add = TRUE)
[13:33:41.260]                   }
[13:33:41.260]                   {
[13:33:41.260]                     lapply(seq_along(...future.elements_ii), 
[13:33:41.260]                       FUN = function(jj) {
[13:33:41.260]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.260]                         ...future.FUN(...future.X_jj, ...)
[13:33:41.260]                       })
[13:33:41.260]                   }
[13:33:41.260]                 }, args = future.call.arguments)
[13:33:41.260]             }))
[13:33:41.260]             future::FutureResult(value = ...future.value$value, 
[13:33:41.260]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.260]                   ...future.rng), globalenv = if (FALSE) 
[13:33:41.260]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:41.260]                     ...future.globalenv.names))
[13:33:41.260]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:41.260]         }, condition = base::local({
[13:33:41.260]             c <- base::c
[13:33:41.260]             inherits <- base::inherits
[13:33:41.260]             invokeRestart <- base::invokeRestart
[13:33:41.260]             length <- base::length
[13:33:41.260]             list <- base::list
[13:33:41.260]             seq.int <- base::seq.int
[13:33:41.260]             signalCondition <- base::signalCondition
[13:33:41.260]             sys.calls <- base::sys.calls
[13:33:41.260]             `[[` <- base::`[[`
[13:33:41.260]             `+` <- base::`+`
[13:33:41.260]             `<<-` <- base::`<<-`
[13:33:41.260]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:41.260]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:41.260]                   3L)]
[13:33:41.260]             }
[13:33:41.260]             function(cond) {
[13:33:41.260]                 is_error <- inherits(cond, "error")
[13:33:41.260]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:41.260]                   NULL)
[13:33:41.260]                 if (is_error) {
[13:33:41.260]                   sessionInformation <- function() {
[13:33:41.260]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:41.260]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:41.260]                       search = base::search(), system = base::Sys.info())
[13:33:41.260]                   }
[13:33:41.260]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.260]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:41.260]                     cond$call), session = sessionInformation(), 
[13:33:41.260]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:41.260]                   signalCondition(cond)
[13:33:41.260]                 }
[13:33:41.260]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:41.260]                 "immediateCondition"))) {
[13:33:41.260]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:41.260]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.260]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:41.260]                   if (TRUE && !signal) {
[13:33:41.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.260]                     {
[13:33:41.260]                       inherits <- base::inherits
[13:33:41.260]                       invokeRestart <- base::invokeRestart
[13:33:41.260]                       is.null <- base::is.null
[13:33:41.260]                       muffled <- FALSE
[13:33:41.260]                       if (inherits(cond, "message")) {
[13:33:41.260]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.260]                         if (muffled) 
[13:33:41.260]                           invokeRestart("muffleMessage")
[13:33:41.260]                       }
[13:33:41.260]                       else if (inherits(cond, "warning")) {
[13:33:41.260]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.260]                         if (muffled) 
[13:33:41.260]                           invokeRestart("muffleWarning")
[13:33:41.260]                       }
[13:33:41.260]                       else if (inherits(cond, "condition")) {
[13:33:41.260]                         if (!is.null(pattern)) {
[13:33:41.260]                           computeRestarts <- base::computeRestarts
[13:33:41.260]                           grepl <- base::grepl
[13:33:41.260]                           restarts <- computeRestarts(cond)
[13:33:41.260]                           for (restart in restarts) {
[13:33:41.260]                             name <- restart$name
[13:33:41.260]                             if (is.null(name)) 
[13:33:41.260]                               next
[13:33:41.260]                             if (!grepl(pattern, name)) 
[13:33:41.260]                               next
[13:33:41.260]                             invokeRestart(restart)
[13:33:41.260]                             muffled <- TRUE
[13:33:41.260]                             break
[13:33:41.260]                           }
[13:33:41.260]                         }
[13:33:41.260]                       }
[13:33:41.260]                       invisible(muffled)
[13:33:41.260]                     }
[13:33:41.260]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.260]                   }
[13:33:41.260]                 }
[13:33:41.260]                 else {
[13:33:41.260]                   if (TRUE) {
[13:33:41.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.260]                     {
[13:33:41.260]                       inherits <- base::inherits
[13:33:41.260]                       invokeRestart <- base::invokeRestart
[13:33:41.260]                       is.null <- base::is.null
[13:33:41.260]                       muffled <- FALSE
[13:33:41.260]                       if (inherits(cond, "message")) {
[13:33:41.260]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.260]                         if (muffled) 
[13:33:41.260]                           invokeRestart("muffleMessage")
[13:33:41.260]                       }
[13:33:41.260]                       else if (inherits(cond, "warning")) {
[13:33:41.260]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.260]                         if (muffled) 
[13:33:41.260]                           invokeRestart("muffleWarning")
[13:33:41.260]                       }
[13:33:41.260]                       else if (inherits(cond, "condition")) {
[13:33:41.260]                         if (!is.null(pattern)) {
[13:33:41.260]                           computeRestarts <- base::computeRestarts
[13:33:41.260]                           grepl <- base::grepl
[13:33:41.260]                           restarts <- computeRestarts(cond)
[13:33:41.260]                           for (restart in restarts) {
[13:33:41.260]                             name <- restart$name
[13:33:41.260]                             if (is.null(name)) 
[13:33:41.260]                               next
[13:33:41.260]                             if (!grepl(pattern, name)) 
[13:33:41.260]                               next
[13:33:41.260]                             invokeRestart(restart)
[13:33:41.260]                             muffled <- TRUE
[13:33:41.260]                             break
[13:33:41.260]                           }
[13:33:41.260]                         }
[13:33:41.260]                       }
[13:33:41.260]                       invisible(muffled)
[13:33:41.260]                     }
[13:33:41.260]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.260]                   }
[13:33:41.260]                 }
[13:33:41.260]             }
[13:33:41.260]         }))
[13:33:41.260]     }, error = function(ex) {
[13:33:41.260]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:41.260]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.260]                 ...future.rng), started = ...future.startTime, 
[13:33:41.260]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:41.260]             version = "1.8"), class = "FutureResult")
[13:33:41.260]     }, finally = {
[13:33:41.260]         if (!identical(...future.workdir, getwd())) 
[13:33:41.260]             setwd(...future.workdir)
[13:33:41.260]         {
[13:33:41.260]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:41.260]                 ...future.oldOptions$nwarnings <- NULL
[13:33:41.260]             }
[13:33:41.260]             base::options(...future.oldOptions)
[13:33:41.260]             if (.Platform$OS.type == "windows") {
[13:33:41.260]                 old_names <- names(...future.oldEnvVars)
[13:33:41.260]                 envs <- base::Sys.getenv()
[13:33:41.260]                 names <- names(envs)
[13:33:41.260]                 common <- intersect(names, old_names)
[13:33:41.260]                 added <- setdiff(names, old_names)
[13:33:41.260]                 removed <- setdiff(old_names, names)
[13:33:41.260]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:41.260]                   envs[common]]
[13:33:41.260]                 NAMES <- toupper(changed)
[13:33:41.260]                 args <- list()
[13:33:41.260]                 for (kk in seq_along(NAMES)) {
[13:33:41.260]                   name <- changed[[kk]]
[13:33:41.260]                   NAME <- NAMES[[kk]]
[13:33:41.260]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.260]                     next
[13:33:41.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.260]                 }
[13:33:41.260]                 NAMES <- toupper(added)
[13:33:41.260]                 for (kk in seq_along(NAMES)) {
[13:33:41.260]                   name <- added[[kk]]
[13:33:41.260]                   NAME <- NAMES[[kk]]
[13:33:41.260]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.260]                     next
[13:33:41.260]                   args[[name]] <- ""
[13:33:41.260]                 }
[13:33:41.260]                 NAMES <- toupper(removed)
[13:33:41.260]                 for (kk in seq_along(NAMES)) {
[13:33:41.260]                   name <- removed[[kk]]
[13:33:41.260]                   NAME <- NAMES[[kk]]
[13:33:41.260]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.260]                     next
[13:33:41.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.260]                 }
[13:33:41.260]                 if (length(args) > 0) 
[13:33:41.260]                   base::do.call(base::Sys.setenv, args = args)
[13:33:41.260]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:41.260]             }
[13:33:41.260]             else {
[13:33:41.260]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:41.260]             }
[13:33:41.260]             {
[13:33:41.260]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:41.260]                   0L) {
[13:33:41.260]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:41.260]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:41.260]                   base::options(opts)
[13:33:41.260]                 }
[13:33:41.260]                 {
[13:33:41.260]                   {
[13:33:41.260]                     NULL
[13:33:41.260]                     RNGkind("Mersenne-Twister")
[13:33:41.260]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:41.260]                       inherits = FALSE)
[13:33:41.260]                   }
[13:33:41.260]                   options(future.plan = NULL)
[13:33:41.260]                   if (is.na(NA_character_)) 
[13:33:41.260]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.260]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:41.260]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:41.260]                     .init = FALSE)
[13:33:41.260]                 }
[13:33:41.260]             }
[13:33:41.260]         }
[13:33:41.260]     })
[13:33:41.260]     if (TRUE) {
[13:33:41.260]         base::sink(type = "output", split = FALSE)
[13:33:41.260]         if (TRUE) {
[13:33:41.260]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:41.260]         }
[13:33:41.260]         else {
[13:33:41.260]             ...future.result["stdout"] <- base::list(NULL)
[13:33:41.260]         }
[13:33:41.260]         base::close(...future.stdout)
[13:33:41.260]         ...future.stdout <- NULL
[13:33:41.260]     }
[13:33:41.260]     ...future.result$conditions <- ...future.conditions
[13:33:41.260]     ...future.result$finished <- base::Sys.time()
[13:33:41.260]     ...future.result
[13:33:41.260] }
[13:33:41.262] assign_globals() ...
[13:33:41.262] List of 5
[13:33:41.262]  $ ...future.FUN            :function (object, ...)  
[13:33:41.262]  $ future.call.arguments    :List of 1
[13:33:41.262]   ..$ digits: int 2
[13:33:41.262]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.262]  $ ...future.elements_ii    :List of 6
[13:33:41.262]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[13:33:41.262]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[13:33:41.262]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[13:33:41.262]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[13:33:41.262]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[13:33:41.262]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[13:33:41.262]  $ ...future.seeds_ii       : NULL
[13:33:41.262]  $ ...future.globals.maxSize: NULL
[13:33:41.262]  - attr(*, "where")=List of 5
[13:33:41.262]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:41.262]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:41.262]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:41.262]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:41.262]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:41.262]  - attr(*, "resolved")= logi FALSE
[13:33:41.262]  - attr(*, "total_size")= num 1296
[13:33:41.262]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.262]  - attr(*, "already-done")= logi TRUE
[13:33:41.268] - copied ‘...future.FUN’ to environment
[13:33:41.268] - copied ‘future.call.arguments’ to environment
[13:33:41.268] - copied ‘...future.elements_ii’ to environment
[13:33:41.268] - copied ‘...future.seeds_ii’ to environment
[13:33:41.268] - copied ‘...future.globals.maxSize’ to environment
[13:33:41.268] assign_globals() ... done
[13:33:41.269] plan(): Setting new future strategy stack:
[13:33:41.269] List of future strategies:
[13:33:41.269] 1. sequential:
[13:33:41.269]    - args: function (..., envir = parent.frame())
[13:33:41.269]    - tweaked: FALSE
[13:33:41.269]    - call: NULL
[13:33:41.269] plan(): nbrOfWorkers() = 1
[13:33:41.270] plan(): Setting new future strategy stack:
[13:33:41.270] List of future strategies:
[13:33:41.270] 1. multisession:
[13:33:41.270]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:33:41.270]    - tweaked: FALSE
[13:33:41.270]    - call: plan(strategy)
[13:33:41.273] plan(): nbrOfWorkers() = 1
[13:33:41.274] SequentialFuture started (and completed)
[13:33:41.274] - Launch lazy future ... done
[13:33:41.274] run() for ‘SequentialFuture’ ... done
[13:33:41.274] Created future:
[13:33:41.274] SequentialFuture:
[13:33:41.274] Label: ‘future_by-1’
[13:33:41.274] Expression:
[13:33:41.274] {
[13:33:41.274]     do.call(function(...) {
[13:33:41.274]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.274]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.274]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.274]             on.exit(options(oopts), add = TRUE)
[13:33:41.274]         }
[13:33:41.274]         {
[13:33:41.274]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.274]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.274]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.274]             })
[13:33:41.274]         }
[13:33:41.274]     }, args = future.call.arguments)
[13:33:41.274] }
[13:33:41.274] Lazy evaluation: FALSE
[13:33:41.274] Asynchronous evaluation: FALSE
[13:33:41.274] Local evaluation: TRUE
[13:33:41.274] Environment: R_GlobalEnv
[13:33:41.274] Capture standard output: TRUE
[13:33:41.274] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:41.274] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:41.274] Packages: <none>
[13:33:41.274] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:41.274] Resolved: TRUE
[13:33:41.274] Value: 5.48 KiB of class ‘list’
[13:33:41.274] Early signaling: FALSE
[13:33:41.274] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:41.274] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.275] Chunk #1 of 1 ... DONE
[13:33:41.275] Launching 1 futures (chunks) ... DONE
[13:33:41.275] Resolving 1 futures (chunks) ...
[13:33:41.275] resolve() on list ...
[13:33:41.275]  recursive: 0
[13:33:41.275]  length: 1
[13:33:41.276] 
[13:33:41.276] resolved() for ‘SequentialFuture’ ...
[13:33:41.276] - state: ‘finished’
[13:33:41.276] - run: TRUE
[13:33:41.276] - result: ‘FutureResult’
[13:33:41.276] resolved() for ‘SequentialFuture’ ... done
[13:33:41.276] Future #1
[13:33:41.276] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:41.276] - nx: 1
[13:33:41.276] - relay: TRUE
[13:33:41.276] - stdout: TRUE
[13:33:41.277] - signal: TRUE
[13:33:41.277] - resignal: FALSE
[13:33:41.278] - force: TRUE
[13:33:41.278] - relayed: [n=1] FALSE
[13:33:41.278] - queued futures: [n=1] FALSE
[13:33:41.278]  - until=1
[13:33:41.278]  - relaying element #1
[13:33:41.278] - relayed: [n=1] TRUE
[13:33:41.278] - queued futures: [n=1] TRUE
[13:33:41.278] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:41.278]  length: 0 (resolved future 1)
[13:33:41.279] Relaying remaining futures
[13:33:41.279] signalConditionsASAP(NULL, pos=0) ...
[13:33:41.279] - nx: 1
[13:33:41.279] - relay: TRUE
[13:33:41.279] - stdout: TRUE
[13:33:41.279] - signal: TRUE
[13:33:41.279] - resignal: FALSE
[13:33:41.279] - force: TRUE
[13:33:41.279] - relayed: [n=1] TRUE
[13:33:41.279] - queued futures: [n=1] TRUE
 - flush all
[13:33:41.279] - relayed: [n=1] TRUE
[13:33:41.279] - queued futures: [n=1] TRUE
[13:33:41.280] signalConditionsASAP(NULL, pos=0) ... done
[13:33:41.280] resolve() on list ... DONE
[13:33:41.280]  - Number of value chunks collected: 1
[13:33:41.280] Resolving 1 futures (chunks) ... DONE
[13:33:41.280] Reducing values from 1 chunks ...
[13:33:41.280]  - Number of values collected after concatenation: 6
[13:33:41.280]  - Number of values expected: 6
[13:33:41.280] Reducing values from 1 chunks ... DONE
[13:33:41.280] future_lapply() ... DONE
[13:33:41.280] future_by_internal() ... DONE
[13:33:41.281] future_by_internal() ...
[13:33:41.282] future_lapply() ...
[13:33:41.285] Number of chunks: 1
[13:33:41.285] getGlobalsAndPackagesXApply() ...
[13:33:41.285]  - future.globals: TRUE
[13:33:41.286] getGlobalsAndPackages() ...
[13:33:41.286] Searching for globals...
[13:33:41.287] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:33:41.287] Searching for globals ... DONE
[13:33:41.287] Resolving globals: FALSE
[13:33:41.288] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[13:33:41.288] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[13:33:41.288] - globals: [1] ‘FUN’
[13:33:41.288] - packages: [1] ‘stats’
[13:33:41.288] getGlobalsAndPackages() ... DONE
[13:33:41.288]  - globals found/used: [n=1] ‘FUN’
[13:33:41.289]  - needed namespaces: [n=1] ‘stats’
[13:33:41.289] Finding globals ... DONE
[13:33:41.289]  - use_args: TRUE
[13:33:41.289]  - Getting '...' globals ...
[13:33:41.289] resolve() on list ...
[13:33:41.289]  recursive: 0
[13:33:41.289]  length: 1
[13:33:41.289]  elements: ‘...’
[13:33:41.289]  length: 0 (resolved future 1)
[13:33:41.289] resolve() on list ... DONE
[13:33:41.290]    - '...' content: [n=1] ‘singular.ok’
[13:33:41.290] List of 1
[13:33:41.290]  $ ...:List of 1
[13:33:41.290]   ..$ singular.ok: logi FALSE
[13:33:41.290]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.290]  - attr(*, "where")=List of 1
[13:33:41.290]   ..$ ...:<environment: 0x55cb80acdce0> 
[13:33:41.290]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.290]  - attr(*, "resolved")= logi TRUE
[13:33:41.290]  - attr(*, "total_size")= num NA
[13:33:41.292]  - Getting '...' globals ... DONE
[13:33:41.293] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:41.293] List of 2
[13:33:41.293]  $ ...future.FUN:function (x, ...)  
[13:33:41.293]  $ ...          :List of 1
[13:33:41.293]   ..$ singular.ok: logi FALSE
[13:33:41.293]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.293]  - attr(*, "where")=List of 2
[13:33:41.293]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:41.293]   ..$ ...          :<environment: 0x55cb80acdce0> 
[13:33:41.293]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.293]  - attr(*, "resolved")= logi FALSE
[13:33:41.293]  - attr(*, "total_size")= num 5384
[13:33:41.296] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:41.296] getGlobalsAndPackagesXApply() ... DONE
[13:33:41.296] Number of futures (= number of chunks): 1
[13:33:41.296] Launching 1 futures (chunks) ...
[13:33:41.297] Chunk #1 of 1 ...
[13:33:41.297]  - Finding globals in 'X' for chunk #1 ...
[13:33:41.297] getGlobalsAndPackages() ...
[13:33:41.298] Searching for globals...
[13:33:41.298] 
[13:33:41.298] Searching for globals ... DONE
[13:33:41.298] - globals: [0] <none>
[13:33:41.298] getGlobalsAndPackages() ... DONE
[13:33:41.298]    + additional globals found: [n=0] 
[13:33:41.299]    + additional namespaces needed: [n=0] 
[13:33:41.299]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:41.299]  - seeds: <none>
[13:33:41.299]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.299] getGlobalsAndPackages() ...
[13:33:41.299] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.299] Resolving globals: FALSE
[13:33:41.299] Tweak future expression to call with '...' arguments ...
[13:33:41.299] {
[13:33:41.299]     do.call(function(...) {
[13:33:41.299]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.299]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.299]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.299]             on.exit(options(oopts), add = TRUE)
[13:33:41.299]         }
[13:33:41.299]         {
[13:33:41.299]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.299]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.299]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.299]             })
[13:33:41.299]         }
[13:33:41.299]     }, args = future.call.arguments)
[13:33:41.299] }
[13:33:41.300] Tweak future expression to call with '...' arguments ... DONE
[13:33:41.300] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.300] 
[13:33:41.300] getGlobalsAndPackages() ... DONE
[13:33:41.300] run() for ‘Future’ ...
[13:33:41.300] - state: ‘created’
[13:33:41.301] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:41.304] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.304] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:41.304]   - Field: ‘label’
[13:33:41.304]   - Field: ‘local’
[13:33:41.304]   - Field: ‘owner’
[13:33:41.305]   - Field: ‘envir’
[13:33:41.305]   - Field: ‘packages’
[13:33:41.305]   - Field: ‘gc’
[13:33:41.305]   - Field: ‘conditions’
[13:33:41.305]   - Field: ‘expr’
[13:33:41.305]   - Field: ‘uuid’
[13:33:41.305]   - Field: ‘seed’
[13:33:41.305]   - Field: ‘version’
[13:33:41.305]   - Field: ‘result’
[13:33:41.305]   - Field: ‘asynchronous’
[13:33:41.305]   - Field: ‘calls’
[13:33:41.305]   - Field: ‘globals’
[13:33:41.306]   - Field: ‘stdout’
[13:33:41.306]   - Field: ‘earlySignal’
[13:33:41.306]   - Field: ‘lazy’
[13:33:41.306]   - Field: ‘state’
[13:33:41.306] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:41.306] - Launch lazy future ...
[13:33:41.306] Packages needed by the future expression (n = 1): ‘stats’
[13:33:41.306] Packages needed by future strategies (n = 0): <none>
[13:33:41.307] {
[13:33:41.307]     {
[13:33:41.307]         {
[13:33:41.307]             ...future.startTime <- base::Sys.time()
[13:33:41.307]             {
[13:33:41.307]                 {
[13:33:41.307]                   {
[13:33:41.307]                     {
[13:33:41.307]                       base::local({
[13:33:41.307]                         has_future <- base::requireNamespace("future", 
[13:33:41.307]                           quietly = TRUE)
[13:33:41.307]                         if (has_future) {
[13:33:41.307]                           ns <- base::getNamespace("future")
[13:33:41.307]                           version <- ns[[".package"]][["version"]]
[13:33:41.307]                           if (is.null(version)) 
[13:33:41.307]                             version <- utils::packageVersion("future")
[13:33:41.307]                         }
[13:33:41.307]                         else {
[13:33:41.307]                           version <- NULL
[13:33:41.307]                         }
[13:33:41.307]                         if (!has_future || version < "1.8.0") {
[13:33:41.307]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:41.307]                             "", base::R.version$version.string), 
[13:33:41.307]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:41.307]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:41.307]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:41.307]                               "release", "version")], collapse = " "), 
[13:33:41.307]                             hostname = base::Sys.info()[["nodename"]])
[13:33:41.307]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:41.307]                             info)
[13:33:41.307]                           info <- base::paste(info, collapse = "; ")
[13:33:41.307]                           if (!has_future) {
[13:33:41.307]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:41.307]                               info)
[13:33:41.307]                           }
[13:33:41.307]                           else {
[13:33:41.307]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:41.307]                               info, version)
[13:33:41.307]                           }
[13:33:41.307]                           base::stop(msg)
[13:33:41.307]                         }
[13:33:41.307]                       })
[13:33:41.307]                     }
[13:33:41.307]                     base::local({
[13:33:41.307]                       for (pkg in "stats") {
[13:33:41.307]                         base::loadNamespace(pkg)
[13:33:41.307]                         base::library(pkg, character.only = TRUE)
[13:33:41.307]                       }
[13:33:41.307]                     })
[13:33:41.307]                   }
[13:33:41.307]                   ...future.strategy.old <- future::plan("list")
[13:33:41.307]                   options(future.plan = NULL)
[13:33:41.307]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.307]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:41.307]                 }
[13:33:41.307]                 ...future.workdir <- getwd()
[13:33:41.307]             }
[13:33:41.307]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:41.307]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:41.307]         }
[13:33:41.307]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:41.307]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:41.307]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:41.307]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:41.307]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:41.307]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:41.307]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:41.307]             base::names(...future.oldOptions))
[13:33:41.307]     }
[13:33:41.307]     if (FALSE) {
[13:33:41.307]     }
[13:33:41.307]     else {
[13:33:41.307]         if (TRUE) {
[13:33:41.307]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:41.307]                 open = "w")
[13:33:41.307]         }
[13:33:41.307]         else {
[13:33:41.307]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:41.307]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:41.307]         }
[13:33:41.307]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:41.307]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:41.307]             base::sink(type = "output", split = FALSE)
[13:33:41.307]             base::close(...future.stdout)
[13:33:41.307]         }, add = TRUE)
[13:33:41.307]     }
[13:33:41.307]     ...future.frame <- base::sys.nframe()
[13:33:41.307]     ...future.conditions <- base::list()
[13:33:41.307]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:41.307]     if (FALSE) {
[13:33:41.307]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:41.307]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:41.307]     }
[13:33:41.307]     ...future.result <- base::tryCatch({
[13:33:41.307]         base::withCallingHandlers({
[13:33:41.307]             ...future.value <- base::withVisible(base::local({
[13:33:41.307]                 do.call(function(...) {
[13:33:41.307]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.307]                   if (!identical(...future.globals.maxSize.org, 
[13:33:41.307]                     ...future.globals.maxSize)) {
[13:33:41.307]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.307]                     on.exit(options(oopts), add = TRUE)
[13:33:41.307]                   }
[13:33:41.307]                   {
[13:33:41.307]                     lapply(seq_along(...future.elements_ii), 
[13:33:41.307]                       FUN = function(jj) {
[13:33:41.307]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.307]                         ...future.FUN(...future.X_jj, ...)
[13:33:41.307]                       })
[13:33:41.307]                   }
[13:33:41.307]                 }, args = future.call.arguments)
[13:33:41.307]             }))
[13:33:41.307]             future::FutureResult(value = ...future.value$value, 
[13:33:41.307]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.307]                   ...future.rng), globalenv = if (FALSE) 
[13:33:41.307]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:41.307]                     ...future.globalenv.names))
[13:33:41.307]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:41.307]         }, condition = base::local({
[13:33:41.307]             c <- base::c
[13:33:41.307]             inherits <- base::inherits
[13:33:41.307]             invokeRestart <- base::invokeRestart
[13:33:41.307]             length <- base::length
[13:33:41.307]             list <- base::list
[13:33:41.307]             seq.int <- base::seq.int
[13:33:41.307]             signalCondition <- base::signalCondition
[13:33:41.307]             sys.calls <- base::sys.calls
[13:33:41.307]             `[[` <- base::`[[`
[13:33:41.307]             `+` <- base::`+`
[13:33:41.307]             `<<-` <- base::`<<-`
[13:33:41.307]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:41.307]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:41.307]                   3L)]
[13:33:41.307]             }
[13:33:41.307]             function(cond) {
[13:33:41.307]                 is_error <- inherits(cond, "error")
[13:33:41.307]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:41.307]                   NULL)
[13:33:41.307]                 if (is_error) {
[13:33:41.307]                   sessionInformation <- function() {
[13:33:41.307]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:41.307]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:41.307]                       search = base::search(), system = base::Sys.info())
[13:33:41.307]                   }
[13:33:41.307]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.307]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:41.307]                     cond$call), session = sessionInformation(), 
[13:33:41.307]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:41.307]                   signalCondition(cond)
[13:33:41.307]                 }
[13:33:41.307]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:41.307]                 "immediateCondition"))) {
[13:33:41.307]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:41.307]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.307]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:41.307]                   if (TRUE && !signal) {
[13:33:41.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.307]                     {
[13:33:41.307]                       inherits <- base::inherits
[13:33:41.307]                       invokeRestart <- base::invokeRestart
[13:33:41.307]                       is.null <- base::is.null
[13:33:41.307]                       muffled <- FALSE
[13:33:41.307]                       if (inherits(cond, "message")) {
[13:33:41.307]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.307]                         if (muffled) 
[13:33:41.307]                           invokeRestart("muffleMessage")
[13:33:41.307]                       }
[13:33:41.307]                       else if (inherits(cond, "warning")) {
[13:33:41.307]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.307]                         if (muffled) 
[13:33:41.307]                           invokeRestart("muffleWarning")
[13:33:41.307]                       }
[13:33:41.307]                       else if (inherits(cond, "condition")) {
[13:33:41.307]                         if (!is.null(pattern)) {
[13:33:41.307]                           computeRestarts <- base::computeRestarts
[13:33:41.307]                           grepl <- base::grepl
[13:33:41.307]                           restarts <- computeRestarts(cond)
[13:33:41.307]                           for (restart in restarts) {
[13:33:41.307]                             name <- restart$name
[13:33:41.307]                             if (is.null(name)) 
[13:33:41.307]                               next
[13:33:41.307]                             if (!grepl(pattern, name)) 
[13:33:41.307]                               next
[13:33:41.307]                             invokeRestart(restart)
[13:33:41.307]                             muffled <- TRUE
[13:33:41.307]                             break
[13:33:41.307]                           }
[13:33:41.307]                         }
[13:33:41.307]                       }
[13:33:41.307]                       invisible(muffled)
[13:33:41.307]                     }
[13:33:41.307]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.307]                   }
[13:33:41.307]                 }
[13:33:41.307]                 else {
[13:33:41.307]                   if (TRUE) {
[13:33:41.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.307]                     {
[13:33:41.307]                       inherits <- base::inherits
[13:33:41.307]                       invokeRestart <- base::invokeRestart
[13:33:41.307]                       is.null <- base::is.null
[13:33:41.307]                       muffled <- FALSE
[13:33:41.307]                       if (inherits(cond, "message")) {
[13:33:41.307]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.307]                         if (muffled) 
[13:33:41.307]                           invokeRestart("muffleMessage")
[13:33:41.307]                       }
[13:33:41.307]                       else if (inherits(cond, "warning")) {
[13:33:41.307]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.307]                         if (muffled) 
[13:33:41.307]                           invokeRestart("muffleWarning")
[13:33:41.307]                       }
[13:33:41.307]                       else if (inherits(cond, "condition")) {
[13:33:41.307]                         if (!is.null(pattern)) {
[13:33:41.307]                           computeRestarts <- base::computeRestarts
[13:33:41.307]                           grepl <- base::grepl
[13:33:41.307]                           restarts <- computeRestarts(cond)
[13:33:41.307]                           for (restart in restarts) {
[13:33:41.307]                             name <- restart$name
[13:33:41.307]                             if (is.null(name)) 
[13:33:41.307]                               next
[13:33:41.307]                             if (!grepl(pattern, name)) 
[13:33:41.307]                               next
[13:33:41.307]                             invokeRestart(restart)
[13:33:41.307]                             muffled <- TRUE
[13:33:41.307]                             break
[13:33:41.307]                           }
[13:33:41.307]                         }
[13:33:41.307]                       }
[13:33:41.307]                       invisible(muffled)
[13:33:41.307]                     }
[13:33:41.307]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.307]                   }
[13:33:41.307]                 }
[13:33:41.307]             }
[13:33:41.307]         }))
[13:33:41.307]     }, error = function(ex) {
[13:33:41.307]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:41.307]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.307]                 ...future.rng), started = ...future.startTime, 
[13:33:41.307]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:41.307]             version = "1.8"), class = "FutureResult")
[13:33:41.307]     }, finally = {
[13:33:41.307]         if (!identical(...future.workdir, getwd())) 
[13:33:41.307]             setwd(...future.workdir)
[13:33:41.307]         {
[13:33:41.307]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:41.307]                 ...future.oldOptions$nwarnings <- NULL
[13:33:41.307]             }
[13:33:41.307]             base::options(...future.oldOptions)
[13:33:41.307]             if (.Platform$OS.type == "windows") {
[13:33:41.307]                 old_names <- names(...future.oldEnvVars)
[13:33:41.307]                 envs <- base::Sys.getenv()
[13:33:41.307]                 names <- names(envs)
[13:33:41.307]                 common <- intersect(names, old_names)
[13:33:41.307]                 added <- setdiff(names, old_names)
[13:33:41.307]                 removed <- setdiff(old_names, names)
[13:33:41.307]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:41.307]                   envs[common]]
[13:33:41.307]                 NAMES <- toupper(changed)
[13:33:41.307]                 args <- list()
[13:33:41.307]                 for (kk in seq_along(NAMES)) {
[13:33:41.307]                   name <- changed[[kk]]
[13:33:41.307]                   NAME <- NAMES[[kk]]
[13:33:41.307]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.307]                     next
[13:33:41.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.307]                 }
[13:33:41.307]                 NAMES <- toupper(added)
[13:33:41.307]                 for (kk in seq_along(NAMES)) {
[13:33:41.307]                   name <- added[[kk]]
[13:33:41.307]                   NAME <- NAMES[[kk]]
[13:33:41.307]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.307]                     next
[13:33:41.307]                   args[[name]] <- ""
[13:33:41.307]                 }
[13:33:41.307]                 NAMES <- toupper(removed)
[13:33:41.307]                 for (kk in seq_along(NAMES)) {
[13:33:41.307]                   name <- removed[[kk]]
[13:33:41.307]                   NAME <- NAMES[[kk]]
[13:33:41.307]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.307]                     next
[13:33:41.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.307]                 }
[13:33:41.307]                 if (length(args) > 0) 
[13:33:41.307]                   base::do.call(base::Sys.setenv, args = args)
[13:33:41.307]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:41.307]             }
[13:33:41.307]             else {
[13:33:41.307]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:41.307]             }
[13:33:41.307]             {
[13:33:41.307]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:41.307]                   0L) {
[13:33:41.307]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:41.307]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:41.307]                   base::options(opts)
[13:33:41.307]                 }
[13:33:41.307]                 {
[13:33:41.307]                   {
[13:33:41.307]                     NULL
[13:33:41.307]                     RNGkind("Mersenne-Twister")
[13:33:41.307]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:41.307]                       inherits = FALSE)
[13:33:41.307]                   }
[13:33:41.307]                   options(future.plan = NULL)
[13:33:41.307]                   if (is.na(NA_character_)) 
[13:33:41.307]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.307]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:41.307]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:41.307]                     .init = FALSE)
[13:33:41.307]                 }
[13:33:41.307]             }
[13:33:41.307]         }
[13:33:41.307]     })
[13:33:41.307]     if (TRUE) {
[13:33:41.307]         base::sink(type = "output", split = FALSE)
[13:33:41.307]         if (TRUE) {
[13:33:41.307]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:41.307]         }
[13:33:41.307]         else {
[13:33:41.307]             ...future.result["stdout"] <- base::list(NULL)
[13:33:41.307]         }
[13:33:41.307]         base::close(...future.stdout)
[13:33:41.307]         ...future.stdout <- NULL
[13:33:41.307]     }
[13:33:41.307]     ...future.result$conditions <- ...future.conditions
[13:33:41.307]     ...future.result$finished <- base::Sys.time()
[13:33:41.307]     ...future.result
[13:33:41.307] }
[13:33:41.309] assign_globals() ...
[13:33:41.309] List of 5
[13:33:41.309]  $ ...future.FUN            :function (x, ...)  
[13:33:41.309]  $ future.call.arguments    :List of 1
[13:33:41.309]   ..$ singular.ok: logi FALSE
[13:33:41.309]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.309]  $ ...future.elements_ii    :List of 3
[13:33:41.309]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.309]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:33:41.309]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.309]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:41.309]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.309]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:33:41.309]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.309]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:33:41.309]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.309]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:33:41.309]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.309]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:33:41.309]  $ ...future.seeds_ii       : NULL
[13:33:41.309]  $ ...future.globals.maxSize: NULL
[13:33:41.309]  - attr(*, "where")=List of 5
[13:33:41.309]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:41.309]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:41.309]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:41.309]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:41.309]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:41.309]  - attr(*, "resolved")= logi FALSE
[13:33:41.309]  - attr(*, "total_size")= num 5384
[13:33:41.309]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.309]  - attr(*, "already-done")= logi TRUE
[13:33:41.317] - reassign environment for ‘...future.FUN’
[13:33:41.317] - copied ‘...future.FUN’ to environment
[13:33:41.317] - copied ‘future.call.arguments’ to environment
[13:33:41.317] - copied ‘...future.elements_ii’ to environment
[13:33:41.317] - copied ‘...future.seeds_ii’ to environment
[13:33:41.318] - copied ‘...future.globals.maxSize’ to environment
[13:33:41.318] assign_globals() ... done
[13:33:41.318] plan(): Setting new future strategy stack:
[13:33:41.318] List of future strategies:
[13:33:41.318] 1. sequential:
[13:33:41.318]    - args: function (..., envir = parent.frame())
[13:33:41.318]    - tweaked: FALSE
[13:33:41.318]    - call: NULL
[13:33:41.319] plan(): nbrOfWorkers() = 1
[13:33:41.322] plan(): Setting new future strategy stack:
[13:33:41.322] List of future strategies:
[13:33:41.322] 1. multisession:
[13:33:41.322]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:33:41.322]    - tweaked: FALSE
[13:33:41.322]    - call: plan(strategy)
[13:33:41.325] plan(): nbrOfWorkers() = 1
[13:33:41.326] SequentialFuture started (and completed)
[13:33:41.326] - Launch lazy future ... done
[13:33:41.326] run() for ‘SequentialFuture’ ... done
[13:33:41.326] Created future:
[13:33:41.326] SequentialFuture:
[13:33:41.326] Label: ‘future_by-1’
[13:33:41.326] Expression:
[13:33:41.326] {
[13:33:41.326]     do.call(function(...) {
[13:33:41.326]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.326]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.326]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.326]             on.exit(options(oopts), add = TRUE)
[13:33:41.326]         }
[13:33:41.326]         {
[13:33:41.326]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.326]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.326]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.326]             })
[13:33:41.326]         }
[13:33:41.326]     }, args = future.call.arguments)
[13:33:41.326] }
[13:33:41.326] Lazy evaluation: FALSE
[13:33:41.326] Asynchronous evaluation: FALSE
[13:33:41.326] Local evaluation: TRUE
[13:33:41.326] Environment: R_GlobalEnv
[13:33:41.326] Capture standard output: TRUE
[13:33:41.326] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:41.326] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:41.326] Packages: 1 packages (‘stats’)
[13:33:41.326] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:41.326] Resolved: TRUE
[13:33:41.326] Value: 26.06 KiB of class ‘list’
[13:33:41.326] Early signaling: FALSE
[13:33:41.326] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:41.326] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.327] Chunk #1 of 1 ... DONE
[13:33:41.328] Launching 1 futures (chunks) ... DONE
[13:33:41.328] Resolving 1 futures (chunks) ...
[13:33:41.328] resolve() on list ...
[13:33:41.328]  recursive: 0
[13:33:41.328]  length: 1
[13:33:41.328] 
[13:33:41.328] resolved() for ‘SequentialFuture’ ...
[13:33:41.328] - state: ‘finished’
[13:33:41.328] - run: TRUE
[13:33:41.328] - result: ‘FutureResult’
[13:33:41.328] resolved() for ‘SequentialFuture’ ... done
[13:33:41.329] Future #1
[13:33:41.329] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:41.329] - nx: 1
[13:33:41.329] - relay: TRUE
[13:33:41.329] - stdout: TRUE
[13:33:41.329] - signal: TRUE
[13:33:41.329] - resignal: FALSE
[13:33:41.329] - force: TRUE
[13:33:41.329] - relayed: [n=1] FALSE
[13:33:41.329] - queued futures: [n=1] FALSE
[13:33:41.329]  - until=1
[13:33:41.330]  - relaying element #1
[13:33:41.330] - relayed: [n=1] TRUE
[13:33:41.330] - queued futures: [n=1] TRUE
[13:33:41.330] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:41.330]  length: 0 (resolved future 1)
[13:33:41.330] Relaying remaining futures
[13:33:41.330] signalConditionsASAP(NULL, pos=0) ...
[13:33:41.330] - nx: 1
[13:33:41.330] - relay: TRUE
[13:33:41.330] - stdout: TRUE
[13:33:41.331] - signal: TRUE
[13:33:41.331] - resignal: FALSE
[13:33:41.331] - force: TRUE
[13:33:41.331] - relayed: [n=1] TRUE
[13:33:41.331] - queued futures: [n=1] TRUE
 - flush all
[13:33:41.331] - relayed: [n=1] TRUE
[13:33:41.331] - queued futures: [n=1] TRUE
[13:33:41.331] signalConditionsASAP(NULL, pos=0) ... done
[13:33:41.331] resolve() on list ... DONE
[13:33:41.331]  - Number of value chunks collected: 1
[13:33:41.331] Resolving 1 futures (chunks) ... DONE
[13:33:41.332] Reducing values from 1 chunks ...
[13:33:41.332]  - Number of values collected after concatenation: 3
[13:33:41.332]  - Number of values expected: 3
[13:33:41.332] Reducing values from 1 chunks ... DONE
[13:33:41.332] future_lapply() ... DONE
[13:33:41.332] future_by_internal() ... DONE
[13:33:41.336] future_by_internal() ...
[13:33:41.336] future_lapply() ...
[13:33:41.341] Number of chunks: 1
[13:33:41.341] getGlobalsAndPackagesXApply() ...
[13:33:41.341]  - future.globals: TRUE
[13:33:41.341] getGlobalsAndPackages() ...
[13:33:41.341] Searching for globals...
[13:33:41.343] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:33:41.343] Searching for globals ... DONE
[13:33:41.343] Resolving globals: FALSE
[13:33:41.343] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[13:33:41.344] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[13:33:41.344] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[13:33:41.344] - packages: [1] ‘stats’
[13:33:41.344] getGlobalsAndPackages() ... DONE
[13:33:41.344]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[13:33:41.344]  - needed namespaces: [n=1] ‘stats’
[13:33:41.344] Finding globals ... DONE
[13:33:41.344]  - use_args: TRUE
[13:33:41.344]  - Getting '...' globals ...
[13:33:41.345] resolve() on list ...
[13:33:41.345]  recursive: 0
[13:33:41.345]  length: 1
[13:33:41.345]  elements: ‘...’
[13:33:41.345]  length: 0 (resolved future 1)
[13:33:41.345] resolve() on list ... DONE
[13:33:41.345]    - '...' content: [n=0] 
[13:33:41.345] List of 1
[13:33:41.345]  $ ...: list()
[13:33:41.345]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.345]  - attr(*, "where")=List of 1
[13:33:41.345]   ..$ ...:<environment: 0x55cb826e1430> 
[13:33:41.345]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.345]  - attr(*, "resolved")= logi TRUE
[13:33:41.345]  - attr(*, "total_size")= num NA
[13:33:41.348]  - Getting '...' globals ... DONE
[13:33:41.348] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[13:33:41.348] List of 4
[13:33:41.348]  $ ...future.FUN:function (x)  
[13:33:41.348]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:33:41.348]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:41.348]  $ ...          : list()
[13:33:41.348]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.348]  - attr(*, "where")=List of 4
[13:33:41.348]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:41.348]   ..$ breaks       :<environment: R_EmptyEnv> 
[13:33:41.348]   ..$ wool         :<environment: R_EmptyEnv> 
[13:33:41.348]   ..$ ...          :<environment: 0x55cb826e1430> 
[13:33:41.348]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.348]  - attr(*, "resolved")= logi FALSE
[13:33:41.348]  - attr(*, "total_size")= num 2320
[13:33:41.352] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:41.352] getGlobalsAndPackagesXApply() ... DONE
[13:33:41.352] Number of futures (= number of chunks): 1
[13:33:41.352] Launching 1 futures (chunks) ...
[13:33:41.352] Chunk #1 of 1 ...
[13:33:41.352]  - Finding globals in 'X' for chunk #1 ...
[13:33:41.352] getGlobalsAndPackages() ...
[13:33:41.352] Searching for globals...
[13:33:41.353] 
[13:33:41.353] Searching for globals ... DONE
[13:33:41.353] - globals: [0] <none>
[13:33:41.353] getGlobalsAndPackages() ... DONE
[13:33:41.353]    + additional globals found: [n=0] 
[13:33:41.353]    + additional namespaces needed: [n=0] 
[13:33:41.353]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:41.353]  - seeds: <none>
[13:33:41.354]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.354] getGlobalsAndPackages() ...
[13:33:41.354] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.354] Resolving globals: FALSE
[13:33:41.354] Tweak future expression to call with '...' arguments ...
[13:33:41.354] {
[13:33:41.354]     do.call(function(...) {
[13:33:41.354]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.354]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.354]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.354]             on.exit(options(oopts), add = TRUE)
[13:33:41.354]         }
[13:33:41.354]         {
[13:33:41.354]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.354]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.354]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.354]             })
[13:33:41.354]         }
[13:33:41.354]     }, args = future.call.arguments)
[13:33:41.354] }
[13:33:41.354] Tweak future expression to call with '...' arguments ... DONE
[13:33:41.355] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.355] 
[13:33:41.355] getGlobalsAndPackages() ... DONE
[13:33:41.355] run() for ‘Future’ ...
[13:33:41.355] - state: ‘created’
[13:33:41.355] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:41.359] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.359] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:41.359]   - Field: ‘label’
[13:33:41.359]   - Field: ‘local’
[13:33:41.359]   - Field: ‘owner’
[13:33:41.359]   - Field: ‘envir’
[13:33:41.359]   - Field: ‘packages’
[13:33:41.359]   - Field: ‘gc’
[13:33:41.359]   - Field: ‘conditions’
[13:33:41.360]   - Field: ‘expr’
[13:33:41.361]   - Field: ‘uuid’
[13:33:41.361]   - Field: ‘seed’
[13:33:41.361]   - Field: ‘version’
[13:33:41.361]   - Field: ‘result’
[13:33:41.361]   - Field: ‘asynchronous’
[13:33:41.361]   - Field: ‘calls’
[13:33:41.361]   - Field: ‘globals’
[13:33:41.361]   - Field: ‘stdout’
[13:33:41.361]   - Field: ‘earlySignal’
[13:33:41.361]   - Field: ‘lazy’
[13:33:41.361]   - Field: ‘state’
[13:33:41.362] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:41.362] - Launch lazy future ...
[13:33:41.362] Packages needed by the future expression (n = 1): ‘stats’
[13:33:41.362] Packages needed by future strategies (n = 0): <none>
[13:33:41.362] {
[13:33:41.362]     {
[13:33:41.362]         {
[13:33:41.362]             ...future.startTime <- base::Sys.time()
[13:33:41.362]             {
[13:33:41.362]                 {
[13:33:41.362]                   {
[13:33:41.362]                     {
[13:33:41.362]                       base::local({
[13:33:41.362]                         has_future <- base::requireNamespace("future", 
[13:33:41.362]                           quietly = TRUE)
[13:33:41.362]                         if (has_future) {
[13:33:41.362]                           ns <- base::getNamespace("future")
[13:33:41.362]                           version <- ns[[".package"]][["version"]]
[13:33:41.362]                           if (is.null(version)) 
[13:33:41.362]                             version <- utils::packageVersion("future")
[13:33:41.362]                         }
[13:33:41.362]                         else {
[13:33:41.362]                           version <- NULL
[13:33:41.362]                         }
[13:33:41.362]                         if (!has_future || version < "1.8.0") {
[13:33:41.362]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:41.362]                             "", base::R.version$version.string), 
[13:33:41.362]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:41.362]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:41.362]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:41.362]                               "release", "version")], collapse = " "), 
[13:33:41.362]                             hostname = base::Sys.info()[["nodename"]])
[13:33:41.362]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:41.362]                             info)
[13:33:41.362]                           info <- base::paste(info, collapse = "; ")
[13:33:41.362]                           if (!has_future) {
[13:33:41.362]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:41.362]                               info)
[13:33:41.362]                           }
[13:33:41.362]                           else {
[13:33:41.362]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:41.362]                               info, version)
[13:33:41.362]                           }
[13:33:41.362]                           base::stop(msg)
[13:33:41.362]                         }
[13:33:41.362]                       })
[13:33:41.362]                     }
[13:33:41.362]                     base::local({
[13:33:41.362]                       for (pkg in "stats") {
[13:33:41.362]                         base::loadNamespace(pkg)
[13:33:41.362]                         base::library(pkg, character.only = TRUE)
[13:33:41.362]                       }
[13:33:41.362]                     })
[13:33:41.362]                   }
[13:33:41.362]                   ...future.strategy.old <- future::plan("list")
[13:33:41.362]                   options(future.plan = NULL)
[13:33:41.362]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.362]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:41.362]                 }
[13:33:41.362]                 ...future.workdir <- getwd()
[13:33:41.362]             }
[13:33:41.362]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:41.362]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:41.362]         }
[13:33:41.362]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:41.362]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:41.362]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:41.362]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:41.362]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:41.362]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:41.362]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:41.362]             base::names(...future.oldOptions))
[13:33:41.362]     }
[13:33:41.362]     if (FALSE) {
[13:33:41.362]     }
[13:33:41.362]     else {
[13:33:41.362]         if (TRUE) {
[13:33:41.362]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:41.362]                 open = "w")
[13:33:41.362]         }
[13:33:41.362]         else {
[13:33:41.362]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:41.362]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:41.362]         }
[13:33:41.362]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:41.362]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:41.362]             base::sink(type = "output", split = FALSE)
[13:33:41.362]             base::close(...future.stdout)
[13:33:41.362]         }, add = TRUE)
[13:33:41.362]     }
[13:33:41.362]     ...future.frame <- base::sys.nframe()
[13:33:41.362]     ...future.conditions <- base::list()
[13:33:41.362]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:41.362]     if (FALSE) {
[13:33:41.362]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:41.362]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:41.362]     }
[13:33:41.362]     ...future.result <- base::tryCatch({
[13:33:41.362]         base::withCallingHandlers({
[13:33:41.362]             ...future.value <- base::withVisible(base::local({
[13:33:41.362]                 do.call(function(...) {
[13:33:41.362]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.362]                   if (!identical(...future.globals.maxSize.org, 
[13:33:41.362]                     ...future.globals.maxSize)) {
[13:33:41.362]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.362]                     on.exit(options(oopts), add = TRUE)
[13:33:41.362]                   }
[13:33:41.362]                   {
[13:33:41.362]                     lapply(seq_along(...future.elements_ii), 
[13:33:41.362]                       FUN = function(jj) {
[13:33:41.362]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.362]                         ...future.FUN(...future.X_jj, ...)
[13:33:41.362]                       })
[13:33:41.362]                   }
[13:33:41.362]                 }, args = future.call.arguments)
[13:33:41.362]             }))
[13:33:41.362]             future::FutureResult(value = ...future.value$value, 
[13:33:41.362]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.362]                   ...future.rng), globalenv = if (FALSE) 
[13:33:41.362]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:41.362]                     ...future.globalenv.names))
[13:33:41.362]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:41.362]         }, condition = base::local({
[13:33:41.362]             c <- base::c
[13:33:41.362]             inherits <- base::inherits
[13:33:41.362]             invokeRestart <- base::invokeRestart
[13:33:41.362]             length <- base::length
[13:33:41.362]             list <- base::list
[13:33:41.362]             seq.int <- base::seq.int
[13:33:41.362]             signalCondition <- base::signalCondition
[13:33:41.362]             sys.calls <- base::sys.calls
[13:33:41.362]             `[[` <- base::`[[`
[13:33:41.362]             `+` <- base::`+`
[13:33:41.362]             `<<-` <- base::`<<-`
[13:33:41.362]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:41.362]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:41.362]                   3L)]
[13:33:41.362]             }
[13:33:41.362]             function(cond) {
[13:33:41.362]                 is_error <- inherits(cond, "error")
[13:33:41.362]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:41.362]                   NULL)
[13:33:41.362]                 if (is_error) {
[13:33:41.362]                   sessionInformation <- function() {
[13:33:41.362]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:41.362]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:41.362]                       search = base::search(), system = base::Sys.info())
[13:33:41.362]                   }
[13:33:41.362]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.362]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:41.362]                     cond$call), session = sessionInformation(), 
[13:33:41.362]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:41.362]                   signalCondition(cond)
[13:33:41.362]                 }
[13:33:41.362]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:41.362]                 "immediateCondition"))) {
[13:33:41.362]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:41.362]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.362]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:41.362]                   if (TRUE && !signal) {
[13:33:41.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.362]                     {
[13:33:41.362]                       inherits <- base::inherits
[13:33:41.362]                       invokeRestart <- base::invokeRestart
[13:33:41.362]                       is.null <- base::is.null
[13:33:41.362]                       muffled <- FALSE
[13:33:41.362]                       if (inherits(cond, "message")) {
[13:33:41.362]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.362]                         if (muffled) 
[13:33:41.362]                           invokeRestart("muffleMessage")
[13:33:41.362]                       }
[13:33:41.362]                       else if (inherits(cond, "warning")) {
[13:33:41.362]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.362]                         if (muffled) 
[13:33:41.362]                           invokeRestart("muffleWarning")
[13:33:41.362]                       }
[13:33:41.362]                       else if (inherits(cond, "condition")) {
[13:33:41.362]                         if (!is.null(pattern)) {
[13:33:41.362]                           computeRestarts <- base::computeRestarts
[13:33:41.362]                           grepl <- base::grepl
[13:33:41.362]                           restarts <- computeRestarts(cond)
[13:33:41.362]                           for (restart in restarts) {
[13:33:41.362]                             name <- restart$name
[13:33:41.362]                             if (is.null(name)) 
[13:33:41.362]                               next
[13:33:41.362]                             if (!grepl(pattern, name)) 
[13:33:41.362]                               next
[13:33:41.362]                             invokeRestart(restart)
[13:33:41.362]                             muffled <- TRUE
[13:33:41.362]                             break
[13:33:41.362]                           }
[13:33:41.362]                         }
[13:33:41.362]                       }
[13:33:41.362]                       invisible(muffled)
[13:33:41.362]                     }
[13:33:41.362]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.362]                   }
[13:33:41.362]                 }
[13:33:41.362]                 else {
[13:33:41.362]                   if (TRUE) {
[13:33:41.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.362]                     {
[13:33:41.362]                       inherits <- base::inherits
[13:33:41.362]                       invokeRestart <- base::invokeRestart
[13:33:41.362]                       is.null <- base::is.null
[13:33:41.362]                       muffled <- FALSE
[13:33:41.362]                       if (inherits(cond, "message")) {
[13:33:41.362]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.362]                         if (muffled) 
[13:33:41.362]                           invokeRestart("muffleMessage")
[13:33:41.362]                       }
[13:33:41.362]                       else if (inherits(cond, "warning")) {
[13:33:41.362]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.362]                         if (muffled) 
[13:33:41.362]                           invokeRestart("muffleWarning")
[13:33:41.362]                       }
[13:33:41.362]                       else if (inherits(cond, "condition")) {
[13:33:41.362]                         if (!is.null(pattern)) {
[13:33:41.362]                           computeRestarts <- base::computeRestarts
[13:33:41.362]                           grepl <- base::grepl
[13:33:41.362]                           restarts <- computeRestarts(cond)
[13:33:41.362]                           for (restart in restarts) {
[13:33:41.362]                             name <- restart$name
[13:33:41.362]                             if (is.null(name)) 
[13:33:41.362]                               next
[13:33:41.362]                             if (!grepl(pattern, name)) 
[13:33:41.362]                               next
[13:33:41.362]                             invokeRestart(restart)
[13:33:41.362]                             muffled <- TRUE
[13:33:41.362]                             break
[13:33:41.362]                           }
[13:33:41.362]                         }
[13:33:41.362]                       }
[13:33:41.362]                       invisible(muffled)
[13:33:41.362]                     }
[13:33:41.362]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.362]                   }
[13:33:41.362]                 }
[13:33:41.362]             }
[13:33:41.362]         }))
[13:33:41.362]     }, error = function(ex) {
[13:33:41.362]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:41.362]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.362]                 ...future.rng), started = ...future.startTime, 
[13:33:41.362]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:41.362]             version = "1.8"), class = "FutureResult")
[13:33:41.362]     }, finally = {
[13:33:41.362]         if (!identical(...future.workdir, getwd())) 
[13:33:41.362]             setwd(...future.workdir)
[13:33:41.362]         {
[13:33:41.362]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:41.362]                 ...future.oldOptions$nwarnings <- NULL
[13:33:41.362]             }
[13:33:41.362]             base::options(...future.oldOptions)
[13:33:41.362]             if (.Platform$OS.type == "windows") {
[13:33:41.362]                 old_names <- names(...future.oldEnvVars)
[13:33:41.362]                 envs <- base::Sys.getenv()
[13:33:41.362]                 names <- names(envs)
[13:33:41.362]                 common <- intersect(names, old_names)
[13:33:41.362]                 added <- setdiff(names, old_names)
[13:33:41.362]                 removed <- setdiff(old_names, names)
[13:33:41.362]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:41.362]                   envs[common]]
[13:33:41.362]                 NAMES <- toupper(changed)
[13:33:41.362]                 args <- list()
[13:33:41.362]                 for (kk in seq_along(NAMES)) {
[13:33:41.362]                   name <- changed[[kk]]
[13:33:41.362]                   NAME <- NAMES[[kk]]
[13:33:41.362]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.362]                     next
[13:33:41.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.362]                 }
[13:33:41.362]                 NAMES <- toupper(added)
[13:33:41.362]                 for (kk in seq_along(NAMES)) {
[13:33:41.362]                   name <- added[[kk]]
[13:33:41.362]                   NAME <- NAMES[[kk]]
[13:33:41.362]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.362]                     next
[13:33:41.362]                   args[[name]] <- ""
[13:33:41.362]                 }
[13:33:41.362]                 NAMES <- toupper(removed)
[13:33:41.362]                 for (kk in seq_along(NAMES)) {
[13:33:41.362]                   name <- removed[[kk]]
[13:33:41.362]                   NAME <- NAMES[[kk]]
[13:33:41.362]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.362]                     next
[13:33:41.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.362]                 }
[13:33:41.362]                 if (length(args) > 0) 
[13:33:41.362]                   base::do.call(base::Sys.setenv, args = args)
[13:33:41.362]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:41.362]             }
[13:33:41.362]             else {
[13:33:41.362]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:41.362]             }
[13:33:41.362]             {
[13:33:41.362]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:41.362]                   0L) {
[13:33:41.362]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:41.362]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:41.362]                   base::options(opts)
[13:33:41.362]                 }
[13:33:41.362]                 {
[13:33:41.362]                   {
[13:33:41.362]                     NULL
[13:33:41.362]                     RNGkind("Mersenne-Twister")
[13:33:41.362]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:41.362]                       inherits = FALSE)
[13:33:41.362]                   }
[13:33:41.362]                   options(future.plan = NULL)
[13:33:41.362]                   if (is.na(NA_character_)) 
[13:33:41.362]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.362]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:41.362]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:41.362]                     .init = FALSE)
[13:33:41.362]                 }
[13:33:41.362]             }
[13:33:41.362]         }
[13:33:41.362]     })
[13:33:41.362]     if (TRUE) {
[13:33:41.362]         base::sink(type = "output", split = FALSE)
[13:33:41.362]         if (TRUE) {
[13:33:41.362]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:41.362]         }
[13:33:41.362]         else {
[13:33:41.362]             ...future.result["stdout"] <- base::list(NULL)
[13:33:41.362]         }
[13:33:41.362]         base::close(...future.stdout)
[13:33:41.362]         ...future.stdout <- NULL
[13:33:41.362]     }
[13:33:41.362]     ...future.result$conditions <- ...future.conditions
[13:33:41.362]     ...future.result$finished <- base::Sys.time()
[13:33:41.362]     ...future.result
[13:33:41.362] }
[13:33:41.364] assign_globals() ...
[13:33:41.364] List of 7
[13:33:41.364]  $ ...future.FUN            :function (x)  
[13:33:41.364]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:33:41.364]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:41.364]  $ future.call.arguments    : list()
[13:33:41.364]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.364]  $ ...future.elements_ii    :List of 3
[13:33:41.364]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.364]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:33:41.364]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.364]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:41.364]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.364]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:33:41.364]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.364]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:33:41.364]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.364]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:33:41.364]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.364]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:33:41.364]  $ ...future.seeds_ii       : NULL
[13:33:41.364]  $ ...future.globals.maxSize: NULL
[13:33:41.364]  - attr(*, "where")=List of 7
[13:33:41.364]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:41.364]   ..$ breaks                   :<environment: R_EmptyEnv> 
[13:33:41.364]   ..$ wool                     :<environment: R_EmptyEnv> 
[13:33:41.364]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:41.364]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:41.364]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:41.364]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:41.364]  - attr(*, "resolved")= logi FALSE
[13:33:41.364]  - attr(*, "total_size")= num 2320
[13:33:41.364]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.364]  - attr(*, "already-done")= logi TRUE
[13:33:41.373] - reassign environment for ‘...future.FUN’
[13:33:41.373] - copied ‘...future.FUN’ to environment
[13:33:41.374] - copied ‘breaks’ to environment
[13:33:41.374] - copied ‘wool’ to environment
[13:33:41.374] - copied ‘future.call.arguments’ to environment
[13:33:41.374] - copied ‘...future.elements_ii’ to environment
[13:33:41.374] - copied ‘...future.seeds_ii’ to environment
[13:33:41.374] - copied ‘...future.globals.maxSize’ to environment
[13:33:41.374] assign_globals() ... done
[13:33:41.374] plan(): Setting new future strategy stack:
[13:33:41.375] List of future strategies:
[13:33:41.375] 1. sequential:
[13:33:41.375]    - args: function (..., envir = parent.frame())
[13:33:41.375]    - tweaked: FALSE
[13:33:41.375]    - call: NULL
[13:33:41.375] plan(): nbrOfWorkers() = 1
[13:33:41.378] plan(): Setting new future strategy stack:
[13:33:41.378] List of future strategies:
[13:33:41.378] 1. multisession:
[13:33:41.378]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:33:41.378]    - tweaked: FALSE
[13:33:41.378]    - call: plan(strategy)
[13:33:41.382] plan(): nbrOfWorkers() = 1
[13:33:41.382] SequentialFuture started (and completed)
[13:33:41.382] - Launch lazy future ... done
[13:33:41.382] run() for ‘SequentialFuture’ ... done
[13:33:41.382] Created future:
[13:33:41.383] SequentialFuture:
[13:33:41.383] Label: ‘future_by-1’
[13:33:41.383] Expression:
[13:33:41.383] {
[13:33:41.383]     do.call(function(...) {
[13:33:41.383]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.383]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.383]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.383]             on.exit(options(oopts), add = TRUE)
[13:33:41.383]         }
[13:33:41.383]         {
[13:33:41.383]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.383]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.383]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.383]             })
[13:33:41.383]         }
[13:33:41.383]     }, args = future.call.arguments)
[13:33:41.383] }
[13:33:41.383] Lazy evaluation: FALSE
[13:33:41.383] Asynchronous evaluation: FALSE
[13:33:41.383] Local evaluation: TRUE
[13:33:41.383] Environment: 0x55cb8266cbc8
[13:33:41.383] Capture standard output: TRUE
[13:33:41.383] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:41.383] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[13:33:41.383] Packages: 1 packages (‘stats’)
[13:33:41.383] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:41.383] Resolved: TRUE
[13:33:41.383] Value: 25.57 KiB of class ‘list’
[13:33:41.383] Early signaling: FALSE
[13:33:41.383] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:41.383] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.384] Chunk #1 of 1 ... DONE
[13:33:41.384] Launching 1 futures (chunks) ... DONE
[13:33:41.384] Resolving 1 futures (chunks) ...
[13:33:41.384] resolve() on list ...
[13:33:41.384]  recursive: 0
[13:33:41.385]  length: 1
[13:33:41.385] 
[13:33:41.385] resolved() for ‘SequentialFuture’ ...
[13:33:41.385] - state: ‘finished’
[13:33:41.385] - run: TRUE
[13:33:41.385] - result: ‘FutureResult’
[13:33:41.385] resolved() for ‘SequentialFuture’ ... done
[13:33:41.385] Future #1
[13:33:41.385] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:41.385] - nx: 1
[13:33:41.385] - relay: TRUE
[13:33:41.386] - stdout: TRUE
[13:33:41.386] - signal: TRUE
[13:33:41.386] - resignal: FALSE
[13:33:41.386] - force: TRUE
[13:33:41.386] - relayed: [n=1] FALSE
[13:33:41.386] - queued futures: [n=1] FALSE
[13:33:41.386]  - until=1
[13:33:41.386]  - relaying element #1
[13:33:41.386] - relayed: [n=1] TRUE
[13:33:41.386] - queued futures: [n=1] TRUE
[13:33:41.387] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:41.387]  length: 0 (resolved future 1)
[13:33:41.387] Relaying remaining futures
[13:33:41.387] signalConditionsASAP(NULL, pos=0) ...
[13:33:41.387] - nx: 1
[13:33:41.387] - relay: TRUE
[13:33:41.387] - stdout: TRUE
[13:33:41.387] - signal: TRUE
[13:33:41.387] - resignal: FALSE
[13:33:41.387] - force: TRUE
[13:33:41.387] - relayed: [n=1] TRUE
[13:33:41.387] - queued futures: [n=1] TRUE
 - flush all
[13:33:41.388] - relayed: [n=1] TRUE
[13:33:41.388] - queued futures: [n=1] TRUE
[13:33:41.388] signalConditionsASAP(NULL, pos=0) ... done
[13:33:41.388] resolve() on list ... DONE
[13:33:41.388]  - Number of value chunks collected: 1
[13:33:41.388] Resolving 1 futures (chunks) ... DONE
[13:33:41.388] Reducing values from 1 chunks ...
[13:33:41.388]  - Number of values collected after concatenation: 3
[13:33:41.388]  - Number of values expected: 3
[13:33:41.388] Reducing values from 1 chunks ... DONE
[13:33:41.388] future_lapply() ... DONE
[13:33:41.389] future_by_internal() ... DONE
[13:33:41.389] future_by_internal() ...
[13:33:41.389] future_lapply() ...
[13:33:41.393] Number of chunks: 1
[13:33:41.393] getGlobalsAndPackagesXApply() ...
[13:33:41.393]  - future.globals: TRUE
[13:33:41.393] getGlobalsAndPackages() ...
[13:33:41.393] Searching for globals...
[13:33:41.394] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:41.394] Searching for globals ... DONE
[13:33:41.394] Resolving globals: FALSE
[13:33:41.395] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:41.395] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:41.395] - globals: [1] ‘FUN’
[13:33:41.395] 
[13:33:41.395] getGlobalsAndPackages() ... DONE
[13:33:41.395]  - globals found/used: [n=1] ‘FUN’
[13:33:41.395]  - needed namespaces: [n=0] 
[13:33:41.395] Finding globals ... DONE
[13:33:41.396]  - use_args: TRUE
[13:33:41.396]  - Getting '...' globals ...
[13:33:41.396] resolve() on list ...
[13:33:41.396]  recursive: 0
[13:33:41.396]  length: 1
[13:33:41.396]  elements: ‘...’
[13:33:41.396]  length: 0 (resolved future 1)
[13:33:41.396] resolve() on list ... DONE
[13:33:41.396]    - '...' content: [n=0] 
[13:33:41.397] List of 1
[13:33:41.397]  $ ...: list()
[13:33:41.397]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.397]  - attr(*, "where")=List of 1
[13:33:41.397]   ..$ ...:<environment: 0x55cb80d9ceb8> 
[13:33:41.397]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.397]  - attr(*, "resolved")= logi TRUE
[13:33:41.397]  - attr(*, "total_size")= num NA
[13:33:41.399]  - Getting '...' globals ... DONE
[13:33:41.399] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:41.399] List of 2
[13:33:41.399]  $ ...future.FUN:function (object, ...)  
[13:33:41.399]  $ ...          : list()
[13:33:41.399]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.399]  - attr(*, "where")=List of 2
[13:33:41.399]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:41.399]   ..$ ...          :<environment: 0x55cb80d9ceb8> 
[13:33:41.399]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.399]  - attr(*, "resolved")= logi FALSE
[13:33:41.399]  - attr(*, "total_size")= num 1240
[13:33:41.403] Packages to be attached in all futures: [n=0] 
[13:33:41.403] getGlobalsAndPackagesXApply() ... DONE
[13:33:41.403] Number of futures (= number of chunks): 1
[13:33:41.403] Launching 1 futures (chunks) ...
[13:33:41.403] Chunk #1 of 1 ...
[13:33:41.403]  - Finding globals in 'X' for chunk #1 ...
[13:33:41.403] getGlobalsAndPackages() ...
[13:33:41.404] Searching for globals...
[13:33:41.404] 
[13:33:41.404] Searching for globals ... DONE
[13:33:41.404] - globals: [0] <none>
[13:33:41.404] getGlobalsAndPackages() ... DONE
[13:33:41.404]    + additional globals found: [n=0] 
[13:33:41.404]    + additional namespaces needed: [n=0] 
[13:33:41.405]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:41.405]  - seeds: <none>
[13:33:41.405]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.405] getGlobalsAndPackages() ...
[13:33:41.405] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.405] Resolving globals: FALSE
[13:33:41.405] Tweak future expression to call with '...' arguments ...
[13:33:41.405] {
[13:33:41.405]     do.call(function(...) {
[13:33:41.405]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.405]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.405]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.405]             on.exit(options(oopts), add = TRUE)
[13:33:41.405]         }
[13:33:41.405]         {
[13:33:41.405]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.405]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.405]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.405]             })
[13:33:41.405]         }
[13:33:41.405]     }, args = future.call.arguments)
[13:33:41.405] }
[13:33:41.405] Tweak future expression to call with '...' arguments ... DONE
[13:33:41.406] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.406] 
[13:33:41.406] getGlobalsAndPackages() ... DONE
[13:33:41.406] run() for ‘Future’ ...
[13:33:41.406] - state: ‘created’
[13:33:41.406] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:41.410] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.410] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:41.410]   - Field: ‘label’
[13:33:41.410]   - Field: ‘local’
[13:33:41.410]   - Field: ‘owner’
[13:33:41.410]   - Field: ‘envir’
[13:33:41.410]   - Field: ‘packages’
[13:33:41.410]   - Field: ‘gc’
[13:33:41.410]   - Field: ‘conditions’
[13:33:41.411]   - Field: ‘expr’
[13:33:41.411]   - Field: ‘uuid’
[13:33:41.411]   - Field: ‘seed’
[13:33:41.411]   - Field: ‘version’
[13:33:41.411]   - Field: ‘result’
[13:33:41.411]   - Field: ‘asynchronous’
[13:33:41.411]   - Field: ‘calls’
[13:33:41.411]   - Field: ‘globals’
[13:33:41.411]   - Field: ‘stdout’
[13:33:41.411]   - Field: ‘earlySignal’
[13:33:41.411]   - Field: ‘lazy’
[13:33:41.411]   - Field: ‘state’
[13:33:41.412] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:41.412] - Launch lazy future ...
[13:33:41.412] Packages needed by the future expression (n = 0): <none>
[13:33:41.412] Packages needed by future strategies (n = 0): <none>
[13:33:41.412] {
[13:33:41.412]     {
[13:33:41.412]         {
[13:33:41.412]             ...future.startTime <- base::Sys.time()
[13:33:41.412]             {
[13:33:41.412]                 {
[13:33:41.412]                   {
[13:33:41.412]                     base::local({
[13:33:41.412]                       has_future <- base::requireNamespace("future", 
[13:33:41.412]                         quietly = TRUE)
[13:33:41.412]                       if (has_future) {
[13:33:41.412]                         ns <- base::getNamespace("future")
[13:33:41.412]                         version <- ns[[".package"]][["version"]]
[13:33:41.412]                         if (is.null(version)) 
[13:33:41.412]                           version <- utils::packageVersion("future")
[13:33:41.412]                       }
[13:33:41.412]                       else {
[13:33:41.412]                         version <- NULL
[13:33:41.412]                       }
[13:33:41.412]                       if (!has_future || version < "1.8.0") {
[13:33:41.412]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:41.412]                           "", base::R.version$version.string), 
[13:33:41.412]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:41.412]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:41.412]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:41.412]                             "release", "version")], collapse = " "), 
[13:33:41.412]                           hostname = base::Sys.info()[["nodename"]])
[13:33:41.412]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:41.412]                           info)
[13:33:41.412]                         info <- base::paste(info, collapse = "; ")
[13:33:41.412]                         if (!has_future) {
[13:33:41.412]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:41.412]                             info)
[13:33:41.412]                         }
[13:33:41.412]                         else {
[13:33:41.412]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:41.412]                             info, version)
[13:33:41.412]                         }
[13:33:41.412]                         base::stop(msg)
[13:33:41.412]                       }
[13:33:41.412]                     })
[13:33:41.412]                   }
[13:33:41.412]                   ...future.strategy.old <- future::plan("list")
[13:33:41.412]                   options(future.plan = NULL)
[13:33:41.412]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.412]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:41.412]                 }
[13:33:41.412]                 ...future.workdir <- getwd()
[13:33:41.412]             }
[13:33:41.412]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:41.412]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:41.412]         }
[13:33:41.412]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:41.412]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:41.412]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:41.412]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:41.412]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:41.412]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:41.412]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:41.412]             base::names(...future.oldOptions))
[13:33:41.412]     }
[13:33:41.412]     if (FALSE) {
[13:33:41.412]     }
[13:33:41.412]     else {
[13:33:41.412]         if (TRUE) {
[13:33:41.412]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:41.412]                 open = "w")
[13:33:41.412]         }
[13:33:41.412]         else {
[13:33:41.412]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:41.412]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:41.412]         }
[13:33:41.412]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:41.412]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:41.412]             base::sink(type = "output", split = FALSE)
[13:33:41.412]             base::close(...future.stdout)
[13:33:41.412]         }, add = TRUE)
[13:33:41.412]     }
[13:33:41.412]     ...future.frame <- base::sys.nframe()
[13:33:41.412]     ...future.conditions <- base::list()
[13:33:41.412]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:41.412]     if (FALSE) {
[13:33:41.412]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:41.412]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:41.412]     }
[13:33:41.412]     ...future.result <- base::tryCatch({
[13:33:41.412]         base::withCallingHandlers({
[13:33:41.412]             ...future.value <- base::withVisible(base::local({
[13:33:41.412]                 do.call(function(...) {
[13:33:41.412]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.412]                   if (!identical(...future.globals.maxSize.org, 
[13:33:41.412]                     ...future.globals.maxSize)) {
[13:33:41.412]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.412]                     on.exit(options(oopts), add = TRUE)
[13:33:41.412]                   }
[13:33:41.412]                   {
[13:33:41.412]                     lapply(seq_along(...future.elements_ii), 
[13:33:41.412]                       FUN = function(jj) {
[13:33:41.412]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.412]                         ...future.FUN(...future.X_jj, ...)
[13:33:41.412]                       })
[13:33:41.412]                   }
[13:33:41.412]                 }, args = future.call.arguments)
[13:33:41.412]             }))
[13:33:41.412]             future::FutureResult(value = ...future.value$value, 
[13:33:41.412]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.412]                   ...future.rng), globalenv = if (FALSE) 
[13:33:41.412]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:41.412]                     ...future.globalenv.names))
[13:33:41.412]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:41.412]         }, condition = base::local({
[13:33:41.412]             c <- base::c
[13:33:41.412]             inherits <- base::inherits
[13:33:41.412]             invokeRestart <- base::invokeRestart
[13:33:41.412]             length <- base::length
[13:33:41.412]             list <- base::list
[13:33:41.412]             seq.int <- base::seq.int
[13:33:41.412]             signalCondition <- base::signalCondition
[13:33:41.412]             sys.calls <- base::sys.calls
[13:33:41.412]             `[[` <- base::`[[`
[13:33:41.412]             `+` <- base::`+`
[13:33:41.412]             `<<-` <- base::`<<-`
[13:33:41.412]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:41.412]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:41.412]                   3L)]
[13:33:41.412]             }
[13:33:41.412]             function(cond) {
[13:33:41.412]                 is_error <- inherits(cond, "error")
[13:33:41.412]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:41.412]                   NULL)
[13:33:41.412]                 if (is_error) {
[13:33:41.412]                   sessionInformation <- function() {
[13:33:41.412]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:41.412]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:41.412]                       search = base::search(), system = base::Sys.info())
[13:33:41.412]                   }
[13:33:41.412]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.412]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:41.412]                     cond$call), session = sessionInformation(), 
[13:33:41.412]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:41.412]                   signalCondition(cond)
[13:33:41.412]                 }
[13:33:41.412]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:41.412]                 "immediateCondition"))) {
[13:33:41.412]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:41.412]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.412]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:41.412]                   if (TRUE && !signal) {
[13:33:41.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.412]                     {
[13:33:41.412]                       inherits <- base::inherits
[13:33:41.412]                       invokeRestart <- base::invokeRestart
[13:33:41.412]                       is.null <- base::is.null
[13:33:41.412]                       muffled <- FALSE
[13:33:41.412]                       if (inherits(cond, "message")) {
[13:33:41.412]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.412]                         if (muffled) 
[13:33:41.412]                           invokeRestart("muffleMessage")
[13:33:41.412]                       }
[13:33:41.412]                       else if (inherits(cond, "warning")) {
[13:33:41.412]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.412]                         if (muffled) 
[13:33:41.412]                           invokeRestart("muffleWarning")
[13:33:41.412]                       }
[13:33:41.412]                       else if (inherits(cond, "condition")) {
[13:33:41.412]                         if (!is.null(pattern)) {
[13:33:41.412]                           computeRestarts <- base::computeRestarts
[13:33:41.412]                           grepl <- base::grepl
[13:33:41.412]                           restarts <- computeRestarts(cond)
[13:33:41.412]                           for (restart in restarts) {
[13:33:41.412]                             name <- restart$name
[13:33:41.412]                             if (is.null(name)) 
[13:33:41.412]                               next
[13:33:41.412]                             if (!grepl(pattern, name)) 
[13:33:41.412]                               next
[13:33:41.412]                             invokeRestart(restart)
[13:33:41.412]                             muffled <- TRUE
[13:33:41.412]                             break
[13:33:41.412]                           }
[13:33:41.412]                         }
[13:33:41.412]                       }
[13:33:41.412]                       invisible(muffled)
[13:33:41.412]                     }
[13:33:41.412]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.412]                   }
[13:33:41.412]                 }
[13:33:41.412]                 else {
[13:33:41.412]                   if (TRUE) {
[13:33:41.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.412]                     {
[13:33:41.412]                       inherits <- base::inherits
[13:33:41.412]                       invokeRestart <- base::invokeRestart
[13:33:41.412]                       is.null <- base::is.null
[13:33:41.412]                       muffled <- FALSE
[13:33:41.412]                       if (inherits(cond, "message")) {
[13:33:41.412]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.412]                         if (muffled) 
[13:33:41.412]                           invokeRestart("muffleMessage")
[13:33:41.412]                       }
[13:33:41.412]                       else if (inherits(cond, "warning")) {
[13:33:41.412]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.412]                         if (muffled) 
[13:33:41.412]                           invokeRestart("muffleWarning")
[13:33:41.412]                       }
[13:33:41.412]                       else if (inherits(cond, "condition")) {
[13:33:41.412]                         if (!is.null(pattern)) {
[13:33:41.412]                           computeRestarts <- base::computeRestarts
[13:33:41.412]                           grepl <- base::grepl
[13:33:41.412]                           restarts <- computeRestarts(cond)
[13:33:41.412]                           for (restart in restarts) {
[13:33:41.412]                             name <- restart$name
[13:33:41.412]                             if (is.null(name)) 
[13:33:41.412]                               next
[13:33:41.412]                             if (!grepl(pattern, name)) 
[13:33:41.412]                               next
[13:33:41.412]                             invokeRestart(restart)
[13:33:41.412]                             muffled <- TRUE
[13:33:41.412]                             break
[13:33:41.412]                           }
[13:33:41.412]                         }
[13:33:41.412]                       }
[13:33:41.412]                       invisible(muffled)
[13:33:41.412]                     }
[13:33:41.412]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.412]                   }
[13:33:41.412]                 }
[13:33:41.412]             }
[13:33:41.412]         }))
[13:33:41.412]     }, error = function(ex) {
[13:33:41.412]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:41.412]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.412]                 ...future.rng), started = ...future.startTime, 
[13:33:41.412]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:41.412]             version = "1.8"), class = "FutureResult")
[13:33:41.412]     }, finally = {
[13:33:41.412]         if (!identical(...future.workdir, getwd())) 
[13:33:41.412]             setwd(...future.workdir)
[13:33:41.412]         {
[13:33:41.412]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:41.412]                 ...future.oldOptions$nwarnings <- NULL
[13:33:41.412]             }
[13:33:41.412]             base::options(...future.oldOptions)
[13:33:41.412]             if (.Platform$OS.type == "windows") {
[13:33:41.412]                 old_names <- names(...future.oldEnvVars)
[13:33:41.412]                 envs <- base::Sys.getenv()
[13:33:41.412]                 names <- names(envs)
[13:33:41.412]                 common <- intersect(names, old_names)
[13:33:41.412]                 added <- setdiff(names, old_names)
[13:33:41.412]                 removed <- setdiff(old_names, names)
[13:33:41.412]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:41.412]                   envs[common]]
[13:33:41.412]                 NAMES <- toupper(changed)
[13:33:41.412]                 args <- list()
[13:33:41.412]                 for (kk in seq_along(NAMES)) {
[13:33:41.412]                   name <- changed[[kk]]
[13:33:41.412]                   NAME <- NAMES[[kk]]
[13:33:41.412]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.412]                     next
[13:33:41.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.412]                 }
[13:33:41.412]                 NAMES <- toupper(added)
[13:33:41.412]                 for (kk in seq_along(NAMES)) {
[13:33:41.412]                   name <- added[[kk]]
[13:33:41.412]                   NAME <- NAMES[[kk]]
[13:33:41.412]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.412]                     next
[13:33:41.412]                   args[[name]] <- ""
[13:33:41.412]                 }
[13:33:41.412]                 NAMES <- toupper(removed)
[13:33:41.412]                 for (kk in seq_along(NAMES)) {
[13:33:41.412]                   name <- removed[[kk]]
[13:33:41.412]                   NAME <- NAMES[[kk]]
[13:33:41.412]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.412]                     next
[13:33:41.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.412]                 }
[13:33:41.412]                 if (length(args) > 0) 
[13:33:41.412]                   base::do.call(base::Sys.setenv, args = args)
[13:33:41.412]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:41.412]             }
[13:33:41.412]             else {
[13:33:41.412]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:41.412]             }
[13:33:41.412]             {
[13:33:41.412]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:41.412]                   0L) {
[13:33:41.412]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:41.412]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:41.412]                   base::options(opts)
[13:33:41.412]                 }
[13:33:41.412]                 {
[13:33:41.412]                   {
[13:33:41.412]                     NULL
[13:33:41.412]                     RNGkind("Mersenne-Twister")
[13:33:41.412]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:41.412]                       inherits = FALSE)
[13:33:41.412]                   }
[13:33:41.412]                   options(future.plan = NULL)
[13:33:41.412]                   if (is.na(NA_character_)) 
[13:33:41.412]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.412]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:41.412]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:41.412]                     .init = FALSE)
[13:33:41.412]                 }
[13:33:41.412]             }
[13:33:41.412]         }
[13:33:41.412]     })
[13:33:41.412]     if (TRUE) {
[13:33:41.412]         base::sink(type = "output", split = FALSE)
[13:33:41.412]         if (TRUE) {
[13:33:41.412]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:41.412]         }
[13:33:41.412]         else {
[13:33:41.412]             ...future.result["stdout"] <- base::list(NULL)
[13:33:41.412]         }
[13:33:41.412]         base::close(...future.stdout)
[13:33:41.412]         ...future.stdout <- NULL
[13:33:41.412]     }
[13:33:41.412]     ...future.result$conditions <- ...future.conditions
[13:33:41.412]     ...future.result$finished <- base::Sys.time()
[13:33:41.412]     ...future.result
[13:33:41.412] }
[13:33:41.414] assign_globals() ...
[13:33:41.414] List of 5
[13:33:41.414]  $ ...future.FUN            :function (object, ...)  
[13:33:41.414]  $ future.call.arguments    : list()
[13:33:41.414]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.414]  $ ...future.elements_ii    :List of 3
[13:33:41.414]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.414]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:33:41.414]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.414]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:41.414]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.414]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:33:41.414]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.414]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:33:41.414]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.414]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:33:41.414]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.414]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:33:41.414]  $ ...future.seeds_ii       : NULL
[13:33:41.414]  $ ...future.globals.maxSize: NULL
[13:33:41.414]  - attr(*, "where")=List of 5
[13:33:41.414]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:41.414]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:41.414]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:41.414]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:41.414]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:41.414]  - attr(*, "resolved")= logi FALSE
[13:33:41.414]  - attr(*, "total_size")= num 1240
[13:33:41.414]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.414]  - attr(*, "already-done")= logi TRUE
[13:33:41.423] - copied ‘...future.FUN’ to environment
[13:33:41.423] - copied ‘future.call.arguments’ to environment
[13:33:41.423] - copied ‘...future.elements_ii’ to environment
[13:33:41.423] - copied ‘...future.seeds_ii’ to environment
[13:33:41.423] - copied ‘...future.globals.maxSize’ to environment
[13:33:41.423] assign_globals() ... done
[13:33:41.424] plan(): Setting new future strategy stack:
[13:33:41.424] List of future strategies:
[13:33:41.424] 1. sequential:
[13:33:41.424]    - args: function (..., envir = parent.frame())
[13:33:41.424]    - tweaked: FALSE
[13:33:41.424]    - call: NULL
[13:33:41.424] plan(): nbrOfWorkers() = 1
[13:33:41.426] plan(): Setting new future strategy stack:
[13:33:41.426] List of future strategies:
[13:33:41.426] 1. multisession:
[13:33:41.426]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:33:41.426]    - tweaked: FALSE
[13:33:41.426]    - call: plan(strategy)
[13:33:41.429] plan(): nbrOfWorkers() = 1
[13:33:41.429] SequentialFuture started (and completed)
[13:33:41.430] - Launch lazy future ... done
[13:33:41.430] run() for ‘SequentialFuture’ ... done
[13:33:41.430] Created future:
[13:33:41.430] SequentialFuture:
[13:33:41.430] Label: ‘future_by-1’
[13:33:41.430] Expression:
[13:33:41.430] {
[13:33:41.430]     do.call(function(...) {
[13:33:41.430]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.430]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.430]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.430]             on.exit(options(oopts), add = TRUE)
[13:33:41.430]         }
[13:33:41.430]         {
[13:33:41.430]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.430]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.430]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.430]             })
[13:33:41.430]         }
[13:33:41.430]     }, args = future.call.arguments)
[13:33:41.430] }
[13:33:41.430] Lazy evaluation: FALSE
[13:33:41.430] Asynchronous evaluation: FALSE
[13:33:41.430] Local evaluation: TRUE
[13:33:41.430] Environment: 0x55cb80fc9f28
[13:33:41.430] Capture standard output: TRUE
[13:33:41.430] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:41.430] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:41.430] Packages: <none>
[13:33:41.430] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:41.430] Resolved: TRUE
[13:33:41.430] Value: 5.37 KiB of class ‘list’
[13:33:41.430] Early signaling: FALSE
[13:33:41.430] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:41.430] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.431] Chunk #1 of 1 ... DONE
[13:33:41.431] Launching 1 futures (chunks) ... DONE
[13:33:41.431] Resolving 1 futures (chunks) ...
[13:33:41.431] resolve() on list ...
[13:33:41.431]  recursive: 0
[13:33:41.431]  length: 1
[13:33:41.432] 
[13:33:41.432] resolved() for ‘SequentialFuture’ ...
[13:33:41.432] - state: ‘finished’
[13:33:41.432] - run: TRUE
[13:33:41.432] - result: ‘FutureResult’
[13:33:41.432] resolved() for ‘SequentialFuture’ ... done
[13:33:41.432] Future #1
[13:33:41.432] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:41.432] - nx: 1
[13:33:41.432] - relay: TRUE
[13:33:41.433] - stdout: TRUE
[13:33:41.433] - signal: TRUE
[13:33:41.433] - resignal: FALSE
[13:33:41.433] - force: TRUE
[13:33:41.433] - relayed: [n=1] FALSE
[13:33:41.433] - queued futures: [n=1] FALSE
[13:33:41.433]  - until=1
[13:33:41.433]  - relaying element #1
[13:33:41.433] - relayed: [n=1] TRUE
[13:33:41.433] - queued futures: [n=1] TRUE
[13:33:41.433] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:41.434]  length: 0 (resolved future 1)
[13:33:41.434] Relaying remaining futures
[13:33:41.434] signalConditionsASAP(NULL, pos=0) ...
[13:33:41.434] - nx: 1
[13:33:41.434] - relay: TRUE
[13:33:41.434] - stdout: TRUE
[13:33:41.434] - signal: TRUE
[13:33:41.434] - resignal: FALSE
[13:33:41.434] - force: TRUE
[13:33:41.434] - relayed: [n=1] TRUE
[13:33:41.434] - queued futures: [n=1] TRUE
 - flush all
[13:33:41.434] - relayed: [n=1] TRUE
[13:33:41.435] - queued futures: [n=1] TRUE
[13:33:41.435] signalConditionsASAP(NULL, pos=0) ... done
[13:33:41.435] resolve() on list ... DONE
[13:33:41.435]  - Number of value chunks collected: 1
[13:33:41.435] Resolving 1 futures (chunks) ... DONE
[13:33:41.435] Reducing values from 1 chunks ...
[13:33:41.435]  - Number of values collected after concatenation: 3
[13:33:41.435]  - Number of values expected: 3
[13:33:41.435] Reducing values from 1 chunks ... DONE
[13:33:41.435] future_lapply() ... DONE
[13:33:41.435] future_by_internal() ... DONE
[13:33:41.436] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[13:33:41.437] future_lapply() ...
[13:33:41.440] Number of chunks: 1
[13:33:41.440] getGlobalsAndPackagesXApply() ...
[13:33:41.440]  - future.globals: TRUE
[13:33:41.440] getGlobalsAndPackages() ...
[13:33:41.440] Searching for globals...
[13:33:41.441] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:41.441] Searching for globals ... DONE
[13:33:41.442] Resolving globals: FALSE
[13:33:41.442] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:41.442] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:41.442] - globals: [1] ‘FUN’
[13:33:41.442] 
[13:33:41.443] getGlobalsAndPackages() ... DONE
[13:33:41.443]  - globals found/used: [n=1] ‘FUN’
[13:33:41.443]  - needed namespaces: [n=0] 
[13:33:41.443] Finding globals ... DONE
[13:33:41.443]  - use_args: TRUE
[13:33:41.443]  - Getting '...' globals ...
[13:33:41.443] resolve() on list ...
[13:33:41.443]  recursive: 0
[13:33:41.443]  length: 1
[13:33:41.444]  elements: ‘...’
[13:33:41.444]  length: 0 (resolved future 1)
[13:33:41.444] resolve() on list ... DONE
[13:33:41.444]    - '...' content: [n=0] 
[13:33:41.446] List of 1
[13:33:41.446]  $ ...: list()
[13:33:41.446]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.446]  - attr(*, "where")=List of 1
[13:33:41.446]   ..$ ...:<environment: 0x55cb823f5330> 
[13:33:41.446]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.446]  - attr(*, "resolved")= logi TRUE
[13:33:41.446]  - attr(*, "total_size")= num NA
[13:33:41.448]  - Getting '...' globals ... DONE
[13:33:41.448] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:41.449] List of 2
[13:33:41.449]  $ ...future.FUN:function (object, ...)  
[13:33:41.449]  $ ...          : list()
[13:33:41.449]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.449]  - attr(*, "where")=List of 2
[13:33:41.449]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:41.449]   ..$ ...          :<environment: 0x55cb823f5330> 
[13:33:41.449]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.449]  - attr(*, "resolved")= logi FALSE
[13:33:41.449]  - attr(*, "total_size")= num 1240
[13:33:41.451] Packages to be attached in all futures: [n=0] 
[13:33:41.451] getGlobalsAndPackagesXApply() ... DONE
[13:33:41.451] Number of futures (= number of chunks): 1
[13:33:41.452] Launching 1 futures (chunks) ...
[13:33:41.452] Chunk #1 of 1 ...
[13:33:41.452]  - Finding globals in 'X' for chunk #1 ...
[13:33:41.452] getGlobalsAndPackages() ...
[13:33:41.452] Searching for globals...
[13:33:41.452] 
[13:33:41.452] Searching for globals ... DONE
[13:33:41.453] - globals: [0] <none>
[13:33:41.453] getGlobalsAndPackages() ... DONE
[13:33:41.453]    + additional globals found: [n=0] 
[13:33:41.453]    + additional namespaces needed: [n=0] 
[13:33:41.453]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:41.453]  - seeds: <none>
[13:33:41.453]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.453] getGlobalsAndPackages() ...
[13:33:41.453] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.453] Resolving globals: FALSE
[13:33:41.453] Tweak future expression to call with '...' arguments ...
[13:33:41.454] {
[13:33:41.454]     do.call(function(...) {
[13:33:41.454]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.454]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.454]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.454]             on.exit(options(oopts), add = TRUE)
[13:33:41.454]         }
[13:33:41.454]         {
[13:33:41.454]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.454]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.454]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.454]             })
[13:33:41.454]         }
[13:33:41.454]     }, args = future.call.arguments)
[13:33:41.454] }
[13:33:41.454] Tweak future expression to call with '...' arguments ... DONE
[13:33:41.454] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.454] 
[13:33:41.454] getGlobalsAndPackages() ... DONE
[13:33:41.455] run() for ‘Future’ ...
[13:33:41.455] - state: ‘created’
[13:33:41.455] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:41.458] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.458] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:41.458]   - Field: ‘label’
[13:33:41.458]   - Field: ‘local’
[13:33:41.458]   - Field: ‘owner’
[13:33:41.458]   - Field: ‘envir’
[13:33:41.459]   - Field: ‘packages’
[13:33:41.459]   - Field: ‘gc’
[13:33:41.459]   - Field: ‘conditions’
[13:33:41.459]   - Field: ‘expr’
[13:33:41.459]   - Field: ‘uuid’
[13:33:41.459]   - Field: ‘seed’
[13:33:41.459]   - Field: ‘version’
[13:33:41.459]   - Field: ‘result’
[13:33:41.459]   - Field: ‘asynchronous’
[13:33:41.459]   - Field: ‘calls’
[13:33:41.459]   - Field: ‘globals’
[13:33:41.460]   - Field: ‘stdout’
[13:33:41.460]   - Field: ‘earlySignal’
[13:33:41.460]   - Field: ‘lazy’
[13:33:41.460]   - Field: ‘state’
[13:33:41.460] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:41.460] - Launch lazy future ...
[13:33:41.460] Packages needed by the future expression (n = 0): <none>
[13:33:41.460] Packages needed by future strategies (n = 0): <none>
[13:33:41.461] {
[13:33:41.461]     {
[13:33:41.461]         {
[13:33:41.461]             ...future.startTime <- base::Sys.time()
[13:33:41.461]             {
[13:33:41.461]                 {
[13:33:41.461]                   {
[13:33:41.461]                     base::local({
[13:33:41.461]                       has_future <- base::requireNamespace("future", 
[13:33:41.461]                         quietly = TRUE)
[13:33:41.461]                       if (has_future) {
[13:33:41.461]                         ns <- base::getNamespace("future")
[13:33:41.461]                         version <- ns[[".package"]][["version"]]
[13:33:41.461]                         if (is.null(version)) 
[13:33:41.461]                           version <- utils::packageVersion("future")
[13:33:41.461]                       }
[13:33:41.461]                       else {
[13:33:41.461]                         version <- NULL
[13:33:41.461]                       }
[13:33:41.461]                       if (!has_future || version < "1.8.0") {
[13:33:41.461]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:41.461]                           "", base::R.version$version.string), 
[13:33:41.461]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:41.461]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:41.461]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:41.461]                             "release", "version")], collapse = " "), 
[13:33:41.461]                           hostname = base::Sys.info()[["nodename"]])
[13:33:41.461]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:41.461]                           info)
[13:33:41.461]                         info <- base::paste(info, collapse = "; ")
[13:33:41.461]                         if (!has_future) {
[13:33:41.461]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:41.461]                             info)
[13:33:41.461]                         }
[13:33:41.461]                         else {
[13:33:41.461]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:41.461]                             info, version)
[13:33:41.461]                         }
[13:33:41.461]                         base::stop(msg)
[13:33:41.461]                       }
[13:33:41.461]                     })
[13:33:41.461]                   }
[13:33:41.461]                   ...future.strategy.old <- future::plan("list")
[13:33:41.461]                   options(future.plan = NULL)
[13:33:41.461]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.461]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:41.461]                 }
[13:33:41.461]                 ...future.workdir <- getwd()
[13:33:41.461]             }
[13:33:41.461]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:41.461]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:41.461]         }
[13:33:41.461]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:41.461]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:41.461]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:41.461]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:41.461]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:41.461]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:41.461]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:41.461]             base::names(...future.oldOptions))
[13:33:41.461]     }
[13:33:41.461]     if (FALSE) {
[13:33:41.461]     }
[13:33:41.461]     else {
[13:33:41.461]         if (TRUE) {
[13:33:41.461]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:41.461]                 open = "w")
[13:33:41.461]         }
[13:33:41.461]         else {
[13:33:41.461]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:41.461]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:41.461]         }
[13:33:41.461]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:41.461]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:41.461]             base::sink(type = "output", split = FALSE)
[13:33:41.461]             base::close(...future.stdout)
[13:33:41.461]         }, add = TRUE)
[13:33:41.461]     }
[13:33:41.461]     ...future.frame <- base::sys.nframe()
[13:33:41.461]     ...future.conditions <- base::list()
[13:33:41.461]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:41.461]     if (FALSE) {
[13:33:41.461]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:41.461]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:41.461]     }
[13:33:41.461]     ...future.result <- base::tryCatch({
[13:33:41.461]         base::withCallingHandlers({
[13:33:41.461]             ...future.value <- base::withVisible(base::local({
[13:33:41.461]                 do.call(function(...) {
[13:33:41.461]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.461]                   if (!identical(...future.globals.maxSize.org, 
[13:33:41.461]                     ...future.globals.maxSize)) {
[13:33:41.461]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.461]                     on.exit(options(oopts), add = TRUE)
[13:33:41.461]                   }
[13:33:41.461]                   {
[13:33:41.461]                     lapply(seq_along(...future.elements_ii), 
[13:33:41.461]                       FUN = function(jj) {
[13:33:41.461]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.461]                         ...future.FUN(...future.X_jj, ...)
[13:33:41.461]                       })
[13:33:41.461]                   }
[13:33:41.461]                 }, args = future.call.arguments)
[13:33:41.461]             }))
[13:33:41.461]             future::FutureResult(value = ...future.value$value, 
[13:33:41.461]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.461]                   ...future.rng), globalenv = if (FALSE) 
[13:33:41.461]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:41.461]                     ...future.globalenv.names))
[13:33:41.461]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:41.461]         }, condition = base::local({
[13:33:41.461]             c <- base::c
[13:33:41.461]             inherits <- base::inherits
[13:33:41.461]             invokeRestart <- base::invokeRestart
[13:33:41.461]             length <- base::length
[13:33:41.461]             list <- base::list
[13:33:41.461]             seq.int <- base::seq.int
[13:33:41.461]             signalCondition <- base::signalCondition
[13:33:41.461]             sys.calls <- base::sys.calls
[13:33:41.461]             `[[` <- base::`[[`
[13:33:41.461]             `+` <- base::`+`
[13:33:41.461]             `<<-` <- base::`<<-`
[13:33:41.461]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:41.461]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:41.461]                   3L)]
[13:33:41.461]             }
[13:33:41.461]             function(cond) {
[13:33:41.461]                 is_error <- inherits(cond, "error")
[13:33:41.461]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:41.461]                   NULL)
[13:33:41.461]                 if (is_error) {
[13:33:41.461]                   sessionInformation <- function() {
[13:33:41.461]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:41.461]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:41.461]                       search = base::search(), system = base::Sys.info())
[13:33:41.461]                   }
[13:33:41.461]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.461]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:41.461]                     cond$call), session = sessionInformation(), 
[13:33:41.461]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:41.461]                   signalCondition(cond)
[13:33:41.461]                 }
[13:33:41.461]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:41.461]                 "immediateCondition"))) {
[13:33:41.461]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:41.461]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.461]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:41.461]                   if (TRUE && !signal) {
[13:33:41.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.461]                     {
[13:33:41.461]                       inherits <- base::inherits
[13:33:41.461]                       invokeRestart <- base::invokeRestart
[13:33:41.461]                       is.null <- base::is.null
[13:33:41.461]                       muffled <- FALSE
[13:33:41.461]                       if (inherits(cond, "message")) {
[13:33:41.461]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.461]                         if (muffled) 
[13:33:41.461]                           invokeRestart("muffleMessage")
[13:33:41.461]                       }
[13:33:41.461]                       else if (inherits(cond, "warning")) {
[13:33:41.461]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.461]                         if (muffled) 
[13:33:41.461]                           invokeRestart("muffleWarning")
[13:33:41.461]                       }
[13:33:41.461]                       else if (inherits(cond, "condition")) {
[13:33:41.461]                         if (!is.null(pattern)) {
[13:33:41.461]                           computeRestarts <- base::computeRestarts
[13:33:41.461]                           grepl <- base::grepl
[13:33:41.461]                           restarts <- computeRestarts(cond)
[13:33:41.461]                           for (restart in restarts) {
[13:33:41.461]                             name <- restart$name
[13:33:41.461]                             if (is.null(name)) 
[13:33:41.461]                               next
[13:33:41.461]                             if (!grepl(pattern, name)) 
[13:33:41.461]                               next
[13:33:41.461]                             invokeRestart(restart)
[13:33:41.461]                             muffled <- TRUE
[13:33:41.461]                             break
[13:33:41.461]                           }
[13:33:41.461]                         }
[13:33:41.461]                       }
[13:33:41.461]                       invisible(muffled)
[13:33:41.461]                     }
[13:33:41.461]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.461]                   }
[13:33:41.461]                 }
[13:33:41.461]                 else {
[13:33:41.461]                   if (TRUE) {
[13:33:41.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.461]                     {
[13:33:41.461]                       inherits <- base::inherits
[13:33:41.461]                       invokeRestart <- base::invokeRestart
[13:33:41.461]                       is.null <- base::is.null
[13:33:41.461]                       muffled <- FALSE
[13:33:41.461]                       if (inherits(cond, "message")) {
[13:33:41.461]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.461]                         if (muffled) 
[13:33:41.461]                           invokeRestart("muffleMessage")
[13:33:41.461]                       }
[13:33:41.461]                       else if (inherits(cond, "warning")) {
[13:33:41.461]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.461]                         if (muffled) 
[13:33:41.461]                           invokeRestart("muffleWarning")
[13:33:41.461]                       }
[13:33:41.461]                       else if (inherits(cond, "condition")) {
[13:33:41.461]                         if (!is.null(pattern)) {
[13:33:41.461]                           computeRestarts <- base::computeRestarts
[13:33:41.461]                           grepl <- base::grepl
[13:33:41.461]                           restarts <- computeRestarts(cond)
[13:33:41.461]                           for (restart in restarts) {
[13:33:41.461]                             name <- restart$name
[13:33:41.461]                             if (is.null(name)) 
[13:33:41.461]                               next
[13:33:41.461]                             if (!grepl(pattern, name)) 
[13:33:41.461]                               next
[13:33:41.461]                             invokeRestart(restart)
[13:33:41.461]                             muffled <- TRUE
[13:33:41.461]                             break
[13:33:41.461]                           }
[13:33:41.461]                         }
[13:33:41.461]                       }
[13:33:41.461]                       invisible(muffled)
[13:33:41.461]                     }
[13:33:41.461]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.461]                   }
[13:33:41.461]                 }
[13:33:41.461]             }
[13:33:41.461]         }))
[13:33:41.461]     }, error = function(ex) {
[13:33:41.461]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:41.461]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.461]                 ...future.rng), started = ...future.startTime, 
[13:33:41.461]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:41.461]             version = "1.8"), class = "FutureResult")
[13:33:41.461]     }, finally = {
[13:33:41.461]         if (!identical(...future.workdir, getwd())) 
[13:33:41.461]             setwd(...future.workdir)
[13:33:41.461]         {
[13:33:41.461]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:41.461]                 ...future.oldOptions$nwarnings <- NULL
[13:33:41.461]             }
[13:33:41.461]             base::options(...future.oldOptions)
[13:33:41.461]             if (.Platform$OS.type == "windows") {
[13:33:41.461]                 old_names <- names(...future.oldEnvVars)
[13:33:41.461]                 envs <- base::Sys.getenv()
[13:33:41.461]                 names <- names(envs)
[13:33:41.461]                 common <- intersect(names, old_names)
[13:33:41.461]                 added <- setdiff(names, old_names)
[13:33:41.461]                 removed <- setdiff(old_names, names)
[13:33:41.461]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:41.461]                   envs[common]]
[13:33:41.461]                 NAMES <- toupper(changed)
[13:33:41.461]                 args <- list()
[13:33:41.461]                 for (kk in seq_along(NAMES)) {
[13:33:41.461]                   name <- changed[[kk]]
[13:33:41.461]                   NAME <- NAMES[[kk]]
[13:33:41.461]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.461]                     next
[13:33:41.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.461]                 }
[13:33:41.461]                 NAMES <- toupper(added)
[13:33:41.461]                 for (kk in seq_along(NAMES)) {
[13:33:41.461]                   name <- added[[kk]]
[13:33:41.461]                   NAME <- NAMES[[kk]]
[13:33:41.461]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.461]                     next
[13:33:41.461]                   args[[name]] <- ""
[13:33:41.461]                 }
[13:33:41.461]                 NAMES <- toupper(removed)
[13:33:41.461]                 for (kk in seq_along(NAMES)) {
[13:33:41.461]                   name <- removed[[kk]]
[13:33:41.461]                   NAME <- NAMES[[kk]]
[13:33:41.461]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.461]                     next
[13:33:41.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.461]                 }
[13:33:41.461]                 if (length(args) > 0) 
[13:33:41.461]                   base::do.call(base::Sys.setenv, args = args)
[13:33:41.461]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:41.461]             }
[13:33:41.461]             else {
[13:33:41.461]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:41.461]             }
[13:33:41.461]             {
[13:33:41.461]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:41.461]                   0L) {
[13:33:41.461]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:41.461]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:41.461]                   base::options(opts)
[13:33:41.461]                 }
[13:33:41.461]                 {
[13:33:41.461]                   {
[13:33:41.461]                     NULL
[13:33:41.461]                     RNGkind("Mersenne-Twister")
[13:33:41.461]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:41.461]                       inherits = FALSE)
[13:33:41.461]                   }
[13:33:41.461]                   options(future.plan = NULL)
[13:33:41.461]                   if (is.na(NA_character_)) 
[13:33:41.461]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.461]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:41.461]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:41.461]                     .init = FALSE)
[13:33:41.461]                 }
[13:33:41.461]             }
[13:33:41.461]         }
[13:33:41.461]     })
[13:33:41.461]     if (TRUE) {
[13:33:41.461]         base::sink(type = "output", split = FALSE)
[13:33:41.461]         if (TRUE) {
[13:33:41.461]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:41.461]         }
[13:33:41.461]         else {
[13:33:41.461]             ...future.result["stdout"] <- base::list(NULL)
[13:33:41.461]         }
[13:33:41.461]         base::close(...future.stdout)
[13:33:41.461]         ...future.stdout <- NULL
[13:33:41.461]     }
[13:33:41.461]     ...future.result$conditions <- ...future.conditions
[13:33:41.461]     ...future.result$finished <- base::Sys.time()
[13:33:41.461]     ...future.result
[13:33:41.461] }
[13:33:41.462] assign_globals() ...
[13:33:41.462] List of 5
[13:33:41.462]  $ ...future.FUN            :function (object, ...)  
[13:33:41.462]  $ future.call.arguments    : list()
[13:33:41.462]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.462]  $ ...future.elements_ii    :List of 3
[13:33:41.462]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.462]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:33:41.462]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.462]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:41.462]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.462]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:33:41.462]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.462]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:33:41.462]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.462]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:33:41.462]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.462]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:33:41.462]  $ ...future.seeds_ii       : NULL
[13:33:41.462]  $ ...future.globals.maxSize: NULL
[13:33:41.462]  - attr(*, "where")=List of 5
[13:33:41.462]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:41.462]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:41.462]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:41.462]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:41.462]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:41.462]  - attr(*, "resolved")= logi FALSE
[13:33:41.462]  - attr(*, "total_size")= num 1240
[13:33:41.462]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.462]  - attr(*, "already-done")= logi TRUE
[13:33:41.471] - copied ‘...future.FUN’ to environment
[13:33:41.471] - copied ‘future.call.arguments’ to environment
[13:33:41.472] - copied ‘...future.elements_ii’ to environment
[13:33:41.472] - copied ‘...future.seeds_ii’ to environment
[13:33:41.472] - copied ‘...future.globals.maxSize’ to environment
[13:33:41.472] assign_globals() ... done
[13:33:41.472] plan(): Setting new future strategy stack:
[13:33:41.472] List of future strategies:
[13:33:41.472] 1. sequential:
[13:33:41.472]    - args: function (..., envir = parent.frame())
[13:33:41.472]    - tweaked: FALSE
[13:33:41.472]    - call: NULL
[13:33:41.472] plan(): nbrOfWorkers() = 1
[13:33:41.474] plan(): Setting new future strategy stack:
[13:33:41.475] List of future strategies:
[13:33:41.475] 1. multisession:
[13:33:41.475]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:33:41.475]    - tweaked: FALSE
[13:33:41.475]    - call: plan(strategy)
[13:33:41.478] plan(): nbrOfWorkers() = 1
[13:33:41.478] SequentialFuture started (and completed)
[13:33:41.478] - Launch lazy future ... done
[13:33:41.478] run() for ‘SequentialFuture’ ... done
[13:33:41.478] Created future:
[13:33:41.478] SequentialFuture:
[13:33:41.478] Label: ‘future_by-1’
[13:33:41.478] Expression:
[13:33:41.478] {
[13:33:41.478]     do.call(function(...) {
[13:33:41.478]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.478]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.478]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.478]             on.exit(options(oopts), add = TRUE)
[13:33:41.478]         }
[13:33:41.478]         {
[13:33:41.478]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.478]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.478]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.478]             })
[13:33:41.478]         }
[13:33:41.478]     }, args = future.call.arguments)
[13:33:41.478] }
[13:33:41.478] Lazy evaluation: FALSE
[13:33:41.478] Asynchronous evaluation: FALSE
[13:33:41.478] Local evaluation: TRUE
[13:33:41.478] Environment: 0x55cb823077d0
[13:33:41.478] Capture standard output: TRUE
[13:33:41.478] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:41.478] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:41.478] Packages: <none>
[13:33:41.478] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:41.478] Resolved: TRUE
[13:33:41.478] Value: 5.37 KiB of class ‘list’
[13:33:41.478] Early signaling: FALSE
[13:33:41.478] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:41.478] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.479] Chunk #1 of 1 ... DONE
[13:33:41.480] Launching 1 futures (chunks) ... DONE
[13:33:41.480] Resolving 1 futures (chunks) ...
[13:33:41.480] resolve() on list ...
[13:33:41.480]  recursive: 0
[13:33:41.480]  length: 1
[13:33:41.480] 
[13:33:41.480] resolved() for ‘SequentialFuture’ ...
[13:33:41.480] - state: ‘finished’
[13:33:41.480] - run: TRUE
[13:33:41.480] - result: ‘FutureResult’
[13:33:41.480] resolved() for ‘SequentialFuture’ ... done
[13:33:41.481] Future #1
[13:33:41.481] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:41.481] - nx: 1
[13:33:41.481] - relay: TRUE
[13:33:41.481] - stdout: TRUE
[13:33:41.481] - signal: TRUE
[13:33:41.481] - resignal: FALSE
[13:33:41.481] - force: TRUE
[13:33:41.481] - relayed: [n=1] FALSE
[13:33:41.481] - queued futures: [n=1] FALSE
[13:33:41.481]  - until=1
[13:33:41.482]  - relaying element #1
[13:33:41.482] - relayed: [n=1] TRUE
[13:33:41.482] - queued futures: [n=1] TRUE
[13:33:41.482] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:41.482]  length: 0 (resolved future 1)
[13:33:41.482] Relaying remaining futures
[13:33:41.482] signalConditionsASAP(NULL, pos=0) ...
[13:33:41.482] - nx: 1
[13:33:41.482] - relay: TRUE
[13:33:41.482] - stdout: TRUE
[13:33:41.482] - signal: TRUE
[13:33:41.483] - resignal: FALSE
[13:33:41.483] - force: TRUE
[13:33:41.483] - relayed: [n=1] TRUE
[13:33:41.483] - queued futures: [n=1] TRUE
 - flush all
[13:33:41.483] - relayed: [n=1] TRUE
[13:33:41.483] - queued futures: [n=1] TRUE
[13:33:41.483] signalConditionsASAP(NULL, pos=0) ... done
[13:33:41.483] resolve() on list ... DONE
[13:33:41.483]  - Number of value chunks collected: 1
[13:33:41.483] Resolving 1 futures (chunks) ... DONE
[13:33:41.483] Reducing values from 1 chunks ...
[13:33:41.484]  - Number of values collected after concatenation: 3
[13:33:41.484]  - Number of values expected: 3
[13:33:41.484] Reducing values from 1 chunks ... DONE
[13:33:41.484] future_lapply() ... DONE
[13:33:41.484] future_by_internal() ... DONE
[13:33:41.485] future_by_internal() ...
Testing with 1 cores ... DONE
Testing with 2 cores ...
- plan('sequential') ...
[13:33:41.485] plan(): Setting new future strategy stack:
[13:33:41.485] List of future strategies:
[13:33:41.485] 1. sequential:
[13:33:41.485]    - args: function (..., envir = parent.frame())
[13:33:41.485]    - tweaked: FALSE
[13:33:41.485]    - call: plan(strategy)
[13:33:41.486] plan(): nbrOfWorkers() = 1
[13:33:41.486] future_by_internal() ...
[13:33:41.486] future_lapply() ...
[13:33:41.487] Number of chunks: 1
[13:33:41.487] getGlobalsAndPackagesXApply() ...
[13:33:41.487]  - future.globals: TRUE
[13:33:41.487] getGlobalsAndPackages() ...
[13:33:41.487] Searching for globals...
[13:33:41.488] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:41.488] Searching for globals ... DONE
[13:33:41.488] Resolving globals: FALSE
[13:33:41.488] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:41.489] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:41.490] - globals: [1] ‘FUN’
[13:33:41.490] 
[13:33:41.490] getGlobalsAndPackages() ... DONE
[13:33:41.490]  - globals found/used: [n=1] ‘FUN’
[13:33:41.490]  - needed namespaces: [n=0] 
[13:33:41.490] Finding globals ... DONE
[13:33:41.490]  - use_args: TRUE
[13:33:41.490]  - Getting '...' globals ...
[13:33:41.491] resolve() on list ...
[13:33:41.491]  recursive: 0
[13:33:41.491]  length: 1
[13:33:41.491]  elements: ‘...’
[13:33:41.491]  length: 0 (resolved future 1)
[13:33:41.491] resolve() on list ... DONE
[13:33:41.491]    - '...' content: [n=0] 
[13:33:41.491] List of 1
[13:33:41.491]  $ ...: list()
[13:33:41.491]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.491]  - attr(*, "where")=List of 1
[13:33:41.491]   ..$ ...:<environment: 0x55cb8259ed20> 
[13:33:41.491]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.491]  - attr(*, "resolved")= logi TRUE
[13:33:41.491]  - attr(*, "total_size")= num NA
[13:33:41.494]  - Getting '...' globals ... DONE
[13:33:41.494] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:41.494] List of 2
[13:33:41.494]  $ ...future.FUN:function (object, ...)  
[13:33:41.494]  $ ...          : list()
[13:33:41.494]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.494]  - attr(*, "where")=List of 2
[13:33:41.494]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:41.494]   ..$ ...          :<environment: 0x55cb8259ed20> 
[13:33:41.494]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.494]  - attr(*, "resolved")= logi FALSE
[13:33:41.494]  - attr(*, "total_size")= num 1240
[13:33:41.497] Packages to be attached in all futures: [n=0] 
[13:33:41.497] getGlobalsAndPackagesXApply() ... DONE
[13:33:41.497] Number of futures (= number of chunks): 1
[13:33:41.497] Launching 1 futures (chunks) ...
[13:33:41.497] Chunk #1 of 1 ...
[13:33:41.497]  - Finding globals in 'X' for chunk #1 ...
[13:33:41.497] getGlobalsAndPackages() ...
[13:33:41.497] Searching for globals...
[13:33:41.498] 
[13:33:41.498] Searching for globals ... DONE
[13:33:41.498] - globals: [0] <none>
[13:33:41.498] getGlobalsAndPackages() ... DONE
[13:33:41.498]    + additional globals found: [n=0] 
[13:33:41.498]    + additional namespaces needed: [n=0] 
[13:33:41.498]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:41.498]  - seeds: <none>
[13:33:41.499]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.499] getGlobalsAndPackages() ...
[13:33:41.499] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.499] Resolving globals: FALSE
[13:33:41.499] Tweak future expression to call with '...' arguments ...
[13:33:41.499] {
[13:33:41.499]     do.call(function(...) {
[13:33:41.499]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.499]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.499]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.499]             on.exit(options(oopts), add = TRUE)
[13:33:41.499]         }
[13:33:41.499]         {
[13:33:41.499]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.499]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.499]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.499]             })
[13:33:41.499]         }
[13:33:41.499]     }, args = future.call.arguments)
[13:33:41.499] }
[13:33:41.499] Tweak future expression to call with '...' arguments ... DONE
[13:33:41.500] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.500] 
[13:33:41.500] getGlobalsAndPackages() ... DONE
[13:33:41.500] run() for ‘Future’ ...
[13:33:41.500] - state: ‘created’
[13:33:41.500] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:33:41.500] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.501] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:41.501]   - Field: ‘label’
[13:33:41.501]   - Field: ‘local’
[13:33:41.501]   - Field: ‘owner’
[13:33:41.501]   - Field: ‘envir’
[13:33:41.501]   - Field: ‘packages’
[13:33:41.501]   - Field: ‘gc’
[13:33:41.501]   - Field: ‘conditions’
[13:33:41.501]   - Field: ‘expr’
[13:33:41.501]   - Field: ‘uuid’
[13:33:41.501]   - Field: ‘seed’
[13:33:41.502]   - Field: ‘version’
[13:33:41.502]   - Field: ‘result’
[13:33:41.502]   - Field: ‘asynchronous’
[13:33:41.502]   - Field: ‘calls’
[13:33:41.502]   - Field: ‘globals’
[13:33:41.502]   - Field: ‘stdout’
[13:33:41.502]   - Field: ‘earlySignal’
[13:33:41.502]   - Field: ‘lazy’
[13:33:41.502]   - Field: ‘state’
[13:33:41.502] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:41.502] - Launch lazy future ...
[13:33:41.503] Packages needed by the future expression (n = 0): <none>
[13:33:41.503] Packages needed by future strategies (n = 0): <none>
[13:33:41.503] {
[13:33:41.503]     {
[13:33:41.503]         {
[13:33:41.503]             ...future.startTime <- base::Sys.time()
[13:33:41.503]             {
[13:33:41.503]                 {
[13:33:41.503]                   {
[13:33:41.503]                     base::local({
[13:33:41.503]                       has_future <- base::requireNamespace("future", 
[13:33:41.503]                         quietly = TRUE)
[13:33:41.503]                       if (has_future) {
[13:33:41.503]                         ns <- base::getNamespace("future")
[13:33:41.503]                         version <- ns[[".package"]][["version"]]
[13:33:41.503]                         if (is.null(version)) 
[13:33:41.503]                           version <- utils::packageVersion("future")
[13:33:41.503]                       }
[13:33:41.503]                       else {
[13:33:41.503]                         version <- NULL
[13:33:41.503]                       }
[13:33:41.503]                       if (!has_future || version < "1.8.0") {
[13:33:41.503]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:41.503]                           "", base::R.version$version.string), 
[13:33:41.503]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:41.503]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:41.503]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:41.503]                             "release", "version")], collapse = " "), 
[13:33:41.503]                           hostname = base::Sys.info()[["nodename"]])
[13:33:41.503]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:41.503]                           info)
[13:33:41.503]                         info <- base::paste(info, collapse = "; ")
[13:33:41.503]                         if (!has_future) {
[13:33:41.503]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:41.503]                             info)
[13:33:41.503]                         }
[13:33:41.503]                         else {
[13:33:41.503]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:41.503]                             info, version)
[13:33:41.503]                         }
[13:33:41.503]                         base::stop(msg)
[13:33:41.503]                       }
[13:33:41.503]                     })
[13:33:41.503]                   }
[13:33:41.503]                   ...future.strategy.old <- future::plan("list")
[13:33:41.503]                   options(future.plan = NULL)
[13:33:41.503]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.503]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:41.503]                 }
[13:33:41.503]                 ...future.workdir <- getwd()
[13:33:41.503]             }
[13:33:41.503]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:41.503]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:41.503]         }
[13:33:41.503]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:41.503]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:41.503]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:41.503]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:41.503]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:41.503]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:41.503]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:41.503]             base::names(...future.oldOptions))
[13:33:41.503]     }
[13:33:41.503]     if (FALSE) {
[13:33:41.503]     }
[13:33:41.503]     else {
[13:33:41.503]         if (TRUE) {
[13:33:41.503]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:41.503]                 open = "w")
[13:33:41.503]         }
[13:33:41.503]         else {
[13:33:41.503]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:41.503]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:41.503]         }
[13:33:41.503]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:41.503]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:41.503]             base::sink(type = "output", split = FALSE)
[13:33:41.503]             base::close(...future.stdout)
[13:33:41.503]         }, add = TRUE)
[13:33:41.503]     }
[13:33:41.503]     ...future.frame <- base::sys.nframe()
[13:33:41.503]     ...future.conditions <- base::list()
[13:33:41.503]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:41.503]     if (FALSE) {
[13:33:41.503]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:41.503]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:41.503]     }
[13:33:41.503]     ...future.result <- base::tryCatch({
[13:33:41.503]         base::withCallingHandlers({
[13:33:41.503]             ...future.value <- base::withVisible(base::local({
[13:33:41.503]                 do.call(function(...) {
[13:33:41.503]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.503]                   if (!identical(...future.globals.maxSize.org, 
[13:33:41.503]                     ...future.globals.maxSize)) {
[13:33:41.503]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.503]                     on.exit(options(oopts), add = TRUE)
[13:33:41.503]                   }
[13:33:41.503]                   {
[13:33:41.503]                     lapply(seq_along(...future.elements_ii), 
[13:33:41.503]                       FUN = function(jj) {
[13:33:41.503]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.503]                         ...future.FUN(...future.X_jj, ...)
[13:33:41.503]                       })
[13:33:41.503]                   }
[13:33:41.503]                 }, args = future.call.arguments)
[13:33:41.503]             }))
[13:33:41.503]             future::FutureResult(value = ...future.value$value, 
[13:33:41.503]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.503]                   ...future.rng), globalenv = if (FALSE) 
[13:33:41.503]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:41.503]                     ...future.globalenv.names))
[13:33:41.503]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:41.503]         }, condition = base::local({
[13:33:41.503]             c <- base::c
[13:33:41.503]             inherits <- base::inherits
[13:33:41.503]             invokeRestart <- base::invokeRestart
[13:33:41.503]             length <- base::length
[13:33:41.503]             list <- base::list
[13:33:41.503]             seq.int <- base::seq.int
[13:33:41.503]             signalCondition <- base::signalCondition
[13:33:41.503]             sys.calls <- base::sys.calls
[13:33:41.503]             `[[` <- base::`[[`
[13:33:41.503]             `+` <- base::`+`
[13:33:41.503]             `<<-` <- base::`<<-`
[13:33:41.503]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:41.503]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:41.503]                   3L)]
[13:33:41.503]             }
[13:33:41.503]             function(cond) {
[13:33:41.503]                 is_error <- inherits(cond, "error")
[13:33:41.503]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:41.503]                   NULL)
[13:33:41.503]                 if (is_error) {
[13:33:41.503]                   sessionInformation <- function() {
[13:33:41.503]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:41.503]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:41.503]                       search = base::search(), system = base::Sys.info())
[13:33:41.503]                   }
[13:33:41.503]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.503]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:41.503]                     cond$call), session = sessionInformation(), 
[13:33:41.503]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:41.503]                   signalCondition(cond)
[13:33:41.503]                 }
[13:33:41.503]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:41.503]                 "immediateCondition"))) {
[13:33:41.503]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:41.503]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.503]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:41.503]                   if (TRUE && !signal) {
[13:33:41.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.503]                     {
[13:33:41.503]                       inherits <- base::inherits
[13:33:41.503]                       invokeRestart <- base::invokeRestart
[13:33:41.503]                       is.null <- base::is.null
[13:33:41.503]                       muffled <- FALSE
[13:33:41.503]                       if (inherits(cond, "message")) {
[13:33:41.503]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.503]                         if (muffled) 
[13:33:41.503]                           invokeRestart("muffleMessage")
[13:33:41.503]                       }
[13:33:41.503]                       else if (inherits(cond, "warning")) {
[13:33:41.503]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.503]                         if (muffled) 
[13:33:41.503]                           invokeRestart("muffleWarning")
[13:33:41.503]                       }
[13:33:41.503]                       else if (inherits(cond, "condition")) {
[13:33:41.503]                         if (!is.null(pattern)) {
[13:33:41.503]                           computeRestarts <- base::computeRestarts
[13:33:41.503]                           grepl <- base::grepl
[13:33:41.503]                           restarts <- computeRestarts(cond)
[13:33:41.503]                           for (restart in restarts) {
[13:33:41.503]                             name <- restart$name
[13:33:41.503]                             if (is.null(name)) 
[13:33:41.503]                               next
[13:33:41.503]                             if (!grepl(pattern, name)) 
[13:33:41.503]                               next
[13:33:41.503]                             invokeRestart(restart)
[13:33:41.503]                             muffled <- TRUE
[13:33:41.503]                             break
[13:33:41.503]                           }
[13:33:41.503]                         }
[13:33:41.503]                       }
[13:33:41.503]                       invisible(muffled)
[13:33:41.503]                     }
[13:33:41.503]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.503]                   }
[13:33:41.503]                 }
[13:33:41.503]                 else {
[13:33:41.503]                   if (TRUE) {
[13:33:41.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.503]                     {
[13:33:41.503]                       inherits <- base::inherits
[13:33:41.503]                       invokeRestart <- base::invokeRestart
[13:33:41.503]                       is.null <- base::is.null
[13:33:41.503]                       muffled <- FALSE
[13:33:41.503]                       if (inherits(cond, "message")) {
[13:33:41.503]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.503]                         if (muffled) 
[13:33:41.503]                           invokeRestart("muffleMessage")
[13:33:41.503]                       }
[13:33:41.503]                       else if (inherits(cond, "warning")) {
[13:33:41.503]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.503]                         if (muffled) 
[13:33:41.503]                           invokeRestart("muffleWarning")
[13:33:41.503]                       }
[13:33:41.503]                       else if (inherits(cond, "condition")) {
[13:33:41.503]                         if (!is.null(pattern)) {
[13:33:41.503]                           computeRestarts <- base::computeRestarts
[13:33:41.503]                           grepl <- base::grepl
[13:33:41.503]                           restarts <- computeRestarts(cond)
[13:33:41.503]                           for (restart in restarts) {
[13:33:41.503]                             name <- restart$name
[13:33:41.503]                             if (is.null(name)) 
[13:33:41.503]                               next
[13:33:41.503]                             if (!grepl(pattern, name)) 
[13:33:41.503]                               next
[13:33:41.503]                             invokeRestart(restart)
[13:33:41.503]                             muffled <- TRUE
[13:33:41.503]                             break
[13:33:41.503]                           }
[13:33:41.503]                         }
[13:33:41.503]                       }
[13:33:41.503]                       invisible(muffled)
[13:33:41.503]                     }
[13:33:41.503]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.503]                   }
[13:33:41.503]                 }
[13:33:41.503]             }
[13:33:41.503]         }))
[13:33:41.503]     }, error = function(ex) {
[13:33:41.503]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:41.503]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.503]                 ...future.rng), started = ...future.startTime, 
[13:33:41.503]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:41.503]             version = "1.8"), class = "FutureResult")
[13:33:41.503]     }, finally = {
[13:33:41.503]         if (!identical(...future.workdir, getwd())) 
[13:33:41.503]             setwd(...future.workdir)
[13:33:41.503]         {
[13:33:41.503]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:41.503]                 ...future.oldOptions$nwarnings <- NULL
[13:33:41.503]             }
[13:33:41.503]             base::options(...future.oldOptions)
[13:33:41.503]             if (.Platform$OS.type == "windows") {
[13:33:41.503]                 old_names <- names(...future.oldEnvVars)
[13:33:41.503]                 envs <- base::Sys.getenv()
[13:33:41.503]                 names <- names(envs)
[13:33:41.503]                 common <- intersect(names, old_names)
[13:33:41.503]                 added <- setdiff(names, old_names)
[13:33:41.503]                 removed <- setdiff(old_names, names)
[13:33:41.503]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:41.503]                   envs[common]]
[13:33:41.503]                 NAMES <- toupper(changed)
[13:33:41.503]                 args <- list()
[13:33:41.503]                 for (kk in seq_along(NAMES)) {
[13:33:41.503]                   name <- changed[[kk]]
[13:33:41.503]                   NAME <- NAMES[[kk]]
[13:33:41.503]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.503]                     next
[13:33:41.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.503]                 }
[13:33:41.503]                 NAMES <- toupper(added)
[13:33:41.503]                 for (kk in seq_along(NAMES)) {
[13:33:41.503]                   name <- added[[kk]]
[13:33:41.503]                   NAME <- NAMES[[kk]]
[13:33:41.503]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.503]                     next
[13:33:41.503]                   args[[name]] <- ""
[13:33:41.503]                 }
[13:33:41.503]                 NAMES <- toupper(removed)
[13:33:41.503]                 for (kk in seq_along(NAMES)) {
[13:33:41.503]                   name <- removed[[kk]]
[13:33:41.503]                   NAME <- NAMES[[kk]]
[13:33:41.503]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.503]                     next
[13:33:41.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.503]                 }
[13:33:41.503]                 if (length(args) > 0) 
[13:33:41.503]                   base::do.call(base::Sys.setenv, args = args)
[13:33:41.503]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:41.503]             }
[13:33:41.503]             else {
[13:33:41.503]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:41.503]             }
[13:33:41.503]             {
[13:33:41.503]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:41.503]                   0L) {
[13:33:41.503]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:41.503]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:41.503]                   base::options(opts)
[13:33:41.503]                 }
[13:33:41.503]                 {
[13:33:41.503]                   {
[13:33:41.503]                     NULL
[13:33:41.503]                     RNGkind("Mersenne-Twister")
[13:33:41.503]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:41.503]                       inherits = FALSE)
[13:33:41.503]                   }
[13:33:41.503]                   options(future.plan = NULL)
[13:33:41.503]                   if (is.na(NA_character_)) 
[13:33:41.503]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.503]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:41.503]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:41.503]                     .init = FALSE)
[13:33:41.503]                 }
[13:33:41.503]             }
[13:33:41.503]         }
[13:33:41.503]     })
[13:33:41.503]     if (TRUE) {
[13:33:41.503]         base::sink(type = "output", split = FALSE)
[13:33:41.503]         if (TRUE) {
[13:33:41.503]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:41.503]         }
[13:33:41.503]         else {
[13:33:41.503]             ...future.result["stdout"] <- base::list(NULL)
[13:33:41.503]         }
[13:33:41.503]         base::close(...future.stdout)
[13:33:41.503]         ...future.stdout <- NULL
[13:33:41.503]     }
[13:33:41.503]     ...future.result$conditions <- ...future.conditions
[13:33:41.503]     ...future.result$finished <- base::Sys.time()
[13:33:41.503]     ...future.result
[13:33:41.503] }
[13:33:41.505] assign_globals() ...
[13:33:41.505] List of 5
[13:33:41.505]  $ ...future.FUN            :function (object, ...)  
[13:33:41.505]  $ future.call.arguments    : list()
[13:33:41.505]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.505]  $ ...future.elements_ii    :List of 3
[13:33:41.505]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:33:41.505]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:33:41.505]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.505]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:33:41.505]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:33:41.505]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.505]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:33:41.505]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:33:41.505]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.505]  $ ...future.seeds_ii       : NULL
[13:33:41.505]  $ ...future.globals.maxSize: NULL
[13:33:41.505]  - attr(*, "where")=List of 5
[13:33:41.505]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:41.505]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:41.505]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:41.505]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:41.505]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:41.505]  - attr(*, "resolved")= logi FALSE
[13:33:41.505]  - attr(*, "total_size")= num 1240
[13:33:41.505]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.505]  - attr(*, "already-done")= logi TRUE
[13:33:41.513] - copied ‘...future.FUN’ to environment
[13:33:41.513] - copied ‘future.call.arguments’ to environment
[13:33:41.513] - copied ‘...future.elements_ii’ to environment
[13:33:41.513] - copied ‘...future.seeds_ii’ to environment
[13:33:41.513] - copied ‘...future.globals.maxSize’ to environment
[13:33:41.513] assign_globals() ... done
[13:33:41.513] plan(): Setting new future strategy stack:
[13:33:41.513] List of future strategies:
[13:33:41.513] 1. sequential:
[13:33:41.513]    - args: function (..., envir = parent.frame())
[13:33:41.513]    - tweaked: FALSE
[13:33:41.513]    - call: NULL
[13:33:41.514] plan(): nbrOfWorkers() = 1
[13:33:41.515] plan(): Setting new future strategy stack:
[13:33:41.516] List of future strategies:
[13:33:41.516] 1. sequential:
[13:33:41.516]    - args: function (..., envir = parent.frame())
[13:33:41.516]    - tweaked: FALSE
[13:33:41.516]    - call: plan(strategy)
[13:33:41.516] plan(): nbrOfWorkers() = 1
[13:33:41.516] SequentialFuture started (and completed)
[13:33:41.516] - Launch lazy future ... done
[13:33:41.516] run() for ‘SequentialFuture’ ... done
[13:33:41.516] Created future:
[13:33:41.516] SequentialFuture:
[13:33:41.516] Label: ‘future_by-1’
[13:33:41.516] Expression:
[13:33:41.516] {
[13:33:41.516]     do.call(function(...) {
[13:33:41.516]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.516]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.516]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.516]             on.exit(options(oopts), add = TRUE)
[13:33:41.516]         }
[13:33:41.516]         {
[13:33:41.516]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.516]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.516]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.516]             })
[13:33:41.516]         }
[13:33:41.516]     }, args = future.call.arguments)
[13:33:41.516] }
[13:33:41.516] Lazy evaluation: FALSE
[13:33:41.516] Asynchronous evaluation: FALSE
[13:33:41.516] Local evaluation: TRUE
[13:33:41.516] Environment: R_GlobalEnv
[13:33:41.516] Capture standard output: TRUE
[13:33:41.516] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:41.516] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:41.516] Packages: <none>
[13:33:41.516] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:41.516] Resolved: TRUE
[13:33:41.516] Value: 4.62 KiB of class ‘list’
[13:33:41.516] Early signaling: FALSE
[13:33:41.516] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:41.516] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.517] Chunk #1 of 1 ... DONE
[13:33:41.517] Launching 1 futures (chunks) ... DONE
[13:33:41.518] Resolving 1 futures (chunks) ...
[13:33:41.518] resolve() on list ...
[13:33:41.518]  recursive: 0
[13:33:41.518]  length: 1
[13:33:41.518] 
[13:33:41.518] resolved() for ‘SequentialFuture’ ...
[13:33:41.518] - state: ‘finished’
[13:33:41.518] - run: TRUE
[13:33:41.518] - result: ‘FutureResult’
[13:33:41.518] resolved() for ‘SequentialFuture’ ... done
[13:33:41.519] Future #1
[13:33:41.519] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:41.519] - nx: 1
[13:33:41.519] - relay: TRUE
[13:33:41.519] - stdout: TRUE
[13:33:41.519] - signal: TRUE
[13:33:41.519] - resignal: FALSE
[13:33:41.519] - force: TRUE
[13:33:41.519] - relayed: [n=1] FALSE
[13:33:41.519] - queued futures: [n=1] FALSE
[13:33:41.519]  - until=1
[13:33:41.519]  - relaying element #1
[13:33:41.520] - relayed: [n=1] TRUE
[13:33:41.520] - queued futures: [n=1] TRUE
[13:33:41.520] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:41.520]  length: 0 (resolved future 1)
[13:33:41.520] Relaying remaining futures
[13:33:41.520] signalConditionsASAP(NULL, pos=0) ...
[13:33:41.520] - nx: 1
[13:33:41.520] - relay: TRUE
[13:33:41.520] - stdout: TRUE
[13:33:41.520] - signal: TRUE
[13:33:41.520] - resignal: FALSE
[13:33:41.521] - force: TRUE
[13:33:41.521] - relayed: [n=1] TRUE
[13:33:41.521] - queued futures: [n=1] TRUE
 - flush all
[13:33:41.521] - relayed: [n=1] TRUE
[13:33:41.521] - queued futures: [n=1] TRUE
[13:33:41.521] signalConditionsASAP(NULL, pos=0) ... done
[13:33:41.521] resolve() on list ... DONE
[13:33:41.521]  - Number of value chunks collected: 1
[13:33:41.521] Resolving 1 futures (chunks) ... DONE
[13:33:41.521] Reducing values from 1 chunks ...
[13:33:41.521]  - Number of values collected after concatenation: 3
[13:33:41.521]  - Number of values expected: 3
[13:33:41.522] Reducing values from 1 chunks ... DONE
[13:33:41.522] future_lapply() ... DONE
[13:33:41.522] future_by_internal() ... DONE
[13:33:41.522] future_by_internal() ...
[13:33:41.522] future_lapply() ...
[13:33:41.523] Number of chunks: 1
[13:33:41.523] getGlobalsAndPackagesXApply() ...
[13:33:41.523]  - future.globals: TRUE
[13:33:41.523] getGlobalsAndPackages() ...
[13:33:41.523] Searching for globals...
[13:33:41.524] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:41.524] Searching for globals ... DONE
[13:33:41.524] Resolving globals: FALSE
[13:33:41.525] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:41.525] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:41.525] - globals: [1] ‘FUN’
[13:33:41.525] 
[13:33:41.525] getGlobalsAndPackages() ... DONE
[13:33:41.525]  - globals found/used: [n=1] ‘FUN’
[13:33:41.525]  - needed namespaces: [n=0] 
[13:33:41.525] Finding globals ... DONE
[13:33:41.525]  - use_args: TRUE
[13:33:41.526]  - Getting '...' globals ...
[13:33:41.526] resolve() on list ...
[13:33:41.526]  recursive: 0
[13:33:41.526]  length: 1
[13:33:41.526]  elements: ‘...’
[13:33:41.526]  length: 0 (resolved future 1)
[13:33:41.526] resolve() on list ... DONE
[13:33:41.526]    - '...' content: [n=1] ‘digits’
[13:33:41.527] List of 1
[13:33:41.527]  $ ...:List of 1
[13:33:41.527]   ..$ digits: int 2
[13:33:41.527]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.527]  - attr(*, "where")=List of 1
[13:33:41.527]   ..$ ...:<environment: 0x55cb822c9180> 
[13:33:41.527]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.527]  - attr(*, "resolved")= logi TRUE
[13:33:41.527]  - attr(*, "total_size")= num NA
[13:33:41.531]  - Getting '...' globals ... DONE
[13:33:41.531] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:41.531] List of 2
[13:33:41.531]  $ ...future.FUN:function (object, ...)  
[13:33:41.531]  $ ...          :List of 1
[13:33:41.531]   ..$ digits: int 2
[13:33:41.531]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.531]  - attr(*, "where")=List of 2
[13:33:41.531]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:41.531]   ..$ ...          :<environment: 0x55cb822c9180> 
[13:33:41.531]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.531]  - attr(*, "resolved")= logi FALSE
[13:33:41.531]  - attr(*, "total_size")= num 1296
[13:33:41.534] Packages to be attached in all futures: [n=0] 
[13:33:41.534] getGlobalsAndPackagesXApply() ... DONE
[13:33:41.534] Number of futures (= number of chunks): 1
[13:33:41.535] Launching 1 futures (chunks) ...
[13:33:41.535] Chunk #1 of 1 ...
[13:33:41.535]  - Finding globals in 'X' for chunk #1 ...
[13:33:41.535] getGlobalsAndPackages() ...
[13:33:41.535] Searching for globals...
[13:33:41.535] 
[13:33:41.535] Searching for globals ... DONE
[13:33:41.535] - globals: [0] <none>
[13:33:41.535] getGlobalsAndPackages() ... DONE
[13:33:41.536]    + additional globals found: [n=0] 
[13:33:41.536]    + additional namespaces needed: [n=0] 
[13:33:41.536]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:41.536]  - seeds: <none>
[13:33:41.536]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.536] getGlobalsAndPackages() ...
[13:33:41.536] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.536] Resolving globals: FALSE
[13:33:41.536] Tweak future expression to call with '...' arguments ...
[13:33:41.536] {
[13:33:41.536]     do.call(function(...) {
[13:33:41.536]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.536]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.536]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.536]             on.exit(options(oopts), add = TRUE)
[13:33:41.536]         }
[13:33:41.536]         {
[13:33:41.536]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.536]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.536]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.536]             })
[13:33:41.536]         }
[13:33:41.536]     }, args = future.call.arguments)
[13:33:41.536] }
[13:33:41.537] Tweak future expression to call with '...' arguments ... DONE
[13:33:41.537] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.537] 
[13:33:41.537] getGlobalsAndPackages() ... DONE
[13:33:41.537] run() for ‘Future’ ...
[13:33:41.538] - state: ‘created’
[13:33:41.538] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:33:41.538] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.538] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:41.538]   - Field: ‘label’
[13:33:41.538]   - Field: ‘local’
[13:33:41.538]   - Field: ‘owner’
[13:33:41.539]   - Field: ‘envir’
[13:33:41.539]   - Field: ‘packages’
[13:33:41.539]   - Field: ‘gc’
[13:33:41.539]   - Field: ‘conditions’
[13:33:41.539]   - Field: ‘expr’
[13:33:41.539]   - Field: ‘uuid’
[13:33:41.539]   - Field: ‘seed’
[13:33:41.539]   - Field: ‘version’
[13:33:41.539]   - Field: ‘result’
[13:33:41.539]   - Field: ‘asynchronous’
[13:33:41.539]   - Field: ‘calls’
[13:33:41.540]   - Field: ‘globals’
[13:33:41.540]   - Field: ‘stdout’
[13:33:41.540]   - Field: ‘earlySignal’
[13:33:41.540]   - Field: ‘lazy’
[13:33:41.540]   - Field: ‘state’
[13:33:41.540] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:41.540] - Launch lazy future ...
[13:33:41.540] Packages needed by the future expression (n = 0): <none>
[13:33:41.540] Packages needed by future strategies (n = 0): <none>
[13:33:41.541] {
[13:33:41.541]     {
[13:33:41.541]         {
[13:33:41.541]             ...future.startTime <- base::Sys.time()
[13:33:41.541]             {
[13:33:41.541]                 {
[13:33:41.541]                   {
[13:33:41.541]                     base::local({
[13:33:41.541]                       has_future <- base::requireNamespace("future", 
[13:33:41.541]                         quietly = TRUE)
[13:33:41.541]                       if (has_future) {
[13:33:41.541]                         ns <- base::getNamespace("future")
[13:33:41.541]                         version <- ns[[".package"]][["version"]]
[13:33:41.541]                         if (is.null(version)) 
[13:33:41.541]                           version <- utils::packageVersion("future")
[13:33:41.541]                       }
[13:33:41.541]                       else {
[13:33:41.541]                         version <- NULL
[13:33:41.541]                       }
[13:33:41.541]                       if (!has_future || version < "1.8.0") {
[13:33:41.541]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:41.541]                           "", base::R.version$version.string), 
[13:33:41.541]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:41.541]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:41.541]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:41.541]                             "release", "version")], collapse = " "), 
[13:33:41.541]                           hostname = base::Sys.info()[["nodename"]])
[13:33:41.541]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:41.541]                           info)
[13:33:41.541]                         info <- base::paste(info, collapse = "; ")
[13:33:41.541]                         if (!has_future) {
[13:33:41.541]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:41.541]                             info)
[13:33:41.541]                         }
[13:33:41.541]                         else {
[13:33:41.541]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:41.541]                             info, version)
[13:33:41.541]                         }
[13:33:41.541]                         base::stop(msg)
[13:33:41.541]                       }
[13:33:41.541]                     })
[13:33:41.541]                   }
[13:33:41.541]                   ...future.strategy.old <- future::plan("list")
[13:33:41.541]                   options(future.plan = NULL)
[13:33:41.541]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.541]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:41.541]                 }
[13:33:41.541]                 ...future.workdir <- getwd()
[13:33:41.541]             }
[13:33:41.541]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:41.541]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:41.541]         }
[13:33:41.541]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:41.541]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:41.541]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:41.541]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:41.541]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:41.541]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:41.541]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:41.541]             base::names(...future.oldOptions))
[13:33:41.541]     }
[13:33:41.541]     if (FALSE) {
[13:33:41.541]     }
[13:33:41.541]     else {
[13:33:41.541]         if (TRUE) {
[13:33:41.541]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:41.541]                 open = "w")
[13:33:41.541]         }
[13:33:41.541]         else {
[13:33:41.541]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:41.541]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:41.541]         }
[13:33:41.541]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:41.541]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:41.541]             base::sink(type = "output", split = FALSE)
[13:33:41.541]             base::close(...future.stdout)
[13:33:41.541]         }, add = TRUE)
[13:33:41.541]     }
[13:33:41.541]     ...future.frame <- base::sys.nframe()
[13:33:41.541]     ...future.conditions <- base::list()
[13:33:41.541]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:41.541]     if (FALSE) {
[13:33:41.541]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:41.541]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:41.541]     }
[13:33:41.541]     ...future.result <- base::tryCatch({
[13:33:41.541]         base::withCallingHandlers({
[13:33:41.541]             ...future.value <- base::withVisible(base::local({
[13:33:41.541]                 do.call(function(...) {
[13:33:41.541]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.541]                   if (!identical(...future.globals.maxSize.org, 
[13:33:41.541]                     ...future.globals.maxSize)) {
[13:33:41.541]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.541]                     on.exit(options(oopts), add = TRUE)
[13:33:41.541]                   }
[13:33:41.541]                   {
[13:33:41.541]                     lapply(seq_along(...future.elements_ii), 
[13:33:41.541]                       FUN = function(jj) {
[13:33:41.541]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.541]                         ...future.FUN(...future.X_jj, ...)
[13:33:41.541]                       })
[13:33:41.541]                   }
[13:33:41.541]                 }, args = future.call.arguments)
[13:33:41.541]             }))
[13:33:41.541]             future::FutureResult(value = ...future.value$value, 
[13:33:41.541]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.541]                   ...future.rng), globalenv = if (FALSE) 
[13:33:41.541]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:41.541]                     ...future.globalenv.names))
[13:33:41.541]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:41.541]         }, condition = base::local({
[13:33:41.541]             c <- base::c
[13:33:41.541]             inherits <- base::inherits
[13:33:41.541]             invokeRestart <- base::invokeRestart
[13:33:41.541]             length <- base::length
[13:33:41.541]             list <- base::list
[13:33:41.541]             seq.int <- base::seq.int
[13:33:41.541]             signalCondition <- base::signalCondition
[13:33:41.541]             sys.calls <- base::sys.calls
[13:33:41.541]             `[[` <- base::`[[`
[13:33:41.541]             `+` <- base::`+`
[13:33:41.541]             `<<-` <- base::`<<-`
[13:33:41.541]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:41.541]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:41.541]                   3L)]
[13:33:41.541]             }
[13:33:41.541]             function(cond) {
[13:33:41.541]                 is_error <- inherits(cond, "error")
[13:33:41.541]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:41.541]                   NULL)
[13:33:41.541]                 if (is_error) {
[13:33:41.541]                   sessionInformation <- function() {
[13:33:41.541]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:41.541]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:41.541]                       search = base::search(), system = base::Sys.info())
[13:33:41.541]                   }
[13:33:41.541]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.541]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:41.541]                     cond$call), session = sessionInformation(), 
[13:33:41.541]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:41.541]                   signalCondition(cond)
[13:33:41.541]                 }
[13:33:41.541]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:41.541]                 "immediateCondition"))) {
[13:33:41.541]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:41.541]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.541]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:41.541]                   if (TRUE && !signal) {
[13:33:41.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.541]                     {
[13:33:41.541]                       inherits <- base::inherits
[13:33:41.541]                       invokeRestart <- base::invokeRestart
[13:33:41.541]                       is.null <- base::is.null
[13:33:41.541]                       muffled <- FALSE
[13:33:41.541]                       if (inherits(cond, "message")) {
[13:33:41.541]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.541]                         if (muffled) 
[13:33:41.541]                           invokeRestart("muffleMessage")
[13:33:41.541]                       }
[13:33:41.541]                       else if (inherits(cond, "warning")) {
[13:33:41.541]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.541]                         if (muffled) 
[13:33:41.541]                           invokeRestart("muffleWarning")
[13:33:41.541]                       }
[13:33:41.541]                       else if (inherits(cond, "condition")) {
[13:33:41.541]                         if (!is.null(pattern)) {
[13:33:41.541]                           computeRestarts <- base::computeRestarts
[13:33:41.541]                           grepl <- base::grepl
[13:33:41.541]                           restarts <- computeRestarts(cond)
[13:33:41.541]                           for (restart in restarts) {
[13:33:41.541]                             name <- restart$name
[13:33:41.541]                             if (is.null(name)) 
[13:33:41.541]                               next
[13:33:41.541]                             if (!grepl(pattern, name)) 
[13:33:41.541]                               next
[13:33:41.541]                             invokeRestart(restart)
[13:33:41.541]                             muffled <- TRUE
[13:33:41.541]                             break
[13:33:41.541]                           }
[13:33:41.541]                         }
[13:33:41.541]                       }
[13:33:41.541]                       invisible(muffled)
[13:33:41.541]                     }
[13:33:41.541]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.541]                   }
[13:33:41.541]                 }
[13:33:41.541]                 else {
[13:33:41.541]                   if (TRUE) {
[13:33:41.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.541]                     {
[13:33:41.541]                       inherits <- base::inherits
[13:33:41.541]                       invokeRestart <- base::invokeRestart
[13:33:41.541]                       is.null <- base::is.null
[13:33:41.541]                       muffled <- FALSE
[13:33:41.541]                       if (inherits(cond, "message")) {
[13:33:41.541]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.541]                         if (muffled) 
[13:33:41.541]                           invokeRestart("muffleMessage")
[13:33:41.541]                       }
[13:33:41.541]                       else if (inherits(cond, "warning")) {
[13:33:41.541]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.541]                         if (muffled) 
[13:33:41.541]                           invokeRestart("muffleWarning")
[13:33:41.541]                       }
[13:33:41.541]                       else if (inherits(cond, "condition")) {
[13:33:41.541]                         if (!is.null(pattern)) {
[13:33:41.541]                           computeRestarts <- base::computeRestarts
[13:33:41.541]                           grepl <- base::grepl
[13:33:41.541]                           restarts <- computeRestarts(cond)
[13:33:41.541]                           for (restart in restarts) {
[13:33:41.541]                             name <- restart$name
[13:33:41.541]                             if (is.null(name)) 
[13:33:41.541]                               next
[13:33:41.541]                             if (!grepl(pattern, name)) 
[13:33:41.541]                               next
[13:33:41.541]                             invokeRestart(restart)
[13:33:41.541]                             muffled <- TRUE
[13:33:41.541]                             break
[13:33:41.541]                           }
[13:33:41.541]                         }
[13:33:41.541]                       }
[13:33:41.541]                       invisible(muffled)
[13:33:41.541]                     }
[13:33:41.541]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.541]                   }
[13:33:41.541]                 }
[13:33:41.541]             }
[13:33:41.541]         }))
[13:33:41.541]     }, error = function(ex) {
[13:33:41.541]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:41.541]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.541]                 ...future.rng), started = ...future.startTime, 
[13:33:41.541]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:41.541]             version = "1.8"), class = "FutureResult")
[13:33:41.541]     }, finally = {
[13:33:41.541]         if (!identical(...future.workdir, getwd())) 
[13:33:41.541]             setwd(...future.workdir)
[13:33:41.541]         {
[13:33:41.541]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:41.541]                 ...future.oldOptions$nwarnings <- NULL
[13:33:41.541]             }
[13:33:41.541]             base::options(...future.oldOptions)
[13:33:41.541]             if (.Platform$OS.type == "windows") {
[13:33:41.541]                 old_names <- names(...future.oldEnvVars)
[13:33:41.541]                 envs <- base::Sys.getenv()
[13:33:41.541]                 names <- names(envs)
[13:33:41.541]                 common <- intersect(names, old_names)
[13:33:41.541]                 added <- setdiff(names, old_names)
[13:33:41.541]                 removed <- setdiff(old_names, names)
[13:33:41.541]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:41.541]                   envs[common]]
[13:33:41.541]                 NAMES <- toupper(changed)
[13:33:41.541]                 args <- list()
[13:33:41.541]                 for (kk in seq_along(NAMES)) {
[13:33:41.541]                   name <- changed[[kk]]
[13:33:41.541]                   NAME <- NAMES[[kk]]
[13:33:41.541]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.541]                     next
[13:33:41.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.541]                 }
[13:33:41.541]                 NAMES <- toupper(added)
[13:33:41.541]                 for (kk in seq_along(NAMES)) {
[13:33:41.541]                   name <- added[[kk]]
[13:33:41.541]                   NAME <- NAMES[[kk]]
[13:33:41.541]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.541]                     next
[13:33:41.541]                   args[[name]] <- ""
[13:33:41.541]                 }
[13:33:41.541]                 NAMES <- toupper(removed)
[13:33:41.541]                 for (kk in seq_along(NAMES)) {
[13:33:41.541]                   name <- removed[[kk]]
[13:33:41.541]                   NAME <- NAMES[[kk]]
[13:33:41.541]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.541]                     next
[13:33:41.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.541]                 }
[13:33:41.541]                 if (length(args) > 0) 
[13:33:41.541]                   base::do.call(base::Sys.setenv, args = args)
[13:33:41.541]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:41.541]             }
[13:33:41.541]             else {
[13:33:41.541]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:41.541]             }
[13:33:41.541]             {
[13:33:41.541]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:41.541]                   0L) {
[13:33:41.541]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:41.541]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:41.541]                   base::options(opts)
[13:33:41.541]                 }
[13:33:41.541]                 {
[13:33:41.541]                   {
[13:33:41.541]                     NULL
[13:33:41.541]                     RNGkind("Mersenne-Twister")
[13:33:41.541]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:41.541]                       inherits = FALSE)
[13:33:41.541]                   }
[13:33:41.541]                   options(future.plan = NULL)
[13:33:41.541]                   if (is.na(NA_character_)) 
[13:33:41.541]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.541]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:41.541]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:41.541]                     .init = FALSE)
[13:33:41.541]                 }
[13:33:41.541]             }
[13:33:41.541]         }
[13:33:41.541]     })
[13:33:41.541]     if (TRUE) {
[13:33:41.541]         base::sink(type = "output", split = FALSE)
[13:33:41.541]         if (TRUE) {
[13:33:41.541]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:41.541]         }
[13:33:41.541]         else {
[13:33:41.541]             ...future.result["stdout"] <- base::list(NULL)
[13:33:41.541]         }
[13:33:41.541]         base::close(...future.stdout)
[13:33:41.541]         ...future.stdout <- NULL
[13:33:41.541]     }
[13:33:41.541]     ...future.result$conditions <- ...future.conditions
[13:33:41.541]     ...future.result$finished <- base::Sys.time()
[13:33:41.541]     ...future.result
[13:33:41.541] }
[13:33:41.542] assign_globals() ...
[13:33:41.543] List of 5
[13:33:41.543]  $ ...future.FUN            :function (object, ...)  
[13:33:41.543]  $ future.call.arguments    :List of 1
[13:33:41.543]   ..$ digits: int 2
[13:33:41.543]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.543]  $ ...future.elements_ii    :List of 6
[13:33:41.543]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[13:33:41.543]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[13:33:41.543]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[13:33:41.543]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[13:33:41.543]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[13:33:41.543]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[13:33:41.543]  $ ...future.seeds_ii       : NULL
[13:33:41.543]  $ ...future.globals.maxSize: NULL
[13:33:41.543]  - attr(*, "where")=List of 5
[13:33:41.543]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:41.543]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:41.543]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:41.543]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:41.543]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:41.543]  - attr(*, "resolved")= logi FALSE
[13:33:41.543]  - attr(*, "total_size")= num 1296
[13:33:41.543]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.543]  - attr(*, "already-done")= logi TRUE
[13:33:41.550] - copied ‘...future.FUN’ to environment
[13:33:41.551] - copied ‘future.call.arguments’ to environment
[13:33:41.551] - copied ‘...future.elements_ii’ to environment
[13:33:41.551] - copied ‘...future.seeds_ii’ to environment
[13:33:41.551] - copied ‘...future.globals.maxSize’ to environment
[13:33:41.551] assign_globals() ... done
[13:33:41.551] plan(): Setting new future strategy stack:
[13:33:41.551] List of future strategies:
[13:33:41.551] 1. sequential:
[13:33:41.551]    - args: function (..., envir = parent.frame())
[13:33:41.551]    - tweaked: FALSE
[13:33:41.551]    - call: NULL
[13:33:41.552] plan(): nbrOfWorkers() = 1
[13:33:41.553] plan(): Setting new future strategy stack:
[13:33:41.553] List of future strategies:
[13:33:41.553] 1. sequential:
[13:33:41.553]    - args: function (..., envir = parent.frame())
[13:33:41.553]    - tweaked: FALSE
[13:33:41.553]    - call: plan(strategy)
[13:33:41.554] plan(): nbrOfWorkers() = 1
[13:33:41.554] SequentialFuture started (and completed)
[13:33:41.554] - Launch lazy future ... done
[13:33:41.554] run() for ‘SequentialFuture’ ... done
[13:33:41.554] Created future:
[13:33:41.554] SequentialFuture:
[13:33:41.554] Label: ‘future_by-1’
[13:33:41.554] Expression:
[13:33:41.554] {
[13:33:41.554]     do.call(function(...) {
[13:33:41.554]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.554]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.554]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.554]             on.exit(options(oopts), add = TRUE)
[13:33:41.554]         }
[13:33:41.554]         {
[13:33:41.554]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.554]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.554]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.554]             })
[13:33:41.554]         }
[13:33:41.554]     }, args = future.call.arguments)
[13:33:41.554] }
[13:33:41.554] Lazy evaluation: FALSE
[13:33:41.554] Asynchronous evaluation: FALSE
[13:33:41.554] Local evaluation: TRUE
[13:33:41.554] Environment: R_GlobalEnv
[13:33:41.554] Capture standard output: TRUE
[13:33:41.554] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:41.554] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:41.554] Packages: <none>
[13:33:41.554] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:41.554] Resolved: TRUE
[13:33:41.554] Value: 5.48 KiB of class ‘list’
[13:33:41.554] Early signaling: FALSE
[13:33:41.554] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:41.554] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.555] Chunk #1 of 1 ... DONE
[13:33:41.555] Launching 1 futures (chunks) ... DONE
[13:33:41.556] Resolving 1 futures (chunks) ...
[13:33:41.556] resolve() on list ...
[13:33:41.556]  recursive: 0
[13:33:41.556]  length: 1
[13:33:41.556] 
[13:33:41.556] resolved() for ‘SequentialFuture’ ...
[13:33:41.556] - state: ‘finished’
[13:33:41.556] - run: TRUE
[13:33:41.556] - result: ‘FutureResult’
[13:33:41.556] resolved() for ‘SequentialFuture’ ... done
[13:33:41.556] Future #1
[13:33:41.557] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:41.557] - nx: 1
[13:33:41.557] - relay: TRUE
[13:33:41.557] - stdout: TRUE
[13:33:41.557] - signal: TRUE
[13:33:41.557] - resignal: FALSE
[13:33:41.557] - force: TRUE
[13:33:41.557] - relayed: [n=1] FALSE
[13:33:41.557] - queued futures: [n=1] FALSE
[13:33:41.557]  - until=1
[13:33:41.557]  - relaying element #1
[13:33:41.558] - relayed: [n=1] TRUE
[13:33:41.558] - queued futures: [n=1] TRUE
[13:33:41.558] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:41.558]  length: 0 (resolved future 1)
[13:33:41.558] Relaying remaining futures
[13:33:41.558] signalConditionsASAP(NULL, pos=0) ...
[13:33:41.558] - nx: 1
[13:33:41.558] - relay: TRUE
[13:33:41.558] - stdout: TRUE
[13:33:41.559] - signal: TRUE
[13:33:41.559] - resignal: FALSE
[13:33:41.559] - force: TRUE
[13:33:41.559] - relayed: [n=1] TRUE
[13:33:41.559] - queued futures: [n=1] TRUE
 - flush all
[13:33:41.559] - relayed: [n=1] TRUE
[13:33:41.559] - queued futures: [n=1] TRUE
[13:33:41.559] signalConditionsASAP(NULL, pos=0) ... done
[13:33:41.559] resolve() on list ... DONE
[13:33:41.559]  - Number of value chunks collected: 1
[13:33:41.559] Resolving 1 futures (chunks) ... DONE
[13:33:41.560] Reducing values from 1 chunks ...
[13:33:41.560]  - Number of values collected after concatenation: 6
[13:33:41.560]  - Number of values expected: 6
[13:33:41.560] Reducing values from 1 chunks ... DONE
[13:33:41.560] future_lapply() ... DONE
[13:33:41.560] future_by_internal() ... DONE
[13:33:41.561] future_by_internal() ...
[13:33:41.561] future_lapply() ...
[13:33:41.562] Number of chunks: 1
[13:33:41.562] getGlobalsAndPackagesXApply() ...
[13:33:41.562]  - future.globals: TRUE
[13:33:41.563] getGlobalsAndPackages() ...
[13:33:41.563] Searching for globals...
[13:33:41.564] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:33:41.564] Searching for globals ... DONE
[13:33:41.564] Resolving globals: FALSE
[13:33:41.565] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[13:33:41.565] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[13:33:41.565] - globals: [1] ‘FUN’
[13:33:41.565] - packages: [1] ‘stats’
[13:33:41.565] getGlobalsAndPackages() ... DONE
[13:33:41.566]  - globals found/used: [n=1] ‘FUN’
[13:33:41.566]  - needed namespaces: [n=1] ‘stats’
[13:33:41.566] Finding globals ... DONE
[13:33:41.566]  - use_args: TRUE
[13:33:41.566]  - Getting '...' globals ...
[13:33:41.566] resolve() on list ...
[13:33:41.566]  recursive: 0
[13:33:41.566]  length: 1
[13:33:41.566]  elements: ‘...’
[13:33:41.567]  length: 0 (resolved future 1)
[13:33:41.567] resolve() on list ... DONE
[13:33:41.567]    - '...' content: [n=1] ‘singular.ok’
[13:33:41.567] List of 1
[13:33:41.567]  $ ...:List of 1
[13:33:41.567]   ..$ singular.ok: logi FALSE
[13:33:41.567]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.567]  - attr(*, "where")=List of 1
[13:33:41.567]   ..$ ...:<environment: 0x55cb81c9e460> 
[13:33:41.567]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.567]  - attr(*, "resolved")= logi TRUE
[13:33:41.567]  - attr(*, "total_size")= num NA
[13:33:41.571]  - Getting '...' globals ... DONE
[13:33:41.571] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:41.571] List of 2
[13:33:41.571]  $ ...future.FUN:function (x, ...)  
[13:33:41.571]  $ ...          :List of 1
[13:33:41.571]   ..$ singular.ok: logi FALSE
[13:33:41.571]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.571]  - attr(*, "where")=List of 2
[13:33:41.571]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:41.571]   ..$ ...          :<environment: 0x55cb81c9e460> 
[13:33:41.571]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.571]  - attr(*, "resolved")= logi FALSE
[13:33:41.571]  - attr(*, "total_size")= num 5384
[13:33:41.574] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:41.575] getGlobalsAndPackagesXApply() ... DONE
[13:33:41.575] Number of futures (= number of chunks): 1
[13:33:41.575] Launching 1 futures (chunks) ...
[13:33:41.575] Chunk #1 of 1 ...
[13:33:41.575]  - Finding globals in 'X' for chunk #1 ...
[13:33:41.575] getGlobalsAndPackages() ...
[13:33:41.575] Searching for globals...
[13:33:41.576] 
[13:33:41.576] Searching for globals ... DONE
[13:33:41.576] - globals: [0] <none>
[13:33:41.576] getGlobalsAndPackages() ... DONE
[13:33:41.576]    + additional globals found: [n=0] 
[13:33:41.576]    + additional namespaces needed: [n=0] 
[13:33:41.576]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:41.576]  - seeds: <none>
[13:33:41.576]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.577] getGlobalsAndPackages() ...
[13:33:41.577] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.577] Resolving globals: FALSE
[13:33:41.577] Tweak future expression to call with '...' arguments ...
[13:33:41.577] {
[13:33:41.577]     do.call(function(...) {
[13:33:41.577]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.577]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.577]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.577]             on.exit(options(oopts), add = TRUE)
[13:33:41.577]         }
[13:33:41.577]         {
[13:33:41.577]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.577]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.577]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.577]             })
[13:33:41.577]         }
[13:33:41.577]     }, args = future.call.arguments)
[13:33:41.577] }
[13:33:41.577] Tweak future expression to call with '...' arguments ... DONE
[13:33:41.578] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.578] 
[13:33:41.578] getGlobalsAndPackages() ... DONE
[13:33:41.578] run() for ‘Future’ ...
[13:33:41.578] - state: ‘created’
[13:33:41.578] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:33:41.579] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.579] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:41.579]   - Field: ‘label’
[13:33:41.579]   - Field: ‘local’
[13:33:41.579]   - Field: ‘owner’
[13:33:41.579]   - Field: ‘envir’
[13:33:41.579]   - Field: ‘packages’
[13:33:41.579]   - Field: ‘gc’
[13:33:41.579]   - Field: ‘conditions’
[13:33:41.579]   - Field: ‘expr’
[13:33:41.579]   - Field: ‘uuid’
[13:33:41.580]   - Field: ‘seed’
[13:33:41.580]   - Field: ‘version’
[13:33:41.580]   - Field: ‘result’
[13:33:41.580]   - Field: ‘asynchronous’
[13:33:41.580]   - Field: ‘calls’
[13:33:41.580]   - Field: ‘globals’
[13:33:41.580]   - Field: ‘stdout’
[13:33:41.580]   - Field: ‘earlySignal’
[13:33:41.580]   - Field: ‘lazy’
[13:33:41.580]   - Field: ‘state’
[13:33:41.580] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:41.581] - Launch lazy future ...
[13:33:41.581] Packages needed by the future expression (n = 1): ‘stats’
[13:33:41.581] Packages needed by future strategies (n = 0): <none>
[13:33:41.581] {
[13:33:41.581]     {
[13:33:41.581]         {
[13:33:41.581]             ...future.startTime <- base::Sys.time()
[13:33:41.581]             {
[13:33:41.581]                 {
[13:33:41.581]                   {
[13:33:41.581]                     {
[13:33:41.581]                       base::local({
[13:33:41.581]                         has_future <- base::requireNamespace("future", 
[13:33:41.581]                           quietly = TRUE)
[13:33:41.581]                         if (has_future) {
[13:33:41.581]                           ns <- base::getNamespace("future")
[13:33:41.581]                           version <- ns[[".package"]][["version"]]
[13:33:41.581]                           if (is.null(version)) 
[13:33:41.581]                             version <- utils::packageVersion("future")
[13:33:41.581]                         }
[13:33:41.581]                         else {
[13:33:41.581]                           version <- NULL
[13:33:41.581]                         }
[13:33:41.581]                         if (!has_future || version < "1.8.0") {
[13:33:41.581]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:41.581]                             "", base::R.version$version.string), 
[13:33:41.581]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:41.581]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:41.581]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:41.581]                               "release", "version")], collapse = " "), 
[13:33:41.581]                             hostname = base::Sys.info()[["nodename"]])
[13:33:41.581]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:41.581]                             info)
[13:33:41.581]                           info <- base::paste(info, collapse = "; ")
[13:33:41.581]                           if (!has_future) {
[13:33:41.581]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:41.581]                               info)
[13:33:41.581]                           }
[13:33:41.581]                           else {
[13:33:41.581]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:41.581]                               info, version)
[13:33:41.581]                           }
[13:33:41.581]                           base::stop(msg)
[13:33:41.581]                         }
[13:33:41.581]                       })
[13:33:41.581]                     }
[13:33:41.581]                     base::local({
[13:33:41.581]                       for (pkg in "stats") {
[13:33:41.581]                         base::loadNamespace(pkg)
[13:33:41.581]                         base::library(pkg, character.only = TRUE)
[13:33:41.581]                       }
[13:33:41.581]                     })
[13:33:41.581]                   }
[13:33:41.581]                   ...future.strategy.old <- future::plan("list")
[13:33:41.581]                   options(future.plan = NULL)
[13:33:41.581]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.581]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:41.581]                 }
[13:33:41.581]                 ...future.workdir <- getwd()
[13:33:41.581]             }
[13:33:41.581]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:41.581]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:41.581]         }
[13:33:41.581]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:41.581]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:41.581]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:41.581]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:41.581]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:41.581]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:41.581]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:41.581]             base::names(...future.oldOptions))
[13:33:41.581]     }
[13:33:41.581]     if (FALSE) {
[13:33:41.581]     }
[13:33:41.581]     else {
[13:33:41.581]         if (TRUE) {
[13:33:41.581]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:41.581]                 open = "w")
[13:33:41.581]         }
[13:33:41.581]         else {
[13:33:41.581]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:41.581]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:41.581]         }
[13:33:41.581]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:41.581]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:41.581]             base::sink(type = "output", split = FALSE)
[13:33:41.581]             base::close(...future.stdout)
[13:33:41.581]         }, add = TRUE)
[13:33:41.581]     }
[13:33:41.581]     ...future.frame <- base::sys.nframe()
[13:33:41.581]     ...future.conditions <- base::list()
[13:33:41.581]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:41.581]     if (FALSE) {
[13:33:41.581]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:41.581]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:41.581]     }
[13:33:41.581]     ...future.result <- base::tryCatch({
[13:33:41.581]         base::withCallingHandlers({
[13:33:41.581]             ...future.value <- base::withVisible(base::local({
[13:33:41.581]                 do.call(function(...) {
[13:33:41.581]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.581]                   if (!identical(...future.globals.maxSize.org, 
[13:33:41.581]                     ...future.globals.maxSize)) {
[13:33:41.581]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.581]                     on.exit(options(oopts), add = TRUE)
[13:33:41.581]                   }
[13:33:41.581]                   {
[13:33:41.581]                     lapply(seq_along(...future.elements_ii), 
[13:33:41.581]                       FUN = function(jj) {
[13:33:41.581]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.581]                         ...future.FUN(...future.X_jj, ...)
[13:33:41.581]                       })
[13:33:41.581]                   }
[13:33:41.581]                 }, args = future.call.arguments)
[13:33:41.581]             }))
[13:33:41.581]             future::FutureResult(value = ...future.value$value, 
[13:33:41.581]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.581]                   ...future.rng), globalenv = if (FALSE) 
[13:33:41.581]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:41.581]                     ...future.globalenv.names))
[13:33:41.581]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:41.581]         }, condition = base::local({
[13:33:41.581]             c <- base::c
[13:33:41.581]             inherits <- base::inherits
[13:33:41.581]             invokeRestart <- base::invokeRestart
[13:33:41.581]             length <- base::length
[13:33:41.581]             list <- base::list
[13:33:41.581]             seq.int <- base::seq.int
[13:33:41.581]             signalCondition <- base::signalCondition
[13:33:41.581]             sys.calls <- base::sys.calls
[13:33:41.581]             `[[` <- base::`[[`
[13:33:41.581]             `+` <- base::`+`
[13:33:41.581]             `<<-` <- base::`<<-`
[13:33:41.581]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:41.581]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:41.581]                   3L)]
[13:33:41.581]             }
[13:33:41.581]             function(cond) {
[13:33:41.581]                 is_error <- inherits(cond, "error")
[13:33:41.581]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:41.581]                   NULL)
[13:33:41.581]                 if (is_error) {
[13:33:41.581]                   sessionInformation <- function() {
[13:33:41.581]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:41.581]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:41.581]                       search = base::search(), system = base::Sys.info())
[13:33:41.581]                   }
[13:33:41.581]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.581]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:41.581]                     cond$call), session = sessionInformation(), 
[13:33:41.581]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:41.581]                   signalCondition(cond)
[13:33:41.581]                 }
[13:33:41.581]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:41.581]                 "immediateCondition"))) {
[13:33:41.581]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:41.581]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.581]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:41.581]                   if (TRUE && !signal) {
[13:33:41.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.581]                     {
[13:33:41.581]                       inherits <- base::inherits
[13:33:41.581]                       invokeRestart <- base::invokeRestart
[13:33:41.581]                       is.null <- base::is.null
[13:33:41.581]                       muffled <- FALSE
[13:33:41.581]                       if (inherits(cond, "message")) {
[13:33:41.581]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.581]                         if (muffled) 
[13:33:41.581]                           invokeRestart("muffleMessage")
[13:33:41.581]                       }
[13:33:41.581]                       else if (inherits(cond, "warning")) {
[13:33:41.581]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.581]                         if (muffled) 
[13:33:41.581]                           invokeRestart("muffleWarning")
[13:33:41.581]                       }
[13:33:41.581]                       else if (inherits(cond, "condition")) {
[13:33:41.581]                         if (!is.null(pattern)) {
[13:33:41.581]                           computeRestarts <- base::computeRestarts
[13:33:41.581]                           grepl <- base::grepl
[13:33:41.581]                           restarts <- computeRestarts(cond)
[13:33:41.581]                           for (restart in restarts) {
[13:33:41.581]                             name <- restart$name
[13:33:41.581]                             if (is.null(name)) 
[13:33:41.581]                               next
[13:33:41.581]                             if (!grepl(pattern, name)) 
[13:33:41.581]                               next
[13:33:41.581]                             invokeRestart(restart)
[13:33:41.581]                             muffled <- TRUE
[13:33:41.581]                             break
[13:33:41.581]                           }
[13:33:41.581]                         }
[13:33:41.581]                       }
[13:33:41.581]                       invisible(muffled)
[13:33:41.581]                     }
[13:33:41.581]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.581]                   }
[13:33:41.581]                 }
[13:33:41.581]                 else {
[13:33:41.581]                   if (TRUE) {
[13:33:41.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.581]                     {
[13:33:41.581]                       inherits <- base::inherits
[13:33:41.581]                       invokeRestart <- base::invokeRestart
[13:33:41.581]                       is.null <- base::is.null
[13:33:41.581]                       muffled <- FALSE
[13:33:41.581]                       if (inherits(cond, "message")) {
[13:33:41.581]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.581]                         if (muffled) 
[13:33:41.581]                           invokeRestart("muffleMessage")
[13:33:41.581]                       }
[13:33:41.581]                       else if (inherits(cond, "warning")) {
[13:33:41.581]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.581]                         if (muffled) 
[13:33:41.581]                           invokeRestart("muffleWarning")
[13:33:41.581]                       }
[13:33:41.581]                       else if (inherits(cond, "condition")) {
[13:33:41.581]                         if (!is.null(pattern)) {
[13:33:41.581]                           computeRestarts <- base::computeRestarts
[13:33:41.581]                           grepl <- base::grepl
[13:33:41.581]                           restarts <- computeRestarts(cond)
[13:33:41.581]                           for (restart in restarts) {
[13:33:41.581]                             name <- restart$name
[13:33:41.581]                             if (is.null(name)) 
[13:33:41.581]                               next
[13:33:41.581]                             if (!grepl(pattern, name)) 
[13:33:41.581]                               next
[13:33:41.581]                             invokeRestart(restart)
[13:33:41.581]                             muffled <- TRUE
[13:33:41.581]                             break
[13:33:41.581]                           }
[13:33:41.581]                         }
[13:33:41.581]                       }
[13:33:41.581]                       invisible(muffled)
[13:33:41.581]                     }
[13:33:41.581]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.581]                   }
[13:33:41.581]                 }
[13:33:41.581]             }
[13:33:41.581]         }))
[13:33:41.581]     }, error = function(ex) {
[13:33:41.581]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:41.581]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.581]                 ...future.rng), started = ...future.startTime, 
[13:33:41.581]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:41.581]             version = "1.8"), class = "FutureResult")
[13:33:41.581]     }, finally = {
[13:33:41.581]         if (!identical(...future.workdir, getwd())) 
[13:33:41.581]             setwd(...future.workdir)
[13:33:41.581]         {
[13:33:41.581]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:41.581]                 ...future.oldOptions$nwarnings <- NULL
[13:33:41.581]             }
[13:33:41.581]             base::options(...future.oldOptions)
[13:33:41.581]             if (.Platform$OS.type == "windows") {
[13:33:41.581]                 old_names <- names(...future.oldEnvVars)
[13:33:41.581]                 envs <- base::Sys.getenv()
[13:33:41.581]                 names <- names(envs)
[13:33:41.581]                 common <- intersect(names, old_names)
[13:33:41.581]                 added <- setdiff(names, old_names)
[13:33:41.581]                 removed <- setdiff(old_names, names)
[13:33:41.581]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:41.581]                   envs[common]]
[13:33:41.581]                 NAMES <- toupper(changed)
[13:33:41.581]                 args <- list()
[13:33:41.581]                 for (kk in seq_along(NAMES)) {
[13:33:41.581]                   name <- changed[[kk]]
[13:33:41.581]                   NAME <- NAMES[[kk]]
[13:33:41.581]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.581]                     next
[13:33:41.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.581]                 }
[13:33:41.581]                 NAMES <- toupper(added)
[13:33:41.581]                 for (kk in seq_along(NAMES)) {
[13:33:41.581]                   name <- added[[kk]]
[13:33:41.581]                   NAME <- NAMES[[kk]]
[13:33:41.581]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.581]                     next
[13:33:41.581]                   args[[name]] <- ""
[13:33:41.581]                 }
[13:33:41.581]                 NAMES <- toupper(removed)
[13:33:41.581]                 for (kk in seq_along(NAMES)) {
[13:33:41.581]                   name <- removed[[kk]]
[13:33:41.581]                   NAME <- NAMES[[kk]]
[13:33:41.581]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.581]                     next
[13:33:41.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.581]                 }
[13:33:41.581]                 if (length(args) > 0) 
[13:33:41.581]                   base::do.call(base::Sys.setenv, args = args)
[13:33:41.581]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:41.581]             }
[13:33:41.581]             else {
[13:33:41.581]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:41.581]             }
[13:33:41.581]             {
[13:33:41.581]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:41.581]                   0L) {
[13:33:41.581]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:41.581]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:41.581]                   base::options(opts)
[13:33:41.581]                 }
[13:33:41.581]                 {
[13:33:41.581]                   {
[13:33:41.581]                     NULL
[13:33:41.581]                     RNGkind("Mersenne-Twister")
[13:33:41.581]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:41.581]                       inherits = FALSE)
[13:33:41.581]                   }
[13:33:41.581]                   options(future.plan = NULL)
[13:33:41.581]                   if (is.na(NA_character_)) 
[13:33:41.581]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.581]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:41.581]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:41.581]                     .init = FALSE)
[13:33:41.581]                 }
[13:33:41.581]             }
[13:33:41.581]         }
[13:33:41.581]     })
[13:33:41.581]     if (TRUE) {
[13:33:41.581]         base::sink(type = "output", split = FALSE)
[13:33:41.581]         if (TRUE) {
[13:33:41.581]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:41.581]         }
[13:33:41.581]         else {
[13:33:41.581]             ...future.result["stdout"] <- base::list(NULL)
[13:33:41.581]         }
[13:33:41.581]         base::close(...future.stdout)
[13:33:41.581]         ...future.stdout <- NULL
[13:33:41.581]     }
[13:33:41.581]     ...future.result$conditions <- ...future.conditions
[13:33:41.581]     ...future.result$finished <- base::Sys.time()
[13:33:41.581]     ...future.result
[13:33:41.581] }
[13:33:41.583] assign_globals() ...
[13:33:41.583] List of 5
[13:33:41.583]  $ ...future.FUN            :function (x, ...)  
[13:33:41.583]  $ future.call.arguments    :List of 1
[13:33:41.583]   ..$ singular.ok: logi FALSE
[13:33:41.583]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.583]  $ ...future.elements_ii    :List of 3
[13:33:41.583]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.583]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:33:41.583]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.583]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:41.583]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.583]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:33:41.583]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.583]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:33:41.583]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.583]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:33:41.583]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.583]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:33:41.583]  $ ...future.seeds_ii       : NULL
[13:33:41.583]  $ ...future.globals.maxSize: NULL
[13:33:41.583]  - attr(*, "where")=List of 5
[13:33:41.583]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:41.583]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:41.583]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:41.583]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:41.583]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:41.583]  - attr(*, "resolved")= logi FALSE
[13:33:41.583]  - attr(*, "total_size")= num 5384
[13:33:41.583]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.583]  - attr(*, "already-done")= logi TRUE
[13:33:41.594] - reassign environment for ‘...future.FUN’
[13:33:41.594] - copied ‘...future.FUN’ to environment
[13:33:41.594] - copied ‘future.call.arguments’ to environment
[13:33:41.594] - copied ‘...future.elements_ii’ to environment
[13:33:41.594] - copied ‘...future.seeds_ii’ to environment
[13:33:41.594] - copied ‘...future.globals.maxSize’ to environment
[13:33:41.594] assign_globals() ... done
[13:33:41.595] plan(): Setting new future strategy stack:
[13:33:41.595] List of future strategies:
[13:33:41.595] 1. sequential:
[13:33:41.595]    - args: function (..., envir = parent.frame())
[13:33:41.595]    - tweaked: FALSE
[13:33:41.595]    - call: NULL
[13:33:41.595] plan(): nbrOfWorkers() = 1
[13:33:41.598] plan(): Setting new future strategy stack:
[13:33:41.598] List of future strategies:
[13:33:41.598] 1. sequential:
[13:33:41.598]    - args: function (..., envir = parent.frame())
[13:33:41.598]    - tweaked: FALSE
[13:33:41.598]    - call: plan(strategy)
[13:33:41.598] plan(): nbrOfWorkers() = 1
[13:33:41.598] SequentialFuture started (and completed)
[13:33:41.599] - Launch lazy future ... done
[13:33:41.599] run() for ‘SequentialFuture’ ... done
[13:33:41.599] Created future:
[13:33:41.599] SequentialFuture:
[13:33:41.599] Label: ‘future_by-1’
[13:33:41.599] Expression:
[13:33:41.599] {
[13:33:41.599]     do.call(function(...) {
[13:33:41.599]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.599]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.599]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.599]             on.exit(options(oopts), add = TRUE)
[13:33:41.599]         }
[13:33:41.599]         {
[13:33:41.599]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.599]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.599]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.599]             })
[13:33:41.599]         }
[13:33:41.599]     }, args = future.call.arguments)
[13:33:41.599] }
[13:33:41.599] Lazy evaluation: FALSE
[13:33:41.599] Asynchronous evaluation: FALSE
[13:33:41.599] Local evaluation: TRUE
[13:33:41.599] Environment: R_GlobalEnv
[13:33:41.599] Capture standard output: TRUE
[13:33:41.599] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:41.599] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:41.599] Packages: 1 packages (‘stats’)
[13:33:41.599] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:41.599] Resolved: TRUE
[13:33:41.599] Value: 26.06 KiB of class ‘list’
[13:33:41.599] Early signaling: FALSE
[13:33:41.599] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:41.599] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.600] Chunk #1 of 1 ... DONE
[13:33:41.600] Launching 1 futures (chunks) ... DONE
[13:33:41.600] Resolving 1 futures (chunks) ...
[13:33:41.601] resolve() on list ...
[13:33:41.601]  recursive: 0
[13:33:41.601]  length: 1
[13:33:41.601] 
[13:33:41.601] resolved() for ‘SequentialFuture’ ...
[13:33:41.601] - state: ‘finished’
[13:33:41.601] - run: TRUE
[13:33:41.601] - result: ‘FutureResult’
[13:33:41.601] resolved() for ‘SequentialFuture’ ... done
[13:33:41.601] Future #1
[13:33:41.602] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:41.602] - nx: 1
[13:33:41.602] - relay: TRUE
[13:33:41.602] - stdout: TRUE
[13:33:41.602] - signal: TRUE
[13:33:41.602] - resignal: FALSE
[13:33:41.602] - force: TRUE
[13:33:41.602] - relayed: [n=1] FALSE
[13:33:41.602] - queued futures: [n=1] FALSE
[13:33:41.602]  - until=1
[13:33:41.602]  - relaying element #1
[13:33:41.603] - relayed: [n=1] TRUE
[13:33:41.603] - queued futures: [n=1] TRUE
[13:33:41.603] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:41.603]  length: 0 (resolved future 1)
[13:33:41.603] Relaying remaining futures
[13:33:41.603] signalConditionsASAP(NULL, pos=0) ...
[13:33:41.603] - nx: 1
[13:33:41.603] - relay: TRUE
[13:33:41.603] - stdout: TRUE
[13:33:41.603] - signal: TRUE
[13:33:41.603] - resignal: FALSE
[13:33:41.604] - force: TRUE
[13:33:41.604] - relayed: [n=1] TRUE
[13:33:41.604] - queued futures: [n=1] TRUE
 - flush all
[13:33:41.604] - relayed: [n=1] TRUE
[13:33:41.604] - queued futures: [n=1] TRUE
[13:33:41.604] signalConditionsASAP(NULL, pos=0) ... done
[13:33:41.604] resolve() on list ... DONE
[13:33:41.604]  - Number of value chunks collected: 1
[13:33:41.604] Resolving 1 futures (chunks) ... DONE
[13:33:41.604] Reducing values from 1 chunks ...
[13:33:41.605]  - Number of values collected after concatenation: 3
[13:33:41.605]  - Number of values expected: 3
[13:33:41.605] Reducing values from 1 chunks ... DONE
[13:33:41.605] future_lapply() ... DONE
[13:33:41.605] future_by_internal() ... DONE
[13:33:41.610] future_by_internal() ...
[13:33:41.611] future_lapply() ...
[13:33:41.612] Number of chunks: 1
[13:33:41.612] getGlobalsAndPackagesXApply() ...
[13:33:41.612]  - future.globals: TRUE
[13:33:41.612] getGlobalsAndPackages() ...
[13:33:41.612] Searching for globals...
[13:33:41.614] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:33:41.614] Searching for globals ... DONE
[13:33:41.614] Resolving globals: FALSE
[13:33:41.614] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[13:33:41.615] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[13:33:41.615] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[13:33:41.615] - packages: [1] ‘stats’
[13:33:41.615] getGlobalsAndPackages() ... DONE
[13:33:41.615]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[13:33:41.615]  - needed namespaces: [n=1] ‘stats’
[13:33:41.615] Finding globals ... DONE
[13:33:41.615]  - use_args: TRUE
[13:33:41.616]  - Getting '...' globals ...
[13:33:41.616] resolve() on list ...
[13:33:41.616]  recursive: 0
[13:33:41.616]  length: 1
[13:33:41.616]  elements: ‘...’
[13:33:41.616]  length: 0 (resolved future 1)
[13:33:41.616] resolve() on list ... DONE
[13:33:41.616]    - '...' content: [n=0] 
[13:33:41.617] List of 1
[13:33:41.617]  $ ...: list()
[13:33:41.617]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.617]  - attr(*, "where")=List of 1
[13:33:41.617]   ..$ ...:<environment: 0x55cb825f1870> 
[13:33:41.617]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.617]  - attr(*, "resolved")= logi TRUE
[13:33:41.617]  - attr(*, "total_size")= num NA
[13:33:41.619]  - Getting '...' globals ... DONE
[13:33:41.619] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[13:33:41.619] List of 4
[13:33:41.619]  $ ...future.FUN:function (x)  
[13:33:41.619]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:33:41.619]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:41.619]  $ ...          : list()
[13:33:41.619]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.619]  - attr(*, "where")=List of 4
[13:33:41.619]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:41.619]   ..$ breaks       :<environment: R_EmptyEnv> 
[13:33:41.619]   ..$ wool         :<environment: R_EmptyEnv> 
[13:33:41.619]   ..$ ...          :<environment: 0x55cb825f1870> 
[13:33:41.619]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.619]  - attr(*, "resolved")= logi FALSE
[13:33:41.619]  - attr(*, "total_size")= num 2320
[13:33:41.623] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:41.623] getGlobalsAndPackagesXApply() ... DONE
[13:33:41.623] Number of futures (= number of chunks): 1
[13:33:41.623] Launching 1 futures (chunks) ...
[13:33:41.623] Chunk #1 of 1 ...
[13:33:41.623]  - Finding globals in 'X' for chunk #1 ...
[13:33:41.624] getGlobalsAndPackages() ...
[13:33:41.624] Searching for globals...
[13:33:41.624] 
[13:33:41.624] Searching for globals ... DONE
[13:33:41.624] - globals: [0] <none>
[13:33:41.624] getGlobalsAndPackages() ... DONE
[13:33:41.624]    + additional globals found: [n=0] 
[13:33:41.625]    + additional namespaces needed: [n=0] 
[13:33:41.625]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:41.625]  - seeds: <none>
[13:33:41.625]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.625] getGlobalsAndPackages() ...
[13:33:41.625] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.625] Resolving globals: FALSE
[13:33:41.625] Tweak future expression to call with '...' arguments ...
[13:33:41.625] {
[13:33:41.625]     do.call(function(...) {
[13:33:41.625]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.625]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.625]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.625]             on.exit(options(oopts), add = TRUE)
[13:33:41.625]         }
[13:33:41.625]         {
[13:33:41.625]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.625]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.625]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.625]             })
[13:33:41.625]         }
[13:33:41.625]     }, args = future.call.arguments)
[13:33:41.625] }
[13:33:41.626] Tweak future expression to call with '...' arguments ... DONE
[13:33:41.626] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.626] 
[13:33:41.626] getGlobalsAndPackages() ... DONE
[13:33:41.626] run() for ‘Future’ ...
[13:33:41.626] - state: ‘created’
[13:33:41.628] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:33:41.628] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.628] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:41.628]   - Field: ‘label’
[13:33:41.628]   - Field: ‘local’
[13:33:41.628]   - Field: ‘owner’
[13:33:41.628]   - Field: ‘envir’
[13:33:41.629]   - Field: ‘packages’
[13:33:41.629]   - Field: ‘gc’
[13:33:41.629]   - Field: ‘conditions’
[13:33:41.629]   - Field: ‘expr’
[13:33:41.629]   - Field: ‘uuid’
[13:33:41.629]   - Field: ‘seed’
[13:33:41.629]   - Field: ‘version’
[13:33:41.629]   - Field: ‘result’
[13:33:41.629]   - Field: ‘asynchronous’
[13:33:41.629]   - Field: ‘calls’
[13:33:41.630]   - Field: ‘globals’
[13:33:41.630]   - Field: ‘stdout’
[13:33:41.630]   - Field: ‘earlySignal’
[13:33:41.630]   - Field: ‘lazy’
[13:33:41.630]   - Field: ‘state’
[13:33:41.630] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:41.630] - Launch lazy future ...
[13:33:41.630] Packages needed by the future expression (n = 1): ‘stats’
[13:33:41.630] Packages needed by future strategies (n = 0): <none>
[13:33:41.631] {
[13:33:41.631]     {
[13:33:41.631]         {
[13:33:41.631]             ...future.startTime <- base::Sys.time()
[13:33:41.631]             {
[13:33:41.631]                 {
[13:33:41.631]                   {
[13:33:41.631]                     {
[13:33:41.631]                       base::local({
[13:33:41.631]                         has_future <- base::requireNamespace("future", 
[13:33:41.631]                           quietly = TRUE)
[13:33:41.631]                         if (has_future) {
[13:33:41.631]                           ns <- base::getNamespace("future")
[13:33:41.631]                           version <- ns[[".package"]][["version"]]
[13:33:41.631]                           if (is.null(version)) 
[13:33:41.631]                             version <- utils::packageVersion("future")
[13:33:41.631]                         }
[13:33:41.631]                         else {
[13:33:41.631]                           version <- NULL
[13:33:41.631]                         }
[13:33:41.631]                         if (!has_future || version < "1.8.0") {
[13:33:41.631]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:41.631]                             "", base::R.version$version.string), 
[13:33:41.631]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:41.631]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:41.631]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:41.631]                               "release", "version")], collapse = " "), 
[13:33:41.631]                             hostname = base::Sys.info()[["nodename"]])
[13:33:41.631]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:41.631]                             info)
[13:33:41.631]                           info <- base::paste(info, collapse = "; ")
[13:33:41.631]                           if (!has_future) {
[13:33:41.631]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:41.631]                               info)
[13:33:41.631]                           }
[13:33:41.631]                           else {
[13:33:41.631]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:41.631]                               info, version)
[13:33:41.631]                           }
[13:33:41.631]                           base::stop(msg)
[13:33:41.631]                         }
[13:33:41.631]                       })
[13:33:41.631]                     }
[13:33:41.631]                     base::local({
[13:33:41.631]                       for (pkg in "stats") {
[13:33:41.631]                         base::loadNamespace(pkg)
[13:33:41.631]                         base::library(pkg, character.only = TRUE)
[13:33:41.631]                       }
[13:33:41.631]                     })
[13:33:41.631]                   }
[13:33:41.631]                   ...future.strategy.old <- future::plan("list")
[13:33:41.631]                   options(future.plan = NULL)
[13:33:41.631]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.631]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:41.631]                 }
[13:33:41.631]                 ...future.workdir <- getwd()
[13:33:41.631]             }
[13:33:41.631]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:41.631]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:41.631]         }
[13:33:41.631]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:41.631]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:41.631]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:41.631]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:41.631]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:41.631]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:41.631]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:41.631]             base::names(...future.oldOptions))
[13:33:41.631]     }
[13:33:41.631]     if (FALSE) {
[13:33:41.631]     }
[13:33:41.631]     else {
[13:33:41.631]         if (TRUE) {
[13:33:41.631]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:41.631]                 open = "w")
[13:33:41.631]         }
[13:33:41.631]         else {
[13:33:41.631]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:41.631]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:41.631]         }
[13:33:41.631]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:41.631]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:41.631]             base::sink(type = "output", split = FALSE)
[13:33:41.631]             base::close(...future.stdout)
[13:33:41.631]         }, add = TRUE)
[13:33:41.631]     }
[13:33:41.631]     ...future.frame <- base::sys.nframe()
[13:33:41.631]     ...future.conditions <- base::list()
[13:33:41.631]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:41.631]     if (FALSE) {
[13:33:41.631]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:41.631]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:41.631]     }
[13:33:41.631]     ...future.result <- base::tryCatch({
[13:33:41.631]         base::withCallingHandlers({
[13:33:41.631]             ...future.value <- base::withVisible(base::local({
[13:33:41.631]                 do.call(function(...) {
[13:33:41.631]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.631]                   if (!identical(...future.globals.maxSize.org, 
[13:33:41.631]                     ...future.globals.maxSize)) {
[13:33:41.631]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.631]                     on.exit(options(oopts), add = TRUE)
[13:33:41.631]                   }
[13:33:41.631]                   {
[13:33:41.631]                     lapply(seq_along(...future.elements_ii), 
[13:33:41.631]                       FUN = function(jj) {
[13:33:41.631]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.631]                         ...future.FUN(...future.X_jj, ...)
[13:33:41.631]                       })
[13:33:41.631]                   }
[13:33:41.631]                 }, args = future.call.arguments)
[13:33:41.631]             }))
[13:33:41.631]             future::FutureResult(value = ...future.value$value, 
[13:33:41.631]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.631]                   ...future.rng), globalenv = if (FALSE) 
[13:33:41.631]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:41.631]                     ...future.globalenv.names))
[13:33:41.631]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:41.631]         }, condition = base::local({
[13:33:41.631]             c <- base::c
[13:33:41.631]             inherits <- base::inherits
[13:33:41.631]             invokeRestart <- base::invokeRestart
[13:33:41.631]             length <- base::length
[13:33:41.631]             list <- base::list
[13:33:41.631]             seq.int <- base::seq.int
[13:33:41.631]             signalCondition <- base::signalCondition
[13:33:41.631]             sys.calls <- base::sys.calls
[13:33:41.631]             `[[` <- base::`[[`
[13:33:41.631]             `+` <- base::`+`
[13:33:41.631]             `<<-` <- base::`<<-`
[13:33:41.631]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:41.631]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:41.631]                   3L)]
[13:33:41.631]             }
[13:33:41.631]             function(cond) {
[13:33:41.631]                 is_error <- inherits(cond, "error")
[13:33:41.631]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:41.631]                   NULL)
[13:33:41.631]                 if (is_error) {
[13:33:41.631]                   sessionInformation <- function() {
[13:33:41.631]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:41.631]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:41.631]                       search = base::search(), system = base::Sys.info())
[13:33:41.631]                   }
[13:33:41.631]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.631]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:41.631]                     cond$call), session = sessionInformation(), 
[13:33:41.631]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:41.631]                   signalCondition(cond)
[13:33:41.631]                 }
[13:33:41.631]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:41.631]                 "immediateCondition"))) {
[13:33:41.631]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:41.631]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.631]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:41.631]                   if (TRUE && !signal) {
[13:33:41.631]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.631]                     {
[13:33:41.631]                       inherits <- base::inherits
[13:33:41.631]                       invokeRestart <- base::invokeRestart
[13:33:41.631]                       is.null <- base::is.null
[13:33:41.631]                       muffled <- FALSE
[13:33:41.631]                       if (inherits(cond, "message")) {
[13:33:41.631]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.631]                         if (muffled) 
[13:33:41.631]                           invokeRestart("muffleMessage")
[13:33:41.631]                       }
[13:33:41.631]                       else if (inherits(cond, "warning")) {
[13:33:41.631]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.631]                         if (muffled) 
[13:33:41.631]                           invokeRestart("muffleWarning")
[13:33:41.631]                       }
[13:33:41.631]                       else if (inherits(cond, "condition")) {
[13:33:41.631]                         if (!is.null(pattern)) {
[13:33:41.631]                           computeRestarts <- base::computeRestarts
[13:33:41.631]                           grepl <- base::grepl
[13:33:41.631]                           restarts <- computeRestarts(cond)
[13:33:41.631]                           for (restart in restarts) {
[13:33:41.631]                             name <- restart$name
[13:33:41.631]                             if (is.null(name)) 
[13:33:41.631]                               next
[13:33:41.631]                             if (!grepl(pattern, name)) 
[13:33:41.631]                               next
[13:33:41.631]                             invokeRestart(restart)
[13:33:41.631]                             muffled <- TRUE
[13:33:41.631]                             break
[13:33:41.631]                           }
[13:33:41.631]                         }
[13:33:41.631]                       }
[13:33:41.631]                       invisible(muffled)
[13:33:41.631]                     }
[13:33:41.631]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.631]                   }
[13:33:41.631]                 }
[13:33:41.631]                 else {
[13:33:41.631]                   if (TRUE) {
[13:33:41.631]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.631]                     {
[13:33:41.631]                       inherits <- base::inherits
[13:33:41.631]                       invokeRestart <- base::invokeRestart
[13:33:41.631]                       is.null <- base::is.null
[13:33:41.631]                       muffled <- FALSE
[13:33:41.631]                       if (inherits(cond, "message")) {
[13:33:41.631]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.631]                         if (muffled) 
[13:33:41.631]                           invokeRestart("muffleMessage")
[13:33:41.631]                       }
[13:33:41.631]                       else if (inherits(cond, "warning")) {
[13:33:41.631]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.631]                         if (muffled) 
[13:33:41.631]                           invokeRestart("muffleWarning")
[13:33:41.631]                       }
[13:33:41.631]                       else if (inherits(cond, "condition")) {
[13:33:41.631]                         if (!is.null(pattern)) {
[13:33:41.631]                           computeRestarts <- base::computeRestarts
[13:33:41.631]                           grepl <- base::grepl
[13:33:41.631]                           restarts <- computeRestarts(cond)
[13:33:41.631]                           for (restart in restarts) {
[13:33:41.631]                             name <- restart$name
[13:33:41.631]                             if (is.null(name)) 
[13:33:41.631]                               next
[13:33:41.631]                             if (!grepl(pattern, name)) 
[13:33:41.631]                               next
[13:33:41.631]                             invokeRestart(restart)
[13:33:41.631]                             muffled <- TRUE
[13:33:41.631]                             break
[13:33:41.631]                           }
[13:33:41.631]                         }
[13:33:41.631]                       }
[13:33:41.631]                       invisible(muffled)
[13:33:41.631]                     }
[13:33:41.631]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.631]                   }
[13:33:41.631]                 }
[13:33:41.631]             }
[13:33:41.631]         }))
[13:33:41.631]     }, error = function(ex) {
[13:33:41.631]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:41.631]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.631]                 ...future.rng), started = ...future.startTime, 
[13:33:41.631]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:41.631]             version = "1.8"), class = "FutureResult")
[13:33:41.631]     }, finally = {
[13:33:41.631]         if (!identical(...future.workdir, getwd())) 
[13:33:41.631]             setwd(...future.workdir)
[13:33:41.631]         {
[13:33:41.631]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:41.631]                 ...future.oldOptions$nwarnings <- NULL
[13:33:41.631]             }
[13:33:41.631]             base::options(...future.oldOptions)
[13:33:41.631]             if (.Platform$OS.type == "windows") {
[13:33:41.631]                 old_names <- names(...future.oldEnvVars)
[13:33:41.631]                 envs <- base::Sys.getenv()
[13:33:41.631]                 names <- names(envs)
[13:33:41.631]                 common <- intersect(names, old_names)
[13:33:41.631]                 added <- setdiff(names, old_names)
[13:33:41.631]                 removed <- setdiff(old_names, names)
[13:33:41.631]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:41.631]                   envs[common]]
[13:33:41.631]                 NAMES <- toupper(changed)
[13:33:41.631]                 args <- list()
[13:33:41.631]                 for (kk in seq_along(NAMES)) {
[13:33:41.631]                   name <- changed[[kk]]
[13:33:41.631]                   NAME <- NAMES[[kk]]
[13:33:41.631]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.631]                     next
[13:33:41.631]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.631]                 }
[13:33:41.631]                 NAMES <- toupper(added)
[13:33:41.631]                 for (kk in seq_along(NAMES)) {
[13:33:41.631]                   name <- added[[kk]]
[13:33:41.631]                   NAME <- NAMES[[kk]]
[13:33:41.631]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.631]                     next
[13:33:41.631]                   args[[name]] <- ""
[13:33:41.631]                 }
[13:33:41.631]                 NAMES <- toupper(removed)
[13:33:41.631]                 for (kk in seq_along(NAMES)) {
[13:33:41.631]                   name <- removed[[kk]]
[13:33:41.631]                   NAME <- NAMES[[kk]]
[13:33:41.631]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.631]                     next
[13:33:41.631]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.631]                 }
[13:33:41.631]                 if (length(args) > 0) 
[13:33:41.631]                   base::do.call(base::Sys.setenv, args = args)
[13:33:41.631]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:41.631]             }
[13:33:41.631]             else {
[13:33:41.631]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:41.631]             }
[13:33:41.631]             {
[13:33:41.631]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:41.631]                   0L) {
[13:33:41.631]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:41.631]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:41.631]                   base::options(opts)
[13:33:41.631]                 }
[13:33:41.631]                 {
[13:33:41.631]                   {
[13:33:41.631]                     NULL
[13:33:41.631]                     RNGkind("Mersenne-Twister")
[13:33:41.631]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:41.631]                       inherits = FALSE)
[13:33:41.631]                   }
[13:33:41.631]                   options(future.plan = NULL)
[13:33:41.631]                   if (is.na(NA_character_)) 
[13:33:41.631]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.631]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:41.631]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:41.631]                     .init = FALSE)
[13:33:41.631]                 }
[13:33:41.631]             }
[13:33:41.631]         }
[13:33:41.631]     })
[13:33:41.631]     if (TRUE) {
[13:33:41.631]         base::sink(type = "output", split = FALSE)
[13:33:41.631]         if (TRUE) {
[13:33:41.631]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:41.631]         }
[13:33:41.631]         else {
[13:33:41.631]             ...future.result["stdout"] <- base::list(NULL)
[13:33:41.631]         }
[13:33:41.631]         base::close(...future.stdout)
[13:33:41.631]         ...future.stdout <- NULL
[13:33:41.631]     }
[13:33:41.631]     ...future.result$conditions <- ...future.conditions
[13:33:41.631]     ...future.result$finished <- base::Sys.time()
[13:33:41.631]     ...future.result
[13:33:41.631] }
[13:33:41.633] assign_globals() ...
[13:33:41.633] List of 7
[13:33:41.633]  $ ...future.FUN            :function (x)  
[13:33:41.633]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:33:41.633]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:41.633]  $ future.call.arguments    : list()
[13:33:41.633]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.633]  $ ...future.elements_ii    :List of 3
[13:33:41.633]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.633]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:33:41.633]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.633]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:41.633]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.633]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:33:41.633]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.633]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:33:41.633]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.633]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:33:41.633]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.633]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:33:41.633]  $ ...future.seeds_ii       : NULL
[13:33:41.633]  $ ...future.globals.maxSize: NULL
[13:33:41.633]  - attr(*, "where")=List of 7
[13:33:41.633]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:41.633]   ..$ breaks                   :<environment: R_EmptyEnv> 
[13:33:41.633]   ..$ wool                     :<environment: R_EmptyEnv> 
[13:33:41.633]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:41.633]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:41.633]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:41.633]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:41.633]  - attr(*, "resolved")= logi FALSE
[13:33:41.633]  - attr(*, "total_size")= num 2320
[13:33:41.633]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.633]  - attr(*, "already-done")= logi TRUE
[13:33:41.642] - reassign environment for ‘...future.FUN’
[13:33:41.642] - copied ‘...future.FUN’ to environment
[13:33:41.642] - copied ‘breaks’ to environment
[13:33:41.642] - copied ‘wool’ to environment
[13:33:41.642] - copied ‘future.call.arguments’ to environment
[13:33:41.642] - copied ‘...future.elements_ii’ to environment
[13:33:41.642] - copied ‘...future.seeds_ii’ to environment
[13:33:41.642] - copied ‘...future.globals.maxSize’ to environment
[13:33:41.642] assign_globals() ... done
[13:33:41.643] plan(): Setting new future strategy stack:
[13:33:41.643] List of future strategies:
[13:33:41.643] 1. sequential:
[13:33:41.643]    - args: function (..., envir = parent.frame())
[13:33:41.643]    - tweaked: FALSE
[13:33:41.643]    - call: NULL
[13:33:41.643] plan(): nbrOfWorkers() = 1
[13:33:41.646] plan(): Setting new future strategy stack:
[13:33:41.647] List of future strategies:
[13:33:41.647] 1. sequential:
[13:33:41.647]    - args: function (..., envir = parent.frame())
[13:33:41.647]    - tweaked: FALSE
[13:33:41.647]    - call: plan(strategy)
[13:33:41.647] plan(): nbrOfWorkers() = 1
[13:33:41.647] SequentialFuture started (and completed)
[13:33:41.648] - Launch lazy future ... done
[13:33:41.648] run() for ‘SequentialFuture’ ... done
[13:33:41.648] Created future:
[13:33:41.648] SequentialFuture:
[13:33:41.648] Label: ‘future_by-1’
[13:33:41.648] Expression:
[13:33:41.648] {
[13:33:41.648]     do.call(function(...) {
[13:33:41.648]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.648]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.648]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.648]             on.exit(options(oopts), add = TRUE)
[13:33:41.648]         }
[13:33:41.648]         {
[13:33:41.648]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.648]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.648]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.648]             })
[13:33:41.648]         }
[13:33:41.648]     }, args = future.call.arguments)
[13:33:41.648] }
[13:33:41.648] Lazy evaluation: FALSE
[13:33:41.648] Asynchronous evaluation: FALSE
[13:33:41.648] Local evaluation: TRUE
[13:33:41.648] Environment: 0x55cb80a67fa0
[13:33:41.648] Capture standard output: TRUE
[13:33:41.648] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:41.648] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[13:33:41.648] Packages: 1 packages (‘stats’)
[13:33:41.648] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:41.648] Resolved: TRUE
[13:33:41.648] Value: 25.57 KiB of class ‘list’
[13:33:41.648] Early signaling: FALSE
[13:33:41.648] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:41.648] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.649] Chunk #1 of 1 ... DONE
[13:33:41.649] Launching 1 futures (chunks) ... DONE
[13:33:41.650] Resolving 1 futures (chunks) ...
[13:33:41.650] resolve() on list ...
[13:33:41.650]  recursive: 0
[13:33:41.650]  length: 1
[13:33:41.650] 
[13:33:41.650] resolved() for ‘SequentialFuture’ ...
[13:33:41.650] - state: ‘finished’
[13:33:41.650] - run: TRUE
[13:33:41.650] - result: ‘FutureResult’
[13:33:41.650] resolved() for ‘SequentialFuture’ ... done
[13:33:41.650] Future #1
[13:33:41.651] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:41.651] - nx: 1
[13:33:41.651] - relay: TRUE
[13:33:41.651] - stdout: TRUE
[13:33:41.651] - signal: TRUE
[13:33:41.651] - resignal: FALSE
[13:33:41.651] - force: TRUE
[13:33:41.651] - relayed: [n=1] FALSE
[13:33:41.651] - queued futures: [n=1] FALSE
[13:33:41.651]  - until=1
[13:33:41.651]  - relaying element #1
[13:33:41.652] - relayed: [n=1] TRUE
[13:33:41.652] - queued futures: [n=1] TRUE
[13:33:41.652] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:41.652]  length: 0 (resolved future 1)
[13:33:41.652] Relaying remaining futures
[13:33:41.652] signalConditionsASAP(NULL, pos=0) ...
[13:33:41.652] - nx: 1
[13:33:41.652] - relay: TRUE
[13:33:41.652] - stdout: TRUE
[13:33:41.652] - signal: TRUE
[13:33:41.652] - resignal: FALSE
[13:33:41.653] - force: TRUE
[13:33:41.653] - relayed: [n=1] TRUE
[13:33:41.653] - queued futures: [n=1] TRUE
 - flush all
[13:33:41.653] - relayed: [n=1] TRUE
[13:33:41.653] - queued futures: [n=1] TRUE
[13:33:41.653] signalConditionsASAP(NULL, pos=0) ... done
[13:33:41.653] resolve() on list ... DONE
[13:33:41.653]  - Number of value chunks collected: 1
[13:33:41.653] Resolving 1 futures (chunks) ... DONE
[13:33:41.653] Reducing values from 1 chunks ...
[13:33:41.653]  - Number of values collected after concatenation: 3
[13:33:41.654]  - Number of values expected: 3
[13:33:41.654] Reducing values from 1 chunks ... DONE
[13:33:41.654] future_lapply() ... DONE
[13:33:41.654] future_by_internal() ... DONE
[13:33:41.654] future_by_internal() ...
[13:33:41.654] future_lapply() ...
[13:33:41.655] Number of chunks: 1
[13:33:41.655] getGlobalsAndPackagesXApply() ...
[13:33:41.655]  - future.globals: TRUE
[13:33:41.655] getGlobalsAndPackages() ...
[13:33:41.655] Searching for globals...
[13:33:41.656] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:41.656] Searching for globals ... DONE
[13:33:41.656] Resolving globals: FALSE
[13:33:41.657] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:41.657] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:41.657] - globals: [1] ‘FUN’
[13:33:41.657] 
[13:33:41.657] getGlobalsAndPackages() ... DONE
[13:33:41.657]  - globals found/used: [n=1] ‘FUN’
[13:33:41.657]  - needed namespaces: [n=0] 
[13:33:41.658] Finding globals ... DONE
[13:33:41.658]  - use_args: TRUE
[13:33:41.658]  - Getting '...' globals ...
[13:33:41.658] resolve() on list ...
[13:33:41.658]  recursive: 0
[13:33:41.658]  length: 1
[13:33:41.658]  elements: ‘...’
[13:33:41.658]  length: 0 (resolved future 1)
[13:33:41.658] resolve() on list ... DONE
[13:33:41.659]    - '...' content: [n=0] 
[13:33:41.659] List of 1
[13:33:41.659]  $ ...: list()
[13:33:41.659]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.659]  - attr(*, "where")=List of 1
[13:33:41.659]   ..$ ...:<environment: 0x55cb801a1dd0> 
[13:33:41.659]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.659]  - attr(*, "resolved")= logi TRUE
[13:33:41.659]  - attr(*, "total_size")= num NA
[13:33:41.661]  - Getting '...' globals ... DONE
[13:33:41.661] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:41.661] List of 2
[13:33:41.661]  $ ...future.FUN:function (object, ...)  
[13:33:41.661]  $ ...          : list()
[13:33:41.661]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.661]  - attr(*, "where")=List of 2
[13:33:41.661]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:41.661]   ..$ ...          :<environment: 0x55cb801a1dd0> 
[13:33:41.661]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.661]  - attr(*, "resolved")= logi FALSE
[13:33:41.661]  - attr(*, "total_size")= num 1240
[13:33:41.664] Packages to be attached in all futures: [n=0] 
[13:33:41.665] getGlobalsAndPackagesXApply() ... DONE
[13:33:41.665] Number of futures (= number of chunks): 1
[13:33:41.665] Launching 1 futures (chunks) ...
[13:33:41.665] Chunk #1 of 1 ...
[13:33:41.665]  - Finding globals in 'X' for chunk #1 ...
[13:33:41.665] getGlobalsAndPackages() ...
[13:33:41.665] Searching for globals...
[13:33:41.666] 
[13:33:41.666] Searching for globals ... DONE
[13:33:41.666] - globals: [0] <none>
[13:33:41.666] getGlobalsAndPackages() ... DONE
[13:33:41.666]    + additional globals found: [n=0] 
[13:33:41.666]    + additional namespaces needed: [n=0] 
[13:33:41.666]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:41.666]  - seeds: <none>
[13:33:41.666]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.666] getGlobalsAndPackages() ...
[13:33:41.667] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.667] Resolving globals: FALSE
[13:33:41.667] Tweak future expression to call with '...' arguments ...
[13:33:41.667] {
[13:33:41.667]     do.call(function(...) {
[13:33:41.667]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.667]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.667]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.667]             on.exit(options(oopts), add = TRUE)
[13:33:41.667]         }
[13:33:41.667]         {
[13:33:41.667]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.667]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.667]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.667]             })
[13:33:41.667]         }
[13:33:41.667]     }, args = future.call.arguments)
[13:33:41.667] }
[13:33:41.667] Tweak future expression to call with '...' arguments ... DONE
[13:33:41.667] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.668] 
[13:33:41.668] getGlobalsAndPackages() ... DONE
[13:33:41.668] run() for ‘Future’ ...
[13:33:41.668] - state: ‘created’
[13:33:41.668] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:33:41.668] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.668] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:41.669]   - Field: ‘label’
[13:33:41.669]   - Field: ‘local’
[13:33:41.669]   - Field: ‘owner’
[13:33:41.669]   - Field: ‘envir’
[13:33:41.669]   - Field: ‘packages’
[13:33:41.669]   - Field: ‘gc’
[13:33:41.669]   - Field: ‘conditions’
[13:33:41.669]   - Field: ‘expr’
[13:33:41.669]   - Field: ‘uuid’
[13:33:41.669]   - Field: ‘seed’
[13:33:41.669]   - Field: ‘version’
[13:33:41.670]   - Field: ‘result’
[13:33:41.670]   - Field: ‘asynchronous’
[13:33:41.670]   - Field: ‘calls’
[13:33:41.670]   - Field: ‘globals’
[13:33:41.670]   - Field: ‘stdout’
[13:33:41.670]   - Field: ‘earlySignal’
[13:33:41.670]   - Field: ‘lazy’
[13:33:41.670]   - Field: ‘state’
[13:33:41.670] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:41.670] - Launch lazy future ...
[13:33:41.670] Packages needed by the future expression (n = 0): <none>
[13:33:41.671] Packages needed by future strategies (n = 0): <none>
[13:33:41.671] {
[13:33:41.671]     {
[13:33:41.671]         {
[13:33:41.671]             ...future.startTime <- base::Sys.time()
[13:33:41.671]             {
[13:33:41.671]                 {
[13:33:41.671]                   {
[13:33:41.671]                     base::local({
[13:33:41.671]                       has_future <- base::requireNamespace("future", 
[13:33:41.671]                         quietly = TRUE)
[13:33:41.671]                       if (has_future) {
[13:33:41.671]                         ns <- base::getNamespace("future")
[13:33:41.671]                         version <- ns[[".package"]][["version"]]
[13:33:41.671]                         if (is.null(version)) 
[13:33:41.671]                           version <- utils::packageVersion("future")
[13:33:41.671]                       }
[13:33:41.671]                       else {
[13:33:41.671]                         version <- NULL
[13:33:41.671]                       }
[13:33:41.671]                       if (!has_future || version < "1.8.0") {
[13:33:41.671]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:41.671]                           "", base::R.version$version.string), 
[13:33:41.671]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:41.671]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:41.671]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:41.671]                             "release", "version")], collapse = " "), 
[13:33:41.671]                           hostname = base::Sys.info()[["nodename"]])
[13:33:41.671]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:41.671]                           info)
[13:33:41.671]                         info <- base::paste(info, collapse = "; ")
[13:33:41.671]                         if (!has_future) {
[13:33:41.671]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:41.671]                             info)
[13:33:41.671]                         }
[13:33:41.671]                         else {
[13:33:41.671]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:41.671]                             info, version)
[13:33:41.671]                         }
[13:33:41.671]                         base::stop(msg)
[13:33:41.671]                       }
[13:33:41.671]                     })
[13:33:41.671]                   }
[13:33:41.671]                   ...future.strategy.old <- future::plan("list")
[13:33:41.671]                   options(future.plan = NULL)
[13:33:41.671]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.671]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:41.671]                 }
[13:33:41.671]                 ...future.workdir <- getwd()
[13:33:41.671]             }
[13:33:41.671]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:41.671]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:41.671]         }
[13:33:41.671]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:41.671]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:41.671]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:41.671]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:41.671]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:41.671]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:41.671]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:41.671]             base::names(...future.oldOptions))
[13:33:41.671]     }
[13:33:41.671]     if (FALSE) {
[13:33:41.671]     }
[13:33:41.671]     else {
[13:33:41.671]         if (TRUE) {
[13:33:41.671]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:41.671]                 open = "w")
[13:33:41.671]         }
[13:33:41.671]         else {
[13:33:41.671]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:41.671]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:41.671]         }
[13:33:41.671]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:41.671]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:41.671]             base::sink(type = "output", split = FALSE)
[13:33:41.671]             base::close(...future.stdout)
[13:33:41.671]         }, add = TRUE)
[13:33:41.671]     }
[13:33:41.671]     ...future.frame <- base::sys.nframe()
[13:33:41.671]     ...future.conditions <- base::list()
[13:33:41.671]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:41.671]     if (FALSE) {
[13:33:41.671]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:41.671]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:41.671]     }
[13:33:41.671]     ...future.result <- base::tryCatch({
[13:33:41.671]         base::withCallingHandlers({
[13:33:41.671]             ...future.value <- base::withVisible(base::local({
[13:33:41.671]                 do.call(function(...) {
[13:33:41.671]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.671]                   if (!identical(...future.globals.maxSize.org, 
[13:33:41.671]                     ...future.globals.maxSize)) {
[13:33:41.671]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.671]                     on.exit(options(oopts), add = TRUE)
[13:33:41.671]                   }
[13:33:41.671]                   {
[13:33:41.671]                     lapply(seq_along(...future.elements_ii), 
[13:33:41.671]                       FUN = function(jj) {
[13:33:41.671]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.671]                         ...future.FUN(...future.X_jj, ...)
[13:33:41.671]                       })
[13:33:41.671]                   }
[13:33:41.671]                 }, args = future.call.arguments)
[13:33:41.671]             }))
[13:33:41.671]             future::FutureResult(value = ...future.value$value, 
[13:33:41.671]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.671]                   ...future.rng), globalenv = if (FALSE) 
[13:33:41.671]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:41.671]                     ...future.globalenv.names))
[13:33:41.671]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:41.671]         }, condition = base::local({
[13:33:41.671]             c <- base::c
[13:33:41.671]             inherits <- base::inherits
[13:33:41.671]             invokeRestart <- base::invokeRestart
[13:33:41.671]             length <- base::length
[13:33:41.671]             list <- base::list
[13:33:41.671]             seq.int <- base::seq.int
[13:33:41.671]             signalCondition <- base::signalCondition
[13:33:41.671]             sys.calls <- base::sys.calls
[13:33:41.671]             `[[` <- base::`[[`
[13:33:41.671]             `+` <- base::`+`
[13:33:41.671]             `<<-` <- base::`<<-`
[13:33:41.671]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:41.671]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:41.671]                   3L)]
[13:33:41.671]             }
[13:33:41.671]             function(cond) {
[13:33:41.671]                 is_error <- inherits(cond, "error")
[13:33:41.671]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:41.671]                   NULL)
[13:33:41.671]                 if (is_error) {
[13:33:41.671]                   sessionInformation <- function() {
[13:33:41.671]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:41.671]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:41.671]                       search = base::search(), system = base::Sys.info())
[13:33:41.671]                   }
[13:33:41.671]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.671]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:41.671]                     cond$call), session = sessionInformation(), 
[13:33:41.671]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:41.671]                   signalCondition(cond)
[13:33:41.671]                 }
[13:33:41.671]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:41.671]                 "immediateCondition"))) {
[13:33:41.671]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:41.671]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.671]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:41.671]                   if (TRUE && !signal) {
[13:33:41.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.671]                     {
[13:33:41.671]                       inherits <- base::inherits
[13:33:41.671]                       invokeRestart <- base::invokeRestart
[13:33:41.671]                       is.null <- base::is.null
[13:33:41.671]                       muffled <- FALSE
[13:33:41.671]                       if (inherits(cond, "message")) {
[13:33:41.671]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.671]                         if (muffled) 
[13:33:41.671]                           invokeRestart("muffleMessage")
[13:33:41.671]                       }
[13:33:41.671]                       else if (inherits(cond, "warning")) {
[13:33:41.671]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.671]                         if (muffled) 
[13:33:41.671]                           invokeRestart("muffleWarning")
[13:33:41.671]                       }
[13:33:41.671]                       else if (inherits(cond, "condition")) {
[13:33:41.671]                         if (!is.null(pattern)) {
[13:33:41.671]                           computeRestarts <- base::computeRestarts
[13:33:41.671]                           grepl <- base::grepl
[13:33:41.671]                           restarts <- computeRestarts(cond)
[13:33:41.671]                           for (restart in restarts) {
[13:33:41.671]                             name <- restart$name
[13:33:41.671]                             if (is.null(name)) 
[13:33:41.671]                               next
[13:33:41.671]                             if (!grepl(pattern, name)) 
[13:33:41.671]                               next
[13:33:41.671]                             invokeRestart(restart)
[13:33:41.671]                             muffled <- TRUE
[13:33:41.671]                             break
[13:33:41.671]                           }
[13:33:41.671]                         }
[13:33:41.671]                       }
[13:33:41.671]                       invisible(muffled)
[13:33:41.671]                     }
[13:33:41.671]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.671]                   }
[13:33:41.671]                 }
[13:33:41.671]                 else {
[13:33:41.671]                   if (TRUE) {
[13:33:41.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.671]                     {
[13:33:41.671]                       inherits <- base::inherits
[13:33:41.671]                       invokeRestart <- base::invokeRestart
[13:33:41.671]                       is.null <- base::is.null
[13:33:41.671]                       muffled <- FALSE
[13:33:41.671]                       if (inherits(cond, "message")) {
[13:33:41.671]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.671]                         if (muffled) 
[13:33:41.671]                           invokeRestart("muffleMessage")
[13:33:41.671]                       }
[13:33:41.671]                       else if (inherits(cond, "warning")) {
[13:33:41.671]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.671]                         if (muffled) 
[13:33:41.671]                           invokeRestart("muffleWarning")
[13:33:41.671]                       }
[13:33:41.671]                       else if (inherits(cond, "condition")) {
[13:33:41.671]                         if (!is.null(pattern)) {
[13:33:41.671]                           computeRestarts <- base::computeRestarts
[13:33:41.671]                           grepl <- base::grepl
[13:33:41.671]                           restarts <- computeRestarts(cond)
[13:33:41.671]                           for (restart in restarts) {
[13:33:41.671]                             name <- restart$name
[13:33:41.671]                             if (is.null(name)) 
[13:33:41.671]                               next
[13:33:41.671]                             if (!grepl(pattern, name)) 
[13:33:41.671]                               next
[13:33:41.671]                             invokeRestart(restart)
[13:33:41.671]                             muffled <- TRUE
[13:33:41.671]                             break
[13:33:41.671]                           }
[13:33:41.671]                         }
[13:33:41.671]                       }
[13:33:41.671]                       invisible(muffled)
[13:33:41.671]                     }
[13:33:41.671]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.671]                   }
[13:33:41.671]                 }
[13:33:41.671]             }
[13:33:41.671]         }))
[13:33:41.671]     }, error = function(ex) {
[13:33:41.671]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:41.671]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.671]                 ...future.rng), started = ...future.startTime, 
[13:33:41.671]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:41.671]             version = "1.8"), class = "FutureResult")
[13:33:41.671]     }, finally = {
[13:33:41.671]         if (!identical(...future.workdir, getwd())) 
[13:33:41.671]             setwd(...future.workdir)
[13:33:41.671]         {
[13:33:41.671]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:41.671]                 ...future.oldOptions$nwarnings <- NULL
[13:33:41.671]             }
[13:33:41.671]             base::options(...future.oldOptions)
[13:33:41.671]             if (.Platform$OS.type == "windows") {
[13:33:41.671]                 old_names <- names(...future.oldEnvVars)
[13:33:41.671]                 envs <- base::Sys.getenv()
[13:33:41.671]                 names <- names(envs)
[13:33:41.671]                 common <- intersect(names, old_names)
[13:33:41.671]                 added <- setdiff(names, old_names)
[13:33:41.671]                 removed <- setdiff(old_names, names)
[13:33:41.671]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:41.671]                   envs[common]]
[13:33:41.671]                 NAMES <- toupper(changed)
[13:33:41.671]                 args <- list()
[13:33:41.671]                 for (kk in seq_along(NAMES)) {
[13:33:41.671]                   name <- changed[[kk]]
[13:33:41.671]                   NAME <- NAMES[[kk]]
[13:33:41.671]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.671]                     next
[13:33:41.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.671]                 }
[13:33:41.671]                 NAMES <- toupper(added)
[13:33:41.671]                 for (kk in seq_along(NAMES)) {
[13:33:41.671]                   name <- added[[kk]]
[13:33:41.671]                   NAME <- NAMES[[kk]]
[13:33:41.671]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.671]                     next
[13:33:41.671]                   args[[name]] <- ""
[13:33:41.671]                 }
[13:33:41.671]                 NAMES <- toupper(removed)
[13:33:41.671]                 for (kk in seq_along(NAMES)) {
[13:33:41.671]                   name <- removed[[kk]]
[13:33:41.671]                   NAME <- NAMES[[kk]]
[13:33:41.671]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.671]                     next
[13:33:41.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.671]                 }
[13:33:41.671]                 if (length(args) > 0) 
[13:33:41.671]                   base::do.call(base::Sys.setenv, args = args)
[13:33:41.671]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:41.671]             }
[13:33:41.671]             else {
[13:33:41.671]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:41.671]             }
[13:33:41.671]             {
[13:33:41.671]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:41.671]                   0L) {
[13:33:41.671]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:41.671]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:41.671]                   base::options(opts)
[13:33:41.671]                 }
[13:33:41.671]                 {
[13:33:41.671]                   {
[13:33:41.671]                     NULL
[13:33:41.671]                     RNGkind("Mersenne-Twister")
[13:33:41.671]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:41.671]                       inherits = FALSE)
[13:33:41.671]                   }
[13:33:41.671]                   options(future.plan = NULL)
[13:33:41.671]                   if (is.na(NA_character_)) 
[13:33:41.671]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.671]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:41.671]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:41.671]                     .init = FALSE)
[13:33:41.671]                 }
[13:33:41.671]             }
[13:33:41.671]         }
[13:33:41.671]     })
[13:33:41.671]     if (TRUE) {
[13:33:41.671]         base::sink(type = "output", split = FALSE)
[13:33:41.671]         if (TRUE) {
[13:33:41.671]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:41.671]         }
[13:33:41.671]         else {
[13:33:41.671]             ...future.result["stdout"] <- base::list(NULL)
[13:33:41.671]         }
[13:33:41.671]         base::close(...future.stdout)
[13:33:41.671]         ...future.stdout <- NULL
[13:33:41.671]     }
[13:33:41.671]     ...future.result$conditions <- ...future.conditions
[13:33:41.671]     ...future.result$finished <- base::Sys.time()
[13:33:41.671]     ...future.result
[13:33:41.671] }
[13:33:41.673] assign_globals() ...
[13:33:41.673] List of 5
[13:33:41.673]  $ ...future.FUN            :function (object, ...)  
[13:33:41.673]  $ future.call.arguments    : list()
[13:33:41.673]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.673]  $ ...future.elements_ii    :List of 3
[13:33:41.673]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.673]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:33:41.673]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.673]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:41.673]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.673]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:33:41.673]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.673]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:33:41.673]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.673]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:33:41.673]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.673]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:33:41.673]  $ ...future.seeds_ii       : NULL
[13:33:41.673]  $ ...future.globals.maxSize: NULL
[13:33:41.673]  - attr(*, "where")=List of 5
[13:33:41.673]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:41.673]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:41.673]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:41.673]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:41.673]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:41.673]  - attr(*, "resolved")= logi FALSE
[13:33:41.673]  - attr(*, "total_size")= num 1240
[13:33:41.673]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.673]  - attr(*, "already-done")= logi TRUE
[13:33:41.680] - copied ‘...future.FUN’ to environment
[13:33:41.681] - copied ‘future.call.arguments’ to environment
[13:33:41.681] - copied ‘...future.elements_ii’ to environment
[13:33:41.681] - copied ‘...future.seeds_ii’ to environment
[13:33:41.681] - copied ‘...future.globals.maxSize’ to environment
[13:33:41.681] assign_globals() ... done
[13:33:41.681] plan(): Setting new future strategy stack:
[13:33:41.681] List of future strategies:
[13:33:41.681] 1. sequential:
[13:33:41.681]    - args: function (..., envir = parent.frame())
[13:33:41.681]    - tweaked: FALSE
[13:33:41.681]    - call: NULL
[13:33:41.682] plan(): nbrOfWorkers() = 1
[13:33:41.684] plan(): Setting new future strategy stack:
[13:33:41.685] List of future strategies:
[13:33:41.685] 1. sequential:
[13:33:41.685]    - args: function (..., envir = parent.frame())
[13:33:41.685]    - tweaked: FALSE
[13:33:41.685]    - call: plan(strategy)
[13:33:41.685] plan(): nbrOfWorkers() = 1
[13:33:41.685] SequentialFuture started (and completed)
[13:33:41.685] - Launch lazy future ... done
[13:33:41.685] run() for ‘SequentialFuture’ ... done
[13:33:41.685] Created future:
[13:33:41.685] SequentialFuture:
[13:33:41.685] Label: ‘future_by-1’
[13:33:41.685] Expression:
[13:33:41.685] {
[13:33:41.685]     do.call(function(...) {
[13:33:41.685]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.685]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.685]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.685]             on.exit(options(oopts), add = TRUE)
[13:33:41.685]         }
[13:33:41.685]         {
[13:33:41.685]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.685]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.685]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.685]             })
[13:33:41.685]         }
[13:33:41.685]     }, args = future.call.arguments)
[13:33:41.685] }
[13:33:41.685] Lazy evaluation: FALSE
[13:33:41.685] Asynchronous evaluation: FALSE
[13:33:41.685] Local evaluation: TRUE
[13:33:41.685] Environment: 0x55cb8029ee20
[13:33:41.685] Capture standard output: TRUE
[13:33:41.685] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:41.685] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:41.685] Packages: <none>
[13:33:41.685] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:41.685] Resolved: TRUE
[13:33:41.685] Value: 5.37 KiB of class ‘list’
[13:33:41.685] Early signaling: FALSE
[13:33:41.685] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:41.685] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.687] Chunk #1 of 1 ... DONE
[13:33:41.687] Launching 1 futures (chunks) ... DONE
[13:33:41.687] Resolving 1 futures (chunks) ...
[13:33:41.687] resolve() on list ...
[13:33:41.687]  recursive: 0
[13:33:41.687]  length: 1
[13:33:41.687] 
[13:33:41.687] resolved() for ‘SequentialFuture’ ...
[13:33:41.687] - state: ‘finished’
[13:33:41.687] - run: TRUE
[13:33:41.688] - result: ‘FutureResult’
[13:33:41.688] resolved() for ‘SequentialFuture’ ... done
[13:33:41.688] Future #1
[13:33:41.688] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:41.688] - nx: 1
[13:33:41.688] - relay: TRUE
[13:33:41.688] - stdout: TRUE
[13:33:41.688] - signal: TRUE
[13:33:41.688] - resignal: FALSE
[13:33:41.688] - force: TRUE
[13:33:41.688] - relayed: [n=1] FALSE
[13:33:41.688] - queued futures: [n=1] FALSE
[13:33:41.689]  - until=1
[13:33:41.689]  - relaying element #1
[13:33:41.689] - relayed: [n=1] TRUE
[13:33:41.689] - queued futures: [n=1] TRUE
[13:33:41.689] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:41.689]  length: 0 (resolved future 1)
[13:33:41.689] Relaying remaining futures
[13:33:41.689] signalConditionsASAP(NULL, pos=0) ...
[13:33:41.689] - nx: 1
[13:33:41.689] - relay: TRUE
[13:33:41.689] - stdout: TRUE
[13:33:41.690] - signal: TRUE
[13:33:41.690] - resignal: FALSE
[13:33:41.690] - force: TRUE
[13:33:41.690] - relayed: [n=1] TRUE
[13:33:41.690] - queued futures: [n=1] TRUE
 - flush all
[13:33:41.690] - relayed: [n=1] TRUE
[13:33:41.690] - queued futures: [n=1] TRUE
[13:33:41.690] signalConditionsASAP(NULL, pos=0) ... done
[13:33:41.690] resolve() on list ... DONE
[13:33:41.690]  - Number of value chunks collected: 1
[13:33:41.690] Resolving 1 futures (chunks) ... DONE
[13:33:41.691] Reducing values from 1 chunks ...
[13:33:41.691]  - Number of values collected after concatenation: 3
[13:33:41.691]  - Number of values expected: 3
[13:33:41.691] Reducing values from 1 chunks ... DONE
[13:33:41.691] future_lapply() ... DONE
[13:33:41.691] future_by_internal() ... DONE
[13:33:41.692] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[13:33:41.692] future_lapply() ...
[13:33:41.693] Number of chunks: 1
[13:33:41.693] getGlobalsAndPackagesXApply() ...
[13:33:41.693]  - future.globals: TRUE
[13:33:41.693] getGlobalsAndPackages() ...
[13:33:41.693] Searching for globals...
[13:33:41.694] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:41.694] Searching for globals ... DONE
[13:33:41.694] Resolving globals: FALSE
[13:33:41.694] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:41.695] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:41.695] - globals: [1] ‘FUN’
[13:33:41.695] 
[13:33:41.695] getGlobalsAndPackages() ... DONE
[13:33:41.695]  - globals found/used: [n=1] ‘FUN’
[13:33:41.695]  - needed namespaces: [n=0] 
[13:33:41.695] Finding globals ... DONE
[13:33:41.695]  - use_args: TRUE
[13:33:41.695]  - Getting '...' globals ...
[13:33:41.696] resolve() on list ...
[13:33:41.696]  recursive: 0
[13:33:41.696]  length: 1
[13:33:41.696]  elements: ‘...’
[13:33:41.696]  length: 0 (resolved future 1)
[13:33:41.696] resolve() on list ... DONE
[13:33:41.696]    - '...' content: [n=0] 
[13:33:41.696] List of 1
[13:33:41.696]  $ ...: list()
[13:33:41.696]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.696]  - attr(*, "where")=List of 1
[13:33:41.696]   ..$ ...:<environment: 0x55cb81bd0e78> 
[13:33:41.696]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.696]  - attr(*, "resolved")= logi TRUE
[13:33:41.696]  - attr(*, "total_size")= num NA
[13:33:41.699]  - Getting '...' globals ... DONE
[13:33:41.699] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:41.699] List of 2
[13:33:41.699]  $ ...future.FUN:function (object, ...)  
[13:33:41.699]  $ ...          : list()
[13:33:41.699]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.699]  - attr(*, "where")=List of 2
[13:33:41.699]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:41.699]   ..$ ...          :<environment: 0x55cb81bd0e78> 
[13:33:41.699]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.699]  - attr(*, "resolved")= logi FALSE
[13:33:41.699]  - attr(*, "total_size")= num 1240
[13:33:41.702] Packages to be attached in all futures: [n=0] 
[13:33:41.702] getGlobalsAndPackagesXApply() ... DONE
[13:33:41.703] Number of futures (= number of chunks): 1
[13:33:41.703] Launching 1 futures (chunks) ...
[13:33:41.703] Chunk #1 of 1 ...
[13:33:41.703]  - Finding globals in 'X' for chunk #1 ...
[13:33:41.703] getGlobalsAndPackages() ...
[13:33:41.703] Searching for globals...
[13:33:41.703] 
[13:33:41.704] Searching for globals ... DONE
[13:33:41.704] - globals: [0] <none>
[13:33:41.704] getGlobalsAndPackages() ... DONE
[13:33:41.704]    + additional globals found: [n=0] 
[13:33:41.704]    + additional namespaces needed: [n=0] 
[13:33:41.704]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:41.704]  - seeds: <none>
[13:33:41.704]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.704] getGlobalsAndPackages() ...
[13:33:41.704] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.704] Resolving globals: FALSE
[13:33:41.705] Tweak future expression to call with '...' arguments ...
[13:33:41.705] {
[13:33:41.705]     do.call(function(...) {
[13:33:41.705]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.705]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.705]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.705]             on.exit(options(oopts), add = TRUE)
[13:33:41.705]         }
[13:33:41.705]         {
[13:33:41.705]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.705]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.705]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.705]             })
[13:33:41.705]         }
[13:33:41.705]     }, args = future.call.arguments)
[13:33:41.705] }
[13:33:41.705] Tweak future expression to call with '...' arguments ... DONE
[13:33:41.705] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.705] 
[13:33:41.705] getGlobalsAndPackages() ... DONE
[13:33:41.706] run() for ‘Future’ ...
[13:33:41.706] - state: ‘created’
[13:33:41.706] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:33:41.706] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.706] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:41.706]   - Field: ‘label’
[13:33:41.706]   - Field: ‘local’
[13:33:41.706]   - Field: ‘owner’
[13:33:41.707]   - Field: ‘envir’
[13:33:41.707]   - Field: ‘packages’
[13:33:41.707]   - Field: ‘gc’
[13:33:41.707]   - Field: ‘conditions’
[13:33:41.707]   - Field: ‘expr’
[13:33:41.707]   - Field: ‘uuid’
[13:33:41.707]   - Field: ‘seed’
[13:33:41.707]   - Field: ‘version’
[13:33:41.707]   - Field: ‘result’
[13:33:41.707]   - Field: ‘asynchronous’
[13:33:41.707]   - Field: ‘calls’
[13:33:41.707]   - Field: ‘globals’
[13:33:41.708]   - Field: ‘stdout’
[13:33:41.708]   - Field: ‘earlySignal’
[13:33:41.708]   - Field: ‘lazy’
[13:33:41.708]   - Field: ‘state’
[13:33:41.708] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:41.708] - Launch lazy future ...
[13:33:41.708] Packages needed by the future expression (n = 0): <none>
[13:33:41.708] Packages needed by future strategies (n = 0): <none>
[13:33:41.709] {
[13:33:41.709]     {
[13:33:41.709]         {
[13:33:41.709]             ...future.startTime <- base::Sys.time()
[13:33:41.709]             {
[13:33:41.709]                 {
[13:33:41.709]                   {
[13:33:41.709]                     base::local({
[13:33:41.709]                       has_future <- base::requireNamespace("future", 
[13:33:41.709]                         quietly = TRUE)
[13:33:41.709]                       if (has_future) {
[13:33:41.709]                         ns <- base::getNamespace("future")
[13:33:41.709]                         version <- ns[[".package"]][["version"]]
[13:33:41.709]                         if (is.null(version)) 
[13:33:41.709]                           version <- utils::packageVersion("future")
[13:33:41.709]                       }
[13:33:41.709]                       else {
[13:33:41.709]                         version <- NULL
[13:33:41.709]                       }
[13:33:41.709]                       if (!has_future || version < "1.8.0") {
[13:33:41.709]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:41.709]                           "", base::R.version$version.string), 
[13:33:41.709]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:41.709]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:41.709]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:41.709]                             "release", "version")], collapse = " "), 
[13:33:41.709]                           hostname = base::Sys.info()[["nodename"]])
[13:33:41.709]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:41.709]                           info)
[13:33:41.709]                         info <- base::paste(info, collapse = "; ")
[13:33:41.709]                         if (!has_future) {
[13:33:41.709]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:41.709]                             info)
[13:33:41.709]                         }
[13:33:41.709]                         else {
[13:33:41.709]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:41.709]                             info, version)
[13:33:41.709]                         }
[13:33:41.709]                         base::stop(msg)
[13:33:41.709]                       }
[13:33:41.709]                     })
[13:33:41.709]                   }
[13:33:41.709]                   ...future.strategy.old <- future::plan("list")
[13:33:41.709]                   options(future.plan = NULL)
[13:33:41.709]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.709]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:41.709]                 }
[13:33:41.709]                 ...future.workdir <- getwd()
[13:33:41.709]             }
[13:33:41.709]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:41.709]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:41.709]         }
[13:33:41.709]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:41.709]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:41.709]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:41.709]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:41.709]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:41.709]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:41.709]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:41.709]             base::names(...future.oldOptions))
[13:33:41.709]     }
[13:33:41.709]     if (FALSE) {
[13:33:41.709]     }
[13:33:41.709]     else {
[13:33:41.709]         if (TRUE) {
[13:33:41.709]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:41.709]                 open = "w")
[13:33:41.709]         }
[13:33:41.709]         else {
[13:33:41.709]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:41.709]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:41.709]         }
[13:33:41.709]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:41.709]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:41.709]             base::sink(type = "output", split = FALSE)
[13:33:41.709]             base::close(...future.stdout)
[13:33:41.709]         }, add = TRUE)
[13:33:41.709]     }
[13:33:41.709]     ...future.frame <- base::sys.nframe()
[13:33:41.709]     ...future.conditions <- base::list()
[13:33:41.709]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:41.709]     if (FALSE) {
[13:33:41.709]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:41.709]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:41.709]     }
[13:33:41.709]     ...future.result <- base::tryCatch({
[13:33:41.709]         base::withCallingHandlers({
[13:33:41.709]             ...future.value <- base::withVisible(base::local({
[13:33:41.709]                 do.call(function(...) {
[13:33:41.709]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.709]                   if (!identical(...future.globals.maxSize.org, 
[13:33:41.709]                     ...future.globals.maxSize)) {
[13:33:41.709]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.709]                     on.exit(options(oopts), add = TRUE)
[13:33:41.709]                   }
[13:33:41.709]                   {
[13:33:41.709]                     lapply(seq_along(...future.elements_ii), 
[13:33:41.709]                       FUN = function(jj) {
[13:33:41.709]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.709]                         ...future.FUN(...future.X_jj, ...)
[13:33:41.709]                       })
[13:33:41.709]                   }
[13:33:41.709]                 }, args = future.call.arguments)
[13:33:41.709]             }))
[13:33:41.709]             future::FutureResult(value = ...future.value$value, 
[13:33:41.709]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.709]                   ...future.rng), globalenv = if (FALSE) 
[13:33:41.709]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:41.709]                     ...future.globalenv.names))
[13:33:41.709]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:41.709]         }, condition = base::local({
[13:33:41.709]             c <- base::c
[13:33:41.709]             inherits <- base::inherits
[13:33:41.709]             invokeRestart <- base::invokeRestart
[13:33:41.709]             length <- base::length
[13:33:41.709]             list <- base::list
[13:33:41.709]             seq.int <- base::seq.int
[13:33:41.709]             signalCondition <- base::signalCondition
[13:33:41.709]             sys.calls <- base::sys.calls
[13:33:41.709]             `[[` <- base::`[[`
[13:33:41.709]             `+` <- base::`+`
[13:33:41.709]             `<<-` <- base::`<<-`
[13:33:41.709]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:41.709]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:41.709]                   3L)]
[13:33:41.709]             }
[13:33:41.709]             function(cond) {
[13:33:41.709]                 is_error <- inherits(cond, "error")
[13:33:41.709]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:41.709]                   NULL)
[13:33:41.709]                 if (is_error) {
[13:33:41.709]                   sessionInformation <- function() {
[13:33:41.709]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:41.709]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:41.709]                       search = base::search(), system = base::Sys.info())
[13:33:41.709]                   }
[13:33:41.709]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.709]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:41.709]                     cond$call), session = sessionInformation(), 
[13:33:41.709]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:41.709]                   signalCondition(cond)
[13:33:41.709]                 }
[13:33:41.709]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:41.709]                 "immediateCondition"))) {
[13:33:41.709]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:41.709]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.709]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:41.709]                   if (TRUE && !signal) {
[13:33:41.709]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.709]                     {
[13:33:41.709]                       inherits <- base::inherits
[13:33:41.709]                       invokeRestart <- base::invokeRestart
[13:33:41.709]                       is.null <- base::is.null
[13:33:41.709]                       muffled <- FALSE
[13:33:41.709]                       if (inherits(cond, "message")) {
[13:33:41.709]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.709]                         if (muffled) 
[13:33:41.709]                           invokeRestart("muffleMessage")
[13:33:41.709]                       }
[13:33:41.709]                       else if (inherits(cond, "warning")) {
[13:33:41.709]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.709]                         if (muffled) 
[13:33:41.709]                           invokeRestart("muffleWarning")
[13:33:41.709]                       }
[13:33:41.709]                       else if (inherits(cond, "condition")) {
[13:33:41.709]                         if (!is.null(pattern)) {
[13:33:41.709]                           computeRestarts <- base::computeRestarts
[13:33:41.709]                           grepl <- base::grepl
[13:33:41.709]                           restarts <- computeRestarts(cond)
[13:33:41.709]                           for (restart in restarts) {
[13:33:41.709]                             name <- restart$name
[13:33:41.709]                             if (is.null(name)) 
[13:33:41.709]                               next
[13:33:41.709]                             if (!grepl(pattern, name)) 
[13:33:41.709]                               next
[13:33:41.709]                             invokeRestart(restart)
[13:33:41.709]                             muffled <- TRUE
[13:33:41.709]                             break
[13:33:41.709]                           }
[13:33:41.709]                         }
[13:33:41.709]                       }
[13:33:41.709]                       invisible(muffled)
[13:33:41.709]                     }
[13:33:41.709]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.709]                   }
[13:33:41.709]                 }
[13:33:41.709]                 else {
[13:33:41.709]                   if (TRUE) {
[13:33:41.709]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.709]                     {
[13:33:41.709]                       inherits <- base::inherits
[13:33:41.709]                       invokeRestart <- base::invokeRestart
[13:33:41.709]                       is.null <- base::is.null
[13:33:41.709]                       muffled <- FALSE
[13:33:41.709]                       if (inherits(cond, "message")) {
[13:33:41.709]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.709]                         if (muffled) 
[13:33:41.709]                           invokeRestart("muffleMessage")
[13:33:41.709]                       }
[13:33:41.709]                       else if (inherits(cond, "warning")) {
[13:33:41.709]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.709]                         if (muffled) 
[13:33:41.709]                           invokeRestart("muffleWarning")
[13:33:41.709]                       }
[13:33:41.709]                       else if (inherits(cond, "condition")) {
[13:33:41.709]                         if (!is.null(pattern)) {
[13:33:41.709]                           computeRestarts <- base::computeRestarts
[13:33:41.709]                           grepl <- base::grepl
[13:33:41.709]                           restarts <- computeRestarts(cond)
[13:33:41.709]                           for (restart in restarts) {
[13:33:41.709]                             name <- restart$name
[13:33:41.709]                             if (is.null(name)) 
[13:33:41.709]                               next
[13:33:41.709]                             if (!grepl(pattern, name)) 
[13:33:41.709]                               next
[13:33:41.709]                             invokeRestart(restart)
[13:33:41.709]                             muffled <- TRUE
[13:33:41.709]                             break
[13:33:41.709]                           }
[13:33:41.709]                         }
[13:33:41.709]                       }
[13:33:41.709]                       invisible(muffled)
[13:33:41.709]                     }
[13:33:41.709]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.709]                   }
[13:33:41.709]                 }
[13:33:41.709]             }
[13:33:41.709]         }))
[13:33:41.709]     }, error = function(ex) {
[13:33:41.709]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:41.709]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.709]                 ...future.rng), started = ...future.startTime, 
[13:33:41.709]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:41.709]             version = "1.8"), class = "FutureResult")
[13:33:41.709]     }, finally = {
[13:33:41.709]         if (!identical(...future.workdir, getwd())) 
[13:33:41.709]             setwd(...future.workdir)
[13:33:41.709]         {
[13:33:41.709]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:41.709]                 ...future.oldOptions$nwarnings <- NULL
[13:33:41.709]             }
[13:33:41.709]             base::options(...future.oldOptions)
[13:33:41.709]             if (.Platform$OS.type == "windows") {
[13:33:41.709]                 old_names <- names(...future.oldEnvVars)
[13:33:41.709]                 envs <- base::Sys.getenv()
[13:33:41.709]                 names <- names(envs)
[13:33:41.709]                 common <- intersect(names, old_names)
[13:33:41.709]                 added <- setdiff(names, old_names)
[13:33:41.709]                 removed <- setdiff(old_names, names)
[13:33:41.709]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:41.709]                   envs[common]]
[13:33:41.709]                 NAMES <- toupper(changed)
[13:33:41.709]                 args <- list()
[13:33:41.709]                 for (kk in seq_along(NAMES)) {
[13:33:41.709]                   name <- changed[[kk]]
[13:33:41.709]                   NAME <- NAMES[[kk]]
[13:33:41.709]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.709]                     next
[13:33:41.709]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.709]                 }
[13:33:41.709]                 NAMES <- toupper(added)
[13:33:41.709]                 for (kk in seq_along(NAMES)) {
[13:33:41.709]                   name <- added[[kk]]
[13:33:41.709]                   NAME <- NAMES[[kk]]
[13:33:41.709]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.709]                     next
[13:33:41.709]                   args[[name]] <- ""
[13:33:41.709]                 }
[13:33:41.709]                 NAMES <- toupper(removed)
[13:33:41.709]                 for (kk in seq_along(NAMES)) {
[13:33:41.709]                   name <- removed[[kk]]
[13:33:41.709]                   NAME <- NAMES[[kk]]
[13:33:41.709]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.709]                     next
[13:33:41.709]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.709]                 }
[13:33:41.709]                 if (length(args) > 0) 
[13:33:41.709]                   base::do.call(base::Sys.setenv, args = args)
[13:33:41.709]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:41.709]             }
[13:33:41.709]             else {
[13:33:41.709]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:41.709]             }
[13:33:41.709]             {
[13:33:41.709]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:41.709]                   0L) {
[13:33:41.709]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:41.709]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:41.709]                   base::options(opts)
[13:33:41.709]                 }
[13:33:41.709]                 {
[13:33:41.709]                   {
[13:33:41.709]                     NULL
[13:33:41.709]                     RNGkind("Mersenne-Twister")
[13:33:41.709]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:41.709]                       inherits = FALSE)
[13:33:41.709]                   }
[13:33:41.709]                   options(future.plan = NULL)
[13:33:41.709]                   if (is.na(NA_character_)) 
[13:33:41.709]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.709]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:41.709]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:41.709]                     .init = FALSE)
[13:33:41.709]                 }
[13:33:41.709]             }
[13:33:41.709]         }
[13:33:41.709]     })
[13:33:41.709]     if (TRUE) {
[13:33:41.709]         base::sink(type = "output", split = FALSE)
[13:33:41.709]         if (TRUE) {
[13:33:41.709]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:41.709]         }
[13:33:41.709]         else {
[13:33:41.709]             ...future.result["stdout"] <- base::list(NULL)
[13:33:41.709]         }
[13:33:41.709]         base::close(...future.stdout)
[13:33:41.709]         ...future.stdout <- NULL
[13:33:41.709]     }
[13:33:41.709]     ...future.result$conditions <- ...future.conditions
[13:33:41.709]     ...future.result$finished <- base::Sys.time()
[13:33:41.709]     ...future.result
[13:33:41.709] }
[13:33:41.710] assign_globals() ...
[13:33:41.710] List of 5
[13:33:41.710]  $ ...future.FUN            :function (object, ...)  
[13:33:41.710]  $ future.call.arguments    : list()
[13:33:41.710]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.710]  $ ...future.elements_ii    :List of 3
[13:33:41.710]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.710]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:33:41.710]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.710]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:41.710]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.710]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:33:41.710]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.710]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:33:41.710]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:41.710]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:33:41.710]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.710]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:33:41.710]  $ ...future.seeds_ii       : NULL
[13:33:41.710]  $ ...future.globals.maxSize: NULL
[13:33:41.710]  - attr(*, "where")=List of 5
[13:33:41.710]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:41.710]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:41.710]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:41.710]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:41.710]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:41.710]  - attr(*, "resolved")= logi FALSE
[13:33:41.710]  - attr(*, "total_size")= num 1240
[13:33:41.710]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.710]  - attr(*, "already-done")= logi TRUE
[13:33:41.719] - copied ‘...future.FUN’ to environment
[13:33:41.719] - copied ‘future.call.arguments’ to environment
[13:33:41.719] - copied ‘...future.elements_ii’ to environment
[13:33:41.719] - copied ‘...future.seeds_ii’ to environment
[13:33:41.719] - copied ‘...future.globals.maxSize’ to environment
[13:33:41.720] assign_globals() ... done
[13:33:41.720] plan(): Setting new future strategy stack:
[13:33:41.720] List of future strategies:
[13:33:41.720] 1. sequential:
[13:33:41.720]    - args: function (..., envir = parent.frame())
[13:33:41.720]    - tweaked: FALSE
[13:33:41.720]    - call: NULL
[13:33:41.720] plan(): nbrOfWorkers() = 1
[13:33:41.722] plan(): Setting new future strategy stack:
[13:33:41.722] List of future strategies:
[13:33:41.722] 1. sequential:
[13:33:41.722]    - args: function (..., envir = parent.frame())
[13:33:41.722]    - tweaked: FALSE
[13:33:41.722]    - call: plan(strategy)
[13:33:41.723] plan(): nbrOfWorkers() = 1
[13:33:41.723] SequentialFuture started (and completed)
[13:33:41.723] - Launch lazy future ... done
[13:33:41.723] run() for ‘SequentialFuture’ ... done
[13:33:41.723] Created future:
[13:33:41.723] SequentialFuture:
[13:33:41.723] Label: ‘future_by-1’
[13:33:41.723] Expression:
[13:33:41.723] {
[13:33:41.723]     do.call(function(...) {
[13:33:41.723]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.723]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.723]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.723]             on.exit(options(oopts), add = TRUE)
[13:33:41.723]         }
[13:33:41.723]         {
[13:33:41.723]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.723]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.723]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.723]             })
[13:33:41.723]         }
[13:33:41.723]     }, args = future.call.arguments)
[13:33:41.723] }
[13:33:41.723] Lazy evaluation: FALSE
[13:33:41.723] Asynchronous evaluation: FALSE
[13:33:41.723] Local evaluation: TRUE
[13:33:41.723] Environment: 0x55cb80503980
[13:33:41.723] Capture standard output: TRUE
[13:33:41.723] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:41.723] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:41.723] Packages: <none>
[13:33:41.723] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:41.723] Resolved: TRUE
[13:33:41.723] Value: 5.37 KiB of class ‘list’
[13:33:41.723] Early signaling: FALSE
[13:33:41.723] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:41.723] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:41.724] Chunk #1 of 1 ... DONE
[13:33:41.724] Launching 1 futures (chunks) ... DONE
[13:33:41.724] Resolving 1 futures (chunks) ...
[13:33:41.725] resolve() on list ...
[13:33:41.725]  recursive: 0
[13:33:41.725]  length: 1
[13:33:41.725] 
[13:33:41.725] resolved() for ‘SequentialFuture’ ...
[13:33:41.725] - state: ‘finished’
[13:33:41.725] - run: TRUE
[13:33:41.725] - result: ‘FutureResult’
[13:33:41.725] resolved() for ‘SequentialFuture’ ... done
[13:33:41.725] Future #1
[13:33:41.725] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:41.726] - nx: 1
[13:33:41.726] - relay: TRUE
[13:33:41.726] - stdout: TRUE
[13:33:41.726] - signal: TRUE
[13:33:41.726] - resignal: FALSE
[13:33:41.726] - force: TRUE
[13:33:41.726] - relayed: [n=1] FALSE
[13:33:41.726] - queued futures: [n=1] FALSE
[13:33:41.726]  - until=1
[13:33:41.726]  - relaying element #1
[13:33:41.726] - relayed: [n=1] TRUE
[13:33:41.727] - queued futures: [n=1] TRUE
[13:33:41.727] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:41.727]  length: 0 (resolved future 1)
[13:33:41.727] Relaying remaining futures
[13:33:41.727] signalConditionsASAP(NULL, pos=0) ...
[13:33:41.727] - nx: 1
[13:33:41.727] - relay: TRUE
[13:33:41.727] - stdout: TRUE
[13:33:41.727] - signal: TRUE
[13:33:41.727] - resignal: FALSE
[13:33:41.727] - force: TRUE
[13:33:41.727] - relayed: [n=1] TRUE
[13:33:41.728] - queued futures: [n=1] TRUE
 - flush all
[13:33:41.728] - relayed: [n=1] TRUE
[13:33:41.728] - queued futures: [n=1] TRUE
[13:33:41.728] signalConditionsASAP(NULL, pos=0) ... done
[13:33:41.728] resolve() on list ... DONE
[13:33:41.728]  - Number of value chunks collected: 1
[13:33:41.728] Resolving 1 futures (chunks) ... DONE
[13:33:41.728] Reducing values from 1 chunks ...
[13:33:41.728]  - Number of values collected after concatenation: 3
[13:33:41.728]  - Number of values expected: 3
[13:33:41.728] Reducing values from 1 chunks ... DONE
[13:33:41.729] future_lapply() ... DONE
[13:33:41.729] future_by_internal() ... DONE
[13:33:41.729] future_by_internal() ...
- plan('multicore') ...
[13:33:41.730] plan(): Setting new future strategy stack:
[13:33:41.730] List of future strategies:
[13:33:41.730] 1. multicore:
[13:33:41.730]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:41.730]    - tweaked: FALSE
[13:33:41.730]    - call: plan(strategy)
[13:33:41.733] plan(): nbrOfWorkers() = 2
[13:33:41.734] future_by_internal() ...
[13:33:41.734] future_lapply() ...
[13:33:41.738] Number of chunks: 2
[13:33:41.738] getGlobalsAndPackagesXApply() ...
[13:33:41.738]  - future.globals: TRUE
[13:33:41.738] getGlobalsAndPackages() ...
[13:33:41.739] Searching for globals...
[13:33:41.740] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:41.741] Searching for globals ... DONE
[13:33:41.741] Resolving globals: FALSE
[13:33:41.741] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:41.741] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:41.741] - globals: [1] ‘FUN’
[13:33:41.742] 
[13:33:41.742] getGlobalsAndPackages() ... DONE
[13:33:41.742]  - globals found/used: [n=1] ‘FUN’
[13:33:41.742]  - needed namespaces: [n=0] 
[13:33:41.742] Finding globals ... DONE
[13:33:41.742]  - use_args: TRUE
[13:33:41.742]  - Getting '...' globals ...
[13:33:41.742] resolve() on list ...
[13:33:41.743]  recursive: 0
[13:33:41.743]  length: 1
[13:33:41.743]  elements: ‘...’
[13:33:41.743]  length: 0 (resolved future 1)
[13:33:41.743] resolve() on list ... DONE
[13:33:41.743]    - '...' content: [n=0] 
[13:33:41.743] List of 1
[13:33:41.743]  $ ...: list()
[13:33:41.743]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.743]  - attr(*, "where")=List of 1
[13:33:41.743]   ..$ ...:<environment: 0x55cb8248b910> 
[13:33:41.743]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.743]  - attr(*, "resolved")= logi TRUE
[13:33:41.743]  - attr(*, "total_size")= num NA
[13:33:41.745]  - Getting '...' globals ... DONE
[13:33:41.746] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:41.746] List of 2
[13:33:41.746]  $ ...future.FUN:function (object, ...)  
[13:33:41.746]  $ ...          : list()
[13:33:41.746]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.746]  - attr(*, "where")=List of 2
[13:33:41.746]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:41.746]   ..$ ...          :<environment: 0x55cb8248b910> 
[13:33:41.746]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.746]  - attr(*, "resolved")= logi FALSE
[13:33:41.746]  - attr(*, "total_size")= num 1240
[13:33:41.748] Packages to be attached in all futures: [n=0] 
[13:33:41.748] getGlobalsAndPackagesXApply() ... DONE
[13:33:41.749] Number of futures (= number of chunks): 2
[13:33:41.749] Launching 2 futures (chunks) ...
[13:33:41.749] Chunk #1 of 2 ...
[13:33:41.749]  - Finding globals in 'X' for chunk #1 ...
[13:33:41.749] getGlobalsAndPackages() ...
[13:33:41.749] Searching for globals...
[13:33:41.749] 
[13:33:41.749] Searching for globals ... DONE
[13:33:41.750] - globals: [0] <none>
[13:33:41.750] getGlobalsAndPackages() ... DONE
[13:33:41.750]    + additional globals found: [n=0] 
[13:33:41.750]    + additional namespaces needed: [n=0] 
[13:33:41.750]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:41.750]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:41.750]  - seeds: <none>
[13:33:41.750]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.750] getGlobalsAndPackages() ...
[13:33:41.750] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.750] Resolving globals: FALSE
[13:33:41.751] Tweak future expression to call with '...' arguments ...
[13:33:41.751] {
[13:33:41.751]     do.call(function(...) {
[13:33:41.751]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.751]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.751]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.751]             on.exit(options(oopts), add = TRUE)
[13:33:41.751]         }
[13:33:41.751]         {
[13:33:41.751]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.751]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.751]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.751]             })
[13:33:41.751]         }
[13:33:41.751]     }, args = future.call.arguments)
[13:33:41.751] }
[13:33:41.751] Tweak future expression to call with '...' arguments ... DONE
[13:33:41.751] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.751] 
[13:33:41.751] getGlobalsAndPackages() ... DONE
[13:33:41.752] run() for ‘Future’ ...
[13:33:41.752] - state: ‘created’
[13:33:41.752] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:41.755] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:41.755] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:41.756]   - Field: ‘label’
[13:33:41.756]   - Field: ‘local’
[13:33:41.756]   - Field: ‘owner’
[13:33:41.756]   - Field: ‘envir’
[13:33:41.756]   - Field: ‘workers’
[13:33:41.756]   - Field: ‘packages’
[13:33:41.756]   - Field: ‘gc’
[13:33:41.756]   - Field: ‘job’
[13:33:41.756]   - Field: ‘conditions’
[13:33:41.756]   - Field: ‘expr’
[13:33:41.756]   - Field: ‘uuid’
[13:33:41.756]   - Field: ‘seed’
[13:33:41.757]   - Field: ‘version’
[13:33:41.757]   - Field: ‘result’
[13:33:41.757]   - Field: ‘asynchronous’
[13:33:41.757]   - Field: ‘calls’
[13:33:41.757]   - Field: ‘globals’
[13:33:41.757]   - Field: ‘stdout’
[13:33:41.757]   - Field: ‘earlySignal’
[13:33:41.757]   - Field: ‘lazy’
[13:33:41.757]   - Field: ‘state’
[13:33:41.757] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:41.757] - Launch lazy future ...
[13:33:41.759] Packages needed by the future expression (n = 0): <none>
[13:33:41.759] Packages needed by future strategies (n = 0): <none>
[13:33:41.759] {
[13:33:41.759]     {
[13:33:41.759]         {
[13:33:41.759]             ...future.startTime <- base::Sys.time()
[13:33:41.759]             {
[13:33:41.759]                 {
[13:33:41.759]                   {
[13:33:41.759]                     {
[13:33:41.759]                       base::local({
[13:33:41.759]                         has_future <- base::requireNamespace("future", 
[13:33:41.759]                           quietly = TRUE)
[13:33:41.759]                         if (has_future) {
[13:33:41.759]                           ns <- base::getNamespace("future")
[13:33:41.759]                           version <- ns[[".package"]][["version"]]
[13:33:41.759]                           if (is.null(version)) 
[13:33:41.759]                             version <- utils::packageVersion("future")
[13:33:41.759]                         }
[13:33:41.759]                         else {
[13:33:41.759]                           version <- NULL
[13:33:41.759]                         }
[13:33:41.759]                         if (!has_future || version < "1.8.0") {
[13:33:41.759]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:41.759]                             "", base::R.version$version.string), 
[13:33:41.759]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:41.759]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:41.759]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:41.759]                               "release", "version")], collapse = " "), 
[13:33:41.759]                             hostname = base::Sys.info()[["nodename"]])
[13:33:41.759]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:41.759]                             info)
[13:33:41.759]                           info <- base::paste(info, collapse = "; ")
[13:33:41.759]                           if (!has_future) {
[13:33:41.759]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:41.759]                               info)
[13:33:41.759]                           }
[13:33:41.759]                           else {
[13:33:41.759]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:41.759]                               info, version)
[13:33:41.759]                           }
[13:33:41.759]                           base::stop(msg)
[13:33:41.759]                         }
[13:33:41.759]                       })
[13:33:41.759]                     }
[13:33:41.759]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:41.759]                     base::options(mc.cores = 1L)
[13:33:41.759]                   }
[13:33:41.759]                   ...future.strategy.old <- future::plan("list")
[13:33:41.759]                   options(future.plan = NULL)
[13:33:41.759]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.759]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:41.759]                 }
[13:33:41.759]                 ...future.workdir <- getwd()
[13:33:41.759]             }
[13:33:41.759]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:41.759]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:41.759]         }
[13:33:41.759]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:41.759]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:41.759]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:41.759]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:41.759]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:41.759]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:41.759]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:41.759]             base::names(...future.oldOptions))
[13:33:41.759]     }
[13:33:41.759]     if (FALSE) {
[13:33:41.759]     }
[13:33:41.759]     else {
[13:33:41.759]         if (TRUE) {
[13:33:41.759]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:41.759]                 open = "w")
[13:33:41.759]         }
[13:33:41.759]         else {
[13:33:41.759]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:41.759]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:41.759]         }
[13:33:41.759]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:41.759]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:41.759]             base::sink(type = "output", split = FALSE)
[13:33:41.759]             base::close(...future.stdout)
[13:33:41.759]         }, add = TRUE)
[13:33:41.759]     }
[13:33:41.759]     ...future.frame <- base::sys.nframe()
[13:33:41.759]     ...future.conditions <- base::list()
[13:33:41.759]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:41.759]     if (FALSE) {
[13:33:41.759]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:41.759]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:41.759]     }
[13:33:41.759]     ...future.result <- base::tryCatch({
[13:33:41.759]         base::withCallingHandlers({
[13:33:41.759]             ...future.value <- base::withVisible(base::local({
[13:33:41.759]                 withCallingHandlers({
[13:33:41.759]                   {
[13:33:41.759]                     do.call(function(...) {
[13:33:41.759]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.759]                       if (!identical(...future.globals.maxSize.org, 
[13:33:41.759]                         ...future.globals.maxSize)) {
[13:33:41.759]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.759]                         on.exit(options(oopts), add = TRUE)
[13:33:41.759]                       }
[13:33:41.759]                       {
[13:33:41.759]                         lapply(seq_along(...future.elements_ii), 
[13:33:41.759]                           FUN = function(jj) {
[13:33:41.759]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.759]                             ...future.FUN(...future.X_jj, ...)
[13:33:41.759]                           })
[13:33:41.759]                       }
[13:33:41.759]                     }, args = future.call.arguments)
[13:33:41.759]                   }
[13:33:41.759]                 }, immediateCondition = function(cond) {
[13:33:41.759]                   save_rds <- function (object, pathname, ...) 
[13:33:41.759]                   {
[13:33:41.759]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:41.759]                     if (file_test("-f", pathname_tmp)) {
[13:33:41.759]                       fi_tmp <- file.info(pathname_tmp)
[13:33:41.759]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:41.759]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:41.759]                         fi_tmp[["mtime"]])
[13:33:41.759]                     }
[13:33:41.759]                     tryCatch({
[13:33:41.759]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:41.759]                     }, error = function(ex) {
[13:33:41.759]                       msg <- conditionMessage(ex)
[13:33:41.759]                       fi_tmp <- file.info(pathname_tmp)
[13:33:41.759]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:41.759]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:41.759]                         fi_tmp[["mtime"]], msg)
[13:33:41.759]                       ex$message <- msg
[13:33:41.759]                       stop(ex)
[13:33:41.759]                     })
[13:33:41.759]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:41.759]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:41.759]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:41.759]                       fi_tmp <- file.info(pathname_tmp)
[13:33:41.759]                       fi <- file.info(pathname)
[13:33:41.759]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:41.759]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:41.759]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:41.759]                         fi[["size"]], fi[["mtime"]])
[13:33:41.759]                       stop(msg)
[13:33:41.759]                     }
[13:33:41.759]                     invisible(pathname)
[13:33:41.759]                   }
[13:33:41.759]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:41.759]                     rootPath = tempdir()) 
[13:33:41.759]                   {
[13:33:41.759]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:41.759]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:41.759]                       tmpdir = path, fileext = ".rds")
[13:33:41.759]                     save_rds(obj, file)
[13:33:41.759]                   }
[13:33:41.759]                   saveImmediateCondition(cond, path = "/tmp/RtmpMLLN1L/.future/immediateConditions")
[13:33:41.759]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.759]                   {
[13:33:41.759]                     inherits <- base::inherits
[13:33:41.759]                     invokeRestart <- base::invokeRestart
[13:33:41.759]                     is.null <- base::is.null
[13:33:41.759]                     muffled <- FALSE
[13:33:41.759]                     if (inherits(cond, "message")) {
[13:33:41.759]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:41.759]                       if (muffled) 
[13:33:41.759]                         invokeRestart("muffleMessage")
[13:33:41.759]                     }
[13:33:41.759]                     else if (inherits(cond, "warning")) {
[13:33:41.759]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:41.759]                       if (muffled) 
[13:33:41.759]                         invokeRestart("muffleWarning")
[13:33:41.759]                     }
[13:33:41.759]                     else if (inherits(cond, "condition")) {
[13:33:41.759]                       if (!is.null(pattern)) {
[13:33:41.759]                         computeRestarts <- base::computeRestarts
[13:33:41.759]                         grepl <- base::grepl
[13:33:41.759]                         restarts <- computeRestarts(cond)
[13:33:41.759]                         for (restart in restarts) {
[13:33:41.759]                           name <- restart$name
[13:33:41.759]                           if (is.null(name)) 
[13:33:41.759]                             next
[13:33:41.759]                           if (!grepl(pattern, name)) 
[13:33:41.759]                             next
[13:33:41.759]                           invokeRestart(restart)
[13:33:41.759]                           muffled <- TRUE
[13:33:41.759]                           break
[13:33:41.759]                         }
[13:33:41.759]                       }
[13:33:41.759]                     }
[13:33:41.759]                     invisible(muffled)
[13:33:41.759]                   }
[13:33:41.759]                   muffleCondition(cond)
[13:33:41.759]                 })
[13:33:41.759]             }))
[13:33:41.759]             future::FutureResult(value = ...future.value$value, 
[13:33:41.759]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.759]                   ...future.rng), globalenv = if (FALSE) 
[13:33:41.759]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:41.759]                     ...future.globalenv.names))
[13:33:41.759]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:41.759]         }, condition = base::local({
[13:33:41.759]             c <- base::c
[13:33:41.759]             inherits <- base::inherits
[13:33:41.759]             invokeRestart <- base::invokeRestart
[13:33:41.759]             length <- base::length
[13:33:41.759]             list <- base::list
[13:33:41.759]             seq.int <- base::seq.int
[13:33:41.759]             signalCondition <- base::signalCondition
[13:33:41.759]             sys.calls <- base::sys.calls
[13:33:41.759]             `[[` <- base::`[[`
[13:33:41.759]             `+` <- base::`+`
[13:33:41.759]             `<<-` <- base::`<<-`
[13:33:41.759]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:41.759]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:41.759]                   3L)]
[13:33:41.759]             }
[13:33:41.759]             function(cond) {
[13:33:41.759]                 is_error <- inherits(cond, "error")
[13:33:41.759]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:41.759]                   NULL)
[13:33:41.759]                 if (is_error) {
[13:33:41.759]                   sessionInformation <- function() {
[13:33:41.759]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:41.759]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:41.759]                       search = base::search(), system = base::Sys.info())
[13:33:41.759]                   }
[13:33:41.759]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.759]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:41.759]                     cond$call), session = sessionInformation(), 
[13:33:41.759]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:41.759]                   signalCondition(cond)
[13:33:41.759]                 }
[13:33:41.759]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:41.759]                 "immediateCondition"))) {
[13:33:41.759]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:41.759]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.759]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:41.759]                   if (TRUE && !signal) {
[13:33:41.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.759]                     {
[13:33:41.759]                       inherits <- base::inherits
[13:33:41.759]                       invokeRestart <- base::invokeRestart
[13:33:41.759]                       is.null <- base::is.null
[13:33:41.759]                       muffled <- FALSE
[13:33:41.759]                       if (inherits(cond, "message")) {
[13:33:41.759]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.759]                         if (muffled) 
[13:33:41.759]                           invokeRestart("muffleMessage")
[13:33:41.759]                       }
[13:33:41.759]                       else if (inherits(cond, "warning")) {
[13:33:41.759]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.759]                         if (muffled) 
[13:33:41.759]                           invokeRestart("muffleWarning")
[13:33:41.759]                       }
[13:33:41.759]                       else if (inherits(cond, "condition")) {
[13:33:41.759]                         if (!is.null(pattern)) {
[13:33:41.759]                           computeRestarts <- base::computeRestarts
[13:33:41.759]                           grepl <- base::grepl
[13:33:41.759]                           restarts <- computeRestarts(cond)
[13:33:41.759]                           for (restart in restarts) {
[13:33:41.759]                             name <- restart$name
[13:33:41.759]                             if (is.null(name)) 
[13:33:41.759]                               next
[13:33:41.759]                             if (!grepl(pattern, name)) 
[13:33:41.759]                               next
[13:33:41.759]                             invokeRestart(restart)
[13:33:41.759]                             muffled <- TRUE
[13:33:41.759]                             break
[13:33:41.759]                           }
[13:33:41.759]                         }
[13:33:41.759]                       }
[13:33:41.759]                       invisible(muffled)
[13:33:41.759]                     }
[13:33:41.759]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.759]                   }
[13:33:41.759]                 }
[13:33:41.759]                 else {
[13:33:41.759]                   if (TRUE) {
[13:33:41.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.759]                     {
[13:33:41.759]                       inherits <- base::inherits
[13:33:41.759]                       invokeRestart <- base::invokeRestart
[13:33:41.759]                       is.null <- base::is.null
[13:33:41.759]                       muffled <- FALSE
[13:33:41.759]                       if (inherits(cond, "message")) {
[13:33:41.759]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.759]                         if (muffled) 
[13:33:41.759]                           invokeRestart("muffleMessage")
[13:33:41.759]                       }
[13:33:41.759]                       else if (inherits(cond, "warning")) {
[13:33:41.759]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.759]                         if (muffled) 
[13:33:41.759]                           invokeRestart("muffleWarning")
[13:33:41.759]                       }
[13:33:41.759]                       else if (inherits(cond, "condition")) {
[13:33:41.759]                         if (!is.null(pattern)) {
[13:33:41.759]                           computeRestarts <- base::computeRestarts
[13:33:41.759]                           grepl <- base::grepl
[13:33:41.759]                           restarts <- computeRestarts(cond)
[13:33:41.759]                           for (restart in restarts) {
[13:33:41.759]                             name <- restart$name
[13:33:41.759]                             if (is.null(name)) 
[13:33:41.759]                               next
[13:33:41.759]                             if (!grepl(pattern, name)) 
[13:33:41.759]                               next
[13:33:41.759]                             invokeRestart(restart)
[13:33:41.759]                             muffled <- TRUE
[13:33:41.759]                             break
[13:33:41.759]                           }
[13:33:41.759]                         }
[13:33:41.759]                       }
[13:33:41.759]                       invisible(muffled)
[13:33:41.759]                     }
[13:33:41.759]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.759]                   }
[13:33:41.759]                 }
[13:33:41.759]             }
[13:33:41.759]         }))
[13:33:41.759]     }, error = function(ex) {
[13:33:41.759]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:41.759]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.759]                 ...future.rng), started = ...future.startTime, 
[13:33:41.759]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:41.759]             version = "1.8"), class = "FutureResult")
[13:33:41.759]     }, finally = {
[13:33:41.759]         if (!identical(...future.workdir, getwd())) 
[13:33:41.759]             setwd(...future.workdir)
[13:33:41.759]         {
[13:33:41.759]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:41.759]                 ...future.oldOptions$nwarnings <- NULL
[13:33:41.759]             }
[13:33:41.759]             base::options(...future.oldOptions)
[13:33:41.759]             if (.Platform$OS.type == "windows") {
[13:33:41.759]                 old_names <- names(...future.oldEnvVars)
[13:33:41.759]                 envs <- base::Sys.getenv()
[13:33:41.759]                 names <- names(envs)
[13:33:41.759]                 common <- intersect(names, old_names)
[13:33:41.759]                 added <- setdiff(names, old_names)
[13:33:41.759]                 removed <- setdiff(old_names, names)
[13:33:41.759]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:41.759]                   envs[common]]
[13:33:41.759]                 NAMES <- toupper(changed)
[13:33:41.759]                 args <- list()
[13:33:41.759]                 for (kk in seq_along(NAMES)) {
[13:33:41.759]                   name <- changed[[kk]]
[13:33:41.759]                   NAME <- NAMES[[kk]]
[13:33:41.759]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.759]                     next
[13:33:41.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.759]                 }
[13:33:41.759]                 NAMES <- toupper(added)
[13:33:41.759]                 for (kk in seq_along(NAMES)) {
[13:33:41.759]                   name <- added[[kk]]
[13:33:41.759]                   NAME <- NAMES[[kk]]
[13:33:41.759]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.759]                     next
[13:33:41.759]                   args[[name]] <- ""
[13:33:41.759]                 }
[13:33:41.759]                 NAMES <- toupper(removed)
[13:33:41.759]                 for (kk in seq_along(NAMES)) {
[13:33:41.759]                   name <- removed[[kk]]
[13:33:41.759]                   NAME <- NAMES[[kk]]
[13:33:41.759]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.759]                     next
[13:33:41.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.759]                 }
[13:33:41.759]                 if (length(args) > 0) 
[13:33:41.759]                   base::do.call(base::Sys.setenv, args = args)
[13:33:41.759]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:41.759]             }
[13:33:41.759]             else {
[13:33:41.759]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:41.759]             }
[13:33:41.759]             {
[13:33:41.759]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:41.759]                   0L) {
[13:33:41.759]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:41.759]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:41.759]                   base::options(opts)
[13:33:41.759]                 }
[13:33:41.759]                 {
[13:33:41.759]                   {
[13:33:41.759]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:41.759]                     NULL
[13:33:41.759]                   }
[13:33:41.759]                   options(future.plan = NULL)
[13:33:41.759]                   if (is.na(NA_character_)) 
[13:33:41.759]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.759]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:41.759]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:41.759]                     .init = FALSE)
[13:33:41.759]                 }
[13:33:41.759]             }
[13:33:41.759]         }
[13:33:41.759]     })
[13:33:41.759]     if (TRUE) {
[13:33:41.759]         base::sink(type = "output", split = FALSE)
[13:33:41.759]         if (TRUE) {
[13:33:41.759]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:41.759]         }
[13:33:41.759]         else {
[13:33:41.759]             ...future.result["stdout"] <- base::list(NULL)
[13:33:41.759]         }
[13:33:41.759]         base::close(...future.stdout)
[13:33:41.759]         ...future.stdout <- NULL
[13:33:41.759]     }
[13:33:41.759]     ...future.result$conditions <- ...future.conditions
[13:33:41.759]     ...future.result$finished <- base::Sys.time()
[13:33:41.759]     ...future.result
[13:33:41.759] }
[13:33:41.762] assign_globals() ...
[13:33:41.762] List of 5
[13:33:41.762]  $ ...future.FUN            :function (object, ...)  
[13:33:41.762]  $ future.call.arguments    : list()
[13:33:41.762]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.762]  $ ...future.elements_ii    :List of 1
[13:33:41.762]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:33:41.762]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:33:41.762]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.762]  $ ...future.seeds_ii       : NULL
[13:33:41.762]  $ ...future.globals.maxSize: NULL
[13:33:41.762]  - attr(*, "where")=List of 5
[13:33:41.762]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:41.762]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:41.762]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:41.762]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:41.762]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:41.762]  - attr(*, "resolved")= logi FALSE
[13:33:41.762]  - attr(*, "total_size")= num 1240
[13:33:41.762]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.762]  - attr(*, "already-done")= logi TRUE
[13:33:41.768] - copied ‘...future.FUN’ to environment
[13:33:41.768] - copied ‘future.call.arguments’ to environment
[13:33:41.768] - copied ‘...future.elements_ii’ to environment
[13:33:41.768] - copied ‘...future.seeds_ii’ to environment
[13:33:41.768] - copied ‘...future.globals.maxSize’ to environment
[13:33:41.768] assign_globals() ... done
[13:33:41.768] requestCore(): workers = 2
[13:33:41.771] MulticoreFuture started
[13:33:41.772] - Launch lazy future ... done
[13:33:41.772] plan(): Setting new future strategy stack:
[13:33:41.772] run() for ‘MulticoreFuture’ ... done
[13:33:41.773] Created future:
[13:33:41.772] List of future strategies:
[13:33:41.772] 1. sequential:
[13:33:41.772]    - args: function (..., envir = parent.frame())
[13:33:41.772]    - tweaked: FALSE
[13:33:41.772]    - call: NULL
[13:33:41.773] plan(): nbrOfWorkers() = 1
[13:33:41.776] plan(): Setting new future strategy stack:
[13:33:41.777] List of future strategies:
[13:33:41.777] 1. multicore:
[13:33:41.777]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:41.777]    - tweaked: FALSE
[13:33:41.777]    - call: plan(strategy)
[13:33:41.782] plan(): nbrOfWorkers() = 2
[13:33:41.773] MulticoreFuture:
[13:33:41.773] Label: ‘future_by-1’
[13:33:41.773] Expression:
[13:33:41.773] {
[13:33:41.773]     do.call(function(...) {
[13:33:41.773]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.773]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.773]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.773]             on.exit(options(oopts), add = TRUE)
[13:33:41.773]         }
[13:33:41.773]         {
[13:33:41.773]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.773]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.773]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.773]             })
[13:33:41.773]         }
[13:33:41.773]     }, args = future.call.arguments)
[13:33:41.773] }
[13:33:41.773] Lazy evaluation: FALSE
[13:33:41.773] Asynchronous evaluation: TRUE
[13:33:41.773] Local evaluation: TRUE
[13:33:41.773] Environment: R_GlobalEnv
[13:33:41.773] Capture standard output: TRUE
[13:33:41.773] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:41.773] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:41.773] Packages: <none>
[13:33:41.773] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:41.773] Resolved: TRUE
[13:33:41.773] Value: <not collected>
[13:33:41.773] Conditions captured: <none>
[13:33:41.773] Early signaling: FALSE
[13:33:41.773] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:41.773] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:41.784] Chunk #1 of 2 ... DONE
[13:33:41.784] Chunk #2 of 2 ...
[13:33:41.784]  - Finding globals in 'X' for chunk #2 ...
[13:33:41.784] getGlobalsAndPackages() ...
[13:33:41.784] Searching for globals...
[13:33:41.785] 
[13:33:41.785] Searching for globals ... DONE
[13:33:41.786] - globals: [0] <none>
[13:33:41.786] getGlobalsAndPackages() ... DONE
[13:33:41.786]    + additional globals found: [n=0] 
[13:33:41.786]    + additional namespaces needed: [n=0] 
[13:33:41.786]  - Finding globals in 'X' for chunk #2 ... DONE
[13:33:41.786]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:41.787]  - seeds: <none>
[13:33:41.787]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.787] getGlobalsAndPackages() ...
[13:33:41.787] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.788] Resolving globals: FALSE
[13:33:41.788] Tweak future expression to call with '...' arguments ...
[13:33:41.788] {
[13:33:41.788]     do.call(function(...) {
[13:33:41.788]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.788]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.788]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.788]             on.exit(options(oopts), add = TRUE)
[13:33:41.788]         }
[13:33:41.788]         {
[13:33:41.788]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.788]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.788]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.788]             })
[13:33:41.788]         }
[13:33:41.788]     }, args = future.call.arguments)
[13:33:41.788] }
[13:33:41.788] Tweak future expression to call with '...' arguments ... DONE
[13:33:41.789] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.789] 
[13:33:41.790] getGlobalsAndPackages() ... DONE
[13:33:41.790] run() for ‘Future’ ...
[13:33:41.790] - state: ‘created’
[13:33:41.791] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:41.795] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:41.795] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:41.796]   - Field: ‘label’
[13:33:41.796]   - Field: ‘local’
[13:33:41.796]   - Field: ‘owner’
[13:33:41.796]   - Field: ‘envir’
[13:33:41.796]   - Field: ‘workers’
[13:33:41.796]   - Field: ‘packages’
[13:33:41.797]   - Field: ‘gc’
[13:33:41.797]   - Field: ‘job’
[13:33:41.797]   - Field: ‘conditions’
[13:33:41.797]   - Field: ‘expr’
[13:33:41.797]   - Field: ‘uuid’
[13:33:41.797]   - Field: ‘seed’
[13:33:41.797]   - Field: ‘version’
[13:33:41.797]   - Field: ‘result’
[13:33:41.798]   - Field: ‘asynchronous’
[13:33:41.798]   - Field: ‘calls’
[13:33:41.798]   - Field: ‘globals’
[13:33:41.798]   - Field: ‘stdout’
[13:33:41.798]   - Field: ‘earlySignal’
[13:33:41.798]   - Field: ‘lazy’
[13:33:41.798]   - Field: ‘state’
[13:33:41.799] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:41.799] - Launch lazy future ...
[13:33:41.799] Packages needed by the future expression (n = 0): <none>
[13:33:41.799] Packages needed by future strategies (n = 0): <none>
[13:33:41.800] {
[13:33:41.800]     {
[13:33:41.800]         {
[13:33:41.800]             ...future.startTime <- base::Sys.time()
[13:33:41.800]             {
[13:33:41.800]                 {
[13:33:41.800]                   {
[13:33:41.800]                     {
[13:33:41.800]                       base::local({
[13:33:41.800]                         has_future <- base::requireNamespace("future", 
[13:33:41.800]                           quietly = TRUE)
[13:33:41.800]                         if (has_future) {
[13:33:41.800]                           ns <- base::getNamespace("future")
[13:33:41.800]                           version <- ns[[".package"]][["version"]]
[13:33:41.800]                           if (is.null(version)) 
[13:33:41.800]                             version <- utils::packageVersion("future")
[13:33:41.800]                         }
[13:33:41.800]                         else {
[13:33:41.800]                           version <- NULL
[13:33:41.800]                         }
[13:33:41.800]                         if (!has_future || version < "1.8.0") {
[13:33:41.800]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:41.800]                             "", base::R.version$version.string), 
[13:33:41.800]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:41.800]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:41.800]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:41.800]                               "release", "version")], collapse = " "), 
[13:33:41.800]                             hostname = base::Sys.info()[["nodename"]])
[13:33:41.800]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:41.800]                             info)
[13:33:41.800]                           info <- base::paste(info, collapse = "; ")
[13:33:41.800]                           if (!has_future) {
[13:33:41.800]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:41.800]                               info)
[13:33:41.800]                           }
[13:33:41.800]                           else {
[13:33:41.800]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:41.800]                               info, version)
[13:33:41.800]                           }
[13:33:41.800]                           base::stop(msg)
[13:33:41.800]                         }
[13:33:41.800]                       })
[13:33:41.800]                     }
[13:33:41.800]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:41.800]                     base::options(mc.cores = 1L)
[13:33:41.800]                   }
[13:33:41.800]                   ...future.strategy.old <- future::plan("list")
[13:33:41.800]                   options(future.plan = NULL)
[13:33:41.800]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.800]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:41.800]                 }
[13:33:41.800]                 ...future.workdir <- getwd()
[13:33:41.800]             }
[13:33:41.800]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:41.800]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:41.800]         }
[13:33:41.800]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:41.800]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:41.800]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:41.800]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:41.800]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:41.800]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:41.800]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:41.800]             base::names(...future.oldOptions))
[13:33:41.800]     }
[13:33:41.800]     if (FALSE) {
[13:33:41.800]     }
[13:33:41.800]     else {
[13:33:41.800]         if (TRUE) {
[13:33:41.800]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:41.800]                 open = "w")
[13:33:41.800]         }
[13:33:41.800]         else {
[13:33:41.800]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:41.800]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:41.800]         }
[13:33:41.800]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:41.800]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:41.800]             base::sink(type = "output", split = FALSE)
[13:33:41.800]             base::close(...future.stdout)
[13:33:41.800]         }, add = TRUE)
[13:33:41.800]     }
[13:33:41.800]     ...future.frame <- base::sys.nframe()
[13:33:41.800]     ...future.conditions <- base::list()
[13:33:41.800]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:41.800]     if (FALSE) {
[13:33:41.800]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:41.800]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:41.800]     }
[13:33:41.800]     ...future.result <- base::tryCatch({
[13:33:41.800]         base::withCallingHandlers({
[13:33:41.800]             ...future.value <- base::withVisible(base::local({
[13:33:41.800]                 withCallingHandlers({
[13:33:41.800]                   {
[13:33:41.800]                     do.call(function(...) {
[13:33:41.800]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.800]                       if (!identical(...future.globals.maxSize.org, 
[13:33:41.800]                         ...future.globals.maxSize)) {
[13:33:41.800]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.800]                         on.exit(options(oopts), add = TRUE)
[13:33:41.800]                       }
[13:33:41.800]                       {
[13:33:41.800]                         lapply(seq_along(...future.elements_ii), 
[13:33:41.800]                           FUN = function(jj) {
[13:33:41.800]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.800]                             ...future.FUN(...future.X_jj, ...)
[13:33:41.800]                           })
[13:33:41.800]                       }
[13:33:41.800]                     }, args = future.call.arguments)
[13:33:41.800]                   }
[13:33:41.800]                 }, immediateCondition = function(cond) {
[13:33:41.800]                   save_rds <- function (object, pathname, ...) 
[13:33:41.800]                   {
[13:33:41.800]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:41.800]                     if (file_test("-f", pathname_tmp)) {
[13:33:41.800]                       fi_tmp <- file.info(pathname_tmp)
[13:33:41.800]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:41.800]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:41.800]                         fi_tmp[["mtime"]])
[13:33:41.800]                     }
[13:33:41.800]                     tryCatch({
[13:33:41.800]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:41.800]                     }, error = function(ex) {
[13:33:41.800]                       msg <- conditionMessage(ex)
[13:33:41.800]                       fi_tmp <- file.info(pathname_tmp)
[13:33:41.800]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:41.800]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:41.800]                         fi_tmp[["mtime"]], msg)
[13:33:41.800]                       ex$message <- msg
[13:33:41.800]                       stop(ex)
[13:33:41.800]                     })
[13:33:41.800]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:41.800]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:41.800]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:41.800]                       fi_tmp <- file.info(pathname_tmp)
[13:33:41.800]                       fi <- file.info(pathname)
[13:33:41.800]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:41.800]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:41.800]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:41.800]                         fi[["size"]], fi[["mtime"]])
[13:33:41.800]                       stop(msg)
[13:33:41.800]                     }
[13:33:41.800]                     invisible(pathname)
[13:33:41.800]                   }
[13:33:41.800]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:41.800]                     rootPath = tempdir()) 
[13:33:41.800]                   {
[13:33:41.800]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:41.800]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:41.800]                       tmpdir = path, fileext = ".rds")
[13:33:41.800]                     save_rds(obj, file)
[13:33:41.800]                   }
[13:33:41.800]                   saveImmediateCondition(cond, path = "/tmp/RtmpMLLN1L/.future/immediateConditions")
[13:33:41.800]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.800]                   {
[13:33:41.800]                     inherits <- base::inherits
[13:33:41.800]                     invokeRestart <- base::invokeRestart
[13:33:41.800]                     is.null <- base::is.null
[13:33:41.800]                     muffled <- FALSE
[13:33:41.800]                     if (inherits(cond, "message")) {
[13:33:41.800]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:41.800]                       if (muffled) 
[13:33:41.800]                         invokeRestart("muffleMessage")
[13:33:41.800]                     }
[13:33:41.800]                     else if (inherits(cond, "warning")) {
[13:33:41.800]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:41.800]                       if (muffled) 
[13:33:41.800]                         invokeRestart("muffleWarning")
[13:33:41.800]                     }
[13:33:41.800]                     else if (inherits(cond, "condition")) {
[13:33:41.800]                       if (!is.null(pattern)) {
[13:33:41.800]                         computeRestarts <- base::computeRestarts
[13:33:41.800]                         grepl <- base::grepl
[13:33:41.800]                         restarts <- computeRestarts(cond)
[13:33:41.800]                         for (restart in restarts) {
[13:33:41.800]                           name <- restart$name
[13:33:41.800]                           if (is.null(name)) 
[13:33:41.800]                             next
[13:33:41.800]                           if (!grepl(pattern, name)) 
[13:33:41.800]                             next
[13:33:41.800]                           invokeRestart(restart)
[13:33:41.800]                           muffled <- TRUE
[13:33:41.800]                           break
[13:33:41.800]                         }
[13:33:41.800]                       }
[13:33:41.800]                     }
[13:33:41.800]                     invisible(muffled)
[13:33:41.800]                   }
[13:33:41.800]                   muffleCondition(cond)
[13:33:41.800]                 })
[13:33:41.800]             }))
[13:33:41.800]             future::FutureResult(value = ...future.value$value, 
[13:33:41.800]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.800]                   ...future.rng), globalenv = if (FALSE) 
[13:33:41.800]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:41.800]                     ...future.globalenv.names))
[13:33:41.800]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:41.800]         }, condition = base::local({
[13:33:41.800]             c <- base::c
[13:33:41.800]             inherits <- base::inherits
[13:33:41.800]             invokeRestart <- base::invokeRestart
[13:33:41.800]             length <- base::length
[13:33:41.800]             list <- base::list
[13:33:41.800]             seq.int <- base::seq.int
[13:33:41.800]             signalCondition <- base::signalCondition
[13:33:41.800]             sys.calls <- base::sys.calls
[13:33:41.800]             `[[` <- base::`[[`
[13:33:41.800]             `+` <- base::`+`
[13:33:41.800]             `<<-` <- base::`<<-`
[13:33:41.800]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:41.800]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:41.800]                   3L)]
[13:33:41.800]             }
[13:33:41.800]             function(cond) {
[13:33:41.800]                 is_error <- inherits(cond, "error")
[13:33:41.800]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:41.800]                   NULL)
[13:33:41.800]                 if (is_error) {
[13:33:41.800]                   sessionInformation <- function() {
[13:33:41.800]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:41.800]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:41.800]                       search = base::search(), system = base::Sys.info())
[13:33:41.800]                   }
[13:33:41.800]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.800]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:41.800]                     cond$call), session = sessionInformation(), 
[13:33:41.800]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:41.800]                   signalCondition(cond)
[13:33:41.800]                 }
[13:33:41.800]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:41.800]                 "immediateCondition"))) {
[13:33:41.800]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:41.800]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.800]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:41.800]                   if (TRUE && !signal) {
[13:33:41.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.800]                     {
[13:33:41.800]                       inherits <- base::inherits
[13:33:41.800]                       invokeRestart <- base::invokeRestart
[13:33:41.800]                       is.null <- base::is.null
[13:33:41.800]                       muffled <- FALSE
[13:33:41.800]                       if (inherits(cond, "message")) {
[13:33:41.800]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.800]                         if (muffled) 
[13:33:41.800]                           invokeRestart("muffleMessage")
[13:33:41.800]                       }
[13:33:41.800]                       else if (inherits(cond, "warning")) {
[13:33:41.800]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.800]                         if (muffled) 
[13:33:41.800]                           invokeRestart("muffleWarning")
[13:33:41.800]                       }
[13:33:41.800]                       else if (inherits(cond, "condition")) {
[13:33:41.800]                         if (!is.null(pattern)) {
[13:33:41.800]                           computeRestarts <- base::computeRestarts
[13:33:41.800]                           grepl <- base::grepl
[13:33:41.800]                           restarts <- computeRestarts(cond)
[13:33:41.800]                           for (restart in restarts) {
[13:33:41.800]                             name <- restart$name
[13:33:41.800]                             if (is.null(name)) 
[13:33:41.800]                               next
[13:33:41.800]                             if (!grepl(pattern, name)) 
[13:33:41.800]                               next
[13:33:41.800]                             invokeRestart(restart)
[13:33:41.800]                             muffled <- TRUE
[13:33:41.800]                             break
[13:33:41.800]                           }
[13:33:41.800]                         }
[13:33:41.800]                       }
[13:33:41.800]                       invisible(muffled)
[13:33:41.800]                     }
[13:33:41.800]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.800]                   }
[13:33:41.800]                 }
[13:33:41.800]                 else {
[13:33:41.800]                   if (TRUE) {
[13:33:41.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.800]                     {
[13:33:41.800]                       inherits <- base::inherits
[13:33:41.800]                       invokeRestart <- base::invokeRestart
[13:33:41.800]                       is.null <- base::is.null
[13:33:41.800]                       muffled <- FALSE
[13:33:41.800]                       if (inherits(cond, "message")) {
[13:33:41.800]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.800]                         if (muffled) 
[13:33:41.800]                           invokeRestart("muffleMessage")
[13:33:41.800]                       }
[13:33:41.800]                       else if (inherits(cond, "warning")) {
[13:33:41.800]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.800]                         if (muffled) 
[13:33:41.800]                           invokeRestart("muffleWarning")
[13:33:41.800]                       }
[13:33:41.800]                       else if (inherits(cond, "condition")) {
[13:33:41.800]                         if (!is.null(pattern)) {
[13:33:41.800]                           computeRestarts <- base::computeRestarts
[13:33:41.800]                           grepl <- base::grepl
[13:33:41.800]                           restarts <- computeRestarts(cond)
[13:33:41.800]                           for (restart in restarts) {
[13:33:41.800]                             name <- restart$name
[13:33:41.800]                             if (is.null(name)) 
[13:33:41.800]                               next
[13:33:41.800]                             if (!grepl(pattern, name)) 
[13:33:41.800]                               next
[13:33:41.800]                             invokeRestart(restart)
[13:33:41.800]                             muffled <- TRUE
[13:33:41.800]                             break
[13:33:41.800]                           }
[13:33:41.800]                         }
[13:33:41.800]                       }
[13:33:41.800]                       invisible(muffled)
[13:33:41.800]                     }
[13:33:41.800]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.800]                   }
[13:33:41.800]                 }
[13:33:41.800]             }
[13:33:41.800]         }))
[13:33:41.800]     }, error = function(ex) {
[13:33:41.800]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:41.800]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.800]                 ...future.rng), started = ...future.startTime, 
[13:33:41.800]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:41.800]             version = "1.8"), class = "FutureResult")
[13:33:41.800]     }, finally = {
[13:33:41.800]         if (!identical(...future.workdir, getwd())) 
[13:33:41.800]             setwd(...future.workdir)
[13:33:41.800]         {
[13:33:41.800]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:41.800]                 ...future.oldOptions$nwarnings <- NULL
[13:33:41.800]             }
[13:33:41.800]             base::options(...future.oldOptions)
[13:33:41.800]             if (.Platform$OS.type == "windows") {
[13:33:41.800]                 old_names <- names(...future.oldEnvVars)
[13:33:41.800]                 envs <- base::Sys.getenv()
[13:33:41.800]                 names <- names(envs)
[13:33:41.800]                 common <- intersect(names, old_names)
[13:33:41.800]                 added <- setdiff(names, old_names)
[13:33:41.800]                 removed <- setdiff(old_names, names)
[13:33:41.800]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:41.800]                   envs[common]]
[13:33:41.800]                 NAMES <- toupper(changed)
[13:33:41.800]                 args <- list()
[13:33:41.800]                 for (kk in seq_along(NAMES)) {
[13:33:41.800]                   name <- changed[[kk]]
[13:33:41.800]                   NAME <- NAMES[[kk]]
[13:33:41.800]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.800]                     next
[13:33:41.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.800]                 }
[13:33:41.800]                 NAMES <- toupper(added)
[13:33:41.800]                 for (kk in seq_along(NAMES)) {
[13:33:41.800]                   name <- added[[kk]]
[13:33:41.800]                   NAME <- NAMES[[kk]]
[13:33:41.800]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.800]                     next
[13:33:41.800]                   args[[name]] <- ""
[13:33:41.800]                 }
[13:33:41.800]                 NAMES <- toupper(removed)
[13:33:41.800]                 for (kk in seq_along(NAMES)) {
[13:33:41.800]                   name <- removed[[kk]]
[13:33:41.800]                   NAME <- NAMES[[kk]]
[13:33:41.800]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.800]                     next
[13:33:41.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.800]                 }
[13:33:41.800]                 if (length(args) > 0) 
[13:33:41.800]                   base::do.call(base::Sys.setenv, args = args)
[13:33:41.800]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:41.800]             }
[13:33:41.800]             else {
[13:33:41.800]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:41.800]             }
[13:33:41.800]             {
[13:33:41.800]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:41.800]                   0L) {
[13:33:41.800]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:41.800]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:41.800]                   base::options(opts)
[13:33:41.800]                 }
[13:33:41.800]                 {
[13:33:41.800]                   {
[13:33:41.800]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:41.800]                     NULL
[13:33:41.800]                   }
[13:33:41.800]                   options(future.plan = NULL)
[13:33:41.800]                   if (is.na(NA_character_)) 
[13:33:41.800]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.800]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:41.800]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:41.800]                     .init = FALSE)
[13:33:41.800]                 }
[13:33:41.800]             }
[13:33:41.800]         }
[13:33:41.800]     })
[13:33:41.800]     if (TRUE) {
[13:33:41.800]         base::sink(type = "output", split = FALSE)
[13:33:41.800]         if (TRUE) {
[13:33:41.800]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:41.800]         }
[13:33:41.800]         else {
[13:33:41.800]             ...future.result["stdout"] <- base::list(NULL)
[13:33:41.800]         }
[13:33:41.800]         base::close(...future.stdout)
[13:33:41.800]         ...future.stdout <- NULL
[13:33:41.800]     }
[13:33:41.800]     ...future.result$conditions <- ...future.conditions
[13:33:41.800]     ...future.result$finished <- base::Sys.time()
[13:33:41.800]     ...future.result
[13:33:41.800] }
[13:33:41.806] assign_globals() ...
[13:33:41.806] List of 5
[13:33:41.806]  $ ...future.FUN            :function (object, ...)  
[13:33:41.806]  $ future.call.arguments    : list()
[13:33:41.806]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.806]  $ ...future.elements_ii    :List of 2
[13:33:41.806]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:33:41.806]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:33:41.806]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.806]   ..$ :'data.frame':	18 obs. of  2 variables:
[13:33:41.806]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:33:41.806]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:41.806]  $ ...future.seeds_ii       : NULL
[13:33:41.806]  $ ...future.globals.maxSize: NULL
[13:33:41.806]  - attr(*, "where")=List of 5
[13:33:41.806]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:41.806]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:41.806]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:41.806]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:41.806]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:41.806]  - attr(*, "resolved")= logi FALSE
[13:33:41.806]  - attr(*, "total_size")= num 1240
[13:33:41.806]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.806]  - attr(*, "already-done")= logi TRUE
[13:33:41.818] - copied ‘...future.FUN’ to environment
[13:33:41.818] - copied ‘future.call.arguments’ to environment
[13:33:41.818] - copied ‘...future.elements_ii’ to environment
[13:33:41.819] - copied ‘...future.seeds_ii’ to environment
[13:33:41.819] - copied ‘...future.globals.maxSize’ to environment
[13:33:41.819] assign_globals() ... done
[13:33:41.819] requestCore(): workers = 2
[13:33:41.824] MulticoreFuture started
[13:33:41.824] - Launch lazy future ... done
[13:33:41.824] run() for ‘MulticoreFuture’ ... done
[13:33:41.825] Created future:
[13:33:41.825] plan(): Setting new future strategy stack:
[13:33:41.825] List of future strategies:
[13:33:41.825] 1. sequential:
[13:33:41.825]    - args: function (..., envir = parent.frame())
[13:33:41.825]    - tweaked: FALSE
[13:33:41.825]    - call: NULL
[13:33:41.826] plan(): nbrOfWorkers() = 1
[13:33:41.829] plan(): Setting new future strategy stack:
[13:33:41.830] List of future strategies:
[13:33:41.830] 1. multicore:
[13:33:41.830]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:41.830]    - tweaked: FALSE
[13:33:41.830]    - call: plan(strategy)
[13:33:41.835] plan(): nbrOfWorkers() = 2
[13:33:41.825] MulticoreFuture:
[13:33:41.825] Label: ‘future_by-2’
[13:33:41.825] Expression:
[13:33:41.825] {
[13:33:41.825]     do.call(function(...) {
[13:33:41.825]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.825]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.825]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.825]             on.exit(options(oopts), add = TRUE)
[13:33:41.825]         }
[13:33:41.825]         {
[13:33:41.825]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.825]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.825]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.825]             })
[13:33:41.825]         }
[13:33:41.825]     }, args = future.call.arguments)
[13:33:41.825] }
[13:33:41.825] Lazy evaluation: FALSE
[13:33:41.825] Asynchronous evaluation: TRUE
[13:33:41.825] Local evaluation: TRUE
[13:33:41.825] Environment: R_GlobalEnv
[13:33:41.825] Capture standard output: TRUE
[13:33:41.825] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:41.825] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:41.825] Packages: <none>
[13:33:41.825] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:41.825] Resolved: TRUE
[13:33:41.825] Value: <not collected>
[13:33:41.825] Conditions captured: <none>
[13:33:41.825] Early signaling: FALSE
[13:33:41.825] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:41.825] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:41.836] Chunk #2 of 2 ... DONE
[13:33:41.836] Launching 2 futures (chunks) ... DONE
[13:33:41.836] Resolving 2 futures (chunks) ...
[13:33:41.836] resolve() on list ...
[13:33:41.836]  recursive: 0
[13:33:41.836]  length: 2
[13:33:41.837] 
[13:33:41.837] Future #1
[13:33:41.838] result() for MulticoreFuture ...
[13:33:41.839] result() for MulticoreFuture ...
[13:33:41.840] result() for MulticoreFuture ... done
[13:33:41.840] result() for MulticoreFuture ... done
[13:33:41.840] result() for MulticoreFuture ...
[13:33:41.840] result() for MulticoreFuture ... done
[13:33:41.840] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:33:41.840] - nx: 2
[13:33:41.840] - relay: TRUE
[13:33:41.841] - stdout: TRUE
[13:33:41.841] - signal: TRUE
[13:33:41.841] - resignal: FALSE
[13:33:41.841] - force: TRUE
[13:33:41.841] - relayed: [n=2] FALSE, FALSE
[13:33:41.841] - queued futures: [n=2] FALSE, FALSE
[13:33:41.841]  - until=1
[13:33:41.842]  - relaying element #1
[13:33:41.842] result() for MulticoreFuture ...
[13:33:41.842] result() for MulticoreFuture ... done
[13:33:41.842] result() for MulticoreFuture ...
[13:33:41.842] result() for MulticoreFuture ... done
[13:33:41.842] result() for MulticoreFuture ...
[13:33:41.843] result() for MulticoreFuture ... done
[13:33:41.843] result() for MulticoreFuture ...
[13:33:41.843] result() for MulticoreFuture ... done
[13:33:41.843] - relayed: [n=2] TRUE, FALSE
[13:33:41.843] - queued futures: [n=2] TRUE, FALSE
[13:33:41.843] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:33:41.843]  length: 1 (resolved future 1)
[13:33:41.853] Future #2
[13:33:41.853] result() for MulticoreFuture ...
[13:33:41.853] result() for MulticoreFuture ...
[13:33:41.854] result() for MulticoreFuture ... done
[13:33:41.854] result() for MulticoreFuture ... done
[13:33:41.854] result() for MulticoreFuture ...
[13:33:41.854] result() for MulticoreFuture ... done
[13:33:41.854] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:33:41.854] - nx: 2
[13:33:41.854] - relay: TRUE
[13:33:41.854] - stdout: TRUE
[13:33:41.855] - signal: TRUE
[13:33:41.855] - resignal: FALSE
[13:33:41.855] - force: TRUE
[13:33:41.855] - relayed: [n=2] TRUE, FALSE
[13:33:41.855] - queued futures: [n=2] TRUE, FALSE
[13:33:41.855]  - until=2
[13:33:41.855]  - relaying element #2
[13:33:41.856] result() for MulticoreFuture ...
[13:33:41.856] result() for MulticoreFuture ... done
[13:33:41.856] result() for MulticoreFuture ...
[13:33:41.856] result() for MulticoreFuture ... done
[13:33:41.856] result() for MulticoreFuture ...
[13:33:41.856] result() for MulticoreFuture ... done
[13:33:41.856] result() for MulticoreFuture ...
[13:33:41.857] result() for MulticoreFuture ... done
[13:33:41.857] - relayed: [n=2] TRUE, TRUE
[13:33:41.857] - queued futures: [n=2] TRUE, TRUE
[13:33:41.857] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:33:41.857]  length: 0 (resolved future 2)
[13:33:41.857] Relaying remaining futures
[13:33:41.857] signalConditionsASAP(NULL, pos=0) ...
[13:33:41.858] - nx: 2
[13:33:41.858] - relay: TRUE
[13:33:41.858] - stdout: TRUE
[13:33:41.858] - signal: TRUE
[13:33:41.858] - resignal: FALSE
[13:33:41.858] - force: TRUE
[13:33:41.858] - relayed: [n=2] TRUE, TRUE
[13:33:41.859] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:41.859] - relayed: [n=2] TRUE, TRUE
[13:33:41.859] - queued futures: [n=2] TRUE, TRUE
[13:33:41.859] signalConditionsASAP(NULL, pos=0) ... done
[13:33:41.859] resolve() on list ... DONE
[13:33:41.859] result() for MulticoreFuture ...
[13:33:41.859] result() for MulticoreFuture ... done
[13:33:41.860] result() for MulticoreFuture ...
[13:33:41.860] result() for MulticoreFuture ... done
[13:33:41.860] result() for MulticoreFuture ...
[13:33:41.860] result() for MulticoreFuture ... done
[13:33:41.860] result() for MulticoreFuture ...
[13:33:41.860] result() for MulticoreFuture ... done
[13:33:41.860]  - Number of value chunks collected: 2
[13:33:41.860] Resolving 2 futures (chunks) ... DONE
[13:33:41.861] Reducing values from 2 chunks ...
[13:33:41.861]  - Number of values collected after concatenation: 3
[13:33:41.861]  - Number of values expected: 3
[13:33:41.861] Reducing values from 2 chunks ... DONE
[13:33:41.861] future_lapply() ... DONE
[13:33:41.861] future_by_internal() ... DONE
[13:33:41.862] future_by_internal() ...
[13:33:41.862] future_lapply() ...
[13:33:41.867] Number of chunks: 2
[13:33:41.867] getGlobalsAndPackagesXApply() ...
[13:33:41.867]  - future.globals: TRUE
[13:33:41.867] getGlobalsAndPackages() ...
[13:33:41.867] Searching for globals...
[13:33:41.868] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:41.869] Searching for globals ... DONE
[13:33:41.869] Resolving globals: FALSE
[13:33:41.869] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:41.869] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:41.870] - globals: [1] ‘FUN’
[13:33:41.870] 
[13:33:41.870] getGlobalsAndPackages() ... DONE
[13:33:41.870]  - globals found/used: [n=1] ‘FUN’
[13:33:41.870]  - needed namespaces: [n=0] 
[13:33:41.870] Finding globals ... DONE
[13:33:41.870]  - use_args: TRUE
[13:33:41.870]  - Getting '...' globals ...
[13:33:41.871] resolve() on list ...
[13:33:41.871]  recursive: 0
[13:33:41.871]  length: 1
[13:33:41.871]  elements: ‘...’
[13:33:41.871]  length: 0 (resolved future 1)
[13:33:41.871] resolve() on list ... DONE
[13:33:41.871]    - '...' content: [n=1] ‘digits’
[13:33:41.871] List of 1
[13:33:41.871]  $ ...:List of 1
[13:33:41.871]   ..$ digits: int 2
[13:33:41.871]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.871]  - attr(*, "where")=List of 1
[13:33:41.871]   ..$ ...:<environment: 0x55cb81643cd0> 
[13:33:41.871]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.871]  - attr(*, "resolved")= logi TRUE
[13:33:41.871]  - attr(*, "total_size")= num NA
[13:33:41.875]  - Getting '...' globals ... DONE
[13:33:41.875] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:41.875] List of 2
[13:33:41.875]  $ ...future.FUN:function (object, ...)  
[13:33:41.875]  $ ...          :List of 1
[13:33:41.875]   ..$ digits: int 2
[13:33:41.875]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.875]  - attr(*, "where")=List of 2
[13:33:41.875]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:41.875]   ..$ ...          :<environment: 0x55cb81643cd0> 
[13:33:41.875]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.875]  - attr(*, "resolved")= logi FALSE
[13:33:41.875]  - attr(*, "total_size")= num 1296
[13:33:41.880] Packages to be attached in all futures: [n=0] 
[13:33:41.880] getGlobalsAndPackagesXApply() ... DONE
[13:33:41.880] Number of futures (= number of chunks): 2
[13:33:41.880] Launching 2 futures (chunks) ...
[13:33:41.881] Chunk #1 of 2 ...
[13:33:41.881]  - Finding globals in 'X' for chunk #1 ...
[13:33:41.881] getGlobalsAndPackages() ...
[13:33:41.881] Searching for globals...
[13:33:41.881] 
[13:33:41.881] Searching for globals ... DONE
[13:33:41.881] - globals: [0] <none>
[13:33:41.881] getGlobalsAndPackages() ... DONE
[13:33:41.882]    + additional globals found: [n=0] 
[13:33:41.882]    + additional namespaces needed: [n=0] 
[13:33:41.882]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:41.882]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:41.882]  - seeds: <none>
[13:33:41.882]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.882] getGlobalsAndPackages() ...
[13:33:41.882] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.883] Resolving globals: FALSE
[13:33:41.883] Tweak future expression to call with '...' arguments ...
[13:33:41.883] {
[13:33:41.883]     do.call(function(...) {
[13:33:41.883]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.883]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.883]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.883]             on.exit(options(oopts), add = TRUE)
[13:33:41.883]         }
[13:33:41.883]         {
[13:33:41.883]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.883]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.883]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.883]             })
[13:33:41.883]         }
[13:33:41.883]     }, args = future.call.arguments)
[13:33:41.883] }
[13:33:41.883] Tweak future expression to call with '...' arguments ... DONE
[13:33:41.883] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.884] 
[13:33:41.884] getGlobalsAndPackages() ... DONE
[13:33:41.884] run() for ‘Future’ ...
[13:33:41.884] - state: ‘created’
[13:33:41.884] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:41.888] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:41.888] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:41.888]   - Field: ‘label’
[13:33:41.888]   - Field: ‘local’
[13:33:41.888]   - Field: ‘owner’
[13:33:41.889]   - Field: ‘envir’
[13:33:41.889]   - Field: ‘workers’
[13:33:41.889]   - Field: ‘packages’
[13:33:41.889]   - Field: ‘gc’
[13:33:41.889]   - Field: ‘job’
[13:33:41.889]   - Field: ‘conditions’
[13:33:41.889]   - Field: ‘expr’
[13:33:41.889]   - Field: ‘uuid’
[13:33:41.889]   - Field: ‘seed’
[13:33:41.889]   - Field: ‘version’
[13:33:41.889]   - Field: ‘result’
[13:33:41.890]   - Field: ‘asynchronous’
[13:33:41.890]   - Field: ‘calls’
[13:33:41.890]   - Field: ‘globals’
[13:33:41.890]   - Field: ‘stdout’
[13:33:41.890]   - Field: ‘earlySignal’
[13:33:41.890]   - Field: ‘lazy’
[13:33:41.890]   - Field: ‘state’
[13:33:41.890] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:41.890] - Launch lazy future ...
[13:33:41.891] Packages needed by the future expression (n = 0): <none>
[13:33:41.891] Packages needed by future strategies (n = 0): <none>
[13:33:41.891] {
[13:33:41.891]     {
[13:33:41.891]         {
[13:33:41.891]             ...future.startTime <- base::Sys.time()
[13:33:41.891]             {
[13:33:41.891]                 {
[13:33:41.891]                   {
[13:33:41.891]                     {
[13:33:41.891]                       base::local({
[13:33:41.891]                         has_future <- base::requireNamespace("future", 
[13:33:41.891]                           quietly = TRUE)
[13:33:41.891]                         if (has_future) {
[13:33:41.891]                           ns <- base::getNamespace("future")
[13:33:41.891]                           version <- ns[[".package"]][["version"]]
[13:33:41.891]                           if (is.null(version)) 
[13:33:41.891]                             version <- utils::packageVersion("future")
[13:33:41.891]                         }
[13:33:41.891]                         else {
[13:33:41.891]                           version <- NULL
[13:33:41.891]                         }
[13:33:41.891]                         if (!has_future || version < "1.8.0") {
[13:33:41.891]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:41.891]                             "", base::R.version$version.string), 
[13:33:41.891]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:41.891]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:41.891]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:41.891]                               "release", "version")], collapse = " "), 
[13:33:41.891]                             hostname = base::Sys.info()[["nodename"]])
[13:33:41.891]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:41.891]                             info)
[13:33:41.891]                           info <- base::paste(info, collapse = "; ")
[13:33:41.891]                           if (!has_future) {
[13:33:41.891]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:41.891]                               info)
[13:33:41.891]                           }
[13:33:41.891]                           else {
[13:33:41.891]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:41.891]                               info, version)
[13:33:41.891]                           }
[13:33:41.891]                           base::stop(msg)
[13:33:41.891]                         }
[13:33:41.891]                       })
[13:33:41.891]                     }
[13:33:41.891]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:41.891]                     base::options(mc.cores = 1L)
[13:33:41.891]                   }
[13:33:41.891]                   ...future.strategy.old <- future::plan("list")
[13:33:41.891]                   options(future.plan = NULL)
[13:33:41.891]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.891]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:41.891]                 }
[13:33:41.891]                 ...future.workdir <- getwd()
[13:33:41.891]             }
[13:33:41.891]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:41.891]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:41.891]         }
[13:33:41.891]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:41.891]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:41.891]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:41.891]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:41.891]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:41.891]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:41.891]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:41.891]             base::names(...future.oldOptions))
[13:33:41.891]     }
[13:33:41.891]     if (FALSE) {
[13:33:41.891]     }
[13:33:41.891]     else {
[13:33:41.891]         if (TRUE) {
[13:33:41.891]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:41.891]                 open = "w")
[13:33:41.891]         }
[13:33:41.891]         else {
[13:33:41.891]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:41.891]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:41.891]         }
[13:33:41.891]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:41.891]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:41.891]             base::sink(type = "output", split = FALSE)
[13:33:41.891]             base::close(...future.stdout)
[13:33:41.891]         }, add = TRUE)
[13:33:41.891]     }
[13:33:41.891]     ...future.frame <- base::sys.nframe()
[13:33:41.891]     ...future.conditions <- base::list()
[13:33:41.891]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:41.891]     if (FALSE) {
[13:33:41.891]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:41.891]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:41.891]     }
[13:33:41.891]     ...future.result <- base::tryCatch({
[13:33:41.891]         base::withCallingHandlers({
[13:33:41.891]             ...future.value <- base::withVisible(base::local({
[13:33:41.891]                 withCallingHandlers({
[13:33:41.891]                   {
[13:33:41.891]                     do.call(function(...) {
[13:33:41.891]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.891]                       if (!identical(...future.globals.maxSize.org, 
[13:33:41.891]                         ...future.globals.maxSize)) {
[13:33:41.891]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.891]                         on.exit(options(oopts), add = TRUE)
[13:33:41.891]                       }
[13:33:41.891]                       {
[13:33:41.891]                         lapply(seq_along(...future.elements_ii), 
[13:33:41.891]                           FUN = function(jj) {
[13:33:41.891]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.891]                             ...future.FUN(...future.X_jj, ...)
[13:33:41.891]                           })
[13:33:41.891]                       }
[13:33:41.891]                     }, args = future.call.arguments)
[13:33:41.891]                   }
[13:33:41.891]                 }, immediateCondition = function(cond) {
[13:33:41.891]                   save_rds <- function (object, pathname, ...) 
[13:33:41.891]                   {
[13:33:41.891]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:41.891]                     if (file_test("-f", pathname_tmp)) {
[13:33:41.891]                       fi_tmp <- file.info(pathname_tmp)
[13:33:41.891]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:41.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:41.891]                         fi_tmp[["mtime"]])
[13:33:41.891]                     }
[13:33:41.891]                     tryCatch({
[13:33:41.891]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:41.891]                     }, error = function(ex) {
[13:33:41.891]                       msg <- conditionMessage(ex)
[13:33:41.891]                       fi_tmp <- file.info(pathname_tmp)
[13:33:41.891]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:41.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:41.891]                         fi_tmp[["mtime"]], msg)
[13:33:41.891]                       ex$message <- msg
[13:33:41.891]                       stop(ex)
[13:33:41.891]                     })
[13:33:41.891]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:41.891]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:41.891]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:41.891]                       fi_tmp <- file.info(pathname_tmp)
[13:33:41.891]                       fi <- file.info(pathname)
[13:33:41.891]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:41.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:41.891]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:41.891]                         fi[["size"]], fi[["mtime"]])
[13:33:41.891]                       stop(msg)
[13:33:41.891]                     }
[13:33:41.891]                     invisible(pathname)
[13:33:41.891]                   }
[13:33:41.891]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:41.891]                     rootPath = tempdir()) 
[13:33:41.891]                   {
[13:33:41.891]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:41.891]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:41.891]                       tmpdir = path, fileext = ".rds")
[13:33:41.891]                     save_rds(obj, file)
[13:33:41.891]                   }
[13:33:41.891]                   saveImmediateCondition(cond, path = "/tmp/RtmpMLLN1L/.future/immediateConditions")
[13:33:41.891]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.891]                   {
[13:33:41.891]                     inherits <- base::inherits
[13:33:41.891]                     invokeRestart <- base::invokeRestart
[13:33:41.891]                     is.null <- base::is.null
[13:33:41.891]                     muffled <- FALSE
[13:33:41.891]                     if (inherits(cond, "message")) {
[13:33:41.891]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:41.891]                       if (muffled) 
[13:33:41.891]                         invokeRestart("muffleMessage")
[13:33:41.891]                     }
[13:33:41.891]                     else if (inherits(cond, "warning")) {
[13:33:41.891]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:41.891]                       if (muffled) 
[13:33:41.891]                         invokeRestart("muffleWarning")
[13:33:41.891]                     }
[13:33:41.891]                     else if (inherits(cond, "condition")) {
[13:33:41.891]                       if (!is.null(pattern)) {
[13:33:41.891]                         computeRestarts <- base::computeRestarts
[13:33:41.891]                         grepl <- base::grepl
[13:33:41.891]                         restarts <- computeRestarts(cond)
[13:33:41.891]                         for (restart in restarts) {
[13:33:41.891]                           name <- restart$name
[13:33:41.891]                           if (is.null(name)) 
[13:33:41.891]                             next
[13:33:41.891]                           if (!grepl(pattern, name)) 
[13:33:41.891]                             next
[13:33:41.891]                           invokeRestart(restart)
[13:33:41.891]                           muffled <- TRUE
[13:33:41.891]                           break
[13:33:41.891]                         }
[13:33:41.891]                       }
[13:33:41.891]                     }
[13:33:41.891]                     invisible(muffled)
[13:33:41.891]                   }
[13:33:41.891]                   muffleCondition(cond)
[13:33:41.891]                 })
[13:33:41.891]             }))
[13:33:41.891]             future::FutureResult(value = ...future.value$value, 
[13:33:41.891]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.891]                   ...future.rng), globalenv = if (FALSE) 
[13:33:41.891]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:41.891]                     ...future.globalenv.names))
[13:33:41.891]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:41.891]         }, condition = base::local({
[13:33:41.891]             c <- base::c
[13:33:41.891]             inherits <- base::inherits
[13:33:41.891]             invokeRestart <- base::invokeRestart
[13:33:41.891]             length <- base::length
[13:33:41.891]             list <- base::list
[13:33:41.891]             seq.int <- base::seq.int
[13:33:41.891]             signalCondition <- base::signalCondition
[13:33:41.891]             sys.calls <- base::sys.calls
[13:33:41.891]             `[[` <- base::`[[`
[13:33:41.891]             `+` <- base::`+`
[13:33:41.891]             `<<-` <- base::`<<-`
[13:33:41.891]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:41.891]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:41.891]                   3L)]
[13:33:41.891]             }
[13:33:41.891]             function(cond) {
[13:33:41.891]                 is_error <- inherits(cond, "error")
[13:33:41.891]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:41.891]                   NULL)
[13:33:41.891]                 if (is_error) {
[13:33:41.891]                   sessionInformation <- function() {
[13:33:41.891]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:41.891]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:41.891]                       search = base::search(), system = base::Sys.info())
[13:33:41.891]                   }
[13:33:41.891]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.891]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:41.891]                     cond$call), session = sessionInformation(), 
[13:33:41.891]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:41.891]                   signalCondition(cond)
[13:33:41.891]                 }
[13:33:41.891]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:41.891]                 "immediateCondition"))) {
[13:33:41.891]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:41.891]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.891]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:41.891]                   if (TRUE && !signal) {
[13:33:41.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.891]                     {
[13:33:41.891]                       inherits <- base::inherits
[13:33:41.891]                       invokeRestart <- base::invokeRestart
[13:33:41.891]                       is.null <- base::is.null
[13:33:41.891]                       muffled <- FALSE
[13:33:41.891]                       if (inherits(cond, "message")) {
[13:33:41.891]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.891]                         if (muffled) 
[13:33:41.891]                           invokeRestart("muffleMessage")
[13:33:41.891]                       }
[13:33:41.891]                       else if (inherits(cond, "warning")) {
[13:33:41.891]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.891]                         if (muffled) 
[13:33:41.891]                           invokeRestart("muffleWarning")
[13:33:41.891]                       }
[13:33:41.891]                       else if (inherits(cond, "condition")) {
[13:33:41.891]                         if (!is.null(pattern)) {
[13:33:41.891]                           computeRestarts <- base::computeRestarts
[13:33:41.891]                           grepl <- base::grepl
[13:33:41.891]                           restarts <- computeRestarts(cond)
[13:33:41.891]                           for (restart in restarts) {
[13:33:41.891]                             name <- restart$name
[13:33:41.891]                             if (is.null(name)) 
[13:33:41.891]                               next
[13:33:41.891]                             if (!grepl(pattern, name)) 
[13:33:41.891]                               next
[13:33:41.891]                             invokeRestart(restart)
[13:33:41.891]                             muffled <- TRUE
[13:33:41.891]                             break
[13:33:41.891]                           }
[13:33:41.891]                         }
[13:33:41.891]                       }
[13:33:41.891]                       invisible(muffled)
[13:33:41.891]                     }
[13:33:41.891]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.891]                   }
[13:33:41.891]                 }
[13:33:41.891]                 else {
[13:33:41.891]                   if (TRUE) {
[13:33:41.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.891]                     {
[13:33:41.891]                       inherits <- base::inherits
[13:33:41.891]                       invokeRestart <- base::invokeRestart
[13:33:41.891]                       is.null <- base::is.null
[13:33:41.891]                       muffled <- FALSE
[13:33:41.891]                       if (inherits(cond, "message")) {
[13:33:41.891]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.891]                         if (muffled) 
[13:33:41.891]                           invokeRestart("muffleMessage")
[13:33:41.891]                       }
[13:33:41.891]                       else if (inherits(cond, "warning")) {
[13:33:41.891]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.891]                         if (muffled) 
[13:33:41.891]                           invokeRestart("muffleWarning")
[13:33:41.891]                       }
[13:33:41.891]                       else if (inherits(cond, "condition")) {
[13:33:41.891]                         if (!is.null(pattern)) {
[13:33:41.891]                           computeRestarts <- base::computeRestarts
[13:33:41.891]                           grepl <- base::grepl
[13:33:41.891]                           restarts <- computeRestarts(cond)
[13:33:41.891]                           for (restart in restarts) {
[13:33:41.891]                             name <- restart$name
[13:33:41.891]                             if (is.null(name)) 
[13:33:41.891]                               next
[13:33:41.891]                             if (!grepl(pattern, name)) 
[13:33:41.891]                               next
[13:33:41.891]                             invokeRestart(restart)
[13:33:41.891]                             muffled <- TRUE
[13:33:41.891]                             break
[13:33:41.891]                           }
[13:33:41.891]                         }
[13:33:41.891]                       }
[13:33:41.891]                       invisible(muffled)
[13:33:41.891]                     }
[13:33:41.891]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.891]                   }
[13:33:41.891]                 }
[13:33:41.891]             }
[13:33:41.891]         }))
[13:33:41.891]     }, error = function(ex) {
[13:33:41.891]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:41.891]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.891]                 ...future.rng), started = ...future.startTime, 
[13:33:41.891]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:41.891]             version = "1.8"), class = "FutureResult")
[13:33:41.891]     }, finally = {
[13:33:41.891]         if (!identical(...future.workdir, getwd())) 
[13:33:41.891]             setwd(...future.workdir)
[13:33:41.891]         {
[13:33:41.891]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:41.891]                 ...future.oldOptions$nwarnings <- NULL
[13:33:41.891]             }
[13:33:41.891]             base::options(...future.oldOptions)
[13:33:41.891]             if (.Platform$OS.type == "windows") {
[13:33:41.891]                 old_names <- names(...future.oldEnvVars)
[13:33:41.891]                 envs <- base::Sys.getenv()
[13:33:41.891]                 names <- names(envs)
[13:33:41.891]                 common <- intersect(names, old_names)
[13:33:41.891]                 added <- setdiff(names, old_names)
[13:33:41.891]                 removed <- setdiff(old_names, names)
[13:33:41.891]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:41.891]                   envs[common]]
[13:33:41.891]                 NAMES <- toupper(changed)
[13:33:41.891]                 args <- list()
[13:33:41.891]                 for (kk in seq_along(NAMES)) {
[13:33:41.891]                   name <- changed[[kk]]
[13:33:41.891]                   NAME <- NAMES[[kk]]
[13:33:41.891]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.891]                     next
[13:33:41.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.891]                 }
[13:33:41.891]                 NAMES <- toupper(added)
[13:33:41.891]                 for (kk in seq_along(NAMES)) {
[13:33:41.891]                   name <- added[[kk]]
[13:33:41.891]                   NAME <- NAMES[[kk]]
[13:33:41.891]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.891]                     next
[13:33:41.891]                   args[[name]] <- ""
[13:33:41.891]                 }
[13:33:41.891]                 NAMES <- toupper(removed)
[13:33:41.891]                 for (kk in seq_along(NAMES)) {
[13:33:41.891]                   name <- removed[[kk]]
[13:33:41.891]                   NAME <- NAMES[[kk]]
[13:33:41.891]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.891]                     next
[13:33:41.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.891]                 }
[13:33:41.891]                 if (length(args) > 0) 
[13:33:41.891]                   base::do.call(base::Sys.setenv, args = args)
[13:33:41.891]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:41.891]             }
[13:33:41.891]             else {
[13:33:41.891]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:41.891]             }
[13:33:41.891]             {
[13:33:41.891]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:41.891]                   0L) {
[13:33:41.891]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:41.891]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:41.891]                   base::options(opts)
[13:33:41.891]                 }
[13:33:41.891]                 {
[13:33:41.891]                   {
[13:33:41.891]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:41.891]                     NULL
[13:33:41.891]                   }
[13:33:41.891]                   options(future.plan = NULL)
[13:33:41.891]                   if (is.na(NA_character_)) 
[13:33:41.891]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.891]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:41.891]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:41.891]                     .init = FALSE)
[13:33:41.891]                 }
[13:33:41.891]             }
[13:33:41.891]         }
[13:33:41.891]     })
[13:33:41.891]     if (TRUE) {
[13:33:41.891]         base::sink(type = "output", split = FALSE)
[13:33:41.891]         if (TRUE) {
[13:33:41.891]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:41.891]         }
[13:33:41.891]         else {
[13:33:41.891]             ...future.result["stdout"] <- base::list(NULL)
[13:33:41.891]         }
[13:33:41.891]         base::close(...future.stdout)
[13:33:41.891]         ...future.stdout <- NULL
[13:33:41.891]     }
[13:33:41.891]     ...future.result$conditions <- ...future.conditions
[13:33:41.891]     ...future.result$finished <- base::Sys.time()
[13:33:41.891]     ...future.result
[13:33:41.891] }
[13:33:41.894] assign_globals() ...
[13:33:41.894] List of 5
[13:33:41.894]  $ ...future.FUN            :function (object, ...)  
[13:33:41.894]  $ future.call.arguments    :List of 1
[13:33:41.894]   ..$ digits: int 2
[13:33:41.894]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.894]  $ ...future.elements_ii    :List of 3
[13:33:41.894]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[13:33:41.894]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[13:33:41.894]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[13:33:41.894]  $ ...future.seeds_ii       : NULL
[13:33:41.894]  $ ...future.globals.maxSize: NULL
[13:33:41.894]  - attr(*, "where")=List of 5
[13:33:41.894]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:41.894]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:41.894]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:41.894]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:41.894]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:41.894]  - attr(*, "resolved")= logi FALSE
[13:33:41.894]  - attr(*, "total_size")= num 1296
[13:33:41.894]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.894]  - attr(*, "already-done")= logi TRUE
[13:33:41.899] - copied ‘...future.FUN’ to environment
[13:33:41.899] - copied ‘future.call.arguments’ to environment
[13:33:41.899] - copied ‘...future.elements_ii’ to environment
[13:33:41.900] - copied ‘...future.seeds_ii’ to environment
[13:33:41.900] - copied ‘...future.globals.maxSize’ to environment
[13:33:41.900] assign_globals() ... done
[13:33:41.900] requestCore(): workers = 2
[13:33:41.902] MulticoreFuture started
[13:33:41.902] - Launch lazy future ... done
[13:33:41.902] run() for ‘MulticoreFuture’ ... done
[13:33:41.903] Created future:
[13:33:41.903] plan(): Setting new future strategy stack:
[13:33:41.903] List of future strategies:
[13:33:41.903] 1. sequential:
[13:33:41.903]    - args: function (..., envir = parent.frame())
[13:33:41.903]    - tweaked: FALSE
[13:33:41.903]    - call: NULL
[13:33:41.904] plan(): nbrOfWorkers() = 1
[13:33:41.911] plan(): Setting new future strategy stack:
[13:33:41.911] List of future strategies:
[13:33:41.911] 1. multicore:
[13:33:41.911]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:41.911]    - tweaked: FALSE
[13:33:41.911]    - call: plan(strategy)
[13:33:41.903] MulticoreFuture:
[13:33:41.903] Label: ‘future_by-1’
[13:33:41.903] Expression:
[13:33:41.903] {
[13:33:41.903]     do.call(function(...) {
[13:33:41.903]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.903]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.903]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.903]             on.exit(options(oopts), add = TRUE)
[13:33:41.903]         }
[13:33:41.903]         {
[13:33:41.903]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.903]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.903]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.903]             })
[13:33:41.903]         }
[13:33:41.903]     }, args = future.call.arguments)
[13:33:41.903] }
[13:33:41.903] Lazy evaluation: FALSE
[13:33:41.903] Asynchronous evaluation: TRUE
[13:33:41.903] Local evaluation: TRUE
[13:33:41.903] Environment: R_GlobalEnv
[13:33:41.903] Capture standard output: TRUE
[13:33:41.903] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:41.903] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:41.903] Packages: <none>
[13:33:41.903] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:41.903] Resolved: FALSE
[13:33:41.903] Value: <not collected>
[13:33:41.903] Conditions captured: <none>
[13:33:41.903] Early signaling: FALSE
[13:33:41.903] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:41.903] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:41.918] Chunk #1 of 2 ... DONE
[13:33:41.918] Chunk #2 of 2 ...
[13:33:41.919] plan(): nbrOfWorkers() = 2
[13:33:41.919]  - Finding globals in 'X' for chunk #2 ...
[13:33:41.919] getGlobalsAndPackages() ...
[13:33:41.919] Searching for globals...
[13:33:41.920] 
[13:33:41.920] Searching for globals ... DONE
[13:33:41.920] - globals: [0] <none>
[13:33:41.921] getGlobalsAndPackages() ... DONE
[13:33:41.921]    + additional globals found: [n=0] 
[13:33:41.921]    + additional namespaces needed: [n=0] 
[13:33:41.921]  - Finding globals in 'X' for chunk #2 ... DONE
[13:33:41.921]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:41.922]  - seeds: <none>
[13:33:41.922]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.922] getGlobalsAndPackages() ...
[13:33:41.922] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.922] Resolving globals: FALSE
[13:33:41.923] Tweak future expression to call with '...' arguments ...
[13:33:41.923] {
[13:33:41.923]     do.call(function(...) {
[13:33:41.923]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.923]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.923]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.923]             on.exit(options(oopts), add = TRUE)
[13:33:41.923]         }
[13:33:41.923]         {
[13:33:41.923]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.923]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.923]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.923]             })
[13:33:41.923]         }
[13:33:41.923]     }, args = future.call.arguments)
[13:33:41.923] }
[13:33:41.924] Tweak future expression to call with '...' arguments ... DONE
[13:33:41.924] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:41.925] 
[13:33:41.925] getGlobalsAndPackages() ... DONE
[13:33:41.925] run() for ‘Future’ ...
[13:33:41.926] - state: ‘created’
[13:33:41.926] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:41.931] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:41.931] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:41.931]   - Field: ‘label’
[13:33:41.932]   - Field: ‘local’
[13:33:41.932]   - Field: ‘owner’
[13:33:41.932]   - Field: ‘envir’
[13:33:41.932]   - Field: ‘workers’
[13:33:41.932]   - Field: ‘packages’
[13:33:41.932]   - Field: ‘gc’
[13:33:41.933]   - Field: ‘job’
[13:33:41.933]   - Field: ‘conditions’
[13:33:41.933]   - Field: ‘expr’
[13:33:41.933]   - Field: ‘uuid’
[13:33:41.933]   - Field: ‘seed’
[13:33:41.934]   - Field: ‘version’
[13:33:41.934]   - Field: ‘result’
[13:33:41.934]   - Field: ‘asynchronous’
[13:33:41.934]   - Field: ‘calls’
[13:33:41.934]   - Field: ‘globals’
[13:33:41.934]   - Field: ‘stdout’
[13:33:41.935]   - Field: ‘earlySignal’
[13:33:41.935]   - Field: ‘lazy’
[13:33:41.935]   - Field: ‘state’
[13:33:41.935] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:41.935] - Launch lazy future ...
[13:33:41.935] Packages needed by the future expression (n = 0): <none>
[13:33:41.936] Packages needed by future strategies (n = 0): <none>
[13:33:41.936] {
[13:33:41.936]     {
[13:33:41.936]         {
[13:33:41.936]             ...future.startTime <- base::Sys.time()
[13:33:41.936]             {
[13:33:41.936]                 {
[13:33:41.936]                   {
[13:33:41.936]                     {
[13:33:41.936]                       base::local({
[13:33:41.936]                         has_future <- base::requireNamespace("future", 
[13:33:41.936]                           quietly = TRUE)
[13:33:41.936]                         if (has_future) {
[13:33:41.936]                           ns <- base::getNamespace("future")
[13:33:41.936]                           version <- ns[[".package"]][["version"]]
[13:33:41.936]                           if (is.null(version)) 
[13:33:41.936]                             version <- utils::packageVersion("future")
[13:33:41.936]                         }
[13:33:41.936]                         else {
[13:33:41.936]                           version <- NULL
[13:33:41.936]                         }
[13:33:41.936]                         if (!has_future || version < "1.8.0") {
[13:33:41.936]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:41.936]                             "", base::R.version$version.string), 
[13:33:41.936]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:41.936]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:41.936]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:41.936]                               "release", "version")], collapse = " "), 
[13:33:41.936]                             hostname = base::Sys.info()[["nodename"]])
[13:33:41.936]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:41.936]                             info)
[13:33:41.936]                           info <- base::paste(info, collapse = "; ")
[13:33:41.936]                           if (!has_future) {
[13:33:41.936]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:41.936]                               info)
[13:33:41.936]                           }
[13:33:41.936]                           else {
[13:33:41.936]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:41.936]                               info, version)
[13:33:41.936]                           }
[13:33:41.936]                           base::stop(msg)
[13:33:41.936]                         }
[13:33:41.936]                       })
[13:33:41.936]                     }
[13:33:41.936]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:41.936]                     base::options(mc.cores = 1L)
[13:33:41.936]                   }
[13:33:41.936]                   ...future.strategy.old <- future::plan("list")
[13:33:41.936]                   options(future.plan = NULL)
[13:33:41.936]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.936]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:41.936]                 }
[13:33:41.936]                 ...future.workdir <- getwd()
[13:33:41.936]             }
[13:33:41.936]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:41.936]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:41.936]         }
[13:33:41.936]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:41.936]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:41.936]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:41.936]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:41.936]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:41.936]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:41.936]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:41.936]             base::names(...future.oldOptions))
[13:33:41.936]     }
[13:33:41.936]     if (FALSE) {
[13:33:41.936]     }
[13:33:41.936]     else {
[13:33:41.936]         if (TRUE) {
[13:33:41.936]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:41.936]                 open = "w")
[13:33:41.936]         }
[13:33:41.936]         else {
[13:33:41.936]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:41.936]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:41.936]         }
[13:33:41.936]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:41.936]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:41.936]             base::sink(type = "output", split = FALSE)
[13:33:41.936]             base::close(...future.stdout)
[13:33:41.936]         }, add = TRUE)
[13:33:41.936]     }
[13:33:41.936]     ...future.frame <- base::sys.nframe()
[13:33:41.936]     ...future.conditions <- base::list()
[13:33:41.936]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:41.936]     if (FALSE) {
[13:33:41.936]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:41.936]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:41.936]     }
[13:33:41.936]     ...future.result <- base::tryCatch({
[13:33:41.936]         base::withCallingHandlers({
[13:33:41.936]             ...future.value <- base::withVisible(base::local({
[13:33:41.936]                 withCallingHandlers({
[13:33:41.936]                   {
[13:33:41.936]                     do.call(function(...) {
[13:33:41.936]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.936]                       if (!identical(...future.globals.maxSize.org, 
[13:33:41.936]                         ...future.globals.maxSize)) {
[13:33:41.936]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.936]                         on.exit(options(oopts), add = TRUE)
[13:33:41.936]                       }
[13:33:41.936]                       {
[13:33:41.936]                         lapply(seq_along(...future.elements_ii), 
[13:33:41.936]                           FUN = function(jj) {
[13:33:41.936]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.936]                             ...future.FUN(...future.X_jj, ...)
[13:33:41.936]                           })
[13:33:41.936]                       }
[13:33:41.936]                     }, args = future.call.arguments)
[13:33:41.936]                   }
[13:33:41.936]                 }, immediateCondition = function(cond) {
[13:33:41.936]                   save_rds <- function (object, pathname, ...) 
[13:33:41.936]                   {
[13:33:41.936]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:41.936]                     if (file_test("-f", pathname_tmp)) {
[13:33:41.936]                       fi_tmp <- file.info(pathname_tmp)
[13:33:41.936]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:41.936]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:41.936]                         fi_tmp[["mtime"]])
[13:33:41.936]                     }
[13:33:41.936]                     tryCatch({
[13:33:41.936]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:41.936]                     }, error = function(ex) {
[13:33:41.936]                       msg <- conditionMessage(ex)
[13:33:41.936]                       fi_tmp <- file.info(pathname_tmp)
[13:33:41.936]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:41.936]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:41.936]                         fi_tmp[["mtime"]], msg)
[13:33:41.936]                       ex$message <- msg
[13:33:41.936]                       stop(ex)
[13:33:41.936]                     })
[13:33:41.936]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:41.936]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:41.936]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:41.936]                       fi_tmp <- file.info(pathname_tmp)
[13:33:41.936]                       fi <- file.info(pathname)
[13:33:41.936]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:41.936]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:41.936]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:41.936]                         fi[["size"]], fi[["mtime"]])
[13:33:41.936]                       stop(msg)
[13:33:41.936]                     }
[13:33:41.936]                     invisible(pathname)
[13:33:41.936]                   }
[13:33:41.936]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:41.936]                     rootPath = tempdir()) 
[13:33:41.936]                   {
[13:33:41.936]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:41.936]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:41.936]                       tmpdir = path, fileext = ".rds")
[13:33:41.936]                     save_rds(obj, file)
[13:33:41.936]                   }
[13:33:41.936]                   saveImmediateCondition(cond, path = "/tmp/RtmpMLLN1L/.future/immediateConditions")
[13:33:41.936]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.936]                   {
[13:33:41.936]                     inherits <- base::inherits
[13:33:41.936]                     invokeRestart <- base::invokeRestart
[13:33:41.936]                     is.null <- base::is.null
[13:33:41.936]                     muffled <- FALSE
[13:33:41.936]                     if (inherits(cond, "message")) {
[13:33:41.936]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:41.936]                       if (muffled) 
[13:33:41.936]                         invokeRestart("muffleMessage")
[13:33:41.936]                     }
[13:33:41.936]                     else if (inherits(cond, "warning")) {
[13:33:41.936]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:41.936]                       if (muffled) 
[13:33:41.936]                         invokeRestart("muffleWarning")
[13:33:41.936]                     }
[13:33:41.936]                     else if (inherits(cond, "condition")) {
[13:33:41.936]                       if (!is.null(pattern)) {
[13:33:41.936]                         computeRestarts <- base::computeRestarts
[13:33:41.936]                         grepl <- base::grepl
[13:33:41.936]                         restarts <- computeRestarts(cond)
[13:33:41.936]                         for (restart in restarts) {
[13:33:41.936]                           name <- restart$name
[13:33:41.936]                           if (is.null(name)) 
[13:33:41.936]                             next
[13:33:41.936]                           if (!grepl(pattern, name)) 
[13:33:41.936]                             next
[13:33:41.936]                           invokeRestart(restart)
[13:33:41.936]                           muffled <- TRUE
[13:33:41.936]                           break
[13:33:41.936]                         }
[13:33:41.936]                       }
[13:33:41.936]                     }
[13:33:41.936]                     invisible(muffled)
[13:33:41.936]                   }
[13:33:41.936]                   muffleCondition(cond)
[13:33:41.936]                 })
[13:33:41.936]             }))
[13:33:41.936]             future::FutureResult(value = ...future.value$value, 
[13:33:41.936]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.936]                   ...future.rng), globalenv = if (FALSE) 
[13:33:41.936]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:41.936]                     ...future.globalenv.names))
[13:33:41.936]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:41.936]         }, condition = base::local({
[13:33:41.936]             c <- base::c
[13:33:41.936]             inherits <- base::inherits
[13:33:41.936]             invokeRestart <- base::invokeRestart
[13:33:41.936]             length <- base::length
[13:33:41.936]             list <- base::list
[13:33:41.936]             seq.int <- base::seq.int
[13:33:41.936]             signalCondition <- base::signalCondition
[13:33:41.936]             sys.calls <- base::sys.calls
[13:33:41.936]             `[[` <- base::`[[`
[13:33:41.936]             `+` <- base::`+`
[13:33:41.936]             `<<-` <- base::`<<-`
[13:33:41.936]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:41.936]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:41.936]                   3L)]
[13:33:41.936]             }
[13:33:41.936]             function(cond) {
[13:33:41.936]                 is_error <- inherits(cond, "error")
[13:33:41.936]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:41.936]                   NULL)
[13:33:41.936]                 if (is_error) {
[13:33:41.936]                   sessionInformation <- function() {
[13:33:41.936]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:41.936]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:41.936]                       search = base::search(), system = base::Sys.info())
[13:33:41.936]                   }
[13:33:41.936]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.936]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:41.936]                     cond$call), session = sessionInformation(), 
[13:33:41.936]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:41.936]                   signalCondition(cond)
[13:33:41.936]                 }
[13:33:41.936]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:41.936]                 "immediateCondition"))) {
[13:33:41.936]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:41.936]                   ...future.conditions[[length(...future.conditions) + 
[13:33:41.936]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:41.936]                   if (TRUE && !signal) {
[13:33:41.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.936]                     {
[13:33:41.936]                       inherits <- base::inherits
[13:33:41.936]                       invokeRestart <- base::invokeRestart
[13:33:41.936]                       is.null <- base::is.null
[13:33:41.936]                       muffled <- FALSE
[13:33:41.936]                       if (inherits(cond, "message")) {
[13:33:41.936]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.936]                         if (muffled) 
[13:33:41.936]                           invokeRestart("muffleMessage")
[13:33:41.936]                       }
[13:33:41.936]                       else if (inherits(cond, "warning")) {
[13:33:41.936]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.936]                         if (muffled) 
[13:33:41.936]                           invokeRestart("muffleWarning")
[13:33:41.936]                       }
[13:33:41.936]                       else if (inherits(cond, "condition")) {
[13:33:41.936]                         if (!is.null(pattern)) {
[13:33:41.936]                           computeRestarts <- base::computeRestarts
[13:33:41.936]                           grepl <- base::grepl
[13:33:41.936]                           restarts <- computeRestarts(cond)
[13:33:41.936]                           for (restart in restarts) {
[13:33:41.936]                             name <- restart$name
[13:33:41.936]                             if (is.null(name)) 
[13:33:41.936]                               next
[13:33:41.936]                             if (!grepl(pattern, name)) 
[13:33:41.936]                               next
[13:33:41.936]                             invokeRestart(restart)
[13:33:41.936]                             muffled <- TRUE
[13:33:41.936]                             break
[13:33:41.936]                           }
[13:33:41.936]                         }
[13:33:41.936]                       }
[13:33:41.936]                       invisible(muffled)
[13:33:41.936]                     }
[13:33:41.936]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.936]                   }
[13:33:41.936]                 }
[13:33:41.936]                 else {
[13:33:41.936]                   if (TRUE) {
[13:33:41.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:41.936]                     {
[13:33:41.936]                       inherits <- base::inherits
[13:33:41.936]                       invokeRestart <- base::invokeRestart
[13:33:41.936]                       is.null <- base::is.null
[13:33:41.936]                       muffled <- FALSE
[13:33:41.936]                       if (inherits(cond, "message")) {
[13:33:41.936]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:41.936]                         if (muffled) 
[13:33:41.936]                           invokeRestart("muffleMessage")
[13:33:41.936]                       }
[13:33:41.936]                       else if (inherits(cond, "warning")) {
[13:33:41.936]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:41.936]                         if (muffled) 
[13:33:41.936]                           invokeRestart("muffleWarning")
[13:33:41.936]                       }
[13:33:41.936]                       else if (inherits(cond, "condition")) {
[13:33:41.936]                         if (!is.null(pattern)) {
[13:33:41.936]                           computeRestarts <- base::computeRestarts
[13:33:41.936]                           grepl <- base::grepl
[13:33:41.936]                           restarts <- computeRestarts(cond)
[13:33:41.936]                           for (restart in restarts) {
[13:33:41.936]                             name <- restart$name
[13:33:41.936]                             if (is.null(name)) 
[13:33:41.936]                               next
[13:33:41.936]                             if (!grepl(pattern, name)) 
[13:33:41.936]                               next
[13:33:41.936]                             invokeRestart(restart)
[13:33:41.936]                             muffled <- TRUE
[13:33:41.936]                             break
[13:33:41.936]                           }
[13:33:41.936]                         }
[13:33:41.936]                       }
[13:33:41.936]                       invisible(muffled)
[13:33:41.936]                     }
[13:33:41.936]                     muffleCondition(cond, pattern = "^muffle")
[13:33:41.936]                   }
[13:33:41.936]                 }
[13:33:41.936]             }
[13:33:41.936]         }))
[13:33:41.936]     }, error = function(ex) {
[13:33:41.936]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:41.936]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:41.936]                 ...future.rng), started = ...future.startTime, 
[13:33:41.936]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:41.936]             version = "1.8"), class = "FutureResult")
[13:33:41.936]     }, finally = {
[13:33:41.936]         if (!identical(...future.workdir, getwd())) 
[13:33:41.936]             setwd(...future.workdir)
[13:33:41.936]         {
[13:33:41.936]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:41.936]                 ...future.oldOptions$nwarnings <- NULL
[13:33:41.936]             }
[13:33:41.936]             base::options(...future.oldOptions)
[13:33:41.936]             if (.Platform$OS.type == "windows") {
[13:33:41.936]                 old_names <- names(...future.oldEnvVars)
[13:33:41.936]                 envs <- base::Sys.getenv()
[13:33:41.936]                 names <- names(envs)
[13:33:41.936]                 common <- intersect(names, old_names)
[13:33:41.936]                 added <- setdiff(names, old_names)
[13:33:41.936]                 removed <- setdiff(old_names, names)
[13:33:41.936]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:41.936]                   envs[common]]
[13:33:41.936]                 NAMES <- toupper(changed)
[13:33:41.936]                 args <- list()
[13:33:41.936]                 for (kk in seq_along(NAMES)) {
[13:33:41.936]                   name <- changed[[kk]]
[13:33:41.936]                   NAME <- NAMES[[kk]]
[13:33:41.936]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.936]                     next
[13:33:41.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.936]                 }
[13:33:41.936]                 NAMES <- toupper(added)
[13:33:41.936]                 for (kk in seq_along(NAMES)) {
[13:33:41.936]                   name <- added[[kk]]
[13:33:41.936]                   NAME <- NAMES[[kk]]
[13:33:41.936]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.936]                     next
[13:33:41.936]                   args[[name]] <- ""
[13:33:41.936]                 }
[13:33:41.936]                 NAMES <- toupper(removed)
[13:33:41.936]                 for (kk in seq_along(NAMES)) {
[13:33:41.936]                   name <- removed[[kk]]
[13:33:41.936]                   NAME <- NAMES[[kk]]
[13:33:41.936]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:41.936]                     next
[13:33:41.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:41.936]                 }
[13:33:41.936]                 if (length(args) > 0) 
[13:33:41.936]                   base::do.call(base::Sys.setenv, args = args)
[13:33:41.936]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:41.936]             }
[13:33:41.936]             else {
[13:33:41.936]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:41.936]             }
[13:33:41.936]             {
[13:33:41.936]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:41.936]                   0L) {
[13:33:41.936]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:41.936]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:41.936]                   base::options(opts)
[13:33:41.936]                 }
[13:33:41.936]                 {
[13:33:41.936]                   {
[13:33:41.936]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:41.936]                     NULL
[13:33:41.936]                   }
[13:33:41.936]                   options(future.plan = NULL)
[13:33:41.936]                   if (is.na(NA_character_)) 
[13:33:41.936]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:41.936]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:41.936]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:41.936]                     .init = FALSE)
[13:33:41.936]                 }
[13:33:41.936]             }
[13:33:41.936]         }
[13:33:41.936]     })
[13:33:41.936]     if (TRUE) {
[13:33:41.936]         base::sink(type = "output", split = FALSE)
[13:33:41.936]         if (TRUE) {
[13:33:41.936]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:41.936]         }
[13:33:41.936]         else {
[13:33:41.936]             ...future.result["stdout"] <- base::list(NULL)
[13:33:41.936]         }
[13:33:41.936]         base::close(...future.stdout)
[13:33:41.936]         ...future.stdout <- NULL
[13:33:41.936]     }
[13:33:41.936]     ...future.result$conditions <- ...future.conditions
[13:33:41.936]     ...future.result$finished <- base::Sys.time()
[13:33:41.936]     ...future.result
[13:33:41.936] }
[13:33:41.939] assign_globals() ...
[13:33:41.939] List of 5
[13:33:41.939]  $ ...future.FUN            :function (object, ...)  
[13:33:41.939]  $ future.call.arguments    :List of 1
[13:33:41.939]   ..$ digits: int 2
[13:33:41.939]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:41.939]  $ ...future.elements_ii    :List of 3
[13:33:41.939]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[13:33:41.939]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[13:33:41.939]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[13:33:41.939]  $ ...future.seeds_ii       : NULL
[13:33:41.939]  $ ...future.globals.maxSize: NULL
[13:33:41.939]  - attr(*, "where")=List of 5
[13:33:41.939]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:41.939]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:41.939]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:41.939]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:41.939]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:41.939]  - attr(*, "resolved")= logi FALSE
[13:33:41.939]  - attr(*, "total_size")= num 1296
[13:33:41.939]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:41.939]  - attr(*, "already-done")= logi TRUE
[13:33:41.946] - copied ‘...future.FUN’ to environment
[13:33:41.946] - copied ‘future.call.arguments’ to environment
[13:33:41.947] - copied ‘...future.elements_ii’ to environment
[13:33:41.947] - copied ‘...future.seeds_ii’ to environment
[13:33:41.947] - copied ‘...future.globals.maxSize’ to environment
[13:33:41.947] assign_globals() ... done
[13:33:41.947] requestCore(): workers = 2
[13:33:41.949] MulticoreFuture started
[13:33:41.950] - Launch lazy future ... done
[13:33:41.950] run() for ‘MulticoreFuture’ ... done
[13:33:41.950] Created future:
[13:33:41.950] plan(): Setting new future strategy stack:
[13:33:41.951] List of future strategies:
[13:33:41.951] 1. sequential:
[13:33:41.951]    - args: function (..., envir = parent.frame())
[13:33:41.951]    - tweaked: FALSE
[13:33:41.951]    - call: NULL
[13:33:41.951] plan(): nbrOfWorkers() = 1
[13:33:41.954] plan(): Setting new future strategy stack:
[13:33:41.954] List of future strategies:
[13:33:41.954] 1. multicore:
[13:33:41.954]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:41.954]    - tweaked: FALSE
[13:33:41.954]    - call: plan(strategy)
[13:33:41.950] MulticoreFuture:
[13:33:41.950] Label: ‘future_by-2’
[13:33:41.950] Expression:
[13:33:41.950] {
[13:33:41.950]     do.call(function(...) {
[13:33:41.950]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:41.950]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:41.950]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:41.950]             on.exit(options(oopts), add = TRUE)
[13:33:41.950]         }
[13:33:41.950]         {
[13:33:41.950]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:41.950]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:41.950]                 ...future.FUN(...future.X_jj, ...)
[13:33:41.950]             })
[13:33:41.950]         }
[13:33:41.950]     }, args = future.call.arguments)
[13:33:41.950] }
[13:33:41.950] Lazy evaluation: FALSE
[13:33:41.950] Asynchronous evaluation: TRUE
[13:33:41.950] Local evaluation: TRUE
[13:33:41.950] Environment: R_GlobalEnv
[13:33:41.950] Capture standard output: TRUE
[13:33:41.950] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:41.950] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:41.950] Packages: <none>
[13:33:41.950] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:41.950] Resolved: FALSE
[13:33:41.950] Value: <not collected>
[13:33:41.950] Conditions captured: <none>
[13:33:41.950] Early signaling: FALSE
[13:33:41.950] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:41.950] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:41.963] Chunk #2 of 2 ... DONE
[13:33:41.963] Launching 2 futures (chunks) ... DONE
[13:33:41.964] Resolving 2 futures (chunks) ...
[13:33:41.964] resolve() on list ...
[13:33:41.964]  recursive: 0
[13:33:41.964]  length: 2
[13:33:41.964] 
[13:33:41.965] Future #1
[13:33:41.965] result() for MulticoreFuture ...
[13:33:41.965] plan(): nbrOfWorkers() = 2
[13:33:41.969] result() for MulticoreFuture ...
[13:33:41.969] result() for MulticoreFuture ... done
[13:33:41.970] result() for MulticoreFuture ... done
[13:33:41.970] result() for MulticoreFuture ...
[13:33:41.970] result() for MulticoreFuture ... done
[13:33:41.970] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:33:41.971] - nx: 2
[13:33:41.971] - relay: TRUE
[13:33:41.971] - stdout: TRUE
[13:33:41.971] - signal: TRUE
[13:33:41.972] - resignal: FALSE
[13:33:41.972] - force: TRUE
[13:33:41.972] - relayed: [n=2] FALSE, FALSE
[13:33:41.973] - queued futures: [n=2] FALSE, FALSE
[13:33:41.973]  - until=1
[13:33:41.973]  - relaying element #1
[13:33:41.973] result() for MulticoreFuture ...
[13:33:41.974] result() for MulticoreFuture ... done
[13:33:41.974] result() for MulticoreFuture ...
[13:33:41.974] result() for MulticoreFuture ... done
[13:33:41.975] result() for MulticoreFuture ...
[13:33:41.975] result() for MulticoreFuture ... done
[13:33:41.975] result() for MulticoreFuture ...
[13:33:41.975] result() for MulticoreFuture ... done
[13:33:41.975] - relayed: [n=2] TRUE, FALSE
[13:33:41.976] - queued futures: [n=2] TRUE, FALSE
[13:33:41.976] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:33:41.976]  length: 1 (resolved future 1)
[13:33:41.976] Future #2
[13:33:41.977] result() for MulticoreFuture ...
[13:33:41.978] result() for MulticoreFuture ...
[13:33:41.978] result() for MulticoreFuture ... done
[13:33:41.978] result() for MulticoreFuture ... done
[13:33:41.979] result() for MulticoreFuture ...
[13:33:41.979] result() for MulticoreFuture ... done
[13:33:41.979] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:33:41.979] - nx: 2
[13:33:41.980] - relay: TRUE
[13:33:41.980] - stdout: TRUE
[13:33:41.980] - signal: TRUE
[13:33:41.980] - resignal: FALSE
[13:33:41.980] - force: TRUE
[13:33:41.980] - relayed: [n=2] TRUE, FALSE
[13:33:41.981] - queued futures: [n=2] TRUE, FALSE
[13:33:41.981]  - until=2
[13:33:41.981]  - relaying element #2
[13:33:41.981] result() for MulticoreFuture ...
[13:33:41.981] result() for MulticoreFuture ... done
[13:33:41.981] result() for MulticoreFuture ...
[13:33:41.982] result() for MulticoreFuture ... done
[13:33:41.982] result() for MulticoreFuture ...
[13:33:41.982] result() for MulticoreFuture ... done
[13:33:41.982] result() for MulticoreFuture ...
[13:33:41.982] result() for MulticoreFuture ... done
[13:33:41.982] - relayed: [n=2] TRUE, TRUE
[13:33:41.983] - queued futures: [n=2] TRUE, TRUE
[13:33:41.983] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:33:41.983]  length: 0 (resolved future 2)
[13:33:41.983] Relaying remaining futures
[13:33:41.983] signalConditionsASAP(NULL, pos=0) ...
[13:33:41.983] - nx: 2
[13:33:41.983] - relay: TRUE
[13:33:41.983] - stdout: TRUE
[13:33:41.983] - signal: TRUE
[13:33:41.984] - resignal: FALSE
[13:33:41.984] - force: TRUE
[13:33:41.984] - relayed: [n=2] TRUE, TRUE
[13:33:41.984] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:41.984] - relayed: [n=2] TRUE, TRUE
[13:33:41.984] - queued futures: [n=2] TRUE, TRUE
[13:33:41.984] signalConditionsASAP(NULL, pos=0) ... done
[13:33:41.984] resolve() on list ... DONE
[13:33:41.984] result() for MulticoreFuture ...
[13:33:41.985] result() for MulticoreFuture ... done
[13:33:41.985] result() for MulticoreFuture ...
[13:33:41.985] result() for MulticoreFuture ... done
[13:33:41.985] result() for MulticoreFuture ...
[13:33:41.985] result() for MulticoreFuture ... done
[13:33:41.985] result() for MulticoreFuture ...
[13:33:41.985] result() for MulticoreFuture ... done
[13:33:41.985]  - Number of value chunks collected: 2
[13:33:41.985] Resolving 2 futures (chunks) ... DONE
[13:33:41.986] Reducing values from 2 chunks ...
[13:33:41.986]  - Number of values collected after concatenation: 6
[13:33:41.986]  - Number of values expected: 6
[13:33:41.986] Reducing values from 2 chunks ... DONE
[13:33:41.986] future_lapply() ... DONE
[13:33:41.986] future_by_internal() ... DONE
[13:33:41.987] future_by_internal() ...
[13:33:41.988] future_lapply() ...
[13:33:41.993] Number of chunks: 2
[13:33:41.993] getGlobalsAndPackagesXApply() ...
[13:33:41.993]  - future.globals: TRUE
[13:33:41.993] getGlobalsAndPackages() ...
[13:33:41.993] Searching for globals...
[13:33:41.995] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:33:41.995] Searching for globals ... DONE
[13:33:41.995] Resolving globals: FALSE
[13:33:41.996] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[13:33:41.996] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[13:33:41.996] - globals: [1] ‘FUN’
[13:33:41.996] - packages: [1] ‘stats’
[13:33:41.996] getGlobalsAndPackages() ... DONE
[13:33:41.996]  - globals found/used: [n=1] ‘FUN’
[13:33:41.996]  - needed namespaces: [n=1] ‘stats’
[13:33:41.997] Finding globals ... DONE
[13:33:41.997]  - use_args: TRUE
[13:33:41.997]  - Getting '...' globals ...
[13:33:41.997] resolve() on list ...
[13:33:41.997]  recursive: 0
[13:33:41.997]  length: 1
[13:33:41.997]  elements: ‘...’
[13:33:41.998]  length: 0 (resolved future 1)
[13:33:42.000] resolve() on list ... DONE
[13:33:42.000]    - '...' content: [n=1] ‘singular.ok’
[13:33:42.000] List of 1
[13:33:42.000]  $ ...:List of 1
[13:33:42.000]   ..$ singular.ok: logi FALSE
[13:33:42.000]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:42.000]  - attr(*, "where")=List of 1
[13:33:42.000]   ..$ ...:<environment: 0x55cb810799b0> 
[13:33:42.000]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:42.000]  - attr(*, "resolved")= logi TRUE
[13:33:42.000]  - attr(*, "total_size")= num NA
[13:33:42.004]  - Getting '...' globals ... DONE
[13:33:42.004] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:42.004] List of 2
[13:33:42.004]  $ ...future.FUN:function (x, ...)  
[13:33:42.004]  $ ...          :List of 1
[13:33:42.004]   ..$ singular.ok: logi FALSE
[13:33:42.004]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:42.004]  - attr(*, "where")=List of 2
[13:33:42.004]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:42.004]   ..$ ...          :<environment: 0x55cb810799b0> 
[13:33:42.004]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:42.004]  - attr(*, "resolved")= logi FALSE
[13:33:42.004]  - attr(*, "total_size")= num 5384
[13:33:42.007] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:42.007] getGlobalsAndPackagesXApply() ... DONE
[13:33:42.008] Number of futures (= number of chunks): 2
[13:33:42.008] Launching 2 futures (chunks) ...
[13:33:42.008] Chunk #1 of 2 ...
[13:33:42.008]  - Finding globals in 'X' for chunk #1 ...
[13:33:42.008] getGlobalsAndPackages() ...
[13:33:42.008] Searching for globals...
[13:33:42.008] 
[13:33:42.009] Searching for globals ... DONE
[13:33:42.009] - globals: [0] <none>
[13:33:42.009] getGlobalsAndPackages() ... DONE
[13:33:42.009]    + additional globals found: [n=0] 
[13:33:42.009]    + additional namespaces needed: [n=0] 
[13:33:42.009]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:42.009]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:42.009]  - seeds: <none>
[13:33:42.009]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:42.009] getGlobalsAndPackages() ...
[13:33:42.010] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:42.010] Resolving globals: FALSE
[13:33:42.010] Tweak future expression to call with '...' arguments ...
[13:33:42.010] {
[13:33:42.010]     do.call(function(...) {
[13:33:42.010]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:42.010]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:42.010]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:42.010]             on.exit(options(oopts), add = TRUE)
[13:33:42.010]         }
[13:33:42.010]         {
[13:33:42.010]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:42.010]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:42.010]                 ...future.FUN(...future.X_jj, ...)
[13:33:42.010]             })
[13:33:42.010]         }
[13:33:42.010]     }, args = future.call.arguments)
[13:33:42.010] }
[13:33:42.010] Tweak future expression to call with '...' arguments ... DONE
[13:33:42.010] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:42.011] 
[13:33:42.011] getGlobalsAndPackages() ... DONE
[13:33:42.011] run() for ‘Future’ ...
[13:33:42.011] - state: ‘created’
[13:33:42.011] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:42.015] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:42.015] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:42.015]   - Field: ‘label’
[13:33:42.015]   - Field: ‘local’
[13:33:42.015]   - Field: ‘owner’
[13:33:42.015]   - Field: ‘envir’
[13:33:42.016]   - Field: ‘workers’
[13:33:42.016]   - Field: ‘packages’
[13:33:42.016]   - Field: ‘gc’
[13:33:42.016]   - Field: ‘job’
[13:33:42.016]   - Field: ‘conditions’
[13:33:42.016]   - Field: ‘expr’
[13:33:42.016]   - Field: ‘uuid’
[13:33:42.016]   - Field: ‘seed’
[13:33:42.016]   - Field: ‘version’
[13:33:42.016]   - Field: ‘result’
[13:33:42.016]   - Field: ‘asynchronous’
[13:33:42.017]   - Field: ‘calls’
[13:33:42.017]   - Field: ‘globals’
[13:33:42.017]   - Field: ‘stdout’
[13:33:42.017]   - Field: ‘earlySignal’
[13:33:42.017]   - Field: ‘lazy’
[13:33:42.017]   - Field: ‘state’
[13:33:42.017] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:42.017] - Launch lazy future ...
[13:33:42.017] Packages needed by the future expression (n = 1): ‘stats’
[13:33:42.018] Packages needed by future strategies (n = 0): <none>
[13:33:42.018] {
[13:33:42.018]     {
[13:33:42.018]         {
[13:33:42.018]             ...future.startTime <- base::Sys.time()
[13:33:42.018]             {
[13:33:42.018]                 {
[13:33:42.018]                   {
[13:33:42.018]                     {
[13:33:42.018]                       {
[13:33:42.018]                         base::local({
[13:33:42.018]                           has_future <- base::requireNamespace("future", 
[13:33:42.018]                             quietly = TRUE)
[13:33:42.018]                           if (has_future) {
[13:33:42.018]                             ns <- base::getNamespace("future")
[13:33:42.018]                             version <- ns[[".package"]][["version"]]
[13:33:42.018]                             if (is.null(version)) 
[13:33:42.018]                               version <- utils::packageVersion("future")
[13:33:42.018]                           }
[13:33:42.018]                           else {
[13:33:42.018]                             version <- NULL
[13:33:42.018]                           }
[13:33:42.018]                           if (!has_future || version < "1.8.0") {
[13:33:42.018]                             info <- base::c(r_version = base::gsub("R version ", 
[13:33:42.018]                               "", base::R.version$version.string), 
[13:33:42.018]                               platform = base::sprintf("%s (%s-bit)", 
[13:33:42.018]                                 base::R.version$platform, 8 * 
[13:33:42.018]                                   base::.Machine$sizeof.pointer), 
[13:33:42.018]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:42.018]                                 "release", "version")], collapse = " "), 
[13:33:42.018]                               hostname = base::Sys.info()[["nodename"]])
[13:33:42.018]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:33:42.018]                               info)
[13:33:42.018]                             info <- base::paste(info, collapse = "; ")
[13:33:42.018]                             if (!has_future) {
[13:33:42.018]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:42.018]                                 info)
[13:33:42.018]                             }
[13:33:42.018]                             else {
[13:33:42.018]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:42.018]                                 info, version)
[13:33:42.018]                             }
[13:33:42.018]                             base::stop(msg)
[13:33:42.018]                           }
[13:33:42.018]                         })
[13:33:42.018]                       }
[13:33:42.018]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:42.018]                       base::options(mc.cores = 1L)
[13:33:42.018]                     }
[13:33:42.018]                     base::local({
[13:33:42.018]                       for (pkg in "stats") {
[13:33:42.018]                         base::loadNamespace(pkg)
[13:33:42.018]                         base::library(pkg, character.only = TRUE)
[13:33:42.018]                       }
[13:33:42.018]                     })
[13:33:42.018]                   }
[13:33:42.018]                   ...future.strategy.old <- future::plan("list")
[13:33:42.018]                   options(future.plan = NULL)
[13:33:42.018]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:42.018]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:42.018]                 }
[13:33:42.018]                 ...future.workdir <- getwd()
[13:33:42.018]             }
[13:33:42.018]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:42.018]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:42.018]         }
[13:33:42.018]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:42.018]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:42.018]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:42.018]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:42.018]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:42.018]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:42.018]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:42.018]             base::names(...future.oldOptions))
[13:33:42.018]     }
[13:33:42.018]     if (FALSE) {
[13:33:42.018]     }
[13:33:42.018]     else {
[13:33:42.018]         if (TRUE) {
[13:33:42.018]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:42.018]                 open = "w")
[13:33:42.018]         }
[13:33:42.018]         else {
[13:33:42.018]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:42.018]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:42.018]         }
[13:33:42.018]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:42.018]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:42.018]             base::sink(type = "output", split = FALSE)
[13:33:42.018]             base::close(...future.stdout)
[13:33:42.018]         }, add = TRUE)
[13:33:42.018]     }
[13:33:42.018]     ...future.frame <- base::sys.nframe()
[13:33:42.018]     ...future.conditions <- base::list()
[13:33:42.018]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:42.018]     if (FALSE) {
[13:33:42.018]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:42.018]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:42.018]     }
[13:33:42.018]     ...future.result <- base::tryCatch({
[13:33:42.018]         base::withCallingHandlers({
[13:33:42.018]             ...future.value <- base::withVisible(base::local({
[13:33:42.018]                 withCallingHandlers({
[13:33:42.018]                   {
[13:33:42.018]                     do.call(function(...) {
[13:33:42.018]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:42.018]                       if (!identical(...future.globals.maxSize.org, 
[13:33:42.018]                         ...future.globals.maxSize)) {
[13:33:42.018]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:42.018]                         on.exit(options(oopts), add = TRUE)
[13:33:42.018]                       }
[13:33:42.018]                       {
[13:33:42.018]                         lapply(seq_along(...future.elements_ii), 
[13:33:42.018]                           FUN = function(jj) {
[13:33:42.018]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:42.018]                             ...future.FUN(...future.X_jj, ...)
[13:33:42.018]                           })
[13:33:42.018]                       }
[13:33:42.018]                     }, args = future.call.arguments)
[13:33:42.018]                   }
[13:33:42.018]                 }, immediateCondition = function(cond) {
[13:33:42.018]                   save_rds <- function (object, pathname, ...) 
[13:33:42.018]                   {
[13:33:42.018]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:42.018]                     if (file_test("-f", pathname_tmp)) {
[13:33:42.018]                       fi_tmp <- file.info(pathname_tmp)
[13:33:42.018]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:42.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:42.018]                         fi_tmp[["mtime"]])
[13:33:42.018]                     }
[13:33:42.018]                     tryCatch({
[13:33:42.018]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:42.018]                     }, error = function(ex) {
[13:33:42.018]                       msg <- conditionMessage(ex)
[13:33:42.018]                       fi_tmp <- file.info(pathname_tmp)
[13:33:42.018]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:42.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:42.018]                         fi_tmp[["mtime"]], msg)
[13:33:42.018]                       ex$message <- msg
[13:33:42.018]                       stop(ex)
[13:33:42.018]                     })
[13:33:42.018]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:42.018]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:42.018]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:42.018]                       fi_tmp <- file.info(pathname_tmp)
[13:33:42.018]                       fi <- file.info(pathname)
[13:33:42.018]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:42.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:42.018]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:42.018]                         fi[["size"]], fi[["mtime"]])
[13:33:42.018]                       stop(msg)
[13:33:42.018]                     }
[13:33:42.018]                     invisible(pathname)
[13:33:42.018]                   }
[13:33:42.018]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:42.018]                     rootPath = tempdir()) 
[13:33:42.018]                   {
[13:33:42.018]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:42.018]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:42.018]                       tmpdir = path, fileext = ".rds")
[13:33:42.018]                     save_rds(obj, file)
[13:33:42.018]                   }
[13:33:42.018]                   saveImmediateCondition(cond, path = "/tmp/RtmpMLLN1L/.future/immediateConditions")
[13:33:42.018]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:42.018]                   {
[13:33:42.018]                     inherits <- base::inherits
[13:33:42.018]                     invokeRestart <- base::invokeRestart
[13:33:42.018]                     is.null <- base::is.null
[13:33:42.018]                     muffled <- FALSE
[13:33:42.018]                     if (inherits(cond, "message")) {
[13:33:42.018]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:42.018]                       if (muffled) 
[13:33:42.018]                         invokeRestart("muffleMessage")
[13:33:42.018]                     }
[13:33:42.018]                     else if (inherits(cond, "warning")) {
[13:33:42.018]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:42.018]                       if (muffled) 
[13:33:42.018]                         invokeRestart("muffleWarning")
[13:33:42.018]                     }
[13:33:42.018]                     else if (inherits(cond, "condition")) {
[13:33:42.018]                       if (!is.null(pattern)) {
[13:33:42.018]                         computeRestarts <- base::computeRestarts
[13:33:42.018]                         grepl <- base::grepl
[13:33:42.018]                         restarts <- computeRestarts(cond)
[13:33:42.018]                         for (restart in restarts) {
[13:33:42.018]                           name <- restart$name
[13:33:42.018]                           if (is.null(name)) 
[13:33:42.018]                             next
[13:33:42.018]                           if (!grepl(pattern, name)) 
[13:33:42.018]                             next
[13:33:42.018]                           invokeRestart(restart)
[13:33:42.018]                           muffled <- TRUE
[13:33:42.018]                           break
[13:33:42.018]                         }
[13:33:42.018]                       }
[13:33:42.018]                     }
[13:33:42.018]                     invisible(muffled)
[13:33:42.018]                   }
[13:33:42.018]                   muffleCondition(cond)
[13:33:42.018]                 })
[13:33:42.018]             }))
[13:33:42.018]             future::FutureResult(value = ...future.value$value, 
[13:33:42.018]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:42.018]                   ...future.rng), globalenv = if (FALSE) 
[13:33:42.018]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:42.018]                     ...future.globalenv.names))
[13:33:42.018]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:42.018]         }, condition = base::local({
[13:33:42.018]             c <- base::c
[13:33:42.018]             inherits <- base::inherits
[13:33:42.018]             invokeRestart <- base::invokeRestart
[13:33:42.018]             length <- base::length
[13:33:42.018]             list <- base::list
[13:33:42.018]             seq.int <- base::seq.int
[13:33:42.018]             signalCondition <- base::signalCondition
[13:33:42.018]             sys.calls <- base::sys.calls
[13:33:42.018]             `[[` <- base::`[[`
[13:33:42.018]             `+` <- base::`+`
[13:33:42.018]             `<<-` <- base::`<<-`
[13:33:42.018]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:42.018]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:42.018]                   3L)]
[13:33:42.018]             }
[13:33:42.018]             function(cond) {
[13:33:42.018]                 is_error <- inherits(cond, "error")
[13:33:42.018]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:42.018]                   NULL)
[13:33:42.018]                 if (is_error) {
[13:33:42.018]                   sessionInformation <- function() {
[13:33:42.018]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:42.018]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:42.018]                       search = base::search(), system = base::Sys.info())
[13:33:42.018]                   }
[13:33:42.018]                   ...future.conditions[[length(...future.conditions) + 
[13:33:42.018]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:42.018]                     cond$call), session = sessionInformation(), 
[13:33:42.018]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:42.018]                   signalCondition(cond)
[13:33:42.018]                 }
[13:33:42.018]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:42.018]                 "immediateCondition"))) {
[13:33:42.018]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:42.018]                   ...future.conditions[[length(...future.conditions) + 
[13:33:42.018]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:42.018]                   if (TRUE && !signal) {
[13:33:42.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:42.018]                     {
[13:33:42.018]                       inherits <- base::inherits
[13:33:42.018]                       invokeRestart <- base::invokeRestart
[13:33:42.018]                       is.null <- base::is.null
[13:33:42.018]                       muffled <- FALSE
[13:33:42.018]                       if (inherits(cond, "message")) {
[13:33:42.018]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:42.018]                         if (muffled) 
[13:33:42.018]                           invokeRestart("muffleMessage")
[13:33:42.018]                       }
[13:33:42.018]                       else if (inherits(cond, "warning")) {
[13:33:42.018]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:42.018]                         if (muffled) 
[13:33:42.018]                           invokeRestart("muffleWarning")
[13:33:42.018]                       }
[13:33:42.018]                       else if (inherits(cond, "condition")) {
[13:33:42.018]                         if (!is.null(pattern)) {
[13:33:42.018]                           computeRestarts <- base::computeRestarts
[13:33:42.018]                           grepl <- base::grepl
[13:33:42.018]                           restarts <- computeRestarts(cond)
[13:33:42.018]                           for (restart in restarts) {
[13:33:42.018]                             name <- restart$name
[13:33:42.018]                             if (is.null(name)) 
[13:33:42.018]                               next
[13:33:42.018]                             if (!grepl(pattern, name)) 
[13:33:42.018]                               next
[13:33:42.018]                             invokeRestart(restart)
[13:33:42.018]                             muffled <- TRUE
[13:33:42.018]                             break
[13:33:42.018]                           }
[13:33:42.018]                         }
[13:33:42.018]                       }
[13:33:42.018]                       invisible(muffled)
[13:33:42.018]                     }
[13:33:42.018]                     muffleCondition(cond, pattern = "^muffle")
[13:33:42.018]                   }
[13:33:42.018]                 }
[13:33:42.018]                 else {
[13:33:42.018]                   if (TRUE) {
[13:33:42.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:42.018]                     {
[13:33:42.018]                       inherits <- base::inherits
[13:33:42.018]                       invokeRestart <- base::invokeRestart
[13:33:42.018]                       is.null <- base::is.null
[13:33:42.018]                       muffled <- FALSE
[13:33:42.018]                       if (inherits(cond, "message")) {
[13:33:42.018]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:42.018]                         if (muffled) 
[13:33:42.018]                           invokeRestart("muffleMessage")
[13:33:42.018]                       }
[13:33:42.018]                       else if (inherits(cond, "warning")) {
[13:33:42.018]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:42.018]                         if (muffled) 
[13:33:42.018]                           invokeRestart("muffleWarning")
[13:33:42.018]                       }
[13:33:42.018]                       else if (inherits(cond, "condition")) {
[13:33:42.018]                         if (!is.null(pattern)) {
[13:33:42.018]                           computeRestarts <- base::computeRestarts
[13:33:42.018]                           grepl <- base::grepl
[13:33:42.018]                           restarts <- computeRestarts(cond)
[13:33:42.018]                           for (restart in restarts) {
[13:33:42.018]                             name <- restart$name
[13:33:42.018]                             if (is.null(name)) 
[13:33:42.018]                               next
[13:33:42.018]                             if (!grepl(pattern, name)) 
[13:33:42.018]                               next
[13:33:42.018]                             invokeRestart(restart)
[13:33:42.018]                             muffled <- TRUE
[13:33:42.018]                             break
[13:33:42.018]                           }
[13:33:42.018]                         }
[13:33:42.018]                       }
[13:33:42.018]                       invisible(muffled)
[13:33:42.018]                     }
[13:33:42.018]                     muffleCondition(cond, pattern = "^muffle")
[13:33:42.018]                   }
[13:33:42.018]                 }
[13:33:42.018]             }
[13:33:42.018]         }))
[13:33:42.018]     }, error = function(ex) {
[13:33:42.018]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:42.018]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:42.018]                 ...future.rng), started = ...future.startTime, 
[13:33:42.018]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:42.018]             version = "1.8"), class = "FutureResult")
[13:33:42.018]     }, finally = {
[13:33:42.018]         if (!identical(...future.workdir, getwd())) 
[13:33:42.018]             setwd(...future.workdir)
[13:33:42.018]         {
[13:33:42.018]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:42.018]                 ...future.oldOptions$nwarnings <- NULL
[13:33:42.018]             }
[13:33:42.018]             base::options(...future.oldOptions)
[13:33:42.018]             if (.Platform$OS.type == "windows") {
[13:33:42.018]                 old_names <- names(...future.oldEnvVars)
[13:33:42.018]                 envs <- base::Sys.getenv()
[13:33:42.018]                 names <- names(envs)
[13:33:42.018]                 common <- intersect(names, old_names)
[13:33:42.018]                 added <- setdiff(names, old_names)
[13:33:42.018]                 removed <- setdiff(old_names, names)
[13:33:42.018]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:42.018]                   envs[common]]
[13:33:42.018]                 NAMES <- toupper(changed)
[13:33:42.018]                 args <- list()
[13:33:42.018]                 for (kk in seq_along(NAMES)) {
[13:33:42.018]                   name <- changed[[kk]]
[13:33:42.018]                   NAME <- NAMES[[kk]]
[13:33:42.018]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:42.018]                     next
[13:33:42.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:42.018]                 }
[13:33:42.018]                 NAMES <- toupper(added)
[13:33:42.018]                 for (kk in seq_along(NAMES)) {
[13:33:42.018]                   name <- added[[kk]]
[13:33:42.018]                   NAME <- NAMES[[kk]]
[13:33:42.018]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:42.018]                     next
[13:33:42.018]                   args[[name]] <- ""
[13:33:42.018]                 }
[13:33:42.018]                 NAMES <- toupper(removed)
[13:33:42.018]                 for (kk in seq_along(NAMES)) {
[13:33:42.018]                   name <- removed[[kk]]
[13:33:42.018]                   NAME <- NAMES[[kk]]
[13:33:42.018]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:42.018]                     next
[13:33:42.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:42.018]                 }
[13:33:42.018]                 if (length(args) > 0) 
[13:33:42.018]                   base::do.call(base::Sys.setenv, args = args)
[13:33:42.018]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:42.018]             }
[13:33:42.018]             else {
[13:33:42.018]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:42.018]             }
[13:33:42.018]             {
[13:33:42.018]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:42.018]                   0L) {
[13:33:42.018]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:42.018]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:42.018]                   base::options(opts)
[13:33:42.018]                 }
[13:33:42.018]                 {
[13:33:42.018]                   {
[13:33:42.018]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:42.018]                     NULL
[13:33:42.018]                   }
[13:33:42.018]                   options(future.plan = NULL)
[13:33:42.018]                   if (is.na(NA_character_)) 
[13:33:42.018]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:42.018]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:42.018]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:42.018]                     .init = FALSE)
[13:33:42.018]                 }
[13:33:42.018]             }
[13:33:42.018]         }
[13:33:42.018]     })
[13:33:42.018]     if (TRUE) {
[13:33:42.018]         base::sink(type = "output", split = FALSE)
[13:33:42.018]         if (TRUE) {
[13:33:42.018]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:42.018]         }
[13:33:42.018]         else {
[13:33:42.018]             ...future.result["stdout"] <- base::list(NULL)
[13:33:42.018]         }
[13:33:42.018]         base::close(...future.stdout)
[13:33:42.018]         ...future.stdout <- NULL
[13:33:42.018]     }
[13:33:42.018]     ...future.result$conditions <- ...future.conditions
[13:33:42.018]     ...future.result$finished <- base::Sys.time()
[13:33:42.018]     ...future.result
[13:33:42.018] }
[13:33:42.020] assign_globals() ...
[13:33:42.021] List of 5
[13:33:42.021]  $ ...future.FUN            :function (x, ...)  
[13:33:42.021]  $ future.call.arguments    :List of 1
[13:33:42.021]   ..$ singular.ok: logi FALSE
[13:33:42.021]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:42.021]  $ ...future.elements_ii    :List of 1
[13:33:42.021]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:42.021]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:33:42.021]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:42.021]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:42.021]  $ ...future.seeds_ii       : NULL
[13:33:42.021]  $ ...future.globals.maxSize: NULL
[13:33:42.021]  - attr(*, "where")=List of 5
[13:33:42.021]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:42.021]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:42.021]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:42.021]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:42.021]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:42.021]  - attr(*, "resolved")= logi FALSE
[13:33:42.021]  - attr(*, "total_size")= num 5384
[13:33:42.021]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:42.021]  - attr(*, "already-done")= logi TRUE
[13:33:42.029] - reassign environment for ‘...future.FUN’
[13:33:42.029] - copied ‘...future.FUN’ to environment
[13:33:42.029] - copied ‘future.call.arguments’ to environment
[13:33:42.029] - copied ‘...future.elements_ii’ to environment
[13:33:42.029] - copied ‘...future.seeds_ii’ to environment
[13:33:42.029] - copied ‘...future.globals.maxSize’ to environment
[13:33:42.029] assign_globals() ... done
[13:33:42.030] requestCore(): workers = 2
[13:33:42.032] MulticoreFuture started
[13:33:42.032] - Launch lazy future ... done
[13:33:42.033] run() for ‘MulticoreFuture’ ... done
[13:33:42.033] Created future:
[13:33:42.034] plan(): Setting new future strategy stack:
[13:33:42.034] List of future strategies:
[13:33:42.034] 1. sequential:
[13:33:42.034]    - args: function (..., envir = parent.frame())
[13:33:42.034]    - tweaked: FALSE
[13:33:42.034]    - call: NULL
[13:33:42.035] plan(): nbrOfWorkers() = 1
[13:33:42.039] plan(): Setting new future strategy stack:
[13:33:42.040] List of future strategies:
[13:33:42.040] 1. multicore:
[13:33:42.040]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:42.040]    - tweaked: FALSE
[13:33:42.040]    - call: plan(strategy)
[13:33:42.045] plan(): nbrOfWorkers() = 2
[13:33:42.034] MulticoreFuture:
[13:33:42.034] Label: ‘future_by-1’
[13:33:42.034] Expression:
[13:33:42.034] {
[13:33:42.034]     do.call(function(...) {
[13:33:42.034]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:42.034]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:42.034]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:42.034]             on.exit(options(oopts), add = TRUE)
[13:33:42.034]         }
[13:33:42.034]         {
[13:33:42.034]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:42.034]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:42.034]                 ...future.FUN(...future.X_jj, ...)
[13:33:42.034]             })
[13:33:42.034]         }
[13:33:42.034]     }, args = future.call.arguments)
[13:33:42.034] }
[13:33:42.034] Lazy evaluation: FALSE
[13:33:42.034] Asynchronous evaluation: TRUE
[13:33:42.034] Local evaluation: TRUE
[13:33:42.034] Environment: R_GlobalEnv
[13:33:42.034] Capture standard output: TRUE
[13:33:42.034] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:42.034] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:42.034] Packages: 1 packages (‘stats’)
[13:33:42.034] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:42.034] Resolved: TRUE
[13:33:42.034] Value: <not collected>
[13:33:42.034] Conditions captured: <none>
[13:33:42.034] Early signaling: FALSE
[13:33:42.034] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:42.034] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:42.047] Chunk #1 of 2 ... DONE
[13:33:42.047] Chunk #2 of 2 ...
[13:33:42.047]  - Finding globals in 'X' for chunk #2 ...
[13:33:42.047] getGlobalsAndPackages() ...
[13:33:42.047] Searching for globals...
[13:33:42.048] 
[13:33:42.049] Searching for globals ... DONE
[13:33:42.049] - globals: [0] <none>
[13:33:42.049] getGlobalsAndPackages() ... DONE
[13:33:42.049]    + additional globals found: [n=0] 
[13:33:42.049]    + additional namespaces needed: [n=0] 
[13:33:42.049]  - Finding globals in 'X' for chunk #2 ... DONE
[13:33:42.049]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:42.050]  - seeds: <none>
[13:33:42.050]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:42.050] getGlobalsAndPackages() ...
[13:33:42.050] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:42.050] Resolving globals: FALSE
[13:33:42.050] Tweak future expression to call with '...' arguments ...
[13:33:42.051] {
[13:33:42.051]     do.call(function(...) {
[13:33:42.051]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:42.051]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:42.051]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:42.051]             on.exit(options(oopts), add = TRUE)
[13:33:42.051]         }
[13:33:42.051]         {
[13:33:42.051]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:42.051]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:42.051]                 ...future.FUN(...future.X_jj, ...)
[13:33:42.051]             })
[13:33:42.051]         }
[13:33:42.051]     }, args = future.call.arguments)
[13:33:42.051] }
[13:33:42.051] Tweak future expression to call with '...' arguments ... DONE
[13:33:42.052] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:42.052] 
[13:33:42.052] getGlobalsAndPackages() ... DONE
[13:33:42.052] run() for ‘Future’ ...
[13:33:42.053] - state: ‘created’
[13:33:42.053] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:42.058] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:42.058] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:42.058]   - Field: ‘label’
[13:33:42.059]   - Field: ‘local’
[13:33:42.059]   - Field: ‘owner’
[13:33:42.059]   - Field: ‘envir’
[13:33:42.059]   - Field: ‘workers’
[13:33:42.059]   - Field: ‘packages’
[13:33:42.059]   - Field: ‘gc’
[13:33:42.059]   - Field: ‘job’
[13:33:42.060]   - Field: ‘conditions’
[13:33:42.060]   - Field: ‘expr’
[13:33:42.060]   - Field: ‘uuid’
[13:33:42.060]   - Field: ‘seed’
[13:33:42.060]   - Field: ‘version’
[13:33:42.060]   - Field: ‘result’
[13:33:42.060]   - Field: ‘asynchronous’
[13:33:42.061]   - Field: ‘calls’
[13:33:42.061]   - Field: ‘globals’
[13:33:42.061]   - Field: ‘stdout’
[13:33:42.061]   - Field: ‘earlySignal’
[13:33:42.061]   - Field: ‘lazy’
[13:33:42.061]   - Field: ‘state’
[13:33:42.061] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:42.062] - Launch lazy future ...
[13:33:42.062] Packages needed by the future expression (n = 1): ‘stats’
[13:33:42.062] Packages needed by future strategies (n = 0): <none>
[13:33:42.063] {
[13:33:42.063]     {
[13:33:42.063]         {
[13:33:42.063]             ...future.startTime <- base::Sys.time()
[13:33:42.063]             {
[13:33:42.063]                 {
[13:33:42.063]                   {
[13:33:42.063]                     {
[13:33:42.063]                       {
[13:33:42.063]                         base::local({
[13:33:42.063]                           has_future <- base::requireNamespace("future", 
[13:33:42.063]                             quietly = TRUE)
[13:33:42.063]                           if (has_future) {
[13:33:42.063]                             ns <- base::getNamespace("future")
[13:33:42.063]                             version <- ns[[".package"]][["version"]]
[13:33:42.063]                             if (is.null(version)) 
[13:33:42.063]                               version <- utils::packageVersion("future")
[13:33:42.063]                           }
[13:33:42.063]                           else {
[13:33:42.063]                             version <- NULL
[13:33:42.063]                           }
[13:33:42.063]                           if (!has_future || version < "1.8.0") {
[13:33:42.063]                             info <- base::c(r_version = base::gsub("R version ", 
[13:33:42.063]                               "", base::R.version$version.string), 
[13:33:42.063]                               platform = base::sprintf("%s (%s-bit)", 
[13:33:42.063]                                 base::R.version$platform, 8 * 
[13:33:42.063]                                   base::.Machine$sizeof.pointer), 
[13:33:42.063]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:42.063]                                 "release", "version")], collapse = " "), 
[13:33:42.063]                               hostname = base::Sys.info()[["nodename"]])
[13:33:42.063]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:33:42.063]                               info)
[13:33:42.063]                             info <- base::paste(info, collapse = "; ")
[13:33:42.063]                             if (!has_future) {
[13:33:42.063]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:42.063]                                 info)
[13:33:42.063]                             }
[13:33:42.063]                             else {
[13:33:42.063]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:42.063]                                 info, version)
[13:33:42.063]                             }
[13:33:42.063]                             base::stop(msg)
[13:33:42.063]                           }
[13:33:42.063]                         })
[13:33:42.063]                       }
[13:33:42.063]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:42.063]                       base::options(mc.cores = 1L)
[13:33:42.063]                     }
[13:33:42.063]                     base::local({
[13:33:42.063]                       for (pkg in "stats") {
[13:33:42.063]                         base::loadNamespace(pkg)
[13:33:42.063]                         base::library(pkg, character.only = TRUE)
[13:33:42.063]                       }
[13:33:42.063]                     })
[13:33:42.063]                   }
[13:33:42.063]                   ...future.strategy.old <- future::plan("list")
[13:33:42.063]                   options(future.plan = NULL)
[13:33:42.063]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:42.063]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:42.063]                 }
[13:33:42.063]                 ...future.workdir <- getwd()
[13:33:42.063]             }
[13:33:42.063]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:42.063]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:42.063]         }
[13:33:42.063]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:42.063]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:42.063]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:42.063]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:42.063]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:42.063]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:42.063]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:42.063]             base::names(...future.oldOptions))
[13:33:42.063]     }
[13:33:42.063]     if (FALSE) {
[13:33:42.063]     }
[13:33:42.063]     else {
[13:33:42.063]         if (TRUE) {
[13:33:42.063]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:42.063]                 open = "w")
[13:33:42.063]         }
[13:33:42.063]         else {
[13:33:42.063]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:42.063]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:42.063]         }
[13:33:42.063]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:42.063]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:42.063]             base::sink(type = "output", split = FALSE)
[13:33:42.063]             base::close(...future.stdout)
[13:33:42.063]         }, add = TRUE)
[13:33:42.063]     }
[13:33:42.063]     ...future.frame <- base::sys.nframe()
[13:33:42.063]     ...future.conditions <- base::list()
[13:33:42.063]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:42.063]     if (FALSE) {
[13:33:42.063]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:42.063]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:42.063]     }
[13:33:42.063]     ...future.result <- base::tryCatch({
[13:33:42.063]         base::withCallingHandlers({
[13:33:42.063]             ...future.value <- base::withVisible(base::local({
[13:33:42.063]                 withCallingHandlers({
[13:33:42.063]                   {
[13:33:42.063]                     do.call(function(...) {
[13:33:42.063]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:42.063]                       if (!identical(...future.globals.maxSize.org, 
[13:33:42.063]                         ...future.globals.maxSize)) {
[13:33:42.063]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:42.063]                         on.exit(options(oopts), add = TRUE)
[13:33:42.063]                       }
[13:33:42.063]                       {
[13:33:42.063]                         lapply(seq_along(...future.elements_ii), 
[13:33:42.063]                           FUN = function(jj) {
[13:33:42.063]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:42.063]                             ...future.FUN(...future.X_jj, ...)
[13:33:42.063]                           })
[13:33:42.063]                       }
[13:33:42.063]                     }, args = future.call.arguments)
[13:33:42.063]                   }
[13:33:42.063]                 }, immediateCondition = function(cond) {
[13:33:42.063]                   save_rds <- function (object, pathname, ...) 
[13:33:42.063]                   {
[13:33:42.063]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:42.063]                     if (file_test("-f", pathname_tmp)) {
[13:33:42.063]                       fi_tmp <- file.info(pathname_tmp)
[13:33:42.063]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:42.063]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:42.063]                         fi_tmp[["mtime"]])
[13:33:42.063]                     }
[13:33:42.063]                     tryCatch({
[13:33:42.063]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:42.063]                     }, error = function(ex) {
[13:33:42.063]                       msg <- conditionMessage(ex)
[13:33:42.063]                       fi_tmp <- file.info(pathname_tmp)
[13:33:42.063]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:42.063]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:42.063]                         fi_tmp[["mtime"]], msg)
[13:33:42.063]                       ex$message <- msg
[13:33:42.063]                       stop(ex)
[13:33:42.063]                     })
[13:33:42.063]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:42.063]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:42.063]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:42.063]                       fi_tmp <- file.info(pathname_tmp)
[13:33:42.063]                       fi <- file.info(pathname)
[13:33:42.063]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:42.063]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:42.063]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:42.063]                         fi[["size"]], fi[["mtime"]])
[13:33:42.063]                       stop(msg)
[13:33:42.063]                     }
[13:33:42.063]                     invisible(pathname)
[13:33:42.063]                   }
[13:33:42.063]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:42.063]                     rootPath = tempdir()) 
[13:33:42.063]                   {
[13:33:42.063]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:42.063]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:42.063]                       tmpdir = path, fileext = ".rds")
[13:33:42.063]                     save_rds(obj, file)
[13:33:42.063]                   }
[13:33:42.063]                   saveImmediateCondition(cond, path = "/tmp/RtmpMLLN1L/.future/immediateConditions")
[13:33:42.063]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:42.063]                   {
[13:33:42.063]                     inherits <- base::inherits
[13:33:42.063]                     invokeRestart <- base::invokeRestart
[13:33:42.063]                     is.null <- base::is.null
[13:33:42.063]                     muffled <- FALSE
[13:33:42.063]                     if (inherits(cond, "message")) {
[13:33:42.063]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:42.063]                       if (muffled) 
[13:33:42.063]                         invokeRestart("muffleMessage")
[13:33:42.063]                     }
[13:33:42.063]                     else if (inherits(cond, "warning")) {
[13:33:42.063]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:42.063]                       if (muffled) 
[13:33:42.063]                         invokeRestart("muffleWarning")
[13:33:42.063]                     }
[13:33:42.063]                     else if (inherits(cond, "condition")) {
[13:33:42.063]                       if (!is.null(pattern)) {
[13:33:42.063]                         computeRestarts <- base::computeRestarts
[13:33:42.063]                         grepl <- base::grepl
[13:33:42.063]                         restarts <- computeRestarts(cond)
[13:33:42.063]                         for (restart in restarts) {
[13:33:42.063]                           name <- restart$name
[13:33:42.063]                           if (is.null(name)) 
[13:33:42.063]                             next
[13:33:42.063]                           if (!grepl(pattern, name)) 
[13:33:42.063]                             next
[13:33:42.063]                           invokeRestart(restart)
[13:33:42.063]                           muffled <- TRUE
[13:33:42.063]                           break
[13:33:42.063]                         }
[13:33:42.063]                       }
[13:33:42.063]                     }
[13:33:42.063]                     invisible(muffled)
[13:33:42.063]                   }
[13:33:42.063]                   muffleCondition(cond)
[13:33:42.063]                 })
[13:33:42.063]             }))
[13:33:42.063]             future::FutureResult(value = ...future.value$value, 
[13:33:42.063]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:42.063]                   ...future.rng), globalenv = if (FALSE) 
[13:33:42.063]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:42.063]                     ...future.globalenv.names))
[13:33:42.063]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:42.063]         }, condition = base::local({
[13:33:42.063]             c <- base::c
[13:33:42.063]             inherits <- base::inherits
[13:33:42.063]             invokeRestart <- base::invokeRestart
[13:33:42.063]             length <- base::length
[13:33:42.063]             list <- base::list
[13:33:42.063]             seq.int <- base::seq.int
[13:33:42.063]             signalCondition <- base::signalCondition
[13:33:42.063]             sys.calls <- base::sys.calls
[13:33:42.063]             `[[` <- base::`[[`
[13:33:42.063]             `+` <- base::`+`
[13:33:42.063]             `<<-` <- base::`<<-`
[13:33:42.063]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:42.063]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:42.063]                   3L)]
[13:33:42.063]             }
[13:33:42.063]             function(cond) {
[13:33:42.063]                 is_error <- inherits(cond, "error")
[13:33:42.063]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:42.063]                   NULL)
[13:33:42.063]                 if (is_error) {
[13:33:42.063]                   sessionInformation <- function() {
[13:33:42.063]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:42.063]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:42.063]                       search = base::search(), system = base::Sys.info())
[13:33:42.063]                   }
[13:33:42.063]                   ...future.conditions[[length(...future.conditions) + 
[13:33:42.063]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:42.063]                     cond$call), session = sessionInformation(), 
[13:33:42.063]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:42.063]                   signalCondition(cond)
[13:33:42.063]                 }
[13:33:42.063]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:42.063]                 "immediateCondition"))) {
[13:33:42.063]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:42.063]                   ...future.conditions[[length(...future.conditions) + 
[13:33:42.063]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:42.063]                   if (TRUE && !signal) {
[13:33:42.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:42.063]                     {
[13:33:42.063]                       inherits <- base::inherits
[13:33:42.063]                       invokeRestart <- base::invokeRestart
[13:33:42.063]                       is.null <- base::is.null
[13:33:42.063]                       muffled <- FALSE
[13:33:42.063]                       if (inherits(cond, "message")) {
[13:33:42.063]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:42.063]                         if (muffled) 
[13:33:42.063]                           invokeRestart("muffleMessage")
[13:33:42.063]                       }
[13:33:42.063]                       else if (inherits(cond, "warning")) {
[13:33:42.063]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:42.063]                         if (muffled) 
[13:33:42.063]                           invokeRestart("muffleWarning")
[13:33:42.063]                       }
[13:33:42.063]                       else if (inherits(cond, "condition")) {
[13:33:42.063]                         if (!is.null(pattern)) {
[13:33:42.063]                           computeRestarts <- base::computeRestarts
[13:33:42.063]                           grepl <- base::grepl
[13:33:42.063]                           restarts <- computeRestarts(cond)
[13:33:42.063]                           for (restart in restarts) {
[13:33:42.063]                             name <- restart$name
[13:33:42.063]                             if (is.null(name)) 
[13:33:42.063]                               next
[13:33:42.063]                             if (!grepl(pattern, name)) 
[13:33:42.063]                               next
[13:33:42.063]                             invokeRestart(restart)
[13:33:42.063]                             muffled <- TRUE
[13:33:42.063]                             break
[13:33:42.063]                           }
[13:33:42.063]                         }
[13:33:42.063]                       }
[13:33:42.063]                       invisible(muffled)
[13:33:42.063]                     }
[13:33:42.063]                     muffleCondition(cond, pattern = "^muffle")
[13:33:42.063]                   }
[13:33:42.063]                 }
[13:33:42.063]                 else {
[13:33:42.063]                   if (TRUE) {
[13:33:42.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:42.063]                     {
[13:33:42.063]                       inherits <- base::inherits
[13:33:42.063]                       invokeRestart <- base::invokeRestart
[13:33:42.063]                       is.null <- base::is.null
[13:33:42.063]                       muffled <- FALSE
[13:33:42.063]                       if (inherits(cond, "message")) {
[13:33:42.063]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:42.063]                         if (muffled) 
[13:33:42.063]                           invokeRestart("muffleMessage")
[13:33:42.063]                       }
[13:33:42.063]                       else if (inherits(cond, "warning")) {
[13:33:42.063]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:42.063]                         if (muffled) 
[13:33:42.063]                           invokeRestart("muffleWarning")
[13:33:42.063]                       }
[13:33:42.063]                       else if (inherits(cond, "condition")) {
[13:33:42.063]                         if (!is.null(pattern)) {
[13:33:42.063]                           computeRestarts <- base::computeRestarts
[13:33:42.063]                           grepl <- base::grepl
[13:33:42.063]                           restarts <- computeRestarts(cond)
[13:33:42.063]                           for (restart in restarts) {
[13:33:42.063]                             name <- restart$name
[13:33:42.063]                             if (is.null(name)) 
[13:33:42.063]                               next
[13:33:42.063]                             if (!grepl(pattern, name)) 
[13:33:42.063]                               next
[13:33:42.063]                             invokeRestart(restart)
[13:33:42.063]                             muffled <- TRUE
[13:33:42.063]                             break
[13:33:42.063]                           }
[13:33:42.063]                         }
[13:33:42.063]                       }
[13:33:42.063]                       invisible(muffled)
[13:33:42.063]                     }
[13:33:42.063]                     muffleCondition(cond, pattern = "^muffle")
[13:33:42.063]                   }
[13:33:42.063]                 }
[13:33:42.063]             }
[13:33:42.063]         }))
[13:33:42.063]     }, error = function(ex) {
[13:33:42.063]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:42.063]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:42.063]                 ...future.rng), started = ...future.startTime, 
[13:33:42.063]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:42.063]             version = "1.8"), class = "FutureResult")
[13:33:42.063]     }, finally = {
[13:33:42.063]         if (!identical(...future.workdir, getwd())) 
[13:33:42.063]             setwd(...future.workdir)
[13:33:42.063]         {
[13:33:42.063]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:42.063]                 ...future.oldOptions$nwarnings <- NULL
[13:33:42.063]             }
[13:33:42.063]             base::options(...future.oldOptions)
[13:33:42.063]             if (.Platform$OS.type == "windows") {
[13:33:42.063]                 old_names <- names(...future.oldEnvVars)
[13:33:42.063]                 envs <- base::Sys.getenv()
[13:33:42.063]                 names <- names(envs)
[13:33:42.063]                 common <- intersect(names, old_names)
[13:33:42.063]                 added <- setdiff(names, old_names)
[13:33:42.063]                 removed <- setdiff(old_names, names)
[13:33:42.063]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:42.063]                   envs[common]]
[13:33:42.063]                 NAMES <- toupper(changed)
[13:33:42.063]                 args <- list()
[13:33:42.063]                 for (kk in seq_along(NAMES)) {
[13:33:42.063]                   name <- changed[[kk]]
[13:33:42.063]                   NAME <- NAMES[[kk]]
[13:33:42.063]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:42.063]                     next
[13:33:42.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:42.063]                 }
[13:33:42.063]                 NAMES <- toupper(added)
[13:33:42.063]                 for (kk in seq_along(NAMES)) {
[13:33:42.063]                   name <- added[[kk]]
[13:33:42.063]                   NAME <- NAMES[[kk]]
[13:33:42.063]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:42.063]                     next
[13:33:42.063]                   args[[name]] <- ""
[13:33:42.063]                 }
[13:33:42.063]                 NAMES <- toupper(removed)
[13:33:42.063]                 for (kk in seq_along(NAMES)) {
[13:33:42.063]                   name <- removed[[kk]]
[13:33:42.063]                   NAME <- NAMES[[kk]]
[13:33:42.063]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:42.063]                     next
[13:33:42.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:42.063]                 }
[13:33:42.063]                 if (length(args) > 0) 
[13:33:42.063]                   base::do.call(base::Sys.setenv, args = args)
[13:33:42.063]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:42.063]             }
[13:33:42.063]             else {
[13:33:42.063]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:42.063]             }
[13:33:42.063]             {
[13:33:42.063]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:42.063]                   0L) {
[13:33:42.063]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:42.063]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:42.063]                   base::options(opts)
[13:33:42.063]                 }
[13:33:42.063]                 {
[13:33:42.063]                   {
[13:33:42.063]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:42.063]                     NULL
[13:33:42.063]                   }
[13:33:42.063]                   options(future.plan = NULL)
[13:33:42.063]                   if (is.na(NA_character_)) 
[13:33:42.063]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:42.063]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:42.063]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:42.063]                     .init = FALSE)
[13:33:42.063]                 }
[13:33:42.063]             }
[13:33:42.063]         }
[13:33:42.063]     })
[13:33:42.063]     if (TRUE) {
[13:33:42.063]         base::sink(type = "output", split = FALSE)
[13:33:42.063]         if (TRUE) {
[13:33:42.063]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:42.063]         }
[13:33:42.063]         else {
[13:33:42.063]             ...future.result["stdout"] <- base::list(NULL)
[13:33:42.063]         }
[13:33:42.063]         base::close(...future.stdout)
[13:33:42.063]         ...future.stdout <- NULL
[13:33:42.063]     }
[13:33:42.063]     ...future.result$conditions <- ...future.conditions
[13:33:42.063]     ...future.result$finished <- base::Sys.time()
[13:33:42.063]     ...future.result
[13:33:42.063] }
[13:33:42.066] assign_globals() ...
[13:33:42.066] List of 5
[13:33:42.066]  $ ...future.FUN            :function (x, ...)  
[13:33:42.066]  $ future.call.arguments    :List of 1
[13:33:42.066]   ..$ singular.ok: logi FALSE
[13:33:42.066]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:42.066]  $ ...future.elements_ii    :List of 2
[13:33:42.066]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:42.066]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:33:42.066]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:42.066]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:33:42.066]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:42.066]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:33:42.066]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:42.066]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:33:42.066]  $ ...future.seeds_ii       : NULL
[13:33:42.066]  $ ...future.globals.maxSize: NULL
[13:33:42.066]  - attr(*, "where")=List of 5
[13:33:42.066]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:42.066]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:42.066]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:42.066]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:42.066]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:42.066]  - attr(*, "resolved")= logi FALSE
[13:33:42.066]  - attr(*, "total_size")= num 5384
[13:33:42.066]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:42.066]  - attr(*, "already-done")= logi TRUE
[13:33:42.082] - reassign environment for ‘...future.FUN’
[13:33:42.082] - copied ‘...future.FUN’ to environment
[13:33:42.082] - copied ‘future.call.arguments’ to environment
[13:33:42.082] - copied ‘...future.elements_ii’ to environment
[13:33:42.082] - copied ‘...future.seeds_ii’ to environment
[13:33:42.082] - copied ‘...future.globals.maxSize’ to environment
[13:33:42.082] assign_globals() ... done
[13:33:42.083] requestCore(): workers = 2
[13:33:42.085] MulticoreFuture started
[13:33:42.085] - Launch lazy future ... done
[13:33:42.085] run() for ‘MulticoreFuture’ ... done
[13:33:42.086] Created future:
[13:33:42.086] plan(): Setting new future strategy stack:
[13:33:42.087] List of future strategies:
[13:33:42.087] 1. sequential:
[13:33:42.087]    - args: function (..., envir = parent.frame())
[13:33:42.087]    - tweaked: FALSE
[13:33:42.087]    - call: NULL
[13:33:42.087] plan(): nbrOfWorkers() = 1
[13:33:42.093] plan(): Setting new future strategy stack:
[13:33:42.093] List of future strategies:
[13:33:42.093] 1. multicore:
[13:33:42.093]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:42.093]    - tweaked: FALSE
[13:33:42.093]    - call: plan(strategy)
[13:33:42.098] plan(): nbrOfWorkers() = 2
[13:33:42.086] MulticoreFuture:
[13:33:42.086] Label: ‘future_by-2’
[13:33:42.086] Expression:
[13:33:42.086] {
[13:33:42.086]     do.call(function(...) {
[13:33:42.086]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:42.086]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:42.086]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:42.086]             on.exit(options(oopts), add = TRUE)
[13:33:42.086]         }
[13:33:42.086]         {
[13:33:42.086]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:42.086]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:42.086]                 ...future.FUN(...future.X_jj, ...)
[13:33:42.086]             })
[13:33:42.086]         }
[13:33:42.086]     }, args = future.call.arguments)
[13:33:42.086] }
[13:33:42.086] Lazy evaluation: FALSE
[13:33:42.086] Asynchronous evaluation: TRUE
[13:33:42.086] Local evaluation: TRUE
[13:33:42.086] Environment: R_GlobalEnv
[13:33:42.086] Capture standard output: TRUE
[13:33:42.086] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:42.086] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:42.086] Packages: 1 packages (‘stats’)
[13:33:42.086] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:42.086] Resolved: FALSE
[13:33:42.086] Value: <not collected>
[13:33:42.086] Conditions captured: <none>
[13:33:42.086] Early signaling: FALSE
[13:33:42.086] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:42.086] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:42.100] Chunk #2 of 2 ... DONE
[13:33:42.100] Launching 2 futures (chunks) ... DONE
[13:33:42.100] Resolving 2 futures (chunks) ...
[13:33:42.100] resolve() on list ...
[13:33:42.101]  recursive: 0
[13:33:42.101]  length: 2
[13:33:42.101] 
[13:33:42.101] Future #1
[13:33:42.101] result() for MulticoreFuture ...
[13:33:42.103] result() for MulticoreFuture ...
[13:33:42.103] result() for MulticoreFuture ... done
[13:33:42.103] result() for MulticoreFuture ... done
[13:33:42.103] result() for MulticoreFuture ...
[13:33:42.103] result() for MulticoreFuture ... done
[13:33:42.104] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:33:42.104] - nx: 2
[13:33:42.104] - relay: TRUE
[13:33:42.104] - stdout: TRUE
[13:33:42.104] - signal: TRUE
[13:33:42.104] - resignal: FALSE
[13:33:42.104] - force: TRUE
[13:33:42.105] - relayed: [n=2] FALSE, FALSE
[13:33:42.105] - queued futures: [n=2] FALSE, FALSE
[13:33:42.105]  - until=1
[13:33:42.105]  - relaying element #1
[13:33:42.105] result() for MulticoreFuture ...
[13:33:42.105] result() for MulticoreFuture ... done
[13:33:42.105] result() for MulticoreFuture ...
[13:33:42.106] result() for MulticoreFuture ... done
[13:33:42.106] result() for MulticoreFuture ...
[13:33:42.106] result() for MulticoreFuture ... done
[13:33:42.106] result() for MulticoreFuture ...
[13:33:42.106] result() for MulticoreFuture ... done
[13:33:42.106] - relayed: [n=2] TRUE, FALSE
[13:33:42.107] - queued futures: [n=2] TRUE, FALSE
[13:33:42.107] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:33:42.107]  length: 1 (resolved future 1)
[13:33:42.107] Future #2
[13:33:42.107] result() for MulticoreFuture ...
[13:33:42.109] result() for MulticoreFuture ...
[13:33:42.109] result() for MulticoreFuture ... done
[13:33:42.109] result() for MulticoreFuture ... done
[13:33:42.110] result() for MulticoreFuture ...
[13:33:42.110] result() for MulticoreFuture ... done
[13:33:42.110] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:33:42.110] - nx: 2
[13:33:42.110] - relay: TRUE
[13:33:42.110] - stdout: TRUE
[13:33:42.111] - signal: TRUE
[13:33:42.111] - resignal: FALSE
[13:33:42.111] - force: TRUE
[13:33:42.111] - relayed: [n=2] TRUE, FALSE
[13:33:42.111] - queued futures: [n=2] TRUE, FALSE
[13:33:42.111]  - until=2
[13:33:42.112]  - relaying element #2
[13:33:42.112] result() for MulticoreFuture ...
[13:33:42.112] result() for MulticoreFuture ... done
[13:33:42.112] result() for MulticoreFuture ...
[13:33:42.112] result() for MulticoreFuture ... done
[13:33:42.112] result() for MulticoreFuture ...
[13:33:42.112] result() for MulticoreFuture ... done
[13:33:42.113] result() for MulticoreFuture ...
[13:33:42.113] result() for MulticoreFuture ... done
[13:33:42.113] - relayed: [n=2] TRUE, TRUE
[13:33:42.113] - queued futures: [n=2] TRUE, TRUE
[13:33:42.113] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:33:42.113]  length: 0 (resolved future 2)
[13:33:42.113] Relaying remaining futures
[13:33:42.113] signalConditionsASAP(NULL, pos=0) ...
[13:33:42.113] - nx: 2
[13:33:42.114] - relay: TRUE
[13:33:42.114] - stdout: TRUE
[13:33:42.114] - signal: TRUE
[13:33:42.114] - resignal: FALSE
[13:33:42.114] - force: TRUE
[13:33:42.114] - relayed: [n=2] TRUE, TRUE
[13:33:42.114] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:42.115] - relayed: [n=2] TRUE, TRUE
[13:33:42.118] - queued futures: [n=2] TRUE, TRUE
[13:33:42.118] signalConditionsASAP(NULL, pos=0) ... done
[13:33:42.118] resolve() on list ... DONE
[13:33:42.118] result() for MulticoreFuture ...
[13:33:42.119] result() for MulticoreFuture ... done
[13:33:42.119] result() for MulticoreFuture ...
[13:33:42.119] result() for MulticoreFuture ... done
[13:33:42.119] result() for MulticoreFuture ...
[13:33:42.119] result() for MulticoreFuture ... done
[13:33:42.119] result() for MulticoreFuture ...
[13:33:42.120] result() for MulticoreFuture ... done
[13:33:42.120]  - Number of value chunks collected: 2
[13:33:42.120] Resolving 2 futures (chunks) ... DONE
[13:33:42.120] Reducing values from 2 chunks ...
[13:33:42.120]  - Number of values collected after concatenation: 3
[13:33:42.120]  - Number of values expected: 3
[13:33:42.120] Reducing values from 2 chunks ... DONE
[13:33:42.121] future_lapply() ... DONE
[13:33:42.121] future_by_internal() ... DONE
[13:33:42.127] future_by_internal() ...
[13:33:42.127] future_lapply() ...
[13:33:42.132] Number of chunks: 2
[13:33:42.132] getGlobalsAndPackagesXApply() ...
[13:33:42.132]  - future.globals: TRUE
[13:33:42.132] getGlobalsAndPackages() ...
[13:33:42.132] Searching for globals...
[13:33:42.134] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:33:42.134] Searching for globals ... DONE
[13:33:42.134] Resolving globals: FALSE
[13:33:42.135] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[13:33:42.135] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[13:33:42.135] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[13:33:42.135] - packages: [1] ‘stats’
[13:33:42.135] getGlobalsAndPackages() ... DONE
[13:33:42.135]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[13:33:42.136]  - needed namespaces: [n=1] ‘stats’
[13:33:42.136] Finding globals ... DONE
[13:33:42.136]  - use_args: TRUE
[13:33:42.136]  - Getting '...' globals ...
[13:33:42.136] resolve() on list ...
[13:33:42.136]  recursive: 0
[13:33:42.136]  length: 1
[13:33:42.136]  elements: ‘...’
[13:33:42.137]  length: 0 (resolved future 1)
[13:33:42.137] resolve() on list ... DONE
[13:33:42.137]    - '...' content: [n=0] 
[13:33:42.137] List of 1
[13:33:42.137]  $ ...: list()
[13:33:42.137]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:42.137]  - attr(*, "where")=List of 1
[13:33:42.137]   ..$ ...:<environment: 0x55cb80bf6858> 
[13:33:42.137]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:42.137]  - attr(*, "resolved")= logi TRUE
[13:33:42.137]  - attr(*, "total_size")= num NA
[13:33:42.142]  - Getting '...' globals ... DONE
[13:33:42.142] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[13:33:42.143] List of 4
[13:33:42.143]  $ ...future.FUN:function (x)  
[13:33:42.143]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:33:42.143]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:42.143]  $ ...          : list()
[13:33:42.143]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:42.143]  - attr(*, "where")=List of 4
[13:33:42.143]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:42.143]   ..$ breaks       :<environment: R_EmptyEnv> 
[13:33:42.143]   ..$ wool         :<environment: R_EmptyEnv> 
[13:33:42.143]   ..$ ...          :<environment: 0x55cb80bf6858> 
[13:33:42.143]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:42.143]  - attr(*, "resolved")= logi FALSE
[13:33:42.143]  - attr(*, "total_size")= num 2320
[13:33:42.147] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:42.147] getGlobalsAndPackagesXApply() ... DONE
[13:33:42.147] Number of futures (= number of chunks): 2
[13:33:42.147] Launching 2 futures (chunks) ...
[13:33:42.147] Chunk #1 of 2 ...
[13:33:42.148]  - Finding globals in 'X' for chunk #1 ...
[13:33:42.148] getGlobalsAndPackages() ...
[13:33:42.148] Searching for globals...
[13:33:42.148] 
[13:33:42.148] Searching for globals ... DONE
[13:33:42.148] - globals: [0] <none>
[13:33:42.148] getGlobalsAndPackages() ... DONE
[13:33:42.148]    + additional globals found: [n=0] 
[13:33:42.149]    + additional namespaces needed: [n=0] 
[13:33:42.149]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:42.149]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:42.149]  - seeds: <none>
[13:33:42.149]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:42.149] getGlobalsAndPackages() ...
[13:33:42.149] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:42.149] Resolving globals: FALSE
[13:33:42.149] Tweak future expression to call with '...' arguments ...
[13:33:42.150] {
[13:33:42.150]     do.call(function(...) {
[13:33:42.150]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:42.150]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:42.150]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:42.150]             on.exit(options(oopts), add = TRUE)
[13:33:42.150]         }
[13:33:42.150]         {
[13:33:42.150]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:42.150]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:42.150]                 ...future.FUN(...future.X_jj, ...)
[13:33:42.150]             })
[13:33:42.150]         }
[13:33:42.150]     }, args = future.call.arguments)
[13:33:42.150] }
[13:33:42.150] Tweak future expression to call with '...' arguments ... DONE
[13:33:42.150] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:42.150] 
[13:33:42.150] getGlobalsAndPackages() ... DONE
[13:33:42.151] run() for ‘Future’ ...
[13:33:42.151] - state: ‘created’
[13:33:42.151] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:42.154] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:42.155] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:42.155]   - Field: ‘label’
[13:33:42.155]   - Field: ‘local’
[13:33:42.155]   - Field: ‘owner’
[13:33:42.155]   - Field: ‘envir’
[13:33:42.155]   - Field: ‘workers’
[13:33:42.155]   - Field: ‘packages’
[13:33:42.155]   - Field: ‘gc’
[13:33:42.155]   - Field: ‘job’
[13:33:42.155]   - Field: ‘conditions’
[13:33:42.156]   - Field: ‘expr’
[13:33:42.156]   - Field: ‘uuid’
[13:33:42.156]   - Field: ‘seed’
[13:33:42.156]   - Field: ‘version’
[13:33:42.156]   - Field: ‘result’
[13:33:42.156]   - Field: ‘asynchronous’
[13:33:42.156]   - Field: ‘calls’
[13:33:42.156]   - Field: ‘globals’
[13:33:42.156]   - Field: ‘stdout’
[13:33:42.156]   - Field: ‘earlySignal’
[13:33:42.156]   - Field: ‘lazy’
[13:33:42.157]   - Field: ‘state’
[13:33:42.157] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:42.157] - Launch lazy future ...
[13:33:42.157] Packages needed by the future expression (n = 1): ‘stats’
[13:33:42.157] Packages needed by future strategies (n = 0): <none>
[13:33:42.158] {
[13:33:42.158]     {
[13:33:42.158]         {
[13:33:42.158]             ...future.startTime <- base::Sys.time()
[13:33:42.158]             {
[13:33:42.158]                 {
[13:33:42.158]                   {
[13:33:42.158]                     {
[13:33:42.158]                       {
[13:33:42.158]                         base::local({
[13:33:42.158]                           has_future <- base::requireNamespace("future", 
[13:33:42.158]                             quietly = TRUE)
[13:33:42.158]                           if (has_future) {
[13:33:42.158]                             ns <- base::getNamespace("future")
[13:33:42.158]                             version <- ns[[".package"]][["version"]]
[13:33:42.158]                             if (is.null(version)) 
[13:33:42.158]                               version <- utils::packageVersion("future")
[13:33:42.158]                           }
[13:33:42.158]                           else {
[13:33:42.158]                             version <- NULL
[13:33:42.158]                           }
[13:33:42.158]                           if (!has_future || version < "1.8.0") {
[13:33:42.158]                             info <- base::c(r_version = base::gsub("R version ", 
[13:33:42.158]                               "", base::R.version$version.string), 
[13:33:42.158]                               platform = base::sprintf("%s (%s-bit)", 
[13:33:42.158]                                 base::R.version$platform, 8 * 
[13:33:42.158]                                   base::.Machine$sizeof.pointer), 
[13:33:42.158]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:42.158]                                 "release", "version")], collapse = " "), 
[13:33:42.158]                               hostname = base::Sys.info()[["nodename"]])
[13:33:42.158]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:33:42.158]                               info)
[13:33:42.158]                             info <- base::paste(info, collapse = "; ")
[13:33:42.158]                             if (!has_future) {
[13:33:42.158]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:42.158]                                 info)
[13:33:42.158]                             }
[13:33:42.158]                             else {
[13:33:42.158]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:42.158]                                 info, version)
[13:33:42.158]                             }
[13:33:42.158]                             base::stop(msg)
[13:33:42.158]                           }
[13:33:42.158]                         })
[13:33:42.158]                       }
[13:33:42.158]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:42.158]                       base::options(mc.cores = 1L)
[13:33:42.158]                     }
[13:33:42.158]                     base::local({
[13:33:42.158]                       for (pkg in "stats") {
[13:33:42.158]                         base::loadNamespace(pkg)
[13:33:42.158]                         base::library(pkg, character.only = TRUE)
[13:33:42.158]                       }
[13:33:42.158]                     })
[13:33:42.158]                   }
[13:33:42.158]                   ...future.strategy.old <- future::plan("list")
[13:33:42.158]                   options(future.plan = NULL)
[13:33:42.158]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:42.158]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:42.158]                 }
[13:33:42.158]                 ...future.workdir <- getwd()
[13:33:42.158]             }
[13:33:42.158]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:42.158]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:42.158]         }
[13:33:42.158]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:42.158]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:42.158]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:42.158]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:42.158]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:42.158]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:42.158]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:42.158]             base::names(...future.oldOptions))
[13:33:42.158]     }
[13:33:42.158]     if (FALSE) {
[13:33:42.158]     }
[13:33:42.158]     else {
[13:33:42.158]         if (TRUE) {
[13:33:42.158]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:42.158]                 open = "w")
[13:33:42.158]         }
[13:33:42.158]         else {
[13:33:42.158]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:42.158]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:42.158]         }
[13:33:42.158]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:42.158]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:42.158]             base::sink(type = "output", split = FALSE)
[13:33:42.158]             base::close(...future.stdout)
[13:33:42.158]         }, add = TRUE)
[13:33:42.158]     }
[13:33:42.158]     ...future.frame <- base::sys.nframe()
[13:33:42.158]     ...future.conditions <- base::list()
[13:33:42.158]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:42.158]     if (FALSE) {
[13:33:42.158]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:42.158]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:42.158]     }
[13:33:42.158]     ...future.result <- base::tryCatch({
[13:33:42.158]         base::withCallingHandlers({
[13:33:42.158]             ...future.value <- base::withVisible(base::local({
[13:33:42.158]                 withCallingHandlers({
[13:33:42.158]                   {
[13:33:42.158]                     do.call(function(...) {
[13:33:42.158]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:42.158]                       if (!identical(...future.globals.maxSize.org, 
[13:33:42.158]                         ...future.globals.maxSize)) {
[13:33:42.158]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:42.158]                         on.exit(options(oopts), add = TRUE)
[13:33:42.158]                       }
[13:33:42.158]                       {
[13:33:42.158]                         lapply(seq_along(...future.elements_ii), 
[13:33:42.158]                           FUN = function(jj) {
[13:33:42.158]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:42.158]                             ...future.FUN(...future.X_jj, ...)
[13:33:42.158]                           })
[13:33:42.158]                       }
[13:33:42.158]                     }, args = future.call.arguments)
[13:33:42.158]                   }
[13:33:42.158]                 }, immediateCondition = function(cond) {
[13:33:42.158]                   save_rds <- function (object, pathname, ...) 
[13:33:42.158]                   {
[13:33:42.158]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:42.158]                     if (file_test("-f", pathname_tmp)) {
[13:33:42.158]                       fi_tmp <- file.info(pathname_tmp)
[13:33:42.158]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:42.158]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:42.158]                         fi_tmp[["mtime"]])
[13:33:42.158]                     }
[13:33:42.158]                     tryCatch({
[13:33:42.158]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:42.158]                     }, error = function(ex) {
[13:33:42.158]                       msg <- conditionMessage(ex)
[13:33:42.158]                       fi_tmp <- file.info(pathname_tmp)
[13:33:42.158]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:42.158]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:42.158]                         fi_tmp[["mtime"]], msg)
[13:33:42.158]                       ex$message <- msg
[13:33:42.158]                       stop(ex)
[13:33:42.158]                     })
[13:33:42.158]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:42.158]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:42.158]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:42.158]                       fi_tmp <- file.info(pathname_tmp)
[13:33:42.158]                       fi <- file.info(pathname)
[13:33:42.158]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:42.158]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:42.158]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:42.158]                         fi[["size"]], fi[["mtime"]])
[13:33:42.158]                       stop(msg)
[13:33:42.158]                     }
[13:33:42.158]                     invisible(pathname)
[13:33:42.158]                   }
[13:33:42.158]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:42.158]                     rootPath = tempdir()) 
[13:33:42.158]                   {
[13:33:42.158]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:42.158]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:42.158]                       tmpdir = path, fileext = ".rds")
[13:33:42.158]                     save_rds(obj, file)
[13:33:42.158]                   }
[13:33:42.158]                   saveImmediateCondition(cond, path = "/tmp/RtmpMLLN1L/.future/immediateConditions")
[13:33:42.158]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:42.158]                   {
[13:33:42.158]                     inherits <- base::inherits
[13:33:42.158]                     invokeRestart <- base::invokeRestart
[13:33:42.158]                     is.null <- base::is.null
[13:33:42.158]                     muffled <- FALSE
[13:33:42.158]                     if (inherits(cond, "message")) {
[13:33:42.158]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:42.158]                       if (muffled) 
[13:33:42.158]                         invokeRestart("muffleMessage")
[13:33:42.158]                     }
[13:33:42.158]                     else if (inherits(cond, "warning")) {
[13:33:42.158]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:42.158]                       if (muffled) 
[13:33:42.158]                         invokeRestart("muffleWarning")
[13:33:42.158]                     }
[13:33:42.158]                     else if (inherits(cond, "condition")) {
[13:33:42.158]                       if (!is.null(pattern)) {
[13:33:42.158]                         computeRestarts <- base::computeRestarts
[13:33:42.158]                         grepl <- base::grepl
[13:33:42.158]                         restarts <- computeRestarts(cond)
[13:33:42.158]                         for (restart in restarts) {
[13:33:42.158]                           name <- restart$name
[13:33:42.158]                           if (is.null(name)) 
[13:33:42.158]                             next
[13:33:42.158]                           if (!grepl(pattern, name)) 
[13:33:42.158]                             next
[13:33:42.158]                           invokeRestart(restart)
[13:33:42.158]                           muffled <- TRUE
[13:33:42.158]                           break
[13:33:42.158]                         }
[13:33:42.158]                       }
[13:33:42.158]                     }
[13:33:42.158]                     invisible(muffled)
[13:33:42.158]                   }
[13:33:42.158]                   muffleCondition(cond)
[13:33:42.158]                 })
[13:33:42.158]             }))
[13:33:42.158]             future::FutureResult(value = ...future.value$value, 
[13:33:42.158]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:42.158]                   ...future.rng), globalenv = if (FALSE) 
[13:33:42.158]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:42.158]                     ...future.globalenv.names))
[13:33:42.158]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:42.158]         }, condition = base::local({
[13:33:42.158]             c <- base::c
[13:33:42.158]             inherits <- base::inherits
[13:33:42.158]             invokeRestart <- base::invokeRestart
[13:33:42.158]             length <- base::length
[13:33:42.158]             list <- base::list
[13:33:42.158]             seq.int <- base::seq.int
[13:33:42.158]             signalCondition <- base::signalCondition
[13:33:42.158]             sys.calls <- base::sys.calls
[13:33:42.158]             `[[` <- base::`[[`
[13:33:42.158]             `+` <- base::`+`
[13:33:42.158]             `<<-` <- base::`<<-`
[13:33:42.158]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:42.158]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:42.158]                   3L)]
[13:33:42.158]             }
[13:33:42.158]             function(cond) {
[13:33:42.158]                 is_error <- inherits(cond, "error")
[13:33:42.158]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:42.158]                   NULL)
[13:33:42.158]                 if (is_error) {
[13:33:42.158]                   sessionInformation <- function() {
[13:33:42.158]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:42.158]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:42.158]                       search = base::search(), system = base::Sys.info())
[13:33:42.158]                   }
[13:33:42.158]                   ...future.conditions[[length(...future.conditions) + 
[13:33:42.158]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:42.158]                     cond$call), session = sessionInformation(), 
[13:33:42.158]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:42.158]                   signalCondition(cond)
[13:33:42.158]                 }
[13:33:42.158]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:42.158]                 "immediateCondition"))) {
[13:33:42.158]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:42.158]                   ...future.conditions[[length(...future.conditions) + 
[13:33:42.158]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:42.158]                   if (TRUE && !signal) {
[13:33:42.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:42.158]                     {
[13:33:42.158]                       inherits <- base::inherits
[13:33:42.158]                       invokeRestart <- base::invokeRestart
[13:33:42.158]                       is.null <- base::is.null
[13:33:42.158]                       muffled <- FALSE
[13:33:42.158]                       if (inherits(cond, "message")) {
[13:33:42.158]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:42.158]                         if (muffled) 
[13:33:42.158]                           invokeRestart("muffleMessage")
[13:33:42.158]                       }
[13:33:42.158]                       else if (inherits(cond, "warning")) {
[13:33:42.158]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:42.158]                         if (muffled) 
[13:33:42.158]                           invokeRestart("muffleWarning")
[13:33:42.158]                       }
[13:33:42.158]                       else if (inherits(cond, "condition")) {
[13:33:42.158]                         if (!is.null(pattern)) {
[13:33:42.158]                           computeRestarts <- base::computeRestarts
[13:33:42.158]                           grepl <- base::grepl
[13:33:42.158]                           restarts <- computeRestarts(cond)
[13:33:42.158]                           for (restart in restarts) {
[13:33:42.158]                             name <- restart$name
[13:33:42.158]                             if (is.null(name)) 
[13:33:42.158]                               next
[13:33:42.158]                             if (!grepl(pattern, name)) 
[13:33:42.158]                               next
[13:33:42.158]                             invokeRestart(restart)
[13:33:42.158]                             muffled <- TRUE
[13:33:42.158]                             break
[13:33:42.158]                           }
[13:33:42.158]                         }
[13:33:42.158]                       }
[13:33:42.158]                       invisible(muffled)
[13:33:42.158]                     }
[13:33:42.158]                     muffleCondition(cond, pattern = "^muffle")
[13:33:42.158]                   }
[13:33:42.158]                 }
[13:33:42.158]                 else {
[13:33:42.158]                   if (TRUE) {
[13:33:42.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:42.158]                     {
[13:33:42.158]                       inherits <- base::inherits
[13:33:42.158]                       invokeRestart <- base::invokeRestart
[13:33:42.158]                       is.null <- base::is.null
[13:33:42.158]                       muffled <- FALSE
[13:33:42.158]                       if (inherits(cond, "message")) {
[13:33:42.158]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:42.158]                         if (muffled) 
[13:33:42.158]                           invokeRestart("muffleMessage")
[13:33:42.158]                       }
[13:33:42.158]                       else if (inherits(cond, "warning")) {
[13:33:42.158]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:42.158]                         if (muffled) 
[13:33:42.158]                           invokeRestart("muffleWarning")
[13:33:42.158]                       }
[13:33:42.158]                       else if (inherits(cond, "condition")) {
[13:33:42.158]                         if (!is.null(pattern)) {
[13:33:42.158]                           computeRestarts <- base::computeRestarts
[13:33:42.158]                           grepl <- base::grepl
[13:33:42.158]                           restarts <- computeRestarts(cond)
[13:33:42.158]                           for (restart in restarts) {
[13:33:42.158]                             name <- restart$name
[13:33:42.158]                             if (is.null(name)) 
[13:33:42.158]                               next
[13:33:42.158]                             if (!grepl(pattern, name)) 
[13:33:42.158]                               next
[13:33:42.158]                             invokeRestart(restart)
[13:33:42.158]                             muffled <- TRUE
[13:33:42.158]                             break
[13:33:42.158]                           }
[13:33:42.158]                         }
[13:33:42.158]                       }
[13:33:42.158]                       invisible(muffled)
[13:33:42.158]                     }
[13:33:42.158]                     muffleCondition(cond, pattern = "^muffle")
[13:33:42.158]                   }
[13:33:42.158]                 }
[13:33:42.158]             }
[13:33:42.158]         }))
[13:33:42.158]     }, error = function(ex) {
[13:33:42.158]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:42.158]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:42.158]                 ...future.rng), started = ...future.startTime, 
[13:33:42.158]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:42.158]             version = "1.8"), class = "FutureResult")
[13:33:42.158]     }, finally = {
[13:33:42.158]         if (!identical(...future.workdir, getwd())) 
[13:33:42.158]             setwd(...future.workdir)
[13:33:42.158]         {
[13:33:42.158]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:42.158]                 ...future.oldOptions$nwarnings <- NULL
[13:33:42.158]             }
[13:33:42.158]             base::options(...future.oldOptions)
[13:33:42.158]             if (.Platform$OS.type == "windows") {
[13:33:42.158]                 old_names <- names(...future.oldEnvVars)
[13:33:42.158]                 envs <- base::Sys.getenv()
[13:33:42.158]                 names <- names(envs)
[13:33:42.158]                 common <- intersect(names, old_names)
[13:33:42.158]                 added <- setdiff(names, old_names)
[13:33:42.158]                 removed <- setdiff(old_names, names)
[13:33:42.158]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:42.158]                   envs[common]]
[13:33:42.158]                 NAMES <- toupper(changed)
[13:33:42.158]                 args <- list()
[13:33:42.158]                 for (kk in seq_along(NAMES)) {
[13:33:42.158]                   name <- changed[[kk]]
[13:33:42.158]                   NAME <- NAMES[[kk]]
[13:33:42.158]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:42.158]                     next
[13:33:42.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:42.158]                 }
[13:33:42.158]                 NAMES <- toupper(added)
[13:33:42.158]                 for (kk in seq_along(NAMES)) {
[13:33:42.158]                   name <- added[[kk]]
[13:33:42.158]                   NAME <- NAMES[[kk]]
[13:33:42.158]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:42.158]                     next
[13:33:42.158]                   args[[name]] <- ""
[13:33:42.158]                 }
[13:33:42.158]                 NAMES <- toupper(removed)
[13:33:42.158]                 for (kk in seq_along(NAMES)) {
[13:33:42.158]                   name <- removed[[kk]]
[13:33:42.158]                   NAME <- NAMES[[kk]]
[13:33:42.158]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:42.158]                     next
[13:33:42.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:42.158]                 }
[13:33:42.158]                 if (length(args) > 0) 
[13:33:42.158]                   base::do.call(base::Sys.setenv, args = args)
[13:33:42.158]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:42.158]             }
[13:33:42.158]             else {
[13:33:42.158]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:42.158]             }
[13:33:42.158]             {
[13:33:42.158]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:42.158]                   0L) {
[13:33:42.158]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:42.158]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:42.158]                   base::options(opts)
[13:33:42.158]                 }
[13:33:42.158]                 {
[13:33:42.158]                   {
[13:33:42.158]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:42.158]                     NULL
[13:33:42.158]                   }
[13:33:42.158]                   options(future.plan = NULL)
[13:33:42.158]                   if (is.na(NA_character_)) 
[13:33:42.158]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:42.158]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:42.158]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:42.158]                     .init = FALSE)
[13:33:42.158]                 }
[13:33:42.158]             }
[13:33:42.158]         }
[13:33:42.158]     })
[13:33:42.158]     if (TRUE) {
[13:33:42.158]         base::sink(type = "output", split = FALSE)
[13:33:42.158]         if (TRUE) {
[13:33:42.158]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:42.158]         }
[13:33:42.158]         else {
[13:33:42.158]             ...future.result["stdout"] <- base::list(NULL)
[13:33:42.158]         }
[13:33:42.158]         base::close(...future.stdout)
[13:33:42.158]         ...future.stdout <- NULL
[13:33:42.158]     }
[13:33:42.158]     ...future.result$conditions <- ...future.conditions
[13:33:42.158]     ...future.result$finished <- base::Sys.time()
[13:33:42.158]     ...future.result
[13:33:42.158] }
[13:33:42.160] assign_globals() ...
[13:33:42.160] List of 7
[13:33:42.160]  $ ...future.FUN            :function (x)  
[13:33:42.160]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:33:42.160]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:42.160]  $ future.call.arguments    : list()
[13:33:42.160]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:42.160]  $ ...future.elements_ii    :List of 1
[13:33:42.160]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:42.160]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:33:42.160]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:42.160]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:42.160]  $ ...future.seeds_ii       : NULL
[13:33:42.160]  $ ...future.globals.maxSize: NULL
[13:33:42.160]  - attr(*, "where")=List of 7
[13:33:42.160]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:42.160]   ..$ breaks                   :<environment: R_EmptyEnv> 
[13:33:42.160]   ..$ wool                     :<environment: R_EmptyEnv> 
[13:33:42.160]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:42.160]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:42.160]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:42.160]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:42.160]  - attr(*, "resolved")= logi FALSE
[13:33:42.160]  - attr(*, "total_size")= num 2320
[13:33:42.160]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:42.160]  - attr(*, "already-done")= logi TRUE
[13:33:42.169] - reassign environment for ‘...future.FUN’
[13:33:42.169] - copied ‘...future.FUN’ to environment
[13:33:42.170] - copied ‘breaks’ to environment
[13:33:42.170] - copied ‘wool’ to environment
[13:33:42.170] - copied ‘future.call.arguments’ to environment
[13:33:42.170] - copied ‘...future.elements_ii’ to environment
[13:33:42.170] - copied ‘...future.seeds_ii’ to environment
[13:33:42.170] - copied ‘...future.globals.maxSize’ to environment
[13:33:42.170] assign_globals() ... done
[13:33:42.170] requestCore(): workers = 2
[13:33:42.172] MulticoreFuture started
[13:33:42.173] - Launch lazy future ... done
[13:33:42.173] run() for ‘MulticoreFuture’ ... done
[13:33:42.174] Created future:
[13:33:42.174] plan(): Setting new future strategy stack:
[13:33:42.174] List of future strategies:
[13:33:42.174] 1. sequential:
[13:33:42.174]    - args: function (..., envir = parent.frame())
[13:33:42.174]    - tweaked: FALSE
[13:33:42.174]    - call: NULL
[13:33:42.175] plan(): nbrOfWorkers() = 1
[13:33:42.180] plan(): Setting new future strategy stack:
[13:33:42.180] List of future strategies:
[13:33:42.180] 1. multicore:
[13:33:42.180]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:42.180]    - tweaked: FALSE
[13:33:42.180]    - call: plan(strategy)
[13:33:42.185] plan(): nbrOfWorkers() = 2
[13:33:42.174] MulticoreFuture:
[13:33:42.174] Label: ‘future_by-1’
[13:33:42.174] Expression:
[13:33:42.174] {
[13:33:42.174]     do.call(function(...) {
[13:33:42.174]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:42.174]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:42.174]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:42.174]             on.exit(options(oopts), add = TRUE)
[13:33:42.174]         }
[13:33:42.174]         {
[13:33:42.174]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:42.174]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:42.174]                 ...future.FUN(...future.X_jj, ...)
[13:33:42.174]             })
[13:33:42.174]         }
[13:33:42.174]     }, args = future.call.arguments)
[13:33:42.174] }
[13:33:42.174] Lazy evaluation: FALSE
[13:33:42.174] Asynchronous evaluation: TRUE
[13:33:42.174] Local evaluation: TRUE
[13:33:42.174] Environment: 0x55cb80e16db8
[13:33:42.174] Capture standard output: TRUE
[13:33:42.174] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:42.174] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[13:33:42.174] Packages: 1 packages (‘stats’)
[13:33:42.174] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:42.174] Resolved: TRUE
[13:33:42.174] Value: <not collected>
[13:33:42.174] Conditions captured: <none>
[13:33:42.174] Early signaling: FALSE
[13:33:42.174] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:42.174] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:42.187] Chunk #1 of 2 ... DONE
[13:33:42.188] Chunk #2 of 2 ...
[13:33:42.188]  - Finding globals in 'X' for chunk #2 ...
[13:33:42.188] getGlobalsAndPackages() ...
[13:33:42.188] Searching for globals...
[13:33:42.189] 
[13:33:42.189] Searching for globals ... DONE
[13:33:42.189] - globals: [0] <none>
[13:33:42.189] getGlobalsAndPackages() ... DONE
[13:33:42.189]    + additional globals found: [n=0] 
[13:33:42.190]    + additional namespaces needed: [n=0] 
[13:33:42.190]  - Finding globals in 'X' for chunk #2 ... DONE
[13:33:42.190]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:42.190]  - seeds: <none>
[13:33:42.190]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:42.190] getGlobalsAndPackages() ...
[13:33:42.191] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:42.191] Resolving globals: FALSE
[13:33:42.191] Tweak future expression to call with '...' arguments ...
[13:33:42.191] {
[13:33:42.191]     do.call(function(...) {
[13:33:42.191]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:42.191]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:42.191]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:42.191]             on.exit(options(oopts), add = TRUE)
[13:33:42.191]         }
[13:33:42.191]         {
[13:33:42.191]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:42.191]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:42.191]                 ...future.FUN(...future.X_jj, ...)
[13:33:42.191]             })
[13:33:42.191]         }
[13:33:42.191]     }, args = future.call.arguments)
[13:33:42.191] }
[13:33:42.191] Tweak future expression to call with '...' arguments ... DONE
[13:33:42.192] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:42.192] 
[13:33:42.193] getGlobalsAndPackages() ... DONE
[13:33:42.193] run() for ‘Future’ ...
[13:33:42.193] - state: ‘created’
[13:33:42.194] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:42.198] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:42.198] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:42.199]   - Field: ‘label’
[13:33:42.199]   - Field: ‘local’
[13:33:42.199]   - Field: ‘owner’
[13:33:42.199]   - Field: ‘envir’
[13:33:42.199]   - Field: ‘workers’
[13:33:42.199]   - Field: ‘packages’
[13:33:42.200]   - Field: ‘gc’
[13:33:42.200]   - Field: ‘job’
[13:33:42.200]   - Field: ‘conditions’
[13:33:42.200]   - Field: ‘expr’
[13:33:42.200]   - Field: ‘uuid’
[13:33:42.200]   - Field: ‘seed’
[13:33:42.200]   - Field: ‘version’
[13:33:42.201]   - Field: ‘result’
[13:33:42.201]   - Field: ‘asynchronous’
[13:33:42.201]   - Field: ‘calls’
[13:33:42.201]   - Field: ‘globals’
[13:33:42.201]   - Field: ‘stdout’
[13:33:42.201]   - Field: ‘earlySignal’
[13:33:42.201]   - Field: ‘lazy’
[13:33:42.202]   - Field: ‘state’
[13:33:42.202] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:42.202] - Launch lazy future ...
[13:33:42.202] Packages needed by the future expression (n = 1): ‘stats’
[13:33:42.203] Packages needed by future strategies (n = 0): <none>
[13:33:42.203] {
[13:33:42.203]     {
[13:33:42.203]         {
[13:33:42.203]             ...future.startTime <- base::Sys.time()
[13:33:42.203]             {
[13:33:42.203]                 {
[13:33:42.203]                   {
[13:33:42.203]                     {
[13:33:42.203]                       {
[13:33:42.203]                         base::local({
[13:33:42.203]                           has_future <- base::requireNamespace("future", 
[13:33:42.203]                             quietly = TRUE)
[13:33:42.203]                           if (has_future) {
[13:33:42.203]                             ns <- base::getNamespace("future")
[13:33:42.203]                             version <- ns[[".package"]][["version"]]
[13:33:42.203]                             if (is.null(version)) 
[13:33:42.203]                               version <- utils::packageVersion("future")
[13:33:42.203]                           }
[13:33:42.203]                           else {
[13:33:42.203]                             version <- NULL
[13:33:42.203]                           }
[13:33:42.203]                           if (!has_future || version < "1.8.0") {
[13:33:42.203]                             info <- base::c(r_version = base::gsub("R version ", 
[13:33:42.203]                               "", base::R.version$version.string), 
[13:33:42.203]                               platform = base::sprintf("%s (%s-bit)", 
[13:33:42.203]                                 base::R.version$platform, 8 * 
[13:33:42.203]                                   base::.Machine$sizeof.pointer), 
[13:33:42.203]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:42.203]                                 "release", "version")], collapse = " "), 
[13:33:42.203]                               hostname = base::Sys.info()[["nodename"]])
[13:33:42.203]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:33:42.203]                               info)
[13:33:42.203]                             info <- base::paste(info, collapse = "; ")
[13:33:42.203]                             if (!has_future) {
[13:33:42.203]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:42.203]                                 info)
[13:33:42.203]                             }
[13:33:42.203]                             else {
[13:33:42.203]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:42.203]                                 info, version)
[13:33:42.203]                             }
[13:33:42.203]                             base::stop(msg)
[13:33:42.203]                           }
[13:33:42.203]                         })
[13:33:42.203]                       }
[13:33:42.203]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:42.203]                       base::options(mc.cores = 1L)
[13:33:42.203]                     }
[13:33:42.203]                     base::local({
[13:33:42.203]                       for (pkg in "stats") {
[13:33:42.203]                         base::loadNamespace(pkg)
[13:33:42.203]                         base::library(pkg, character.only = TRUE)
[13:33:42.203]                       }
[13:33:42.203]                     })
[13:33:42.203]                   }
[13:33:42.203]                   ...future.strategy.old <- future::plan("list")
[13:33:42.203]                   options(future.plan = NULL)
[13:33:42.203]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:42.203]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:42.203]                 }
[13:33:42.203]                 ...future.workdir <- getwd()
[13:33:42.203]             }
[13:33:42.203]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:42.203]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:42.203]         }
[13:33:42.203]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:42.203]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:42.203]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:42.203]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:42.203]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:42.203]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:42.203]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:42.203]             base::names(...future.oldOptions))
[13:33:42.203]     }
[13:33:42.203]     if (FALSE) {
[13:33:42.203]     }
[13:33:42.203]     else {
[13:33:42.203]         if (TRUE) {
[13:33:42.203]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:42.203]                 open = "w")
[13:33:42.203]         }
[13:33:42.203]         else {
[13:33:42.203]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:42.203]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:42.203]         }
[13:33:42.203]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:42.203]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:42.203]             base::sink(type = "output", split = FALSE)
[13:33:42.203]             base::close(...future.stdout)
[13:33:42.203]         }, add = TRUE)
[13:33:42.203]     }
[13:33:42.203]     ...future.frame <- base::sys.nframe()
[13:33:42.203]     ...future.conditions <- base::list()
[13:33:42.203]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:42.203]     if (FALSE) {
[13:33:42.203]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:42.203]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:42.203]     }
[13:33:42.203]     ...future.result <- base::tryCatch({
[13:33:42.203]         base::withCallingHandlers({
[13:33:42.203]             ...future.value <- base::withVisible(base::local({
[13:33:42.203]                 withCallingHandlers({
[13:33:42.203]                   {
[13:33:42.203]                     do.call(function(...) {
[13:33:42.203]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:42.203]                       if (!identical(...future.globals.maxSize.org, 
[13:33:42.203]                         ...future.globals.maxSize)) {
[13:33:42.203]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:42.203]                         on.exit(options(oopts), add = TRUE)
[13:33:42.203]                       }
[13:33:42.203]                       {
[13:33:42.203]                         lapply(seq_along(...future.elements_ii), 
[13:33:42.203]                           FUN = function(jj) {
[13:33:42.203]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:42.203]                             ...future.FUN(...future.X_jj, ...)
[13:33:42.203]                           })
[13:33:42.203]                       }
[13:33:42.203]                     }, args = future.call.arguments)
[13:33:42.203]                   }
[13:33:42.203]                 }, immediateCondition = function(cond) {
[13:33:42.203]                   save_rds <- function (object, pathname, ...) 
[13:33:42.203]                   {
[13:33:42.203]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:42.203]                     if (file_test("-f", pathname_tmp)) {
[13:33:42.203]                       fi_tmp <- file.info(pathname_tmp)
[13:33:42.203]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:42.203]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:42.203]                         fi_tmp[["mtime"]])
[13:33:42.203]                     }
[13:33:42.203]                     tryCatch({
[13:33:42.203]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:42.203]                     }, error = function(ex) {
[13:33:42.203]                       msg <- conditionMessage(ex)
[13:33:42.203]                       fi_tmp <- file.info(pathname_tmp)
[13:33:42.203]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:42.203]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:42.203]                         fi_tmp[["mtime"]], msg)
[13:33:42.203]                       ex$message <- msg
[13:33:42.203]                       stop(ex)
[13:33:42.203]                     })
[13:33:42.203]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:42.203]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:42.203]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:42.203]                       fi_tmp <- file.info(pathname_tmp)
[13:33:42.203]                       fi <- file.info(pathname)
[13:33:42.203]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:42.203]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:42.203]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:42.203]                         fi[["size"]], fi[["mtime"]])
[13:33:42.203]                       stop(msg)
[13:33:42.203]                     }
[13:33:42.203]                     invisible(pathname)
[13:33:42.203]                   }
[13:33:42.203]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:42.203]                     rootPath = tempdir()) 
[13:33:42.203]                   {
[13:33:42.203]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:42.203]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:42.203]                       tmpdir = path, fileext = ".rds")
[13:33:42.203]                     save_rds(obj, file)
[13:33:42.203]                   }
[13:33:42.203]                   saveImmediateCondition(cond, path = "/tmp/RtmpMLLN1L/.future/immediateConditions")
[13:33:42.203]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:42.203]                   {
[13:33:42.203]                     inherits <- base::inherits
[13:33:42.203]                     invokeRestart <- base::invokeRestart
[13:33:42.203]                     is.null <- base::is.null
[13:33:42.203]                     muffled <- FALSE
[13:33:42.203]                     if (inherits(cond, "message")) {
[13:33:42.203]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:42.203]                       if (muffled) 
[13:33:42.203]                         invokeRestart("muffleMessage")
[13:33:42.203]                     }
[13:33:42.203]                     else if (inherits(cond, "warning")) {
[13:33:42.203]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:42.203]                       if (muffled) 
[13:33:42.203]                         invokeRestart("muffleWarning")
[13:33:42.203]                     }
[13:33:42.203]                     else if (inherits(cond, "condition")) {
[13:33:42.203]                       if (!is.null(pattern)) {
[13:33:42.203]                         computeRestarts <- base::computeRestarts
[13:33:42.203]                         grepl <- base::grepl
[13:33:42.203]                         restarts <- computeRestarts(cond)
[13:33:42.203]                         for (restart in restarts) {
[13:33:42.203]                           name <- restart$name
[13:33:42.203]                           if (is.null(name)) 
[13:33:42.203]                             next
[13:33:42.203]                           if (!grepl(pattern, name)) 
[13:33:42.203]                             next
[13:33:42.203]                           invokeRestart(restart)
[13:33:42.203]                           muffled <- TRUE
[13:33:42.203]                           break
[13:33:42.203]                         }
[13:33:42.203]                       }
[13:33:42.203]                     }
[13:33:42.203]                     invisible(muffled)
[13:33:42.203]                   }
[13:33:42.203]                   muffleCondition(cond)
[13:33:42.203]                 })
[13:33:42.203]             }))
[13:33:42.203]             future::FutureResult(value = ...future.value$value, 
[13:33:42.203]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:42.203]                   ...future.rng), globalenv = if (FALSE) 
[13:33:42.203]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:42.203]                     ...future.globalenv.names))
[13:33:42.203]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:42.203]         }, condition = base::local({
[13:33:42.203]             c <- base::c
[13:33:42.203]             inherits <- base::inherits
[13:33:42.203]             invokeRestart <- base::invokeRestart
[13:33:42.203]             length <- base::length
[13:33:42.203]             list <- base::list
[13:33:42.203]             seq.int <- base::seq.int
[13:33:42.203]             signalCondition <- base::signalCondition
[13:33:42.203]             sys.calls <- base::sys.calls
[13:33:42.203]             `[[` <- base::`[[`
[13:33:42.203]             `+` <- base::`+`
[13:33:42.203]             `<<-` <- base::`<<-`
[13:33:42.203]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:42.203]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:42.203]                   3L)]
[13:33:42.203]             }
[13:33:42.203]             function(cond) {
[13:33:42.203]                 is_error <- inherits(cond, "error")
[13:33:42.203]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:42.203]                   NULL)
[13:33:42.203]                 if (is_error) {
[13:33:42.203]                   sessionInformation <- function() {
[13:33:42.203]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:42.203]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:42.203]                       search = base::search(), system = base::Sys.info())
[13:33:42.203]                   }
[13:33:42.203]                   ...future.conditions[[length(...future.conditions) + 
[13:33:42.203]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:42.203]                     cond$call), session = sessionInformation(), 
[13:33:42.203]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:42.203]                   signalCondition(cond)
[13:33:42.203]                 }
[13:33:42.203]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:42.203]                 "immediateCondition"))) {
[13:33:42.203]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:42.203]                   ...future.conditions[[length(...future.conditions) + 
[13:33:42.203]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:42.203]                   if (TRUE && !signal) {
[13:33:42.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:42.203]                     {
[13:33:42.203]                       inherits <- base::inherits
[13:33:42.203]                       invokeRestart <- base::invokeRestart
[13:33:42.203]                       is.null <- base::is.null
[13:33:42.203]                       muffled <- FALSE
[13:33:42.203]                       if (inherits(cond, "message")) {
[13:33:42.203]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:42.203]                         if (muffled) 
[13:33:42.203]                           invokeRestart("muffleMessage")
[13:33:42.203]                       }
[13:33:42.203]                       else if (inherits(cond, "warning")) {
[13:33:42.203]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:42.203]                         if (muffled) 
[13:33:42.203]                           invokeRestart("muffleWarning")
[13:33:42.203]                       }
[13:33:42.203]                       else if (inherits(cond, "condition")) {
[13:33:42.203]                         if (!is.null(pattern)) {
[13:33:42.203]                           computeRestarts <- base::computeRestarts
[13:33:42.203]                           grepl <- base::grepl
[13:33:42.203]                           restarts <- computeRestarts(cond)
[13:33:42.203]                           for (restart in restarts) {
[13:33:42.203]                             name <- restart$name
[13:33:42.203]                             if (is.null(name)) 
[13:33:42.203]                               next
[13:33:42.203]                             if (!grepl(pattern, name)) 
[13:33:42.203]                               next
[13:33:42.203]                             invokeRestart(restart)
[13:33:42.203]                             muffled <- TRUE
[13:33:42.203]                             break
[13:33:42.203]                           }
[13:33:42.203]                         }
[13:33:42.203]                       }
[13:33:42.203]                       invisible(muffled)
[13:33:42.203]                     }
[13:33:42.203]                     muffleCondition(cond, pattern = "^muffle")
[13:33:42.203]                   }
[13:33:42.203]                 }
[13:33:42.203]                 else {
[13:33:42.203]                   if (TRUE) {
[13:33:42.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:42.203]                     {
[13:33:42.203]                       inherits <- base::inherits
[13:33:42.203]                       invokeRestart <- base::invokeRestart
[13:33:42.203]                       is.null <- base::is.null
[13:33:42.203]                       muffled <- FALSE
[13:33:42.203]                       if (inherits(cond, "message")) {
[13:33:42.203]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:42.203]                         if (muffled) 
[13:33:42.203]                           invokeRestart("muffleMessage")
[13:33:42.203]                       }
[13:33:42.203]                       else if (inherits(cond, "warning")) {
[13:33:42.203]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:42.203]                         if (muffled) 
[13:33:42.203]                           invokeRestart("muffleWarning")
[13:33:42.203]                       }
[13:33:42.203]                       else if (inherits(cond, "condition")) {
[13:33:42.203]                         if (!is.null(pattern)) {
[13:33:42.203]                           computeRestarts <- base::computeRestarts
[13:33:42.203]                           grepl <- base::grepl
[13:33:42.203]                           restarts <- computeRestarts(cond)
[13:33:42.203]                           for (restart in restarts) {
[13:33:42.203]                             name <- restart$name
[13:33:42.203]                             if (is.null(name)) 
[13:33:42.203]                               next
[13:33:42.203]                             if (!grepl(pattern, name)) 
[13:33:42.203]                               next
[13:33:42.203]                             invokeRestart(restart)
[13:33:42.203]                             muffled <- TRUE
[13:33:42.203]                             break
[13:33:42.203]                           }
[13:33:42.203]                         }
[13:33:42.203]                       }
[13:33:42.203]                       invisible(muffled)
[13:33:42.203]                     }
[13:33:42.203]                     muffleCondition(cond, pattern = "^muffle")
[13:33:42.203]                   }
[13:33:42.203]                 }
[13:33:42.203]             }
[13:33:42.203]         }))
[13:33:42.203]     }, error = function(ex) {
[13:33:42.203]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:42.203]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:42.203]                 ...future.rng), started = ...future.startTime, 
[13:33:42.203]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:42.203]             version = "1.8"), class = "FutureResult")
[13:33:42.203]     }, finally = {
[13:33:42.203]         if (!identical(...future.workdir, getwd())) 
[13:33:42.203]             setwd(...future.workdir)
[13:33:42.203]         {
[13:33:42.203]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:42.203]                 ...future.oldOptions$nwarnings <- NULL
[13:33:42.203]             }
[13:33:42.203]             base::options(...future.oldOptions)
[13:33:42.203]             if (.Platform$OS.type == "windows") {
[13:33:42.203]                 old_names <- names(...future.oldEnvVars)
[13:33:42.203]                 envs <- base::Sys.getenv()
[13:33:42.203]                 names <- names(envs)
[13:33:42.203]                 common <- intersect(names, old_names)
[13:33:42.203]                 added <- setdiff(names, old_names)
[13:33:42.203]                 removed <- setdiff(old_names, names)
[13:33:42.203]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:42.203]                   envs[common]]
[13:33:42.203]                 NAMES <- toupper(changed)
[13:33:42.203]                 args <- list()
[13:33:42.203]                 for (kk in seq_along(NAMES)) {
[13:33:42.203]                   name <- changed[[kk]]
[13:33:42.203]                   NAME <- NAMES[[kk]]
[13:33:42.203]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:42.203]                     next
[13:33:42.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:42.203]                 }
[13:33:42.203]                 NAMES <- toupper(added)
[13:33:42.203]                 for (kk in seq_along(NAMES)) {
[13:33:42.203]                   name <- added[[kk]]
[13:33:42.203]                   NAME <- NAMES[[kk]]
[13:33:42.203]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:42.203]                     next
[13:33:42.203]                   args[[name]] <- ""
[13:33:42.203]                 }
[13:33:42.203]                 NAMES <- toupper(removed)
[13:33:42.203]                 for (kk in seq_along(NAMES)) {
[13:33:42.203]                   name <- removed[[kk]]
[13:33:42.203]                   NAME <- NAMES[[kk]]
[13:33:42.203]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:42.203]                     next
[13:33:42.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:42.203]                 }
[13:33:42.203]                 if (length(args) > 0) 
[13:33:42.203]                   base::do.call(base::Sys.setenv, args = args)
[13:33:42.203]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:42.203]             }
[13:33:42.203]             else {
[13:33:42.203]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:42.203]             }
[13:33:42.203]             {
[13:33:42.203]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:42.203]                   0L) {
[13:33:42.203]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:42.203]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:42.203]                   base::options(opts)
[13:33:42.203]                 }
[13:33:42.203]                 {
[13:33:42.203]                   {
[13:33:42.203]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:42.203]                     NULL
[13:33:42.203]                   }
[13:33:42.203]                   options(future.plan = NULL)
[13:33:42.203]                   if (is.na(NA_character_)) 
[13:33:42.203]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:42.203]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:42.203]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:42.203]                     .init = FALSE)
[13:33:42.203]                 }
[13:33:42.203]             }
[13:33:42.203]         }
[13:33:42.203]     })
[13:33:42.203]     if (TRUE) {
[13:33:42.203]         base::sink(type = "output", split = FALSE)
[13:33:42.203]         if (TRUE) {
[13:33:42.203]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:42.203]         }
[13:33:42.203]         else {
[13:33:42.203]             ...future.result["stdout"] <- base::list(NULL)
[13:33:42.203]         }
[13:33:42.203]         base::close(...future.stdout)
[13:33:42.203]         ...future.stdout <- NULL
[13:33:42.203]     }
[13:33:42.203]     ...future.result$conditions <- ...future.conditions
[13:33:42.203]     ...future.result$finished <- base::Sys.time()
[13:33:42.203]     ...future.result
[13:33:42.203] }
[13:33:42.207] assign_globals() ...
[13:33:42.207] List of 7
[13:33:42.207]  $ ...future.FUN            :function (x)  
[13:33:42.207]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:33:42.207]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:42.207]  $ future.call.arguments    : list()
[13:33:42.207]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:42.207]  $ ...future.elements_ii    :List of 2
[13:33:42.207]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:42.207]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:33:42.207]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:42.207]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:33:42.207]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:42.207]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:33:42.207]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:42.207]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:33:42.207]  $ ...future.seeds_ii       : NULL
[13:33:42.207]  $ ...future.globals.maxSize: NULL
[13:33:42.207]  - attr(*, "where")=List of 7
[13:33:42.207]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:42.207]   ..$ breaks                   :<environment: R_EmptyEnv> 
[13:33:42.207]   ..$ wool                     :<environment: R_EmptyEnv> 
[13:33:42.207]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:42.207]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:42.207]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:42.207]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:42.207]  - attr(*, "resolved")= logi FALSE
[13:33:42.207]  - attr(*, "total_size")= num 2320
[13:33:42.207]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:42.207]  - attr(*, "already-done")= logi TRUE
[13:33:42.223] - reassign environment for ‘...future.FUN’
[13:33:42.223] - copied ‘...future.FUN’ to environment
[13:33:42.223] - copied ‘breaks’ to environment
[13:33:42.223] - copied ‘wool’ to environment
[13:33:42.224] - copied ‘future.call.arguments’ to environment
[13:33:42.224] - copied ‘...future.elements_ii’ to environment
[13:33:42.224] - copied ‘...future.seeds_ii’ to environment
[13:33:42.224] - copied ‘...future.globals.maxSize’ to environment
[13:33:42.224] assign_globals() ... done
[13:33:42.224] requestCore(): workers = 2
[13:33:42.226] MulticoreFuture started
[13:33:42.227] - Launch lazy future ... done
[13:33:42.227] run() for ‘MulticoreFuture’ ... done
[13:33:42.227] Created future:
[13:33:42.228] plan(): Setting new future strategy stack:
[13:33:42.228] List of future strategies:
[13:33:42.228] 1. sequential:
[13:33:42.228]    - args: function (..., envir = parent.frame())
[13:33:42.228]    - tweaked: FALSE
[13:33:42.228]    - call: NULL
[13:33:42.229] plan(): nbrOfWorkers() = 1
[13:33:42.234] plan(): Setting new future strategy stack:
[13:33:42.234] List of future strategies:
[13:33:42.234] 1. multicore:
[13:33:42.234]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:42.234]    - tweaked: FALSE
[13:33:42.234]    - call: plan(strategy)
[13:33:42.239] plan(): nbrOfWorkers() = 2
[13:33:42.227] MulticoreFuture:
[13:33:42.227] Label: ‘future_by-2’
[13:33:42.227] Expression:
[13:33:42.227] {
[13:33:42.227]     do.call(function(...) {
[13:33:42.227]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:42.227]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:42.227]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:42.227]             on.exit(options(oopts), add = TRUE)
[13:33:42.227]         }
[13:33:42.227]         {
[13:33:42.227]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:42.227]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:42.227]                 ...future.FUN(...future.X_jj, ...)
[13:33:42.227]             })
[13:33:42.227]         }
[13:33:42.227]     }, args = future.call.arguments)
[13:33:42.227] }
[13:33:42.227] Lazy evaluation: FALSE
[13:33:42.227] Asynchronous evaluation: TRUE
[13:33:42.227] Local evaluation: TRUE
[13:33:42.227] Environment: 0x55cb80e16db8
[13:33:42.227] Capture standard output: TRUE
[13:33:42.227] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:42.227] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[13:33:42.227] Packages: 1 packages (‘stats’)
[13:33:42.227] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:42.227] Resolved: FALSE
[13:33:42.227] Value: <not collected>
[13:33:42.227] Conditions captured: <none>
[13:33:42.227] Early signaling: FALSE
[13:33:42.227] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:42.227] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:42.241] Chunk #2 of 2 ... DONE
[13:33:42.241] Launching 2 futures (chunks) ... DONE
[13:33:42.241] Resolving 2 futures (chunks) ...
[13:33:42.241] resolve() on list ...
[13:33:42.242]  recursive: 0
[13:33:42.242]  length: 2
[13:33:42.242] 
[13:33:42.242] Future #1
[13:33:42.242] result() for MulticoreFuture ...
[13:33:42.244] result() for MulticoreFuture ...
[13:33:42.244] result() for MulticoreFuture ... done
[13:33:42.244] result() for MulticoreFuture ... done
[13:33:42.244] result() for MulticoreFuture ...
[13:33:42.244] result() for MulticoreFuture ... done
[13:33:42.245] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:33:42.245] - nx: 2
[13:33:42.245] - relay: TRUE
[13:33:42.245] - stdout: TRUE
[13:33:42.245] - signal: TRUE
[13:33:42.245] - resignal: FALSE
[13:33:42.245] - force: TRUE
[13:33:42.245] - relayed: [n=2] FALSE, FALSE
[13:33:42.246] - queued futures: [n=2] FALSE, FALSE
[13:33:42.246]  - until=1
[13:33:42.246]  - relaying element #1
[13:33:42.246] result() for MulticoreFuture ...
[13:33:42.246] result() for MulticoreFuture ... done
[13:33:42.246] result() for MulticoreFuture ...
[13:33:42.246] result() for MulticoreFuture ... done
[13:33:42.247] result() for MulticoreFuture ...
[13:33:42.247] result() for MulticoreFuture ... done
[13:33:42.247] result() for MulticoreFuture ...
[13:33:42.247] result() for MulticoreFuture ... done
[13:33:42.247] - relayed: [n=2] TRUE, FALSE
[13:33:42.247] - queued futures: [n=2] TRUE, FALSE
[13:33:42.248] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:33:42.248]  length: 1 (resolved future 1)
[13:33:42.248] Future #2
[13:33:42.248] result() for MulticoreFuture ...
[13:33:42.249] result() for MulticoreFuture ...
[13:33:42.289] result() for MulticoreFuture ... done
[13:33:42.290] result() for MulticoreFuture ... done
[13:33:42.290] result() for MulticoreFuture ...
[13:33:42.290] result() for MulticoreFuture ... done
[13:33:42.290] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:33:42.290] - nx: 2
[13:33:42.290] - relay: TRUE
[13:33:42.290] - stdout: TRUE
[13:33:42.290] - signal: TRUE
[13:33:42.290] - resignal: FALSE
[13:33:42.290] - force: TRUE
[13:33:42.290] - relayed: [n=2] TRUE, FALSE
[13:33:42.291] - queued futures: [n=2] TRUE, FALSE
[13:33:42.291]  - until=2
[13:33:42.291]  - relaying element #2
[13:33:42.291] result() for MulticoreFuture ...
[13:33:42.291] result() for MulticoreFuture ... done
[13:33:42.291] result() for MulticoreFuture ...
[13:33:42.291] result() for MulticoreFuture ... done
[13:33:42.291] result() for MulticoreFuture ...
[13:33:42.291] result() for MulticoreFuture ... done
[13:33:42.291] result() for MulticoreFuture ...
[13:33:42.291] result() for MulticoreFuture ... done
[13:33:42.292] - relayed: [n=2] TRUE, TRUE
[13:33:42.292] - queued futures: [n=2] TRUE, TRUE
[13:33:42.292] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:33:42.292]  length: 0 (resolved future 2)
[13:33:42.292] Relaying remaining futures
[13:33:42.292] signalConditionsASAP(NULL, pos=0) ...
[13:33:42.292] - nx: 2
[13:33:42.292] - relay: TRUE
[13:33:42.292] - stdout: TRUE
[13:33:42.292] - signal: TRUE
[13:33:42.292] - resignal: FALSE
[13:33:42.292] - force: TRUE
[13:33:42.293] - relayed: [n=2] TRUE, TRUE
[13:33:42.293] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:42.293] - relayed: [n=2] TRUE, TRUE
[13:33:42.293] - queued futures: [n=2] TRUE, TRUE
[13:33:42.293] signalConditionsASAP(NULL, pos=0) ... done
[13:33:42.293] resolve() on list ... DONE
[13:33:42.293] result() for MulticoreFuture ...
[13:33:42.293] result() for MulticoreFuture ... done
[13:33:42.293] result() for MulticoreFuture ...
[13:33:42.293] result() for MulticoreFuture ... done
[13:33:42.293] result() for MulticoreFuture ...
[13:33:42.294] result() for MulticoreFuture ... done
[13:33:42.294] result() for MulticoreFuture ...
[13:33:42.294] result() for MulticoreFuture ... done
[13:33:42.294]  - Number of value chunks collected: 2
[13:33:42.294] Resolving 2 futures (chunks) ... DONE
[13:33:42.294] Reducing values from 2 chunks ...
[13:33:42.294]  - Number of values collected after concatenation: 3
[13:33:42.294]  - Number of values expected: 3
[13:33:42.294] Reducing values from 2 chunks ... DONE
[13:33:42.294] future_lapply() ... DONE
[13:33:42.294] future_by_internal() ... DONE
[13:33:42.295] future_by_internal() ...
[13:33:42.295] future_lapply() ...
[13:33:42.300] Number of chunks: 2
[13:33:42.300] getGlobalsAndPackagesXApply() ...
[13:33:42.300]  - future.globals: TRUE
[13:33:42.300] getGlobalsAndPackages() ...
[13:33:42.300] Searching for globals...
[13:33:42.301] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:42.301] Searching for globals ... DONE
[13:33:42.301] Resolving globals: FALSE
[13:33:42.302] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:42.302] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:42.302] - globals: [1] ‘FUN’
[13:33:42.302] 
[13:33:42.302] getGlobalsAndPackages() ... DONE
[13:33:42.302]  - globals found/used: [n=1] ‘FUN’
[13:33:42.302]  - needed namespaces: [n=0] 
[13:33:42.302] Finding globals ... DONE
[13:33:42.303]  - use_args: TRUE
[13:33:42.303]  - Getting '...' globals ...
[13:33:42.303] resolve() on list ...
[13:33:42.303]  recursive: 0
[13:33:42.303]  length: 1
[13:33:42.303]  elements: ‘...’
[13:33:42.303]  length: 0 (resolved future 1)
[13:33:42.303] resolve() on list ... DONE
[13:33:42.303]    - '...' content: [n=0] 
[13:33:42.304] List of 1
[13:33:42.304]  $ ...: list()
[13:33:42.304]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:42.304]  - attr(*, "where")=List of 1
[13:33:42.304]   ..$ ...:<environment: 0x55cb82912d50> 
[13:33:42.304]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:42.304]  - attr(*, "resolved")= logi TRUE
[13:33:42.304]  - attr(*, "total_size")= num NA
[13:33:42.306]  - Getting '...' globals ... DONE
[13:33:42.306] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:42.306] List of 2
[13:33:42.306]  $ ...future.FUN:function (object, ...)  
[13:33:42.306]  $ ...          : list()
[13:33:42.306]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:42.306]  - attr(*, "where")=List of 2
[13:33:42.306]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:42.306]   ..$ ...          :<environment: 0x55cb82912d50> 
[13:33:42.306]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:42.306]  - attr(*, "resolved")= logi FALSE
[13:33:42.306]  - attr(*, "total_size")= num 1240
[13:33:42.309] Packages to be attached in all futures: [n=0] 
[13:33:42.309] getGlobalsAndPackagesXApply() ... DONE
[13:33:42.309] Number of futures (= number of chunks): 2
[13:33:42.309] Launching 2 futures (chunks) ...
[13:33:42.309] Chunk #1 of 2 ...
[13:33:42.309]  - Finding globals in 'X' for chunk #1 ...
[13:33:42.310] getGlobalsAndPackages() ...
[13:33:42.310] Searching for globals...
[13:33:42.310] 
[13:33:42.310] Searching for globals ... DONE
[13:33:42.310] - globals: [0] <none>
[13:33:42.310] getGlobalsAndPackages() ... DONE
[13:33:42.310]    + additional globals found: [n=0] 
[13:33:42.310]    + additional namespaces needed: [n=0] 
[13:33:42.311]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:42.311]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:42.311]  - seeds: <none>
[13:33:42.311]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:42.311] getGlobalsAndPackages() ...
[13:33:42.311] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:42.311] Resolving globals: FALSE
[13:33:42.311] Tweak future expression to call with '...' arguments ...
[13:33:42.311] {
[13:33:42.311]     do.call(function(...) {
[13:33:42.311]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:42.311]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:42.311]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:42.311]             on.exit(options(oopts), add = TRUE)
[13:33:42.311]         }
[13:33:42.311]         {
[13:33:42.311]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:42.311]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:42.311]                 ...future.FUN(...future.X_jj, ...)
[13:33:42.311]             })
[13:33:42.311]         }
[13:33:42.311]     }, args = future.call.arguments)
[13:33:42.311] }
[13:33:42.312] Tweak future expression to call with '...' arguments ... DONE
[13:33:42.312] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:42.312] 
[13:33:42.312] getGlobalsAndPackages() ... DONE
[13:33:42.312] run() for ‘Future’ ...
[13:33:42.312] - state: ‘created’
[13:33:42.313] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:42.316] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:42.316] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:42.316]   - Field: ‘label’
[13:33:42.316]   - Field: ‘local’
[13:33:42.317]   - Field: ‘owner’
[13:33:42.317]   - Field: ‘envir’
[13:33:42.317]   - Field: ‘workers’
[13:33:42.317]   - Field: ‘packages’
[13:33:42.317]   - Field: ‘gc’
[13:33:42.317]   - Field: ‘job’
[13:33:42.317]   - Field: ‘conditions’
[13:33:42.317]   - Field: ‘expr’
[13:33:42.317]   - Field: ‘uuid’
[13:33:42.317]   - Field: ‘seed’
[13:33:42.317]   - Field: ‘version’
[13:33:42.318]   - Field: ‘result’
[13:33:42.318]   - Field: ‘asynchronous’
[13:33:42.318]   - Field: ‘calls’
[13:33:42.318]   - Field: ‘globals’
[13:33:42.318]   - Field: ‘stdout’
[13:33:42.318]   - Field: ‘earlySignal’
[13:33:42.318]   - Field: ‘lazy’
[13:33:42.318]   - Field: ‘state’
[13:33:42.318] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:42.318] - Launch lazy future ...
[13:33:42.319] Packages needed by the future expression (n = 0): <none>
[13:33:42.319] Packages needed by future strategies (n = 0): <none>
[13:33:42.319] {
[13:33:42.319]     {
[13:33:42.319]         {
[13:33:42.319]             ...future.startTime <- base::Sys.time()
[13:33:42.319]             {
[13:33:42.319]                 {
[13:33:42.319]                   {
[13:33:42.319]                     {
[13:33:42.319]                       base::local({
[13:33:42.319]                         has_future <- base::requireNamespace("future", 
[13:33:42.319]                           quietly = TRUE)
[13:33:42.319]                         if (has_future) {
[13:33:42.319]                           ns <- base::getNamespace("future")
[13:33:42.319]                           version <- ns[[".package"]][["version"]]
[13:33:42.319]                           if (is.null(version)) 
[13:33:42.319]                             version <- utils::packageVersion("future")
[13:33:42.319]                         }
[13:33:42.319]                         else {
[13:33:42.319]                           version <- NULL
[13:33:42.319]                         }
[13:33:42.319]                         if (!has_future || version < "1.8.0") {
[13:33:42.319]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:42.319]                             "", base::R.version$version.string), 
[13:33:42.319]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:42.319]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:42.319]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:42.319]                               "release", "version")], collapse = " "), 
[13:33:42.319]                             hostname = base::Sys.info()[["nodename"]])
[13:33:42.319]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:42.319]                             info)
[13:33:42.319]                           info <- base::paste(info, collapse = "; ")
[13:33:42.319]                           if (!has_future) {
[13:33:42.319]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:42.319]                               info)
[13:33:42.319]                           }
[13:33:42.319]                           else {
[13:33:42.319]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:42.319]                               info, version)
[13:33:42.319]                           }
[13:33:42.319]                           base::stop(msg)
[13:33:42.319]                         }
[13:33:42.319]                       })
[13:33:42.319]                     }
[13:33:42.319]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:42.319]                     base::options(mc.cores = 1L)
[13:33:42.319]                   }
[13:33:42.319]                   ...future.strategy.old <- future::plan("list")
[13:33:42.319]                   options(future.plan = NULL)
[13:33:42.319]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:42.319]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:42.319]                 }
[13:33:42.319]                 ...future.workdir <- getwd()
[13:33:42.319]             }
[13:33:42.319]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:42.319]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:42.319]         }
[13:33:42.319]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:42.319]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:42.319]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:42.319]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:42.319]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:42.319]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:42.319]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:42.319]             base::names(...future.oldOptions))
[13:33:42.319]     }
[13:33:42.319]     if (FALSE) {
[13:33:42.319]     }
[13:33:42.319]     else {
[13:33:42.319]         if (TRUE) {
[13:33:42.319]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:42.319]                 open = "w")
[13:33:42.319]         }
[13:33:42.319]         else {
[13:33:42.319]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:42.319]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:42.319]         }
[13:33:42.319]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:42.319]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:42.319]             base::sink(type = "output", split = FALSE)
[13:33:42.319]             base::close(...future.stdout)
[13:33:42.319]         }, add = TRUE)
[13:33:42.319]     }
[13:33:42.319]     ...future.frame <- base::sys.nframe()
[13:33:42.319]     ...future.conditions <- base::list()
[13:33:42.319]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:42.319]     if (FALSE) {
[13:33:42.319]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:42.319]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:42.319]     }
[13:33:42.319]     ...future.result <- base::tryCatch({
[13:33:42.319]         base::withCallingHandlers({
[13:33:42.319]             ...future.value <- base::withVisible(base::local({
[13:33:42.319]                 withCallingHandlers({
[13:33:42.319]                   {
[13:33:42.319]                     do.call(function(...) {
[13:33:42.319]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:42.319]                       if (!identical(...future.globals.maxSize.org, 
[13:33:42.319]                         ...future.globals.maxSize)) {
[13:33:42.319]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:42.319]                         on.exit(options(oopts), add = TRUE)
[13:33:42.319]                       }
[13:33:42.319]                       {
[13:33:42.319]                         lapply(seq_along(...future.elements_ii), 
[13:33:42.319]                           FUN = function(jj) {
[13:33:42.319]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:42.319]                             ...future.FUN(...future.X_jj, ...)
[13:33:42.319]                           })
[13:33:42.319]                       }
[13:33:42.319]                     }, args = future.call.arguments)
[13:33:42.319]                   }
[13:33:42.319]                 }, immediateCondition = function(cond) {
[13:33:42.319]                   save_rds <- function (object, pathname, ...) 
[13:33:42.319]                   {
[13:33:42.319]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:42.319]                     if (file_test("-f", pathname_tmp)) {
[13:33:42.319]                       fi_tmp <- file.info(pathname_tmp)
[13:33:42.319]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:42.319]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:42.319]                         fi_tmp[["mtime"]])
[13:33:42.319]                     }
[13:33:42.319]                     tryCatch({
[13:33:42.319]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:42.319]                     }, error = function(ex) {
[13:33:42.319]                       msg <- conditionMessage(ex)
[13:33:42.319]                       fi_tmp <- file.info(pathname_tmp)
[13:33:42.319]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:42.319]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:42.319]                         fi_tmp[["mtime"]], msg)
[13:33:42.319]                       ex$message <- msg
[13:33:42.319]                       stop(ex)
[13:33:42.319]                     })
[13:33:42.319]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:42.319]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:42.319]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:42.319]                       fi_tmp <- file.info(pathname_tmp)
[13:33:42.319]                       fi <- file.info(pathname)
[13:33:42.319]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:42.319]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:42.319]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:42.319]                         fi[["size"]], fi[["mtime"]])
[13:33:42.319]                       stop(msg)
[13:33:42.319]                     }
[13:33:42.319]                     invisible(pathname)
[13:33:42.319]                   }
[13:33:42.319]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:42.319]                     rootPath = tempdir()) 
[13:33:42.319]                   {
[13:33:42.319]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:42.319]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:42.319]                       tmpdir = path, fileext = ".rds")
[13:33:42.319]                     save_rds(obj, file)
[13:33:42.319]                   }
[13:33:42.319]                   saveImmediateCondition(cond, path = "/tmp/RtmpMLLN1L/.future/immediateConditions")
[13:33:42.319]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:42.319]                   {
[13:33:42.319]                     inherits <- base::inherits
[13:33:42.319]                     invokeRestart <- base::invokeRestart
[13:33:42.319]                     is.null <- base::is.null
[13:33:42.319]                     muffled <- FALSE
[13:33:42.319]                     if (inherits(cond, "message")) {
[13:33:42.319]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:42.319]                       if (muffled) 
[13:33:42.319]                         invokeRestart("muffleMessage")
[13:33:42.319]                     }
[13:33:42.319]                     else if (inherits(cond, "warning")) {
[13:33:42.319]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:42.319]                       if (muffled) 
[13:33:42.319]                         invokeRestart("muffleWarning")
[13:33:42.319]                     }
[13:33:42.319]                     else if (inherits(cond, "condition")) {
[13:33:42.319]                       if (!is.null(pattern)) {
[13:33:42.319]                         computeRestarts <- base::computeRestarts
[13:33:42.319]                         grepl <- base::grepl
[13:33:42.319]                         restarts <- computeRestarts(cond)
[13:33:42.319]                         for (restart in restarts) {
[13:33:42.319]                           name <- restart$name
[13:33:42.319]                           if (is.null(name)) 
[13:33:42.319]                             next
[13:33:42.319]                           if (!grepl(pattern, name)) 
[13:33:42.319]                             next
[13:33:42.319]                           invokeRestart(restart)
[13:33:42.319]                           muffled <- TRUE
[13:33:42.319]                           break
[13:33:42.319]                         }
[13:33:42.319]                       }
[13:33:42.319]                     }
[13:33:42.319]                     invisible(muffled)
[13:33:42.319]                   }
[13:33:42.319]                   muffleCondition(cond)
[13:33:42.319]                 })
[13:33:42.319]             }))
[13:33:42.319]             future::FutureResult(value = ...future.value$value, 
[13:33:42.319]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:42.319]                   ...future.rng), globalenv = if (FALSE) 
[13:33:42.319]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:42.319]                     ...future.globalenv.names))
[13:33:42.319]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:42.319]         }, condition = base::local({
[13:33:42.319]             c <- base::c
[13:33:42.319]             inherits <- base::inherits
[13:33:42.319]             invokeRestart <- base::invokeRestart
[13:33:42.319]             length <- base::length
[13:33:42.319]             list <- base::list
[13:33:42.319]             seq.int <- base::seq.int
[13:33:42.319]             signalCondition <- base::signalCondition
[13:33:42.319]             sys.calls <- base::sys.calls
[13:33:42.319]             `[[` <- base::`[[`
[13:33:42.319]             `+` <- base::`+`
[13:33:42.319]             `<<-` <- base::`<<-`
[13:33:42.319]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:42.319]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:42.319]                   3L)]
[13:33:42.319]             }
[13:33:42.319]             function(cond) {
[13:33:42.319]                 is_error <- inherits(cond, "error")
[13:33:42.319]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:42.319]                   NULL)
[13:33:42.319]                 if (is_error) {
[13:33:42.319]                   sessionInformation <- function() {
[13:33:42.319]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:42.319]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:42.319]                       search = base::search(), system = base::Sys.info())
[13:33:42.319]                   }
[13:33:42.319]                   ...future.conditions[[length(...future.conditions) + 
[13:33:42.319]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:42.319]                     cond$call), session = sessionInformation(), 
[13:33:42.319]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:42.319]                   signalCondition(cond)
[13:33:42.319]                 }
[13:33:42.319]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:42.319]                 "immediateCondition"))) {
[13:33:42.319]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:42.319]                   ...future.conditions[[length(...future.conditions) + 
[13:33:42.319]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:42.319]                   if (TRUE && !signal) {
[13:33:42.319]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:42.319]                     {
[13:33:42.319]                       inherits <- base::inherits
[13:33:42.319]                       invokeRestart <- base::invokeRestart
[13:33:42.319]                       is.null <- base::is.null
[13:33:42.319]                       muffled <- FALSE
[13:33:42.319]                       if (inherits(cond, "message")) {
[13:33:42.319]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:42.319]                         if (muffled) 
[13:33:42.319]                           invokeRestart("muffleMessage")
[13:33:42.319]                       }
[13:33:42.319]                       else if (inherits(cond, "warning")) {
[13:33:42.319]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:42.319]                         if (muffled) 
[13:33:42.319]                           invokeRestart("muffleWarning")
[13:33:42.319]                       }
[13:33:42.319]                       else if (inherits(cond, "condition")) {
[13:33:42.319]                         if (!is.null(pattern)) {
[13:33:42.319]                           computeRestarts <- base::computeRestarts
[13:33:42.319]                           grepl <- base::grepl
[13:33:42.319]                           restarts <- computeRestarts(cond)
[13:33:42.319]                           for (restart in restarts) {
[13:33:42.319]                             name <- restart$name
[13:33:42.319]                             if (is.null(name)) 
[13:33:42.319]                               next
[13:33:42.319]                             if (!grepl(pattern, name)) 
[13:33:42.319]                               next
[13:33:42.319]                             invokeRestart(restart)
[13:33:42.319]                             muffled <- TRUE
[13:33:42.319]                             break
[13:33:42.319]                           }
[13:33:42.319]                         }
[13:33:42.319]                       }
[13:33:42.319]                       invisible(muffled)
[13:33:42.319]                     }
[13:33:42.319]                     muffleCondition(cond, pattern = "^muffle")
[13:33:42.319]                   }
[13:33:42.319]                 }
[13:33:42.319]                 else {
[13:33:42.319]                   if (TRUE) {
[13:33:42.319]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:42.319]                     {
[13:33:42.319]                       inherits <- base::inherits
[13:33:42.319]                       invokeRestart <- base::invokeRestart
[13:33:42.319]                       is.null <- base::is.null
[13:33:42.319]                       muffled <- FALSE
[13:33:42.319]                       if (inherits(cond, "message")) {
[13:33:42.319]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:42.319]                         if (muffled) 
[13:33:42.319]                           invokeRestart("muffleMessage")
[13:33:42.319]                       }
[13:33:42.319]                       else if (inherits(cond, "warning")) {
[13:33:42.319]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:42.319]                         if (muffled) 
[13:33:42.319]                           invokeRestart("muffleWarning")
[13:33:42.319]                       }
[13:33:42.319]                       else if (inherits(cond, "condition")) {
[13:33:42.319]                         if (!is.null(pattern)) {
[13:33:42.319]                           computeRestarts <- base::computeRestarts
[13:33:42.319]                           grepl <- base::grepl
[13:33:42.319]                           restarts <- computeRestarts(cond)
[13:33:42.319]                           for (restart in restarts) {
[13:33:42.319]                             name <- restart$name
[13:33:42.319]                             if (is.null(name)) 
[13:33:42.319]                               next
[13:33:42.319]                             if (!grepl(pattern, name)) 
[13:33:42.319]                               next
[13:33:42.319]                             invokeRestart(restart)
[13:33:42.319]                             muffled <- TRUE
[13:33:42.319]                             break
[13:33:42.319]                           }
[13:33:42.319]                         }
[13:33:42.319]                       }
[13:33:42.319]                       invisible(muffled)
[13:33:42.319]                     }
[13:33:42.319]                     muffleCondition(cond, pattern = "^muffle")
[13:33:42.319]                   }
[13:33:42.319]                 }
[13:33:42.319]             }
[13:33:42.319]         }))
[13:33:42.319]     }, error = function(ex) {
[13:33:42.319]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:42.319]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:42.319]                 ...future.rng), started = ...future.startTime, 
[13:33:42.319]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:42.319]             version = "1.8"), class = "FutureResult")
[13:33:42.319]     }, finally = {
[13:33:42.319]         if (!identical(...future.workdir, getwd())) 
[13:33:42.319]             setwd(...future.workdir)
[13:33:42.319]         {
[13:33:42.319]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:42.319]                 ...future.oldOptions$nwarnings <- NULL
[13:33:42.319]             }
[13:33:42.319]             base::options(...future.oldOptions)
[13:33:42.319]             if (.Platform$OS.type == "windows") {
[13:33:42.319]                 old_names <- names(...future.oldEnvVars)
[13:33:42.319]                 envs <- base::Sys.getenv()
[13:33:42.319]                 names <- names(envs)
[13:33:42.319]                 common <- intersect(names, old_names)
[13:33:42.319]                 added <- setdiff(names, old_names)
[13:33:42.319]                 removed <- setdiff(old_names, names)
[13:33:42.319]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:42.319]                   envs[common]]
[13:33:42.319]                 NAMES <- toupper(changed)
[13:33:42.319]                 args <- list()
[13:33:42.319]                 for (kk in seq_along(NAMES)) {
[13:33:42.319]                   name <- changed[[kk]]
[13:33:42.319]                   NAME <- NAMES[[kk]]
[13:33:42.319]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:42.319]                     next
[13:33:42.319]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:42.319]                 }
[13:33:42.319]                 NAMES <- toupper(added)
[13:33:42.319]                 for (kk in seq_along(NAMES)) {
[13:33:42.319]                   name <- added[[kk]]
[13:33:42.319]                   NAME <- NAMES[[kk]]
[13:33:42.319]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:42.319]                     next
[13:33:42.319]                   args[[name]] <- ""
[13:33:42.319]                 }
[13:33:42.319]                 NAMES <- toupper(removed)
[13:33:42.319]                 for (kk in seq_along(NAMES)) {
[13:33:42.319]                   name <- removed[[kk]]
[13:33:42.319]                   NAME <- NAMES[[kk]]
[13:33:42.319]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:42.319]                     next
[13:33:42.319]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:42.319]                 }
[13:33:42.319]                 if (length(args) > 0) 
[13:33:42.319]                   base::do.call(base::Sys.setenv, args = args)
[13:33:42.319]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:42.319]             }
[13:33:42.319]             else {
[13:33:42.319]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:42.319]             }
[13:33:42.319]             {
[13:33:42.319]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:42.319]                   0L) {
[13:33:42.319]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:42.319]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:42.319]                   base::options(opts)
[13:33:42.319]                 }
[13:33:42.319]                 {
[13:33:42.319]                   {
[13:33:42.319]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:42.319]                     NULL
[13:33:42.319]                   }
[13:33:42.319]                   options(future.plan = NULL)
[13:33:42.319]                   if (is.na(NA_character_)) 
[13:33:42.319]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:42.319]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:42.319]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:42.319]                     .init = FALSE)
[13:33:42.319]                 }
[13:33:42.319]             }
[13:33:42.319]         }
[13:33:42.319]     })
[13:33:42.319]     if (TRUE) {
[13:33:42.319]         base::sink(type = "output", split = FALSE)
[13:33:42.319]         if (TRUE) {
[13:33:42.319]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:42.319]         }
[13:33:42.319]         else {
[13:33:42.319]             ...future.result["stdout"] <- base::list(NULL)
[13:33:42.319]         }
[13:33:42.319]         base::close(...future.stdout)
[13:33:42.319]         ...future.stdout <- NULL
[13:33:42.319]     }
[13:33:42.319]     ...future.result$conditions <- ...future.conditions
[13:33:42.319]     ...future.result$finished <- base::Sys.time()
[13:33:42.319]     ...future.result
[13:33:42.319] }
[13:33:42.322] assign_globals() ...
[13:33:42.322] List of 5
[13:33:42.322]  $ ...future.FUN            :function (object, ...)  
[13:33:42.322]  $ future.call.arguments    : list()
[13:33:42.322]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:42.322]  $ ...future.elements_ii    :List of 1
[13:33:42.322]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:42.322]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:33:42.322]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:42.322]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:42.322]  $ ...future.seeds_ii       : NULL
[13:33:42.322]  $ ...future.globals.maxSize: NULL
[13:33:42.322]  - attr(*, "where")=List of 5
[13:33:42.322]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:42.322]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:42.322]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:42.322]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:42.322]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:42.322]  - attr(*, "resolved")= logi FALSE
[13:33:42.322]  - attr(*, "total_size")= num 1240
[13:33:42.322]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:42.322]  - attr(*, "already-done")= logi TRUE
[13:33:42.328] - copied ‘...future.FUN’ to environment
[13:33:42.329] - copied ‘future.call.arguments’ to environment
[13:33:42.329] - copied ‘...future.elements_ii’ to environment
[13:33:42.329] - copied ‘...future.seeds_ii’ to environment
[13:33:42.329] - copied ‘...future.globals.maxSize’ to environment
[13:33:42.329] assign_globals() ... done
[13:33:42.329] requestCore(): workers = 2
[13:33:42.331] MulticoreFuture started
[13:33:42.332] - Launch lazy future ... done
[13:33:42.332] run() for ‘MulticoreFuture’ ... done
[13:33:42.332] Created future:
[13:33:42.333] plan(): Setting new future strategy stack:
[13:33:42.333] List of future strategies:
[13:33:42.333] 1. sequential:
[13:33:42.333]    - args: function (..., envir = parent.frame())
[13:33:42.333]    - tweaked: FALSE
[13:33:42.333]    - call: NULL
[13:33:42.334] plan(): nbrOfWorkers() = 1
[13:33:42.337] plan(): Setting new future strategy stack:
[13:33:42.337] List of future strategies:
[13:33:42.337] 1. multicore:
[13:33:42.337]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:42.337]    - tweaked: FALSE
[13:33:42.337]    - call: plan(strategy)
[13:33:42.342] plan(): nbrOfWorkers() = 2
[13:33:42.332] MulticoreFuture:
[13:33:42.332] Label: ‘future_by-1’
[13:33:42.332] Expression:
[13:33:42.332] {
[13:33:42.332]     do.call(function(...) {
[13:33:42.332]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:42.332]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:42.332]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:42.332]             on.exit(options(oopts), add = TRUE)
[13:33:42.332]         }
[13:33:42.332]         {
[13:33:42.332]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:42.332]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:42.332]                 ...future.FUN(...future.X_jj, ...)
[13:33:42.332]             })
[13:33:42.332]         }
[13:33:42.332]     }, args = future.call.arguments)
[13:33:42.332] }
[13:33:42.332] Lazy evaluation: FALSE
[13:33:42.332] Asynchronous evaluation: TRUE
[13:33:42.332] Local evaluation: TRUE
[13:33:42.332] Environment: 0x55cb829419a0
[13:33:42.332] Capture standard output: TRUE
[13:33:42.332] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:42.332] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:42.332] Packages: <none>
[13:33:42.332] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:42.332] Resolved: TRUE
[13:33:42.332] Value: <not collected>
[13:33:42.332] Conditions captured: <none>
[13:33:42.332] Early signaling: FALSE
[13:33:42.332] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:42.332] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:42.343] Chunk #1 of 2 ... DONE
[13:33:42.343] Chunk #2 of 2 ...
[13:33:42.343]  - Finding globals in 'X' for chunk #2 ...
[13:33:42.343] getGlobalsAndPackages() ...
[13:33:42.343] Searching for globals...
[13:33:42.344] 
[13:33:42.344] Searching for globals ... DONE
[13:33:42.344] - globals: [0] <none>
[13:33:42.345] getGlobalsAndPackages() ... DONE
[13:33:42.345]    + additional globals found: [n=0] 
[13:33:42.345]    + additional namespaces needed: [n=0] 
[13:33:42.345]  - Finding globals in 'X' for chunk #2 ... DONE
[13:33:42.345]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:42.345]  - seeds: <none>
[13:33:42.345]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:42.345] getGlobalsAndPackages() ...
[13:33:42.346] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:42.346] Resolving globals: FALSE
[13:33:42.346] Tweak future expression to call with '...' arguments ...
[13:33:42.346] {
[13:33:42.346]     do.call(function(...) {
[13:33:42.346]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:42.346]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:42.346]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:42.346]             on.exit(options(oopts), add = TRUE)
[13:33:42.346]         }
[13:33:42.346]         {
[13:33:42.346]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:42.346]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:42.346]                 ...future.FUN(...future.X_jj, ...)
[13:33:42.346]             })
[13:33:42.346]         }
[13:33:42.346]     }, args = future.call.arguments)
[13:33:42.346] }
[13:33:42.346] Tweak future expression to call with '...' arguments ... DONE
[13:33:42.347] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:42.347] 
[13:33:42.347] getGlobalsAndPackages() ... DONE
[13:33:42.348] run() for ‘Future’ ...
[13:33:42.348] - state: ‘created’
[13:33:42.348] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:42.352] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:42.353] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:42.353]   - Field: ‘label’
[13:33:42.353]   - Field: ‘local’
[13:33:42.353]   - Field: ‘owner’
[13:33:42.353]   - Field: ‘envir’
[13:33:42.353]   - Field: ‘workers’
[13:33:42.354]   - Field: ‘packages’
[13:33:42.354]   - Field: ‘gc’
[13:33:42.354]   - Field: ‘job’
[13:33:42.354]   - Field: ‘conditions’
[13:33:42.354]   - Field: ‘expr’
[13:33:42.354]   - Field: ‘uuid’
[13:33:42.354]   - Field: ‘seed’
[13:33:42.355]   - Field: ‘version’
[13:33:42.355]   - Field: ‘result’
[13:33:42.355]   - Field: ‘asynchronous’
[13:33:42.355]   - Field: ‘calls’
[13:33:42.355]   - Field: ‘globals’
[13:33:42.355]   - Field: ‘stdout’
[13:33:42.355]   - Field: ‘earlySignal’
[13:33:42.355]   - Field: ‘lazy’
[13:33:42.356]   - Field: ‘state’
[13:33:42.356] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:42.356] - Launch lazy future ...
[13:33:42.356] Packages needed by the future expression (n = 0): <none>
[13:33:42.356] Packages needed by future strategies (n = 0): <none>
[13:33:42.357] {
[13:33:42.357]     {
[13:33:42.357]         {
[13:33:42.357]             ...future.startTime <- base::Sys.time()
[13:33:42.357]             {
[13:33:42.357]                 {
[13:33:42.357]                   {
[13:33:42.357]                     {
[13:33:42.357]                       base::local({
[13:33:42.357]                         has_future <- base::requireNamespace("future", 
[13:33:42.357]                           quietly = TRUE)
[13:33:42.357]                         if (has_future) {
[13:33:42.357]                           ns <- base::getNamespace("future")
[13:33:42.357]                           version <- ns[[".package"]][["version"]]
[13:33:42.357]                           if (is.null(version)) 
[13:33:42.357]                             version <- utils::packageVersion("future")
[13:33:42.357]                         }
[13:33:42.357]                         else {
[13:33:42.357]                           version <- NULL
[13:33:42.357]                         }
[13:33:42.357]                         if (!has_future || version < "1.8.0") {
[13:33:42.357]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:42.357]                             "", base::R.version$version.string), 
[13:33:42.357]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:42.357]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:42.357]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:42.357]                               "release", "version")], collapse = " "), 
[13:33:42.357]                             hostname = base::Sys.info()[["nodename"]])
[13:33:42.357]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:42.357]                             info)
[13:33:42.357]                           info <- base::paste(info, collapse = "; ")
[13:33:42.357]                           if (!has_future) {
[13:33:42.357]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:42.357]                               info)
[13:33:42.357]                           }
[13:33:42.357]                           else {
[13:33:42.357]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:42.357]                               info, version)
[13:33:42.357]                           }
[13:33:42.357]                           base::stop(msg)
[13:33:42.357]                         }
[13:33:42.357]                       })
[13:33:42.357]                     }
[13:33:42.357]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:42.357]                     base::options(mc.cores = 1L)
[13:33:42.357]                   }
[13:33:42.357]                   ...future.strategy.old <- future::plan("list")
[13:33:42.357]                   options(future.plan = NULL)
[13:33:42.357]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:42.357]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:42.357]                 }
[13:33:42.357]                 ...future.workdir <- getwd()
[13:33:42.357]             }
[13:33:42.357]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:42.357]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:42.357]         }
[13:33:42.357]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:42.357]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:42.357]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:42.357]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:42.357]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:42.357]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:42.357]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:42.357]             base::names(...future.oldOptions))
[13:33:42.357]     }
[13:33:42.357]     if (FALSE) {
[13:33:42.357]     }
[13:33:42.357]     else {
[13:33:42.357]         if (TRUE) {
[13:33:42.357]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:42.357]                 open = "w")
[13:33:42.357]         }
[13:33:42.357]         else {
[13:33:42.357]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:42.357]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:42.357]         }
[13:33:42.357]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:42.357]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:42.357]             base::sink(type = "output", split = FALSE)
[13:33:42.357]             base::close(...future.stdout)
[13:33:42.357]         }, add = TRUE)
[13:33:42.357]     }
[13:33:42.357]     ...future.frame <- base::sys.nframe()
[13:33:42.357]     ...future.conditions <- base::list()
[13:33:42.357]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:42.357]     if (FALSE) {
[13:33:42.357]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:42.357]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:42.357]     }
[13:33:42.357]     ...future.result <- base::tryCatch({
[13:33:42.357]         base::withCallingHandlers({
[13:33:42.357]             ...future.value <- base::withVisible(base::local({
[13:33:42.357]                 withCallingHandlers({
[13:33:42.357]                   {
[13:33:42.357]                     do.call(function(...) {
[13:33:42.357]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:42.357]                       if (!identical(...future.globals.maxSize.org, 
[13:33:42.357]                         ...future.globals.maxSize)) {
[13:33:42.357]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:42.357]                         on.exit(options(oopts), add = TRUE)
[13:33:42.357]                       }
[13:33:42.357]                       {
[13:33:42.357]                         lapply(seq_along(...future.elements_ii), 
[13:33:42.357]                           FUN = function(jj) {
[13:33:42.357]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:42.357]                             ...future.FUN(...future.X_jj, ...)
[13:33:42.357]                           })
[13:33:42.357]                       }
[13:33:42.357]                     }, args = future.call.arguments)
[13:33:42.357]                   }
[13:33:42.357]                 }, immediateCondition = function(cond) {
[13:33:42.357]                   save_rds <- function (object, pathname, ...) 
[13:33:42.357]                   {
[13:33:42.357]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:42.357]                     if (file_test("-f", pathname_tmp)) {
[13:33:42.357]                       fi_tmp <- file.info(pathname_tmp)
[13:33:42.357]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:42.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:42.357]                         fi_tmp[["mtime"]])
[13:33:42.357]                     }
[13:33:42.357]                     tryCatch({
[13:33:42.357]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:42.357]                     }, error = function(ex) {
[13:33:42.357]                       msg <- conditionMessage(ex)
[13:33:42.357]                       fi_tmp <- file.info(pathname_tmp)
[13:33:42.357]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:42.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:42.357]                         fi_tmp[["mtime"]], msg)
[13:33:42.357]                       ex$message <- msg
[13:33:42.357]                       stop(ex)
[13:33:42.357]                     })
[13:33:42.357]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:42.357]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:42.357]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:42.357]                       fi_tmp <- file.info(pathname_tmp)
[13:33:42.357]                       fi <- file.info(pathname)
[13:33:42.357]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:42.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:42.357]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:42.357]                         fi[["size"]], fi[["mtime"]])
[13:33:42.357]                       stop(msg)
[13:33:42.357]                     }
[13:33:42.357]                     invisible(pathname)
[13:33:42.357]                   }
[13:33:42.357]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:42.357]                     rootPath = tempdir()) 
[13:33:42.357]                   {
[13:33:42.357]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:42.357]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:42.357]                       tmpdir = path, fileext = ".rds")
[13:33:42.357]                     save_rds(obj, file)
[13:33:42.357]                   }
[13:33:42.357]                   saveImmediateCondition(cond, path = "/tmp/RtmpMLLN1L/.future/immediateConditions")
[13:33:42.357]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:42.357]                   {
[13:33:42.357]                     inherits <- base::inherits
[13:33:42.357]                     invokeRestart <- base::invokeRestart
[13:33:42.357]                     is.null <- base::is.null
[13:33:42.357]                     muffled <- FALSE
[13:33:42.357]                     if (inherits(cond, "message")) {
[13:33:42.357]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:42.357]                       if (muffled) 
[13:33:42.357]                         invokeRestart("muffleMessage")
[13:33:42.357]                     }
[13:33:42.357]                     else if (inherits(cond, "warning")) {
[13:33:42.357]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:42.357]                       if (muffled) 
[13:33:42.357]                         invokeRestart("muffleWarning")
[13:33:42.357]                     }
[13:33:42.357]                     else if (inherits(cond, "condition")) {
[13:33:42.357]                       if (!is.null(pattern)) {
[13:33:42.357]                         computeRestarts <- base::computeRestarts
[13:33:42.357]                         grepl <- base::grepl
[13:33:42.357]                         restarts <- computeRestarts(cond)
[13:33:42.357]                         for (restart in restarts) {
[13:33:42.357]                           name <- restart$name
[13:33:42.357]                           if (is.null(name)) 
[13:33:42.357]                             next
[13:33:42.357]                           if (!grepl(pattern, name)) 
[13:33:42.357]                             next
[13:33:42.357]                           invokeRestart(restart)
[13:33:42.357]                           muffled <- TRUE
[13:33:42.357]                           break
[13:33:42.357]                         }
[13:33:42.357]                       }
[13:33:42.357]                     }
[13:33:42.357]                     invisible(muffled)
[13:33:42.357]                   }
[13:33:42.357]                   muffleCondition(cond)
[13:33:42.357]                 })
[13:33:42.357]             }))
[13:33:42.357]             future::FutureResult(value = ...future.value$value, 
[13:33:42.357]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:42.357]                   ...future.rng), globalenv = if (FALSE) 
[13:33:42.357]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:42.357]                     ...future.globalenv.names))
[13:33:42.357]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:42.357]         }, condition = base::local({
[13:33:42.357]             c <- base::c
[13:33:42.357]             inherits <- base::inherits
[13:33:42.357]             invokeRestart <- base::invokeRestart
[13:33:42.357]             length <- base::length
[13:33:42.357]             list <- base::list
[13:33:42.357]             seq.int <- base::seq.int
[13:33:42.357]             signalCondition <- base::signalCondition
[13:33:42.357]             sys.calls <- base::sys.calls
[13:33:42.357]             `[[` <- base::`[[`
[13:33:42.357]             `+` <- base::`+`
[13:33:42.357]             `<<-` <- base::`<<-`
[13:33:42.357]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:42.357]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:42.357]                   3L)]
[13:33:42.357]             }
[13:33:42.357]             function(cond) {
[13:33:42.357]                 is_error <- inherits(cond, "error")
[13:33:42.357]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:42.357]                   NULL)
[13:33:42.357]                 if (is_error) {
[13:33:42.357]                   sessionInformation <- function() {
[13:33:42.357]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:42.357]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:42.357]                       search = base::search(), system = base::Sys.info())
[13:33:42.357]                   }
[13:33:42.357]                   ...future.conditions[[length(...future.conditions) + 
[13:33:42.357]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:42.357]                     cond$call), session = sessionInformation(), 
[13:33:42.357]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:42.357]                   signalCondition(cond)
[13:33:42.357]                 }
[13:33:42.357]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:42.357]                 "immediateCondition"))) {
[13:33:42.357]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:42.357]                   ...future.conditions[[length(...future.conditions) + 
[13:33:42.357]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:42.357]                   if (TRUE && !signal) {
[13:33:42.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:42.357]                     {
[13:33:42.357]                       inherits <- base::inherits
[13:33:42.357]                       invokeRestart <- base::invokeRestart
[13:33:42.357]                       is.null <- base::is.null
[13:33:42.357]                       muffled <- FALSE
[13:33:42.357]                       if (inherits(cond, "message")) {
[13:33:42.357]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:42.357]                         if (muffled) 
[13:33:42.357]                           invokeRestart("muffleMessage")
[13:33:42.357]                       }
[13:33:42.357]                       else if (inherits(cond, "warning")) {
[13:33:42.357]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:42.357]                         if (muffled) 
[13:33:42.357]                           invokeRestart("muffleWarning")
[13:33:42.357]                       }
[13:33:42.357]                       else if (inherits(cond, "condition")) {
[13:33:42.357]                         if (!is.null(pattern)) {
[13:33:42.357]                           computeRestarts <- base::computeRestarts
[13:33:42.357]                           grepl <- base::grepl
[13:33:42.357]                           restarts <- computeRestarts(cond)
[13:33:42.357]                           for (restart in restarts) {
[13:33:42.357]                             name <- restart$name
[13:33:42.357]                             if (is.null(name)) 
[13:33:42.357]                               next
[13:33:42.357]                             if (!grepl(pattern, name)) 
[13:33:42.357]                               next
[13:33:42.357]                             invokeRestart(restart)
[13:33:42.357]                             muffled <- TRUE
[13:33:42.357]                             break
[13:33:42.357]                           }
[13:33:42.357]                         }
[13:33:42.357]                       }
[13:33:42.357]                       invisible(muffled)
[13:33:42.357]                     }
[13:33:42.357]                     muffleCondition(cond, pattern = "^muffle")
[13:33:42.357]                   }
[13:33:42.357]                 }
[13:33:42.357]                 else {
[13:33:42.357]                   if (TRUE) {
[13:33:42.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:42.357]                     {
[13:33:42.357]                       inherits <- base::inherits
[13:33:42.357]                       invokeRestart <- base::invokeRestart
[13:33:42.357]                       is.null <- base::is.null
[13:33:42.357]                       muffled <- FALSE
[13:33:42.357]                       if (inherits(cond, "message")) {
[13:33:42.357]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:42.357]                         if (muffled) 
[13:33:42.357]                           invokeRestart("muffleMessage")
[13:33:42.357]                       }
[13:33:42.357]                       else if (inherits(cond, "warning")) {
[13:33:42.357]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:42.357]                         if (muffled) 
[13:33:42.357]                           invokeRestart("muffleWarning")
[13:33:42.357]                       }
[13:33:42.357]                       else if (inherits(cond, "condition")) {
[13:33:42.357]                         if (!is.null(pattern)) {
[13:33:42.357]                           computeRestarts <- base::computeRestarts
[13:33:42.357]                           grepl <- base::grepl
[13:33:42.357]                           restarts <- computeRestarts(cond)
[13:33:42.357]                           for (restart in restarts) {
[13:33:42.357]                             name <- restart$name
[13:33:42.357]                             if (is.null(name)) 
[13:33:42.357]                               next
[13:33:42.357]                             if (!grepl(pattern, name)) 
[13:33:42.357]                               next
[13:33:42.357]                             invokeRestart(restart)
[13:33:42.357]                             muffled <- TRUE
[13:33:42.357]                             break
[13:33:42.357]                           }
[13:33:42.357]                         }
[13:33:42.357]                       }
[13:33:42.357]                       invisible(muffled)
[13:33:42.357]                     }
[13:33:42.357]                     muffleCondition(cond, pattern = "^muffle")
[13:33:42.357]                   }
[13:33:42.357]                 }
[13:33:42.357]             }
[13:33:42.357]         }))
[13:33:42.357]     }, error = function(ex) {
[13:33:42.357]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:42.357]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:42.357]                 ...future.rng), started = ...future.startTime, 
[13:33:42.357]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:42.357]             version = "1.8"), class = "FutureResult")
[13:33:42.357]     }, finally = {
[13:33:42.357]         if (!identical(...future.workdir, getwd())) 
[13:33:42.357]             setwd(...future.workdir)
[13:33:42.357]         {
[13:33:42.357]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:42.357]                 ...future.oldOptions$nwarnings <- NULL
[13:33:42.357]             }
[13:33:42.357]             base::options(...future.oldOptions)
[13:33:42.357]             if (.Platform$OS.type == "windows") {
[13:33:42.357]                 old_names <- names(...future.oldEnvVars)
[13:33:42.357]                 envs <- base::Sys.getenv()
[13:33:42.357]                 names <- names(envs)
[13:33:42.357]                 common <- intersect(names, old_names)
[13:33:42.357]                 added <- setdiff(names, old_names)
[13:33:42.357]                 removed <- setdiff(old_names, names)
[13:33:42.357]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:42.357]                   envs[common]]
[13:33:42.357]                 NAMES <- toupper(changed)
[13:33:42.357]                 args <- list()
[13:33:42.357]                 for (kk in seq_along(NAMES)) {
[13:33:42.357]                   name <- changed[[kk]]
[13:33:42.357]                   NAME <- NAMES[[kk]]
[13:33:42.357]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:42.357]                     next
[13:33:42.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:42.357]                 }
[13:33:42.357]                 NAMES <- toupper(added)
[13:33:42.357]                 for (kk in seq_along(NAMES)) {
[13:33:42.357]                   name <- added[[kk]]
[13:33:42.357]                   NAME <- NAMES[[kk]]
[13:33:42.357]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:42.357]                     next
[13:33:42.357]                   args[[name]] <- ""
[13:33:42.357]                 }
[13:33:42.357]                 NAMES <- toupper(removed)
[13:33:42.357]                 for (kk in seq_along(NAMES)) {
[13:33:42.357]                   name <- removed[[kk]]
[13:33:42.357]                   NAME <- NAMES[[kk]]
[13:33:42.357]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:42.357]                     next
[13:33:42.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:42.357]                 }
[13:33:42.357]                 if (length(args) > 0) 
[13:33:42.357]                   base::do.call(base::Sys.setenv, args = args)
[13:33:42.357]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:42.357]             }
[13:33:42.357]             else {
[13:33:42.357]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:42.357]             }
[13:33:42.357]             {
[13:33:42.357]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:42.357]                   0L) {
[13:33:42.357]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:42.357]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:42.357]                   base::options(opts)
[13:33:42.357]                 }
[13:33:42.357]                 {
[13:33:42.357]                   {
[13:33:42.357]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:42.357]                     NULL
[13:33:42.357]                   }
[13:33:42.357]                   options(future.plan = NULL)
[13:33:42.357]                   if (is.na(NA_character_)) 
[13:33:42.357]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:42.357]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:42.357]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:42.357]                     .init = FALSE)
[13:33:42.357]                 }
[13:33:42.357]             }
[13:33:42.357]         }
[13:33:42.357]     })
[13:33:42.357]     if (TRUE) {
[13:33:42.357]         base::sink(type = "output", split = FALSE)
[13:33:42.357]         if (TRUE) {
[13:33:42.357]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:42.357]         }
[13:33:42.357]         else {
[13:33:42.357]             ...future.result["stdout"] <- base::list(NULL)
[13:33:42.357]         }
[13:33:42.357]         base::close(...future.stdout)
[13:33:42.357]         ...future.stdout <- NULL
[13:33:42.357]     }
[13:33:42.357]     ...future.result$conditions <- ...future.conditions
[13:33:42.357]     ...future.result$finished <- base::Sys.time()
[13:33:42.357]     ...future.result
[13:33:42.357] }
[13:33:42.360] assign_globals() ...
[13:33:42.360] List of 5
[13:33:42.360]  $ ...future.FUN            :function (object, ...)  
[13:33:42.360]  $ future.call.arguments    : list()
[13:33:42.360]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:42.360]  $ ...future.elements_ii    :List of 2
[13:33:42.360]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:42.360]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:33:42.360]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:42.360]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:33:42.360]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:42.360]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:33:42.360]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:42.360]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:33:42.360]  $ ...future.seeds_ii       : NULL
[13:33:42.360]  $ ...future.globals.maxSize: NULL
[13:33:42.360]  - attr(*, "where")=List of 5
[13:33:42.360]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:42.360]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:42.360]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:42.360]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:42.360]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:42.360]  - attr(*, "resolved")= logi FALSE
[13:33:42.360]  - attr(*, "total_size")= num 1240
[13:33:42.360]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:42.360]  - attr(*, "already-done")= logi TRUE
[13:33:42.370] - copied ‘...future.FUN’ to environment
[13:33:42.370] - copied ‘future.call.arguments’ to environment
[13:33:42.370] - copied ‘...future.elements_ii’ to environment
[13:33:42.370] - copied ‘...future.seeds_ii’ to environment
[13:33:42.371] - copied ‘...future.globals.maxSize’ to environment
[13:33:42.371] assign_globals() ... done
[13:33:42.371] requestCore(): workers = 2
[13:33:42.373] MulticoreFuture started
[13:33:42.374] - Launch lazy future ... done
[13:33:42.374] run() for ‘MulticoreFuture’ ... done
[13:33:42.374] Created future:
[13:33:42.374] plan(): Setting new future strategy stack:
[13:33:42.375] List of future strategies:
[13:33:42.375] 1. sequential:
[13:33:42.375]    - args: function (..., envir = parent.frame())
[13:33:42.375]    - tweaked: FALSE
[13:33:42.375]    - call: NULL
[13:33:42.376] plan(): nbrOfWorkers() = 1
[13:33:42.380] plan(): Setting new future strategy stack:
[13:33:42.380] List of future strategies:
[13:33:42.380] 1. multicore:
[13:33:42.380]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:42.380]    - tweaked: FALSE
[13:33:42.380]    - call: plan(strategy)
[13:33:42.385] plan(): nbrOfWorkers() = 2
[13:33:42.374] MulticoreFuture:
[13:33:42.374] Label: ‘future_by-2’
[13:33:42.374] Expression:
[13:33:42.374] {
[13:33:42.374]     do.call(function(...) {
[13:33:42.374]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:42.374]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:42.374]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:42.374]             on.exit(options(oopts), add = TRUE)
[13:33:42.374]         }
[13:33:42.374]         {
[13:33:42.374]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:42.374]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:42.374]                 ...future.FUN(...future.X_jj, ...)
[13:33:42.374]             })
[13:33:42.374]         }
[13:33:42.374]     }, args = future.call.arguments)
[13:33:42.374] }
[13:33:42.374] Lazy evaluation: FALSE
[13:33:42.374] Asynchronous evaluation: TRUE
[13:33:42.374] Local evaluation: TRUE
[13:33:42.374] Environment: 0x55cb829419a0
[13:33:42.374] Capture standard output: TRUE
[13:33:42.374] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:42.374] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:42.374] Packages: <none>
[13:33:42.374] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:42.374] Resolved: TRUE
[13:33:42.374] Value: <not collected>
[13:33:42.374] Conditions captured: <none>
[13:33:42.374] Early signaling: FALSE
[13:33:42.374] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:42.374] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:42.386] Chunk #2 of 2 ... DONE
[13:33:42.386] Launching 2 futures (chunks) ... DONE
[13:33:42.386] Resolving 2 futures (chunks) ...
[13:33:42.386] resolve() on list ...
[13:33:42.386]  recursive: 0
[13:33:42.387]  length: 2
[13:33:42.387] 
[13:33:42.387] Future #1
[13:33:42.387] result() for MulticoreFuture ...
[13:33:42.388] result() for MulticoreFuture ...
[13:33:42.388] result() for MulticoreFuture ... done
[13:33:42.388] result() for MulticoreFuture ... done
[13:33:42.388] result() for MulticoreFuture ...
[13:33:42.389] result() for MulticoreFuture ... done
[13:33:42.389] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:33:42.389] - nx: 2
[13:33:42.389] - relay: TRUE
[13:33:42.389] - stdout: TRUE
[13:33:42.389] - signal: TRUE
[13:33:42.389] - resignal: FALSE
[13:33:42.389] - force: TRUE
[13:33:42.390] - relayed: [n=2] FALSE, FALSE
[13:33:42.390] - queued futures: [n=2] FALSE, FALSE
[13:33:42.390]  - until=1
[13:33:42.390]  - relaying element #1
[13:33:42.390] result() for MulticoreFuture ...
[13:33:42.390] result() for MulticoreFuture ... done
[13:33:42.390] result() for MulticoreFuture ...
[13:33:42.391] result() for MulticoreFuture ... done
[13:33:42.391] result() for MulticoreFuture ...
[13:33:42.391] result() for MulticoreFuture ... done
[13:33:42.391] result() for MulticoreFuture ...
[13:33:42.391] result() for MulticoreFuture ... done
[13:33:42.391] - relayed: [n=2] TRUE, FALSE
[13:33:42.391] - queued futures: [n=2] TRUE, FALSE
[13:33:42.391] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:33:42.392]  length: 1 (resolved future 1)
[13:33:42.392] Future #2
[13:33:42.392] result() for MulticoreFuture ...
[13:33:42.393] result() for MulticoreFuture ...
[13:33:42.393] result() for MulticoreFuture ... done
[13:33:42.393] result() for MulticoreFuture ... done
[13:33:42.393] result() for MulticoreFuture ...
[13:33:42.393] result() for MulticoreFuture ... done
[13:33:42.393] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:33:42.393] - nx: 2
[13:33:42.394] - relay: TRUE
[13:33:42.394] - stdout: TRUE
[13:33:42.394] - signal: TRUE
[13:33:42.394] - resignal: FALSE
[13:33:42.394] - force: TRUE
[13:33:42.394] - relayed: [n=2] TRUE, FALSE
[13:33:42.394] - queued futures: [n=2] TRUE, FALSE
[13:33:42.394]  - until=2
[13:33:42.395]  - relaying element #2
[13:33:42.395] result() for MulticoreFuture ...
[13:33:42.395] result() for MulticoreFuture ... done
[13:33:42.395] result() for MulticoreFuture ...
[13:33:42.395] result() for MulticoreFuture ... done
[13:33:42.395] result() for MulticoreFuture ...
[13:33:42.395] result() for MulticoreFuture ... done
[13:33:42.395] result() for MulticoreFuture ...
[13:33:42.396] result() for MulticoreFuture ... done
[13:33:42.396] - relayed: [n=2] TRUE, TRUE
[13:33:42.396] - queued futures: [n=2] TRUE, TRUE
[13:33:42.396] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:33:42.396]  length: 0 (resolved future 2)
[13:33:42.396] Relaying remaining futures
[13:33:42.396] signalConditionsASAP(NULL, pos=0) ...
[13:33:42.396] - nx: 2
[13:33:42.397] - relay: TRUE
[13:33:42.397] - stdout: TRUE
[13:33:42.397] - signal: TRUE
[13:33:42.397] - resignal: FALSE
[13:33:42.397] - force: TRUE
[13:33:42.397] - relayed: [n=2] TRUE, TRUE
[13:33:42.397] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:42.397] - relayed: [n=2] TRUE, TRUE
[13:33:42.397] - queued futures: [n=2] TRUE, TRUE
[13:33:42.398] signalConditionsASAP(NULL, pos=0) ... done
[13:33:42.398] resolve() on list ... DONE
[13:33:42.398] result() for MulticoreFuture ...
[13:33:42.398] result() for MulticoreFuture ... done
[13:33:42.398] result() for MulticoreFuture ...
[13:33:42.398] result() for MulticoreFuture ... done
[13:33:42.398] result() for MulticoreFuture ...
[13:33:42.398] result() for MulticoreFuture ... done
[13:33:42.399] result() for MulticoreFuture ...
[13:33:42.399] result() for MulticoreFuture ... done
[13:33:42.399]  - Number of value chunks collected: 2
[13:33:42.399] Resolving 2 futures (chunks) ... DONE
[13:33:42.399] Reducing values from 2 chunks ...
[13:33:42.399]  - Number of values collected after concatenation: 3
[13:33:42.399]  - Number of values expected: 3
[13:33:42.399] Reducing values from 2 chunks ... DONE
[13:33:42.400] future_lapply() ... DONE
[13:33:42.400] future_by_internal() ... DONE
[13:33:42.401] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[13:33:42.402] future_lapply() ...
[13:33:42.406] Number of chunks: 2
[13:33:42.407] getGlobalsAndPackagesXApply() ...
[13:33:42.407]  - future.globals: TRUE
[13:33:42.407] getGlobalsAndPackages() ...
[13:33:42.407] Searching for globals...
[13:33:42.408] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:42.409] Searching for globals ... DONE
[13:33:42.409] Resolving globals: FALSE
[13:33:42.409] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:42.410] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:42.410] - globals: [1] ‘FUN’
[13:33:42.410] 
[13:33:42.410] getGlobalsAndPackages() ... DONE
[13:33:42.410]  - globals found/used: [n=1] ‘FUN’
[13:33:42.410]  - needed namespaces: [n=0] 
[13:33:42.410] Finding globals ... DONE
[13:33:42.411]  - use_args: TRUE
[13:33:42.411]  - Getting '...' globals ...
[13:33:42.411] resolve() on list ...
[13:33:42.411]  recursive: 0
[13:33:42.411]  length: 1
[13:33:42.411]  elements: ‘...’
[13:33:42.412]  length: 0 (resolved future 1)
[13:33:42.412] resolve() on list ... DONE
[13:33:42.412]    - '...' content: [n=0] 
[13:33:42.412] List of 1
[13:33:42.412]  $ ...: list()
[13:33:42.412]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:42.412]  - attr(*, "where")=List of 1
[13:33:42.412]   ..$ ...:<environment: 0x55cb8428efc8> 
[13:33:42.412]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:42.412]  - attr(*, "resolved")= logi TRUE
[13:33:42.412]  - attr(*, "total_size")= num NA
[13:33:42.415]  - Getting '...' globals ... DONE
[13:33:42.415] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:42.416] List of 2
[13:33:42.416]  $ ...future.FUN:function (object, ...)  
[13:33:42.416]  $ ...          : list()
[13:33:42.416]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:42.416]  - attr(*, "where")=List of 2
[13:33:42.416]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:42.416]   ..$ ...          :<environment: 0x55cb8428efc8> 
[13:33:42.416]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:42.416]  - attr(*, "resolved")= logi FALSE
[13:33:42.416]  - attr(*, "total_size")= num 1240
[13:33:42.419] Packages to be attached in all futures: [n=0] 
[13:33:42.419] getGlobalsAndPackagesXApply() ... DONE
[13:33:42.419] Number of futures (= number of chunks): 2
[13:33:42.420] Launching 2 futures (chunks) ...
[13:33:42.420] Chunk #1 of 2 ...
[13:33:42.420]  - Finding globals in 'X' for chunk #1 ...
[13:33:42.420] getGlobalsAndPackages() ...
[13:33:42.420] Searching for globals...
[13:33:42.420] 
[13:33:42.423] Searching for globals ... DONE
[13:33:42.423] - globals: [0] <none>
[13:33:42.424] getGlobalsAndPackages() ... DONE
[13:33:42.424]    + additional globals found: [n=0] 
[13:33:42.424]    + additional namespaces needed: [n=0] 
[13:33:42.424]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:42.424]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:42.424]  - seeds: <none>
[13:33:42.424]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:42.424] getGlobalsAndPackages() ...
[13:33:42.424] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:42.425] Resolving globals: FALSE
[13:33:42.425] Tweak future expression to call with '...' arguments ...
[13:33:42.425] {
[13:33:42.425]     do.call(function(...) {
[13:33:42.425]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:42.425]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:42.425]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:42.425]             on.exit(options(oopts), add = TRUE)
[13:33:42.425]         }
[13:33:42.425]         {
[13:33:42.425]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:42.425]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:42.425]                 ...future.FUN(...future.X_jj, ...)
[13:33:42.425]             })
[13:33:42.425]         }
[13:33:42.425]     }, args = future.call.arguments)
[13:33:42.425] }
[13:33:42.425] Tweak future expression to call with '...' arguments ... DONE
[13:33:42.425] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:42.426] 
[13:33:42.426] getGlobalsAndPackages() ... DONE
[13:33:42.426] run() for ‘Future’ ...
[13:33:42.426] - state: ‘created’
[13:33:42.426] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:42.430] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:42.430] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:42.430]   - Field: ‘label’
[13:33:42.430]   - Field: ‘local’
[13:33:42.430]   - Field: ‘owner’
[13:33:42.431]   - Field: ‘envir’
[13:33:42.431]   - Field: ‘workers’
[13:33:42.431]   - Field: ‘packages’
[13:33:42.431]   - Field: ‘gc’
[13:33:42.431]   - Field: ‘job’
[13:33:42.431]   - Field: ‘conditions’
[13:33:42.431]   - Field: ‘expr’
[13:33:42.431]   - Field: ‘uuid’
[13:33:42.431]   - Field: ‘seed’
[13:33:42.431]   - Field: ‘version’
[13:33:42.432]   - Field: ‘result’
[13:33:42.432]   - Field: ‘asynchronous’
[13:33:42.432]   - Field: ‘calls’
[13:33:42.432]   - Field: ‘globals’
[13:33:42.432]   - Field: ‘stdout’
[13:33:42.432]   - Field: ‘earlySignal’
[13:33:42.432]   - Field: ‘lazy’
[13:33:42.432]   - Field: ‘state’
[13:33:42.432] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:42.432] - Launch lazy future ...
[13:33:42.433] Packages needed by the future expression (n = 0): <none>
[13:33:42.433] Packages needed by future strategies (n = 0): <none>
[13:33:42.433] {
[13:33:42.433]     {
[13:33:42.433]         {
[13:33:42.433]             ...future.startTime <- base::Sys.time()
[13:33:42.433]             {
[13:33:42.433]                 {
[13:33:42.433]                   {
[13:33:42.433]                     {
[13:33:42.433]                       base::local({
[13:33:42.433]                         has_future <- base::requireNamespace("future", 
[13:33:42.433]                           quietly = TRUE)
[13:33:42.433]                         if (has_future) {
[13:33:42.433]                           ns <- base::getNamespace("future")
[13:33:42.433]                           version <- ns[[".package"]][["version"]]
[13:33:42.433]                           if (is.null(version)) 
[13:33:42.433]                             version <- utils::packageVersion("future")
[13:33:42.433]                         }
[13:33:42.433]                         else {
[13:33:42.433]                           version <- NULL
[13:33:42.433]                         }
[13:33:42.433]                         if (!has_future || version < "1.8.0") {
[13:33:42.433]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:42.433]                             "", base::R.version$version.string), 
[13:33:42.433]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:42.433]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:42.433]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:42.433]                               "release", "version")], collapse = " "), 
[13:33:42.433]                             hostname = base::Sys.info()[["nodename"]])
[13:33:42.433]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:42.433]                             info)
[13:33:42.433]                           info <- base::paste(info, collapse = "; ")
[13:33:42.433]                           if (!has_future) {
[13:33:42.433]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:42.433]                               info)
[13:33:42.433]                           }
[13:33:42.433]                           else {
[13:33:42.433]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:42.433]                               info, version)
[13:33:42.433]                           }
[13:33:42.433]                           base::stop(msg)
[13:33:42.433]                         }
[13:33:42.433]                       })
[13:33:42.433]                     }
[13:33:42.433]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:42.433]                     base::options(mc.cores = 1L)
[13:33:42.433]                   }
[13:33:42.433]                   ...future.strategy.old <- future::plan("list")
[13:33:42.433]                   options(future.plan = NULL)
[13:33:42.433]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:42.433]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:42.433]                 }
[13:33:42.433]                 ...future.workdir <- getwd()
[13:33:42.433]             }
[13:33:42.433]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:42.433]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:42.433]         }
[13:33:42.433]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:42.433]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:42.433]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:42.433]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:42.433]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:42.433]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:42.433]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:42.433]             base::names(...future.oldOptions))
[13:33:42.433]     }
[13:33:42.433]     if (FALSE) {
[13:33:42.433]     }
[13:33:42.433]     else {
[13:33:42.433]         if (TRUE) {
[13:33:42.433]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:42.433]                 open = "w")
[13:33:42.433]         }
[13:33:42.433]         else {
[13:33:42.433]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:42.433]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:42.433]         }
[13:33:42.433]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:42.433]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:42.433]             base::sink(type = "output", split = FALSE)
[13:33:42.433]             base::close(...future.stdout)
[13:33:42.433]         }, add = TRUE)
[13:33:42.433]     }
[13:33:42.433]     ...future.frame <- base::sys.nframe()
[13:33:42.433]     ...future.conditions <- base::list()
[13:33:42.433]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:42.433]     if (FALSE) {
[13:33:42.433]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:42.433]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:42.433]     }
[13:33:42.433]     ...future.result <- base::tryCatch({
[13:33:42.433]         base::withCallingHandlers({
[13:33:42.433]             ...future.value <- base::withVisible(base::local({
[13:33:42.433]                 withCallingHandlers({
[13:33:42.433]                   {
[13:33:42.433]                     do.call(function(...) {
[13:33:42.433]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:42.433]                       if (!identical(...future.globals.maxSize.org, 
[13:33:42.433]                         ...future.globals.maxSize)) {
[13:33:42.433]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:42.433]                         on.exit(options(oopts), add = TRUE)
[13:33:42.433]                       }
[13:33:42.433]                       {
[13:33:42.433]                         lapply(seq_along(...future.elements_ii), 
[13:33:42.433]                           FUN = function(jj) {
[13:33:42.433]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:42.433]                             ...future.FUN(...future.X_jj, ...)
[13:33:42.433]                           })
[13:33:42.433]                       }
[13:33:42.433]                     }, args = future.call.arguments)
[13:33:42.433]                   }
[13:33:42.433]                 }, immediateCondition = function(cond) {
[13:33:42.433]                   save_rds <- function (object, pathname, ...) 
[13:33:42.433]                   {
[13:33:42.433]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:42.433]                     if (file_test("-f", pathname_tmp)) {
[13:33:42.433]                       fi_tmp <- file.info(pathname_tmp)
[13:33:42.433]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:42.433]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:42.433]                         fi_tmp[["mtime"]])
[13:33:42.433]                     }
[13:33:42.433]                     tryCatch({
[13:33:42.433]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:42.433]                     }, error = function(ex) {
[13:33:42.433]                       msg <- conditionMessage(ex)
[13:33:42.433]                       fi_tmp <- file.info(pathname_tmp)
[13:33:42.433]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:42.433]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:42.433]                         fi_tmp[["mtime"]], msg)
[13:33:42.433]                       ex$message <- msg
[13:33:42.433]                       stop(ex)
[13:33:42.433]                     })
[13:33:42.433]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:42.433]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:42.433]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:42.433]                       fi_tmp <- file.info(pathname_tmp)
[13:33:42.433]                       fi <- file.info(pathname)
[13:33:42.433]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:42.433]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:42.433]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:42.433]                         fi[["size"]], fi[["mtime"]])
[13:33:42.433]                       stop(msg)
[13:33:42.433]                     }
[13:33:42.433]                     invisible(pathname)
[13:33:42.433]                   }
[13:33:42.433]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:42.433]                     rootPath = tempdir()) 
[13:33:42.433]                   {
[13:33:42.433]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:42.433]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:42.433]                       tmpdir = path, fileext = ".rds")
[13:33:42.433]                     save_rds(obj, file)
[13:33:42.433]                   }
[13:33:42.433]                   saveImmediateCondition(cond, path = "/tmp/RtmpMLLN1L/.future/immediateConditions")
[13:33:42.433]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:42.433]                   {
[13:33:42.433]                     inherits <- base::inherits
[13:33:42.433]                     invokeRestart <- base::invokeRestart
[13:33:42.433]                     is.null <- base::is.null
[13:33:42.433]                     muffled <- FALSE
[13:33:42.433]                     if (inherits(cond, "message")) {
[13:33:42.433]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:42.433]                       if (muffled) 
[13:33:42.433]                         invokeRestart("muffleMessage")
[13:33:42.433]                     }
[13:33:42.433]                     else if (inherits(cond, "warning")) {
[13:33:42.433]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:42.433]                       if (muffled) 
[13:33:42.433]                         invokeRestart("muffleWarning")
[13:33:42.433]                     }
[13:33:42.433]                     else if (inherits(cond, "condition")) {
[13:33:42.433]                       if (!is.null(pattern)) {
[13:33:42.433]                         computeRestarts <- base::computeRestarts
[13:33:42.433]                         grepl <- base::grepl
[13:33:42.433]                         restarts <- computeRestarts(cond)
[13:33:42.433]                         for (restart in restarts) {
[13:33:42.433]                           name <- restart$name
[13:33:42.433]                           if (is.null(name)) 
[13:33:42.433]                             next
[13:33:42.433]                           if (!grepl(pattern, name)) 
[13:33:42.433]                             next
[13:33:42.433]                           invokeRestart(restart)
[13:33:42.433]                           muffled <- TRUE
[13:33:42.433]                           break
[13:33:42.433]                         }
[13:33:42.433]                       }
[13:33:42.433]                     }
[13:33:42.433]                     invisible(muffled)
[13:33:42.433]                   }
[13:33:42.433]                   muffleCondition(cond)
[13:33:42.433]                 })
[13:33:42.433]             }))
[13:33:42.433]             future::FutureResult(value = ...future.value$value, 
[13:33:42.433]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:42.433]                   ...future.rng), globalenv = if (FALSE) 
[13:33:42.433]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:42.433]                     ...future.globalenv.names))
[13:33:42.433]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:42.433]         }, condition = base::local({
[13:33:42.433]             c <- base::c
[13:33:42.433]             inherits <- base::inherits
[13:33:42.433]             invokeRestart <- base::invokeRestart
[13:33:42.433]             length <- base::length
[13:33:42.433]             list <- base::list
[13:33:42.433]             seq.int <- base::seq.int
[13:33:42.433]             signalCondition <- base::signalCondition
[13:33:42.433]             sys.calls <- base::sys.calls
[13:33:42.433]             `[[` <- base::`[[`
[13:33:42.433]             `+` <- base::`+`
[13:33:42.433]             `<<-` <- base::`<<-`
[13:33:42.433]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:42.433]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:42.433]                   3L)]
[13:33:42.433]             }
[13:33:42.433]             function(cond) {
[13:33:42.433]                 is_error <- inherits(cond, "error")
[13:33:42.433]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:42.433]                   NULL)
[13:33:42.433]                 if (is_error) {
[13:33:42.433]                   sessionInformation <- function() {
[13:33:42.433]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:42.433]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:42.433]                       search = base::search(), system = base::Sys.info())
[13:33:42.433]                   }
[13:33:42.433]                   ...future.conditions[[length(...future.conditions) + 
[13:33:42.433]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:42.433]                     cond$call), session = sessionInformation(), 
[13:33:42.433]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:42.433]                   signalCondition(cond)
[13:33:42.433]                 }
[13:33:42.433]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:42.433]                 "immediateCondition"))) {
[13:33:42.433]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:42.433]                   ...future.conditions[[length(...future.conditions) + 
[13:33:42.433]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:42.433]                   if (TRUE && !signal) {
[13:33:42.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:42.433]                     {
[13:33:42.433]                       inherits <- base::inherits
[13:33:42.433]                       invokeRestart <- base::invokeRestart
[13:33:42.433]                       is.null <- base::is.null
[13:33:42.433]                       muffled <- FALSE
[13:33:42.433]                       if (inherits(cond, "message")) {
[13:33:42.433]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:42.433]                         if (muffled) 
[13:33:42.433]                           invokeRestart("muffleMessage")
[13:33:42.433]                       }
[13:33:42.433]                       else if (inherits(cond, "warning")) {
[13:33:42.433]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:42.433]                         if (muffled) 
[13:33:42.433]                           invokeRestart("muffleWarning")
[13:33:42.433]                       }
[13:33:42.433]                       else if (inherits(cond, "condition")) {
[13:33:42.433]                         if (!is.null(pattern)) {
[13:33:42.433]                           computeRestarts <- base::computeRestarts
[13:33:42.433]                           grepl <- base::grepl
[13:33:42.433]                           restarts <- computeRestarts(cond)
[13:33:42.433]                           for (restart in restarts) {
[13:33:42.433]                             name <- restart$name
[13:33:42.433]                             if (is.null(name)) 
[13:33:42.433]                               next
[13:33:42.433]                             if (!grepl(pattern, name)) 
[13:33:42.433]                               next
[13:33:42.433]                             invokeRestart(restart)
[13:33:42.433]                             muffled <- TRUE
[13:33:42.433]                             break
[13:33:42.433]                           }
[13:33:42.433]                         }
[13:33:42.433]                       }
[13:33:42.433]                       invisible(muffled)
[13:33:42.433]                     }
[13:33:42.433]                     muffleCondition(cond, pattern = "^muffle")
[13:33:42.433]                   }
[13:33:42.433]                 }
[13:33:42.433]                 else {
[13:33:42.433]                   if (TRUE) {
[13:33:42.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:42.433]                     {
[13:33:42.433]                       inherits <- base::inherits
[13:33:42.433]                       invokeRestart <- base::invokeRestart
[13:33:42.433]                       is.null <- base::is.null
[13:33:42.433]                       muffled <- FALSE
[13:33:42.433]                       if (inherits(cond, "message")) {
[13:33:42.433]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:42.433]                         if (muffled) 
[13:33:42.433]                           invokeRestart("muffleMessage")
[13:33:42.433]                       }
[13:33:42.433]                       else if (inherits(cond, "warning")) {
[13:33:42.433]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:42.433]                         if (muffled) 
[13:33:42.433]                           invokeRestart("muffleWarning")
[13:33:42.433]                       }
[13:33:42.433]                       else if (inherits(cond, "condition")) {
[13:33:42.433]                         if (!is.null(pattern)) {
[13:33:42.433]                           computeRestarts <- base::computeRestarts
[13:33:42.433]                           grepl <- base::grepl
[13:33:42.433]                           restarts <- computeRestarts(cond)
[13:33:42.433]                           for (restart in restarts) {
[13:33:42.433]                             name <- restart$name
[13:33:42.433]                             if (is.null(name)) 
[13:33:42.433]                               next
[13:33:42.433]                             if (!grepl(pattern, name)) 
[13:33:42.433]                               next
[13:33:42.433]                             invokeRestart(restart)
[13:33:42.433]                             muffled <- TRUE
[13:33:42.433]                             break
[13:33:42.433]                           }
[13:33:42.433]                         }
[13:33:42.433]                       }
[13:33:42.433]                       invisible(muffled)
[13:33:42.433]                     }
[13:33:42.433]                     muffleCondition(cond, pattern = "^muffle")
[13:33:42.433]                   }
[13:33:42.433]                 }
[13:33:42.433]             }
[13:33:42.433]         }))
[13:33:42.433]     }, error = function(ex) {
[13:33:42.433]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:42.433]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:42.433]                 ...future.rng), started = ...future.startTime, 
[13:33:42.433]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:42.433]             version = "1.8"), class = "FutureResult")
[13:33:42.433]     }, finally = {
[13:33:42.433]         if (!identical(...future.workdir, getwd())) 
[13:33:42.433]             setwd(...future.workdir)
[13:33:42.433]         {
[13:33:42.433]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:42.433]                 ...future.oldOptions$nwarnings <- NULL
[13:33:42.433]             }
[13:33:42.433]             base::options(...future.oldOptions)
[13:33:42.433]             if (.Platform$OS.type == "windows") {
[13:33:42.433]                 old_names <- names(...future.oldEnvVars)
[13:33:42.433]                 envs <- base::Sys.getenv()
[13:33:42.433]                 names <- names(envs)
[13:33:42.433]                 common <- intersect(names, old_names)
[13:33:42.433]                 added <- setdiff(names, old_names)
[13:33:42.433]                 removed <- setdiff(old_names, names)
[13:33:42.433]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:42.433]                   envs[common]]
[13:33:42.433]                 NAMES <- toupper(changed)
[13:33:42.433]                 args <- list()
[13:33:42.433]                 for (kk in seq_along(NAMES)) {
[13:33:42.433]                   name <- changed[[kk]]
[13:33:42.433]                   NAME <- NAMES[[kk]]
[13:33:42.433]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:42.433]                     next
[13:33:42.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:42.433]                 }
[13:33:42.433]                 NAMES <- toupper(added)
[13:33:42.433]                 for (kk in seq_along(NAMES)) {
[13:33:42.433]                   name <- added[[kk]]
[13:33:42.433]                   NAME <- NAMES[[kk]]
[13:33:42.433]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:42.433]                     next
[13:33:42.433]                   args[[name]] <- ""
[13:33:42.433]                 }
[13:33:42.433]                 NAMES <- toupper(removed)
[13:33:42.433]                 for (kk in seq_along(NAMES)) {
[13:33:42.433]                   name <- removed[[kk]]
[13:33:42.433]                   NAME <- NAMES[[kk]]
[13:33:42.433]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:42.433]                     next
[13:33:42.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:42.433]                 }
[13:33:42.433]                 if (length(args) > 0) 
[13:33:42.433]                   base::do.call(base::Sys.setenv, args = args)
[13:33:42.433]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:42.433]             }
[13:33:42.433]             else {
[13:33:42.433]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:42.433]             }
[13:33:42.433]             {
[13:33:42.433]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:42.433]                   0L) {
[13:33:42.433]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:42.433]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:42.433]                   base::options(opts)
[13:33:42.433]                 }
[13:33:42.433]                 {
[13:33:42.433]                   {
[13:33:42.433]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:42.433]                     NULL
[13:33:42.433]                   }
[13:33:42.433]                   options(future.plan = NULL)
[13:33:42.433]                   if (is.na(NA_character_)) 
[13:33:42.433]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:42.433]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:42.433]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:42.433]                     .init = FALSE)
[13:33:42.433]                 }
[13:33:42.433]             }
[13:33:42.433]         }
[13:33:42.433]     })
[13:33:42.433]     if (TRUE) {
[13:33:42.433]         base::sink(type = "output", split = FALSE)
[13:33:42.433]         if (TRUE) {
[13:33:42.433]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:42.433]         }
[13:33:42.433]         else {
[13:33:42.433]             ...future.result["stdout"] <- base::list(NULL)
[13:33:42.433]         }
[13:33:42.433]         base::close(...future.stdout)
[13:33:42.433]         ...future.stdout <- NULL
[13:33:42.433]     }
[13:33:42.433]     ...future.result$conditions <- ...future.conditions
[13:33:42.433]     ...future.result$finished <- base::Sys.time()
[13:33:42.433]     ...future.result
[13:33:42.433] }
[13:33:42.436] assign_globals() ...
[13:33:42.436] List of 5
[13:33:42.436]  $ ...future.FUN            :function (object, ...)  
[13:33:42.436]  $ future.call.arguments    : list()
[13:33:42.436]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:42.436]  $ ...future.elements_ii    :List of 1
[13:33:42.436]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:42.436]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[13:33:42.436]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:42.436]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:42.436]  $ ...future.seeds_ii       : NULL
[13:33:42.436]  $ ...future.globals.maxSize: NULL
[13:33:42.436]  - attr(*, "where")=List of 5
[13:33:42.436]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:42.436]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:42.436]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:42.436]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:42.436]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:42.436]  - attr(*, "resolved")= logi FALSE
[13:33:42.436]  - attr(*, "total_size")= num 1240
[13:33:42.436]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:42.436]  - attr(*, "already-done")= logi TRUE
[13:33:42.442] - copied ‘...future.FUN’ to environment
[13:33:42.442] - copied ‘future.call.arguments’ to environment
[13:33:42.442] - copied ‘...future.elements_ii’ to environment
[13:33:42.443] - copied ‘...future.seeds_ii’ to environment
[13:33:42.443] - copied ‘...future.globals.maxSize’ to environment
[13:33:42.443] assign_globals() ... done
[13:33:42.443] requestCore(): workers = 2
[13:33:42.445] MulticoreFuture started
[13:33:42.445] - Launch lazy future ... done
[13:33:42.446] run() for ‘MulticoreFuture’ ... done
[13:33:42.446] Created future:
[13:33:42.446] plan(): Setting new future strategy stack:
[13:33:42.447] List of future strategies:
[13:33:42.447] 1. sequential:
[13:33:42.447]    - args: function (..., envir = parent.frame())
[13:33:42.447]    - tweaked: FALSE
[13:33:42.447]    - call: NULL
[13:33:42.447] plan(): nbrOfWorkers() = 1
[13:33:42.451] plan(): Setting new future strategy stack:
[13:33:42.451] List of future strategies:
[13:33:42.451] 1. multicore:
[13:33:42.451]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:42.451]    - tweaked: FALSE
[13:33:42.451]    - call: plan(strategy)
[13:33:42.456] plan(): nbrOfWorkers() = 2
[13:33:42.446] MulticoreFuture:
[13:33:42.446] Label: ‘future_by-1’
[13:33:42.446] Expression:
[13:33:42.446] {
[13:33:42.446]     do.call(function(...) {
[13:33:42.446]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:42.446]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:42.446]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:42.446]             on.exit(options(oopts), add = TRUE)
[13:33:42.446]         }
[13:33:42.446]         {
[13:33:42.446]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:42.446]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:42.446]                 ...future.FUN(...future.X_jj, ...)
[13:33:42.446]             })
[13:33:42.446]         }
[13:33:42.446]     }, args = future.call.arguments)
[13:33:42.446] }
[13:33:42.446] Lazy evaluation: FALSE
[13:33:42.446] Asynchronous evaluation: TRUE
[13:33:42.446] Local evaluation: TRUE
[13:33:42.446] Environment: 0x55cb84261d80
[13:33:42.446] Capture standard output: TRUE
[13:33:42.446] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:42.446] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:42.446] Packages: <none>
[13:33:42.446] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:42.446] Resolved: TRUE
[13:33:42.446] Value: <not collected>
[13:33:42.446] Conditions captured: <none>
[13:33:42.446] Early signaling: FALSE
[13:33:42.446] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:42.446] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:42.457] Chunk #1 of 2 ... DONE
[13:33:42.457] Chunk #2 of 2 ...
[13:33:42.457]  - Finding globals in 'X' for chunk #2 ...
[13:33:42.458] getGlobalsAndPackages() ...
[13:33:42.458] Searching for globals...
[13:33:42.458] 
[13:33:42.458] Searching for globals ... DONE
[13:33:42.459] - globals: [0] <none>
[13:33:42.459] getGlobalsAndPackages() ... DONE
[13:33:42.459]    + additional globals found: [n=0] 
[13:33:42.459]    + additional namespaces needed: [n=0] 
[13:33:42.459]  - Finding globals in 'X' for chunk #2 ... DONE
[13:33:42.459]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:42.459]  - seeds: <none>
[13:33:42.460]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:42.460] getGlobalsAndPackages() ...
[13:33:42.460] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:42.460] Resolving globals: FALSE
[13:33:42.460] Tweak future expression to call with '...' arguments ...
[13:33:42.460] {
[13:33:42.460]     do.call(function(...) {
[13:33:42.460]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:42.460]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:42.460]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:42.460]             on.exit(options(oopts), add = TRUE)
[13:33:42.460]         }
[13:33:42.460]         {
[13:33:42.460]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:42.460]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:42.460]                 ...future.FUN(...future.X_jj, ...)
[13:33:42.460]             })
[13:33:42.460]         }
[13:33:42.460]     }, args = future.call.arguments)
[13:33:42.460] }
[13:33:42.461] Tweak future expression to call with '...' arguments ... DONE
[13:33:42.462] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:42.462] 
[13:33:42.462] getGlobalsAndPackages() ... DONE
[13:33:42.462] run() for ‘Future’ ...
[13:33:42.463] - state: ‘created’
[13:33:42.463] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:42.468] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:42.469] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:42.469]   - Field: ‘label’
[13:33:42.469]   - Field: ‘local’
[13:33:42.469]   - Field: ‘owner’
[13:33:42.469]   - Field: ‘envir’
[13:33:42.469]   - Field: ‘workers’
[13:33:42.470]   - Field: ‘packages’
[13:33:42.470]   - Field: ‘gc’
[13:33:42.470]   - Field: ‘job’
[13:33:42.470]   - Field: ‘conditions’
[13:33:42.470]   - Field: ‘expr’
[13:33:42.470]   - Field: ‘uuid’
[13:33:42.470]   - Field: ‘seed’
[13:33:42.471]   - Field: ‘version’
[13:33:42.471]   - Field: ‘result’
[13:33:42.471]   - Field: ‘asynchronous’
[13:33:42.471]   - Field: ‘calls’
[13:33:42.471]   - Field: ‘globals’
[13:33:42.471]   - Field: ‘stdout’
[13:33:42.472]   - Field: ‘earlySignal’
[13:33:42.472]   - Field: ‘lazy’
[13:33:42.472]   - Field: ‘state’
[13:33:42.472] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:42.472] - Launch lazy future ...
[13:33:42.473] Packages needed by the future expression (n = 0): <none>
[13:33:42.473] Packages needed by future strategies (n = 0): <none>
[13:33:42.474] {
[13:33:42.474]     {
[13:33:42.474]         {
[13:33:42.474]             ...future.startTime <- base::Sys.time()
[13:33:42.474]             {
[13:33:42.474]                 {
[13:33:42.474]                   {
[13:33:42.474]                     {
[13:33:42.474]                       base::local({
[13:33:42.474]                         has_future <- base::requireNamespace("future", 
[13:33:42.474]                           quietly = TRUE)
[13:33:42.474]                         if (has_future) {
[13:33:42.474]                           ns <- base::getNamespace("future")
[13:33:42.474]                           version <- ns[[".package"]][["version"]]
[13:33:42.474]                           if (is.null(version)) 
[13:33:42.474]                             version <- utils::packageVersion("future")
[13:33:42.474]                         }
[13:33:42.474]                         else {
[13:33:42.474]                           version <- NULL
[13:33:42.474]                         }
[13:33:42.474]                         if (!has_future || version < "1.8.0") {
[13:33:42.474]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:42.474]                             "", base::R.version$version.string), 
[13:33:42.474]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:42.474]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:42.474]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:42.474]                               "release", "version")], collapse = " "), 
[13:33:42.474]                             hostname = base::Sys.info()[["nodename"]])
[13:33:42.474]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:42.474]                             info)
[13:33:42.474]                           info <- base::paste(info, collapse = "; ")
[13:33:42.474]                           if (!has_future) {
[13:33:42.474]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:42.474]                               info)
[13:33:42.474]                           }
[13:33:42.474]                           else {
[13:33:42.474]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:42.474]                               info, version)
[13:33:42.474]                           }
[13:33:42.474]                           base::stop(msg)
[13:33:42.474]                         }
[13:33:42.474]                       })
[13:33:42.474]                     }
[13:33:42.474]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:42.474]                     base::options(mc.cores = 1L)
[13:33:42.474]                   }
[13:33:42.474]                   ...future.strategy.old <- future::plan("list")
[13:33:42.474]                   options(future.plan = NULL)
[13:33:42.474]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:42.474]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:42.474]                 }
[13:33:42.474]                 ...future.workdir <- getwd()
[13:33:42.474]             }
[13:33:42.474]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:42.474]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:42.474]         }
[13:33:42.474]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:42.474]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:42.474]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:42.474]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:42.474]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:42.474]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:42.474]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:42.474]             base::names(...future.oldOptions))
[13:33:42.474]     }
[13:33:42.474]     if (FALSE) {
[13:33:42.474]     }
[13:33:42.474]     else {
[13:33:42.474]         if (TRUE) {
[13:33:42.474]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:42.474]                 open = "w")
[13:33:42.474]         }
[13:33:42.474]         else {
[13:33:42.474]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:42.474]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:42.474]         }
[13:33:42.474]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:42.474]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:42.474]             base::sink(type = "output", split = FALSE)
[13:33:42.474]             base::close(...future.stdout)
[13:33:42.474]         }, add = TRUE)
[13:33:42.474]     }
[13:33:42.474]     ...future.frame <- base::sys.nframe()
[13:33:42.474]     ...future.conditions <- base::list()
[13:33:42.474]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:42.474]     if (FALSE) {
[13:33:42.474]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:42.474]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:42.474]     }
[13:33:42.474]     ...future.result <- base::tryCatch({
[13:33:42.474]         base::withCallingHandlers({
[13:33:42.474]             ...future.value <- base::withVisible(base::local({
[13:33:42.474]                 withCallingHandlers({
[13:33:42.474]                   {
[13:33:42.474]                     do.call(function(...) {
[13:33:42.474]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:42.474]                       if (!identical(...future.globals.maxSize.org, 
[13:33:42.474]                         ...future.globals.maxSize)) {
[13:33:42.474]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:42.474]                         on.exit(options(oopts), add = TRUE)
[13:33:42.474]                       }
[13:33:42.474]                       {
[13:33:42.474]                         lapply(seq_along(...future.elements_ii), 
[13:33:42.474]                           FUN = function(jj) {
[13:33:42.474]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:42.474]                             ...future.FUN(...future.X_jj, ...)
[13:33:42.474]                           })
[13:33:42.474]                       }
[13:33:42.474]                     }, args = future.call.arguments)
[13:33:42.474]                   }
[13:33:42.474]                 }, immediateCondition = function(cond) {
[13:33:42.474]                   save_rds <- function (object, pathname, ...) 
[13:33:42.474]                   {
[13:33:42.474]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:42.474]                     if (file_test("-f", pathname_tmp)) {
[13:33:42.474]                       fi_tmp <- file.info(pathname_tmp)
[13:33:42.474]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:42.474]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:42.474]                         fi_tmp[["mtime"]])
[13:33:42.474]                     }
[13:33:42.474]                     tryCatch({
[13:33:42.474]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:42.474]                     }, error = function(ex) {
[13:33:42.474]                       msg <- conditionMessage(ex)
[13:33:42.474]                       fi_tmp <- file.info(pathname_tmp)
[13:33:42.474]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:42.474]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:42.474]                         fi_tmp[["mtime"]], msg)
[13:33:42.474]                       ex$message <- msg
[13:33:42.474]                       stop(ex)
[13:33:42.474]                     })
[13:33:42.474]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:42.474]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:42.474]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:42.474]                       fi_tmp <- file.info(pathname_tmp)
[13:33:42.474]                       fi <- file.info(pathname)
[13:33:42.474]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:42.474]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:42.474]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:42.474]                         fi[["size"]], fi[["mtime"]])
[13:33:42.474]                       stop(msg)
[13:33:42.474]                     }
[13:33:42.474]                     invisible(pathname)
[13:33:42.474]                   }
[13:33:42.474]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:42.474]                     rootPath = tempdir()) 
[13:33:42.474]                   {
[13:33:42.474]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:42.474]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:42.474]                       tmpdir = path, fileext = ".rds")
[13:33:42.474]                     save_rds(obj, file)
[13:33:42.474]                   }
[13:33:42.474]                   saveImmediateCondition(cond, path = "/tmp/RtmpMLLN1L/.future/immediateConditions")
[13:33:42.474]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:42.474]                   {
[13:33:42.474]                     inherits <- base::inherits
[13:33:42.474]                     invokeRestart <- base::invokeRestart
[13:33:42.474]                     is.null <- base::is.null
[13:33:42.474]                     muffled <- FALSE
[13:33:42.474]                     if (inherits(cond, "message")) {
[13:33:42.474]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:42.474]                       if (muffled) 
[13:33:42.474]                         invokeRestart("muffleMessage")
[13:33:42.474]                     }
[13:33:42.474]                     else if (inherits(cond, "warning")) {
[13:33:42.474]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:42.474]                       if (muffled) 
[13:33:42.474]                         invokeRestart("muffleWarning")
[13:33:42.474]                     }
[13:33:42.474]                     else if (inherits(cond, "condition")) {
[13:33:42.474]                       if (!is.null(pattern)) {
[13:33:42.474]                         computeRestarts <- base::computeRestarts
[13:33:42.474]                         grepl <- base::grepl
[13:33:42.474]                         restarts <- computeRestarts(cond)
[13:33:42.474]                         for (restart in restarts) {
[13:33:42.474]                           name <- restart$name
[13:33:42.474]                           if (is.null(name)) 
[13:33:42.474]                             next
[13:33:42.474]                           if (!grepl(pattern, name)) 
[13:33:42.474]                             next
[13:33:42.474]                           invokeRestart(restart)
[13:33:42.474]                           muffled <- TRUE
[13:33:42.474]                           break
[13:33:42.474]                         }
[13:33:42.474]                       }
[13:33:42.474]                     }
[13:33:42.474]                     invisible(muffled)
[13:33:42.474]                   }
[13:33:42.474]                   muffleCondition(cond)
[13:33:42.474]                 })
[13:33:42.474]             }))
[13:33:42.474]             future::FutureResult(value = ...future.value$value, 
[13:33:42.474]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:42.474]                   ...future.rng), globalenv = if (FALSE) 
[13:33:42.474]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:42.474]                     ...future.globalenv.names))
[13:33:42.474]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:42.474]         }, condition = base::local({
[13:33:42.474]             c <- base::c
[13:33:42.474]             inherits <- base::inherits
[13:33:42.474]             invokeRestart <- base::invokeRestart
[13:33:42.474]             length <- base::length
[13:33:42.474]             list <- base::list
[13:33:42.474]             seq.int <- base::seq.int
[13:33:42.474]             signalCondition <- base::signalCondition
[13:33:42.474]             sys.calls <- base::sys.calls
[13:33:42.474]             `[[` <- base::`[[`
[13:33:42.474]             `+` <- base::`+`
[13:33:42.474]             `<<-` <- base::`<<-`
[13:33:42.474]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:42.474]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:42.474]                   3L)]
[13:33:42.474]             }
[13:33:42.474]             function(cond) {
[13:33:42.474]                 is_error <- inherits(cond, "error")
[13:33:42.474]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:42.474]                   NULL)
[13:33:42.474]                 if (is_error) {
[13:33:42.474]                   sessionInformation <- function() {
[13:33:42.474]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:42.474]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:42.474]                       search = base::search(), system = base::Sys.info())
[13:33:42.474]                   }
[13:33:42.474]                   ...future.conditions[[length(...future.conditions) + 
[13:33:42.474]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:42.474]                     cond$call), session = sessionInformation(), 
[13:33:42.474]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:42.474]                   signalCondition(cond)
[13:33:42.474]                 }
[13:33:42.474]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:42.474]                 "immediateCondition"))) {
[13:33:42.474]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:42.474]                   ...future.conditions[[length(...future.conditions) + 
[13:33:42.474]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:42.474]                   if (TRUE && !signal) {
[13:33:42.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:42.474]                     {
[13:33:42.474]                       inherits <- base::inherits
[13:33:42.474]                       invokeRestart <- base::invokeRestart
[13:33:42.474]                       is.null <- base::is.null
[13:33:42.474]                       muffled <- FALSE
[13:33:42.474]                       if (inherits(cond, "message")) {
[13:33:42.474]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:42.474]                         if (muffled) 
[13:33:42.474]                           invokeRestart("muffleMessage")
[13:33:42.474]                       }
[13:33:42.474]                       else if (inherits(cond, "warning")) {
[13:33:42.474]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:42.474]                         if (muffled) 
[13:33:42.474]                           invokeRestart("muffleWarning")
[13:33:42.474]                       }
[13:33:42.474]                       else if (inherits(cond, "condition")) {
[13:33:42.474]                         if (!is.null(pattern)) {
[13:33:42.474]                           computeRestarts <- base::computeRestarts
[13:33:42.474]                           grepl <- base::grepl
[13:33:42.474]                           restarts <- computeRestarts(cond)
[13:33:42.474]                           for (restart in restarts) {
[13:33:42.474]                             name <- restart$name
[13:33:42.474]                             if (is.null(name)) 
[13:33:42.474]                               next
[13:33:42.474]                             if (!grepl(pattern, name)) 
[13:33:42.474]                               next
[13:33:42.474]                             invokeRestart(restart)
[13:33:42.474]                             muffled <- TRUE
[13:33:42.474]                             break
[13:33:42.474]                           }
[13:33:42.474]                         }
[13:33:42.474]                       }
[13:33:42.474]                       invisible(muffled)
[13:33:42.474]                     }
[13:33:42.474]                     muffleCondition(cond, pattern = "^muffle")
[13:33:42.474]                   }
[13:33:42.474]                 }
[13:33:42.474]                 else {
[13:33:42.474]                   if (TRUE) {
[13:33:42.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:42.474]                     {
[13:33:42.474]                       inherits <- base::inherits
[13:33:42.474]                       invokeRestart <- base::invokeRestart
[13:33:42.474]                       is.null <- base::is.null
[13:33:42.474]                       muffled <- FALSE
[13:33:42.474]                       if (inherits(cond, "message")) {
[13:33:42.474]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:42.474]                         if (muffled) 
[13:33:42.474]                           invokeRestart("muffleMessage")
[13:33:42.474]                       }
[13:33:42.474]                       else if (inherits(cond, "warning")) {
[13:33:42.474]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:42.474]                         if (muffled) 
[13:33:42.474]                           invokeRestart("muffleWarning")
[13:33:42.474]                       }
[13:33:42.474]                       else if (inherits(cond, "condition")) {
[13:33:42.474]                         if (!is.null(pattern)) {
[13:33:42.474]                           computeRestarts <- base::computeRestarts
[13:33:42.474]                           grepl <- base::grepl
[13:33:42.474]                           restarts <- computeRestarts(cond)
[13:33:42.474]                           for (restart in restarts) {
[13:33:42.474]                             name <- restart$name
[13:33:42.474]                             if (is.null(name)) 
[13:33:42.474]                               next
[13:33:42.474]                             if (!grepl(pattern, name)) 
[13:33:42.474]                               next
[13:33:42.474]                             invokeRestart(restart)
[13:33:42.474]                             muffled <- TRUE
[13:33:42.474]                             break
[13:33:42.474]                           }
[13:33:42.474]                         }
[13:33:42.474]                       }
[13:33:42.474]                       invisible(muffled)
[13:33:42.474]                     }
[13:33:42.474]                     muffleCondition(cond, pattern = "^muffle")
[13:33:42.474]                   }
[13:33:42.474]                 }
[13:33:42.474]             }
[13:33:42.474]         }))
[13:33:42.474]     }, error = function(ex) {
[13:33:42.474]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:42.474]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:42.474]                 ...future.rng), started = ...future.startTime, 
[13:33:42.474]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:42.474]             version = "1.8"), class = "FutureResult")
[13:33:42.474]     }, finally = {
[13:33:42.474]         if (!identical(...future.workdir, getwd())) 
[13:33:42.474]             setwd(...future.workdir)
[13:33:42.474]         {
[13:33:42.474]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:42.474]                 ...future.oldOptions$nwarnings <- NULL
[13:33:42.474]             }
[13:33:42.474]             base::options(...future.oldOptions)
[13:33:42.474]             if (.Platform$OS.type == "windows") {
[13:33:42.474]                 old_names <- names(...future.oldEnvVars)
[13:33:42.474]                 envs <- base::Sys.getenv()
[13:33:42.474]                 names <- names(envs)
[13:33:42.474]                 common <- intersect(names, old_names)
[13:33:42.474]                 added <- setdiff(names, old_names)
[13:33:42.474]                 removed <- setdiff(old_names, names)
[13:33:42.474]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:42.474]                   envs[common]]
[13:33:42.474]                 NAMES <- toupper(changed)
[13:33:42.474]                 args <- list()
[13:33:42.474]                 for (kk in seq_along(NAMES)) {
[13:33:42.474]                   name <- changed[[kk]]
[13:33:42.474]                   NAME <- NAMES[[kk]]
[13:33:42.474]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:42.474]                     next
[13:33:42.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:42.474]                 }
[13:33:42.474]                 NAMES <- toupper(added)
[13:33:42.474]                 for (kk in seq_along(NAMES)) {
[13:33:42.474]                   name <- added[[kk]]
[13:33:42.474]                   NAME <- NAMES[[kk]]
[13:33:42.474]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:42.474]                     next
[13:33:42.474]                   args[[name]] <- ""
[13:33:42.474]                 }
[13:33:42.474]                 NAMES <- toupper(removed)
[13:33:42.474]                 for (kk in seq_along(NAMES)) {
[13:33:42.474]                   name <- removed[[kk]]
[13:33:42.474]                   NAME <- NAMES[[kk]]
[13:33:42.474]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:42.474]                     next
[13:33:42.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:42.474]                 }
[13:33:42.474]                 if (length(args) > 0) 
[13:33:42.474]                   base::do.call(base::Sys.setenv, args = args)
[13:33:42.474]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:42.474]             }
[13:33:42.474]             else {
[13:33:42.474]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:42.474]             }
[13:33:42.474]             {
[13:33:42.474]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:42.474]                   0L) {
[13:33:42.474]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:42.474]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:42.474]                   base::options(opts)
[13:33:42.474]                 }
[13:33:42.474]                 {
[13:33:42.474]                   {
[13:33:42.474]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:42.474]                     NULL
[13:33:42.474]                   }
[13:33:42.474]                   options(future.plan = NULL)
[13:33:42.474]                   if (is.na(NA_character_)) 
[13:33:42.474]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:42.474]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:42.474]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:42.474]                     .init = FALSE)
[13:33:42.474]                 }
[13:33:42.474]             }
[13:33:42.474]         }
[13:33:42.474]     })
[13:33:42.474]     if (TRUE) {
[13:33:42.474]         base::sink(type = "output", split = FALSE)
[13:33:42.474]         if (TRUE) {
[13:33:42.474]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:42.474]         }
[13:33:42.474]         else {
[13:33:42.474]             ...future.result["stdout"] <- base::list(NULL)
[13:33:42.474]         }
[13:33:42.474]         base::close(...future.stdout)
[13:33:42.474]         ...future.stdout <- NULL
[13:33:42.474]     }
[13:33:42.474]     ...future.result$conditions <- ...future.conditions
[13:33:42.474]     ...future.result$finished <- base::Sys.time()
[13:33:42.474]     ...future.result
[13:33:42.474] }
[13:33:42.477] assign_globals() ...
[13:33:42.477] List of 5
[13:33:42.477]  $ ...future.FUN            :function (object, ...)  
[13:33:42.477]  $ future.call.arguments    : list()
[13:33:42.477]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:42.477]  $ ...future.elements_ii    :List of 2
[13:33:42.477]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:42.477]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[13:33:42.477]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:42.477]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[13:33:42.477]   ..$ :'data.frame':	18 obs. of  3 variables:
[13:33:42.477]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[13:33:42.477]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[13:33:42.477]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[13:33:42.477]  $ ...future.seeds_ii       : NULL
[13:33:42.477]  $ ...future.globals.maxSize: NULL
[13:33:42.477]  - attr(*, "where")=List of 5
[13:33:42.477]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:42.477]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:42.477]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:42.477]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:42.477]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:42.477]  - attr(*, "resolved")= logi FALSE
[13:33:42.477]  - attr(*, "total_size")= num 1240
[13:33:42.477]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:42.477]  - attr(*, "already-done")= logi TRUE
[13:33:42.487] - copied ‘...future.FUN’ to environment
[13:33:42.488] - copied ‘future.call.arguments’ to environment
[13:33:42.488] - copied ‘...future.elements_ii’ to environment
[13:33:42.488] - copied ‘...future.seeds_ii’ to environment
[13:33:42.488] - copied ‘...future.globals.maxSize’ to environment
[13:33:42.488] assign_globals() ... done
[13:33:42.488] requestCore(): workers = 2
[13:33:42.491] MulticoreFuture started
[13:33:42.491] - Launch lazy future ... done
[13:33:42.491] run() for ‘MulticoreFuture’ ... done
[13:33:42.491] Created future:
[13:33:42.492] plan(): Setting new future strategy stack:
[13:33:42.492] List of future strategies:
[13:33:42.492] 1. sequential:
[13:33:42.492]    - args: function (..., envir = parent.frame())
[13:33:42.492]    - tweaked: FALSE
[13:33:42.492]    - call: NULL
[13:33:42.493] plan(): nbrOfWorkers() = 1
[13:33:42.497] plan(): Setting new future strategy stack:
[13:33:42.497] List of future strategies:
[13:33:42.497] 1. multicore:
[13:33:42.497]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:42.497]    - tweaked: FALSE
[13:33:42.497]    - call: plan(strategy)
[13:33:42.502] plan(): nbrOfWorkers() = 2
[13:33:42.492] MulticoreFuture:
[13:33:42.492] Label: ‘future_by-2’
[13:33:42.492] Expression:
[13:33:42.492] {
[13:33:42.492]     do.call(function(...) {
[13:33:42.492]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:42.492]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:42.492]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:42.492]             on.exit(options(oopts), add = TRUE)
[13:33:42.492]         }
[13:33:42.492]         {
[13:33:42.492]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:42.492]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:42.492]                 ...future.FUN(...future.X_jj, ...)
[13:33:42.492]             })
[13:33:42.492]         }
[13:33:42.492]     }, args = future.call.arguments)
[13:33:42.492] }
[13:33:42.492] Lazy evaluation: FALSE
[13:33:42.492] Asynchronous evaluation: TRUE
[13:33:42.492] Local evaluation: TRUE
[13:33:42.492] Environment: 0x55cb84261d80
[13:33:42.492] Capture standard output: TRUE
[13:33:42.492] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:42.492] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:42.492] Packages: <none>
[13:33:42.492] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:42.492] Resolved: TRUE
[13:33:42.492] Value: <not collected>
[13:33:42.492] Conditions captured: <none>
[13:33:42.492] Early signaling: FALSE
[13:33:42.492] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:42.492] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:42.503] Chunk #2 of 2 ... DONE
[13:33:42.503] Launching 2 futures (chunks) ... DONE
[13:33:42.503] Resolving 2 futures (chunks) ...
[13:33:42.503] resolve() on list ...
[13:33:42.503]  recursive: 0
[13:33:42.504]  length: 2
[13:33:42.504] 
[13:33:42.504] Future #1
[13:33:42.504] result() for MulticoreFuture ...
[13:33:42.505] result() for MulticoreFuture ...
[13:33:42.505] result() for MulticoreFuture ... done
[13:33:42.505] result() for MulticoreFuture ... done
[13:33:42.505] result() for MulticoreFuture ...
[13:33:42.506] result() for MulticoreFuture ... done
[13:33:42.506] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:33:42.506] - nx: 2
[13:33:42.506] - relay: TRUE
[13:33:42.506] - stdout: TRUE
[13:33:42.506] - signal: TRUE
[13:33:42.506] - resignal: FALSE
[13:33:42.507] - force: TRUE
[13:33:42.507] - relayed: [n=2] FALSE, FALSE
[13:33:42.507] - queued futures: [n=2] FALSE, FALSE
[13:33:42.507]  - until=1
[13:33:42.507]  - relaying element #1
[13:33:42.507] result() for MulticoreFuture ...
[13:33:42.507] result() for MulticoreFuture ... done
[13:33:42.507] result() for MulticoreFuture ...
[13:33:42.508] result() for MulticoreFuture ... done
[13:33:42.508] result() for MulticoreFuture ...
[13:33:42.508] result() for MulticoreFuture ... done
[13:33:42.508] result() for MulticoreFuture ...
[13:33:42.508] result() for MulticoreFuture ... done
[13:33:42.508] - relayed: [n=2] TRUE, FALSE
[13:33:42.508] - queued futures: [n=2] TRUE, FALSE
[13:33:42.508] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:33:42.509]  length: 1 (resolved future 1)
[13:33:42.509] Future #2
[13:33:42.509] result() for MulticoreFuture ...
[13:33:42.510] result() for MulticoreFuture ...
[13:33:42.510] result() for MulticoreFuture ... done
[13:33:42.510] result() for MulticoreFuture ... done
[13:33:42.510] result() for MulticoreFuture ...
[13:33:42.511] result() for MulticoreFuture ... done
[13:33:42.511] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:33:42.511] - nx: 2
[13:33:42.511] - relay: TRUE
[13:33:42.511] - stdout: TRUE
[13:33:42.511] - signal: TRUE
[13:33:42.512] - resignal: FALSE
[13:33:42.512] - force: TRUE
[13:33:42.512] - relayed: [n=2] TRUE, FALSE
[13:33:42.512] - queued futures: [n=2] TRUE, FALSE
[13:33:42.512]  - until=2
[13:33:42.512]  - relaying element #2
[13:33:42.512] result() for MulticoreFuture ...
[13:33:42.513] result() for MulticoreFuture ... done
[13:33:42.513] result() for MulticoreFuture ...
[13:33:42.513] result() for MulticoreFuture ... done
[13:33:42.513] result() for MulticoreFuture ...
[13:33:42.513] result() for MulticoreFuture ... done
[13:33:42.513] result() for MulticoreFuture ...
[13:33:42.513] result() for MulticoreFuture ... done
[13:33:42.514] - relayed: [n=2] TRUE, TRUE
[13:33:42.514] - queued futures: [n=2] TRUE, TRUE
[13:33:42.514] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:33:42.514]  length: 0 (resolved future 2)
[13:33:42.514] Relaying remaining futures
[13:33:42.514] signalConditionsASAP(NULL, pos=0) ...
[13:33:42.514] - nx: 2
[13:33:42.514] - relay: TRUE
[13:33:42.514] - stdout: TRUE
[13:33:42.514] - signal: TRUE
[13:33:42.515] - resignal: FALSE
[13:33:42.515] - force: TRUE
[13:33:42.515] - relayed: [n=2] TRUE, TRUE
[13:33:42.515] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:42.515] - relayed: [n=2] TRUE, TRUE
[13:33:42.515] - queued futures: [n=2] TRUE, TRUE
[13:33:42.515] signalConditionsASAP(NULL, pos=0) ... done
[13:33:42.515] resolve() on list ... DONE
[13:33:42.515] result() for MulticoreFuture ...
[13:33:42.516] result() for MulticoreFuture ... done
[13:33:42.516] result() for MulticoreFuture ...
[13:33:42.516] result() for MulticoreFuture ... done
[13:33:42.516] result() for MulticoreFuture ...
[13:33:42.516] result() for MulticoreFuture ... done
[13:33:42.516] result() for MulticoreFuture ...
[13:33:42.516] result() for MulticoreFuture ... done
[13:33:42.516]  - Number of value chunks collected: 2
[13:33:42.516] Resolving 2 futures (chunks) ... DONE
[13:33:42.517] Reducing values from 2 chunks ...
[13:33:42.517]  - Number of values collected after concatenation: 3
[13:33:42.517]  - Number of values expected: 3
[13:33:42.517] Reducing values from 2 chunks ... DONE
[13:33:42.517] future_lapply() ... DONE
[13:33:42.517] future_by_internal() ... DONE
[13:33:42.518] future_by_internal() ...
- plan('multisession') ...
[13:33:42.519] plan(): Setting new future strategy stack:
[13:33:42.519] List of future strategies:
[13:33:42.519] 1. multisession:
[13:33:42.519]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:33:42.519]    - tweaked: FALSE
[13:33:42.519]    - call: plan(strategy)
[13:33:42.519] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:33:42.520] multisession:
[13:33:42.520] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:33:42.520] - tweaked: FALSE
[13:33:42.520] - call: plan(strategy)
[13:33:42.526] getGlobalsAndPackages() ...
[13:33:42.526] Not searching for globals
[13:33:42.527] - globals: [0] <none>
[13:33:42.527] getGlobalsAndPackages() ... DONE
[13:33:42.527] [local output] makeClusterPSOCK() ...
[13:33:42.582] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:33:42.583] [local output] Base port: 11802
[13:33:42.583] [local output] Getting setup options for 2 cluster nodes ...
[13:33:42.583] [local output]  - Node 1 of 2 ...
[13:33:42.584] [local output] localMachine=TRUE => revtunnel=FALSE

[13:33:42.584] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpMLLN1L/worker.rank=1.parallelly.parent=69250.10e8244825fdd.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpMLLN1L/worker.rank=1.parallelly.parent=69250.10e8244825fdd.pid")'’
[13:33:42.773] - Possible to infer worker's PID: TRUE
[13:33:42.773] [local output] Rscript port: 11802

[13:33:42.774] [local output]  - Node 2 of 2 ...
[13:33:42.774] [local output] localMachine=TRUE => revtunnel=FALSE

[13:33:42.775] [local output] Rscript port: 11802

[13:33:42.775] [local output] Getting setup options for 2 cluster nodes ... done
[13:33:42.775] [local output]  - Parallel setup requested for some PSOCK nodes
[13:33:42.776] [local output] Setting up PSOCK nodes in parallel
[13:33:42.776] List of 36
[13:33:42.776]  $ worker          : chr "localhost"
[13:33:42.776]   ..- attr(*, "localhost")= logi TRUE
[13:33:42.776]  $ master          : chr "localhost"
[13:33:42.776]  $ port            : int 11802
[13:33:42.776]  $ connectTimeout  : num 120
[13:33:42.776]  $ timeout         : num 2592000
[13:33:42.776]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:33:42.776]  $ homogeneous     : logi TRUE
[13:33:42.776]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:33:42.776]  $ rscript_envs    : NULL
[13:33:42.776]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:33:42.776]  $ rscript_startup : NULL
[13:33:42.776]  $ rscript_sh      : chr "sh"
[13:33:42.776]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:33:42.776]  $ methods         : logi TRUE
[13:33:42.776]  $ socketOptions   : chr "no-delay"
[13:33:42.776]  $ useXDR          : logi FALSE
[13:33:42.776]  $ outfile         : chr "/dev/null"
[13:33:42.776]  $ renice          : int NA
[13:33:42.776]  $ rshcmd          : NULL
[13:33:42.776]  $ user            : chr(0) 
[13:33:42.776]  $ revtunnel       : logi FALSE
[13:33:42.776]  $ rshlogfile      : NULL
[13:33:42.776]  $ rshopts         : chr(0) 
[13:33:42.776]  $ rank            : int 1
[13:33:42.776]  $ manual          : logi FALSE
[13:33:42.776]  $ dryrun          : logi FALSE
[13:33:42.776]  $ quiet           : logi FALSE
[13:33:42.776]  $ setup_strategy  : chr "parallel"
[13:33:42.776]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:33:42.776]  $ pidfile         : chr "/tmp/RtmpMLLN1L/worker.rank=1.parallelly.parent=69250.10e8244825fdd.pid"
[13:33:42.776]  $ rshcmd_label    : NULL
[13:33:42.776]  $ rsh_call        : NULL
[13:33:42.776]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:33:42.776]  $ localMachine    : logi TRUE
[13:33:42.776]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:33:42.776]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:33:42.776]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:33:42.776]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:33:42.776]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:33:42.776]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:33:42.776]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:33:42.776]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:33:42.776]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:33:42.776]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:33:42.776]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:33:42.776]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:33:42.776]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:33:42.776]  $ arguments       :List of 28
[13:33:42.776]   ..$ worker          : chr "localhost"
[13:33:42.776]   ..$ master          : NULL
[13:33:42.776]   ..$ port            : int 11802
[13:33:42.776]   ..$ connectTimeout  : num 120
[13:33:42.776]   ..$ timeout         : num 2592000
[13:33:42.776]   ..$ rscript         : NULL
[13:33:42.776]   ..$ homogeneous     : NULL
[13:33:42.776]   ..$ rscript_args    : NULL
[13:33:42.776]   ..$ rscript_envs    : NULL
[13:33:42.776]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:33:42.776]   ..$ rscript_startup : NULL
[13:33:42.776]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:33:42.776]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:33:42.776]   ..$ methods         : logi TRUE
[13:33:42.776]   ..$ socketOptions   : chr "no-delay"
[13:33:42.776]   ..$ useXDR          : logi FALSE
[13:33:42.776]   ..$ outfile         : chr "/dev/null"
[13:33:42.776]   ..$ renice          : int NA
[13:33:42.776]   ..$ rshcmd          : NULL
[13:33:42.776]   ..$ user            : NULL
[13:33:42.776]   ..$ revtunnel       : logi NA
[13:33:42.776]   ..$ rshlogfile      : NULL
[13:33:42.776]   ..$ rshopts         : NULL
[13:33:42.776]   ..$ rank            : int 1
[13:33:42.776]   ..$ manual          : logi FALSE
[13:33:42.776]   ..$ dryrun          : logi FALSE
[13:33:42.776]   ..$ quiet           : logi FALSE
[13:33:42.776]   ..$ setup_strategy  : chr "parallel"
[13:33:42.776]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:33:42.792] [local output] System call to launch all workers:
[13:33:42.793] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpMLLN1L/worker.rank=1.parallelly.parent=69250.10e8244825fdd.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11802 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:33:42.793] [local output] Starting PSOCK main server
[13:33:42.798] [local output] Workers launched
[13:33:42.798] [local output] Waiting for workers to connect back
[13:33:42.798]  - [local output] 0 workers out of 2 ready
[13:33:43.044]  - [local output] 0 workers out of 2 ready
[13:33:43.045]  - [local output] 1 workers out of 2 ready
[13:33:43.047]  - [local output] 1 workers out of 2 ready
[13:33:43.047]  - [local output] 2 workers out of 2 ready
[13:33:43.047] [local output] Launching of workers completed
[13:33:43.048] [local output] Collecting session information from workers
[13:33:43.048] [local output]  - Worker #1 of 2
[13:33:43.049] [local output]  - Worker #2 of 2
[13:33:43.049] [local output] makeClusterPSOCK() ... done
[13:33:43.060] Packages needed by the future expression (n = 0): <none>
[13:33:43.060] Packages needed by future strategies (n = 0): <none>
[13:33:43.061] {
[13:33:43.061]     {
[13:33:43.061]         {
[13:33:43.061]             ...future.startTime <- base::Sys.time()
[13:33:43.061]             {
[13:33:43.061]                 {
[13:33:43.061]                   {
[13:33:43.061]                     {
[13:33:43.061]                       base::local({
[13:33:43.061]                         has_future <- base::requireNamespace("future", 
[13:33:43.061]                           quietly = TRUE)
[13:33:43.061]                         if (has_future) {
[13:33:43.061]                           ns <- base::getNamespace("future")
[13:33:43.061]                           version <- ns[[".package"]][["version"]]
[13:33:43.061]                           if (is.null(version)) 
[13:33:43.061]                             version <- utils::packageVersion("future")
[13:33:43.061]                         }
[13:33:43.061]                         else {
[13:33:43.061]                           version <- NULL
[13:33:43.061]                         }
[13:33:43.061]                         if (!has_future || version < "1.8.0") {
[13:33:43.061]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:43.061]                             "", base::R.version$version.string), 
[13:33:43.061]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:43.061]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:43.061]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:43.061]                               "release", "version")], collapse = " "), 
[13:33:43.061]                             hostname = base::Sys.info()[["nodename"]])
[13:33:43.061]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:43.061]                             info)
[13:33:43.061]                           info <- base::paste(info, collapse = "; ")
[13:33:43.061]                           if (!has_future) {
[13:33:43.061]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:43.061]                               info)
[13:33:43.061]                           }
[13:33:43.061]                           else {
[13:33:43.061]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:43.061]                               info, version)
[13:33:43.061]                           }
[13:33:43.061]                           base::stop(msg)
[13:33:43.061]                         }
[13:33:43.061]                       })
[13:33:43.061]                     }
[13:33:43.061]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:43.061]                     base::options(mc.cores = 1L)
[13:33:43.061]                   }
[13:33:43.061]                   ...future.strategy.old <- future::plan("list")
[13:33:43.061]                   options(future.plan = NULL)
[13:33:43.061]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:43.061]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:43.061]                 }
[13:33:43.061]                 ...future.workdir <- getwd()
[13:33:43.061]             }
[13:33:43.061]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:43.061]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:43.061]         }
[13:33:43.061]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:43.061]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:43.061]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:43.061]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:43.061]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:43.061]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:43.061]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:43.061]             base::names(...future.oldOptions))
[13:33:43.061]     }
[13:33:43.061]     if (FALSE) {
[13:33:43.061]     }
[13:33:43.061]     else {
[13:33:43.061]         if (TRUE) {
[13:33:43.061]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:43.061]                 open = "w")
[13:33:43.061]         }
[13:33:43.061]         else {
[13:33:43.061]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:43.061]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:43.061]         }
[13:33:43.061]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:43.061]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:43.061]             base::sink(type = "output", split = FALSE)
[13:33:43.061]             base::close(...future.stdout)
[13:33:43.061]         }, add = TRUE)
[13:33:43.061]     }
[13:33:43.061]     ...future.frame <- base::sys.nframe()
[13:33:43.061]     ...future.conditions <- base::list()
[13:33:43.061]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:43.061]     if (FALSE) {
[13:33:43.061]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:43.061]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:43.061]     }
[13:33:43.061]     ...future.result <- base::tryCatch({
[13:33:43.061]         base::withCallingHandlers({
[13:33:43.061]             ...future.value <- base::withVisible(base::local({
[13:33:43.061]                 ...future.makeSendCondition <- base::local({
[13:33:43.061]                   sendCondition <- NULL
[13:33:43.061]                   function(frame = 1L) {
[13:33:43.061]                     if (is.function(sendCondition)) 
[13:33:43.061]                       return(sendCondition)
[13:33:43.061]                     ns <- getNamespace("parallel")
[13:33:43.061]                     if (exists("sendData", mode = "function", 
[13:33:43.061]                       envir = ns)) {
[13:33:43.061]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:43.061]                         envir = ns)
[13:33:43.061]                       envir <- sys.frame(frame)
[13:33:43.061]                       master <- NULL
[13:33:43.061]                       while (!identical(envir, .GlobalEnv) && 
[13:33:43.061]                         !identical(envir, emptyenv())) {
[13:33:43.061]                         if (exists("master", mode = "list", envir = envir, 
[13:33:43.061]                           inherits = FALSE)) {
[13:33:43.061]                           master <- get("master", mode = "list", 
[13:33:43.061]                             envir = envir, inherits = FALSE)
[13:33:43.061]                           if (inherits(master, c("SOCKnode", 
[13:33:43.061]                             "SOCK0node"))) {
[13:33:43.061]                             sendCondition <<- function(cond) {
[13:33:43.061]                               data <- list(type = "VALUE", value = cond, 
[13:33:43.061]                                 success = TRUE)
[13:33:43.061]                               parallel_sendData(master, data)
[13:33:43.061]                             }
[13:33:43.061]                             return(sendCondition)
[13:33:43.061]                           }
[13:33:43.061]                         }
[13:33:43.061]                         frame <- frame + 1L
[13:33:43.061]                         envir <- sys.frame(frame)
[13:33:43.061]                       }
[13:33:43.061]                     }
[13:33:43.061]                     sendCondition <<- function(cond) NULL
[13:33:43.061]                   }
[13:33:43.061]                 })
[13:33:43.061]                 withCallingHandlers({
[13:33:43.061]                   NA
[13:33:43.061]                 }, immediateCondition = function(cond) {
[13:33:43.061]                   sendCondition <- ...future.makeSendCondition()
[13:33:43.061]                   sendCondition(cond)
[13:33:43.061]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.061]                   {
[13:33:43.061]                     inherits <- base::inherits
[13:33:43.061]                     invokeRestart <- base::invokeRestart
[13:33:43.061]                     is.null <- base::is.null
[13:33:43.061]                     muffled <- FALSE
[13:33:43.061]                     if (inherits(cond, "message")) {
[13:33:43.061]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:43.061]                       if (muffled) 
[13:33:43.061]                         invokeRestart("muffleMessage")
[13:33:43.061]                     }
[13:33:43.061]                     else if (inherits(cond, "warning")) {
[13:33:43.061]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:43.061]                       if (muffled) 
[13:33:43.061]                         invokeRestart("muffleWarning")
[13:33:43.061]                     }
[13:33:43.061]                     else if (inherits(cond, "condition")) {
[13:33:43.061]                       if (!is.null(pattern)) {
[13:33:43.061]                         computeRestarts <- base::computeRestarts
[13:33:43.061]                         grepl <- base::grepl
[13:33:43.061]                         restarts <- computeRestarts(cond)
[13:33:43.061]                         for (restart in restarts) {
[13:33:43.061]                           name <- restart$name
[13:33:43.061]                           if (is.null(name)) 
[13:33:43.061]                             next
[13:33:43.061]                           if (!grepl(pattern, name)) 
[13:33:43.061]                             next
[13:33:43.061]                           invokeRestart(restart)
[13:33:43.061]                           muffled <- TRUE
[13:33:43.061]                           break
[13:33:43.061]                         }
[13:33:43.061]                       }
[13:33:43.061]                     }
[13:33:43.061]                     invisible(muffled)
[13:33:43.061]                   }
[13:33:43.061]                   muffleCondition(cond)
[13:33:43.061]                 })
[13:33:43.061]             }))
[13:33:43.061]             future::FutureResult(value = ...future.value$value, 
[13:33:43.061]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:43.061]                   ...future.rng), globalenv = if (FALSE) 
[13:33:43.061]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:43.061]                     ...future.globalenv.names))
[13:33:43.061]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:43.061]         }, condition = base::local({
[13:33:43.061]             c <- base::c
[13:33:43.061]             inherits <- base::inherits
[13:33:43.061]             invokeRestart <- base::invokeRestart
[13:33:43.061]             length <- base::length
[13:33:43.061]             list <- base::list
[13:33:43.061]             seq.int <- base::seq.int
[13:33:43.061]             signalCondition <- base::signalCondition
[13:33:43.061]             sys.calls <- base::sys.calls
[13:33:43.061]             `[[` <- base::`[[`
[13:33:43.061]             `+` <- base::`+`
[13:33:43.061]             `<<-` <- base::`<<-`
[13:33:43.061]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:43.061]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:43.061]                   3L)]
[13:33:43.061]             }
[13:33:43.061]             function(cond) {
[13:33:43.061]                 is_error <- inherits(cond, "error")
[13:33:43.061]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:43.061]                   NULL)
[13:33:43.061]                 if (is_error) {
[13:33:43.061]                   sessionInformation <- function() {
[13:33:43.061]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:43.061]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:43.061]                       search = base::search(), system = base::Sys.info())
[13:33:43.061]                   }
[13:33:43.061]                   ...future.conditions[[length(...future.conditions) + 
[13:33:43.061]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:43.061]                     cond$call), session = sessionInformation(), 
[13:33:43.061]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:43.061]                   signalCondition(cond)
[13:33:43.061]                 }
[13:33:43.061]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:43.061]                 "immediateCondition"))) {
[13:33:43.061]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:43.061]                   ...future.conditions[[length(...future.conditions) + 
[13:33:43.061]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:43.061]                   if (TRUE && !signal) {
[13:33:43.061]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.061]                     {
[13:33:43.061]                       inherits <- base::inherits
[13:33:43.061]                       invokeRestart <- base::invokeRestart
[13:33:43.061]                       is.null <- base::is.null
[13:33:43.061]                       muffled <- FALSE
[13:33:43.061]                       if (inherits(cond, "message")) {
[13:33:43.061]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:43.061]                         if (muffled) 
[13:33:43.061]                           invokeRestart("muffleMessage")
[13:33:43.061]                       }
[13:33:43.061]                       else if (inherits(cond, "warning")) {
[13:33:43.061]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:43.061]                         if (muffled) 
[13:33:43.061]                           invokeRestart("muffleWarning")
[13:33:43.061]                       }
[13:33:43.061]                       else if (inherits(cond, "condition")) {
[13:33:43.061]                         if (!is.null(pattern)) {
[13:33:43.061]                           computeRestarts <- base::computeRestarts
[13:33:43.061]                           grepl <- base::grepl
[13:33:43.061]                           restarts <- computeRestarts(cond)
[13:33:43.061]                           for (restart in restarts) {
[13:33:43.061]                             name <- restart$name
[13:33:43.061]                             if (is.null(name)) 
[13:33:43.061]                               next
[13:33:43.061]                             if (!grepl(pattern, name)) 
[13:33:43.061]                               next
[13:33:43.061]                             invokeRestart(restart)
[13:33:43.061]                             muffled <- TRUE
[13:33:43.061]                             break
[13:33:43.061]                           }
[13:33:43.061]                         }
[13:33:43.061]                       }
[13:33:43.061]                       invisible(muffled)
[13:33:43.061]                     }
[13:33:43.061]                     muffleCondition(cond, pattern = "^muffle")
[13:33:43.061]                   }
[13:33:43.061]                 }
[13:33:43.061]                 else {
[13:33:43.061]                   if (TRUE) {
[13:33:43.061]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.061]                     {
[13:33:43.061]                       inherits <- base::inherits
[13:33:43.061]                       invokeRestart <- base::invokeRestart
[13:33:43.061]                       is.null <- base::is.null
[13:33:43.061]                       muffled <- FALSE
[13:33:43.061]                       if (inherits(cond, "message")) {
[13:33:43.061]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:43.061]                         if (muffled) 
[13:33:43.061]                           invokeRestart("muffleMessage")
[13:33:43.061]                       }
[13:33:43.061]                       else if (inherits(cond, "warning")) {
[13:33:43.061]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:43.061]                         if (muffled) 
[13:33:43.061]                           invokeRestart("muffleWarning")
[13:33:43.061]                       }
[13:33:43.061]                       else if (inherits(cond, "condition")) {
[13:33:43.061]                         if (!is.null(pattern)) {
[13:33:43.061]                           computeRestarts <- base::computeRestarts
[13:33:43.061]                           grepl <- base::grepl
[13:33:43.061]                           restarts <- computeRestarts(cond)
[13:33:43.061]                           for (restart in restarts) {
[13:33:43.061]                             name <- restart$name
[13:33:43.061]                             if (is.null(name)) 
[13:33:43.061]                               next
[13:33:43.061]                             if (!grepl(pattern, name)) 
[13:33:43.061]                               next
[13:33:43.061]                             invokeRestart(restart)
[13:33:43.061]                             muffled <- TRUE
[13:33:43.061]                             break
[13:33:43.061]                           }
[13:33:43.061]                         }
[13:33:43.061]                       }
[13:33:43.061]                       invisible(muffled)
[13:33:43.061]                     }
[13:33:43.061]                     muffleCondition(cond, pattern = "^muffle")
[13:33:43.061]                   }
[13:33:43.061]                 }
[13:33:43.061]             }
[13:33:43.061]         }))
[13:33:43.061]     }, error = function(ex) {
[13:33:43.061]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:43.061]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:43.061]                 ...future.rng), started = ...future.startTime, 
[13:33:43.061]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:43.061]             version = "1.8"), class = "FutureResult")
[13:33:43.061]     }, finally = {
[13:33:43.061]         if (!identical(...future.workdir, getwd())) 
[13:33:43.061]             setwd(...future.workdir)
[13:33:43.061]         {
[13:33:43.061]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:43.061]                 ...future.oldOptions$nwarnings <- NULL
[13:33:43.061]             }
[13:33:43.061]             base::options(...future.oldOptions)
[13:33:43.061]             if (.Platform$OS.type == "windows") {
[13:33:43.061]                 old_names <- names(...future.oldEnvVars)
[13:33:43.061]                 envs <- base::Sys.getenv()
[13:33:43.061]                 names <- names(envs)
[13:33:43.061]                 common <- intersect(names, old_names)
[13:33:43.061]                 added <- setdiff(names, old_names)
[13:33:43.061]                 removed <- setdiff(old_names, names)
[13:33:43.061]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:43.061]                   envs[common]]
[13:33:43.061]                 NAMES <- toupper(changed)
[13:33:43.061]                 args <- list()
[13:33:43.061]                 for (kk in seq_along(NAMES)) {
[13:33:43.061]                   name <- changed[[kk]]
[13:33:43.061]                   NAME <- NAMES[[kk]]
[13:33:43.061]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.061]                     next
[13:33:43.061]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:43.061]                 }
[13:33:43.061]                 NAMES <- toupper(added)
[13:33:43.061]                 for (kk in seq_along(NAMES)) {
[13:33:43.061]                   name <- added[[kk]]
[13:33:43.061]                   NAME <- NAMES[[kk]]
[13:33:43.061]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.061]                     next
[13:33:43.061]                   args[[name]] <- ""
[13:33:43.061]                 }
[13:33:43.061]                 NAMES <- toupper(removed)
[13:33:43.061]                 for (kk in seq_along(NAMES)) {
[13:33:43.061]                   name <- removed[[kk]]
[13:33:43.061]                   NAME <- NAMES[[kk]]
[13:33:43.061]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.061]                     next
[13:33:43.061]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:43.061]                 }
[13:33:43.061]                 if (length(args) > 0) 
[13:33:43.061]                   base::do.call(base::Sys.setenv, args = args)
[13:33:43.061]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:43.061]             }
[13:33:43.061]             else {
[13:33:43.061]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:43.061]             }
[13:33:43.061]             {
[13:33:43.061]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:43.061]                   0L) {
[13:33:43.061]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:43.061]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:43.061]                   base::options(opts)
[13:33:43.061]                 }
[13:33:43.061]                 {
[13:33:43.061]                   {
[13:33:43.061]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:43.061]                     NULL
[13:33:43.061]                   }
[13:33:43.061]                   options(future.plan = NULL)
[13:33:43.061]                   if (is.na(NA_character_)) 
[13:33:43.061]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:43.061]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:43.061]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:43.061]                     .init = FALSE)
[13:33:43.061]                 }
[13:33:43.061]             }
[13:33:43.061]         }
[13:33:43.061]     })
[13:33:43.061]     if (TRUE) {
[13:33:43.061]         base::sink(type = "output", split = FALSE)
[13:33:43.061]         if (TRUE) {
[13:33:43.061]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:43.061]         }
[13:33:43.061]         else {
[13:33:43.061]             ...future.result["stdout"] <- base::list(NULL)
[13:33:43.061]         }
[13:33:43.061]         base::close(...future.stdout)
[13:33:43.061]         ...future.stdout <- NULL
[13:33:43.061]     }
[13:33:43.061]     ...future.result$conditions <- ...future.conditions
[13:33:43.061]     ...future.result$finished <- base::Sys.time()
[13:33:43.061]     ...future.result
[13:33:43.061] }
[13:33:43.113] MultisessionFuture started
[13:33:43.113] result() for ClusterFuture ...
[13:33:43.114] receiveMessageFromWorker() for ClusterFuture ...
[13:33:43.114] - Validating connection of MultisessionFuture
[13:33:43.147] - received message: FutureResult
[13:33:43.147] - Received FutureResult
[13:33:43.148] - Erased future from FutureRegistry
[13:33:43.148] result() for ClusterFuture ...
[13:33:43.148] - result already collected: FutureResult
[13:33:43.148] result() for ClusterFuture ... done
[13:33:43.148] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:43.148] result() for ClusterFuture ... done
[13:33:43.148] result() for ClusterFuture ...
[13:33:43.148] - result already collected: FutureResult
[13:33:43.148] result() for ClusterFuture ... done
[13:33:43.149] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:33:43.152] plan(): nbrOfWorkers() = 2
[13:33:43.152] future_by_internal() ...
[13:33:43.153] future_lapply() ...
[13:33:43.157] Number of chunks: 2
[13:33:43.157] getGlobalsAndPackagesXApply() ...
[13:33:43.157]  - future.globals: TRUE
[13:33:43.157] getGlobalsAndPackages() ...
[13:33:43.157] Searching for globals...
[13:33:43.158] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:43.158] Searching for globals ... DONE
[13:33:43.158] Resolving globals: FALSE
[13:33:43.159] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:43.159] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:43.159] - globals: [1] ‘FUN’
[13:33:43.159] 
[13:33:43.159] getGlobalsAndPackages() ... DONE
[13:33:43.159]  - globals found/used: [n=1] ‘FUN’
[13:33:43.160]  - needed namespaces: [n=0] 
[13:33:43.160] Finding globals ... DONE
[13:33:43.160]  - use_args: TRUE
[13:33:43.160]  - Getting '...' globals ...
[13:33:43.160] resolve() on list ...
[13:33:43.160]  recursive: 0
[13:33:43.160]  length: 1
[13:33:43.160]  elements: ‘...’
[13:33:43.161]  length: 0 (resolved future 1)
[13:33:43.161] resolve() on list ... DONE
[13:33:43.161]    - '...' content: [n=0] 
[13:33:43.161] List of 1
[13:33:43.161]  $ ...: list()
[13:33:43.161]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:43.161]  - attr(*, "where")=List of 1
[13:33:43.161]   ..$ ...:<environment: 0x55cb8382d120> 
[13:33:43.161]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:43.161]  - attr(*, "resolved")= logi TRUE
[13:33:43.161]  - attr(*, "total_size")= num NA
[13:33:43.163]  - Getting '...' globals ... DONE
[13:33:43.164] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:43.164] List of 2
[13:33:43.164]  $ ...future.FUN:function (object, ...)  
[13:33:43.164]  $ ...          : list()
[13:33:43.164]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:43.164]  - attr(*, "where")=List of 2
[13:33:43.164]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:43.164]   ..$ ...          :<environment: 0x55cb8382d120> 
[13:33:43.164]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:43.164]  - attr(*, "resolved")= logi FALSE
[13:33:43.164]  - attr(*, "total_size")= num 1240
[13:33:43.166] Packages to be attached in all futures: [n=0] 
[13:33:43.166] getGlobalsAndPackagesXApply() ... DONE
[13:33:43.166] Number of futures (= number of chunks): 2
[13:33:43.167] Launching 2 futures (chunks) ...
[13:33:43.167] Chunk #1 of 2 ...
[13:33:43.167]  - Finding globals in 'X' for chunk #1 ...
[13:33:43.167] getGlobalsAndPackages() ...
[13:33:43.167] Searching for globals...
[13:33:43.167] 
[13:33:43.167] Searching for globals ... DONE
[13:33:43.168] - globals: [0] <none>
[13:33:43.168] getGlobalsAndPackages() ... DONE
[13:33:43.168]    + additional globals found: [n=0] 
[13:33:43.168]    + additional namespaces needed: [n=0] 
[13:33:43.168]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:43.168]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:43.168]  - seeds: <none>
[13:33:43.168]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.168] getGlobalsAndPackages() ...
[13:33:43.168] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.168] Resolving globals: FALSE
[13:33:43.169] Tweak future expression to call with '...' arguments ...
[13:33:43.169] {
[13:33:43.169]     do.call(function(...) {
[13:33:43.169]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.169]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:43.169]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.169]             on.exit(options(oopts), add = TRUE)
[13:33:43.169]         }
[13:33:43.169]         {
[13:33:43.169]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:43.169]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.169]                 ...future.FUN(...future.X_jj, ...)
[13:33:43.169]             })
[13:33:43.169]         }
[13:33:43.169]     }, args = future.call.arguments)
[13:33:43.169] }
[13:33:43.169] Tweak future expression to call with '...' arguments ... DONE
[13:33:43.169] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.169] 
[13:33:43.169] getGlobalsAndPackages() ... DONE
[13:33:43.170] run() for ‘Future’ ...
[13:33:43.170] - state: ‘created’
[13:33:43.170] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:43.184] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:43.184] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:43.184]   - Field: ‘node’
[13:33:43.184]   - Field: ‘label’
[13:33:43.185]   - Field: ‘local’
[13:33:43.185]   - Field: ‘owner’
[13:33:43.185]   - Field: ‘envir’
[13:33:43.185]   - Field: ‘workers’
[13:33:43.185]   - Field: ‘packages’
[13:33:43.185]   - Field: ‘gc’
[13:33:43.185]   - Field: ‘conditions’
[13:33:43.185]   - Field: ‘persistent’
[13:33:43.185]   - Field: ‘expr’
[13:33:43.185]   - Field: ‘uuid’
[13:33:43.185]   - Field: ‘seed’
[13:33:43.186]   - Field: ‘version’
[13:33:43.186]   - Field: ‘result’
[13:33:43.186]   - Field: ‘asynchronous’
[13:33:43.186]   - Field: ‘calls’
[13:33:43.186]   - Field: ‘globals’
[13:33:43.186]   - Field: ‘stdout’
[13:33:43.186]   - Field: ‘earlySignal’
[13:33:43.186]   - Field: ‘lazy’
[13:33:43.186]   - Field: ‘state’
[13:33:43.186] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:43.186] - Launch lazy future ...
[13:33:43.187] Packages needed by the future expression (n = 0): <none>
[13:33:43.187] Packages needed by future strategies (n = 0): <none>
[13:33:43.187] {
[13:33:43.187]     {
[13:33:43.187]         {
[13:33:43.187]             ...future.startTime <- base::Sys.time()
[13:33:43.187]             {
[13:33:43.187]                 {
[13:33:43.187]                   {
[13:33:43.187]                     {
[13:33:43.187]                       base::local({
[13:33:43.187]                         has_future <- base::requireNamespace("future", 
[13:33:43.187]                           quietly = TRUE)
[13:33:43.187]                         if (has_future) {
[13:33:43.187]                           ns <- base::getNamespace("future")
[13:33:43.187]                           version <- ns[[".package"]][["version"]]
[13:33:43.187]                           if (is.null(version)) 
[13:33:43.187]                             version <- utils::packageVersion("future")
[13:33:43.187]                         }
[13:33:43.187]                         else {
[13:33:43.187]                           version <- NULL
[13:33:43.187]                         }
[13:33:43.187]                         if (!has_future || version < "1.8.0") {
[13:33:43.187]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:43.187]                             "", base::R.version$version.string), 
[13:33:43.187]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:43.187]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:43.187]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:43.187]                               "release", "version")], collapse = " "), 
[13:33:43.187]                             hostname = base::Sys.info()[["nodename"]])
[13:33:43.187]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:43.187]                             info)
[13:33:43.187]                           info <- base::paste(info, collapse = "; ")
[13:33:43.187]                           if (!has_future) {
[13:33:43.187]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:43.187]                               info)
[13:33:43.187]                           }
[13:33:43.187]                           else {
[13:33:43.187]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:43.187]                               info, version)
[13:33:43.187]                           }
[13:33:43.187]                           base::stop(msg)
[13:33:43.187]                         }
[13:33:43.187]                       })
[13:33:43.187]                     }
[13:33:43.187]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:43.187]                     base::options(mc.cores = 1L)
[13:33:43.187]                   }
[13:33:43.187]                   ...future.strategy.old <- future::plan("list")
[13:33:43.187]                   options(future.plan = NULL)
[13:33:43.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:43.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:43.187]                 }
[13:33:43.187]                 ...future.workdir <- getwd()
[13:33:43.187]             }
[13:33:43.187]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:43.187]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:43.187]         }
[13:33:43.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:43.187]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:43.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:43.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:43.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:43.187]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:43.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:43.187]             base::names(...future.oldOptions))
[13:33:43.187]     }
[13:33:43.187]     if (FALSE) {
[13:33:43.187]     }
[13:33:43.187]     else {
[13:33:43.187]         if (TRUE) {
[13:33:43.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:43.187]                 open = "w")
[13:33:43.187]         }
[13:33:43.187]         else {
[13:33:43.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:43.187]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:43.187]         }
[13:33:43.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:43.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:43.187]             base::sink(type = "output", split = FALSE)
[13:33:43.187]             base::close(...future.stdout)
[13:33:43.187]         }, add = TRUE)
[13:33:43.187]     }
[13:33:43.187]     ...future.frame <- base::sys.nframe()
[13:33:43.187]     ...future.conditions <- base::list()
[13:33:43.187]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:43.187]     if (FALSE) {
[13:33:43.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:43.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:43.187]     }
[13:33:43.187]     ...future.result <- base::tryCatch({
[13:33:43.187]         base::withCallingHandlers({
[13:33:43.187]             ...future.value <- base::withVisible(base::local({
[13:33:43.187]                 ...future.makeSendCondition <- base::local({
[13:33:43.187]                   sendCondition <- NULL
[13:33:43.187]                   function(frame = 1L) {
[13:33:43.187]                     if (is.function(sendCondition)) 
[13:33:43.187]                       return(sendCondition)
[13:33:43.187]                     ns <- getNamespace("parallel")
[13:33:43.187]                     if (exists("sendData", mode = "function", 
[13:33:43.187]                       envir = ns)) {
[13:33:43.187]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:43.187]                         envir = ns)
[13:33:43.187]                       envir <- sys.frame(frame)
[13:33:43.187]                       master <- NULL
[13:33:43.187]                       while (!identical(envir, .GlobalEnv) && 
[13:33:43.187]                         !identical(envir, emptyenv())) {
[13:33:43.187]                         if (exists("master", mode = "list", envir = envir, 
[13:33:43.187]                           inherits = FALSE)) {
[13:33:43.187]                           master <- get("master", mode = "list", 
[13:33:43.187]                             envir = envir, inherits = FALSE)
[13:33:43.187]                           if (inherits(master, c("SOCKnode", 
[13:33:43.187]                             "SOCK0node"))) {
[13:33:43.187]                             sendCondition <<- function(cond) {
[13:33:43.187]                               data <- list(type = "VALUE", value = cond, 
[13:33:43.187]                                 success = TRUE)
[13:33:43.187]                               parallel_sendData(master, data)
[13:33:43.187]                             }
[13:33:43.187]                             return(sendCondition)
[13:33:43.187]                           }
[13:33:43.187]                         }
[13:33:43.187]                         frame <- frame + 1L
[13:33:43.187]                         envir <- sys.frame(frame)
[13:33:43.187]                       }
[13:33:43.187]                     }
[13:33:43.187]                     sendCondition <<- function(cond) NULL
[13:33:43.187]                   }
[13:33:43.187]                 })
[13:33:43.187]                 withCallingHandlers({
[13:33:43.187]                   {
[13:33:43.187]                     do.call(function(...) {
[13:33:43.187]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.187]                       if (!identical(...future.globals.maxSize.org, 
[13:33:43.187]                         ...future.globals.maxSize)) {
[13:33:43.187]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.187]                         on.exit(options(oopts), add = TRUE)
[13:33:43.187]                       }
[13:33:43.187]                       {
[13:33:43.187]                         lapply(seq_along(...future.elements_ii), 
[13:33:43.187]                           FUN = function(jj) {
[13:33:43.187]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.187]                             ...future.FUN(...future.X_jj, ...)
[13:33:43.187]                           })
[13:33:43.187]                       }
[13:33:43.187]                     }, args = future.call.arguments)
[13:33:43.187]                   }
[13:33:43.187]                 }, immediateCondition = function(cond) {
[13:33:43.187]                   sendCondition <- ...future.makeSendCondition()
[13:33:43.187]                   sendCondition(cond)
[13:33:43.187]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.187]                   {
[13:33:43.187]                     inherits <- base::inherits
[13:33:43.187]                     invokeRestart <- base::invokeRestart
[13:33:43.187]                     is.null <- base::is.null
[13:33:43.187]                     muffled <- FALSE
[13:33:43.187]                     if (inherits(cond, "message")) {
[13:33:43.187]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:43.187]                       if (muffled) 
[13:33:43.187]                         invokeRestart("muffleMessage")
[13:33:43.187]                     }
[13:33:43.187]                     else if (inherits(cond, "warning")) {
[13:33:43.187]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:43.187]                       if (muffled) 
[13:33:43.187]                         invokeRestart("muffleWarning")
[13:33:43.187]                     }
[13:33:43.187]                     else if (inherits(cond, "condition")) {
[13:33:43.187]                       if (!is.null(pattern)) {
[13:33:43.187]                         computeRestarts <- base::computeRestarts
[13:33:43.187]                         grepl <- base::grepl
[13:33:43.187]                         restarts <- computeRestarts(cond)
[13:33:43.187]                         for (restart in restarts) {
[13:33:43.187]                           name <- restart$name
[13:33:43.187]                           if (is.null(name)) 
[13:33:43.187]                             next
[13:33:43.187]                           if (!grepl(pattern, name)) 
[13:33:43.187]                             next
[13:33:43.187]                           invokeRestart(restart)
[13:33:43.187]                           muffled <- TRUE
[13:33:43.187]                           break
[13:33:43.187]                         }
[13:33:43.187]                       }
[13:33:43.187]                     }
[13:33:43.187]                     invisible(muffled)
[13:33:43.187]                   }
[13:33:43.187]                   muffleCondition(cond)
[13:33:43.187]                 })
[13:33:43.187]             }))
[13:33:43.187]             future::FutureResult(value = ...future.value$value, 
[13:33:43.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:43.187]                   ...future.rng), globalenv = if (FALSE) 
[13:33:43.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:43.187]                     ...future.globalenv.names))
[13:33:43.187]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:43.187]         }, condition = base::local({
[13:33:43.187]             c <- base::c
[13:33:43.187]             inherits <- base::inherits
[13:33:43.187]             invokeRestart <- base::invokeRestart
[13:33:43.187]             length <- base::length
[13:33:43.187]             list <- base::list
[13:33:43.187]             seq.int <- base::seq.int
[13:33:43.187]             signalCondition <- base::signalCondition
[13:33:43.187]             sys.calls <- base::sys.calls
[13:33:43.187]             `[[` <- base::`[[`
[13:33:43.187]             `+` <- base::`+`
[13:33:43.187]             `<<-` <- base::`<<-`
[13:33:43.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:43.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:43.187]                   3L)]
[13:33:43.187]             }
[13:33:43.187]             function(cond) {
[13:33:43.187]                 is_error <- inherits(cond, "error")
[13:33:43.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:43.187]                   NULL)
[13:33:43.187]                 if (is_error) {
[13:33:43.187]                   sessionInformation <- function() {
[13:33:43.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:43.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:43.187]                       search = base::search(), system = base::Sys.info())
[13:33:43.187]                   }
[13:33:43.187]                   ...future.conditions[[length(...future.conditions) + 
[13:33:43.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:43.187]                     cond$call), session = sessionInformation(), 
[13:33:43.187]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:43.187]                   signalCondition(cond)
[13:33:43.187]                 }
[13:33:43.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:43.187]                 "immediateCondition"))) {
[13:33:43.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:43.187]                   ...future.conditions[[length(...future.conditions) + 
[13:33:43.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:43.187]                   if (TRUE && !signal) {
[13:33:43.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.187]                     {
[13:33:43.187]                       inherits <- base::inherits
[13:33:43.187]                       invokeRestart <- base::invokeRestart
[13:33:43.187]                       is.null <- base::is.null
[13:33:43.187]                       muffled <- FALSE
[13:33:43.187]                       if (inherits(cond, "message")) {
[13:33:43.187]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:43.187]                         if (muffled) 
[13:33:43.187]                           invokeRestart("muffleMessage")
[13:33:43.187]                       }
[13:33:43.187]                       else if (inherits(cond, "warning")) {
[13:33:43.187]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:43.187]                         if (muffled) 
[13:33:43.187]                           invokeRestart("muffleWarning")
[13:33:43.187]                       }
[13:33:43.187]                       else if (inherits(cond, "condition")) {
[13:33:43.187]                         if (!is.null(pattern)) {
[13:33:43.187]                           computeRestarts <- base::computeRestarts
[13:33:43.187]                           grepl <- base::grepl
[13:33:43.187]                           restarts <- computeRestarts(cond)
[13:33:43.187]                           for (restart in restarts) {
[13:33:43.187]                             name <- restart$name
[13:33:43.187]                             if (is.null(name)) 
[13:33:43.187]                               next
[13:33:43.187]                             if (!grepl(pattern, name)) 
[13:33:43.187]                               next
[13:33:43.187]                             invokeRestart(restart)
[13:33:43.187]                             muffled <- TRUE
[13:33:43.187]                             break
[13:33:43.187]                           }
[13:33:43.187]                         }
[13:33:43.187]                       }
[13:33:43.187]                       invisible(muffled)
[13:33:43.187]                     }
[13:33:43.187]                     muffleCondition(cond, pattern = "^muffle")
[13:33:43.187]                   }
[13:33:43.187]                 }
[13:33:43.187]                 else {
[13:33:43.187]                   if (TRUE) {
[13:33:43.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.187]                     {
[13:33:43.187]                       inherits <- base::inherits
[13:33:43.187]                       invokeRestart <- base::invokeRestart
[13:33:43.187]                       is.null <- base::is.null
[13:33:43.187]                       muffled <- FALSE
[13:33:43.187]                       if (inherits(cond, "message")) {
[13:33:43.187]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:43.187]                         if (muffled) 
[13:33:43.187]                           invokeRestart("muffleMessage")
[13:33:43.187]                       }
[13:33:43.187]                       else if (inherits(cond, "warning")) {
[13:33:43.187]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:43.187]                         if (muffled) 
[13:33:43.187]                           invokeRestart("muffleWarning")
[13:33:43.187]                       }
[13:33:43.187]                       else if (inherits(cond, "condition")) {
[13:33:43.187]                         if (!is.null(pattern)) {
[13:33:43.187]                           computeRestarts <- base::computeRestarts
[13:33:43.187]                           grepl <- base::grepl
[13:33:43.187]                           restarts <- computeRestarts(cond)
[13:33:43.187]                           for (restart in restarts) {
[13:33:43.187]                             name <- restart$name
[13:33:43.187]                             if (is.null(name)) 
[13:33:43.187]                               next
[13:33:43.187]                             if (!grepl(pattern, name)) 
[13:33:43.187]                               next
[13:33:43.187]                             invokeRestart(restart)
[13:33:43.187]                             muffled <- TRUE
[13:33:43.187]                             break
[13:33:43.187]                           }
[13:33:43.187]                         }
[13:33:43.187]                       }
[13:33:43.187]                       invisible(muffled)
[13:33:43.187]                     }
[13:33:43.187]                     muffleCondition(cond, pattern = "^muffle")
[13:33:43.187]                   }
[13:33:43.187]                 }
[13:33:43.187]             }
[13:33:43.187]         }))
[13:33:43.187]     }, error = function(ex) {
[13:33:43.187]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:43.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:43.187]                 ...future.rng), started = ...future.startTime, 
[13:33:43.187]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:43.187]             version = "1.8"), class = "FutureResult")
[13:33:43.187]     }, finally = {
[13:33:43.187]         if (!identical(...future.workdir, getwd())) 
[13:33:43.187]             setwd(...future.workdir)
[13:33:43.187]         {
[13:33:43.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:43.187]                 ...future.oldOptions$nwarnings <- NULL
[13:33:43.187]             }
[13:33:43.187]             base::options(...future.oldOptions)
[13:33:43.187]             if (.Platform$OS.type == "windows") {
[13:33:43.187]                 old_names <- names(...future.oldEnvVars)
[13:33:43.187]                 envs <- base::Sys.getenv()
[13:33:43.187]                 names <- names(envs)
[13:33:43.187]                 common <- intersect(names, old_names)
[13:33:43.187]                 added <- setdiff(names, old_names)
[13:33:43.187]                 removed <- setdiff(old_names, names)
[13:33:43.187]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:43.187]                   envs[common]]
[13:33:43.187]                 NAMES <- toupper(changed)
[13:33:43.187]                 args <- list()
[13:33:43.187]                 for (kk in seq_along(NAMES)) {
[13:33:43.187]                   name <- changed[[kk]]
[13:33:43.187]                   NAME <- NAMES[[kk]]
[13:33:43.187]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.187]                     next
[13:33:43.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:43.187]                 }
[13:33:43.187]                 NAMES <- toupper(added)
[13:33:43.187]                 for (kk in seq_along(NAMES)) {
[13:33:43.187]                   name <- added[[kk]]
[13:33:43.187]                   NAME <- NAMES[[kk]]
[13:33:43.187]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.187]                     next
[13:33:43.187]                   args[[name]] <- ""
[13:33:43.187]                 }
[13:33:43.187]                 NAMES <- toupper(removed)
[13:33:43.187]                 for (kk in seq_along(NAMES)) {
[13:33:43.187]                   name <- removed[[kk]]
[13:33:43.187]                   NAME <- NAMES[[kk]]
[13:33:43.187]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.187]                     next
[13:33:43.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:43.187]                 }
[13:33:43.187]                 if (length(args) > 0) 
[13:33:43.187]                   base::do.call(base::Sys.setenv, args = args)
[13:33:43.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:43.187]             }
[13:33:43.187]             else {
[13:33:43.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:43.187]             }
[13:33:43.187]             {
[13:33:43.187]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:43.187]                   0L) {
[13:33:43.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:43.187]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:43.187]                   base::options(opts)
[13:33:43.187]                 }
[13:33:43.187]                 {
[13:33:43.187]                   {
[13:33:43.187]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:43.187]                     NULL
[13:33:43.187]                   }
[13:33:43.187]                   options(future.plan = NULL)
[13:33:43.187]                   if (is.na(NA_character_)) 
[13:33:43.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:43.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:43.187]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:43.187]                     .init = FALSE)
[13:33:43.187]                 }
[13:33:43.187]             }
[13:33:43.187]         }
[13:33:43.187]     })
[13:33:43.187]     if (TRUE) {
[13:33:43.187]         base::sink(type = "output", split = FALSE)
[13:33:43.187]         if (TRUE) {
[13:33:43.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:43.187]         }
[13:33:43.187]         else {
[13:33:43.187]             ...future.result["stdout"] <- base::list(NULL)
[13:33:43.187]         }
[13:33:43.187]         base::close(...future.stdout)
[13:33:43.187]         ...future.stdout <- NULL
[13:33:43.187]     }
[13:33:43.187]     ...future.result$conditions <- ...future.conditions
[13:33:43.187]     ...future.result$finished <- base::Sys.time()
[13:33:43.187]     ...future.result
[13:33:43.187] }
[13:33:43.190] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[13:33:43.190] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[13:33:43.191] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[13:33:43.191] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:33:43.191] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:33:43.191] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ...
[13:33:43.192] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ... DONE
[13:33:43.192] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:33:43.192] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:33:43.192] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:33:43.193] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:33:43.193] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[13:33:43.194] MultisessionFuture started
[13:33:43.194] - Launch lazy future ... done
[13:33:43.194] run() for ‘MultisessionFuture’ ... done
[13:33:43.194] Created future:
[13:33:43.194] MultisessionFuture:
[13:33:43.194] Label: ‘future_by-1’
[13:33:43.194] Expression:
[13:33:43.194] {
[13:33:43.194]     do.call(function(...) {
[13:33:43.194]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.194]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:43.194]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.194]             on.exit(options(oopts), add = TRUE)
[13:33:43.194]         }
[13:33:43.194]         {
[13:33:43.194]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:43.194]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.194]                 ...future.FUN(...future.X_jj, ...)
[13:33:43.194]             })
[13:33:43.194]         }
[13:33:43.194]     }, args = future.call.arguments)
[13:33:43.194] }
[13:33:43.194] Lazy evaluation: FALSE
[13:33:43.194] Asynchronous evaluation: TRUE
[13:33:43.194] Local evaluation: TRUE
[13:33:43.194] Environment: R_GlobalEnv
[13:33:43.194] Capture standard output: TRUE
[13:33:43.194] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:43.194] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:43.194] Packages: <none>
[13:33:43.194] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:43.194] Resolved: FALSE
[13:33:43.194] Value: <not collected>
[13:33:43.194] Conditions captured: <none>
[13:33:43.194] Early signaling: FALSE
[13:33:43.194] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:43.194] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:43.206] Chunk #1 of 2 ... DONE
[13:33:43.206] Chunk #2 of 2 ...
[13:33:43.206]  - Finding globals in 'X' for chunk #2 ...
[13:33:43.206] getGlobalsAndPackages() ...
[13:33:43.206] Searching for globals...
[13:33:43.207] 
[13:33:43.207] Searching for globals ... DONE
[13:33:43.207] - globals: [0] <none>
[13:33:43.207] getGlobalsAndPackages() ... DONE
[13:33:43.207]    + additional globals found: [n=0] 
[13:33:43.207]    + additional namespaces needed: [n=0] 
[13:33:43.207]  - Finding globals in 'X' for chunk #2 ... DONE
[13:33:43.207]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:43.208]  - seeds: <none>
[13:33:43.208]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.208] getGlobalsAndPackages() ...
[13:33:43.208] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.208] Resolving globals: FALSE
[13:33:43.208] Tweak future expression to call with '...' arguments ...
[13:33:43.208] {
[13:33:43.208]     do.call(function(...) {
[13:33:43.208]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.208]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:43.208]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.208]             on.exit(options(oopts), add = TRUE)
[13:33:43.208]         }
[13:33:43.208]         {
[13:33:43.208]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:43.208]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.208]                 ...future.FUN(...future.X_jj, ...)
[13:33:43.208]             })
[13:33:43.208]         }
[13:33:43.208]     }, args = future.call.arguments)
[13:33:43.208] }
[13:33:43.208] Tweak future expression to call with '...' arguments ... DONE
[13:33:43.209] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.209] 
[13:33:43.209] getGlobalsAndPackages() ... DONE
[13:33:43.209] run() for ‘Future’ ...
[13:33:43.209] - state: ‘created’
[13:33:43.209] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:43.223] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:43.223] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:43.223]   - Field: ‘node’
[13:33:43.223]   - Field: ‘label’
[13:33:43.224]   - Field: ‘local’
[13:33:43.224]   - Field: ‘owner’
[13:33:43.224]   - Field: ‘envir’
[13:33:43.224]   - Field: ‘workers’
[13:33:43.224]   - Field: ‘packages’
[13:33:43.224]   - Field: ‘gc’
[13:33:43.224]   - Field: ‘conditions’
[13:33:43.224]   - Field: ‘persistent’
[13:33:43.224]   - Field: ‘expr’
[13:33:43.224]   - Field: ‘uuid’
[13:33:43.224]   - Field: ‘seed’
[13:33:43.224]   - Field: ‘version’
[13:33:43.225]   - Field: ‘result’
[13:33:43.225]   - Field: ‘asynchronous’
[13:33:43.225]   - Field: ‘calls’
[13:33:43.225]   - Field: ‘globals’
[13:33:43.225]   - Field: ‘stdout’
[13:33:43.225]   - Field: ‘earlySignal’
[13:33:43.225]   - Field: ‘lazy’
[13:33:43.225]   - Field: ‘state’
[13:33:43.225] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:43.225] - Launch lazy future ...
[13:33:43.226] Packages needed by the future expression (n = 0): <none>
[13:33:43.226] Packages needed by future strategies (n = 0): <none>
[13:33:43.226] {
[13:33:43.226]     {
[13:33:43.226]         {
[13:33:43.226]             ...future.startTime <- base::Sys.time()
[13:33:43.226]             {
[13:33:43.226]                 {
[13:33:43.226]                   {
[13:33:43.226]                     {
[13:33:43.226]                       base::local({
[13:33:43.226]                         has_future <- base::requireNamespace("future", 
[13:33:43.226]                           quietly = TRUE)
[13:33:43.226]                         if (has_future) {
[13:33:43.226]                           ns <- base::getNamespace("future")
[13:33:43.226]                           version <- ns[[".package"]][["version"]]
[13:33:43.226]                           if (is.null(version)) 
[13:33:43.226]                             version <- utils::packageVersion("future")
[13:33:43.226]                         }
[13:33:43.226]                         else {
[13:33:43.226]                           version <- NULL
[13:33:43.226]                         }
[13:33:43.226]                         if (!has_future || version < "1.8.0") {
[13:33:43.226]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:43.226]                             "", base::R.version$version.string), 
[13:33:43.226]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:43.226]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:43.226]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:43.226]                               "release", "version")], collapse = " "), 
[13:33:43.226]                             hostname = base::Sys.info()[["nodename"]])
[13:33:43.226]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:43.226]                             info)
[13:33:43.226]                           info <- base::paste(info, collapse = "; ")
[13:33:43.226]                           if (!has_future) {
[13:33:43.226]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:43.226]                               info)
[13:33:43.226]                           }
[13:33:43.226]                           else {
[13:33:43.226]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:43.226]                               info, version)
[13:33:43.226]                           }
[13:33:43.226]                           base::stop(msg)
[13:33:43.226]                         }
[13:33:43.226]                       })
[13:33:43.226]                     }
[13:33:43.226]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:43.226]                     base::options(mc.cores = 1L)
[13:33:43.226]                   }
[13:33:43.226]                   ...future.strategy.old <- future::plan("list")
[13:33:43.226]                   options(future.plan = NULL)
[13:33:43.226]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:43.226]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:43.226]                 }
[13:33:43.226]                 ...future.workdir <- getwd()
[13:33:43.226]             }
[13:33:43.226]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:43.226]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:43.226]         }
[13:33:43.226]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:43.226]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:43.226]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:43.226]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:43.226]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:43.226]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:43.226]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:43.226]             base::names(...future.oldOptions))
[13:33:43.226]     }
[13:33:43.226]     if (FALSE) {
[13:33:43.226]     }
[13:33:43.226]     else {
[13:33:43.226]         if (TRUE) {
[13:33:43.226]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:43.226]                 open = "w")
[13:33:43.226]         }
[13:33:43.226]         else {
[13:33:43.226]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:43.226]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:43.226]         }
[13:33:43.226]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:43.226]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:43.226]             base::sink(type = "output", split = FALSE)
[13:33:43.226]             base::close(...future.stdout)
[13:33:43.226]         }, add = TRUE)
[13:33:43.226]     }
[13:33:43.226]     ...future.frame <- base::sys.nframe()
[13:33:43.226]     ...future.conditions <- base::list()
[13:33:43.226]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:43.226]     if (FALSE) {
[13:33:43.226]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:43.226]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:43.226]     }
[13:33:43.226]     ...future.result <- base::tryCatch({
[13:33:43.226]         base::withCallingHandlers({
[13:33:43.226]             ...future.value <- base::withVisible(base::local({
[13:33:43.226]                 ...future.makeSendCondition <- base::local({
[13:33:43.226]                   sendCondition <- NULL
[13:33:43.226]                   function(frame = 1L) {
[13:33:43.226]                     if (is.function(sendCondition)) 
[13:33:43.226]                       return(sendCondition)
[13:33:43.226]                     ns <- getNamespace("parallel")
[13:33:43.226]                     if (exists("sendData", mode = "function", 
[13:33:43.226]                       envir = ns)) {
[13:33:43.226]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:43.226]                         envir = ns)
[13:33:43.226]                       envir <- sys.frame(frame)
[13:33:43.226]                       master <- NULL
[13:33:43.226]                       while (!identical(envir, .GlobalEnv) && 
[13:33:43.226]                         !identical(envir, emptyenv())) {
[13:33:43.226]                         if (exists("master", mode = "list", envir = envir, 
[13:33:43.226]                           inherits = FALSE)) {
[13:33:43.226]                           master <- get("master", mode = "list", 
[13:33:43.226]                             envir = envir, inherits = FALSE)
[13:33:43.226]                           if (inherits(master, c("SOCKnode", 
[13:33:43.226]                             "SOCK0node"))) {
[13:33:43.226]                             sendCondition <<- function(cond) {
[13:33:43.226]                               data <- list(type = "VALUE", value = cond, 
[13:33:43.226]                                 success = TRUE)
[13:33:43.226]                               parallel_sendData(master, data)
[13:33:43.226]                             }
[13:33:43.226]                             return(sendCondition)
[13:33:43.226]                           }
[13:33:43.226]                         }
[13:33:43.226]                         frame <- frame + 1L
[13:33:43.226]                         envir <- sys.frame(frame)
[13:33:43.226]                       }
[13:33:43.226]                     }
[13:33:43.226]                     sendCondition <<- function(cond) NULL
[13:33:43.226]                   }
[13:33:43.226]                 })
[13:33:43.226]                 withCallingHandlers({
[13:33:43.226]                   {
[13:33:43.226]                     do.call(function(...) {
[13:33:43.226]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.226]                       if (!identical(...future.globals.maxSize.org, 
[13:33:43.226]                         ...future.globals.maxSize)) {
[13:33:43.226]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.226]                         on.exit(options(oopts), add = TRUE)
[13:33:43.226]                       }
[13:33:43.226]                       {
[13:33:43.226]                         lapply(seq_along(...future.elements_ii), 
[13:33:43.226]                           FUN = function(jj) {
[13:33:43.226]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.226]                             ...future.FUN(...future.X_jj, ...)
[13:33:43.226]                           })
[13:33:43.226]                       }
[13:33:43.226]                     }, args = future.call.arguments)
[13:33:43.226]                   }
[13:33:43.226]                 }, immediateCondition = function(cond) {
[13:33:43.226]                   sendCondition <- ...future.makeSendCondition()
[13:33:43.226]                   sendCondition(cond)
[13:33:43.226]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.226]                   {
[13:33:43.226]                     inherits <- base::inherits
[13:33:43.226]                     invokeRestart <- base::invokeRestart
[13:33:43.226]                     is.null <- base::is.null
[13:33:43.226]                     muffled <- FALSE
[13:33:43.226]                     if (inherits(cond, "message")) {
[13:33:43.226]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:43.226]                       if (muffled) 
[13:33:43.226]                         invokeRestart("muffleMessage")
[13:33:43.226]                     }
[13:33:43.226]                     else if (inherits(cond, "warning")) {
[13:33:43.226]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:43.226]                       if (muffled) 
[13:33:43.226]                         invokeRestart("muffleWarning")
[13:33:43.226]                     }
[13:33:43.226]                     else if (inherits(cond, "condition")) {
[13:33:43.226]                       if (!is.null(pattern)) {
[13:33:43.226]                         computeRestarts <- base::computeRestarts
[13:33:43.226]                         grepl <- base::grepl
[13:33:43.226]                         restarts <- computeRestarts(cond)
[13:33:43.226]                         for (restart in restarts) {
[13:33:43.226]                           name <- restart$name
[13:33:43.226]                           if (is.null(name)) 
[13:33:43.226]                             next
[13:33:43.226]                           if (!grepl(pattern, name)) 
[13:33:43.226]                             next
[13:33:43.226]                           invokeRestart(restart)
[13:33:43.226]                           muffled <- TRUE
[13:33:43.226]                           break
[13:33:43.226]                         }
[13:33:43.226]                       }
[13:33:43.226]                     }
[13:33:43.226]                     invisible(muffled)
[13:33:43.226]                   }
[13:33:43.226]                   muffleCondition(cond)
[13:33:43.226]                 })
[13:33:43.226]             }))
[13:33:43.226]             future::FutureResult(value = ...future.value$value, 
[13:33:43.226]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:43.226]                   ...future.rng), globalenv = if (FALSE) 
[13:33:43.226]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:43.226]                     ...future.globalenv.names))
[13:33:43.226]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:43.226]         }, condition = base::local({
[13:33:43.226]             c <- base::c
[13:33:43.226]             inherits <- base::inherits
[13:33:43.226]             invokeRestart <- base::invokeRestart
[13:33:43.226]             length <- base::length
[13:33:43.226]             list <- base::list
[13:33:43.226]             seq.int <- base::seq.int
[13:33:43.226]             signalCondition <- base::signalCondition
[13:33:43.226]             sys.calls <- base::sys.calls
[13:33:43.226]             `[[` <- base::`[[`
[13:33:43.226]             `+` <- base::`+`
[13:33:43.226]             `<<-` <- base::`<<-`
[13:33:43.226]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:43.226]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:43.226]                   3L)]
[13:33:43.226]             }
[13:33:43.226]             function(cond) {
[13:33:43.226]                 is_error <- inherits(cond, "error")
[13:33:43.226]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:43.226]                   NULL)
[13:33:43.226]                 if (is_error) {
[13:33:43.226]                   sessionInformation <- function() {
[13:33:43.226]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:43.226]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:43.226]                       search = base::search(), system = base::Sys.info())
[13:33:43.226]                   }
[13:33:43.226]                   ...future.conditions[[length(...future.conditions) + 
[13:33:43.226]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:43.226]                     cond$call), session = sessionInformation(), 
[13:33:43.226]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:43.226]                   signalCondition(cond)
[13:33:43.226]                 }
[13:33:43.226]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:43.226]                 "immediateCondition"))) {
[13:33:43.226]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:43.226]                   ...future.conditions[[length(...future.conditions) + 
[13:33:43.226]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:43.226]                   if (TRUE && !signal) {
[13:33:43.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.226]                     {
[13:33:43.226]                       inherits <- base::inherits
[13:33:43.226]                       invokeRestart <- base::invokeRestart
[13:33:43.226]                       is.null <- base::is.null
[13:33:43.226]                       muffled <- FALSE
[13:33:43.226]                       if (inherits(cond, "message")) {
[13:33:43.226]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:43.226]                         if (muffled) 
[13:33:43.226]                           invokeRestart("muffleMessage")
[13:33:43.226]                       }
[13:33:43.226]                       else if (inherits(cond, "warning")) {
[13:33:43.226]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:43.226]                         if (muffled) 
[13:33:43.226]                           invokeRestart("muffleWarning")
[13:33:43.226]                       }
[13:33:43.226]                       else if (inherits(cond, "condition")) {
[13:33:43.226]                         if (!is.null(pattern)) {
[13:33:43.226]                           computeRestarts <- base::computeRestarts
[13:33:43.226]                           grepl <- base::grepl
[13:33:43.226]                           restarts <- computeRestarts(cond)
[13:33:43.226]                           for (restart in restarts) {
[13:33:43.226]                             name <- restart$name
[13:33:43.226]                             if (is.null(name)) 
[13:33:43.226]                               next
[13:33:43.226]                             if (!grepl(pattern, name)) 
[13:33:43.226]                               next
[13:33:43.226]                             invokeRestart(restart)
[13:33:43.226]                             muffled <- TRUE
[13:33:43.226]                             break
[13:33:43.226]                           }
[13:33:43.226]                         }
[13:33:43.226]                       }
[13:33:43.226]                       invisible(muffled)
[13:33:43.226]                     }
[13:33:43.226]                     muffleCondition(cond, pattern = "^muffle")
[13:33:43.226]                   }
[13:33:43.226]                 }
[13:33:43.226]                 else {
[13:33:43.226]                   if (TRUE) {
[13:33:43.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.226]                     {
[13:33:43.226]                       inherits <- base::inherits
[13:33:43.226]                       invokeRestart <- base::invokeRestart
[13:33:43.226]                       is.null <- base::is.null
[13:33:43.226]                       muffled <- FALSE
[13:33:43.226]                       if (inherits(cond, "message")) {
[13:33:43.226]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:43.226]                         if (muffled) 
[13:33:43.226]                           invokeRestart("muffleMessage")
[13:33:43.226]                       }
[13:33:43.226]                       else if (inherits(cond, "warning")) {
[13:33:43.226]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:43.226]                         if (muffled) 
[13:33:43.226]                           invokeRestart("muffleWarning")
[13:33:43.226]                       }
[13:33:43.226]                       else if (inherits(cond, "condition")) {
[13:33:43.226]                         if (!is.null(pattern)) {
[13:33:43.226]                           computeRestarts <- base::computeRestarts
[13:33:43.226]                           grepl <- base::grepl
[13:33:43.226]                           restarts <- computeRestarts(cond)
[13:33:43.226]                           for (restart in restarts) {
[13:33:43.226]                             name <- restart$name
[13:33:43.226]                             if (is.null(name)) 
[13:33:43.226]                               next
[13:33:43.226]                             if (!grepl(pattern, name)) 
[13:33:43.226]                               next
[13:33:43.226]                             invokeRestart(restart)
[13:33:43.226]                             muffled <- TRUE
[13:33:43.226]                             break
[13:33:43.226]                           }
[13:33:43.226]                         }
[13:33:43.226]                       }
[13:33:43.226]                       invisible(muffled)
[13:33:43.226]                     }
[13:33:43.226]                     muffleCondition(cond, pattern = "^muffle")
[13:33:43.226]                   }
[13:33:43.226]                 }
[13:33:43.226]             }
[13:33:43.226]         }))
[13:33:43.226]     }, error = function(ex) {
[13:33:43.226]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:43.226]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:43.226]                 ...future.rng), started = ...future.startTime, 
[13:33:43.226]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:43.226]             version = "1.8"), class = "FutureResult")
[13:33:43.226]     }, finally = {
[13:33:43.226]         if (!identical(...future.workdir, getwd())) 
[13:33:43.226]             setwd(...future.workdir)
[13:33:43.226]         {
[13:33:43.226]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:43.226]                 ...future.oldOptions$nwarnings <- NULL
[13:33:43.226]             }
[13:33:43.226]             base::options(...future.oldOptions)
[13:33:43.226]             if (.Platform$OS.type == "windows") {
[13:33:43.226]                 old_names <- names(...future.oldEnvVars)
[13:33:43.226]                 envs <- base::Sys.getenv()
[13:33:43.226]                 names <- names(envs)
[13:33:43.226]                 common <- intersect(names, old_names)
[13:33:43.226]                 added <- setdiff(names, old_names)
[13:33:43.226]                 removed <- setdiff(old_names, names)
[13:33:43.226]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:43.226]                   envs[common]]
[13:33:43.226]                 NAMES <- toupper(changed)
[13:33:43.226]                 args <- list()
[13:33:43.226]                 for (kk in seq_along(NAMES)) {
[13:33:43.226]                   name <- changed[[kk]]
[13:33:43.226]                   NAME <- NAMES[[kk]]
[13:33:43.226]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.226]                     next
[13:33:43.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:43.226]                 }
[13:33:43.226]                 NAMES <- toupper(added)
[13:33:43.226]                 for (kk in seq_along(NAMES)) {
[13:33:43.226]                   name <- added[[kk]]
[13:33:43.226]                   NAME <- NAMES[[kk]]
[13:33:43.226]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.226]                     next
[13:33:43.226]                   args[[name]] <- ""
[13:33:43.226]                 }
[13:33:43.226]                 NAMES <- toupper(removed)
[13:33:43.226]                 for (kk in seq_along(NAMES)) {
[13:33:43.226]                   name <- removed[[kk]]
[13:33:43.226]                   NAME <- NAMES[[kk]]
[13:33:43.226]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.226]                     next
[13:33:43.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:43.226]                 }
[13:33:43.226]                 if (length(args) > 0) 
[13:33:43.226]                   base::do.call(base::Sys.setenv, args = args)
[13:33:43.226]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:43.226]             }
[13:33:43.226]             else {
[13:33:43.226]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:43.226]             }
[13:33:43.226]             {
[13:33:43.226]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:43.226]                   0L) {
[13:33:43.226]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:43.226]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:43.226]                   base::options(opts)
[13:33:43.226]                 }
[13:33:43.226]                 {
[13:33:43.226]                   {
[13:33:43.226]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:43.226]                     NULL
[13:33:43.226]                   }
[13:33:43.226]                   options(future.plan = NULL)
[13:33:43.226]                   if (is.na(NA_character_)) 
[13:33:43.226]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:43.226]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:43.226]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:43.226]                     .init = FALSE)
[13:33:43.226]                 }
[13:33:43.226]             }
[13:33:43.226]         }
[13:33:43.226]     })
[13:33:43.226]     if (TRUE) {
[13:33:43.226]         base::sink(type = "output", split = FALSE)
[13:33:43.226]         if (TRUE) {
[13:33:43.226]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:43.226]         }
[13:33:43.226]         else {
[13:33:43.226]             ...future.result["stdout"] <- base::list(NULL)
[13:33:43.226]         }
[13:33:43.226]         base::close(...future.stdout)
[13:33:43.226]         ...future.stdout <- NULL
[13:33:43.226]     }
[13:33:43.226]     ...future.result$conditions <- ...future.conditions
[13:33:43.226]     ...future.result$finished <- base::Sys.time()
[13:33:43.226]     ...future.result
[13:33:43.226] }
[13:33:43.279] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[13:33:43.280] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[13:33:43.280] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[13:33:43.280] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:33:43.281] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:33:43.281] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ...
[13:33:43.281] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ... DONE
[13:33:43.281] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:33:43.282] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:33:43.282] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:33:43.282] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:33:43.282] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[13:33:43.283] MultisessionFuture started
[13:33:43.283] - Launch lazy future ... done
[13:33:43.283] run() for ‘MultisessionFuture’ ... done
[13:33:43.283] Created future:
[13:33:43.283] MultisessionFuture:
[13:33:43.283] Label: ‘future_by-2’
[13:33:43.283] Expression:
[13:33:43.283] {
[13:33:43.283]     do.call(function(...) {
[13:33:43.283]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.283]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:43.283]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.283]             on.exit(options(oopts), add = TRUE)
[13:33:43.283]         }
[13:33:43.283]         {
[13:33:43.283]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:43.283]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.283]                 ...future.FUN(...future.X_jj, ...)
[13:33:43.283]             })
[13:33:43.283]         }
[13:33:43.283]     }, args = future.call.arguments)
[13:33:43.283] }
[13:33:43.283] Lazy evaluation: FALSE
[13:33:43.283] Asynchronous evaluation: TRUE
[13:33:43.283] Local evaluation: TRUE
[13:33:43.283] Environment: R_GlobalEnv
[13:33:43.283] Capture standard output: TRUE
[13:33:43.283] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:43.283] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:43.283] Packages: <none>
[13:33:43.283] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:43.283] Resolved: FALSE
[13:33:43.283] Value: <not collected>
[13:33:43.283] Conditions captured: <none>
[13:33:43.283] Early signaling: FALSE
[13:33:43.283] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:43.283] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:43.295] Chunk #2 of 2 ... DONE
[13:33:43.295] Launching 2 futures (chunks) ... DONE
[13:33:43.295] Resolving 2 futures (chunks) ...
[13:33:43.296] resolve() on list ...
[13:33:43.296]  recursive: 0
[13:33:43.296]  length: 2
[13:33:43.296] 
[13:33:43.296] receiveMessageFromWorker() for ClusterFuture ...
[13:33:43.296] - Validating connection of MultisessionFuture
[13:33:43.297] - received message: FutureResult
[13:33:43.297] - Received FutureResult
[13:33:43.297] - Erased future from FutureRegistry
[13:33:43.297] result() for ClusterFuture ...
[13:33:43.297] - result already collected: FutureResult
[13:33:43.297] result() for ClusterFuture ... done
[13:33:43.297] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:43.297] Future #1
[13:33:43.297] result() for ClusterFuture ...
[13:33:43.298] - result already collected: FutureResult
[13:33:43.298] result() for ClusterFuture ... done
[13:33:43.298] result() for ClusterFuture ...
[13:33:43.298] - result already collected: FutureResult
[13:33:43.298] result() for ClusterFuture ... done
[13:33:43.298] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:33:43.298] - nx: 2
[13:33:43.298] - relay: TRUE
[13:33:43.298] - stdout: TRUE
[13:33:43.298] - signal: TRUE
[13:33:43.299] - resignal: FALSE
[13:33:43.299] - force: TRUE
[13:33:43.299] - relayed: [n=2] FALSE, FALSE
[13:33:43.299] - queued futures: [n=2] FALSE, FALSE
[13:33:43.299]  - until=1
[13:33:43.299]  - relaying element #1
[13:33:43.299] result() for ClusterFuture ...
[13:33:43.302] - result already collected: FutureResult
[13:33:43.302] result() for ClusterFuture ... done
[13:33:43.302] result() for ClusterFuture ...
[13:33:43.302] - result already collected: FutureResult
[13:33:43.302] result() for ClusterFuture ... done
[13:33:43.303] result() for ClusterFuture ...
[13:33:43.303] - result already collected: FutureResult
[13:33:43.303] result() for ClusterFuture ... done
[13:33:43.303] result() for ClusterFuture ...
[13:33:43.303] - result already collected: FutureResult
[13:33:43.303] result() for ClusterFuture ... done
[13:33:43.303] - relayed: [n=2] TRUE, FALSE
[13:33:43.303] - queued futures: [n=2] TRUE, FALSE
[13:33:43.303] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:33:43.303]  length: 1 (resolved future 1)
[13:33:43.367] receiveMessageFromWorker() for ClusterFuture ...
[13:33:43.368] - Validating connection of MultisessionFuture
[13:33:43.368] - received message: FutureResult
[13:33:43.368] - Received FutureResult
[13:33:43.368] - Erased future from FutureRegistry
[13:33:43.369] result() for ClusterFuture ...
[13:33:43.369] - result already collected: FutureResult
[13:33:43.369] result() for ClusterFuture ... done
[13:33:43.369] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:43.369] Future #2
[13:33:43.369] result() for ClusterFuture ...
[13:33:43.369] - result already collected: FutureResult
[13:33:43.369] result() for ClusterFuture ... done
[13:33:43.369] result() for ClusterFuture ...
[13:33:43.369] - result already collected: FutureResult
[13:33:43.369] result() for ClusterFuture ... done
[13:33:43.370] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:33:43.370] - nx: 2
[13:33:43.370] - relay: TRUE
[13:33:43.370] - stdout: TRUE
[13:33:43.370] - signal: TRUE
[13:33:43.370] - resignal: FALSE
[13:33:43.370] - force: TRUE
[13:33:43.370] - relayed: [n=2] TRUE, FALSE
[13:33:43.370] - queued futures: [n=2] TRUE, FALSE
[13:33:43.370]  - until=2
[13:33:43.370]  - relaying element #2
[13:33:43.371] result() for ClusterFuture ...
[13:33:43.371] - result already collected: FutureResult
[13:33:43.371] result() for ClusterFuture ... done
[13:33:43.371] result() for ClusterFuture ...
[13:33:43.371] - result already collected: FutureResult
[13:33:43.371] result() for ClusterFuture ... done
[13:33:43.371] result() for ClusterFuture ...
[13:33:43.371] - result already collected: FutureResult
[13:33:43.371] result() for ClusterFuture ... done
[13:33:43.371] result() for ClusterFuture ...
[13:33:43.371] - result already collected: FutureResult
[13:33:43.372] result() for ClusterFuture ... done
[13:33:43.372] - relayed: [n=2] TRUE, TRUE
[13:33:43.372] - queued futures: [n=2] TRUE, TRUE
[13:33:43.372] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:33:43.372]  length: 0 (resolved future 2)
[13:33:43.372] Relaying remaining futures
[13:33:43.372] signalConditionsASAP(NULL, pos=0) ...
[13:33:43.372] - nx: 2
[13:33:43.372] - relay: TRUE
[13:33:43.372] - stdout: TRUE
[13:33:43.372] - signal: TRUE
[13:33:43.372] - resignal: FALSE
[13:33:43.373] - force: TRUE
[13:33:43.373] - relayed: [n=2] TRUE, TRUE
[13:33:43.373] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:43.373] - relayed: [n=2] TRUE, TRUE
[13:33:43.373] - queued futures: [n=2] TRUE, TRUE
[13:33:43.373] signalConditionsASAP(NULL, pos=0) ... done
[13:33:43.373] resolve() on list ... DONE
[13:33:43.373] result() for ClusterFuture ...
[13:33:43.373] - result already collected: FutureResult
[13:33:43.373] result() for ClusterFuture ... done
[13:33:43.373] result() for ClusterFuture ...
[13:33:43.373] - result already collected: FutureResult
[13:33:43.374] result() for ClusterFuture ... done
[13:33:43.374] result() for ClusterFuture ...
[13:33:43.374] - result already collected: FutureResult
[13:33:43.374] result() for ClusterFuture ... done
[13:33:43.374] result() for ClusterFuture ...
[13:33:43.374] - result already collected: FutureResult
[13:33:43.374] result() for ClusterFuture ... done
[13:33:43.374]  - Number of value chunks collected: 2
[13:33:43.374] Resolving 2 futures (chunks) ... DONE
[13:33:43.374] Reducing values from 2 chunks ...
[13:33:43.374]  - Number of values collected after concatenation: 3
[13:33:43.375]  - Number of values expected: 3
[13:33:43.375] Reducing values from 2 chunks ... DONE
[13:33:43.375] future_lapply() ... DONE
[13:33:43.375] future_by_internal() ... DONE
[13:33:43.375] future_by_internal() ...
[13:33:43.376] future_lapply() ...
[13:33:43.380] Number of chunks: 2
[13:33:43.380] getGlobalsAndPackagesXApply() ...
[13:33:43.380]  - future.globals: TRUE
[13:33:43.380] getGlobalsAndPackages() ...
[13:33:43.380] Searching for globals...
[13:33:43.381] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:43.381] Searching for globals ... DONE
[13:33:43.381] Resolving globals: FALSE
[13:33:43.382] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:43.382] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:43.382] - globals: [1] ‘FUN’
[13:33:43.382] 
[13:33:43.382] getGlobalsAndPackages() ... DONE
[13:33:43.382]  - globals found/used: [n=1] ‘FUN’
[13:33:43.383]  - needed namespaces: [n=0] 
[13:33:43.383] Finding globals ... DONE
[13:33:43.383]  - use_args: TRUE
[13:33:43.383]  - Getting '...' globals ...
[13:33:43.383] resolve() on list ...
[13:33:43.383]  recursive: 0
[13:33:43.383]  length: 1
[13:33:43.383]  elements: ‘...’
[13:33:43.384]  length: 0 (resolved future 1)
[13:33:43.384] resolve() on list ... DONE
[13:33:43.384]    - '...' content: [n=1] ‘digits’
[13:33:43.384] List of 1
[13:33:43.384]  $ ...:List of 1
[13:33:43.384]   ..$ digits: int 2
[13:33:43.384]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:43.384]  - attr(*, "where")=List of 1
[13:33:43.384]   ..$ ...:<environment: 0x55cb84388008> 
[13:33:43.384]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:43.384]  - attr(*, "resolved")= logi TRUE
[13:33:43.384]  - attr(*, "total_size")= num NA
[13:33:43.387]  - Getting '...' globals ... DONE
[13:33:43.387] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:43.387] List of 2
[13:33:43.387]  $ ...future.FUN:function (object, ...)  
[13:33:43.387]  $ ...          :List of 1
[13:33:43.387]   ..$ digits: int 2
[13:33:43.387]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:43.387]  - attr(*, "where")=List of 2
[13:33:43.387]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:43.387]   ..$ ...          :<environment: 0x55cb84388008> 
[13:33:43.387]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:43.387]  - attr(*, "resolved")= logi FALSE
[13:33:43.387]  - attr(*, "total_size")= num 1296
[13:33:43.390] Packages to be attached in all futures: [n=0] 
[13:33:43.390] getGlobalsAndPackagesXApply() ... DONE
[13:33:43.390] Number of futures (= number of chunks): 2
[13:33:43.390] Launching 2 futures (chunks) ...
[13:33:43.390] Chunk #1 of 2 ...
[13:33:43.391]  - Finding globals in 'X' for chunk #1 ...
[13:33:43.391] getGlobalsAndPackages() ...
[13:33:43.391] Searching for globals...
[13:33:43.391] 
[13:33:43.391] Searching for globals ... DONE
[13:33:43.391] - globals: [0] <none>
[13:33:43.391] getGlobalsAndPackages() ... DONE
[13:33:43.391]    + additional globals found: [n=0] 
[13:33:43.391]    + additional namespaces needed: [n=0] 
[13:33:43.392]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:43.392]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:43.392]  - seeds: <none>
[13:33:43.392]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.392] getGlobalsAndPackages() ...
[13:33:43.392] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.392] Resolving globals: FALSE
[13:33:43.392] Tweak future expression to call with '...' arguments ...
[13:33:43.392] {
[13:33:43.392]     do.call(function(...) {
[13:33:43.392]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.392]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:43.392]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.392]             on.exit(options(oopts), add = TRUE)
[13:33:43.392]         }
[13:33:43.392]         {
[13:33:43.392]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:43.392]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.392]                 ...future.FUN(...future.X_jj, ...)
[13:33:43.392]             })
[13:33:43.392]         }
[13:33:43.392]     }, args = future.call.arguments)
[13:33:43.392] }
[13:33:43.393] Tweak future expression to call with '...' arguments ... DONE
[13:33:43.393] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.393] 
[13:33:43.393] getGlobalsAndPackages() ... DONE
[13:33:43.393] run() for ‘Future’ ...
[13:33:43.393] - state: ‘created’
[13:33:43.394] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:43.407] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:43.407] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:43.408]   - Field: ‘node’
[13:33:43.408]   - Field: ‘label’
[13:33:43.408]   - Field: ‘local’
[13:33:43.408]   - Field: ‘owner’
[13:33:43.408]   - Field: ‘envir’
[13:33:43.408]   - Field: ‘workers’
[13:33:43.408]   - Field: ‘packages’
[13:33:43.408]   - Field: ‘gc’
[13:33:43.408]   - Field: ‘conditions’
[13:33:43.408]   - Field: ‘persistent’
[13:33:43.409]   - Field: ‘expr’
[13:33:43.409]   - Field: ‘uuid’
[13:33:43.409]   - Field: ‘seed’
[13:33:43.409]   - Field: ‘version’
[13:33:43.409]   - Field: ‘result’
[13:33:43.409]   - Field: ‘asynchronous’
[13:33:43.409]   - Field: ‘calls’
[13:33:43.409]   - Field: ‘globals’
[13:33:43.409]   - Field: ‘stdout’
[13:33:43.409]   - Field: ‘earlySignal’
[13:33:43.409]   - Field: ‘lazy’
[13:33:43.410]   - Field: ‘state’
[13:33:43.410] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:43.410] - Launch lazy future ...
[13:33:43.410] Packages needed by the future expression (n = 0): <none>
[13:33:43.410] Packages needed by future strategies (n = 0): <none>
[13:33:43.411] {
[13:33:43.411]     {
[13:33:43.411]         {
[13:33:43.411]             ...future.startTime <- base::Sys.time()
[13:33:43.411]             {
[13:33:43.411]                 {
[13:33:43.411]                   {
[13:33:43.411]                     {
[13:33:43.411]                       base::local({
[13:33:43.411]                         has_future <- base::requireNamespace("future", 
[13:33:43.411]                           quietly = TRUE)
[13:33:43.411]                         if (has_future) {
[13:33:43.411]                           ns <- base::getNamespace("future")
[13:33:43.411]                           version <- ns[[".package"]][["version"]]
[13:33:43.411]                           if (is.null(version)) 
[13:33:43.411]                             version <- utils::packageVersion("future")
[13:33:43.411]                         }
[13:33:43.411]                         else {
[13:33:43.411]                           version <- NULL
[13:33:43.411]                         }
[13:33:43.411]                         if (!has_future || version < "1.8.0") {
[13:33:43.411]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:43.411]                             "", base::R.version$version.string), 
[13:33:43.411]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:43.411]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:43.411]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:43.411]                               "release", "version")], collapse = " "), 
[13:33:43.411]                             hostname = base::Sys.info()[["nodename"]])
[13:33:43.411]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:43.411]                             info)
[13:33:43.411]                           info <- base::paste(info, collapse = "; ")
[13:33:43.411]                           if (!has_future) {
[13:33:43.411]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:43.411]                               info)
[13:33:43.411]                           }
[13:33:43.411]                           else {
[13:33:43.411]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:43.411]                               info, version)
[13:33:43.411]                           }
[13:33:43.411]                           base::stop(msg)
[13:33:43.411]                         }
[13:33:43.411]                       })
[13:33:43.411]                     }
[13:33:43.411]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:43.411]                     base::options(mc.cores = 1L)
[13:33:43.411]                   }
[13:33:43.411]                   ...future.strategy.old <- future::plan("list")
[13:33:43.411]                   options(future.plan = NULL)
[13:33:43.411]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:43.411]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:43.411]                 }
[13:33:43.411]                 ...future.workdir <- getwd()
[13:33:43.411]             }
[13:33:43.411]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:43.411]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:43.411]         }
[13:33:43.411]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:43.411]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:43.411]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:43.411]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:43.411]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:43.411]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:43.411]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:43.411]             base::names(...future.oldOptions))
[13:33:43.411]     }
[13:33:43.411]     if (FALSE) {
[13:33:43.411]     }
[13:33:43.411]     else {
[13:33:43.411]         if (TRUE) {
[13:33:43.411]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:43.411]                 open = "w")
[13:33:43.411]         }
[13:33:43.411]         else {
[13:33:43.411]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:43.411]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:43.411]         }
[13:33:43.411]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:43.411]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:43.411]             base::sink(type = "output", split = FALSE)
[13:33:43.411]             base::close(...future.stdout)
[13:33:43.411]         }, add = TRUE)
[13:33:43.411]     }
[13:33:43.411]     ...future.frame <- base::sys.nframe()
[13:33:43.411]     ...future.conditions <- base::list()
[13:33:43.411]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:43.411]     if (FALSE) {
[13:33:43.411]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:43.411]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:43.411]     }
[13:33:43.411]     ...future.result <- base::tryCatch({
[13:33:43.411]         base::withCallingHandlers({
[13:33:43.411]             ...future.value <- base::withVisible(base::local({
[13:33:43.411]                 ...future.makeSendCondition <- base::local({
[13:33:43.411]                   sendCondition <- NULL
[13:33:43.411]                   function(frame = 1L) {
[13:33:43.411]                     if (is.function(sendCondition)) 
[13:33:43.411]                       return(sendCondition)
[13:33:43.411]                     ns <- getNamespace("parallel")
[13:33:43.411]                     if (exists("sendData", mode = "function", 
[13:33:43.411]                       envir = ns)) {
[13:33:43.411]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:43.411]                         envir = ns)
[13:33:43.411]                       envir <- sys.frame(frame)
[13:33:43.411]                       master <- NULL
[13:33:43.411]                       while (!identical(envir, .GlobalEnv) && 
[13:33:43.411]                         !identical(envir, emptyenv())) {
[13:33:43.411]                         if (exists("master", mode = "list", envir = envir, 
[13:33:43.411]                           inherits = FALSE)) {
[13:33:43.411]                           master <- get("master", mode = "list", 
[13:33:43.411]                             envir = envir, inherits = FALSE)
[13:33:43.411]                           if (inherits(master, c("SOCKnode", 
[13:33:43.411]                             "SOCK0node"))) {
[13:33:43.411]                             sendCondition <<- function(cond) {
[13:33:43.411]                               data <- list(type = "VALUE", value = cond, 
[13:33:43.411]                                 success = TRUE)
[13:33:43.411]                               parallel_sendData(master, data)
[13:33:43.411]                             }
[13:33:43.411]                             return(sendCondition)
[13:33:43.411]                           }
[13:33:43.411]                         }
[13:33:43.411]                         frame <- frame + 1L
[13:33:43.411]                         envir <- sys.frame(frame)
[13:33:43.411]                       }
[13:33:43.411]                     }
[13:33:43.411]                     sendCondition <<- function(cond) NULL
[13:33:43.411]                   }
[13:33:43.411]                 })
[13:33:43.411]                 withCallingHandlers({
[13:33:43.411]                   {
[13:33:43.411]                     do.call(function(...) {
[13:33:43.411]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.411]                       if (!identical(...future.globals.maxSize.org, 
[13:33:43.411]                         ...future.globals.maxSize)) {
[13:33:43.411]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.411]                         on.exit(options(oopts), add = TRUE)
[13:33:43.411]                       }
[13:33:43.411]                       {
[13:33:43.411]                         lapply(seq_along(...future.elements_ii), 
[13:33:43.411]                           FUN = function(jj) {
[13:33:43.411]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.411]                             ...future.FUN(...future.X_jj, ...)
[13:33:43.411]                           })
[13:33:43.411]                       }
[13:33:43.411]                     }, args = future.call.arguments)
[13:33:43.411]                   }
[13:33:43.411]                 }, immediateCondition = function(cond) {
[13:33:43.411]                   sendCondition <- ...future.makeSendCondition()
[13:33:43.411]                   sendCondition(cond)
[13:33:43.411]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.411]                   {
[13:33:43.411]                     inherits <- base::inherits
[13:33:43.411]                     invokeRestart <- base::invokeRestart
[13:33:43.411]                     is.null <- base::is.null
[13:33:43.411]                     muffled <- FALSE
[13:33:43.411]                     if (inherits(cond, "message")) {
[13:33:43.411]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:43.411]                       if (muffled) 
[13:33:43.411]                         invokeRestart("muffleMessage")
[13:33:43.411]                     }
[13:33:43.411]                     else if (inherits(cond, "warning")) {
[13:33:43.411]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:43.411]                       if (muffled) 
[13:33:43.411]                         invokeRestart("muffleWarning")
[13:33:43.411]                     }
[13:33:43.411]                     else if (inherits(cond, "condition")) {
[13:33:43.411]                       if (!is.null(pattern)) {
[13:33:43.411]                         computeRestarts <- base::computeRestarts
[13:33:43.411]                         grepl <- base::grepl
[13:33:43.411]                         restarts <- computeRestarts(cond)
[13:33:43.411]                         for (restart in restarts) {
[13:33:43.411]                           name <- restart$name
[13:33:43.411]                           if (is.null(name)) 
[13:33:43.411]                             next
[13:33:43.411]                           if (!grepl(pattern, name)) 
[13:33:43.411]                             next
[13:33:43.411]                           invokeRestart(restart)
[13:33:43.411]                           muffled <- TRUE
[13:33:43.411]                           break
[13:33:43.411]                         }
[13:33:43.411]                       }
[13:33:43.411]                     }
[13:33:43.411]                     invisible(muffled)
[13:33:43.411]                   }
[13:33:43.411]                   muffleCondition(cond)
[13:33:43.411]                 })
[13:33:43.411]             }))
[13:33:43.411]             future::FutureResult(value = ...future.value$value, 
[13:33:43.411]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:43.411]                   ...future.rng), globalenv = if (FALSE) 
[13:33:43.411]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:43.411]                     ...future.globalenv.names))
[13:33:43.411]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:43.411]         }, condition = base::local({
[13:33:43.411]             c <- base::c
[13:33:43.411]             inherits <- base::inherits
[13:33:43.411]             invokeRestart <- base::invokeRestart
[13:33:43.411]             length <- base::length
[13:33:43.411]             list <- base::list
[13:33:43.411]             seq.int <- base::seq.int
[13:33:43.411]             signalCondition <- base::signalCondition
[13:33:43.411]             sys.calls <- base::sys.calls
[13:33:43.411]             `[[` <- base::`[[`
[13:33:43.411]             `+` <- base::`+`
[13:33:43.411]             `<<-` <- base::`<<-`
[13:33:43.411]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:43.411]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:43.411]                   3L)]
[13:33:43.411]             }
[13:33:43.411]             function(cond) {
[13:33:43.411]                 is_error <- inherits(cond, "error")
[13:33:43.411]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:43.411]                   NULL)
[13:33:43.411]                 if (is_error) {
[13:33:43.411]                   sessionInformation <- function() {
[13:33:43.411]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:43.411]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:43.411]                       search = base::search(), system = base::Sys.info())
[13:33:43.411]                   }
[13:33:43.411]                   ...future.conditions[[length(...future.conditions) + 
[13:33:43.411]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:43.411]                     cond$call), session = sessionInformation(), 
[13:33:43.411]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:43.411]                   signalCondition(cond)
[13:33:43.411]                 }
[13:33:43.411]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:43.411]                 "immediateCondition"))) {
[13:33:43.411]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:43.411]                   ...future.conditions[[length(...future.conditions) + 
[13:33:43.411]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:43.411]                   if (TRUE && !signal) {
[13:33:43.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.411]                     {
[13:33:43.411]                       inherits <- base::inherits
[13:33:43.411]                       invokeRestart <- base::invokeRestart
[13:33:43.411]                       is.null <- base::is.null
[13:33:43.411]                       muffled <- FALSE
[13:33:43.411]                       if (inherits(cond, "message")) {
[13:33:43.411]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:43.411]                         if (muffled) 
[13:33:43.411]                           invokeRestart("muffleMessage")
[13:33:43.411]                       }
[13:33:43.411]                       else if (inherits(cond, "warning")) {
[13:33:43.411]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:43.411]                         if (muffled) 
[13:33:43.411]                           invokeRestart("muffleWarning")
[13:33:43.411]                       }
[13:33:43.411]                       else if (inherits(cond, "condition")) {
[13:33:43.411]                         if (!is.null(pattern)) {
[13:33:43.411]                           computeRestarts <- base::computeRestarts
[13:33:43.411]                           grepl <- base::grepl
[13:33:43.411]                           restarts <- computeRestarts(cond)
[13:33:43.411]                           for (restart in restarts) {
[13:33:43.411]                             name <- restart$name
[13:33:43.411]                             if (is.null(name)) 
[13:33:43.411]                               next
[13:33:43.411]                             if (!grepl(pattern, name)) 
[13:33:43.411]                               next
[13:33:43.411]                             invokeRestart(restart)
[13:33:43.411]                             muffled <- TRUE
[13:33:43.411]                             break
[13:33:43.411]                           }
[13:33:43.411]                         }
[13:33:43.411]                       }
[13:33:43.411]                       invisible(muffled)
[13:33:43.411]                     }
[13:33:43.411]                     muffleCondition(cond, pattern = "^muffle")
[13:33:43.411]                   }
[13:33:43.411]                 }
[13:33:43.411]                 else {
[13:33:43.411]                   if (TRUE) {
[13:33:43.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.411]                     {
[13:33:43.411]                       inherits <- base::inherits
[13:33:43.411]                       invokeRestart <- base::invokeRestart
[13:33:43.411]                       is.null <- base::is.null
[13:33:43.411]                       muffled <- FALSE
[13:33:43.411]                       if (inherits(cond, "message")) {
[13:33:43.411]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:43.411]                         if (muffled) 
[13:33:43.411]                           invokeRestart("muffleMessage")
[13:33:43.411]                       }
[13:33:43.411]                       else if (inherits(cond, "warning")) {
[13:33:43.411]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:43.411]                         if (muffled) 
[13:33:43.411]                           invokeRestart("muffleWarning")
[13:33:43.411]                       }
[13:33:43.411]                       else if (inherits(cond, "condition")) {
[13:33:43.411]                         if (!is.null(pattern)) {
[13:33:43.411]                           computeRestarts <- base::computeRestarts
[13:33:43.411]                           grepl <- base::grepl
[13:33:43.411]                           restarts <- computeRestarts(cond)
[13:33:43.411]                           for (restart in restarts) {
[13:33:43.411]                             name <- restart$name
[13:33:43.411]                             if (is.null(name)) 
[13:33:43.411]                               next
[13:33:43.411]                             if (!grepl(pattern, name)) 
[13:33:43.411]                               next
[13:33:43.411]                             invokeRestart(restart)
[13:33:43.411]                             muffled <- TRUE
[13:33:43.411]                             break
[13:33:43.411]                           }
[13:33:43.411]                         }
[13:33:43.411]                       }
[13:33:43.411]                       invisible(muffled)
[13:33:43.411]                     }
[13:33:43.411]                     muffleCondition(cond, pattern = "^muffle")
[13:33:43.411]                   }
[13:33:43.411]                 }
[13:33:43.411]             }
[13:33:43.411]         }))
[13:33:43.411]     }, error = function(ex) {
[13:33:43.411]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:43.411]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:43.411]                 ...future.rng), started = ...future.startTime, 
[13:33:43.411]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:43.411]             version = "1.8"), class = "FutureResult")
[13:33:43.411]     }, finally = {
[13:33:43.411]         if (!identical(...future.workdir, getwd())) 
[13:33:43.411]             setwd(...future.workdir)
[13:33:43.411]         {
[13:33:43.411]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:43.411]                 ...future.oldOptions$nwarnings <- NULL
[13:33:43.411]             }
[13:33:43.411]             base::options(...future.oldOptions)
[13:33:43.411]             if (.Platform$OS.type == "windows") {
[13:33:43.411]                 old_names <- names(...future.oldEnvVars)
[13:33:43.411]                 envs <- base::Sys.getenv()
[13:33:43.411]                 names <- names(envs)
[13:33:43.411]                 common <- intersect(names, old_names)
[13:33:43.411]                 added <- setdiff(names, old_names)
[13:33:43.411]                 removed <- setdiff(old_names, names)
[13:33:43.411]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:43.411]                   envs[common]]
[13:33:43.411]                 NAMES <- toupper(changed)
[13:33:43.411]                 args <- list()
[13:33:43.411]                 for (kk in seq_along(NAMES)) {
[13:33:43.411]                   name <- changed[[kk]]
[13:33:43.411]                   NAME <- NAMES[[kk]]
[13:33:43.411]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.411]                     next
[13:33:43.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:43.411]                 }
[13:33:43.411]                 NAMES <- toupper(added)
[13:33:43.411]                 for (kk in seq_along(NAMES)) {
[13:33:43.411]                   name <- added[[kk]]
[13:33:43.411]                   NAME <- NAMES[[kk]]
[13:33:43.411]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.411]                     next
[13:33:43.411]                   args[[name]] <- ""
[13:33:43.411]                 }
[13:33:43.411]                 NAMES <- toupper(removed)
[13:33:43.411]                 for (kk in seq_along(NAMES)) {
[13:33:43.411]                   name <- removed[[kk]]
[13:33:43.411]                   NAME <- NAMES[[kk]]
[13:33:43.411]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.411]                     next
[13:33:43.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:43.411]                 }
[13:33:43.411]                 if (length(args) > 0) 
[13:33:43.411]                   base::do.call(base::Sys.setenv, args = args)
[13:33:43.411]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:43.411]             }
[13:33:43.411]             else {
[13:33:43.411]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:43.411]             }
[13:33:43.411]             {
[13:33:43.411]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:43.411]                   0L) {
[13:33:43.411]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:43.411]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:43.411]                   base::options(opts)
[13:33:43.411]                 }
[13:33:43.411]                 {
[13:33:43.411]                   {
[13:33:43.411]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:43.411]                     NULL
[13:33:43.411]                   }
[13:33:43.411]                   options(future.plan = NULL)
[13:33:43.411]                   if (is.na(NA_character_)) 
[13:33:43.411]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:43.411]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:43.411]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:43.411]                     .init = FALSE)
[13:33:43.411]                 }
[13:33:43.411]             }
[13:33:43.411]         }
[13:33:43.411]     })
[13:33:43.411]     if (TRUE) {
[13:33:43.411]         base::sink(type = "output", split = FALSE)
[13:33:43.411]         if (TRUE) {
[13:33:43.411]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:43.411]         }
[13:33:43.411]         else {
[13:33:43.411]             ...future.result["stdout"] <- base::list(NULL)
[13:33:43.411]         }
[13:33:43.411]         base::close(...future.stdout)
[13:33:43.411]         ...future.stdout <- NULL
[13:33:43.411]     }
[13:33:43.411]     ...future.result$conditions <- ...future.conditions
[13:33:43.411]     ...future.result$finished <- base::Sys.time()
[13:33:43.411]     ...future.result
[13:33:43.411] }
[13:33:43.413] Exporting 5 global objects (1.27 KiB) to cluster node #1 ...
[13:33:43.413] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[13:33:43.414] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[13:33:43.414] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[13:33:43.414] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[13:33:43.415] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ...
[13:33:43.415] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ... DONE
[13:33:43.415] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:33:43.415] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:33:43.415] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:33:43.416] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:33:43.416] Exporting 5 global objects (1.27 KiB) to cluster node #1 ... DONE
[13:33:43.416] MultisessionFuture started
[13:33:43.417] - Launch lazy future ... done
[13:33:43.417] run() for ‘MultisessionFuture’ ... done
[13:33:43.417] Created future:
[13:33:43.417] MultisessionFuture:
[13:33:43.417] Label: ‘future_by-1’
[13:33:43.417] Expression:
[13:33:43.417] {
[13:33:43.417]     do.call(function(...) {
[13:33:43.417]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.417]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:43.417]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.417]             on.exit(options(oopts), add = TRUE)
[13:33:43.417]         }
[13:33:43.417]         {
[13:33:43.417]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:43.417]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.417]                 ...future.FUN(...future.X_jj, ...)
[13:33:43.417]             })
[13:33:43.417]         }
[13:33:43.417]     }, args = future.call.arguments)
[13:33:43.417] }
[13:33:43.417] Lazy evaluation: FALSE
[13:33:43.417] Asynchronous evaluation: TRUE
[13:33:43.417] Local evaluation: TRUE
[13:33:43.417] Environment: R_GlobalEnv
[13:33:43.417] Capture standard output: TRUE
[13:33:43.417] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:43.417] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:43.417] Packages: <none>
[13:33:43.417] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:43.417] Resolved: FALSE
[13:33:43.417] Value: <not collected>
[13:33:43.417] Conditions captured: <none>
[13:33:43.417] Early signaling: FALSE
[13:33:43.417] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:43.417] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:43.429] Chunk #1 of 2 ... DONE
[13:33:43.429] Chunk #2 of 2 ...
[13:33:43.429]  - Finding globals in 'X' for chunk #2 ...
[13:33:43.429] getGlobalsAndPackages() ...
[13:33:43.429] Searching for globals...
[13:33:43.429] 
[13:33:43.429] Searching for globals ... DONE
[13:33:43.429] - globals: [0] <none>
[13:33:43.429] getGlobalsAndPackages() ... DONE
[13:33:43.430]    + additional globals found: [n=0] 
[13:33:43.430]    + additional namespaces needed: [n=0] 
[13:33:43.430]  - Finding globals in 'X' for chunk #2 ... DONE
[13:33:43.430]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:43.430]  - seeds: <none>
[13:33:43.430]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.430] getGlobalsAndPackages() ...
[13:33:43.430] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.430] Resolving globals: FALSE
[13:33:43.430] Tweak future expression to call with '...' arguments ...
[13:33:43.431] {
[13:33:43.431]     do.call(function(...) {
[13:33:43.431]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.431]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:43.431]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.431]             on.exit(options(oopts), add = TRUE)
[13:33:43.431]         }
[13:33:43.431]         {
[13:33:43.431]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:43.431]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.431]                 ...future.FUN(...future.X_jj, ...)
[13:33:43.431]             })
[13:33:43.431]         }
[13:33:43.431]     }, args = future.call.arguments)
[13:33:43.431] }
[13:33:43.431] Tweak future expression to call with '...' arguments ... DONE
[13:33:43.431] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.431] 
[13:33:43.431] getGlobalsAndPackages() ... DONE
[13:33:43.432] run() for ‘Future’ ...
[13:33:43.432] - state: ‘created’
[13:33:43.432] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:43.445] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:43.445] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:43.445]   - Field: ‘node’
[13:33:43.445]   - Field: ‘label’
[13:33:43.445]   - Field: ‘local’
[13:33:43.446]   - Field: ‘owner’
[13:33:43.446]   - Field: ‘envir’
[13:33:43.446]   - Field: ‘workers’
[13:33:43.446]   - Field: ‘packages’
[13:33:43.446]   - Field: ‘gc’
[13:33:43.446]   - Field: ‘conditions’
[13:33:43.446]   - Field: ‘persistent’
[13:33:43.446]   - Field: ‘expr’
[13:33:43.446]   - Field: ‘uuid’
[13:33:43.446]   - Field: ‘seed’
[13:33:43.446]   - Field: ‘version’
[13:33:43.447]   - Field: ‘result’
[13:33:43.447]   - Field: ‘asynchronous’
[13:33:43.447]   - Field: ‘calls’
[13:33:43.447]   - Field: ‘globals’
[13:33:43.447]   - Field: ‘stdout’
[13:33:43.447]   - Field: ‘earlySignal’
[13:33:43.447]   - Field: ‘lazy’
[13:33:43.447]   - Field: ‘state’
[13:33:43.447] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:43.447] - Launch lazy future ...
[13:33:43.448] Packages needed by the future expression (n = 0): <none>
[13:33:43.448] Packages needed by future strategies (n = 0): <none>
[13:33:43.448] {
[13:33:43.448]     {
[13:33:43.448]         {
[13:33:43.448]             ...future.startTime <- base::Sys.time()
[13:33:43.448]             {
[13:33:43.448]                 {
[13:33:43.448]                   {
[13:33:43.448]                     {
[13:33:43.448]                       base::local({
[13:33:43.448]                         has_future <- base::requireNamespace("future", 
[13:33:43.448]                           quietly = TRUE)
[13:33:43.448]                         if (has_future) {
[13:33:43.448]                           ns <- base::getNamespace("future")
[13:33:43.448]                           version <- ns[[".package"]][["version"]]
[13:33:43.448]                           if (is.null(version)) 
[13:33:43.448]                             version <- utils::packageVersion("future")
[13:33:43.448]                         }
[13:33:43.448]                         else {
[13:33:43.448]                           version <- NULL
[13:33:43.448]                         }
[13:33:43.448]                         if (!has_future || version < "1.8.0") {
[13:33:43.448]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:43.448]                             "", base::R.version$version.string), 
[13:33:43.448]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:43.448]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:43.448]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:43.448]                               "release", "version")], collapse = " "), 
[13:33:43.448]                             hostname = base::Sys.info()[["nodename"]])
[13:33:43.448]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:43.448]                             info)
[13:33:43.448]                           info <- base::paste(info, collapse = "; ")
[13:33:43.448]                           if (!has_future) {
[13:33:43.448]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:43.448]                               info)
[13:33:43.448]                           }
[13:33:43.448]                           else {
[13:33:43.448]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:43.448]                               info, version)
[13:33:43.448]                           }
[13:33:43.448]                           base::stop(msg)
[13:33:43.448]                         }
[13:33:43.448]                       })
[13:33:43.448]                     }
[13:33:43.448]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:43.448]                     base::options(mc.cores = 1L)
[13:33:43.448]                   }
[13:33:43.448]                   ...future.strategy.old <- future::plan("list")
[13:33:43.448]                   options(future.plan = NULL)
[13:33:43.448]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:43.448]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:43.448]                 }
[13:33:43.448]                 ...future.workdir <- getwd()
[13:33:43.448]             }
[13:33:43.448]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:43.448]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:43.448]         }
[13:33:43.448]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:43.448]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:43.448]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:43.448]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:43.448]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:43.448]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:43.448]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:43.448]             base::names(...future.oldOptions))
[13:33:43.448]     }
[13:33:43.448]     if (FALSE) {
[13:33:43.448]     }
[13:33:43.448]     else {
[13:33:43.448]         if (TRUE) {
[13:33:43.448]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:43.448]                 open = "w")
[13:33:43.448]         }
[13:33:43.448]         else {
[13:33:43.448]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:43.448]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:43.448]         }
[13:33:43.448]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:43.448]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:43.448]             base::sink(type = "output", split = FALSE)
[13:33:43.448]             base::close(...future.stdout)
[13:33:43.448]         }, add = TRUE)
[13:33:43.448]     }
[13:33:43.448]     ...future.frame <- base::sys.nframe()
[13:33:43.448]     ...future.conditions <- base::list()
[13:33:43.448]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:43.448]     if (FALSE) {
[13:33:43.448]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:43.448]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:43.448]     }
[13:33:43.448]     ...future.result <- base::tryCatch({
[13:33:43.448]         base::withCallingHandlers({
[13:33:43.448]             ...future.value <- base::withVisible(base::local({
[13:33:43.448]                 ...future.makeSendCondition <- base::local({
[13:33:43.448]                   sendCondition <- NULL
[13:33:43.448]                   function(frame = 1L) {
[13:33:43.448]                     if (is.function(sendCondition)) 
[13:33:43.448]                       return(sendCondition)
[13:33:43.448]                     ns <- getNamespace("parallel")
[13:33:43.448]                     if (exists("sendData", mode = "function", 
[13:33:43.448]                       envir = ns)) {
[13:33:43.448]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:43.448]                         envir = ns)
[13:33:43.448]                       envir <- sys.frame(frame)
[13:33:43.448]                       master <- NULL
[13:33:43.448]                       while (!identical(envir, .GlobalEnv) && 
[13:33:43.448]                         !identical(envir, emptyenv())) {
[13:33:43.448]                         if (exists("master", mode = "list", envir = envir, 
[13:33:43.448]                           inherits = FALSE)) {
[13:33:43.448]                           master <- get("master", mode = "list", 
[13:33:43.448]                             envir = envir, inherits = FALSE)
[13:33:43.448]                           if (inherits(master, c("SOCKnode", 
[13:33:43.448]                             "SOCK0node"))) {
[13:33:43.448]                             sendCondition <<- function(cond) {
[13:33:43.448]                               data <- list(type = "VALUE", value = cond, 
[13:33:43.448]                                 success = TRUE)
[13:33:43.448]                               parallel_sendData(master, data)
[13:33:43.448]                             }
[13:33:43.448]                             return(sendCondition)
[13:33:43.448]                           }
[13:33:43.448]                         }
[13:33:43.448]                         frame <- frame + 1L
[13:33:43.448]                         envir <- sys.frame(frame)
[13:33:43.448]                       }
[13:33:43.448]                     }
[13:33:43.448]                     sendCondition <<- function(cond) NULL
[13:33:43.448]                   }
[13:33:43.448]                 })
[13:33:43.448]                 withCallingHandlers({
[13:33:43.448]                   {
[13:33:43.448]                     do.call(function(...) {
[13:33:43.448]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.448]                       if (!identical(...future.globals.maxSize.org, 
[13:33:43.448]                         ...future.globals.maxSize)) {
[13:33:43.448]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.448]                         on.exit(options(oopts), add = TRUE)
[13:33:43.448]                       }
[13:33:43.448]                       {
[13:33:43.448]                         lapply(seq_along(...future.elements_ii), 
[13:33:43.448]                           FUN = function(jj) {
[13:33:43.448]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.448]                             ...future.FUN(...future.X_jj, ...)
[13:33:43.448]                           })
[13:33:43.448]                       }
[13:33:43.448]                     }, args = future.call.arguments)
[13:33:43.448]                   }
[13:33:43.448]                 }, immediateCondition = function(cond) {
[13:33:43.448]                   sendCondition <- ...future.makeSendCondition()
[13:33:43.448]                   sendCondition(cond)
[13:33:43.448]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.448]                   {
[13:33:43.448]                     inherits <- base::inherits
[13:33:43.448]                     invokeRestart <- base::invokeRestart
[13:33:43.448]                     is.null <- base::is.null
[13:33:43.448]                     muffled <- FALSE
[13:33:43.448]                     if (inherits(cond, "message")) {
[13:33:43.448]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:43.448]                       if (muffled) 
[13:33:43.448]                         invokeRestart("muffleMessage")
[13:33:43.448]                     }
[13:33:43.448]                     else if (inherits(cond, "warning")) {
[13:33:43.448]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:43.448]                       if (muffled) 
[13:33:43.448]                         invokeRestart("muffleWarning")
[13:33:43.448]                     }
[13:33:43.448]                     else if (inherits(cond, "condition")) {
[13:33:43.448]                       if (!is.null(pattern)) {
[13:33:43.448]                         computeRestarts <- base::computeRestarts
[13:33:43.448]                         grepl <- base::grepl
[13:33:43.448]                         restarts <- computeRestarts(cond)
[13:33:43.448]                         for (restart in restarts) {
[13:33:43.448]                           name <- restart$name
[13:33:43.448]                           if (is.null(name)) 
[13:33:43.448]                             next
[13:33:43.448]                           if (!grepl(pattern, name)) 
[13:33:43.448]                             next
[13:33:43.448]                           invokeRestart(restart)
[13:33:43.448]                           muffled <- TRUE
[13:33:43.448]                           break
[13:33:43.448]                         }
[13:33:43.448]                       }
[13:33:43.448]                     }
[13:33:43.448]                     invisible(muffled)
[13:33:43.448]                   }
[13:33:43.448]                   muffleCondition(cond)
[13:33:43.448]                 })
[13:33:43.448]             }))
[13:33:43.448]             future::FutureResult(value = ...future.value$value, 
[13:33:43.448]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:43.448]                   ...future.rng), globalenv = if (FALSE) 
[13:33:43.448]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:43.448]                     ...future.globalenv.names))
[13:33:43.448]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:43.448]         }, condition = base::local({
[13:33:43.448]             c <- base::c
[13:33:43.448]             inherits <- base::inherits
[13:33:43.448]             invokeRestart <- base::invokeRestart
[13:33:43.448]             length <- base::length
[13:33:43.448]             list <- base::list
[13:33:43.448]             seq.int <- base::seq.int
[13:33:43.448]             signalCondition <- base::signalCondition
[13:33:43.448]             sys.calls <- base::sys.calls
[13:33:43.448]             `[[` <- base::`[[`
[13:33:43.448]             `+` <- base::`+`
[13:33:43.448]             `<<-` <- base::`<<-`
[13:33:43.448]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:43.448]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:43.448]                   3L)]
[13:33:43.448]             }
[13:33:43.448]             function(cond) {
[13:33:43.448]                 is_error <- inherits(cond, "error")
[13:33:43.448]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:43.448]                   NULL)
[13:33:43.448]                 if (is_error) {
[13:33:43.448]                   sessionInformation <- function() {
[13:33:43.448]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:43.448]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:43.448]                       search = base::search(), system = base::Sys.info())
[13:33:43.448]                   }
[13:33:43.448]                   ...future.conditions[[length(...future.conditions) + 
[13:33:43.448]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:43.448]                     cond$call), session = sessionInformation(), 
[13:33:43.448]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:43.448]                   signalCondition(cond)
[13:33:43.448]                 }
[13:33:43.448]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:43.448]                 "immediateCondition"))) {
[13:33:43.448]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:43.448]                   ...future.conditions[[length(...future.conditions) + 
[13:33:43.448]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:43.448]                   if (TRUE && !signal) {
[13:33:43.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.448]                     {
[13:33:43.448]                       inherits <- base::inherits
[13:33:43.448]                       invokeRestart <- base::invokeRestart
[13:33:43.448]                       is.null <- base::is.null
[13:33:43.448]                       muffled <- FALSE
[13:33:43.448]                       if (inherits(cond, "message")) {
[13:33:43.448]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:43.448]                         if (muffled) 
[13:33:43.448]                           invokeRestart("muffleMessage")
[13:33:43.448]                       }
[13:33:43.448]                       else if (inherits(cond, "warning")) {
[13:33:43.448]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:43.448]                         if (muffled) 
[13:33:43.448]                           invokeRestart("muffleWarning")
[13:33:43.448]                       }
[13:33:43.448]                       else if (inherits(cond, "condition")) {
[13:33:43.448]                         if (!is.null(pattern)) {
[13:33:43.448]                           computeRestarts <- base::computeRestarts
[13:33:43.448]                           grepl <- base::grepl
[13:33:43.448]                           restarts <- computeRestarts(cond)
[13:33:43.448]                           for (restart in restarts) {
[13:33:43.448]                             name <- restart$name
[13:33:43.448]                             if (is.null(name)) 
[13:33:43.448]                               next
[13:33:43.448]                             if (!grepl(pattern, name)) 
[13:33:43.448]                               next
[13:33:43.448]                             invokeRestart(restart)
[13:33:43.448]                             muffled <- TRUE
[13:33:43.448]                             break
[13:33:43.448]                           }
[13:33:43.448]                         }
[13:33:43.448]                       }
[13:33:43.448]                       invisible(muffled)
[13:33:43.448]                     }
[13:33:43.448]                     muffleCondition(cond, pattern = "^muffle")
[13:33:43.448]                   }
[13:33:43.448]                 }
[13:33:43.448]                 else {
[13:33:43.448]                   if (TRUE) {
[13:33:43.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.448]                     {
[13:33:43.448]                       inherits <- base::inherits
[13:33:43.448]                       invokeRestart <- base::invokeRestart
[13:33:43.448]                       is.null <- base::is.null
[13:33:43.448]                       muffled <- FALSE
[13:33:43.448]                       if (inherits(cond, "message")) {
[13:33:43.448]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:43.448]                         if (muffled) 
[13:33:43.448]                           invokeRestart("muffleMessage")
[13:33:43.448]                       }
[13:33:43.448]                       else if (inherits(cond, "warning")) {
[13:33:43.448]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:43.448]                         if (muffled) 
[13:33:43.448]                           invokeRestart("muffleWarning")
[13:33:43.448]                       }
[13:33:43.448]                       else if (inherits(cond, "condition")) {
[13:33:43.448]                         if (!is.null(pattern)) {
[13:33:43.448]                           computeRestarts <- base::computeRestarts
[13:33:43.448]                           grepl <- base::grepl
[13:33:43.448]                           restarts <- computeRestarts(cond)
[13:33:43.448]                           for (restart in restarts) {
[13:33:43.448]                             name <- restart$name
[13:33:43.448]                             if (is.null(name)) 
[13:33:43.448]                               next
[13:33:43.448]                             if (!grepl(pattern, name)) 
[13:33:43.448]                               next
[13:33:43.448]                             invokeRestart(restart)
[13:33:43.448]                             muffled <- TRUE
[13:33:43.448]                             break
[13:33:43.448]                           }
[13:33:43.448]                         }
[13:33:43.448]                       }
[13:33:43.448]                       invisible(muffled)
[13:33:43.448]                     }
[13:33:43.448]                     muffleCondition(cond, pattern = "^muffle")
[13:33:43.448]                   }
[13:33:43.448]                 }
[13:33:43.448]             }
[13:33:43.448]         }))
[13:33:43.448]     }, error = function(ex) {
[13:33:43.448]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:43.448]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:43.448]                 ...future.rng), started = ...future.startTime, 
[13:33:43.448]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:43.448]             version = "1.8"), class = "FutureResult")
[13:33:43.448]     }, finally = {
[13:33:43.448]         if (!identical(...future.workdir, getwd())) 
[13:33:43.448]             setwd(...future.workdir)
[13:33:43.448]         {
[13:33:43.448]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:43.448]                 ...future.oldOptions$nwarnings <- NULL
[13:33:43.448]             }
[13:33:43.448]             base::options(...future.oldOptions)
[13:33:43.448]             if (.Platform$OS.type == "windows") {
[13:33:43.448]                 old_names <- names(...future.oldEnvVars)
[13:33:43.448]                 envs <- base::Sys.getenv()
[13:33:43.448]                 names <- names(envs)
[13:33:43.448]                 common <- intersect(names, old_names)
[13:33:43.448]                 added <- setdiff(names, old_names)
[13:33:43.448]                 removed <- setdiff(old_names, names)
[13:33:43.448]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:43.448]                   envs[common]]
[13:33:43.448]                 NAMES <- toupper(changed)
[13:33:43.448]                 args <- list()
[13:33:43.448]                 for (kk in seq_along(NAMES)) {
[13:33:43.448]                   name <- changed[[kk]]
[13:33:43.448]                   NAME <- NAMES[[kk]]
[13:33:43.448]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.448]                     next
[13:33:43.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:43.448]                 }
[13:33:43.448]                 NAMES <- toupper(added)
[13:33:43.448]                 for (kk in seq_along(NAMES)) {
[13:33:43.448]                   name <- added[[kk]]
[13:33:43.448]                   NAME <- NAMES[[kk]]
[13:33:43.448]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.448]                     next
[13:33:43.448]                   args[[name]] <- ""
[13:33:43.448]                 }
[13:33:43.448]                 NAMES <- toupper(removed)
[13:33:43.448]                 for (kk in seq_along(NAMES)) {
[13:33:43.448]                   name <- removed[[kk]]
[13:33:43.448]                   NAME <- NAMES[[kk]]
[13:33:43.448]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.448]                     next
[13:33:43.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:43.448]                 }
[13:33:43.448]                 if (length(args) > 0) 
[13:33:43.448]                   base::do.call(base::Sys.setenv, args = args)
[13:33:43.448]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:43.448]             }
[13:33:43.448]             else {
[13:33:43.448]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:43.448]             }
[13:33:43.448]             {
[13:33:43.448]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:43.448]                   0L) {
[13:33:43.448]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:43.448]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:43.448]                   base::options(opts)
[13:33:43.448]                 }
[13:33:43.448]                 {
[13:33:43.448]                   {
[13:33:43.448]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:43.448]                     NULL
[13:33:43.448]                   }
[13:33:43.448]                   options(future.plan = NULL)
[13:33:43.448]                   if (is.na(NA_character_)) 
[13:33:43.448]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:43.448]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:43.448]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:43.448]                     .init = FALSE)
[13:33:43.448]                 }
[13:33:43.448]             }
[13:33:43.448]         }
[13:33:43.448]     })
[13:33:43.448]     if (TRUE) {
[13:33:43.448]         base::sink(type = "output", split = FALSE)
[13:33:43.448]         if (TRUE) {
[13:33:43.448]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:43.448]         }
[13:33:43.448]         else {
[13:33:43.448]             ...future.result["stdout"] <- base::list(NULL)
[13:33:43.448]         }
[13:33:43.448]         base::close(...future.stdout)
[13:33:43.448]         ...future.stdout <- NULL
[13:33:43.448]     }
[13:33:43.448]     ...future.result$conditions <- ...future.conditions
[13:33:43.448]     ...future.result$finished <- base::Sys.time()
[13:33:43.448]     ...future.result
[13:33:43.448] }
[13:33:43.451] Exporting 5 global objects (1.27 KiB) to cluster node #2 ...
[13:33:43.451] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[13:33:43.451] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[13:33:43.451] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[13:33:43.452] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[13:33:43.452] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ...
[13:33:43.452] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ... DONE
[13:33:43.452] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:33:43.452] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:33:43.453] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:33:43.453] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:33:43.453] Exporting 5 global objects (1.27 KiB) to cluster node #2 ... DONE
[13:33:43.453] MultisessionFuture started
[13:33:43.454] - Launch lazy future ... done
[13:33:43.454] run() for ‘MultisessionFuture’ ... done
[13:33:43.454] Created future:
[13:33:43.454] MultisessionFuture:
[13:33:43.454] Label: ‘future_by-2’
[13:33:43.454] Expression:
[13:33:43.454] {
[13:33:43.454]     do.call(function(...) {
[13:33:43.454]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.454]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:43.454]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.454]             on.exit(options(oopts), add = TRUE)
[13:33:43.454]         }
[13:33:43.454]         {
[13:33:43.454]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:43.454]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.454]                 ...future.FUN(...future.X_jj, ...)
[13:33:43.454]             })
[13:33:43.454]         }
[13:33:43.454]     }, args = future.call.arguments)
[13:33:43.454] }
[13:33:43.454] Lazy evaluation: FALSE
[13:33:43.454] Asynchronous evaluation: TRUE
[13:33:43.454] Local evaluation: TRUE
[13:33:43.454] Environment: R_GlobalEnv
[13:33:43.454] Capture standard output: TRUE
[13:33:43.454] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:43.454] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:43.454] Packages: <none>
[13:33:43.454] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:43.454] Resolved: FALSE
[13:33:43.454] Value: <not collected>
[13:33:43.454] Conditions captured: <none>
[13:33:43.454] Early signaling: FALSE
[13:33:43.454] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:43.454] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:43.465] Chunk #2 of 2 ... DONE
[13:33:43.465] Launching 2 futures (chunks) ... DONE
[13:33:43.466] Resolving 2 futures (chunks) ...
[13:33:43.466] resolve() on list ...
[13:33:43.466]  recursive: 0
[13:33:43.466]  length: 2
[13:33:43.466] 
[13:33:43.466] receiveMessageFromWorker() for ClusterFuture ...
[13:33:43.467] - Validating connection of MultisessionFuture
[13:33:43.467] - received message: FutureResult
[13:33:43.467] - Received FutureResult
[13:33:43.467] - Erased future from FutureRegistry
[13:33:43.467] result() for ClusterFuture ...
[13:33:43.467] - result already collected: FutureResult
[13:33:43.467] result() for ClusterFuture ... done
[13:33:43.467] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:43.467] Future #1
[13:33:43.468] result() for ClusterFuture ...
[13:33:43.468] - result already collected: FutureResult
[13:33:43.468] result() for ClusterFuture ... done
[13:33:43.468] result() for ClusterFuture ...
[13:33:43.468] - result already collected: FutureResult
[13:33:43.468] result() for ClusterFuture ... done
[13:33:43.468] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:33:43.468] - nx: 2
[13:33:43.468] - relay: TRUE
[13:33:43.468] - stdout: TRUE
[13:33:43.468] - signal: TRUE
[13:33:43.468] - resignal: FALSE
[13:33:43.469] - force: TRUE
[13:33:43.469] - relayed: [n=2] FALSE, FALSE
[13:33:43.469] - queued futures: [n=2] FALSE, FALSE
[13:33:43.469]  - until=1
[13:33:43.469]  - relaying element #1
[13:33:43.469] result() for ClusterFuture ...
[13:33:43.469] - result already collected: FutureResult
[13:33:43.469] result() for ClusterFuture ... done
[13:33:43.469] result() for ClusterFuture ...
[13:33:43.469] - result already collected: FutureResult
[13:33:43.469] result() for ClusterFuture ... done
[13:33:43.470] result() for ClusterFuture ...
[13:33:43.470] - result already collected: FutureResult
[13:33:43.470] result() for ClusterFuture ... done
[13:33:43.470] result() for ClusterFuture ...
[13:33:43.470] - result already collected: FutureResult
[13:33:43.470] result() for ClusterFuture ... done
[13:33:43.470] - relayed: [n=2] TRUE, FALSE
[13:33:43.470] - queued futures: [n=2] TRUE, FALSE
[13:33:43.470] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:33:43.470]  length: 1 (resolved future 1)
[13:33:43.496] receiveMessageFromWorker() for ClusterFuture ...
[13:33:43.496] - Validating connection of MultisessionFuture
[13:33:43.496] - received message: FutureResult
[13:33:43.497] - Received FutureResult
[13:33:43.497] - Erased future from FutureRegistry
[13:33:43.497] result() for ClusterFuture ...
[13:33:43.497] - result already collected: FutureResult
[13:33:43.497] result() for ClusterFuture ... done
[13:33:43.497] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:43.497] Future #2
[13:33:43.497] result() for ClusterFuture ...
[13:33:43.497] - result already collected: FutureResult
[13:33:43.497] result() for ClusterFuture ... done
[13:33:43.497] result() for ClusterFuture ...
[13:33:43.498] - result already collected: FutureResult
[13:33:43.498] result() for ClusterFuture ... done
[13:33:43.498] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:33:43.498] - nx: 2
[13:33:43.498] - relay: TRUE
[13:33:43.498] - stdout: TRUE
[13:33:43.498] - signal: TRUE
[13:33:43.498] - resignal: FALSE
[13:33:43.498] - force: TRUE
[13:33:43.498] - relayed: [n=2] TRUE, FALSE
[13:33:43.498] - queued futures: [n=2] TRUE, FALSE
[13:33:43.499]  - until=2
[13:33:43.499]  - relaying element #2
[13:33:43.499] result() for ClusterFuture ...
[13:33:43.499] - result already collected: FutureResult
[13:33:43.499] result() for ClusterFuture ... done
[13:33:43.499] result() for ClusterFuture ...
[13:33:43.499] - result already collected: FutureResult
[13:33:43.499] result() for ClusterFuture ... done
[13:33:43.499] result() for ClusterFuture ...
[13:33:43.499] - result already collected: FutureResult
[13:33:43.500] result() for ClusterFuture ... done
[13:33:43.500] result() for ClusterFuture ...
[13:33:43.500] - result already collected: FutureResult
[13:33:43.500] result() for ClusterFuture ... done
[13:33:43.500] - relayed: [n=2] TRUE, TRUE
[13:33:43.500] - queued futures: [n=2] TRUE, TRUE
[13:33:43.500] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:33:43.500]  length: 0 (resolved future 2)
[13:33:43.500] Relaying remaining futures
[13:33:43.500] signalConditionsASAP(NULL, pos=0) ...
[13:33:43.500] - nx: 2
[13:33:43.500] - relay: TRUE
[13:33:43.501] - stdout: TRUE
[13:33:43.501] - signal: TRUE
[13:33:43.501] - resignal: FALSE
[13:33:43.501] - force: TRUE
[13:33:43.501] - relayed: [n=2] TRUE, TRUE
[13:33:43.501] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:43.501] - relayed: [n=2] TRUE, TRUE
[13:33:43.501] - queued futures: [n=2] TRUE, TRUE
[13:33:43.501] signalConditionsASAP(NULL, pos=0) ... done
[13:33:43.501] resolve() on list ... DONE
[13:33:43.501] result() for ClusterFuture ...
[13:33:43.502] - result already collected: FutureResult
[13:33:43.502] result() for ClusterFuture ... done
[13:33:43.502] result() for ClusterFuture ...
[13:33:43.502] - result already collected: FutureResult
[13:33:43.502] result() for ClusterFuture ... done
[13:33:43.502] result() for ClusterFuture ...
[13:33:43.502] - result already collected: FutureResult
[13:33:43.502] result() for ClusterFuture ... done
[13:33:43.502] result() for ClusterFuture ...
[13:33:43.502] - result already collected: FutureResult
[13:33:43.502] result() for ClusterFuture ... done
[13:33:43.503]  - Number of value chunks collected: 2
[13:33:43.503] Resolving 2 futures (chunks) ... DONE
[13:33:43.503] Reducing values from 2 chunks ...
[13:33:43.503]  - Number of values collected after concatenation: 6
[13:33:43.503]  - Number of values expected: 6
[13:33:43.503] Reducing values from 2 chunks ... DONE
[13:33:43.503] future_lapply() ... DONE
[13:33:43.503] future_by_internal() ... DONE
[13:33:43.504] future_by_internal() ...
[13:33:43.505] future_lapply() ...
[13:33:43.509] Number of chunks: 2
[13:33:43.509] getGlobalsAndPackagesXApply() ...
[13:33:43.509]  - future.globals: TRUE
[13:33:43.509] getGlobalsAndPackages() ...
[13:33:43.509] Searching for globals...
[13:33:43.511] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:33:43.511] Searching for globals ... DONE
[13:33:43.511] Resolving globals: FALSE
[13:33:43.512] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[13:33:43.512] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[13:33:43.512] - globals: [1] ‘FUN’
[13:33:43.512] - packages: [1] ‘stats’
[13:33:43.512] getGlobalsAndPackages() ... DONE
[13:33:43.512]  - globals found/used: [n=1] ‘FUN’
[13:33:43.512]  - needed namespaces: [n=1] ‘stats’
[13:33:43.513] Finding globals ... DONE
[13:33:43.513]  - use_args: TRUE
[13:33:43.513]  - Getting '...' globals ...
[13:33:43.513] resolve() on list ...
[13:33:43.513]  recursive: 0
[13:33:43.513]  length: 1
[13:33:43.513]  elements: ‘...’
[13:33:43.514]  length: 0 (resolved future 1)
[13:33:43.514] resolve() on list ... DONE
[13:33:43.514]    - '...' content: [n=1] ‘singular.ok’
[13:33:43.514] List of 1
[13:33:43.514]  $ ...:List of 1
[13:33:43.514]   ..$ singular.ok: logi FALSE
[13:33:43.514]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:43.514]  - attr(*, "where")=List of 1
[13:33:43.514]   ..$ ...:<environment: 0x55cb824b3b50> 
[13:33:43.514]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:43.514]  - attr(*, "resolved")= logi TRUE
[13:33:43.514]  - attr(*, "total_size")= num NA
[13:33:43.517]  - Getting '...' globals ... DONE
[13:33:43.517] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:43.517] List of 2
[13:33:43.517]  $ ...future.FUN:function (x, ...)  
[13:33:43.517]  $ ...          :List of 1
[13:33:43.517]   ..$ singular.ok: logi FALSE
[13:33:43.517]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:43.517]  - attr(*, "where")=List of 2
[13:33:43.517]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:43.517]   ..$ ...          :<environment: 0x55cb824b3b50> 
[13:33:43.517]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:43.517]  - attr(*, "resolved")= logi FALSE
[13:33:43.517]  - attr(*, "total_size")= num 5384
[13:33:43.522] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:43.523] getGlobalsAndPackagesXApply() ... DONE
[13:33:43.523] Number of futures (= number of chunks): 2
[13:33:43.523] Launching 2 futures (chunks) ...
[13:33:43.523] Chunk #1 of 2 ...
[13:33:43.523]  - Finding globals in 'X' for chunk #1 ...
[13:33:43.523] getGlobalsAndPackages() ...
[13:33:43.523] Searching for globals...
[13:33:43.524] 
[13:33:43.524] Searching for globals ... DONE
[13:33:43.524] - globals: [0] <none>
[13:33:43.524] getGlobalsAndPackages() ... DONE
[13:33:43.524]    + additional globals found: [n=0] 
[13:33:43.524]    + additional namespaces needed: [n=0] 
[13:33:43.524]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:43.524]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:43.524]  - seeds: <none>
[13:33:43.524]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.524] getGlobalsAndPackages() ...
[13:33:43.525] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.525] Resolving globals: FALSE
[13:33:43.525] Tweak future expression to call with '...' arguments ...
[13:33:43.525] {
[13:33:43.525]     do.call(function(...) {
[13:33:43.525]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.525]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:43.525]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.525]             on.exit(options(oopts), add = TRUE)
[13:33:43.525]         }
[13:33:43.525]         {
[13:33:43.525]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:43.525]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.525]                 ...future.FUN(...future.X_jj, ...)
[13:33:43.525]             })
[13:33:43.525]         }
[13:33:43.525]     }, args = future.call.arguments)
[13:33:43.525] }
[13:33:43.525] Tweak future expression to call with '...' arguments ... DONE
[13:33:43.525] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.526] 
[13:33:43.526] getGlobalsAndPackages() ... DONE
[13:33:43.526] run() for ‘Future’ ...
[13:33:43.526] - state: ‘created’
[13:33:43.526] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:43.539] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:43.539] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:43.539]   - Field: ‘node’
[13:33:43.540]   - Field: ‘label’
[13:33:43.540]   - Field: ‘local’
[13:33:43.540]   - Field: ‘owner’
[13:33:43.540]   - Field: ‘envir’
[13:33:43.540]   - Field: ‘workers’
[13:33:43.540]   - Field: ‘packages’
[13:33:43.540]   - Field: ‘gc’
[13:33:43.540]   - Field: ‘conditions’
[13:33:43.540]   - Field: ‘persistent’
[13:33:43.540]   - Field: ‘expr’
[13:33:43.540]   - Field: ‘uuid’
[13:33:43.540]   - Field: ‘seed’
[13:33:43.541]   - Field: ‘version’
[13:33:43.541]   - Field: ‘result’
[13:33:43.541]   - Field: ‘asynchronous’
[13:33:43.541]   - Field: ‘calls’
[13:33:43.541]   - Field: ‘globals’
[13:33:43.541]   - Field: ‘stdout’
[13:33:43.541]   - Field: ‘earlySignal’
[13:33:43.541]   - Field: ‘lazy’
[13:33:43.541]   - Field: ‘state’
[13:33:43.541] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:43.541] - Launch lazy future ...
[13:33:43.542] Packages needed by the future expression (n = 1): ‘stats’
[13:33:43.542] Packages needed by future strategies (n = 0): <none>
[13:33:43.542] {
[13:33:43.542]     {
[13:33:43.542]         {
[13:33:43.542]             ...future.startTime <- base::Sys.time()
[13:33:43.542]             {
[13:33:43.542]                 {
[13:33:43.542]                   {
[13:33:43.542]                     {
[13:33:43.542]                       {
[13:33:43.542]                         base::local({
[13:33:43.542]                           has_future <- base::requireNamespace("future", 
[13:33:43.542]                             quietly = TRUE)
[13:33:43.542]                           if (has_future) {
[13:33:43.542]                             ns <- base::getNamespace("future")
[13:33:43.542]                             version <- ns[[".package"]][["version"]]
[13:33:43.542]                             if (is.null(version)) 
[13:33:43.542]                               version <- utils::packageVersion("future")
[13:33:43.542]                           }
[13:33:43.542]                           else {
[13:33:43.542]                             version <- NULL
[13:33:43.542]                           }
[13:33:43.542]                           if (!has_future || version < "1.8.0") {
[13:33:43.542]                             info <- base::c(r_version = base::gsub("R version ", 
[13:33:43.542]                               "", base::R.version$version.string), 
[13:33:43.542]                               platform = base::sprintf("%s (%s-bit)", 
[13:33:43.542]                                 base::R.version$platform, 8 * 
[13:33:43.542]                                   base::.Machine$sizeof.pointer), 
[13:33:43.542]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:43.542]                                 "release", "version")], collapse = " "), 
[13:33:43.542]                               hostname = base::Sys.info()[["nodename"]])
[13:33:43.542]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:33:43.542]                               info)
[13:33:43.542]                             info <- base::paste(info, collapse = "; ")
[13:33:43.542]                             if (!has_future) {
[13:33:43.542]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:43.542]                                 info)
[13:33:43.542]                             }
[13:33:43.542]                             else {
[13:33:43.542]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:43.542]                                 info, version)
[13:33:43.542]                             }
[13:33:43.542]                             base::stop(msg)
[13:33:43.542]                           }
[13:33:43.542]                         })
[13:33:43.542]                       }
[13:33:43.542]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:43.542]                       base::options(mc.cores = 1L)
[13:33:43.542]                     }
[13:33:43.542]                     base::local({
[13:33:43.542]                       for (pkg in "stats") {
[13:33:43.542]                         base::loadNamespace(pkg)
[13:33:43.542]                         base::library(pkg, character.only = TRUE)
[13:33:43.542]                       }
[13:33:43.542]                     })
[13:33:43.542]                   }
[13:33:43.542]                   ...future.strategy.old <- future::plan("list")
[13:33:43.542]                   options(future.plan = NULL)
[13:33:43.542]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:43.542]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:43.542]                 }
[13:33:43.542]                 ...future.workdir <- getwd()
[13:33:43.542]             }
[13:33:43.542]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:43.542]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:43.542]         }
[13:33:43.542]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:43.542]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:43.542]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:43.542]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:43.542]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:43.542]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:43.542]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:43.542]             base::names(...future.oldOptions))
[13:33:43.542]     }
[13:33:43.542]     if (FALSE) {
[13:33:43.542]     }
[13:33:43.542]     else {
[13:33:43.542]         if (TRUE) {
[13:33:43.542]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:43.542]                 open = "w")
[13:33:43.542]         }
[13:33:43.542]         else {
[13:33:43.542]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:43.542]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:43.542]         }
[13:33:43.542]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:43.542]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:43.542]             base::sink(type = "output", split = FALSE)
[13:33:43.542]             base::close(...future.stdout)
[13:33:43.542]         }, add = TRUE)
[13:33:43.542]     }
[13:33:43.542]     ...future.frame <- base::sys.nframe()
[13:33:43.542]     ...future.conditions <- base::list()
[13:33:43.542]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:43.542]     if (FALSE) {
[13:33:43.542]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:43.542]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:43.542]     }
[13:33:43.542]     ...future.result <- base::tryCatch({
[13:33:43.542]         base::withCallingHandlers({
[13:33:43.542]             ...future.value <- base::withVisible(base::local({
[13:33:43.542]                 ...future.makeSendCondition <- base::local({
[13:33:43.542]                   sendCondition <- NULL
[13:33:43.542]                   function(frame = 1L) {
[13:33:43.542]                     if (is.function(sendCondition)) 
[13:33:43.542]                       return(sendCondition)
[13:33:43.542]                     ns <- getNamespace("parallel")
[13:33:43.542]                     if (exists("sendData", mode = "function", 
[13:33:43.542]                       envir = ns)) {
[13:33:43.542]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:43.542]                         envir = ns)
[13:33:43.542]                       envir <- sys.frame(frame)
[13:33:43.542]                       master <- NULL
[13:33:43.542]                       while (!identical(envir, .GlobalEnv) && 
[13:33:43.542]                         !identical(envir, emptyenv())) {
[13:33:43.542]                         if (exists("master", mode = "list", envir = envir, 
[13:33:43.542]                           inherits = FALSE)) {
[13:33:43.542]                           master <- get("master", mode = "list", 
[13:33:43.542]                             envir = envir, inherits = FALSE)
[13:33:43.542]                           if (inherits(master, c("SOCKnode", 
[13:33:43.542]                             "SOCK0node"))) {
[13:33:43.542]                             sendCondition <<- function(cond) {
[13:33:43.542]                               data <- list(type = "VALUE", value = cond, 
[13:33:43.542]                                 success = TRUE)
[13:33:43.542]                               parallel_sendData(master, data)
[13:33:43.542]                             }
[13:33:43.542]                             return(sendCondition)
[13:33:43.542]                           }
[13:33:43.542]                         }
[13:33:43.542]                         frame <- frame + 1L
[13:33:43.542]                         envir <- sys.frame(frame)
[13:33:43.542]                       }
[13:33:43.542]                     }
[13:33:43.542]                     sendCondition <<- function(cond) NULL
[13:33:43.542]                   }
[13:33:43.542]                 })
[13:33:43.542]                 withCallingHandlers({
[13:33:43.542]                   {
[13:33:43.542]                     do.call(function(...) {
[13:33:43.542]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.542]                       if (!identical(...future.globals.maxSize.org, 
[13:33:43.542]                         ...future.globals.maxSize)) {
[13:33:43.542]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.542]                         on.exit(options(oopts), add = TRUE)
[13:33:43.542]                       }
[13:33:43.542]                       {
[13:33:43.542]                         lapply(seq_along(...future.elements_ii), 
[13:33:43.542]                           FUN = function(jj) {
[13:33:43.542]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.542]                             ...future.FUN(...future.X_jj, ...)
[13:33:43.542]                           })
[13:33:43.542]                       }
[13:33:43.542]                     }, args = future.call.arguments)
[13:33:43.542]                   }
[13:33:43.542]                 }, immediateCondition = function(cond) {
[13:33:43.542]                   sendCondition <- ...future.makeSendCondition()
[13:33:43.542]                   sendCondition(cond)
[13:33:43.542]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.542]                   {
[13:33:43.542]                     inherits <- base::inherits
[13:33:43.542]                     invokeRestart <- base::invokeRestart
[13:33:43.542]                     is.null <- base::is.null
[13:33:43.542]                     muffled <- FALSE
[13:33:43.542]                     if (inherits(cond, "message")) {
[13:33:43.542]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:43.542]                       if (muffled) 
[13:33:43.542]                         invokeRestart("muffleMessage")
[13:33:43.542]                     }
[13:33:43.542]                     else if (inherits(cond, "warning")) {
[13:33:43.542]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:43.542]                       if (muffled) 
[13:33:43.542]                         invokeRestart("muffleWarning")
[13:33:43.542]                     }
[13:33:43.542]                     else if (inherits(cond, "condition")) {
[13:33:43.542]                       if (!is.null(pattern)) {
[13:33:43.542]                         computeRestarts <- base::computeRestarts
[13:33:43.542]                         grepl <- base::grepl
[13:33:43.542]                         restarts <- computeRestarts(cond)
[13:33:43.542]                         for (restart in restarts) {
[13:33:43.542]                           name <- restart$name
[13:33:43.542]                           if (is.null(name)) 
[13:33:43.542]                             next
[13:33:43.542]                           if (!grepl(pattern, name)) 
[13:33:43.542]                             next
[13:33:43.542]                           invokeRestart(restart)
[13:33:43.542]                           muffled <- TRUE
[13:33:43.542]                           break
[13:33:43.542]                         }
[13:33:43.542]                       }
[13:33:43.542]                     }
[13:33:43.542]                     invisible(muffled)
[13:33:43.542]                   }
[13:33:43.542]                   muffleCondition(cond)
[13:33:43.542]                 })
[13:33:43.542]             }))
[13:33:43.542]             future::FutureResult(value = ...future.value$value, 
[13:33:43.542]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:43.542]                   ...future.rng), globalenv = if (FALSE) 
[13:33:43.542]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:43.542]                     ...future.globalenv.names))
[13:33:43.542]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:43.542]         }, condition = base::local({
[13:33:43.542]             c <- base::c
[13:33:43.542]             inherits <- base::inherits
[13:33:43.542]             invokeRestart <- base::invokeRestart
[13:33:43.542]             length <- base::length
[13:33:43.542]             list <- base::list
[13:33:43.542]             seq.int <- base::seq.int
[13:33:43.542]             signalCondition <- base::signalCondition
[13:33:43.542]             sys.calls <- base::sys.calls
[13:33:43.542]             `[[` <- base::`[[`
[13:33:43.542]             `+` <- base::`+`
[13:33:43.542]             `<<-` <- base::`<<-`
[13:33:43.542]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:43.542]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:43.542]                   3L)]
[13:33:43.542]             }
[13:33:43.542]             function(cond) {
[13:33:43.542]                 is_error <- inherits(cond, "error")
[13:33:43.542]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:43.542]                   NULL)
[13:33:43.542]                 if (is_error) {
[13:33:43.542]                   sessionInformation <- function() {
[13:33:43.542]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:43.542]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:43.542]                       search = base::search(), system = base::Sys.info())
[13:33:43.542]                   }
[13:33:43.542]                   ...future.conditions[[length(...future.conditions) + 
[13:33:43.542]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:43.542]                     cond$call), session = sessionInformation(), 
[13:33:43.542]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:43.542]                   signalCondition(cond)
[13:33:43.542]                 }
[13:33:43.542]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:43.542]                 "immediateCondition"))) {
[13:33:43.542]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:43.542]                   ...future.conditions[[length(...future.conditions) + 
[13:33:43.542]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:43.542]                   if (TRUE && !signal) {
[13:33:43.542]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.542]                     {
[13:33:43.542]                       inherits <- base::inherits
[13:33:43.542]                       invokeRestart <- base::invokeRestart
[13:33:43.542]                       is.null <- base::is.null
[13:33:43.542]                       muffled <- FALSE
[13:33:43.542]                       if (inherits(cond, "message")) {
[13:33:43.542]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:43.542]                         if (muffled) 
[13:33:43.542]                           invokeRestart("muffleMessage")
[13:33:43.542]                       }
[13:33:43.542]                       else if (inherits(cond, "warning")) {
[13:33:43.542]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:43.542]                         if (muffled) 
[13:33:43.542]                           invokeRestart("muffleWarning")
[13:33:43.542]                       }
[13:33:43.542]                       else if (inherits(cond, "condition")) {
[13:33:43.542]                         if (!is.null(pattern)) {
[13:33:43.542]                           computeRestarts <- base::computeRestarts
[13:33:43.542]                           grepl <- base::grepl
[13:33:43.542]                           restarts <- computeRestarts(cond)
[13:33:43.542]                           for (restart in restarts) {
[13:33:43.542]                             name <- restart$name
[13:33:43.542]                             if (is.null(name)) 
[13:33:43.542]                               next
[13:33:43.542]                             if (!grepl(pattern, name)) 
[13:33:43.542]                               next
[13:33:43.542]                             invokeRestart(restart)
[13:33:43.542]                             muffled <- TRUE
[13:33:43.542]                             break
[13:33:43.542]                           }
[13:33:43.542]                         }
[13:33:43.542]                       }
[13:33:43.542]                       invisible(muffled)
[13:33:43.542]                     }
[13:33:43.542]                     muffleCondition(cond, pattern = "^muffle")
[13:33:43.542]                   }
[13:33:43.542]                 }
[13:33:43.542]                 else {
[13:33:43.542]                   if (TRUE) {
[13:33:43.542]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.542]                     {
[13:33:43.542]                       inherits <- base::inherits
[13:33:43.542]                       invokeRestart <- base::invokeRestart
[13:33:43.542]                       is.null <- base::is.null
[13:33:43.542]                       muffled <- FALSE
[13:33:43.542]                       if (inherits(cond, "message")) {
[13:33:43.542]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:43.542]                         if (muffled) 
[13:33:43.542]                           invokeRestart("muffleMessage")
[13:33:43.542]                       }
[13:33:43.542]                       else if (inherits(cond, "warning")) {
[13:33:43.542]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:43.542]                         if (muffled) 
[13:33:43.542]                           invokeRestart("muffleWarning")
[13:33:43.542]                       }
[13:33:43.542]                       else if (inherits(cond, "condition")) {
[13:33:43.542]                         if (!is.null(pattern)) {
[13:33:43.542]                           computeRestarts <- base::computeRestarts
[13:33:43.542]                           grepl <- base::grepl
[13:33:43.542]                           restarts <- computeRestarts(cond)
[13:33:43.542]                           for (restart in restarts) {
[13:33:43.542]                             name <- restart$name
[13:33:43.542]                             if (is.null(name)) 
[13:33:43.542]                               next
[13:33:43.542]                             if (!grepl(pattern, name)) 
[13:33:43.542]                               next
[13:33:43.542]                             invokeRestart(restart)
[13:33:43.542]                             muffled <- TRUE
[13:33:43.542]                             break
[13:33:43.542]                           }
[13:33:43.542]                         }
[13:33:43.542]                       }
[13:33:43.542]                       invisible(muffled)
[13:33:43.542]                     }
[13:33:43.542]                     muffleCondition(cond, pattern = "^muffle")
[13:33:43.542]                   }
[13:33:43.542]                 }
[13:33:43.542]             }
[13:33:43.542]         }))
[13:33:43.542]     }, error = function(ex) {
[13:33:43.542]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:43.542]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:43.542]                 ...future.rng), started = ...future.startTime, 
[13:33:43.542]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:43.542]             version = "1.8"), class = "FutureResult")
[13:33:43.542]     }, finally = {
[13:33:43.542]         if (!identical(...future.workdir, getwd())) 
[13:33:43.542]             setwd(...future.workdir)
[13:33:43.542]         {
[13:33:43.542]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:43.542]                 ...future.oldOptions$nwarnings <- NULL
[13:33:43.542]             }
[13:33:43.542]             base::options(...future.oldOptions)
[13:33:43.542]             if (.Platform$OS.type == "windows") {
[13:33:43.542]                 old_names <- names(...future.oldEnvVars)
[13:33:43.542]                 envs <- base::Sys.getenv()
[13:33:43.542]                 names <- names(envs)
[13:33:43.542]                 common <- intersect(names, old_names)
[13:33:43.542]                 added <- setdiff(names, old_names)
[13:33:43.542]                 removed <- setdiff(old_names, names)
[13:33:43.542]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:43.542]                   envs[common]]
[13:33:43.542]                 NAMES <- toupper(changed)
[13:33:43.542]                 args <- list()
[13:33:43.542]                 for (kk in seq_along(NAMES)) {
[13:33:43.542]                   name <- changed[[kk]]
[13:33:43.542]                   NAME <- NAMES[[kk]]
[13:33:43.542]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.542]                     next
[13:33:43.542]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:43.542]                 }
[13:33:43.542]                 NAMES <- toupper(added)
[13:33:43.542]                 for (kk in seq_along(NAMES)) {
[13:33:43.542]                   name <- added[[kk]]
[13:33:43.542]                   NAME <- NAMES[[kk]]
[13:33:43.542]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.542]                     next
[13:33:43.542]                   args[[name]] <- ""
[13:33:43.542]                 }
[13:33:43.542]                 NAMES <- toupper(removed)
[13:33:43.542]                 for (kk in seq_along(NAMES)) {
[13:33:43.542]                   name <- removed[[kk]]
[13:33:43.542]                   NAME <- NAMES[[kk]]
[13:33:43.542]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.542]                     next
[13:33:43.542]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:43.542]                 }
[13:33:43.542]                 if (length(args) > 0) 
[13:33:43.542]                   base::do.call(base::Sys.setenv, args = args)
[13:33:43.542]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:43.542]             }
[13:33:43.542]             else {
[13:33:43.542]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:43.542]             }
[13:33:43.542]             {
[13:33:43.542]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:43.542]                   0L) {
[13:33:43.542]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:43.542]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:43.542]                   base::options(opts)
[13:33:43.542]                 }
[13:33:43.542]                 {
[13:33:43.542]                   {
[13:33:43.542]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:43.542]                     NULL
[13:33:43.542]                   }
[13:33:43.542]                   options(future.plan = NULL)
[13:33:43.542]                   if (is.na(NA_character_)) 
[13:33:43.542]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:43.542]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:43.542]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:43.542]                     .init = FALSE)
[13:33:43.542]                 }
[13:33:43.542]             }
[13:33:43.542]         }
[13:33:43.542]     })
[13:33:43.542]     if (TRUE) {
[13:33:43.542]         base::sink(type = "output", split = FALSE)
[13:33:43.542]         if (TRUE) {
[13:33:43.542]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:43.542]         }
[13:33:43.542]         else {
[13:33:43.542]             ...future.result["stdout"] <- base::list(NULL)
[13:33:43.542]         }
[13:33:43.542]         base::close(...future.stdout)
[13:33:43.542]         ...future.stdout <- NULL
[13:33:43.542]     }
[13:33:43.542]     ...future.result$conditions <- ...future.conditions
[13:33:43.542]     ...future.result$finished <- base::Sys.time()
[13:33:43.542]     ...future.result
[13:33:43.542] }
[13:33:43.545] Exporting 5 global objects (5.26 KiB) to cluster node #1 ...
[13:33:43.545] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ...
[13:33:43.545] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ... DONE
[13:33:43.546] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[13:33:43.546] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[13:33:43.546] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[13:33:43.547] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[13:33:43.547] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:33:43.547] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:33:43.547] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:33:43.548] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:33:43.548] Exporting 5 global objects (5.26 KiB) to cluster node #1 ... DONE
[13:33:43.548] MultisessionFuture started
[13:33:43.548] - Launch lazy future ... done
[13:33:43.549] run() for ‘MultisessionFuture’ ... done
[13:33:43.549] Created future:
[13:33:43.549] MultisessionFuture:
[13:33:43.549] Label: ‘future_by-1’
[13:33:43.549] Expression:
[13:33:43.549] {
[13:33:43.549]     do.call(function(...) {
[13:33:43.549]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.549]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:43.549]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.549]             on.exit(options(oopts), add = TRUE)
[13:33:43.549]         }
[13:33:43.549]         {
[13:33:43.549]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:43.549]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.549]                 ...future.FUN(...future.X_jj, ...)
[13:33:43.549]             })
[13:33:43.549]         }
[13:33:43.549]     }, args = future.call.arguments)
[13:33:43.549] }
[13:33:43.549] Lazy evaluation: FALSE
[13:33:43.549] Asynchronous evaluation: TRUE
[13:33:43.549] Local evaluation: TRUE
[13:33:43.549] Environment: R_GlobalEnv
[13:33:43.549] Capture standard output: TRUE
[13:33:43.549] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:43.549] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:43.549] Packages: 1 packages (‘stats’)
[13:33:43.549] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:43.549] Resolved: FALSE
[13:33:43.549] Value: <not collected>
[13:33:43.549] Conditions captured: <none>
[13:33:43.549] Early signaling: FALSE
[13:33:43.549] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:43.549] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:43.560] Chunk #1 of 2 ... DONE
[13:33:43.560] Chunk #2 of 2 ...
[13:33:43.561]  - Finding globals in 'X' for chunk #2 ...
[13:33:43.561] getGlobalsAndPackages() ...
[13:33:43.561] Searching for globals...
[13:33:43.561] 
[13:33:43.561] Searching for globals ... DONE
[13:33:43.561] - globals: [0] <none>
[13:33:43.562] getGlobalsAndPackages() ... DONE
[13:33:43.562]    + additional globals found: [n=0] 
[13:33:43.562]    + additional namespaces needed: [n=0] 
[13:33:43.562]  - Finding globals in 'X' for chunk #2 ... DONE
[13:33:43.562]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:43.562]  - seeds: <none>
[13:33:43.562]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.562] getGlobalsAndPackages() ...
[13:33:43.562] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.562] Resolving globals: FALSE
[13:33:43.563] Tweak future expression to call with '...' arguments ...
[13:33:43.563] {
[13:33:43.563]     do.call(function(...) {
[13:33:43.563]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.563]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:43.563]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.563]             on.exit(options(oopts), add = TRUE)
[13:33:43.563]         }
[13:33:43.563]         {
[13:33:43.563]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:43.563]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.563]                 ...future.FUN(...future.X_jj, ...)
[13:33:43.563]             })
[13:33:43.563]         }
[13:33:43.563]     }, args = future.call.arguments)
[13:33:43.563] }
[13:33:43.563] Tweak future expression to call with '...' arguments ... DONE
[13:33:43.563] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.563] 
[13:33:43.563] getGlobalsAndPackages() ... DONE
[13:33:43.564] run() for ‘Future’ ...
[13:33:43.564] - state: ‘created’
[13:33:43.564] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:43.577] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:43.577] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:43.577]   - Field: ‘node’
[13:33:43.577]   - Field: ‘label’
[13:33:43.578]   - Field: ‘local’
[13:33:43.578]   - Field: ‘owner’
[13:33:43.578]   - Field: ‘envir’
[13:33:43.578]   - Field: ‘workers’
[13:33:43.578]   - Field: ‘packages’
[13:33:43.578]   - Field: ‘gc’
[13:33:43.578]   - Field: ‘conditions’
[13:33:43.578]   - Field: ‘persistent’
[13:33:43.578]   - Field: ‘expr’
[13:33:43.578]   - Field: ‘uuid’
[13:33:43.578]   - Field: ‘seed’
[13:33:43.579]   - Field: ‘version’
[13:33:43.579]   - Field: ‘result’
[13:33:43.579]   - Field: ‘asynchronous’
[13:33:43.579]   - Field: ‘calls’
[13:33:43.579]   - Field: ‘globals’
[13:33:43.579]   - Field: ‘stdout’
[13:33:43.579]   - Field: ‘earlySignal’
[13:33:43.579]   - Field: ‘lazy’
[13:33:43.579]   - Field: ‘state’
[13:33:43.579] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:43.579] - Launch lazy future ...
[13:33:43.580] Packages needed by the future expression (n = 1): ‘stats’
[13:33:43.580] Packages needed by future strategies (n = 0): <none>
[13:33:43.580] {
[13:33:43.580]     {
[13:33:43.580]         {
[13:33:43.580]             ...future.startTime <- base::Sys.time()
[13:33:43.580]             {
[13:33:43.580]                 {
[13:33:43.580]                   {
[13:33:43.580]                     {
[13:33:43.580]                       {
[13:33:43.580]                         base::local({
[13:33:43.580]                           has_future <- base::requireNamespace("future", 
[13:33:43.580]                             quietly = TRUE)
[13:33:43.580]                           if (has_future) {
[13:33:43.580]                             ns <- base::getNamespace("future")
[13:33:43.580]                             version <- ns[[".package"]][["version"]]
[13:33:43.580]                             if (is.null(version)) 
[13:33:43.580]                               version <- utils::packageVersion("future")
[13:33:43.580]                           }
[13:33:43.580]                           else {
[13:33:43.580]                             version <- NULL
[13:33:43.580]                           }
[13:33:43.580]                           if (!has_future || version < "1.8.0") {
[13:33:43.580]                             info <- base::c(r_version = base::gsub("R version ", 
[13:33:43.580]                               "", base::R.version$version.string), 
[13:33:43.580]                               platform = base::sprintf("%s (%s-bit)", 
[13:33:43.580]                                 base::R.version$platform, 8 * 
[13:33:43.580]                                   base::.Machine$sizeof.pointer), 
[13:33:43.580]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:43.580]                                 "release", "version")], collapse = " "), 
[13:33:43.580]                               hostname = base::Sys.info()[["nodename"]])
[13:33:43.580]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:33:43.580]                               info)
[13:33:43.580]                             info <- base::paste(info, collapse = "; ")
[13:33:43.580]                             if (!has_future) {
[13:33:43.580]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:43.580]                                 info)
[13:33:43.580]                             }
[13:33:43.580]                             else {
[13:33:43.580]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:43.580]                                 info, version)
[13:33:43.580]                             }
[13:33:43.580]                             base::stop(msg)
[13:33:43.580]                           }
[13:33:43.580]                         })
[13:33:43.580]                       }
[13:33:43.580]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:43.580]                       base::options(mc.cores = 1L)
[13:33:43.580]                     }
[13:33:43.580]                     base::local({
[13:33:43.580]                       for (pkg in "stats") {
[13:33:43.580]                         base::loadNamespace(pkg)
[13:33:43.580]                         base::library(pkg, character.only = TRUE)
[13:33:43.580]                       }
[13:33:43.580]                     })
[13:33:43.580]                   }
[13:33:43.580]                   ...future.strategy.old <- future::plan("list")
[13:33:43.580]                   options(future.plan = NULL)
[13:33:43.580]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:43.580]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:43.580]                 }
[13:33:43.580]                 ...future.workdir <- getwd()
[13:33:43.580]             }
[13:33:43.580]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:43.580]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:43.580]         }
[13:33:43.580]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:43.580]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:43.580]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:43.580]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:43.580]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:43.580]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:43.580]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:43.580]             base::names(...future.oldOptions))
[13:33:43.580]     }
[13:33:43.580]     if (FALSE) {
[13:33:43.580]     }
[13:33:43.580]     else {
[13:33:43.580]         if (TRUE) {
[13:33:43.580]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:43.580]                 open = "w")
[13:33:43.580]         }
[13:33:43.580]         else {
[13:33:43.580]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:43.580]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:43.580]         }
[13:33:43.580]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:43.580]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:43.580]             base::sink(type = "output", split = FALSE)
[13:33:43.580]             base::close(...future.stdout)
[13:33:43.580]         }, add = TRUE)
[13:33:43.580]     }
[13:33:43.580]     ...future.frame <- base::sys.nframe()
[13:33:43.580]     ...future.conditions <- base::list()
[13:33:43.580]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:43.580]     if (FALSE) {
[13:33:43.580]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:43.580]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:43.580]     }
[13:33:43.580]     ...future.result <- base::tryCatch({
[13:33:43.580]         base::withCallingHandlers({
[13:33:43.580]             ...future.value <- base::withVisible(base::local({
[13:33:43.580]                 ...future.makeSendCondition <- base::local({
[13:33:43.580]                   sendCondition <- NULL
[13:33:43.580]                   function(frame = 1L) {
[13:33:43.580]                     if (is.function(sendCondition)) 
[13:33:43.580]                       return(sendCondition)
[13:33:43.580]                     ns <- getNamespace("parallel")
[13:33:43.580]                     if (exists("sendData", mode = "function", 
[13:33:43.580]                       envir = ns)) {
[13:33:43.580]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:43.580]                         envir = ns)
[13:33:43.580]                       envir <- sys.frame(frame)
[13:33:43.580]                       master <- NULL
[13:33:43.580]                       while (!identical(envir, .GlobalEnv) && 
[13:33:43.580]                         !identical(envir, emptyenv())) {
[13:33:43.580]                         if (exists("master", mode = "list", envir = envir, 
[13:33:43.580]                           inherits = FALSE)) {
[13:33:43.580]                           master <- get("master", mode = "list", 
[13:33:43.580]                             envir = envir, inherits = FALSE)
[13:33:43.580]                           if (inherits(master, c("SOCKnode", 
[13:33:43.580]                             "SOCK0node"))) {
[13:33:43.580]                             sendCondition <<- function(cond) {
[13:33:43.580]                               data <- list(type = "VALUE", value = cond, 
[13:33:43.580]                                 success = TRUE)
[13:33:43.580]                               parallel_sendData(master, data)
[13:33:43.580]                             }
[13:33:43.580]                             return(sendCondition)
[13:33:43.580]                           }
[13:33:43.580]                         }
[13:33:43.580]                         frame <- frame + 1L
[13:33:43.580]                         envir <- sys.frame(frame)
[13:33:43.580]                       }
[13:33:43.580]                     }
[13:33:43.580]                     sendCondition <<- function(cond) NULL
[13:33:43.580]                   }
[13:33:43.580]                 })
[13:33:43.580]                 withCallingHandlers({
[13:33:43.580]                   {
[13:33:43.580]                     do.call(function(...) {
[13:33:43.580]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.580]                       if (!identical(...future.globals.maxSize.org, 
[13:33:43.580]                         ...future.globals.maxSize)) {
[13:33:43.580]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.580]                         on.exit(options(oopts), add = TRUE)
[13:33:43.580]                       }
[13:33:43.580]                       {
[13:33:43.580]                         lapply(seq_along(...future.elements_ii), 
[13:33:43.580]                           FUN = function(jj) {
[13:33:43.580]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.580]                             ...future.FUN(...future.X_jj, ...)
[13:33:43.580]                           })
[13:33:43.580]                       }
[13:33:43.580]                     }, args = future.call.arguments)
[13:33:43.580]                   }
[13:33:43.580]                 }, immediateCondition = function(cond) {
[13:33:43.580]                   sendCondition <- ...future.makeSendCondition()
[13:33:43.580]                   sendCondition(cond)
[13:33:43.580]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.580]                   {
[13:33:43.580]                     inherits <- base::inherits
[13:33:43.580]                     invokeRestart <- base::invokeRestart
[13:33:43.580]                     is.null <- base::is.null
[13:33:43.580]                     muffled <- FALSE
[13:33:43.580]                     if (inherits(cond, "message")) {
[13:33:43.580]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:43.580]                       if (muffled) 
[13:33:43.580]                         invokeRestart("muffleMessage")
[13:33:43.580]                     }
[13:33:43.580]                     else if (inherits(cond, "warning")) {
[13:33:43.580]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:43.580]                       if (muffled) 
[13:33:43.580]                         invokeRestart("muffleWarning")
[13:33:43.580]                     }
[13:33:43.580]                     else if (inherits(cond, "condition")) {
[13:33:43.580]                       if (!is.null(pattern)) {
[13:33:43.580]                         computeRestarts <- base::computeRestarts
[13:33:43.580]                         grepl <- base::grepl
[13:33:43.580]                         restarts <- computeRestarts(cond)
[13:33:43.580]                         for (restart in restarts) {
[13:33:43.580]                           name <- restart$name
[13:33:43.580]                           if (is.null(name)) 
[13:33:43.580]                             next
[13:33:43.580]                           if (!grepl(pattern, name)) 
[13:33:43.580]                             next
[13:33:43.580]                           invokeRestart(restart)
[13:33:43.580]                           muffled <- TRUE
[13:33:43.580]                           break
[13:33:43.580]                         }
[13:33:43.580]                       }
[13:33:43.580]                     }
[13:33:43.580]                     invisible(muffled)
[13:33:43.580]                   }
[13:33:43.580]                   muffleCondition(cond)
[13:33:43.580]                 })
[13:33:43.580]             }))
[13:33:43.580]             future::FutureResult(value = ...future.value$value, 
[13:33:43.580]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:43.580]                   ...future.rng), globalenv = if (FALSE) 
[13:33:43.580]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:43.580]                     ...future.globalenv.names))
[13:33:43.580]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:43.580]         }, condition = base::local({
[13:33:43.580]             c <- base::c
[13:33:43.580]             inherits <- base::inherits
[13:33:43.580]             invokeRestart <- base::invokeRestart
[13:33:43.580]             length <- base::length
[13:33:43.580]             list <- base::list
[13:33:43.580]             seq.int <- base::seq.int
[13:33:43.580]             signalCondition <- base::signalCondition
[13:33:43.580]             sys.calls <- base::sys.calls
[13:33:43.580]             `[[` <- base::`[[`
[13:33:43.580]             `+` <- base::`+`
[13:33:43.580]             `<<-` <- base::`<<-`
[13:33:43.580]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:43.580]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:43.580]                   3L)]
[13:33:43.580]             }
[13:33:43.580]             function(cond) {
[13:33:43.580]                 is_error <- inherits(cond, "error")
[13:33:43.580]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:43.580]                   NULL)
[13:33:43.580]                 if (is_error) {
[13:33:43.580]                   sessionInformation <- function() {
[13:33:43.580]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:43.580]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:43.580]                       search = base::search(), system = base::Sys.info())
[13:33:43.580]                   }
[13:33:43.580]                   ...future.conditions[[length(...future.conditions) + 
[13:33:43.580]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:43.580]                     cond$call), session = sessionInformation(), 
[13:33:43.580]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:43.580]                   signalCondition(cond)
[13:33:43.580]                 }
[13:33:43.580]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:43.580]                 "immediateCondition"))) {
[13:33:43.580]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:43.580]                   ...future.conditions[[length(...future.conditions) + 
[13:33:43.580]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:43.580]                   if (TRUE && !signal) {
[13:33:43.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.580]                     {
[13:33:43.580]                       inherits <- base::inherits
[13:33:43.580]                       invokeRestart <- base::invokeRestart
[13:33:43.580]                       is.null <- base::is.null
[13:33:43.580]                       muffled <- FALSE
[13:33:43.580]                       if (inherits(cond, "message")) {
[13:33:43.580]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:43.580]                         if (muffled) 
[13:33:43.580]                           invokeRestart("muffleMessage")
[13:33:43.580]                       }
[13:33:43.580]                       else if (inherits(cond, "warning")) {
[13:33:43.580]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:43.580]                         if (muffled) 
[13:33:43.580]                           invokeRestart("muffleWarning")
[13:33:43.580]                       }
[13:33:43.580]                       else if (inherits(cond, "condition")) {
[13:33:43.580]                         if (!is.null(pattern)) {
[13:33:43.580]                           computeRestarts <- base::computeRestarts
[13:33:43.580]                           grepl <- base::grepl
[13:33:43.580]                           restarts <- computeRestarts(cond)
[13:33:43.580]                           for (restart in restarts) {
[13:33:43.580]                             name <- restart$name
[13:33:43.580]                             if (is.null(name)) 
[13:33:43.580]                               next
[13:33:43.580]                             if (!grepl(pattern, name)) 
[13:33:43.580]                               next
[13:33:43.580]                             invokeRestart(restart)
[13:33:43.580]                             muffled <- TRUE
[13:33:43.580]                             break
[13:33:43.580]                           }
[13:33:43.580]                         }
[13:33:43.580]                       }
[13:33:43.580]                       invisible(muffled)
[13:33:43.580]                     }
[13:33:43.580]                     muffleCondition(cond, pattern = "^muffle")
[13:33:43.580]                   }
[13:33:43.580]                 }
[13:33:43.580]                 else {
[13:33:43.580]                   if (TRUE) {
[13:33:43.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.580]                     {
[13:33:43.580]                       inherits <- base::inherits
[13:33:43.580]                       invokeRestart <- base::invokeRestart
[13:33:43.580]                       is.null <- base::is.null
[13:33:43.580]                       muffled <- FALSE
[13:33:43.580]                       if (inherits(cond, "message")) {
[13:33:43.580]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:43.580]                         if (muffled) 
[13:33:43.580]                           invokeRestart("muffleMessage")
[13:33:43.580]                       }
[13:33:43.580]                       else if (inherits(cond, "warning")) {
[13:33:43.580]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:43.580]                         if (muffled) 
[13:33:43.580]                           invokeRestart("muffleWarning")
[13:33:43.580]                       }
[13:33:43.580]                       else if (inherits(cond, "condition")) {
[13:33:43.580]                         if (!is.null(pattern)) {
[13:33:43.580]                           computeRestarts <- base::computeRestarts
[13:33:43.580]                           grepl <- base::grepl
[13:33:43.580]                           restarts <- computeRestarts(cond)
[13:33:43.580]                           for (restart in restarts) {
[13:33:43.580]                             name <- restart$name
[13:33:43.580]                             if (is.null(name)) 
[13:33:43.580]                               next
[13:33:43.580]                             if (!grepl(pattern, name)) 
[13:33:43.580]                               next
[13:33:43.580]                             invokeRestart(restart)
[13:33:43.580]                             muffled <- TRUE
[13:33:43.580]                             break
[13:33:43.580]                           }
[13:33:43.580]                         }
[13:33:43.580]                       }
[13:33:43.580]                       invisible(muffled)
[13:33:43.580]                     }
[13:33:43.580]                     muffleCondition(cond, pattern = "^muffle")
[13:33:43.580]                   }
[13:33:43.580]                 }
[13:33:43.580]             }
[13:33:43.580]         }))
[13:33:43.580]     }, error = function(ex) {
[13:33:43.580]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:43.580]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:43.580]                 ...future.rng), started = ...future.startTime, 
[13:33:43.580]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:43.580]             version = "1.8"), class = "FutureResult")
[13:33:43.580]     }, finally = {
[13:33:43.580]         if (!identical(...future.workdir, getwd())) 
[13:33:43.580]             setwd(...future.workdir)
[13:33:43.580]         {
[13:33:43.580]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:43.580]                 ...future.oldOptions$nwarnings <- NULL
[13:33:43.580]             }
[13:33:43.580]             base::options(...future.oldOptions)
[13:33:43.580]             if (.Platform$OS.type == "windows") {
[13:33:43.580]                 old_names <- names(...future.oldEnvVars)
[13:33:43.580]                 envs <- base::Sys.getenv()
[13:33:43.580]                 names <- names(envs)
[13:33:43.580]                 common <- intersect(names, old_names)
[13:33:43.580]                 added <- setdiff(names, old_names)
[13:33:43.580]                 removed <- setdiff(old_names, names)
[13:33:43.580]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:43.580]                   envs[common]]
[13:33:43.580]                 NAMES <- toupper(changed)
[13:33:43.580]                 args <- list()
[13:33:43.580]                 for (kk in seq_along(NAMES)) {
[13:33:43.580]                   name <- changed[[kk]]
[13:33:43.580]                   NAME <- NAMES[[kk]]
[13:33:43.580]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.580]                     next
[13:33:43.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:43.580]                 }
[13:33:43.580]                 NAMES <- toupper(added)
[13:33:43.580]                 for (kk in seq_along(NAMES)) {
[13:33:43.580]                   name <- added[[kk]]
[13:33:43.580]                   NAME <- NAMES[[kk]]
[13:33:43.580]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.580]                     next
[13:33:43.580]                   args[[name]] <- ""
[13:33:43.580]                 }
[13:33:43.580]                 NAMES <- toupper(removed)
[13:33:43.580]                 for (kk in seq_along(NAMES)) {
[13:33:43.580]                   name <- removed[[kk]]
[13:33:43.580]                   NAME <- NAMES[[kk]]
[13:33:43.580]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.580]                     next
[13:33:43.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:43.580]                 }
[13:33:43.580]                 if (length(args) > 0) 
[13:33:43.580]                   base::do.call(base::Sys.setenv, args = args)
[13:33:43.580]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:43.580]             }
[13:33:43.580]             else {
[13:33:43.580]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:43.580]             }
[13:33:43.580]             {
[13:33:43.580]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:43.580]                   0L) {
[13:33:43.580]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:43.580]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:43.580]                   base::options(opts)
[13:33:43.580]                 }
[13:33:43.580]                 {
[13:33:43.580]                   {
[13:33:43.580]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:43.580]                     NULL
[13:33:43.580]                   }
[13:33:43.580]                   options(future.plan = NULL)
[13:33:43.580]                   if (is.na(NA_character_)) 
[13:33:43.580]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:43.580]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:43.580]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:43.580]                     .init = FALSE)
[13:33:43.580]                 }
[13:33:43.580]             }
[13:33:43.580]         }
[13:33:43.580]     })
[13:33:43.580]     if (TRUE) {
[13:33:43.580]         base::sink(type = "output", split = FALSE)
[13:33:43.580]         if (TRUE) {
[13:33:43.580]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:43.580]         }
[13:33:43.580]         else {
[13:33:43.580]             ...future.result["stdout"] <- base::list(NULL)
[13:33:43.580]         }
[13:33:43.580]         base::close(...future.stdout)
[13:33:43.580]         ...future.stdout <- NULL
[13:33:43.580]     }
[13:33:43.580]     ...future.result$conditions <- ...future.conditions
[13:33:43.580]     ...future.result$finished <- base::Sys.time()
[13:33:43.580]     ...future.result
[13:33:43.580] }
[13:33:43.583] Exporting 5 global objects (5.26 KiB) to cluster node #2 ...
[13:33:43.583] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ...
[13:33:43.583] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ... DONE
[13:33:43.584] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[13:33:43.584] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[13:33:43.584] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[13:33:43.584] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[13:33:43.585] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:33:43.585] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:33:43.585] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:33:43.585] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:33:43.585] Exporting 5 global objects (5.26 KiB) to cluster node #2 ... DONE
[13:33:43.586] MultisessionFuture started
[13:33:43.586] - Launch lazy future ... done
[13:33:43.586] run() for ‘MultisessionFuture’ ... done
[13:33:43.586] Created future:
[13:33:43.586] MultisessionFuture:
[13:33:43.586] Label: ‘future_by-2’
[13:33:43.586] Expression:
[13:33:43.586] {
[13:33:43.586]     do.call(function(...) {
[13:33:43.586]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.586]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:43.586]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.586]             on.exit(options(oopts), add = TRUE)
[13:33:43.586]         }
[13:33:43.586]         {
[13:33:43.586]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:43.586]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.586]                 ...future.FUN(...future.X_jj, ...)
[13:33:43.586]             })
[13:33:43.586]         }
[13:33:43.586]     }, args = future.call.arguments)
[13:33:43.586] }
[13:33:43.586] Lazy evaluation: FALSE
[13:33:43.586] Asynchronous evaluation: TRUE
[13:33:43.586] Local evaluation: TRUE
[13:33:43.586] Environment: R_GlobalEnv
[13:33:43.586] Capture standard output: TRUE
[13:33:43.586] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:43.586] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:43.586] Packages: 1 packages (‘stats’)
[13:33:43.586] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:43.586] Resolved: FALSE
[13:33:43.586] Value: <not collected>
[13:33:43.586] Conditions captured: <none>
[13:33:43.586] Early signaling: FALSE
[13:33:43.586] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:43.586] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:43.598] Chunk #2 of 2 ... DONE
[13:33:43.598] Launching 2 futures (chunks) ... DONE
[13:33:43.598] Resolving 2 futures (chunks) ...
[13:33:43.598] resolve() on list ...
[13:33:43.598]  recursive: 0
[13:33:43.598]  length: 2
[13:33:43.598] 
[13:33:43.599] receiveMessageFromWorker() for ClusterFuture ...
[13:33:43.599] - Validating connection of MultisessionFuture
[13:33:43.599] - received message: FutureResult
[13:33:43.599] - Received FutureResult
[13:33:43.600] - Erased future from FutureRegistry
[13:33:43.600] result() for ClusterFuture ...
[13:33:43.600] - result already collected: FutureResult
[13:33:43.600] result() for ClusterFuture ... done
[13:33:43.600] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:43.600] Future #1
[13:33:43.600] result() for ClusterFuture ...
[13:33:43.600] - result already collected: FutureResult
[13:33:43.600] result() for ClusterFuture ... done
[13:33:43.600] result() for ClusterFuture ...
[13:33:43.600] - result already collected: FutureResult
[13:33:43.600] result() for ClusterFuture ... done
[13:33:43.601] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:33:43.601] - nx: 2
[13:33:43.601] - relay: TRUE
[13:33:43.601] - stdout: TRUE
[13:33:43.601] - signal: TRUE
[13:33:43.601] - resignal: FALSE
[13:33:43.601] - force: TRUE
[13:33:43.601] - relayed: [n=2] FALSE, FALSE
[13:33:43.601] - queued futures: [n=2] FALSE, FALSE
[13:33:43.601]  - until=1
[13:33:43.601]  - relaying element #1
[13:33:43.602] result() for ClusterFuture ...
[13:33:43.602] - result already collected: FutureResult
[13:33:43.602] result() for ClusterFuture ... done
[13:33:43.602] result() for ClusterFuture ...
[13:33:43.602] - result already collected: FutureResult
[13:33:43.602] result() for ClusterFuture ... done
[13:33:43.602] result() for ClusterFuture ...
[13:33:43.602] - result already collected: FutureResult
[13:33:43.602] result() for ClusterFuture ... done
[13:33:43.602] result() for ClusterFuture ...
[13:33:43.602] - result already collected: FutureResult
[13:33:43.603] result() for ClusterFuture ... done
[13:33:43.603] - relayed: [n=2] TRUE, FALSE
[13:33:43.603] - queued futures: [n=2] TRUE, FALSE
[13:33:43.603] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:33:43.603]  length: 1 (resolved future 1)
[13:33:43.632] receiveMessageFromWorker() for ClusterFuture ...
[13:33:43.632] - Validating connection of MultisessionFuture
[13:33:43.632] - received message: FutureResult
[13:33:43.633] - Received FutureResult
[13:33:43.633] - Erased future from FutureRegistry
[13:33:43.633] result() for ClusterFuture ...
[13:33:43.633] - result already collected: FutureResult
[13:33:43.633] result() for ClusterFuture ... done
[13:33:43.633] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:43.633] Future #2
[13:33:43.633] result() for ClusterFuture ...
[13:33:43.633] - result already collected: FutureResult
[13:33:43.633] result() for ClusterFuture ... done
[13:33:43.634] result() for ClusterFuture ...
[13:33:43.634] - result already collected: FutureResult
[13:33:43.634] result() for ClusterFuture ... done
[13:33:43.634] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:33:43.634] - nx: 2
[13:33:43.634] - relay: TRUE
[13:33:43.634] - stdout: TRUE
[13:33:43.634] - signal: TRUE
[13:33:43.634] - resignal: FALSE
[13:33:43.634] - force: TRUE
[13:33:43.634] - relayed: [n=2] TRUE, FALSE
[13:33:43.634] - queued futures: [n=2] TRUE, FALSE
[13:33:43.635]  - until=2
[13:33:43.635]  - relaying element #2
[13:33:43.635] result() for ClusterFuture ...
[13:33:43.635] - result already collected: FutureResult
[13:33:43.635] result() for ClusterFuture ... done
[13:33:43.635] result() for ClusterFuture ...
[13:33:43.635] - result already collected: FutureResult
[13:33:43.635] result() for ClusterFuture ... done
[13:33:43.635] result() for ClusterFuture ...
[13:33:43.635] - result already collected: FutureResult
[13:33:43.636] result() for ClusterFuture ... done
[13:33:43.636] result() for ClusterFuture ...
[13:33:43.636] - result already collected: FutureResult
[13:33:43.636] result() for ClusterFuture ... done
[13:33:43.636] - relayed: [n=2] TRUE, TRUE
[13:33:43.636] - queued futures: [n=2] TRUE, TRUE
[13:33:43.636] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:33:43.636]  length: 0 (resolved future 2)
[13:33:43.636] Relaying remaining futures
[13:33:43.636] signalConditionsASAP(NULL, pos=0) ...
[13:33:43.636] - nx: 2
[13:33:43.636] - relay: TRUE
[13:33:43.637] - stdout: TRUE
[13:33:43.637] - signal: TRUE
[13:33:43.637] - resignal: FALSE
[13:33:43.637] - force: TRUE
[13:33:43.637] - relayed: [n=2] TRUE, TRUE
[13:33:43.637] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:43.637] - relayed: [n=2] TRUE, TRUE
[13:33:43.637] - queued futures: [n=2] TRUE, TRUE
[13:33:43.637] signalConditionsASAP(NULL, pos=0) ... done
[13:33:43.637] resolve() on list ... DONE
[13:33:43.637] result() for ClusterFuture ...
[13:33:43.638] - result already collected: FutureResult
[13:33:43.638] result() for ClusterFuture ... done
[13:33:43.638] result() for ClusterFuture ...
[13:33:43.638] - result already collected: FutureResult
[13:33:43.638] result() for ClusterFuture ... done
[13:33:43.638] result() for ClusterFuture ...
[13:33:43.638] - result already collected: FutureResult
[13:33:43.638] result() for ClusterFuture ... done
[13:33:43.638] result() for ClusterFuture ...
[13:33:43.638] - result already collected: FutureResult
[13:33:43.638] result() for ClusterFuture ... done
[13:33:43.639]  - Number of value chunks collected: 2
[13:33:43.639] Resolving 2 futures (chunks) ... DONE
[13:33:43.639] Reducing values from 2 chunks ...
[13:33:43.639]  - Number of values collected after concatenation: 3
[13:33:43.639]  - Number of values expected: 3
[13:33:43.639] Reducing values from 2 chunks ... DONE
[13:33:43.639] future_lapply() ... DONE
[13:33:43.639] future_by_internal() ... DONE
[13:33:43.643] future_by_internal() ...
[13:33:43.643] future_lapply() ...
[13:33:43.648] Number of chunks: 2
[13:33:43.648] getGlobalsAndPackagesXApply() ...
[13:33:43.648]  - future.globals: TRUE
[13:33:43.648] getGlobalsAndPackages() ...
[13:33:43.648] Searching for globals...
[13:33:43.650] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[13:33:43.650] Searching for globals ... DONE
[13:33:43.650] Resolving globals: FALSE
[13:33:43.650] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[13:33:43.651] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[13:33:43.651] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[13:33:43.651] - packages: [1] ‘stats’
[13:33:43.651] getGlobalsAndPackages() ... DONE
[13:33:43.651]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[13:33:43.651]  - needed namespaces: [n=1] ‘stats’
[13:33:43.651] Finding globals ... DONE
[13:33:43.651]  - use_args: TRUE
[13:33:43.652]  - Getting '...' globals ...
[13:33:43.652] resolve() on list ...
[13:33:43.652]  recursive: 0
[13:33:43.652]  length: 1
[13:33:43.652]  elements: ‘...’
[13:33:43.652]  length: 0 (resolved future 1)
[13:33:43.652] resolve() on list ... DONE
[13:33:43.652]    - '...' content: [n=0] 
[13:33:43.652] List of 1
[13:33:43.652]  $ ...: list()
[13:33:43.652]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:43.652]  - attr(*, "where")=List of 1
[13:33:43.652]   ..$ ...:<environment: 0x55cb82e54460> 
[13:33:43.652]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:43.652]  - attr(*, "resolved")= logi TRUE
[13:33:43.652]  - attr(*, "total_size")= num NA
[13:33:43.655]  - Getting '...' globals ... DONE
[13:33:43.655] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[13:33:43.655] List of 4
[13:33:43.655]  $ ...future.FUN:function (x)  
[13:33:43.655]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[13:33:43.655]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[13:33:43.655]  $ ...          : list()
[13:33:43.655]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:43.655]  - attr(*, "where")=List of 4
[13:33:43.655]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:43.655]   ..$ breaks       :<environment: R_EmptyEnv> 
[13:33:43.655]   ..$ wool         :<environment: R_EmptyEnv> 
[13:33:43.655]   ..$ ...          :<environment: 0x55cb82e54460> 
[13:33:43.655]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:43.655]  - attr(*, "resolved")= logi FALSE
[13:33:43.655]  - attr(*, "total_size")= num 2320
[13:33:43.659] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:43.659] getGlobalsAndPackagesXApply() ... DONE
[13:33:43.659] Number of futures (= number of chunks): 2
[13:33:43.659] Launching 2 futures (chunks) ...
[13:33:43.660] Chunk #1 of 2 ...
[13:33:43.660]  - Finding globals in 'X' for chunk #1 ...
[13:33:43.660] getGlobalsAndPackages() ...
[13:33:43.660] Searching for globals...
[13:33:43.660] 
[13:33:43.660] Searching for globals ... DONE
[13:33:43.660] - globals: [0] <none>
[13:33:43.660] getGlobalsAndPackages() ... DONE
[13:33:43.661]    + additional globals found: [n=0] 
[13:33:43.661]    + additional namespaces needed: [n=0] 
[13:33:43.661]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:43.661]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:43.661]  - seeds: <none>
[13:33:43.661]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.661] getGlobalsAndPackages() ...
[13:33:43.661] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.661] Resolving globals: FALSE
[13:33:43.661] Tweak future expression to call with '...' arguments ...
[13:33:43.662] {
[13:33:43.662]     do.call(function(...) {
[13:33:43.662]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.662]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:43.662]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.662]             on.exit(options(oopts), add = TRUE)
[13:33:43.662]         }
[13:33:43.662]         {
[13:33:43.662]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:43.662]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.662]                 ...future.FUN(...future.X_jj, ...)
[13:33:43.662]             })
[13:33:43.662]         }
[13:33:43.662]     }, args = future.call.arguments)
[13:33:43.662] }
[13:33:43.662] Tweak future expression to call with '...' arguments ... DONE
[13:33:43.662] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.662] 
[13:33:43.662] getGlobalsAndPackages() ... DONE
[13:33:43.663] run() for ‘Future’ ...
[13:33:43.663] - state: ‘created’
[13:33:43.663] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:43.677] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:43.677] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:43.677]   - Field: ‘node’
[13:33:43.677]   - Field: ‘label’
[13:33:43.678]   - Field: ‘local’
[13:33:43.678]   - Field: ‘owner’
[13:33:43.678]   - Field: ‘envir’
[13:33:43.678]   - Field: ‘workers’
[13:33:43.678]   - Field: ‘packages’
[13:33:43.678]   - Field: ‘gc’
[13:33:43.678]   - Field: ‘conditions’
[13:33:43.678]   - Field: ‘persistent’
[13:33:43.678]   - Field: ‘expr’
[13:33:43.678]   - Field: ‘uuid’
[13:33:43.679]   - Field: ‘seed’
[13:33:43.679]   - Field: ‘version’
[13:33:43.679]   - Field: ‘result’
[13:33:43.679]   - Field: ‘asynchronous’
[13:33:43.679]   - Field: ‘calls’
[13:33:43.679]   - Field: ‘globals’
[13:33:43.679]   - Field: ‘stdout’
[13:33:43.679]   - Field: ‘earlySignal’
[13:33:43.679]   - Field: ‘lazy’
[13:33:43.679]   - Field: ‘state’
[13:33:43.679] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:43.680] - Launch lazy future ...
[13:33:43.680] Packages needed by the future expression (n = 1): ‘stats’
[13:33:43.680] Packages needed by future strategies (n = 0): <none>
[13:33:43.680] {
[13:33:43.680]     {
[13:33:43.680]         {
[13:33:43.680]             ...future.startTime <- base::Sys.time()
[13:33:43.680]             {
[13:33:43.680]                 {
[13:33:43.680]                   {
[13:33:43.680]                     {
[13:33:43.680]                       {
[13:33:43.680]                         base::local({
[13:33:43.680]                           has_future <- base::requireNamespace("future", 
[13:33:43.680]                             quietly = TRUE)
[13:33:43.680]                           if (has_future) {
[13:33:43.680]                             ns <- base::getNamespace("future")
[13:33:43.680]                             version <- ns[[".package"]][["version"]]
[13:33:43.680]                             if (is.null(version)) 
[13:33:43.680]                               version <- utils::packageVersion("future")
[13:33:43.680]                           }
[13:33:43.680]                           else {
[13:33:43.680]                             version <- NULL
[13:33:43.680]                           }
[13:33:43.680]                           if (!has_future || version < "1.8.0") {
[13:33:43.680]                             info <- base::c(r_version = base::gsub("R version ", 
[13:33:43.680]                               "", base::R.version$version.string), 
[13:33:43.680]                               platform = base::sprintf("%s (%s-bit)", 
[13:33:43.680]                                 base::R.version$platform, 8 * 
[13:33:43.680]                                   base::.Machine$sizeof.pointer), 
[13:33:43.680]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:43.680]                                 "release", "version")], collapse = " "), 
[13:33:43.680]                               hostname = base::Sys.info()[["nodename"]])
[13:33:43.680]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:33:43.680]                               info)
[13:33:43.680]                             info <- base::paste(info, collapse = "; ")
[13:33:43.680]                             if (!has_future) {
[13:33:43.680]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:43.680]                                 info)
[13:33:43.680]                             }
[13:33:43.680]                             else {
[13:33:43.680]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:43.680]                                 info, version)
[13:33:43.680]                             }
[13:33:43.680]                             base::stop(msg)
[13:33:43.680]                           }
[13:33:43.680]                         })
[13:33:43.680]                       }
[13:33:43.680]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:43.680]                       base::options(mc.cores = 1L)
[13:33:43.680]                     }
[13:33:43.680]                     base::local({
[13:33:43.680]                       for (pkg in "stats") {
[13:33:43.680]                         base::loadNamespace(pkg)
[13:33:43.680]                         base::library(pkg, character.only = TRUE)
[13:33:43.680]                       }
[13:33:43.680]                     })
[13:33:43.680]                   }
[13:33:43.680]                   ...future.strategy.old <- future::plan("list")
[13:33:43.680]                   options(future.plan = NULL)
[13:33:43.680]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:43.680]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:43.680]                 }
[13:33:43.680]                 ...future.workdir <- getwd()
[13:33:43.680]             }
[13:33:43.680]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:43.680]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:43.680]         }
[13:33:43.680]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:43.680]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:43.680]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:43.680]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:43.680]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:43.680]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:43.680]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:43.680]             base::names(...future.oldOptions))
[13:33:43.680]     }
[13:33:43.680]     if (FALSE) {
[13:33:43.680]     }
[13:33:43.680]     else {
[13:33:43.680]         if (TRUE) {
[13:33:43.680]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:43.680]                 open = "w")
[13:33:43.680]         }
[13:33:43.680]         else {
[13:33:43.680]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:43.680]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:43.680]         }
[13:33:43.680]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:43.680]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:43.680]             base::sink(type = "output", split = FALSE)
[13:33:43.680]             base::close(...future.stdout)
[13:33:43.680]         }, add = TRUE)
[13:33:43.680]     }
[13:33:43.680]     ...future.frame <- base::sys.nframe()
[13:33:43.680]     ...future.conditions <- base::list()
[13:33:43.680]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:43.680]     if (FALSE) {
[13:33:43.680]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:43.680]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:43.680]     }
[13:33:43.680]     ...future.result <- base::tryCatch({
[13:33:43.680]         base::withCallingHandlers({
[13:33:43.680]             ...future.value <- base::withVisible(base::local({
[13:33:43.680]                 ...future.makeSendCondition <- base::local({
[13:33:43.680]                   sendCondition <- NULL
[13:33:43.680]                   function(frame = 1L) {
[13:33:43.680]                     if (is.function(sendCondition)) 
[13:33:43.680]                       return(sendCondition)
[13:33:43.680]                     ns <- getNamespace("parallel")
[13:33:43.680]                     if (exists("sendData", mode = "function", 
[13:33:43.680]                       envir = ns)) {
[13:33:43.680]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:43.680]                         envir = ns)
[13:33:43.680]                       envir <- sys.frame(frame)
[13:33:43.680]                       master <- NULL
[13:33:43.680]                       while (!identical(envir, .GlobalEnv) && 
[13:33:43.680]                         !identical(envir, emptyenv())) {
[13:33:43.680]                         if (exists("master", mode = "list", envir = envir, 
[13:33:43.680]                           inherits = FALSE)) {
[13:33:43.680]                           master <- get("master", mode = "list", 
[13:33:43.680]                             envir = envir, inherits = FALSE)
[13:33:43.680]                           if (inherits(master, c("SOCKnode", 
[13:33:43.680]                             "SOCK0node"))) {
[13:33:43.680]                             sendCondition <<- function(cond) {
[13:33:43.680]                               data <- list(type = "VALUE", value = cond, 
[13:33:43.680]                                 success = TRUE)
[13:33:43.680]                               parallel_sendData(master, data)
[13:33:43.680]                             }
[13:33:43.680]                             return(sendCondition)
[13:33:43.680]                           }
[13:33:43.680]                         }
[13:33:43.680]                         frame <- frame + 1L
[13:33:43.680]                         envir <- sys.frame(frame)
[13:33:43.680]                       }
[13:33:43.680]                     }
[13:33:43.680]                     sendCondition <<- function(cond) NULL
[13:33:43.680]                   }
[13:33:43.680]                 })
[13:33:43.680]                 withCallingHandlers({
[13:33:43.680]                   {
[13:33:43.680]                     do.call(function(...) {
[13:33:43.680]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.680]                       if (!identical(...future.globals.maxSize.org, 
[13:33:43.680]                         ...future.globals.maxSize)) {
[13:33:43.680]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.680]                         on.exit(options(oopts), add = TRUE)
[13:33:43.680]                       }
[13:33:43.680]                       {
[13:33:43.680]                         lapply(seq_along(...future.elements_ii), 
[13:33:43.680]                           FUN = function(jj) {
[13:33:43.680]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.680]                             ...future.FUN(...future.X_jj, ...)
[13:33:43.680]                           })
[13:33:43.680]                       }
[13:33:43.680]                     }, args = future.call.arguments)
[13:33:43.680]                   }
[13:33:43.680]                 }, immediateCondition = function(cond) {
[13:33:43.680]                   sendCondition <- ...future.makeSendCondition()
[13:33:43.680]                   sendCondition(cond)
[13:33:43.680]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.680]                   {
[13:33:43.680]                     inherits <- base::inherits
[13:33:43.680]                     invokeRestart <- base::invokeRestart
[13:33:43.680]                     is.null <- base::is.null
[13:33:43.680]                     muffled <- FALSE
[13:33:43.680]                     if (inherits(cond, "message")) {
[13:33:43.680]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:43.680]                       if (muffled) 
[13:33:43.680]                         invokeRestart("muffleMessage")
[13:33:43.680]                     }
[13:33:43.680]                     else if (inherits(cond, "warning")) {
[13:33:43.680]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:43.680]                       if (muffled) 
[13:33:43.680]                         invokeRestart("muffleWarning")
[13:33:43.680]                     }
[13:33:43.680]                     else if (inherits(cond, "condition")) {
[13:33:43.680]                       if (!is.null(pattern)) {
[13:33:43.680]                         computeRestarts <- base::computeRestarts
[13:33:43.680]                         grepl <- base::grepl
[13:33:43.680]                         restarts <- computeRestarts(cond)
[13:33:43.680]                         for (restart in restarts) {
[13:33:43.680]                           name <- restart$name
[13:33:43.680]                           if (is.null(name)) 
[13:33:43.680]                             next
[13:33:43.680]                           if (!grepl(pattern, name)) 
[13:33:43.680]                             next
[13:33:43.680]                           invokeRestart(restart)
[13:33:43.680]                           muffled <- TRUE
[13:33:43.680]                           break
[13:33:43.680]                         }
[13:33:43.680]                       }
[13:33:43.680]                     }
[13:33:43.680]                     invisible(muffled)
[13:33:43.680]                   }
[13:33:43.680]                   muffleCondition(cond)
[13:33:43.680]                 })
[13:33:43.680]             }))
[13:33:43.680]             future::FutureResult(value = ...future.value$value, 
[13:33:43.680]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:43.680]                   ...future.rng), globalenv = if (FALSE) 
[13:33:43.680]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:43.680]                     ...future.globalenv.names))
[13:33:43.680]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:43.680]         }, condition = base::local({
[13:33:43.680]             c <- base::c
[13:33:43.680]             inherits <- base::inherits
[13:33:43.680]             invokeRestart <- base::invokeRestart
[13:33:43.680]             length <- base::length
[13:33:43.680]             list <- base::list
[13:33:43.680]             seq.int <- base::seq.int
[13:33:43.680]             signalCondition <- base::signalCondition
[13:33:43.680]             sys.calls <- base::sys.calls
[13:33:43.680]             `[[` <- base::`[[`
[13:33:43.680]             `+` <- base::`+`
[13:33:43.680]             `<<-` <- base::`<<-`
[13:33:43.680]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:43.680]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:43.680]                   3L)]
[13:33:43.680]             }
[13:33:43.680]             function(cond) {
[13:33:43.680]                 is_error <- inherits(cond, "error")
[13:33:43.680]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:43.680]                   NULL)
[13:33:43.680]                 if (is_error) {
[13:33:43.680]                   sessionInformation <- function() {
[13:33:43.680]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:43.680]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:43.680]                       search = base::search(), system = base::Sys.info())
[13:33:43.680]                   }
[13:33:43.680]                   ...future.conditions[[length(...future.conditions) + 
[13:33:43.680]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:43.680]                     cond$call), session = sessionInformation(), 
[13:33:43.680]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:43.680]                   signalCondition(cond)
[13:33:43.680]                 }
[13:33:43.680]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:43.680]                 "immediateCondition"))) {
[13:33:43.680]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:43.680]                   ...future.conditions[[length(...future.conditions) + 
[13:33:43.680]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:43.680]                   if (TRUE && !signal) {
[13:33:43.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.680]                     {
[13:33:43.680]                       inherits <- base::inherits
[13:33:43.680]                       invokeRestart <- base::invokeRestart
[13:33:43.680]                       is.null <- base::is.null
[13:33:43.680]                       muffled <- FALSE
[13:33:43.680]                       if (inherits(cond, "message")) {
[13:33:43.680]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:43.680]                         if (muffled) 
[13:33:43.680]                           invokeRestart("muffleMessage")
[13:33:43.680]                       }
[13:33:43.680]                       else if (inherits(cond, "warning")) {
[13:33:43.680]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:43.680]                         if (muffled) 
[13:33:43.680]                           invokeRestart("muffleWarning")
[13:33:43.680]                       }
[13:33:43.680]                       else if (inherits(cond, "condition")) {
[13:33:43.680]                         if (!is.null(pattern)) {
[13:33:43.680]                           computeRestarts <- base::computeRestarts
[13:33:43.680]                           grepl <- base::grepl
[13:33:43.680]                           restarts <- computeRestarts(cond)
[13:33:43.680]                           for (restart in restarts) {
[13:33:43.680]                             name <- restart$name
[13:33:43.680]                             if (is.null(name)) 
[13:33:43.680]                               next
[13:33:43.680]                             if (!grepl(pattern, name)) 
[13:33:43.680]                               next
[13:33:43.680]                             invokeRestart(restart)
[13:33:43.680]                             muffled <- TRUE
[13:33:43.680]                             break
[13:33:43.680]                           }
[13:33:43.680]                         }
[13:33:43.680]                       }
[13:33:43.680]                       invisible(muffled)
[13:33:43.680]                     }
[13:33:43.680]                     muffleCondition(cond, pattern = "^muffle")
[13:33:43.680]                   }
[13:33:43.680]                 }
[13:33:43.680]                 else {
[13:33:43.680]                   if (TRUE) {
[13:33:43.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.680]                     {
[13:33:43.680]                       inherits <- base::inherits
[13:33:43.680]                       invokeRestart <- base::invokeRestart
[13:33:43.680]                       is.null <- base::is.null
[13:33:43.680]                       muffled <- FALSE
[13:33:43.680]                       if (inherits(cond, "message")) {
[13:33:43.680]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:43.680]                         if (muffled) 
[13:33:43.680]                           invokeRestart("muffleMessage")
[13:33:43.680]                       }
[13:33:43.680]                       else if (inherits(cond, "warning")) {
[13:33:43.680]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:43.680]                         if (muffled) 
[13:33:43.680]                           invokeRestart("muffleWarning")
[13:33:43.680]                       }
[13:33:43.680]                       else if (inherits(cond, "condition")) {
[13:33:43.680]                         if (!is.null(pattern)) {
[13:33:43.680]                           computeRestarts <- base::computeRestarts
[13:33:43.680]                           grepl <- base::grepl
[13:33:43.680]                           restarts <- computeRestarts(cond)
[13:33:43.680]                           for (restart in restarts) {
[13:33:43.680]                             name <- restart$name
[13:33:43.680]                             if (is.null(name)) 
[13:33:43.680]                               next
[13:33:43.680]                             if (!grepl(pattern, name)) 
[13:33:43.680]                               next
[13:33:43.680]                             invokeRestart(restart)
[13:33:43.680]                             muffled <- TRUE
[13:33:43.680]                             break
[13:33:43.680]                           }
[13:33:43.680]                         }
[13:33:43.680]                       }
[13:33:43.680]                       invisible(muffled)
[13:33:43.680]                     }
[13:33:43.680]                     muffleCondition(cond, pattern = "^muffle")
[13:33:43.680]                   }
[13:33:43.680]                 }
[13:33:43.680]             }
[13:33:43.680]         }))
[13:33:43.680]     }, error = function(ex) {
[13:33:43.680]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:43.680]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:43.680]                 ...future.rng), started = ...future.startTime, 
[13:33:43.680]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:43.680]             version = "1.8"), class = "FutureResult")
[13:33:43.680]     }, finally = {
[13:33:43.680]         if (!identical(...future.workdir, getwd())) 
[13:33:43.680]             setwd(...future.workdir)
[13:33:43.680]         {
[13:33:43.680]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:43.680]                 ...future.oldOptions$nwarnings <- NULL
[13:33:43.680]             }
[13:33:43.680]             base::options(...future.oldOptions)
[13:33:43.680]             if (.Platform$OS.type == "windows") {
[13:33:43.680]                 old_names <- names(...future.oldEnvVars)
[13:33:43.680]                 envs <- base::Sys.getenv()
[13:33:43.680]                 names <- names(envs)
[13:33:43.680]                 common <- intersect(names, old_names)
[13:33:43.680]                 added <- setdiff(names, old_names)
[13:33:43.680]                 removed <- setdiff(old_names, names)
[13:33:43.680]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:43.680]                   envs[common]]
[13:33:43.680]                 NAMES <- toupper(changed)
[13:33:43.680]                 args <- list()
[13:33:43.680]                 for (kk in seq_along(NAMES)) {
[13:33:43.680]                   name <- changed[[kk]]
[13:33:43.680]                   NAME <- NAMES[[kk]]
[13:33:43.680]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.680]                     next
[13:33:43.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:43.680]                 }
[13:33:43.680]                 NAMES <- toupper(added)
[13:33:43.680]                 for (kk in seq_along(NAMES)) {
[13:33:43.680]                   name <- added[[kk]]
[13:33:43.680]                   NAME <- NAMES[[kk]]
[13:33:43.680]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.680]                     next
[13:33:43.680]                   args[[name]] <- ""
[13:33:43.680]                 }
[13:33:43.680]                 NAMES <- toupper(removed)
[13:33:43.680]                 for (kk in seq_along(NAMES)) {
[13:33:43.680]                   name <- removed[[kk]]
[13:33:43.680]                   NAME <- NAMES[[kk]]
[13:33:43.680]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.680]                     next
[13:33:43.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:43.680]                 }
[13:33:43.680]                 if (length(args) > 0) 
[13:33:43.680]                   base::do.call(base::Sys.setenv, args = args)
[13:33:43.680]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:43.680]             }
[13:33:43.680]             else {
[13:33:43.680]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:43.680]             }
[13:33:43.680]             {
[13:33:43.680]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:43.680]                   0L) {
[13:33:43.680]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:43.680]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:43.680]                   base::options(opts)
[13:33:43.680]                 }
[13:33:43.680]                 {
[13:33:43.680]                   {
[13:33:43.680]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:43.680]                     NULL
[13:33:43.680]                   }
[13:33:43.680]                   options(future.plan = NULL)
[13:33:43.680]                   if (is.na(NA_character_)) 
[13:33:43.680]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:43.680]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:43.680]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:43.680]                     .init = FALSE)
[13:33:43.680]                 }
[13:33:43.680]             }
[13:33:43.680]         }
[13:33:43.680]     })
[13:33:43.680]     if (TRUE) {
[13:33:43.680]         base::sink(type = "output", split = FALSE)
[13:33:43.680]         if (TRUE) {
[13:33:43.680]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:43.680]         }
[13:33:43.680]         else {
[13:33:43.680]             ...future.result["stdout"] <- base::list(NULL)
[13:33:43.680]         }
[13:33:43.680]         base::close(...future.stdout)
[13:33:43.680]         ...future.stdout <- NULL
[13:33:43.680]     }
[13:33:43.680]     ...future.result$conditions <- ...future.conditions
[13:33:43.680]     ...future.result$finished <- base::Sys.time()
[13:33:43.680]     ...future.result
[13:33:43.680] }
[13:33:43.685] Exporting 7 global objects (2.27 KiB) to cluster node #1 ...
[13:33:43.685] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ...
[13:33:43.686] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ... DONE
[13:33:43.686] Exporting ‘breaks’ (480 bytes) to cluster node #1 ...
[13:33:43.686] Exporting ‘breaks’ (480 bytes) to cluster node #1 ... DONE
[13:33:43.686] Exporting ‘wool’ (776 bytes) to cluster node #1 ...
[13:33:43.687] Exporting ‘wool’ (776 bytes) to cluster node #1 ... DONE
[13:33:43.687] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:33:43.687] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:33:43.688] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[13:33:43.688] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[13:33:43.688] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:33:43.688] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:33:43.689] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:33:43.689] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:33:43.689] Exporting 7 global objects (2.27 KiB) to cluster node #1 ... DONE
[13:33:43.690] MultisessionFuture started
[13:33:43.690] - Launch lazy future ... done
[13:33:43.690] run() for ‘MultisessionFuture’ ... done
[13:33:43.690] Created future:
[13:33:43.690] MultisessionFuture:
[13:33:43.690] Label: ‘future_by-1’
[13:33:43.690] Expression:
[13:33:43.690] {
[13:33:43.690]     do.call(function(...) {
[13:33:43.690]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.690]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:43.690]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.690]             on.exit(options(oopts), add = TRUE)
[13:33:43.690]         }
[13:33:43.690]         {
[13:33:43.690]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:43.690]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.690]                 ...future.FUN(...future.X_jj, ...)
[13:33:43.690]             })
[13:33:43.690]         }
[13:33:43.690]     }, args = future.call.arguments)
[13:33:43.690] }
[13:33:43.690] Lazy evaluation: FALSE
[13:33:43.690] Asynchronous evaluation: TRUE
[13:33:43.690] Local evaluation: TRUE
[13:33:43.690] Environment: 0x55cb83143988
[13:33:43.690] Capture standard output: TRUE
[13:33:43.690] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:43.690] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[13:33:43.690] Packages: 1 packages (‘stats’)
[13:33:43.690] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:43.690] Resolved: FALSE
[13:33:43.690] Value: <not collected>
[13:33:43.690] Conditions captured: <none>
[13:33:43.690] Early signaling: FALSE
[13:33:43.690] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:43.690] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:43.702] Chunk #1 of 2 ... DONE
[13:33:43.702] Chunk #2 of 2 ...
[13:33:43.702]  - Finding globals in 'X' for chunk #2 ...
[13:33:43.702] getGlobalsAndPackages() ...
[13:33:43.702] Searching for globals...
[13:33:43.703] 
[13:33:43.703] Searching for globals ... DONE
[13:33:43.703] - globals: [0] <none>
[13:33:43.703] getGlobalsAndPackages() ... DONE
[13:33:43.703]    + additional globals found: [n=0] 
[13:33:43.703]    + additional namespaces needed: [n=0] 
[13:33:43.703]  - Finding globals in 'X' for chunk #2 ... DONE
[13:33:43.703]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:43.703]  - seeds: <none>
[13:33:43.703]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.704] getGlobalsAndPackages() ...
[13:33:43.704] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.704] Resolving globals: FALSE
[13:33:43.704] Tweak future expression to call with '...' arguments ...
[13:33:43.704] {
[13:33:43.704]     do.call(function(...) {
[13:33:43.704]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.704]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:43.704]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.704]             on.exit(options(oopts), add = TRUE)
[13:33:43.704]         }
[13:33:43.704]         {
[13:33:43.704]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:43.704]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.704]                 ...future.FUN(...future.X_jj, ...)
[13:33:43.704]             })
[13:33:43.704]         }
[13:33:43.704]     }, args = future.call.arguments)
[13:33:43.704] }
[13:33:43.704] Tweak future expression to call with '...' arguments ... DONE
[13:33:43.705] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.705] 
[13:33:43.705] getGlobalsAndPackages() ... DONE
[13:33:43.705] run() for ‘Future’ ...
[13:33:43.705] - state: ‘created’
[13:33:43.705] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:43.718] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:43.718] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:43.719]   - Field: ‘node’
[13:33:43.719]   - Field: ‘label’
[13:33:43.719]   - Field: ‘local’
[13:33:43.719]   - Field: ‘owner’
[13:33:43.719]   - Field: ‘envir’
[13:33:43.719]   - Field: ‘workers’
[13:33:43.719]   - Field: ‘packages’
[13:33:43.719]   - Field: ‘gc’
[13:33:43.719]   - Field: ‘conditions’
[13:33:43.719]   - Field: ‘persistent’
[13:33:43.719]   - Field: ‘expr’
[13:33:43.720]   - Field: ‘uuid’
[13:33:43.720]   - Field: ‘seed’
[13:33:43.720]   - Field: ‘version’
[13:33:43.720]   - Field: ‘result’
[13:33:43.720]   - Field: ‘asynchronous’
[13:33:43.720]   - Field: ‘calls’
[13:33:43.720]   - Field: ‘globals’
[13:33:43.720]   - Field: ‘stdout’
[13:33:43.720]   - Field: ‘earlySignal’
[13:33:43.720]   - Field: ‘lazy’
[13:33:43.720]   - Field: ‘state’
[13:33:43.721] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:43.721] - Launch lazy future ...
[13:33:43.721] Packages needed by the future expression (n = 1): ‘stats’
[13:33:43.721] Packages needed by future strategies (n = 0): <none>
[13:33:43.721] {
[13:33:43.721]     {
[13:33:43.721]         {
[13:33:43.721]             ...future.startTime <- base::Sys.time()
[13:33:43.721]             {
[13:33:43.721]                 {
[13:33:43.721]                   {
[13:33:43.721]                     {
[13:33:43.721]                       {
[13:33:43.721]                         base::local({
[13:33:43.721]                           has_future <- base::requireNamespace("future", 
[13:33:43.721]                             quietly = TRUE)
[13:33:43.721]                           if (has_future) {
[13:33:43.721]                             ns <- base::getNamespace("future")
[13:33:43.721]                             version <- ns[[".package"]][["version"]]
[13:33:43.721]                             if (is.null(version)) 
[13:33:43.721]                               version <- utils::packageVersion("future")
[13:33:43.721]                           }
[13:33:43.721]                           else {
[13:33:43.721]                             version <- NULL
[13:33:43.721]                           }
[13:33:43.721]                           if (!has_future || version < "1.8.0") {
[13:33:43.721]                             info <- base::c(r_version = base::gsub("R version ", 
[13:33:43.721]                               "", base::R.version$version.string), 
[13:33:43.721]                               platform = base::sprintf("%s (%s-bit)", 
[13:33:43.721]                                 base::R.version$platform, 8 * 
[13:33:43.721]                                   base::.Machine$sizeof.pointer), 
[13:33:43.721]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:43.721]                                 "release", "version")], collapse = " "), 
[13:33:43.721]                               hostname = base::Sys.info()[["nodename"]])
[13:33:43.721]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:33:43.721]                               info)
[13:33:43.721]                             info <- base::paste(info, collapse = "; ")
[13:33:43.721]                             if (!has_future) {
[13:33:43.721]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:43.721]                                 info)
[13:33:43.721]                             }
[13:33:43.721]                             else {
[13:33:43.721]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:43.721]                                 info, version)
[13:33:43.721]                             }
[13:33:43.721]                             base::stop(msg)
[13:33:43.721]                           }
[13:33:43.721]                         })
[13:33:43.721]                       }
[13:33:43.721]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:43.721]                       base::options(mc.cores = 1L)
[13:33:43.721]                     }
[13:33:43.721]                     base::local({
[13:33:43.721]                       for (pkg in "stats") {
[13:33:43.721]                         base::loadNamespace(pkg)
[13:33:43.721]                         base::library(pkg, character.only = TRUE)
[13:33:43.721]                       }
[13:33:43.721]                     })
[13:33:43.721]                   }
[13:33:43.721]                   ...future.strategy.old <- future::plan("list")
[13:33:43.721]                   options(future.plan = NULL)
[13:33:43.721]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:43.721]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:43.721]                 }
[13:33:43.721]                 ...future.workdir <- getwd()
[13:33:43.721]             }
[13:33:43.721]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:43.721]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:43.721]         }
[13:33:43.721]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:43.721]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:43.721]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:43.721]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:43.721]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:43.721]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:43.721]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:43.721]             base::names(...future.oldOptions))
[13:33:43.721]     }
[13:33:43.721]     if (FALSE) {
[13:33:43.721]     }
[13:33:43.721]     else {
[13:33:43.721]         if (TRUE) {
[13:33:43.721]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:43.721]                 open = "w")
[13:33:43.721]         }
[13:33:43.721]         else {
[13:33:43.721]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:43.721]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:43.721]         }
[13:33:43.721]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:43.721]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:43.721]             base::sink(type = "output", split = FALSE)
[13:33:43.721]             base::close(...future.stdout)
[13:33:43.721]         }, add = TRUE)
[13:33:43.721]     }
[13:33:43.721]     ...future.frame <- base::sys.nframe()
[13:33:43.721]     ...future.conditions <- base::list()
[13:33:43.721]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:43.721]     if (FALSE) {
[13:33:43.721]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:43.721]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:43.721]     }
[13:33:43.721]     ...future.result <- base::tryCatch({
[13:33:43.721]         base::withCallingHandlers({
[13:33:43.721]             ...future.value <- base::withVisible(base::local({
[13:33:43.721]                 ...future.makeSendCondition <- base::local({
[13:33:43.721]                   sendCondition <- NULL
[13:33:43.721]                   function(frame = 1L) {
[13:33:43.721]                     if (is.function(sendCondition)) 
[13:33:43.721]                       return(sendCondition)
[13:33:43.721]                     ns <- getNamespace("parallel")
[13:33:43.721]                     if (exists("sendData", mode = "function", 
[13:33:43.721]                       envir = ns)) {
[13:33:43.721]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:43.721]                         envir = ns)
[13:33:43.721]                       envir <- sys.frame(frame)
[13:33:43.721]                       master <- NULL
[13:33:43.721]                       while (!identical(envir, .GlobalEnv) && 
[13:33:43.721]                         !identical(envir, emptyenv())) {
[13:33:43.721]                         if (exists("master", mode = "list", envir = envir, 
[13:33:43.721]                           inherits = FALSE)) {
[13:33:43.721]                           master <- get("master", mode = "list", 
[13:33:43.721]                             envir = envir, inherits = FALSE)
[13:33:43.721]                           if (inherits(master, c("SOCKnode", 
[13:33:43.721]                             "SOCK0node"))) {
[13:33:43.721]                             sendCondition <<- function(cond) {
[13:33:43.721]                               data <- list(type = "VALUE", value = cond, 
[13:33:43.721]                                 success = TRUE)
[13:33:43.721]                               parallel_sendData(master, data)
[13:33:43.721]                             }
[13:33:43.721]                             return(sendCondition)
[13:33:43.721]                           }
[13:33:43.721]                         }
[13:33:43.721]                         frame <- frame + 1L
[13:33:43.721]                         envir <- sys.frame(frame)
[13:33:43.721]                       }
[13:33:43.721]                     }
[13:33:43.721]                     sendCondition <<- function(cond) NULL
[13:33:43.721]                   }
[13:33:43.721]                 })
[13:33:43.721]                 withCallingHandlers({
[13:33:43.721]                   {
[13:33:43.721]                     do.call(function(...) {
[13:33:43.721]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.721]                       if (!identical(...future.globals.maxSize.org, 
[13:33:43.721]                         ...future.globals.maxSize)) {
[13:33:43.721]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.721]                         on.exit(options(oopts), add = TRUE)
[13:33:43.721]                       }
[13:33:43.721]                       {
[13:33:43.721]                         lapply(seq_along(...future.elements_ii), 
[13:33:43.721]                           FUN = function(jj) {
[13:33:43.721]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.721]                             ...future.FUN(...future.X_jj, ...)
[13:33:43.721]                           })
[13:33:43.721]                       }
[13:33:43.721]                     }, args = future.call.arguments)
[13:33:43.721]                   }
[13:33:43.721]                 }, immediateCondition = function(cond) {
[13:33:43.721]                   sendCondition <- ...future.makeSendCondition()
[13:33:43.721]                   sendCondition(cond)
[13:33:43.721]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.721]                   {
[13:33:43.721]                     inherits <- base::inherits
[13:33:43.721]                     invokeRestart <- base::invokeRestart
[13:33:43.721]                     is.null <- base::is.null
[13:33:43.721]                     muffled <- FALSE
[13:33:43.721]                     if (inherits(cond, "message")) {
[13:33:43.721]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:43.721]                       if (muffled) 
[13:33:43.721]                         invokeRestart("muffleMessage")
[13:33:43.721]                     }
[13:33:43.721]                     else if (inherits(cond, "warning")) {
[13:33:43.721]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:43.721]                       if (muffled) 
[13:33:43.721]                         invokeRestart("muffleWarning")
[13:33:43.721]                     }
[13:33:43.721]                     else if (inherits(cond, "condition")) {
[13:33:43.721]                       if (!is.null(pattern)) {
[13:33:43.721]                         computeRestarts <- base::computeRestarts
[13:33:43.721]                         grepl <- base::grepl
[13:33:43.721]                         restarts <- computeRestarts(cond)
[13:33:43.721]                         for (restart in restarts) {
[13:33:43.721]                           name <- restart$name
[13:33:43.721]                           if (is.null(name)) 
[13:33:43.721]                             next
[13:33:43.721]                           if (!grepl(pattern, name)) 
[13:33:43.721]                             next
[13:33:43.721]                           invokeRestart(restart)
[13:33:43.721]                           muffled <- TRUE
[13:33:43.721]                           break
[13:33:43.721]                         }
[13:33:43.721]                       }
[13:33:43.721]                     }
[13:33:43.721]                     invisible(muffled)
[13:33:43.721]                   }
[13:33:43.721]                   muffleCondition(cond)
[13:33:43.721]                 })
[13:33:43.721]             }))
[13:33:43.721]             future::FutureResult(value = ...future.value$value, 
[13:33:43.721]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:43.721]                   ...future.rng), globalenv = if (FALSE) 
[13:33:43.721]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:43.721]                     ...future.globalenv.names))
[13:33:43.721]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:43.721]         }, condition = base::local({
[13:33:43.721]             c <- base::c
[13:33:43.721]             inherits <- base::inherits
[13:33:43.721]             invokeRestart <- base::invokeRestart
[13:33:43.721]             length <- base::length
[13:33:43.721]             list <- base::list
[13:33:43.721]             seq.int <- base::seq.int
[13:33:43.721]             signalCondition <- base::signalCondition
[13:33:43.721]             sys.calls <- base::sys.calls
[13:33:43.721]             `[[` <- base::`[[`
[13:33:43.721]             `+` <- base::`+`
[13:33:43.721]             `<<-` <- base::`<<-`
[13:33:43.721]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:43.721]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:43.721]                   3L)]
[13:33:43.721]             }
[13:33:43.721]             function(cond) {
[13:33:43.721]                 is_error <- inherits(cond, "error")
[13:33:43.721]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:43.721]                   NULL)
[13:33:43.721]                 if (is_error) {
[13:33:43.721]                   sessionInformation <- function() {
[13:33:43.721]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:43.721]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:43.721]                       search = base::search(), system = base::Sys.info())
[13:33:43.721]                   }
[13:33:43.721]                   ...future.conditions[[length(...future.conditions) + 
[13:33:43.721]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:43.721]                     cond$call), session = sessionInformation(), 
[13:33:43.721]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:43.721]                   signalCondition(cond)
[13:33:43.721]                 }
[13:33:43.721]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:43.721]                 "immediateCondition"))) {
[13:33:43.721]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:43.721]                   ...future.conditions[[length(...future.conditions) + 
[13:33:43.721]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:43.721]                   if (TRUE && !signal) {
[13:33:43.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.721]                     {
[13:33:43.721]                       inherits <- base::inherits
[13:33:43.721]                       invokeRestart <- base::invokeRestart
[13:33:43.721]                       is.null <- base::is.null
[13:33:43.721]                       muffled <- FALSE
[13:33:43.721]                       if (inherits(cond, "message")) {
[13:33:43.721]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:43.721]                         if (muffled) 
[13:33:43.721]                           invokeRestart("muffleMessage")
[13:33:43.721]                       }
[13:33:43.721]                       else if (inherits(cond, "warning")) {
[13:33:43.721]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:43.721]                         if (muffled) 
[13:33:43.721]                           invokeRestart("muffleWarning")
[13:33:43.721]                       }
[13:33:43.721]                       else if (inherits(cond, "condition")) {
[13:33:43.721]                         if (!is.null(pattern)) {
[13:33:43.721]                           computeRestarts <- base::computeRestarts
[13:33:43.721]                           grepl <- base::grepl
[13:33:43.721]                           restarts <- computeRestarts(cond)
[13:33:43.721]                           for (restart in restarts) {
[13:33:43.721]                             name <- restart$name
[13:33:43.721]                             if (is.null(name)) 
[13:33:43.721]                               next
[13:33:43.721]                             if (!grepl(pattern, name)) 
[13:33:43.721]                               next
[13:33:43.721]                             invokeRestart(restart)
[13:33:43.721]                             muffled <- TRUE
[13:33:43.721]                             break
[13:33:43.721]                           }
[13:33:43.721]                         }
[13:33:43.721]                       }
[13:33:43.721]                       invisible(muffled)
[13:33:43.721]                     }
[13:33:43.721]                     muffleCondition(cond, pattern = "^muffle")
[13:33:43.721]                   }
[13:33:43.721]                 }
[13:33:43.721]                 else {
[13:33:43.721]                   if (TRUE) {
[13:33:43.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.721]                     {
[13:33:43.721]                       inherits <- base::inherits
[13:33:43.721]                       invokeRestart <- base::invokeRestart
[13:33:43.721]                       is.null <- base::is.null
[13:33:43.721]                       muffled <- FALSE
[13:33:43.721]                       if (inherits(cond, "message")) {
[13:33:43.721]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:43.721]                         if (muffled) 
[13:33:43.721]                           invokeRestart("muffleMessage")
[13:33:43.721]                       }
[13:33:43.721]                       else if (inherits(cond, "warning")) {
[13:33:43.721]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:43.721]                         if (muffled) 
[13:33:43.721]                           invokeRestart("muffleWarning")
[13:33:43.721]                       }
[13:33:43.721]                       else if (inherits(cond, "condition")) {
[13:33:43.721]                         if (!is.null(pattern)) {
[13:33:43.721]                           computeRestarts <- base::computeRestarts
[13:33:43.721]                           grepl <- base::grepl
[13:33:43.721]                           restarts <- computeRestarts(cond)
[13:33:43.721]                           for (restart in restarts) {
[13:33:43.721]                             name <- restart$name
[13:33:43.721]                             if (is.null(name)) 
[13:33:43.721]                               next
[13:33:43.721]                             if (!grepl(pattern, name)) 
[13:33:43.721]                               next
[13:33:43.721]                             invokeRestart(restart)
[13:33:43.721]                             muffled <- TRUE
[13:33:43.721]                             break
[13:33:43.721]                           }
[13:33:43.721]                         }
[13:33:43.721]                       }
[13:33:43.721]                       invisible(muffled)
[13:33:43.721]                     }
[13:33:43.721]                     muffleCondition(cond, pattern = "^muffle")
[13:33:43.721]                   }
[13:33:43.721]                 }
[13:33:43.721]             }
[13:33:43.721]         }))
[13:33:43.721]     }, error = function(ex) {
[13:33:43.721]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:43.721]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:43.721]                 ...future.rng), started = ...future.startTime, 
[13:33:43.721]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:43.721]             version = "1.8"), class = "FutureResult")
[13:33:43.721]     }, finally = {
[13:33:43.721]         if (!identical(...future.workdir, getwd())) 
[13:33:43.721]             setwd(...future.workdir)
[13:33:43.721]         {
[13:33:43.721]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:43.721]                 ...future.oldOptions$nwarnings <- NULL
[13:33:43.721]             }
[13:33:43.721]             base::options(...future.oldOptions)
[13:33:43.721]             if (.Platform$OS.type == "windows") {
[13:33:43.721]                 old_names <- names(...future.oldEnvVars)
[13:33:43.721]                 envs <- base::Sys.getenv()
[13:33:43.721]                 names <- names(envs)
[13:33:43.721]                 common <- intersect(names, old_names)
[13:33:43.721]                 added <- setdiff(names, old_names)
[13:33:43.721]                 removed <- setdiff(old_names, names)
[13:33:43.721]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:43.721]                   envs[common]]
[13:33:43.721]                 NAMES <- toupper(changed)
[13:33:43.721]                 args <- list()
[13:33:43.721]                 for (kk in seq_along(NAMES)) {
[13:33:43.721]                   name <- changed[[kk]]
[13:33:43.721]                   NAME <- NAMES[[kk]]
[13:33:43.721]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.721]                     next
[13:33:43.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:43.721]                 }
[13:33:43.721]                 NAMES <- toupper(added)
[13:33:43.721]                 for (kk in seq_along(NAMES)) {
[13:33:43.721]                   name <- added[[kk]]
[13:33:43.721]                   NAME <- NAMES[[kk]]
[13:33:43.721]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.721]                     next
[13:33:43.721]                   args[[name]] <- ""
[13:33:43.721]                 }
[13:33:43.721]                 NAMES <- toupper(removed)
[13:33:43.721]                 for (kk in seq_along(NAMES)) {
[13:33:43.721]                   name <- removed[[kk]]
[13:33:43.721]                   NAME <- NAMES[[kk]]
[13:33:43.721]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.721]                     next
[13:33:43.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:43.721]                 }
[13:33:43.721]                 if (length(args) > 0) 
[13:33:43.721]                   base::do.call(base::Sys.setenv, args = args)
[13:33:43.721]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:43.721]             }
[13:33:43.721]             else {
[13:33:43.721]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:43.721]             }
[13:33:43.721]             {
[13:33:43.721]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:43.721]                   0L) {
[13:33:43.721]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:43.721]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:43.721]                   base::options(opts)
[13:33:43.721]                 }
[13:33:43.721]                 {
[13:33:43.721]                   {
[13:33:43.721]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:43.721]                     NULL
[13:33:43.721]                   }
[13:33:43.721]                   options(future.plan = NULL)
[13:33:43.721]                   if (is.na(NA_character_)) 
[13:33:43.721]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:43.721]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:43.721]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:43.721]                     .init = FALSE)
[13:33:43.721]                 }
[13:33:43.721]             }
[13:33:43.721]         }
[13:33:43.721]     })
[13:33:43.721]     if (TRUE) {
[13:33:43.721]         base::sink(type = "output", split = FALSE)
[13:33:43.721]         if (TRUE) {
[13:33:43.721]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:43.721]         }
[13:33:43.721]         else {
[13:33:43.721]             ...future.result["stdout"] <- base::list(NULL)
[13:33:43.721]         }
[13:33:43.721]         base::close(...future.stdout)
[13:33:43.721]         ...future.stdout <- NULL
[13:33:43.721]     }
[13:33:43.721]     ...future.result$conditions <- ...future.conditions
[13:33:43.721]     ...future.result$finished <- base::Sys.time()
[13:33:43.721]     ...future.result
[13:33:43.721] }
[13:33:43.724] Exporting 7 global objects (2.27 KiB) to cluster node #2 ...
[13:33:43.724] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ...
[13:33:43.724] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ... DONE
[13:33:43.725] Exporting ‘breaks’ (480 bytes) to cluster node #2 ...
[13:33:43.725] Exporting ‘breaks’ (480 bytes) to cluster node #2 ... DONE
[13:33:43.725] Exporting ‘wool’ (776 bytes) to cluster node #2 ...
[13:33:43.725] Exporting ‘wool’ (776 bytes) to cluster node #2 ... DONE
[13:33:43.725] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:33:43.726] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:33:43.726] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[13:33:43.726] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[13:33:43.727] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:33:43.727] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:33:43.727] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:33:43.727] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:33:43.727] Exporting 7 global objects (2.27 KiB) to cluster node #2 ... DONE
[13:33:43.728] MultisessionFuture started
[13:33:43.728] - Launch lazy future ... done
[13:33:43.728] run() for ‘MultisessionFuture’ ... done
[13:33:43.728] Created future:
[13:33:43.728] MultisessionFuture:
[13:33:43.728] Label: ‘future_by-2’
[13:33:43.728] Expression:
[13:33:43.728] {
[13:33:43.728]     do.call(function(...) {
[13:33:43.728]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.728]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:43.728]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.728]             on.exit(options(oopts), add = TRUE)
[13:33:43.728]         }
[13:33:43.728]         {
[13:33:43.728]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:43.728]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.728]                 ...future.FUN(...future.X_jj, ...)
[13:33:43.728]             })
[13:33:43.728]         }
[13:33:43.728]     }, args = future.call.arguments)
[13:33:43.728] }
[13:33:43.728] Lazy evaluation: FALSE
[13:33:43.728] Asynchronous evaluation: TRUE
[13:33:43.728] Local evaluation: TRUE
[13:33:43.728] Environment: 0x55cb83143988
[13:33:43.728] Capture standard output: TRUE
[13:33:43.728] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:43.728] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[13:33:43.728] Packages: 1 packages (‘stats’)
[13:33:43.728] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:43.728] Resolved: FALSE
[13:33:43.728] Value: <not collected>
[13:33:43.728] Conditions captured: <none>
[13:33:43.728] Early signaling: FALSE
[13:33:43.728] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:43.728] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:43.740] Chunk #2 of 2 ... DONE
[13:33:43.740] Launching 2 futures (chunks) ... DONE
[13:33:43.740] Resolving 2 futures (chunks) ...
[13:33:43.740] resolve() on list ...
[13:33:43.740]  recursive: 0
[13:33:43.740]  length: 2
[13:33:43.740] 
[13:33:43.741] receiveMessageFromWorker() for ClusterFuture ...
[13:33:43.741] - Validating connection of MultisessionFuture
[13:33:43.741] - received message: FutureResult
[13:33:43.741] - Received FutureResult
[13:33:43.741] - Erased future from FutureRegistry
[13:33:43.741] result() for ClusterFuture ...
[13:33:43.741] - result already collected: FutureResult
[13:33:43.741] result() for ClusterFuture ... done
[13:33:43.742] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:43.742] Future #1
[13:33:43.742] result() for ClusterFuture ...
[13:33:43.742] - result already collected: FutureResult
[13:33:43.742] result() for ClusterFuture ... done
[13:33:43.742] result() for ClusterFuture ...
[13:33:43.742] - result already collected: FutureResult
[13:33:43.742] result() for ClusterFuture ... done
[13:33:43.742] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:33:43.742] - nx: 2
[13:33:43.742] - relay: TRUE
[13:33:43.743] - stdout: TRUE
[13:33:43.743] - signal: TRUE
[13:33:43.743] - resignal: FALSE
[13:33:43.743] - force: TRUE
[13:33:43.743] - relayed: [n=2] FALSE, FALSE
[13:33:43.743] - queued futures: [n=2] FALSE, FALSE
[13:33:43.743]  - until=1
[13:33:43.743]  - relaying element #1
[13:33:43.743] result() for ClusterFuture ...
[13:33:43.743] - result already collected: FutureResult
[13:33:43.743] result() for ClusterFuture ... done
[13:33:43.743] result() for ClusterFuture ...
[13:33:43.744] - result already collected: FutureResult
[13:33:43.744] result() for ClusterFuture ... done
[13:33:43.744] result() for ClusterFuture ...
[13:33:43.744] - result already collected: FutureResult
[13:33:43.744] result() for ClusterFuture ... done
[13:33:43.744] result() for ClusterFuture ...
[13:33:43.744] - result already collected: FutureResult
[13:33:43.744] result() for ClusterFuture ... done
[13:33:43.744] - relayed: [n=2] TRUE, FALSE
[13:33:43.744] - queued futures: [n=2] TRUE, FALSE
[13:33:43.744] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:33:43.745]  length: 1 (resolved future 1)
[13:33:43.773] receiveMessageFromWorker() for ClusterFuture ...
[13:33:43.773] - Validating connection of MultisessionFuture
[13:33:43.774] - received message: FutureResult
[13:33:43.774] - Received FutureResult
[13:33:43.774] - Erased future from FutureRegistry
[13:33:43.774] result() for ClusterFuture ...
[13:33:43.774] - result already collected: FutureResult
[13:33:43.774] result() for ClusterFuture ... done
[13:33:43.774] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:43.775] Future #2
[13:33:43.775] result() for ClusterFuture ...
[13:33:43.775] - result already collected: FutureResult
[13:33:43.775] result() for ClusterFuture ... done
[13:33:43.775] result() for ClusterFuture ...
[13:33:43.775] - result already collected: FutureResult
[13:33:43.775] result() for ClusterFuture ... done
[13:33:43.775] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:33:43.775] - nx: 2
[13:33:43.775] - relay: TRUE
[13:33:43.775] - stdout: TRUE
[13:33:43.775] - signal: TRUE
[13:33:43.776] - resignal: FALSE
[13:33:43.776] - force: TRUE
[13:33:43.776] - relayed: [n=2] TRUE, FALSE
[13:33:43.776] - queued futures: [n=2] TRUE, FALSE
[13:33:43.776]  - until=2
[13:33:43.776]  - relaying element #2
[13:33:43.776] result() for ClusterFuture ...
[13:33:43.776] - result already collected: FutureResult
[13:33:43.776] result() for ClusterFuture ... done
[13:33:43.776] result() for ClusterFuture ...
[13:33:43.776] - result already collected: FutureResult
[13:33:43.776] result() for ClusterFuture ... done
[13:33:43.777] result() for ClusterFuture ...
[13:33:43.777] - result already collected: FutureResult
[13:33:43.777] result() for ClusterFuture ... done
[13:33:43.777] result() for ClusterFuture ...
[13:33:43.777] - result already collected: FutureResult
[13:33:43.777] result() for ClusterFuture ... done
[13:33:43.777] - relayed: [n=2] TRUE, TRUE
[13:33:43.777] - queued futures: [n=2] TRUE, TRUE
[13:33:43.777] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:33:43.777]  length: 0 (resolved future 2)
[13:33:43.777] Relaying remaining futures
[13:33:43.778] signalConditionsASAP(NULL, pos=0) ...
[13:33:43.778] - nx: 2
[13:33:43.778] - relay: TRUE
[13:33:43.778] - stdout: TRUE
[13:33:43.778] - signal: TRUE
[13:33:43.778] - resignal: FALSE
[13:33:43.778] - force: TRUE
[13:33:43.778] - relayed: [n=2] TRUE, TRUE
[13:33:43.778] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:43.778] - relayed: [n=2] TRUE, TRUE
[13:33:43.778] - queued futures: [n=2] TRUE, TRUE
[13:33:43.779] signalConditionsASAP(NULL, pos=0) ... done
[13:33:43.779] resolve() on list ... DONE
[13:33:43.779] result() for ClusterFuture ...
[13:33:43.779] - result already collected: FutureResult
[13:33:43.779] result() for ClusterFuture ... done
[13:33:43.779] result() for ClusterFuture ...
[13:33:43.779] - result already collected: FutureResult
[13:33:43.779] result() for ClusterFuture ... done
[13:33:43.779] result() for ClusterFuture ...
[13:33:43.779] - result already collected: FutureResult
[13:33:43.779] result() for ClusterFuture ... done
[13:33:43.779] result() for ClusterFuture ...
[13:33:43.780] - result already collected: FutureResult
[13:33:43.780] result() for ClusterFuture ... done
[13:33:43.780]  - Number of value chunks collected: 2
[13:33:43.780] Resolving 2 futures (chunks) ... DONE
[13:33:43.780] Reducing values from 2 chunks ...
[13:33:43.780]  - Number of values collected after concatenation: 3
[13:33:43.780]  - Number of values expected: 3
[13:33:43.780] Reducing values from 2 chunks ... DONE
[13:33:43.780] future_lapply() ... DONE
[13:33:43.780] future_by_internal() ... DONE
[13:33:43.781] future_by_internal() ...
[13:33:43.781] future_lapply() ...
[13:33:43.785] Number of chunks: 2
[13:33:43.785] getGlobalsAndPackagesXApply() ...
[13:33:43.785]  - future.globals: TRUE
[13:33:43.785] getGlobalsAndPackages() ...
[13:33:43.785] Searching for globals...
[13:33:43.786] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:43.786] Searching for globals ... DONE
[13:33:43.787] Resolving globals: FALSE
[13:33:43.787] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:43.787] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:43.787] - globals: [1] ‘FUN’
[13:33:43.787] 
[13:33:43.787] getGlobalsAndPackages() ... DONE
[13:33:43.788]  - globals found/used: [n=1] ‘FUN’
[13:33:43.788]  - needed namespaces: [n=0] 
[13:33:43.788] Finding globals ... DONE
[13:33:43.788]  - use_args: TRUE
[13:33:43.788]  - Getting '...' globals ...
[13:33:43.788] resolve() on list ...
[13:33:43.788]  recursive: 0
[13:33:43.788]  length: 1
[13:33:43.788]  elements: ‘...’
[13:33:43.789]  length: 0 (resolved future 1)
[13:33:43.789] resolve() on list ... DONE
[13:33:43.789]    - '...' content: [n=0] 
[13:33:43.789] List of 1
[13:33:43.789]  $ ...: list()
[13:33:43.789]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:43.789]  - attr(*, "where")=List of 1
[13:33:43.789]   ..$ ...:<environment: 0x55cb8394a5a8> 
[13:33:43.789]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:43.789]  - attr(*, "resolved")= logi TRUE
[13:33:43.789]  - attr(*, "total_size")= num NA
[13:33:43.791]  - Getting '...' globals ... DONE
[13:33:43.791] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:43.792] List of 2
[13:33:43.792]  $ ...future.FUN:function (object, ...)  
[13:33:43.792]  $ ...          : list()
[13:33:43.792]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:43.792]  - attr(*, "where")=List of 2
[13:33:43.792]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:43.792]   ..$ ...          :<environment: 0x55cb8394a5a8> 
[13:33:43.792]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:43.792]  - attr(*, "resolved")= logi FALSE
[13:33:43.792]  - attr(*, "total_size")= num 1240
[13:33:43.794] Packages to be attached in all futures: [n=0] 
[13:33:43.794] getGlobalsAndPackagesXApply() ... DONE
[13:33:43.794] Number of futures (= number of chunks): 2
[13:33:43.795] Launching 2 futures (chunks) ...
[13:33:43.795] Chunk #1 of 2 ...
[13:33:43.795]  - Finding globals in 'X' for chunk #1 ...
[13:33:43.795] getGlobalsAndPackages() ...
[13:33:43.795] Searching for globals...
[13:33:43.795] 
[13:33:43.795] Searching for globals ... DONE
[13:33:43.795] - globals: [0] <none>
[13:33:43.796] getGlobalsAndPackages() ... DONE
[13:33:43.796]    + additional globals found: [n=0] 
[13:33:43.796]    + additional namespaces needed: [n=0] 
[13:33:43.796]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:43.796]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:43.796]  - seeds: <none>
[13:33:43.796]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.796] getGlobalsAndPackages() ...
[13:33:43.796] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.796] Resolving globals: FALSE
[13:33:43.796] Tweak future expression to call with '...' arguments ...
[13:33:43.797] {
[13:33:43.797]     do.call(function(...) {
[13:33:43.797]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.797]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:43.797]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.797]             on.exit(options(oopts), add = TRUE)
[13:33:43.797]         }
[13:33:43.797]         {
[13:33:43.797]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:43.797]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.797]                 ...future.FUN(...future.X_jj, ...)
[13:33:43.797]             })
[13:33:43.797]         }
[13:33:43.797]     }, args = future.call.arguments)
[13:33:43.797] }
[13:33:43.797] Tweak future expression to call with '...' arguments ... DONE
[13:33:43.797] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.797] 
[13:33:43.797] getGlobalsAndPackages() ... DONE
[13:33:43.798] run() for ‘Future’ ...
[13:33:43.798] - state: ‘created’
[13:33:43.798] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:43.811] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:43.811] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:43.811]   - Field: ‘node’
[13:33:43.811]   - Field: ‘label’
[13:33:43.811]   - Field: ‘local’
[13:33:43.812]   - Field: ‘owner’
[13:33:43.812]   - Field: ‘envir’
[13:33:43.812]   - Field: ‘workers’
[13:33:43.812]   - Field: ‘packages’
[13:33:43.812]   - Field: ‘gc’
[13:33:43.812]   - Field: ‘conditions’
[13:33:43.812]   - Field: ‘persistent’
[13:33:43.812]   - Field: ‘expr’
[13:33:43.812]   - Field: ‘uuid’
[13:33:43.812]   - Field: ‘seed’
[13:33:43.812]   - Field: ‘version’
[13:33:43.813]   - Field: ‘result’
[13:33:43.813]   - Field: ‘asynchronous’
[13:33:43.813]   - Field: ‘calls’
[13:33:43.813]   - Field: ‘globals’
[13:33:43.813]   - Field: ‘stdout’
[13:33:43.813]   - Field: ‘earlySignal’
[13:33:43.813]   - Field: ‘lazy’
[13:33:43.813]   - Field: ‘state’
[13:33:43.813] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:43.813] - Launch lazy future ...
[13:33:43.814] Packages needed by the future expression (n = 0): <none>
[13:33:43.814] Packages needed by future strategies (n = 0): <none>
[13:33:43.814] {
[13:33:43.814]     {
[13:33:43.814]         {
[13:33:43.814]             ...future.startTime <- base::Sys.time()
[13:33:43.814]             {
[13:33:43.814]                 {
[13:33:43.814]                   {
[13:33:43.814]                     {
[13:33:43.814]                       base::local({
[13:33:43.814]                         has_future <- base::requireNamespace("future", 
[13:33:43.814]                           quietly = TRUE)
[13:33:43.814]                         if (has_future) {
[13:33:43.814]                           ns <- base::getNamespace("future")
[13:33:43.814]                           version <- ns[[".package"]][["version"]]
[13:33:43.814]                           if (is.null(version)) 
[13:33:43.814]                             version <- utils::packageVersion("future")
[13:33:43.814]                         }
[13:33:43.814]                         else {
[13:33:43.814]                           version <- NULL
[13:33:43.814]                         }
[13:33:43.814]                         if (!has_future || version < "1.8.0") {
[13:33:43.814]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:43.814]                             "", base::R.version$version.string), 
[13:33:43.814]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:43.814]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:43.814]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:43.814]                               "release", "version")], collapse = " "), 
[13:33:43.814]                             hostname = base::Sys.info()[["nodename"]])
[13:33:43.814]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:43.814]                             info)
[13:33:43.814]                           info <- base::paste(info, collapse = "; ")
[13:33:43.814]                           if (!has_future) {
[13:33:43.814]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:43.814]                               info)
[13:33:43.814]                           }
[13:33:43.814]                           else {
[13:33:43.814]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:43.814]                               info, version)
[13:33:43.814]                           }
[13:33:43.814]                           base::stop(msg)
[13:33:43.814]                         }
[13:33:43.814]                       })
[13:33:43.814]                     }
[13:33:43.814]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:43.814]                     base::options(mc.cores = 1L)
[13:33:43.814]                   }
[13:33:43.814]                   ...future.strategy.old <- future::plan("list")
[13:33:43.814]                   options(future.plan = NULL)
[13:33:43.814]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:43.814]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:43.814]                 }
[13:33:43.814]                 ...future.workdir <- getwd()
[13:33:43.814]             }
[13:33:43.814]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:43.814]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:43.814]         }
[13:33:43.814]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:43.814]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:43.814]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:43.814]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:43.814]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:43.814]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:43.814]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:43.814]             base::names(...future.oldOptions))
[13:33:43.814]     }
[13:33:43.814]     if (FALSE) {
[13:33:43.814]     }
[13:33:43.814]     else {
[13:33:43.814]         if (TRUE) {
[13:33:43.814]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:43.814]                 open = "w")
[13:33:43.814]         }
[13:33:43.814]         else {
[13:33:43.814]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:43.814]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:43.814]         }
[13:33:43.814]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:43.814]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:43.814]             base::sink(type = "output", split = FALSE)
[13:33:43.814]             base::close(...future.stdout)
[13:33:43.814]         }, add = TRUE)
[13:33:43.814]     }
[13:33:43.814]     ...future.frame <- base::sys.nframe()
[13:33:43.814]     ...future.conditions <- base::list()
[13:33:43.814]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:43.814]     if (FALSE) {
[13:33:43.814]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:43.814]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:43.814]     }
[13:33:43.814]     ...future.result <- base::tryCatch({
[13:33:43.814]         base::withCallingHandlers({
[13:33:43.814]             ...future.value <- base::withVisible(base::local({
[13:33:43.814]                 ...future.makeSendCondition <- base::local({
[13:33:43.814]                   sendCondition <- NULL
[13:33:43.814]                   function(frame = 1L) {
[13:33:43.814]                     if (is.function(sendCondition)) 
[13:33:43.814]                       return(sendCondition)
[13:33:43.814]                     ns <- getNamespace("parallel")
[13:33:43.814]                     if (exists("sendData", mode = "function", 
[13:33:43.814]                       envir = ns)) {
[13:33:43.814]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:43.814]                         envir = ns)
[13:33:43.814]                       envir <- sys.frame(frame)
[13:33:43.814]                       master <- NULL
[13:33:43.814]                       while (!identical(envir, .GlobalEnv) && 
[13:33:43.814]                         !identical(envir, emptyenv())) {
[13:33:43.814]                         if (exists("master", mode = "list", envir = envir, 
[13:33:43.814]                           inherits = FALSE)) {
[13:33:43.814]                           master <- get("master", mode = "list", 
[13:33:43.814]                             envir = envir, inherits = FALSE)
[13:33:43.814]                           if (inherits(master, c("SOCKnode", 
[13:33:43.814]                             "SOCK0node"))) {
[13:33:43.814]                             sendCondition <<- function(cond) {
[13:33:43.814]                               data <- list(type = "VALUE", value = cond, 
[13:33:43.814]                                 success = TRUE)
[13:33:43.814]                               parallel_sendData(master, data)
[13:33:43.814]                             }
[13:33:43.814]                             return(sendCondition)
[13:33:43.814]                           }
[13:33:43.814]                         }
[13:33:43.814]                         frame <- frame + 1L
[13:33:43.814]                         envir <- sys.frame(frame)
[13:33:43.814]                       }
[13:33:43.814]                     }
[13:33:43.814]                     sendCondition <<- function(cond) NULL
[13:33:43.814]                   }
[13:33:43.814]                 })
[13:33:43.814]                 withCallingHandlers({
[13:33:43.814]                   {
[13:33:43.814]                     do.call(function(...) {
[13:33:43.814]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.814]                       if (!identical(...future.globals.maxSize.org, 
[13:33:43.814]                         ...future.globals.maxSize)) {
[13:33:43.814]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.814]                         on.exit(options(oopts), add = TRUE)
[13:33:43.814]                       }
[13:33:43.814]                       {
[13:33:43.814]                         lapply(seq_along(...future.elements_ii), 
[13:33:43.814]                           FUN = function(jj) {
[13:33:43.814]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.814]                             ...future.FUN(...future.X_jj, ...)
[13:33:43.814]                           })
[13:33:43.814]                       }
[13:33:43.814]                     }, args = future.call.arguments)
[13:33:43.814]                   }
[13:33:43.814]                 }, immediateCondition = function(cond) {
[13:33:43.814]                   sendCondition <- ...future.makeSendCondition()
[13:33:43.814]                   sendCondition(cond)
[13:33:43.814]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.814]                   {
[13:33:43.814]                     inherits <- base::inherits
[13:33:43.814]                     invokeRestart <- base::invokeRestart
[13:33:43.814]                     is.null <- base::is.null
[13:33:43.814]                     muffled <- FALSE
[13:33:43.814]                     if (inherits(cond, "message")) {
[13:33:43.814]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:43.814]                       if (muffled) 
[13:33:43.814]                         invokeRestart("muffleMessage")
[13:33:43.814]                     }
[13:33:43.814]                     else if (inherits(cond, "warning")) {
[13:33:43.814]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:43.814]                       if (muffled) 
[13:33:43.814]                         invokeRestart("muffleWarning")
[13:33:43.814]                     }
[13:33:43.814]                     else if (inherits(cond, "condition")) {
[13:33:43.814]                       if (!is.null(pattern)) {
[13:33:43.814]                         computeRestarts <- base::computeRestarts
[13:33:43.814]                         grepl <- base::grepl
[13:33:43.814]                         restarts <- computeRestarts(cond)
[13:33:43.814]                         for (restart in restarts) {
[13:33:43.814]                           name <- restart$name
[13:33:43.814]                           if (is.null(name)) 
[13:33:43.814]                             next
[13:33:43.814]                           if (!grepl(pattern, name)) 
[13:33:43.814]                             next
[13:33:43.814]                           invokeRestart(restart)
[13:33:43.814]                           muffled <- TRUE
[13:33:43.814]                           break
[13:33:43.814]                         }
[13:33:43.814]                       }
[13:33:43.814]                     }
[13:33:43.814]                     invisible(muffled)
[13:33:43.814]                   }
[13:33:43.814]                   muffleCondition(cond)
[13:33:43.814]                 })
[13:33:43.814]             }))
[13:33:43.814]             future::FutureResult(value = ...future.value$value, 
[13:33:43.814]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:43.814]                   ...future.rng), globalenv = if (FALSE) 
[13:33:43.814]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:43.814]                     ...future.globalenv.names))
[13:33:43.814]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:43.814]         }, condition = base::local({
[13:33:43.814]             c <- base::c
[13:33:43.814]             inherits <- base::inherits
[13:33:43.814]             invokeRestart <- base::invokeRestart
[13:33:43.814]             length <- base::length
[13:33:43.814]             list <- base::list
[13:33:43.814]             seq.int <- base::seq.int
[13:33:43.814]             signalCondition <- base::signalCondition
[13:33:43.814]             sys.calls <- base::sys.calls
[13:33:43.814]             `[[` <- base::`[[`
[13:33:43.814]             `+` <- base::`+`
[13:33:43.814]             `<<-` <- base::`<<-`
[13:33:43.814]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:43.814]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:43.814]                   3L)]
[13:33:43.814]             }
[13:33:43.814]             function(cond) {
[13:33:43.814]                 is_error <- inherits(cond, "error")
[13:33:43.814]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:43.814]                   NULL)
[13:33:43.814]                 if (is_error) {
[13:33:43.814]                   sessionInformation <- function() {
[13:33:43.814]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:43.814]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:43.814]                       search = base::search(), system = base::Sys.info())
[13:33:43.814]                   }
[13:33:43.814]                   ...future.conditions[[length(...future.conditions) + 
[13:33:43.814]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:43.814]                     cond$call), session = sessionInformation(), 
[13:33:43.814]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:43.814]                   signalCondition(cond)
[13:33:43.814]                 }
[13:33:43.814]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:43.814]                 "immediateCondition"))) {
[13:33:43.814]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:43.814]                   ...future.conditions[[length(...future.conditions) + 
[13:33:43.814]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:43.814]                   if (TRUE && !signal) {
[13:33:43.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.814]                     {
[13:33:43.814]                       inherits <- base::inherits
[13:33:43.814]                       invokeRestart <- base::invokeRestart
[13:33:43.814]                       is.null <- base::is.null
[13:33:43.814]                       muffled <- FALSE
[13:33:43.814]                       if (inherits(cond, "message")) {
[13:33:43.814]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:43.814]                         if (muffled) 
[13:33:43.814]                           invokeRestart("muffleMessage")
[13:33:43.814]                       }
[13:33:43.814]                       else if (inherits(cond, "warning")) {
[13:33:43.814]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:43.814]                         if (muffled) 
[13:33:43.814]                           invokeRestart("muffleWarning")
[13:33:43.814]                       }
[13:33:43.814]                       else if (inherits(cond, "condition")) {
[13:33:43.814]                         if (!is.null(pattern)) {
[13:33:43.814]                           computeRestarts <- base::computeRestarts
[13:33:43.814]                           grepl <- base::grepl
[13:33:43.814]                           restarts <- computeRestarts(cond)
[13:33:43.814]                           for (restart in restarts) {
[13:33:43.814]                             name <- restart$name
[13:33:43.814]                             if (is.null(name)) 
[13:33:43.814]                               next
[13:33:43.814]                             if (!grepl(pattern, name)) 
[13:33:43.814]                               next
[13:33:43.814]                             invokeRestart(restart)
[13:33:43.814]                             muffled <- TRUE
[13:33:43.814]                             break
[13:33:43.814]                           }
[13:33:43.814]                         }
[13:33:43.814]                       }
[13:33:43.814]                       invisible(muffled)
[13:33:43.814]                     }
[13:33:43.814]                     muffleCondition(cond, pattern = "^muffle")
[13:33:43.814]                   }
[13:33:43.814]                 }
[13:33:43.814]                 else {
[13:33:43.814]                   if (TRUE) {
[13:33:43.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.814]                     {
[13:33:43.814]                       inherits <- base::inherits
[13:33:43.814]                       invokeRestart <- base::invokeRestart
[13:33:43.814]                       is.null <- base::is.null
[13:33:43.814]                       muffled <- FALSE
[13:33:43.814]                       if (inherits(cond, "message")) {
[13:33:43.814]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:43.814]                         if (muffled) 
[13:33:43.814]                           invokeRestart("muffleMessage")
[13:33:43.814]                       }
[13:33:43.814]                       else if (inherits(cond, "warning")) {
[13:33:43.814]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:43.814]                         if (muffled) 
[13:33:43.814]                           invokeRestart("muffleWarning")
[13:33:43.814]                       }
[13:33:43.814]                       else if (inherits(cond, "condition")) {
[13:33:43.814]                         if (!is.null(pattern)) {
[13:33:43.814]                           computeRestarts <- base::computeRestarts
[13:33:43.814]                           grepl <- base::grepl
[13:33:43.814]                           restarts <- computeRestarts(cond)
[13:33:43.814]                           for (restart in restarts) {
[13:33:43.814]                             name <- restart$name
[13:33:43.814]                             if (is.null(name)) 
[13:33:43.814]                               next
[13:33:43.814]                             if (!grepl(pattern, name)) 
[13:33:43.814]                               next
[13:33:43.814]                             invokeRestart(restart)
[13:33:43.814]                             muffled <- TRUE
[13:33:43.814]                             break
[13:33:43.814]                           }
[13:33:43.814]                         }
[13:33:43.814]                       }
[13:33:43.814]                       invisible(muffled)
[13:33:43.814]                     }
[13:33:43.814]                     muffleCondition(cond, pattern = "^muffle")
[13:33:43.814]                   }
[13:33:43.814]                 }
[13:33:43.814]             }
[13:33:43.814]         }))
[13:33:43.814]     }, error = function(ex) {
[13:33:43.814]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:43.814]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:43.814]                 ...future.rng), started = ...future.startTime, 
[13:33:43.814]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:43.814]             version = "1.8"), class = "FutureResult")
[13:33:43.814]     }, finally = {
[13:33:43.814]         if (!identical(...future.workdir, getwd())) 
[13:33:43.814]             setwd(...future.workdir)
[13:33:43.814]         {
[13:33:43.814]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:43.814]                 ...future.oldOptions$nwarnings <- NULL
[13:33:43.814]             }
[13:33:43.814]             base::options(...future.oldOptions)
[13:33:43.814]             if (.Platform$OS.type == "windows") {
[13:33:43.814]                 old_names <- names(...future.oldEnvVars)
[13:33:43.814]                 envs <- base::Sys.getenv()
[13:33:43.814]                 names <- names(envs)
[13:33:43.814]                 common <- intersect(names, old_names)
[13:33:43.814]                 added <- setdiff(names, old_names)
[13:33:43.814]                 removed <- setdiff(old_names, names)
[13:33:43.814]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:43.814]                   envs[common]]
[13:33:43.814]                 NAMES <- toupper(changed)
[13:33:43.814]                 args <- list()
[13:33:43.814]                 for (kk in seq_along(NAMES)) {
[13:33:43.814]                   name <- changed[[kk]]
[13:33:43.814]                   NAME <- NAMES[[kk]]
[13:33:43.814]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.814]                     next
[13:33:43.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:43.814]                 }
[13:33:43.814]                 NAMES <- toupper(added)
[13:33:43.814]                 for (kk in seq_along(NAMES)) {
[13:33:43.814]                   name <- added[[kk]]
[13:33:43.814]                   NAME <- NAMES[[kk]]
[13:33:43.814]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.814]                     next
[13:33:43.814]                   args[[name]] <- ""
[13:33:43.814]                 }
[13:33:43.814]                 NAMES <- toupper(removed)
[13:33:43.814]                 for (kk in seq_along(NAMES)) {
[13:33:43.814]                   name <- removed[[kk]]
[13:33:43.814]                   NAME <- NAMES[[kk]]
[13:33:43.814]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.814]                     next
[13:33:43.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:43.814]                 }
[13:33:43.814]                 if (length(args) > 0) 
[13:33:43.814]                   base::do.call(base::Sys.setenv, args = args)
[13:33:43.814]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:43.814]             }
[13:33:43.814]             else {
[13:33:43.814]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:43.814]             }
[13:33:43.814]             {
[13:33:43.814]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:43.814]                   0L) {
[13:33:43.814]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:43.814]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:43.814]                   base::options(opts)
[13:33:43.814]                 }
[13:33:43.814]                 {
[13:33:43.814]                   {
[13:33:43.814]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:43.814]                     NULL
[13:33:43.814]                   }
[13:33:43.814]                   options(future.plan = NULL)
[13:33:43.814]                   if (is.na(NA_character_)) 
[13:33:43.814]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:43.814]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:43.814]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:43.814]                     .init = FALSE)
[13:33:43.814]                 }
[13:33:43.814]             }
[13:33:43.814]         }
[13:33:43.814]     })
[13:33:43.814]     if (TRUE) {
[13:33:43.814]         base::sink(type = "output", split = FALSE)
[13:33:43.814]         if (TRUE) {
[13:33:43.814]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:43.814]         }
[13:33:43.814]         else {
[13:33:43.814]             ...future.result["stdout"] <- base::list(NULL)
[13:33:43.814]         }
[13:33:43.814]         base::close(...future.stdout)
[13:33:43.814]         ...future.stdout <- NULL
[13:33:43.814]     }
[13:33:43.814]     ...future.result$conditions <- ...future.conditions
[13:33:43.814]     ...future.result$finished <- base::Sys.time()
[13:33:43.814]     ...future.result
[13:33:43.814] }
[13:33:43.817] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[13:33:43.817] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[13:33:43.817] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[13:33:43.817] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:33:43.818] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:33:43.818] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[13:33:43.818] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[13:33:43.819] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:33:43.819] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:33:43.819] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:33:43.819] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:33:43.820] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[13:33:43.820] MultisessionFuture started
[13:33:43.820] - Launch lazy future ... done
[13:33:43.820] run() for ‘MultisessionFuture’ ... done
[13:33:43.821] Created future:
[13:33:43.821] MultisessionFuture:
[13:33:43.821] Label: ‘future_by-1’
[13:33:43.821] Expression:
[13:33:43.821] {
[13:33:43.821]     do.call(function(...) {
[13:33:43.821]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.821]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:43.821]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.821]             on.exit(options(oopts), add = TRUE)
[13:33:43.821]         }
[13:33:43.821]         {
[13:33:43.821]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:43.821]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.821]                 ...future.FUN(...future.X_jj, ...)
[13:33:43.821]             })
[13:33:43.821]         }
[13:33:43.821]     }, args = future.call.arguments)
[13:33:43.821] }
[13:33:43.821] Lazy evaluation: FALSE
[13:33:43.821] Asynchronous evaluation: TRUE
[13:33:43.821] Local evaluation: TRUE
[13:33:43.821] Environment: 0x55cb83970f90
[13:33:43.821] Capture standard output: TRUE
[13:33:43.821] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:43.821] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:43.821] Packages: <none>
[13:33:43.821] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:43.821] Resolved: FALSE
[13:33:43.821] Value: <not collected>
[13:33:43.821] Conditions captured: <none>
[13:33:43.821] Early signaling: FALSE
[13:33:43.821] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:43.821] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:43.832] Chunk #1 of 2 ... DONE
[13:33:43.832] Chunk #2 of 2 ...
[13:33:43.832]  - Finding globals in 'X' for chunk #2 ...
[13:33:43.832] getGlobalsAndPackages() ...
[13:33:43.833] Searching for globals...
[13:33:43.833] 
[13:33:43.833] Searching for globals ... DONE
[13:33:43.833] - globals: [0] <none>
[13:33:43.833] getGlobalsAndPackages() ... DONE
[13:33:43.833]    + additional globals found: [n=0] 
[13:33:43.833]    + additional namespaces needed: [n=0] 
[13:33:43.833]  - Finding globals in 'X' for chunk #2 ... DONE
[13:33:43.834]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:43.834]  - seeds: <none>
[13:33:43.834]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.834] getGlobalsAndPackages() ...
[13:33:43.834] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.834] Resolving globals: FALSE
[13:33:43.834] Tweak future expression to call with '...' arguments ...
[13:33:43.834] {
[13:33:43.834]     do.call(function(...) {
[13:33:43.834]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.834]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:43.834]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.834]             on.exit(options(oopts), add = TRUE)
[13:33:43.834]         }
[13:33:43.834]         {
[13:33:43.834]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:43.834]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.834]                 ...future.FUN(...future.X_jj, ...)
[13:33:43.834]             })
[13:33:43.834]         }
[13:33:43.834]     }, args = future.call.arguments)
[13:33:43.834] }
[13:33:43.835] Tweak future expression to call with '...' arguments ... DONE
[13:33:43.835] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.835] 
[13:33:43.835] getGlobalsAndPackages() ... DONE
[13:33:43.835] run() for ‘Future’ ...
[13:33:43.835] - state: ‘created’
[13:33:43.836] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:43.850] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:43.850] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:43.850]   - Field: ‘node’
[13:33:43.850]   - Field: ‘label’
[13:33:43.850]   - Field: ‘local’
[13:33:43.850]   - Field: ‘owner’
[13:33:43.850]   - Field: ‘envir’
[13:33:43.851]   - Field: ‘workers’
[13:33:43.851]   - Field: ‘packages’
[13:33:43.851]   - Field: ‘gc’
[13:33:43.851]   - Field: ‘conditions’
[13:33:43.851]   - Field: ‘persistent’
[13:33:43.851]   - Field: ‘expr’
[13:33:43.851]   - Field: ‘uuid’
[13:33:43.851]   - Field: ‘seed’
[13:33:43.851]   - Field: ‘version’
[13:33:43.851]   - Field: ‘result’
[13:33:43.851]   - Field: ‘asynchronous’
[13:33:43.852]   - Field: ‘calls’
[13:33:43.852]   - Field: ‘globals’
[13:33:43.852]   - Field: ‘stdout’
[13:33:43.852]   - Field: ‘earlySignal’
[13:33:43.852]   - Field: ‘lazy’
[13:33:43.852]   - Field: ‘state’
[13:33:43.852] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:43.852] - Launch lazy future ...
[13:33:43.852] Packages needed by the future expression (n = 0): <none>
[13:33:43.853] Packages needed by future strategies (n = 0): <none>
[13:33:43.853] {
[13:33:43.853]     {
[13:33:43.853]         {
[13:33:43.853]             ...future.startTime <- base::Sys.time()
[13:33:43.853]             {
[13:33:43.853]                 {
[13:33:43.853]                   {
[13:33:43.853]                     {
[13:33:43.853]                       base::local({
[13:33:43.853]                         has_future <- base::requireNamespace("future", 
[13:33:43.853]                           quietly = TRUE)
[13:33:43.853]                         if (has_future) {
[13:33:43.853]                           ns <- base::getNamespace("future")
[13:33:43.853]                           version <- ns[[".package"]][["version"]]
[13:33:43.853]                           if (is.null(version)) 
[13:33:43.853]                             version <- utils::packageVersion("future")
[13:33:43.853]                         }
[13:33:43.853]                         else {
[13:33:43.853]                           version <- NULL
[13:33:43.853]                         }
[13:33:43.853]                         if (!has_future || version < "1.8.0") {
[13:33:43.853]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:43.853]                             "", base::R.version$version.string), 
[13:33:43.853]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:43.853]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:43.853]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:43.853]                               "release", "version")], collapse = " "), 
[13:33:43.853]                             hostname = base::Sys.info()[["nodename"]])
[13:33:43.853]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:43.853]                             info)
[13:33:43.853]                           info <- base::paste(info, collapse = "; ")
[13:33:43.853]                           if (!has_future) {
[13:33:43.853]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:43.853]                               info)
[13:33:43.853]                           }
[13:33:43.853]                           else {
[13:33:43.853]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:43.853]                               info, version)
[13:33:43.853]                           }
[13:33:43.853]                           base::stop(msg)
[13:33:43.853]                         }
[13:33:43.853]                       })
[13:33:43.853]                     }
[13:33:43.853]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:43.853]                     base::options(mc.cores = 1L)
[13:33:43.853]                   }
[13:33:43.853]                   ...future.strategy.old <- future::plan("list")
[13:33:43.853]                   options(future.plan = NULL)
[13:33:43.853]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:43.853]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:43.853]                 }
[13:33:43.853]                 ...future.workdir <- getwd()
[13:33:43.853]             }
[13:33:43.853]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:43.853]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:43.853]         }
[13:33:43.853]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:43.853]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:43.853]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:43.853]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:43.853]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:43.853]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:43.853]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:43.853]             base::names(...future.oldOptions))
[13:33:43.853]     }
[13:33:43.853]     if (FALSE) {
[13:33:43.853]     }
[13:33:43.853]     else {
[13:33:43.853]         if (TRUE) {
[13:33:43.853]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:43.853]                 open = "w")
[13:33:43.853]         }
[13:33:43.853]         else {
[13:33:43.853]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:43.853]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:43.853]         }
[13:33:43.853]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:43.853]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:43.853]             base::sink(type = "output", split = FALSE)
[13:33:43.853]             base::close(...future.stdout)
[13:33:43.853]         }, add = TRUE)
[13:33:43.853]     }
[13:33:43.853]     ...future.frame <- base::sys.nframe()
[13:33:43.853]     ...future.conditions <- base::list()
[13:33:43.853]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:43.853]     if (FALSE) {
[13:33:43.853]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:43.853]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:43.853]     }
[13:33:43.853]     ...future.result <- base::tryCatch({
[13:33:43.853]         base::withCallingHandlers({
[13:33:43.853]             ...future.value <- base::withVisible(base::local({
[13:33:43.853]                 ...future.makeSendCondition <- base::local({
[13:33:43.853]                   sendCondition <- NULL
[13:33:43.853]                   function(frame = 1L) {
[13:33:43.853]                     if (is.function(sendCondition)) 
[13:33:43.853]                       return(sendCondition)
[13:33:43.853]                     ns <- getNamespace("parallel")
[13:33:43.853]                     if (exists("sendData", mode = "function", 
[13:33:43.853]                       envir = ns)) {
[13:33:43.853]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:43.853]                         envir = ns)
[13:33:43.853]                       envir <- sys.frame(frame)
[13:33:43.853]                       master <- NULL
[13:33:43.853]                       while (!identical(envir, .GlobalEnv) && 
[13:33:43.853]                         !identical(envir, emptyenv())) {
[13:33:43.853]                         if (exists("master", mode = "list", envir = envir, 
[13:33:43.853]                           inherits = FALSE)) {
[13:33:43.853]                           master <- get("master", mode = "list", 
[13:33:43.853]                             envir = envir, inherits = FALSE)
[13:33:43.853]                           if (inherits(master, c("SOCKnode", 
[13:33:43.853]                             "SOCK0node"))) {
[13:33:43.853]                             sendCondition <<- function(cond) {
[13:33:43.853]                               data <- list(type = "VALUE", value = cond, 
[13:33:43.853]                                 success = TRUE)
[13:33:43.853]                               parallel_sendData(master, data)
[13:33:43.853]                             }
[13:33:43.853]                             return(sendCondition)
[13:33:43.853]                           }
[13:33:43.853]                         }
[13:33:43.853]                         frame <- frame + 1L
[13:33:43.853]                         envir <- sys.frame(frame)
[13:33:43.853]                       }
[13:33:43.853]                     }
[13:33:43.853]                     sendCondition <<- function(cond) NULL
[13:33:43.853]                   }
[13:33:43.853]                 })
[13:33:43.853]                 withCallingHandlers({
[13:33:43.853]                   {
[13:33:43.853]                     do.call(function(...) {
[13:33:43.853]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.853]                       if (!identical(...future.globals.maxSize.org, 
[13:33:43.853]                         ...future.globals.maxSize)) {
[13:33:43.853]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.853]                         on.exit(options(oopts), add = TRUE)
[13:33:43.853]                       }
[13:33:43.853]                       {
[13:33:43.853]                         lapply(seq_along(...future.elements_ii), 
[13:33:43.853]                           FUN = function(jj) {
[13:33:43.853]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.853]                             ...future.FUN(...future.X_jj, ...)
[13:33:43.853]                           })
[13:33:43.853]                       }
[13:33:43.853]                     }, args = future.call.arguments)
[13:33:43.853]                   }
[13:33:43.853]                 }, immediateCondition = function(cond) {
[13:33:43.853]                   sendCondition <- ...future.makeSendCondition()
[13:33:43.853]                   sendCondition(cond)
[13:33:43.853]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.853]                   {
[13:33:43.853]                     inherits <- base::inherits
[13:33:43.853]                     invokeRestart <- base::invokeRestart
[13:33:43.853]                     is.null <- base::is.null
[13:33:43.853]                     muffled <- FALSE
[13:33:43.853]                     if (inherits(cond, "message")) {
[13:33:43.853]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:43.853]                       if (muffled) 
[13:33:43.853]                         invokeRestart("muffleMessage")
[13:33:43.853]                     }
[13:33:43.853]                     else if (inherits(cond, "warning")) {
[13:33:43.853]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:43.853]                       if (muffled) 
[13:33:43.853]                         invokeRestart("muffleWarning")
[13:33:43.853]                     }
[13:33:43.853]                     else if (inherits(cond, "condition")) {
[13:33:43.853]                       if (!is.null(pattern)) {
[13:33:43.853]                         computeRestarts <- base::computeRestarts
[13:33:43.853]                         grepl <- base::grepl
[13:33:43.853]                         restarts <- computeRestarts(cond)
[13:33:43.853]                         for (restart in restarts) {
[13:33:43.853]                           name <- restart$name
[13:33:43.853]                           if (is.null(name)) 
[13:33:43.853]                             next
[13:33:43.853]                           if (!grepl(pattern, name)) 
[13:33:43.853]                             next
[13:33:43.853]                           invokeRestart(restart)
[13:33:43.853]                           muffled <- TRUE
[13:33:43.853]                           break
[13:33:43.853]                         }
[13:33:43.853]                       }
[13:33:43.853]                     }
[13:33:43.853]                     invisible(muffled)
[13:33:43.853]                   }
[13:33:43.853]                   muffleCondition(cond)
[13:33:43.853]                 })
[13:33:43.853]             }))
[13:33:43.853]             future::FutureResult(value = ...future.value$value, 
[13:33:43.853]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:43.853]                   ...future.rng), globalenv = if (FALSE) 
[13:33:43.853]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:43.853]                     ...future.globalenv.names))
[13:33:43.853]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:43.853]         }, condition = base::local({
[13:33:43.853]             c <- base::c
[13:33:43.853]             inherits <- base::inherits
[13:33:43.853]             invokeRestart <- base::invokeRestart
[13:33:43.853]             length <- base::length
[13:33:43.853]             list <- base::list
[13:33:43.853]             seq.int <- base::seq.int
[13:33:43.853]             signalCondition <- base::signalCondition
[13:33:43.853]             sys.calls <- base::sys.calls
[13:33:43.853]             `[[` <- base::`[[`
[13:33:43.853]             `+` <- base::`+`
[13:33:43.853]             `<<-` <- base::`<<-`
[13:33:43.853]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:43.853]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:43.853]                   3L)]
[13:33:43.853]             }
[13:33:43.853]             function(cond) {
[13:33:43.853]                 is_error <- inherits(cond, "error")
[13:33:43.853]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:43.853]                   NULL)
[13:33:43.853]                 if (is_error) {
[13:33:43.853]                   sessionInformation <- function() {
[13:33:43.853]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:43.853]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:43.853]                       search = base::search(), system = base::Sys.info())
[13:33:43.853]                   }
[13:33:43.853]                   ...future.conditions[[length(...future.conditions) + 
[13:33:43.853]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:43.853]                     cond$call), session = sessionInformation(), 
[13:33:43.853]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:43.853]                   signalCondition(cond)
[13:33:43.853]                 }
[13:33:43.853]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:43.853]                 "immediateCondition"))) {
[13:33:43.853]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:43.853]                   ...future.conditions[[length(...future.conditions) + 
[13:33:43.853]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:43.853]                   if (TRUE && !signal) {
[13:33:43.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.853]                     {
[13:33:43.853]                       inherits <- base::inherits
[13:33:43.853]                       invokeRestart <- base::invokeRestart
[13:33:43.853]                       is.null <- base::is.null
[13:33:43.853]                       muffled <- FALSE
[13:33:43.853]                       if (inherits(cond, "message")) {
[13:33:43.853]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:43.853]                         if (muffled) 
[13:33:43.853]                           invokeRestart("muffleMessage")
[13:33:43.853]                       }
[13:33:43.853]                       else if (inherits(cond, "warning")) {
[13:33:43.853]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:43.853]                         if (muffled) 
[13:33:43.853]                           invokeRestart("muffleWarning")
[13:33:43.853]                       }
[13:33:43.853]                       else if (inherits(cond, "condition")) {
[13:33:43.853]                         if (!is.null(pattern)) {
[13:33:43.853]                           computeRestarts <- base::computeRestarts
[13:33:43.853]                           grepl <- base::grepl
[13:33:43.853]                           restarts <- computeRestarts(cond)
[13:33:43.853]                           for (restart in restarts) {
[13:33:43.853]                             name <- restart$name
[13:33:43.853]                             if (is.null(name)) 
[13:33:43.853]                               next
[13:33:43.853]                             if (!grepl(pattern, name)) 
[13:33:43.853]                               next
[13:33:43.853]                             invokeRestart(restart)
[13:33:43.853]                             muffled <- TRUE
[13:33:43.853]                             break
[13:33:43.853]                           }
[13:33:43.853]                         }
[13:33:43.853]                       }
[13:33:43.853]                       invisible(muffled)
[13:33:43.853]                     }
[13:33:43.853]                     muffleCondition(cond, pattern = "^muffle")
[13:33:43.853]                   }
[13:33:43.853]                 }
[13:33:43.853]                 else {
[13:33:43.853]                   if (TRUE) {
[13:33:43.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.853]                     {
[13:33:43.853]                       inherits <- base::inherits
[13:33:43.853]                       invokeRestart <- base::invokeRestart
[13:33:43.853]                       is.null <- base::is.null
[13:33:43.853]                       muffled <- FALSE
[13:33:43.853]                       if (inherits(cond, "message")) {
[13:33:43.853]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:43.853]                         if (muffled) 
[13:33:43.853]                           invokeRestart("muffleMessage")
[13:33:43.853]                       }
[13:33:43.853]                       else if (inherits(cond, "warning")) {
[13:33:43.853]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:43.853]                         if (muffled) 
[13:33:43.853]                           invokeRestart("muffleWarning")
[13:33:43.853]                       }
[13:33:43.853]                       else if (inherits(cond, "condition")) {
[13:33:43.853]                         if (!is.null(pattern)) {
[13:33:43.853]                           computeRestarts <- base::computeRestarts
[13:33:43.853]                           grepl <- base::grepl
[13:33:43.853]                           restarts <- computeRestarts(cond)
[13:33:43.853]                           for (restart in restarts) {
[13:33:43.853]                             name <- restart$name
[13:33:43.853]                             if (is.null(name)) 
[13:33:43.853]                               next
[13:33:43.853]                             if (!grepl(pattern, name)) 
[13:33:43.853]                               next
[13:33:43.853]                             invokeRestart(restart)
[13:33:43.853]                             muffled <- TRUE
[13:33:43.853]                             break
[13:33:43.853]                           }
[13:33:43.853]                         }
[13:33:43.853]                       }
[13:33:43.853]                       invisible(muffled)
[13:33:43.853]                     }
[13:33:43.853]                     muffleCondition(cond, pattern = "^muffle")
[13:33:43.853]                   }
[13:33:43.853]                 }
[13:33:43.853]             }
[13:33:43.853]         }))
[13:33:43.853]     }, error = function(ex) {
[13:33:43.853]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:43.853]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:43.853]                 ...future.rng), started = ...future.startTime, 
[13:33:43.853]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:43.853]             version = "1.8"), class = "FutureResult")
[13:33:43.853]     }, finally = {
[13:33:43.853]         if (!identical(...future.workdir, getwd())) 
[13:33:43.853]             setwd(...future.workdir)
[13:33:43.853]         {
[13:33:43.853]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:43.853]                 ...future.oldOptions$nwarnings <- NULL
[13:33:43.853]             }
[13:33:43.853]             base::options(...future.oldOptions)
[13:33:43.853]             if (.Platform$OS.type == "windows") {
[13:33:43.853]                 old_names <- names(...future.oldEnvVars)
[13:33:43.853]                 envs <- base::Sys.getenv()
[13:33:43.853]                 names <- names(envs)
[13:33:43.853]                 common <- intersect(names, old_names)
[13:33:43.853]                 added <- setdiff(names, old_names)
[13:33:43.853]                 removed <- setdiff(old_names, names)
[13:33:43.853]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:43.853]                   envs[common]]
[13:33:43.853]                 NAMES <- toupper(changed)
[13:33:43.853]                 args <- list()
[13:33:43.853]                 for (kk in seq_along(NAMES)) {
[13:33:43.853]                   name <- changed[[kk]]
[13:33:43.853]                   NAME <- NAMES[[kk]]
[13:33:43.853]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.853]                     next
[13:33:43.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:43.853]                 }
[13:33:43.853]                 NAMES <- toupper(added)
[13:33:43.853]                 for (kk in seq_along(NAMES)) {
[13:33:43.853]                   name <- added[[kk]]
[13:33:43.853]                   NAME <- NAMES[[kk]]
[13:33:43.853]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.853]                     next
[13:33:43.853]                   args[[name]] <- ""
[13:33:43.853]                 }
[13:33:43.853]                 NAMES <- toupper(removed)
[13:33:43.853]                 for (kk in seq_along(NAMES)) {
[13:33:43.853]                   name <- removed[[kk]]
[13:33:43.853]                   NAME <- NAMES[[kk]]
[13:33:43.853]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.853]                     next
[13:33:43.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:43.853]                 }
[13:33:43.853]                 if (length(args) > 0) 
[13:33:43.853]                   base::do.call(base::Sys.setenv, args = args)
[13:33:43.853]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:43.853]             }
[13:33:43.853]             else {
[13:33:43.853]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:43.853]             }
[13:33:43.853]             {
[13:33:43.853]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:43.853]                   0L) {
[13:33:43.853]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:43.853]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:43.853]                   base::options(opts)
[13:33:43.853]                 }
[13:33:43.853]                 {
[13:33:43.853]                   {
[13:33:43.853]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:43.853]                     NULL
[13:33:43.853]                   }
[13:33:43.853]                   options(future.plan = NULL)
[13:33:43.853]                   if (is.na(NA_character_)) 
[13:33:43.853]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:43.853]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:43.853]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:43.853]                     .init = FALSE)
[13:33:43.853]                 }
[13:33:43.853]             }
[13:33:43.853]         }
[13:33:43.853]     })
[13:33:43.853]     if (TRUE) {
[13:33:43.853]         base::sink(type = "output", split = FALSE)
[13:33:43.853]         if (TRUE) {
[13:33:43.853]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:43.853]         }
[13:33:43.853]         else {
[13:33:43.853]             ...future.result["stdout"] <- base::list(NULL)
[13:33:43.853]         }
[13:33:43.853]         base::close(...future.stdout)
[13:33:43.853]         ...future.stdout <- NULL
[13:33:43.853]     }
[13:33:43.853]     ...future.result$conditions <- ...future.conditions
[13:33:43.853]     ...future.result$finished <- base::Sys.time()
[13:33:43.853]     ...future.result
[13:33:43.853] }
[13:33:43.856] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[13:33:43.856] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[13:33:43.856] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[13:33:43.856] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:33:43.857] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:33:43.857] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[13:33:43.857] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[13:33:43.857] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:33:43.858] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:33:43.858] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:33:43.858] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:33:43.858] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[13:33:43.859] MultisessionFuture started
[13:33:43.859] - Launch lazy future ... done
[13:33:43.859] run() for ‘MultisessionFuture’ ... done
[13:33:43.859] Created future:
[13:33:43.859] MultisessionFuture:
[13:33:43.859] Label: ‘future_by-2’
[13:33:43.859] Expression:
[13:33:43.859] {
[13:33:43.859]     do.call(function(...) {
[13:33:43.859]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.859]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:43.859]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.859]             on.exit(options(oopts), add = TRUE)
[13:33:43.859]         }
[13:33:43.859]         {
[13:33:43.859]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:43.859]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.859]                 ...future.FUN(...future.X_jj, ...)
[13:33:43.859]             })
[13:33:43.859]         }
[13:33:43.859]     }, args = future.call.arguments)
[13:33:43.859] }
[13:33:43.859] Lazy evaluation: FALSE
[13:33:43.859] Asynchronous evaluation: TRUE
[13:33:43.859] Local evaluation: TRUE
[13:33:43.859] Environment: 0x55cb83970f90
[13:33:43.859] Capture standard output: TRUE
[13:33:43.859] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:43.859] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:43.859] Packages: <none>
[13:33:43.859] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:43.859] Resolved: FALSE
[13:33:43.859] Value: <not collected>
[13:33:43.859] Conditions captured: <none>
[13:33:43.859] Early signaling: FALSE
[13:33:43.859] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:43.859] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:43.871] Chunk #2 of 2 ... DONE
[13:33:43.871] Launching 2 futures (chunks) ... DONE
[13:33:43.871] Resolving 2 futures (chunks) ...
[13:33:43.871] resolve() on list ...
[13:33:43.871]  recursive: 0
[13:33:43.871]  length: 2
[13:33:43.872] 
[13:33:43.872] receiveMessageFromWorker() for ClusterFuture ...
[13:33:43.872] - Validating connection of MultisessionFuture
[13:33:43.872] - received message: FutureResult
[13:33:43.872] - Received FutureResult
[13:33:43.873] - Erased future from FutureRegistry
[13:33:43.873] result() for ClusterFuture ...
[13:33:43.873] - result already collected: FutureResult
[13:33:43.873] result() for ClusterFuture ... done
[13:33:43.873] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:43.873] Future #1
[13:33:43.873] result() for ClusterFuture ...
[13:33:43.873] - result already collected: FutureResult
[13:33:43.873] result() for ClusterFuture ... done
[13:33:43.873] result() for ClusterFuture ...
[13:33:43.873] - result already collected: FutureResult
[13:33:43.874] result() for ClusterFuture ... done
[13:33:43.876] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:33:43.876] - nx: 2
[13:33:43.876] - relay: TRUE
[13:33:43.877] - stdout: TRUE
[13:33:43.877] - signal: TRUE
[13:33:43.877] - resignal: FALSE
[13:33:43.877] - force: TRUE
[13:33:43.877] - relayed: [n=2] FALSE, FALSE
[13:33:43.877] - queued futures: [n=2] FALSE, FALSE
[13:33:43.877]  - until=1
[13:33:43.877]  - relaying element #1
[13:33:43.877] result() for ClusterFuture ...
[13:33:43.877] - result already collected: FutureResult
[13:33:43.877] result() for ClusterFuture ... done
[13:33:43.878] result() for ClusterFuture ...
[13:33:43.878] - result already collected: FutureResult
[13:33:43.878] result() for ClusterFuture ... done
[13:33:43.878] result() for ClusterFuture ...
[13:33:43.878] - result already collected: FutureResult
[13:33:43.878] result() for ClusterFuture ... done
[13:33:43.878] result() for ClusterFuture ...
[13:33:43.878] - result already collected: FutureResult
[13:33:43.878] result() for ClusterFuture ... done
[13:33:43.878] - relayed: [n=2] TRUE, FALSE
[13:33:43.878] - queued futures: [n=2] TRUE, FALSE
[13:33:43.879] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:33:43.879]  length: 1 (resolved future 1)
[13:33:43.905] receiveMessageFromWorker() for ClusterFuture ...
[13:33:43.905] - Validating connection of MultisessionFuture
[13:33:43.905] - received message: FutureResult
[13:33:43.905] - Received FutureResult
[13:33:43.905] - Erased future from FutureRegistry
[13:33:43.905] result() for ClusterFuture ...
[13:33:43.905] - result already collected: FutureResult
[13:33:43.906] result() for ClusterFuture ... done
[13:33:43.906] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:43.906] Future #2
[13:33:43.906] result() for ClusterFuture ...
[13:33:43.906] - result already collected: FutureResult
[13:33:43.906] result() for ClusterFuture ... done
[13:33:43.906] result() for ClusterFuture ...
[13:33:43.906] - result already collected: FutureResult
[13:33:43.906] result() for ClusterFuture ... done
[13:33:43.906] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:33:43.907] - nx: 2
[13:33:43.907] - relay: TRUE
[13:33:43.907] - stdout: TRUE
[13:33:43.907] - signal: TRUE
[13:33:43.907] - resignal: FALSE
[13:33:43.907] - force: TRUE
[13:33:43.907] - relayed: [n=2] TRUE, FALSE
[13:33:43.907] - queued futures: [n=2] TRUE, FALSE
[13:33:43.907]  - until=2
[13:33:43.907]  - relaying element #2
[13:33:43.907] result() for ClusterFuture ...
[13:33:43.907] - result already collected: FutureResult
[13:33:43.908] result() for ClusterFuture ... done
[13:33:43.908] result() for ClusterFuture ...
[13:33:43.908] - result already collected: FutureResult
[13:33:43.908] result() for ClusterFuture ... done
[13:33:43.908] result() for ClusterFuture ...
[13:33:43.908] - result already collected: FutureResult
[13:33:43.908] result() for ClusterFuture ... done
[13:33:43.908] result() for ClusterFuture ...
[13:33:43.908] - result already collected: FutureResult
[13:33:43.908] result() for ClusterFuture ... done
[13:33:43.908] - relayed: [n=2] TRUE, TRUE
[13:33:43.908] - queued futures: [n=2] TRUE, TRUE
[13:33:43.909] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:33:43.909]  length: 0 (resolved future 2)
[13:33:43.909] Relaying remaining futures
[13:33:43.909] signalConditionsASAP(NULL, pos=0) ...
[13:33:43.909] - nx: 2
[13:33:43.909] - relay: TRUE
[13:33:43.909] - stdout: TRUE
[13:33:43.909] - signal: TRUE
[13:33:43.909] - resignal: FALSE
[13:33:43.909] - force: TRUE
[13:33:43.909] - relayed: [n=2] TRUE, TRUE
[13:33:43.909] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:43.910] - relayed: [n=2] TRUE, TRUE
[13:33:43.910] - queued futures: [n=2] TRUE, TRUE
[13:33:43.910] signalConditionsASAP(NULL, pos=0) ... done
[13:33:43.910] resolve() on list ... DONE
[13:33:43.910] result() for ClusterFuture ...
[13:33:43.910] - result already collected: FutureResult
[13:33:43.910] result() for ClusterFuture ... done
[13:33:43.910] result() for ClusterFuture ...
[13:33:43.910] - result already collected: FutureResult
[13:33:43.910] result() for ClusterFuture ... done
[13:33:43.911] result() for ClusterFuture ...
[13:33:43.911] - result already collected: FutureResult
[13:33:43.911] result() for ClusterFuture ... done
[13:33:43.911] result() for ClusterFuture ...
[13:33:43.911] - result already collected: FutureResult
[13:33:43.911] result() for ClusterFuture ... done
[13:33:43.911]  - Number of value chunks collected: 2
[13:33:43.911] Resolving 2 futures (chunks) ... DONE
[13:33:43.911] Reducing values from 2 chunks ...
[13:33:43.911]  - Number of values collected after concatenation: 3
[13:33:43.911]  - Number of values expected: 3
[13:33:43.911] Reducing values from 2 chunks ... DONE
[13:33:43.912] future_lapply() ... DONE
[13:33:43.912] future_by_internal() ... DONE
[13:33:43.912] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[13:33:43.913] future_lapply() ...
[13:33:43.917] Number of chunks: 2
[13:33:43.917] getGlobalsAndPackagesXApply() ...
[13:33:43.917]  - future.globals: TRUE
[13:33:43.917] getGlobalsAndPackages() ...
[13:33:43.917] Searching for globals...
[13:33:43.918] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:43.918] Searching for globals ... DONE
[13:33:43.918] Resolving globals: FALSE
[13:33:43.919] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:43.919] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:43.919] - globals: [1] ‘FUN’
[13:33:43.919] 
[13:33:43.919] getGlobalsAndPackages() ... DONE
[13:33:43.919]  - globals found/used: [n=1] ‘FUN’
[13:33:43.919]  - needed namespaces: [n=0] 
[13:33:43.919] Finding globals ... DONE
[13:33:43.920]  - use_args: TRUE
[13:33:43.920]  - Getting '...' globals ...
[13:33:43.920] resolve() on list ...
[13:33:43.920]  recursive: 0
[13:33:43.920]  length: 1
[13:33:43.920]  elements: ‘...’
[13:33:43.920]  length: 0 (resolved future 1)
[13:33:43.920] resolve() on list ... DONE
[13:33:43.920]    - '...' content: [n=0] 
[13:33:43.921] List of 1
[13:33:43.921]  $ ...: list()
[13:33:43.921]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:43.921]  - attr(*, "where")=List of 1
[13:33:43.921]   ..$ ...:<environment: 0x55cb842c6698> 
[13:33:43.921]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:43.921]  - attr(*, "resolved")= logi TRUE
[13:33:43.921]  - attr(*, "total_size")= num NA
[13:33:43.923]  - Getting '...' globals ... DONE
[13:33:43.923] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:43.923] List of 2
[13:33:43.923]  $ ...future.FUN:function (object, ...)  
[13:33:43.923]  $ ...          : list()
[13:33:43.923]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:43.923]  - attr(*, "where")=List of 2
[13:33:43.923]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:43.923]   ..$ ...          :<environment: 0x55cb842c6698> 
[13:33:43.923]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:43.923]  - attr(*, "resolved")= logi FALSE
[13:33:43.923]  - attr(*, "total_size")= num 1240
[13:33:43.926] Packages to be attached in all futures: [n=0] 
[13:33:43.926] getGlobalsAndPackagesXApply() ... DONE
[13:33:43.926] Number of futures (= number of chunks): 2
[13:33:43.926] Launching 2 futures (chunks) ...
[13:33:43.926] Chunk #1 of 2 ...
[13:33:43.926]  - Finding globals in 'X' for chunk #1 ...
[13:33:43.927] getGlobalsAndPackages() ...
[13:33:43.927] Searching for globals...
[13:33:43.927] 
[13:33:43.927] Searching for globals ... DONE
[13:33:43.927] - globals: [0] <none>
[13:33:43.927] getGlobalsAndPackages() ... DONE
[13:33:43.927]    + additional globals found: [n=0] 
[13:33:43.927]    + additional namespaces needed: [n=0] 
[13:33:43.927]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:43.928]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:43.928]  - seeds: <none>
[13:33:43.928]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.928] getGlobalsAndPackages() ...
[13:33:43.928] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.928] Resolving globals: FALSE
[13:33:43.928] Tweak future expression to call with '...' arguments ...
[13:33:43.928] {
[13:33:43.928]     do.call(function(...) {
[13:33:43.928]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.928]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:43.928]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.928]             on.exit(options(oopts), add = TRUE)
[13:33:43.928]         }
[13:33:43.928]         {
[13:33:43.928]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:43.928]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.928]                 ...future.FUN(...future.X_jj, ...)
[13:33:43.928]             })
[13:33:43.928]         }
[13:33:43.928]     }, args = future.call.arguments)
[13:33:43.928] }
[13:33:43.928] Tweak future expression to call with '...' arguments ... DONE
[13:33:43.929] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.929] 
[13:33:43.929] getGlobalsAndPackages() ... DONE
[13:33:43.929] run() for ‘Future’ ...
[13:33:43.929] - state: ‘created’
[13:33:43.929] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:43.942] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:43.943] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:43.943]   - Field: ‘node’
[13:33:43.943]   - Field: ‘label’
[13:33:43.943]   - Field: ‘local’
[13:33:43.943]   - Field: ‘owner’
[13:33:43.943]   - Field: ‘envir’
[13:33:43.943]   - Field: ‘workers’
[13:33:43.943]   - Field: ‘packages’
[13:33:43.943]   - Field: ‘gc’
[13:33:43.943]   - Field: ‘conditions’
[13:33:43.944]   - Field: ‘persistent’
[13:33:43.944]   - Field: ‘expr’
[13:33:43.944]   - Field: ‘uuid’
[13:33:43.944]   - Field: ‘seed’
[13:33:43.944]   - Field: ‘version’
[13:33:43.944]   - Field: ‘result’
[13:33:43.944]   - Field: ‘asynchronous’
[13:33:43.944]   - Field: ‘calls’
[13:33:43.944]   - Field: ‘globals’
[13:33:43.944]   - Field: ‘stdout’
[13:33:43.944]   - Field: ‘earlySignal’
[13:33:43.945]   - Field: ‘lazy’
[13:33:43.945]   - Field: ‘state’
[13:33:43.945] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:43.945] - Launch lazy future ...
[13:33:43.945] Packages needed by the future expression (n = 0): <none>
[13:33:43.945] Packages needed by future strategies (n = 0): <none>
[13:33:43.946] {
[13:33:43.946]     {
[13:33:43.946]         {
[13:33:43.946]             ...future.startTime <- base::Sys.time()
[13:33:43.946]             {
[13:33:43.946]                 {
[13:33:43.946]                   {
[13:33:43.946]                     {
[13:33:43.946]                       base::local({
[13:33:43.946]                         has_future <- base::requireNamespace("future", 
[13:33:43.946]                           quietly = TRUE)
[13:33:43.946]                         if (has_future) {
[13:33:43.946]                           ns <- base::getNamespace("future")
[13:33:43.946]                           version <- ns[[".package"]][["version"]]
[13:33:43.946]                           if (is.null(version)) 
[13:33:43.946]                             version <- utils::packageVersion("future")
[13:33:43.946]                         }
[13:33:43.946]                         else {
[13:33:43.946]                           version <- NULL
[13:33:43.946]                         }
[13:33:43.946]                         if (!has_future || version < "1.8.0") {
[13:33:43.946]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:43.946]                             "", base::R.version$version.string), 
[13:33:43.946]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:43.946]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:43.946]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:43.946]                               "release", "version")], collapse = " "), 
[13:33:43.946]                             hostname = base::Sys.info()[["nodename"]])
[13:33:43.946]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:43.946]                             info)
[13:33:43.946]                           info <- base::paste(info, collapse = "; ")
[13:33:43.946]                           if (!has_future) {
[13:33:43.946]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:43.946]                               info)
[13:33:43.946]                           }
[13:33:43.946]                           else {
[13:33:43.946]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:43.946]                               info, version)
[13:33:43.946]                           }
[13:33:43.946]                           base::stop(msg)
[13:33:43.946]                         }
[13:33:43.946]                       })
[13:33:43.946]                     }
[13:33:43.946]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:43.946]                     base::options(mc.cores = 1L)
[13:33:43.946]                   }
[13:33:43.946]                   ...future.strategy.old <- future::plan("list")
[13:33:43.946]                   options(future.plan = NULL)
[13:33:43.946]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:43.946]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:43.946]                 }
[13:33:43.946]                 ...future.workdir <- getwd()
[13:33:43.946]             }
[13:33:43.946]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:43.946]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:43.946]         }
[13:33:43.946]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:43.946]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:43.946]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:43.946]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:43.946]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:43.946]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:43.946]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:43.946]             base::names(...future.oldOptions))
[13:33:43.946]     }
[13:33:43.946]     if (FALSE) {
[13:33:43.946]     }
[13:33:43.946]     else {
[13:33:43.946]         if (TRUE) {
[13:33:43.946]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:43.946]                 open = "w")
[13:33:43.946]         }
[13:33:43.946]         else {
[13:33:43.946]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:43.946]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:43.946]         }
[13:33:43.946]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:43.946]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:43.946]             base::sink(type = "output", split = FALSE)
[13:33:43.946]             base::close(...future.stdout)
[13:33:43.946]         }, add = TRUE)
[13:33:43.946]     }
[13:33:43.946]     ...future.frame <- base::sys.nframe()
[13:33:43.946]     ...future.conditions <- base::list()
[13:33:43.946]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:43.946]     if (FALSE) {
[13:33:43.946]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:43.946]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:43.946]     }
[13:33:43.946]     ...future.result <- base::tryCatch({
[13:33:43.946]         base::withCallingHandlers({
[13:33:43.946]             ...future.value <- base::withVisible(base::local({
[13:33:43.946]                 ...future.makeSendCondition <- base::local({
[13:33:43.946]                   sendCondition <- NULL
[13:33:43.946]                   function(frame = 1L) {
[13:33:43.946]                     if (is.function(sendCondition)) 
[13:33:43.946]                       return(sendCondition)
[13:33:43.946]                     ns <- getNamespace("parallel")
[13:33:43.946]                     if (exists("sendData", mode = "function", 
[13:33:43.946]                       envir = ns)) {
[13:33:43.946]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:43.946]                         envir = ns)
[13:33:43.946]                       envir <- sys.frame(frame)
[13:33:43.946]                       master <- NULL
[13:33:43.946]                       while (!identical(envir, .GlobalEnv) && 
[13:33:43.946]                         !identical(envir, emptyenv())) {
[13:33:43.946]                         if (exists("master", mode = "list", envir = envir, 
[13:33:43.946]                           inherits = FALSE)) {
[13:33:43.946]                           master <- get("master", mode = "list", 
[13:33:43.946]                             envir = envir, inherits = FALSE)
[13:33:43.946]                           if (inherits(master, c("SOCKnode", 
[13:33:43.946]                             "SOCK0node"))) {
[13:33:43.946]                             sendCondition <<- function(cond) {
[13:33:43.946]                               data <- list(type = "VALUE", value = cond, 
[13:33:43.946]                                 success = TRUE)
[13:33:43.946]                               parallel_sendData(master, data)
[13:33:43.946]                             }
[13:33:43.946]                             return(sendCondition)
[13:33:43.946]                           }
[13:33:43.946]                         }
[13:33:43.946]                         frame <- frame + 1L
[13:33:43.946]                         envir <- sys.frame(frame)
[13:33:43.946]                       }
[13:33:43.946]                     }
[13:33:43.946]                     sendCondition <<- function(cond) NULL
[13:33:43.946]                   }
[13:33:43.946]                 })
[13:33:43.946]                 withCallingHandlers({
[13:33:43.946]                   {
[13:33:43.946]                     do.call(function(...) {
[13:33:43.946]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.946]                       if (!identical(...future.globals.maxSize.org, 
[13:33:43.946]                         ...future.globals.maxSize)) {
[13:33:43.946]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.946]                         on.exit(options(oopts), add = TRUE)
[13:33:43.946]                       }
[13:33:43.946]                       {
[13:33:43.946]                         lapply(seq_along(...future.elements_ii), 
[13:33:43.946]                           FUN = function(jj) {
[13:33:43.946]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.946]                             ...future.FUN(...future.X_jj, ...)
[13:33:43.946]                           })
[13:33:43.946]                       }
[13:33:43.946]                     }, args = future.call.arguments)
[13:33:43.946]                   }
[13:33:43.946]                 }, immediateCondition = function(cond) {
[13:33:43.946]                   sendCondition <- ...future.makeSendCondition()
[13:33:43.946]                   sendCondition(cond)
[13:33:43.946]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.946]                   {
[13:33:43.946]                     inherits <- base::inherits
[13:33:43.946]                     invokeRestart <- base::invokeRestart
[13:33:43.946]                     is.null <- base::is.null
[13:33:43.946]                     muffled <- FALSE
[13:33:43.946]                     if (inherits(cond, "message")) {
[13:33:43.946]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:43.946]                       if (muffled) 
[13:33:43.946]                         invokeRestart("muffleMessage")
[13:33:43.946]                     }
[13:33:43.946]                     else if (inherits(cond, "warning")) {
[13:33:43.946]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:43.946]                       if (muffled) 
[13:33:43.946]                         invokeRestart("muffleWarning")
[13:33:43.946]                     }
[13:33:43.946]                     else if (inherits(cond, "condition")) {
[13:33:43.946]                       if (!is.null(pattern)) {
[13:33:43.946]                         computeRestarts <- base::computeRestarts
[13:33:43.946]                         grepl <- base::grepl
[13:33:43.946]                         restarts <- computeRestarts(cond)
[13:33:43.946]                         for (restart in restarts) {
[13:33:43.946]                           name <- restart$name
[13:33:43.946]                           if (is.null(name)) 
[13:33:43.946]                             next
[13:33:43.946]                           if (!grepl(pattern, name)) 
[13:33:43.946]                             next
[13:33:43.946]                           invokeRestart(restart)
[13:33:43.946]                           muffled <- TRUE
[13:33:43.946]                           break
[13:33:43.946]                         }
[13:33:43.946]                       }
[13:33:43.946]                     }
[13:33:43.946]                     invisible(muffled)
[13:33:43.946]                   }
[13:33:43.946]                   muffleCondition(cond)
[13:33:43.946]                 })
[13:33:43.946]             }))
[13:33:43.946]             future::FutureResult(value = ...future.value$value, 
[13:33:43.946]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:43.946]                   ...future.rng), globalenv = if (FALSE) 
[13:33:43.946]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:43.946]                     ...future.globalenv.names))
[13:33:43.946]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:43.946]         }, condition = base::local({
[13:33:43.946]             c <- base::c
[13:33:43.946]             inherits <- base::inherits
[13:33:43.946]             invokeRestart <- base::invokeRestart
[13:33:43.946]             length <- base::length
[13:33:43.946]             list <- base::list
[13:33:43.946]             seq.int <- base::seq.int
[13:33:43.946]             signalCondition <- base::signalCondition
[13:33:43.946]             sys.calls <- base::sys.calls
[13:33:43.946]             `[[` <- base::`[[`
[13:33:43.946]             `+` <- base::`+`
[13:33:43.946]             `<<-` <- base::`<<-`
[13:33:43.946]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:43.946]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:43.946]                   3L)]
[13:33:43.946]             }
[13:33:43.946]             function(cond) {
[13:33:43.946]                 is_error <- inherits(cond, "error")
[13:33:43.946]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:43.946]                   NULL)
[13:33:43.946]                 if (is_error) {
[13:33:43.946]                   sessionInformation <- function() {
[13:33:43.946]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:43.946]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:43.946]                       search = base::search(), system = base::Sys.info())
[13:33:43.946]                   }
[13:33:43.946]                   ...future.conditions[[length(...future.conditions) + 
[13:33:43.946]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:43.946]                     cond$call), session = sessionInformation(), 
[13:33:43.946]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:43.946]                   signalCondition(cond)
[13:33:43.946]                 }
[13:33:43.946]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:43.946]                 "immediateCondition"))) {
[13:33:43.946]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:43.946]                   ...future.conditions[[length(...future.conditions) + 
[13:33:43.946]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:43.946]                   if (TRUE && !signal) {
[13:33:43.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.946]                     {
[13:33:43.946]                       inherits <- base::inherits
[13:33:43.946]                       invokeRestart <- base::invokeRestart
[13:33:43.946]                       is.null <- base::is.null
[13:33:43.946]                       muffled <- FALSE
[13:33:43.946]                       if (inherits(cond, "message")) {
[13:33:43.946]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:43.946]                         if (muffled) 
[13:33:43.946]                           invokeRestart("muffleMessage")
[13:33:43.946]                       }
[13:33:43.946]                       else if (inherits(cond, "warning")) {
[13:33:43.946]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:43.946]                         if (muffled) 
[13:33:43.946]                           invokeRestart("muffleWarning")
[13:33:43.946]                       }
[13:33:43.946]                       else if (inherits(cond, "condition")) {
[13:33:43.946]                         if (!is.null(pattern)) {
[13:33:43.946]                           computeRestarts <- base::computeRestarts
[13:33:43.946]                           grepl <- base::grepl
[13:33:43.946]                           restarts <- computeRestarts(cond)
[13:33:43.946]                           for (restart in restarts) {
[13:33:43.946]                             name <- restart$name
[13:33:43.946]                             if (is.null(name)) 
[13:33:43.946]                               next
[13:33:43.946]                             if (!grepl(pattern, name)) 
[13:33:43.946]                               next
[13:33:43.946]                             invokeRestart(restart)
[13:33:43.946]                             muffled <- TRUE
[13:33:43.946]                             break
[13:33:43.946]                           }
[13:33:43.946]                         }
[13:33:43.946]                       }
[13:33:43.946]                       invisible(muffled)
[13:33:43.946]                     }
[13:33:43.946]                     muffleCondition(cond, pattern = "^muffle")
[13:33:43.946]                   }
[13:33:43.946]                 }
[13:33:43.946]                 else {
[13:33:43.946]                   if (TRUE) {
[13:33:43.946]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.946]                     {
[13:33:43.946]                       inherits <- base::inherits
[13:33:43.946]                       invokeRestart <- base::invokeRestart
[13:33:43.946]                       is.null <- base::is.null
[13:33:43.946]                       muffled <- FALSE
[13:33:43.946]                       if (inherits(cond, "message")) {
[13:33:43.946]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:43.946]                         if (muffled) 
[13:33:43.946]                           invokeRestart("muffleMessage")
[13:33:43.946]                       }
[13:33:43.946]                       else if (inherits(cond, "warning")) {
[13:33:43.946]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:43.946]                         if (muffled) 
[13:33:43.946]                           invokeRestart("muffleWarning")
[13:33:43.946]                       }
[13:33:43.946]                       else if (inherits(cond, "condition")) {
[13:33:43.946]                         if (!is.null(pattern)) {
[13:33:43.946]                           computeRestarts <- base::computeRestarts
[13:33:43.946]                           grepl <- base::grepl
[13:33:43.946]                           restarts <- computeRestarts(cond)
[13:33:43.946]                           for (restart in restarts) {
[13:33:43.946]                             name <- restart$name
[13:33:43.946]                             if (is.null(name)) 
[13:33:43.946]                               next
[13:33:43.946]                             if (!grepl(pattern, name)) 
[13:33:43.946]                               next
[13:33:43.946]                             invokeRestart(restart)
[13:33:43.946]                             muffled <- TRUE
[13:33:43.946]                             break
[13:33:43.946]                           }
[13:33:43.946]                         }
[13:33:43.946]                       }
[13:33:43.946]                       invisible(muffled)
[13:33:43.946]                     }
[13:33:43.946]                     muffleCondition(cond, pattern = "^muffle")
[13:33:43.946]                   }
[13:33:43.946]                 }
[13:33:43.946]             }
[13:33:43.946]         }))
[13:33:43.946]     }, error = function(ex) {
[13:33:43.946]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:43.946]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:43.946]                 ...future.rng), started = ...future.startTime, 
[13:33:43.946]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:43.946]             version = "1.8"), class = "FutureResult")
[13:33:43.946]     }, finally = {
[13:33:43.946]         if (!identical(...future.workdir, getwd())) 
[13:33:43.946]             setwd(...future.workdir)
[13:33:43.946]         {
[13:33:43.946]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:43.946]                 ...future.oldOptions$nwarnings <- NULL
[13:33:43.946]             }
[13:33:43.946]             base::options(...future.oldOptions)
[13:33:43.946]             if (.Platform$OS.type == "windows") {
[13:33:43.946]                 old_names <- names(...future.oldEnvVars)
[13:33:43.946]                 envs <- base::Sys.getenv()
[13:33:43.946]                 names <- names(envs)
[13:33:43.946]                 common <- intersect(names, old_names)
[13:33:43.946]                 added <- setdiff(names, old_names)
[13:33:43.946]                 removed <- setdiff(old_names, names)
[13:33:43.946]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:43.946]                   envs[common]]
[13:33:43.946]                 NAMES <- toupper(changed)
[13:33:43.946]                 args <- list()
[13:33:43.946]                 for (kk in seq_along(NAMES)) {
[13:33:43.946]                   name <- changed[[kk]]
[13:33:43.946]                   NAME <- NAMES[[kk]]
[13:33:43.946]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.946]                     next
[13:33:43.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:43.946]                 }
[13:33:43.946]                 NAMES <- toupper(added)
[13:33:43.946]                 for (kk in seq_along(NAMES)) {
[13:33:43.946]                   name <- added[[kk]]
[13:33:43.946]                   NAME <- NAMES[[kk]]
[13:33:43.946]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.946]                     next
[13:33:43.946]                   args[[name]] <- ""
[13:33:43.946]                 }
[13:33:43.946]                 NAMES <- toupper(removed)
[13:33:43.946]                 for (kk in seq_along(NAMES)) {
[13:33:43.946]                   name <- removed[[kk]]
[13:33:43.946]                   NAME <- NAMES[[kk]]
[13:33:43.946]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.946]                     next
[13:33:43.946]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:43.946]                 }
[13:33:43.946]                 if (length(args) > 0) 
[13:33:43.946]                   base::do.call(base::Sys.setenv, args = args)
[13:33:43.946]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:43.946]             }
[13:33:43.946]             else {
[13:33:43.946]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:43.946]             }
[13:33:43.946]             {
[13:33:43.946]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:43.946]                   0L) {
[13:33:43.946]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:43.946]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:43.946]                   base::options(opts)
[13:33:43.946]                 }
[13:33:43.946]                 {
[13:33:43.946]                   {
[13:33:43.946]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:43.946]                     NULL
[13:33:43.946]                   }
[13:33:43.946]                   options(future.plan = NULL)
[13:33:43.946]                   if (is.na(NA_character_)) 
[13:33:43.946]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:43.946]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:43.946]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:43.946]                     .init = FALSE)
[13:33:43.946]                 }
[13:33:43.946]             }
[13:33:43.946]         }
[13:33:43.946]     })
[13:33:43.946]     if (TRUE) {
[13:33:43.946]         base::sink(type = "output", split = FALSE)
[13:33:43.946]         if (TRUE) {
[13:33:43.946]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:43.946]         }
[13:33:43.946]         else {
[13:33:43.946]             ...future.result["stdout"] <- base::list(NULL)
[13:33:43.946]         }
[13:33:43.946]         base::close(...future.stdout)
[13:33:43.946]         ...future.stdout <- NULL
[13:33:43.946]     }
[13:33:43.946]     ...future.result$conditions <- ...future.conditions
[13:33:43.946]     ...future.result$finished <- base::Sys.time()
[13:33:43.946]     ...future.result
[13:33:43.946] }
[13:33:43.948] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[13:33:43.948] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[13:33:43.949] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[13:33:43.949] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:33:43.949] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:33:43.949] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[13:33:43.950] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[13:33:43.950] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:33:43.950] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:33:43.950] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:33:43.951] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:33:43.951] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[13:33:43.951] MultisessionFuture started
[13:33:43.952] - Launch lazy future ... done
[13:33:43.952] run() for ‘MultisessionFuture’ ... done
[13:33:43.952] Created future:
[13:33:43.952] MultisessionFuture:
[13:33:43.952] Label: ‘future_by-1’
[13:33:43.952] Expression:
[13:33:43.952] {
[13:33:43.952]     do.call(function(...) {
[13:33:43.952]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.952]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:43.952]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.952]             on.exit(options(oopts), add = TRUE)
[13:33:43.952]         }
[13:33:43.952]         {
[13:33:43.952]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:43.952]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.952]                 ...future.FUN(...future.X_jj, ...)
[13:33:43.952]             })
[13:33:43.952]         }
[13:33:43.952]     }, args = future.call.arguments)
[13:33:43.952] }
[13:33:43.952] Lazy evaluation: FALSE
[13:33:43.952] Asynchronous evaluation: TRUE
[13:33:43.952] Local evaluation: TRUE
[13:33:43.952] Environment: 0x55cb842fbd60
[13:33:43.952] Capture standard output: TRUE
[13:33:43.952] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:43.952] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:43.952] Packages: <none>
[13:33:43.952] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:43.952] Resolved: FALSE
[13:33:43.952] Value: <not collected>
[13:33:43.952] Conditions captured: <none>
[13:33:43.952] Early signaling: FALSE
[13:33:43.952] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:43.952] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:43.963] Chunk #1 of 2 ... DONE
[13:33:43.964] Chunk #2 of 2 ...
[13:33:43.964]  - Finding globals in 'X' for chunk #2 ...
[13:33:43.964] getGlobalsAndPackages() ...
[13:33:43.964] Searching for globals...
[13:33:43.964] 
[13:33:43.964] Searching for globals ... DONE
[13:33:43.964] - globals: [0] <none>
[13:33:43.964] getGlobalsAndPackages() ... DONE
[13:33:43.965]    + additional globals found: [n=0] 
[13:33:43.965]    + additional namespaces needed: [n=0] 
[13:33:43.965]  - Finding globals in 'X' for chunk #2 ... DONE
[13:33:43.965]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:43.965]  - seeds: <none>
[13:33:43.965]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.965] getGlobalsAndPackages() ...
[13:33:43.965] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.965] Resolving globals: FALSE
[13:33:43.965] Tweak future expression to call with '...' arguments ...
[13:33:43.966] {
[13:33:43.966]     do.call(function(...) {
[13:33:43.966]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.966]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:43.966]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.966]             on.exit(options(oopts), add = TRUE)
[13:33:43.966]         }
[13:33:43.966]         {
[13:33:43.966]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:43.966]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.966]                 ...future.FUN(...future.X_jj, ...)
[13:33:43.966]             })
[13:33:43.966]         }
[13:33:43.966]     }, args = future.call.arguments)
[13:33:43.966] }
[13:33:43.966] Tweak future expression to call with '...' arguments ... DONE
[13:33:43.966] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:43.966] 
[13:33:43.966] getGlobalsAndPackages() ... DONE
[13:33:43.967] run() for ‘Future’ ...
[13:33:43.967] - state: ‘created’
[13:33:43.967] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:43.980] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:43.980] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:43.980]   - Field: ‘node’
[13:33:43.980]   - Field: ‘label’
[13:33:43.980]   - Field: ‘local’
[13:33:43.980]   - Field: ‘owner’
[13:33:43.980]   - Field: ‘envir’
[13:33:43.980]   - Field: ‘workers’
[13:33:43.981]   - Field: ‘packages’
[13:33:43.981]   - Field: ‘gc’
[13:33:43.981]   - Field: ‘conditions’
[13:33:43.981]   - Field: ‘persistent’
[13:33:43.981]   - Field: ‘expr’
[13:33:43.981]   - Field: ‘uuid’
[13:33:43.981]   - Field: ‘seed’
[13:33:43.981]   - Field: ‘version’
[13:33:43.981]   - Field: ‘result’
[13:33:43.981]   - Field: ‘asynchronous’
[13:33:43.981]   - Field: ‘calls’
[13:33:43.982]   - Field: ‘globals’
[13:33:43.982]   - Field: ‘stdout’
[13:33:43.982]   - Field: ‘earlySignal’
[13:33:43.982]   - Field: ‘lazy’
[13:33:43.982]   - Field: ‘state’
[13:33:43.982] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:43.982] - Launch lazy future ...
[13:33:43.982] Packages needed by the future expression (n = 0): <none>
[13:33:43.982] Packages needed by future strategies (n = 0): <none>
[13:33:43.983] {
[13:33:43.983]     {
[13:33:43.983]         {
[13:33:43.983]             ...future.startTime <- base::Sys.time()
[13:33:43.983]             {
[13:33:43.983]                 {
[13:33:43.983]                   {
[13:33:43.983]                     {
[13:33:43.983]                       base::local({
[13:33:43.983]                         has_future <- base::requireNamespace("future", 
[13:33:43.983]                           quietly = TRUE)
[13:33:43.983]                         if (has_future) {
[13:33:43.983]                           ns <- base::getNamespace("future")
[13:33:43.983]                           version <- ns[[".package"]][["version"]]
[13:33:43.983]                           if (is.null(version)) 
[13:33:43.983]                             version <- utils::packageVersion("future")
[13:33:43.983]                         }
[13:33:43.983]                         else {
[13:33:43.983]                           version <- NULL
[13:33:43.983]                         }
[13:33:43.983]                         if (!has_future || version < "1.8.0") {
[13:33:43.983]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:43.983]                             "", base::R.version$version.string), 
[13:33:43.983]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:43.983]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:43.983]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:43.983]                               "release", "version")], collapse = " "), 
[13:33:43.983]                             hostname = base::Sys.info()[["nodename"]])
[13:33:43.983]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:43.983]                             info)
[13:33:43.983]                           info <- base::paste(info, collapse = "; ")
[13:33:43.983]                           if (!has_future) {
[13:33:43.983]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:43.983]                               info)
[13:33:43.983]                           }
[13:33:43.983]                           else {
[13:33:43.983]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:43.983]                               info, version)
[13:33:43.983]                           }
[13:33:43.983]                           base::stop(msg)
[13:33:43.983]                         }
[13:33:43.983]                       })
[13:33:43.983]                     }
[13:33:43.983]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:43.983]                     base::options(mc.cores = 1L)
[13:33:43.983]                   }
[13:33:43.983]                   ...future.strategy.old <- future::plan("list")
[13:33:43.983]                   options(future.plan = NULL)
[13:33:43.983]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:43.983]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:43.983]                 }
[13:33:43.983]                 ...future.workdir <- getwd()
[13:33:43.983]             }
[13:33:43.983]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:43.983]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:43.983]         }
[13:33:43.983]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:43.983]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:43.983]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:43.983]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:43.983]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:43.983]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:43.983]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:43.983]             base::names(...future.oldOptions))
[13:33:43.983]     }
[13:33:43.983]     if (FALSE) {
[13:33:43.983]     }
[13:33:43.983]     else {
[13:33:43.983]         if (TRUE) {
[13:33:43.983]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:43.983]                 open = "w")
[13:33:43.983]         }
[13:33:43.983]         else {
[13:33:43.983]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:43.983]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:43.983]         }
[13:33:43.983]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:43.983]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:43.983]             base::sink(type = "output", split = FALSE)
[13:33:43.983]             base::close(...future.stdout)
[13:33:43.983]         }, add = TRUE)
[13:33:43.983]     }
[13:33:43.983]     ...future.frame <- base::sys.nframe()
[13:33:43.983]     ...future.conditions <- base::list()
[13:33:43.983]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:43.983]     if (FALSE) {
[13:33:43.983]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:43.983]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:43.983]     }
[13:33:43.983]     ...future.result <- base::tryCatch({
[13:33:43.983]         base::withCallingHandlers({
[13:33:43.983]             ...future.value <- base::withVisible(base::local({
[13:33:43.983]                 ...future.makeSendCondition <- base::local({
[13:33:43.983]                   sendCondition <- NULL
[13:33:43.983]                   function(frame = 1L) {
[13:33:43.983]                     if (is.function(sendCondition)) 
[13:33:43.983]                       return(sendCondition)
[13:33:43.983]                     ns <- getNamespace("parallel")
[13:33:43.983]                     if (exists("sendData", mode = "function", 
[13:33:43.983]                       envir = ns)) {
[13:33:43.983]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:43.983]                         envir = ns)
[13:33:43.983]                       envir <- sys.frame(frame)
[13:33:43.983]                       master <- NULL
[13:33:43.983]                       while (!identical(envir, .GlobalEnv) && 
[13:33:43.983]                         !identical(envir, emptyenv())) {
[13:33:43.983]                         if (exists("master", mode = "list", envir = envir, 
[13:33:43.983]                           inherits = FALSE)) {
[13:33:43.983]                           master <- get("master", mode = "list", 
[13:33:43.983]                             envir = envir, inherits = FALSE)
[13:33:43.983]                           if (inherits(master, c("SOCKnode", 
[13:33:43.983]                             "SOCK0node"))) {
[13:33:43.983]                             sendCondition <<- function(cond) {
[13:33:43.983]                               data <- list(type = "VALUE", value = cond, 
[13:33:43.983]                                 success = TRUE)
[13:33:43.983]                               parallel_sendData(master, data)
[13:33:43.983]                             }
[13:33:43.983]                             return(sendCondition)
[13:33:43.983]                           }
[13:33:43.983]                         }
[13:33:43.983]                         frame <- frame + 1L
[13:33:43.983]                         envir <- sys.frame(frame)
[13:33:43.983]                       }
[13:33:43.983]                     }
[13:33:43.983]                     sendCondition <<- function(cond) NULL
[13:33:43.983]                   }
[13:33:43.983]                 })
[13:33:43.983]                 withCallingHandlers({
[13:33:43.983]                   {
[13:33:43.983]                     do.call(function(...) {
[13:33:43.983]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.983]                       if (!identical(...future.globals.maxSize.org, 
[13:33:43.983]                         ...future.globals.maxSize)) {
[13:33:43.983]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.983]                         on.exit(options(oopts), add = TRUE)
[13:33:43.983]                       }
[13:33:43.983]                       {
[13:33:43.983]                         lapply(seq_along(...future.elements_ii), 
[13:33:43.983]                           FUN = function(jj) {
[13:33:43.983]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.983]                             ...future.FUN(...future.X_jj, ...)
[13:33:43.983]                           })
[13:33:43.983]                       }
[13:33:43.983]                     }, args = future.call.arguments)
[13:33:43.983]                   }
[13:33:43.983]                 }, immediateCondition = function(cond) {
[13:33:43.983]                   sendCondition <- ...future.makeSendCondition()
[13:33:43.983]                   sendCondition(cond)
[13:33:43.983]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.983]                   {
[13:33:43.983]                     inherits <- base::inherits
[13:33:43.983]                     invokeRestart <- base::invokeRestart
[13:33:43.983]                     is.null <- base::is.null
[13:33:43.983]                     muffled <- FALSE
[13:33:43.983]                     if (inherits(cond, "message")) {
[13:33:43.983]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:43.983]                       if (muffled) 
[13:33:43.983]                         invokeRestart("muffleMessage")
[13:33:43.983]                     }
[13:33:43.983]                     else if (inherits(cond, "warning")) {
[13:33:43.983]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:43.983]                       if (muffled) 
[13:33:43.983]                         invokeRestart("muffleWarning")
[13:33:43.983]                     }
[13:33:43.983]                     else if (inherits(cond, "condition")) {
[13:33:43.983]                       if (!is.null(pattern)) {
[13:33:43.983]                         computeRestarts <- base::computeRestarts
[13:33:43.983]                         grepl <- base::grepl
[13:33:43.983]                         restarts <- computeRestarts(cond)
[13:33:43.983]                         for (restart in restarts) {
[13:33:43.983]                           name <- restart$name
[13:33:43.983]                           if (is.null(name)) 
[13:33:43.983]                             next
[13:33:43.983]                           if (!grepl(pattern, name)) 
[13:33:43.983]                             next
[13:33:43.983]                           invokeRestart(restart)
[13:33:43.983]                           muffled <- TRUE
[13:33:43.983]                           break
[13:33:43.983]                         }
[13:33:43.983]                       }
[13:33:43.983]                     }
[13:33:43.983]                     invisible(muffled)
[13:33:43.983]                   }
[13:33:43.983]                   muffleCondition(cond)
[13:33:43.983]                 })
[13:33:43.983]             }))
[13:33:43.983]             future::FutureResult(value = ...future.value$value, 
[13:33:43.983]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:43.983]                   ...future.rng), globalenv = if (FALSE) 
[13:33:43.983]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:43.983]                     ...future.globalenv.names))
[13:33:43.983]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:43.983]         }, condition = base::local({
[13:33:43.983]             c <- base::c
[13:33:43.983]             inherits <- base::inherits
[13:33:43.983]             invokeRestart <- base::invokeRestart
[13:33:43.983]             length <- base::length
[13:33:43.983]             list <- base::list
[13:33:43.983]             seq.int <- base::seq.int
[13:33:43.983]             signalCondition <- base::signalCondition
[13:33:43.983]             sys.calls <- base::sys.calls
[13:33:43.983]             `[[` <- base::`[[`
[13:33:43.983]             `+` <- base::`+`
[13:33:43.983]             `<<-` <- base::`<<-`
[13:33:43.983]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:43.983]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:43.983]                   3L)]
[13:33:43.983]             }
[13:33:43.983]             function(cond) {
[13:33:43.983]                 is_error <- inherits(cond, "error")
[13:33:43.983]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:43.983]                   NULL)
[13:33:43.983]                 if (is_error) {
[13:33:43.983]                   sessionInformation <- function() {
[13:33:43.983]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:43.983]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:43.983]                       search = base::search(), system = base::Sys.info())
[13:33:43.983]                   }
[13:33:43.983]                   ...future.conditions[[length(...future.conditions) + 
[13:33:43.983]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:43.983]                     cond$call), session = sessionInformation(), 
[13:33:43.983]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:43.983]                   signalCondition(cond)
[13:33:43.983]                 }
[13:33:43.983]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:43.983]                 "immediateCondition"))) {
[13:33:43.983]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:43.983]                   ...future.conditions[[length(...future.conditions) + 
[13:33:43.983]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:43.983]                   if (TRUE && !signal) {
[13:33:43.983]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.983]                     {
[13:33:43.983]                       inherits <- base::inherits
[13:33:43.983]                       invokeRestart <- base::invokeRestart
[13:33:43.983]                       is.null <- base::is.null
[13:33:43.983]                       muffled <- FALSE
[13:33:43.983]                       if (inherits(cond, "message")) {
[13:33:43.983]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:43.983]                         if (muffled) 
[13:33:43.983]                           invokeRestart("muffleMessage")
[13:33:43.983]                       }
[13:33:43.983]                       else if (inherits(cond, "warning")) {
[13:33:43.983]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:43.983]                         if (muffled) 
[13:33:43.983]                           invokeRestart("muffleWarning")
[13:33:43.983]                       }
[13:33:43.983]                       else if (inherits(cond, "condition")) {
[13:33:43.983]                         if (!is.null(pattern)) {
[13:33:43.983]                           computeRestarts <- base::computeRestarts
[13:33:43.983]                           grepl <- base::grepl
[13:33:43.983]                           restarts <- computeRestarts(cond)
[13:33:43.983]                           for (restart in restarts) {
[13:33:43.983]                             name <- restart$name
[13:33:43.983]                             if (is.null(name)) 
[13:33:43.983]                               next
[13:33:43.983]                             if (!grepl(pattern, name)) 
[13:33:43.983]                               next
[13:33:43.983]                             invokeRestart(restart)
[13:33:43.983]                             muffled <- TRUE
[13:33:43.983]                             break
[13:33:43.983]                           }
[13:33:43.983]                         }
[13:33:43.983]                       }
[13:33:43.983]                       invisible(muffled)
[13:33:43.983]                     }
[13:33:43.983]                     muffleCondition(cond, pattern = "^muffle")
[13:33:43.983]                   }
[13:33:43.983]                 }
[13:33:43.983]                 else {
[13:33:43.983]                   if (TRUE) {
[13:33:43.983]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:43.983]                     {
[13:33:43.983]                       inherits <- base::inherits
[13:33:43.983]                       invokeRestart <- base::invokeRestart
[13:33:43.983]                       is.null <- base::is.null
[13:33:43.983]                       muffled <- FALSE
[13:33:43.983]                       if (inherits(cond, "message")) {
[13:33:43.983]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:43.983]                         if (muffled) 
[13:33:43.983]                           invokeRestart("muffleMessage")
[13:33:43.983]                       }
[13:33:43.983]                       else if (inherits(cond, "warning")) {
[13:33:43.983]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:43.983]                         if (muffled) 
[13:33:43.983]                           invokeRestart("muffleWarning")
[13:33:43.983]                       }
[13:33:43.983]                       else if (inherits(cond, "condition")) {
[13:33:43.983]                         if (!is.null(pattern)) {
[13:33:43.983]                           computeRestarts <- base::computeRestarts
[13:33:43.983]                           grepl <- base::grepl
[13:33:43.983]                           restarts <- computeRestarts(cond)
[13:33:43.983]                           for (restart in restarts) {
[13:33:43.983]                             name <- restart$name
[13:33:43.983]                             if (is.null(name)) 
[13:33:43.983]                               next
[13:33:43.983]                             if (!grepl(pattern, name)) 
[13:33:43.983]                               next
[13:33:43.983]                             invokeRestart(restart)
[13:33:43.983]                             muffled <- TRUE
[13:33:43.983]                             break
[13:33:43.983]                           }
[13:33:43.983]                         }
[13:33:43.983]                       }
[13:33:43.983]                       invisible(muffled)
[13:33:43.983]                     }
[13:33:43.983]                     muffleCondition(cond, pattern = "^muffle")
[13:33:43.983]                   }
[13:33:43.983]                 }
[13:33:43.983]             }
[13:33:43.983]         }))
[13:33:43.983]     }, error = function(ex) {
[13:33:43.983]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:43.983]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:43.983]                 ...future.rng), started = ...future.startTime, 
[13:33:43.983]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:43.983]             version = "1.8"), class = "FutureResult")
[13:33:43.983]     }, finally = {
[13:33:43.983]         if (!identical(...future.workdir, getwd())) 
[13:33:43.983]             setwd(...future.workdir)
[13:33:43.983]         {
[13:33:43.983]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:43.983]                 ...future.oldOptions$nwarnings <- NULL
[13:33:43.983]             }
[13:33:43.983]             base::options(...future.oldOptions)
[13:33:43.983]             if (.Platform$OS.type == "windows") {
[13:33:43.983]                 old_names <- names(...future.oldEnvVars)
[13:33:43.983]                 envs <- base::Sys.getenv()
[13:33:43.983]                 names <- names(envs)
[13:33:43.983]                 common <- intersect(names, old_names)
[13:33:43.983]                 added <- setdiff(names, old_names)
[13:33:43.983]                 removed <- setdiff(old_names, names)
[13:33:43.983]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:43.983]                   envs[common]]
[13:33:43.983]                 NAMES <- toupper(changed)
[13:33:43.983]                 args <- list()
[13:33:43.983]                 for (kk in seq_along(NAMES)) {
[13:33:43.983]                   name <- changed[[kk]]
[13:33:43.983]                   NAME <- NAMES[[kk]]
[13:33:43.983]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.983]                     next
[13:33:43.983]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:43.983]                 }
[13:33:43.983]                 NAMES <- toupper(added)
[13:33:43.983]                 for (kk in seq_along(NAMES)) {
[13:33:43.983]                   name <- added[[kk]]
[13:33:43.983]                   NAME <- NAMES[[kk]]
[13:33:43.983]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.983]                     next
[13:33:43.983]                   args[[name]] <- ""
[13:33:43.983]                 }
[13:33:43.983]                 NAMES <- toupper(removed)
[13:33:43.983]                 for (kk in seq_along(NAMES)) {
[13:33:43.983]                   name <- removed[[kk]]
[13:33:43.983]                   NAME <- NAMES[[kk]]
[13:33:43.983]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:43.983]                     next
[13:33:43.983]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:43.983]                 }
[13:33:43.983]                 if (length(args) > 0) 
[13:33:43.983]                   base::do.call(base::Sys.setenv, args = args)
[13:33:43.983]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:43.983]             }
[13:33:43.983]             else {
[13:33:43.983]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:43.983]             }
[13:33:43.983]             {
[13:33:43.983]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:43.983]                   0L) {
[13:33:43.983]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:43.983]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:43.983]                   base::options(opts)
[13:33:43.983]                 }
[13:33:43.983]                 {
[13:33:43.983]                   {
[13:33:43.983]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:43.983]                     NULL
[13:33:43.983]                   }
[13:33:43.983]                   options(future.plan = NULL)
[13:33:43.983]                   if (is.na(NA_character_)) 
[13:33:43.983]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:43.983]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:43.983]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:43.983]                     .init = FALSE)
[13:33:43.983]                 }
[13:33:43.983]             }
[13:33:43.983]         }
[13:33:43.983]     })
[13:33:43.983]     if (TRUE) {
[13:33:43.983]         base::sink(type = "output", split = FALSE)
[13:33:43.983]         if (TRUE) {
[13:33:43.983]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:43.983]         }
[13:33:43.983]         else {
[13:33:43.983]             ...future.result["stdout"] <- base::list(NULL)
[13:33:43.983]         }
[13:33:43.983]         base::close(...future.stdout)
[13:33:43.983]         ...future.stdout <- NULL
[13:33:43.983]     }
[13:33:43.983]     ...future.result$conditions <- ...future.conditions
[13:33:43.983]     ...future.result$finished <- base::Sys.time()
[13:33:43.983]     ...future.result
[13:33:43.983] }
[13:33:43.985] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[13:33:43.985] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[13:33:43.986] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[13:33:43.986] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:33:43.986] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:33:43.987] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[13:33:43.987] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[13:33:43.987] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:33:43.987] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:33:43.987] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:33:43.988] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:33:43.988] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[13:33:43.988] MultisessionFuture started
[13:33:43.988] - Launch lazy future ... done
[13:33:43.988] run() for ‘MultisessionFuture’ ... done
[13:33:43.989] Created future:
[13:33:43.989] MultisessionFuture:
[13:33:43.989] Label: ‘future_by-2’
[13:33:43.989] Expression:
[13:33:43.989] {
[13:33:43.989]     do.call(function(...) {
[13:33:43.989]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:43.989]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:43.989]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:43.989]             on.exit(options(oopts), add = TRUE)
[13:33:43.989]         }
[13:33:43.989]         {
[13:33:43.989]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:43.989]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:43.989]                 ...future.FUN(...future.X_jj, ...)
[13:33:43.989]             })
[13:33:43.989]         }
[13:33:43.989]     }, args = future.call.arguments)
[13:33:43.989] }
[13:33:43.989] Lazy evaluation: FALSE
[13:33:43.989] Asynchronous evaluation: TRUE
[13:33:43.989] Local evaluation: TRUE
[13:33:43.989] Environment: 0x55cb842fbd60
[13:33:43.989] Capture standard output: TRUE
[13:33:43.989] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:43.989] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:43.989] Packages: <none>
[13:33:43.989] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:43.989] Resolved: FALSE
[13:33:43.989] Value: <not collected>
[13:33:43.989] Conditions captured: <none>
[13:33:43.989] Early signaling: FALSE
[13:33:43.989] Owner process: 75370bb0-2f20-d935-3e9e-db1edc0f92b1
[13:33:43.989] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:44.000] Chunk #2 of 2 ... DONE
[13:33:44.000] Launching 2 futures (chunks) ... DONE
[13:33:44.001] Resolving 2 futures (chunks) ...
[13:33:44.001] resolve() on list ...
[13:33:44.001]  recursive: 0
[13:33:44.001]  length: 2
[13:33:44.001] 
[13:33:44.001] receiveMessageFromWorker() for ClusterFuture ...
[13:33:44.001] - Validating connection of MultisessionFuture
[13:33:44.002] - received message: FutureResult
[13:33:44.002] - Received FutureResult
[13:33:44.002] - Erased future from FutureRegistry
[13:33:44.002] result() for ClusterFuture ...
[13:33:44.002] - result already collected: FutureResult
[13:33:44.002] result() for ClusterFuture ... done
[13:33:44.002] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:44.002] Future #1
[13:33:44.002] result() for ClusterFuture ...
[13:33:44.002] - result already collected: FutureResult
[13:33:44.003] result() for ClusterFuture ... done
[13:33:44.003] result() for ClusterFuture ...
[13:33:44.003] - result already collected: FutureResult
[13:33:44.003] result() for ClusterFuture ... done
[13:33:44.003] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:33:44.003] - nx: 2
[13:33:44.003] - relay: TRUE
[13:33:44.003] - stdout: TRUE
[13:33:44.003] - signal: TRUE
[13:33:44.003] - resignal: FALSE
[13:33:44.003] - force: TRUE
[13:33:44.003] - relayed: [n=2] FALSE, FALSE
[13:33:44.004] - queued futures: [n=2] FALSE, FALSE
[13:33:44.004]  - until=1
[13:33:44.004]  - relaying element #1
[13:33:44.004] result() for ClusterFuture ...
[13:33:44.004] - result already collected: FutureResult
[13:33:44.004] result() for ClusterFuture ... done
[13:33:44.004] result() for ClusterFuture ...
[13:33:44.004] - result already collected: FutureResult
[13:33:44.004] result() for ClusterFuture ... done
[13:33:44.004] result() for ClusterFuture ...
[13:33:44.004] - result already collected: FutureResult
[13:33:44.005] result() for ClusterFuture ... done
[13:33:44.005] result() for ClusterFuture ...
[13:33:44.005] - result already collected: FutureResult
[13:33:44.005] result() for ClusterFuture ... done
[13:33:44.005] - relayed: [n=2] TRUE, FALSE
[13:33:44.005] - queued futures: [n=2] TRUE, FALSE
[13:33:44.005] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:33:44.005]  length: 1 (resolved future 1)
[13:33:44.033] receiveMessageFromWorker() for ClusterFuture ...
[13:33:44.033] - Validating connection of MultisessionFuture
[13:33:44.033] - received message: FutureResult
[13:33:44.033] - Received FutureResult
[13:33:44.033] - Erased future from FutureRegistry
[13:33:44.033] result() for ClusterFuture ...
[13:33:44.034] - result already collected: FutureResult
[13:33:44.034] result() for ClusterFuture ... done
[13:33:44.034] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:44.034] Future #2
[13:33:44.034] result() for ClusterFuture ...
[13:33:44.034] - result already collected: FutureResult
[13:33:44.034] result() for ClusterFuture ... done
[13:33:44.034] result() for ClusterFuture ...
[13:33:44.034] - result already collected: FutureResult
[13:33:44.034] result() for ClusterFuture ... done
[13:33:44.034] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:33:44.035] - nx: 2
[13:33:44.035] - relay: TRUE
[13:33:44.035] - stdout: TRUE
[13:33:44.035] - signal: TRUE
[13:33:44.035] - resignal: FALSE
[13:33:44.035] - force: TRUE
[13:33:44.035] - relayed: [n=2] TRUE, FALSE
[13:33:44.035] - queued futures: [n=2] TRUE, FALSE
[13:33:44.035]  - until=2
[13:33:44.035]  - relaying element #2
[13:33:44.035] result() for ClusterFuture ...
[13:33:44.035] - result already collected: FutureResult
[13:33:44.036] result() for ClusterFuture ... done
[13:33:44.036] result() for ClusterFuture ...
[13:33:44.036] - result already collected: FutureResult
[13:33:44.036] result() for ClusterFuture ... done
[13:33:44.036] result() for ClusterFuture ...
[13:33:44.036] - result already collected: FutureResult
[13:33:44.036] result() for ClusterFuture ... done
[13:33:44.036] result() for ClusterFuture ...
[13:33:44.036] - result already collected: FutureResult
[13:33:44.036] result() for ClusterFuture ... done
[13:33:44.036] - relayed: [n=2] TRUE, TRUE
[13:33:44.037] - queued futures: [n=2] TRUE, TRUE
[13:33:44.037] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:33:44.037]  length: 0 (resolved future 2)
[13:33:44.037] Relaying remaining futures
[13:33:44.037] signalConditionsASAP(NULL, pos=0) ...
[13:33:44.037] - nx: 2
[13:33:44.037] - relay: TRUE
[13:33:44.037] - stdout: TRUE
[13:33:44.037] - signal: TRUE
[13:33:44.037] - resignal: FALSE
[13:33:44.037] - force: TRUE
[13:33:44.037] - relayed: [n=2] TRUE, TRUE
[13:33:44.038] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:44.038] - relayed: [n=2] TRUE, TRUE
[13:33:44.038] - queued futures: [n=2] TRUE, TRUE
[13:33:44.038] signalConditionsASAP(NULL, pos=0) ... done
[13:33:44.038] resolve() on list ... DONE
[13:33:44.038] result() for ClusterFuture ...
[13:33:44.038] - result already collected: FutureResult
[13:33:44.038] result() for ClusterFuture ... done
[13:33:44.038] result() for ClusterFuture ...
[13:33:44.038] - result already collected: FutureResult
[13:33:44.038] result() for ClusterFuture ... done
[13:33:44.039] result() for ClusterFuture ...
[13:33:44.039] - result already collected: FutureResult
[13:33:44.039] result() for ClusterFuture ... done
[13:33:44.039] result() for ClusterFuture ...
[13:33:44.039] - result already collected: FutureResult
[13:33:44.039] result() for ClusterFuture ... done
[13:33:44.039]  - Number of value chunks collected: 2
[13:33:44.039] Resolving 2 futures (chunks) ... DONE
[13:33:44.039] Reducing values from 2 chunks ...
[13:33:44.039]  - Number of values collected after concatenation: 3
[13:33:44.039]  - Number of values expected: 3
[13:33:44.040] Reducing values from 2 chunks ... DONE
[13:33:44.040] future_lapply() ... DONE
[13:33:44.040] future_by_internal() ... DONE
[13:33:44.041] future_by_internal() ...
Testing with 2 cores ... DONE
> 
> message("*** future_by() ... DONE")
*** future_by() ... DONE
> 
> source("incl/end.R")
[13:33:44.042] plan(): Setting new future strategy stack:
[13:33:44.042] List of future strategies:
[13:33:44.042] 1. FutureStrategy:
[13:33:44.042]    - args: function (..., envir = parent.frame())
[13:33:44.042]    - tweaked: FALSE
[13:33:44.042]    - call: future::plan(oplan)
[13:33:44.042] plan(): nbrOfWorkers() = 1
> 
