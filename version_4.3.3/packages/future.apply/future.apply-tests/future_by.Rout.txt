
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[10:29:52.871] plan(): Setting new future strategy stack:
[10:29:52.872] List of future strategies:
[10:29:52.872] 1. sequential:
[10:29:52.872]    - args: function (..., envir = parent.frame())
[10:29:52.872]    - tweaked: FALSE
[10:29:52.872]    - call: future::plan("sequential")
[10:29:52.886] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> all_equal_but_call <- function(target, current, ...) {
+   attr(target, "call") <- NULL
+   attr(current, "call") <- NULL
+   all.equal(target = target, current = current, ...)
+ }
> 
> message("*** future_by() ...")
*** future_by() ...
> 
> ## ---------------------------------------------------------
> ## by()
> ## ---------------------------------------------------------
> if (require("datasets") && require("stats")) { ## warpbreaks & lm()
+   ## Use a local variable to test that it is properly exported, because
+   ## 'warpbreaks' is available in all R sessions
+   data <- warpbreaks
+   
+   y0 <- by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+   y1 <- by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+   y2 <- by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+     lm(breaks ~ wool, data = x, ...)
+   }, singular.ok = FALSE)
+   
+   ## now suppose we want to extract the coefficients by group
+   tmp <- with(data, by(data, INDICES = tension, FUN = function(x) {
+     lm(breaks ~ wool, data = x)
+   }))
+   y3 <- sapply(tmp, coef)
+ 
+   ## Source: {r-source}/tests/reg-tests-1d.R
+   by2 <- function(data, INDICES, FUN) {
+     by(data, INDICES = INDICES, FUN = FUN)
+   }
+   future_by2 <- function(data, INDICES, FUN) {
+     future_by(data, INDICES = INDICES, FUN = FUN)
+   }
+   y4 <- by2(data, INDICES = data[,"tension"], FUN = summary)
+ 
+   for (cores in 1:availCores) {
+     message(sprintf("Testing with %d cores ...", cores))
+     options(mc.cores = cores)
+     strategies <- supportedStrategies(cores)
+   
+     for (strategy in supportedStrategies()) {
+       message(sprintf("- plan('%s') ...", strategy))
+       plan(strategy)
+     
+       y0f <- future_by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y0f, y0, check.attributes = FALSE))
+       
+       y1f <- future_by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+       stopifnot(all_equal_but_call(y1f, y1))
+       
+       y2f <- future_by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+         lm(breaks ~ wool, data = x, ...)
+       }, singular.ok = FALSE)
+       stopifnot(all_equal_but_call(y2f, y2))
+       
+       ## now suppose we want to extract the coefficients by group
+       tmp <- with(data, future_by(data, INDICES = tension, FUN = function(x) {
+         lm(breaks ~ wool, data = x)
+       }))
+       y3f <- sapply(tmp, coef)
+       stopifnot(all_equal_but_call(y3f, y3))
+       
+       y4f <- future_by2(data, INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y4f, y4))
+ 
+       ## Deprecated /HB 2022-10-24
+       y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       stopifnot(all_equal_but_call(y4f2, y4))
+ 
+       res <- tryCatch({
+         y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       }, warning = identity)
+       stopifnot(inherits(res, "warning"))
+       if (getRversion() >= "3.6.0") {
+         stopifnot(inherits(res, "deprecatedWarning"))
+       }
+     } ## for (strategy ...)
+     
+     message(sprintf("Testing with %d cores ... DONE", cores))
+   } ## for (cores ...)
+ } ## if (require("stats"))
Testing with 1 cores ...
- plan('sequential') ...
[10:29:52.943] plan(): Setting new future strategy stack:
[10:29:52.943] List of future strategies:
[10:29:52.943] 1. sequential:
[10:29:52.943]    - args: function (..., envir = parent.frame())
[10:29:52.943]    - tweaked: FALSE
[10:29:52.943]    - call: plan(strategy)
[10:29:52.955] plan(): nbrOfWorkers() = 1
[10:29:52.955] future_by_internal() ...
[10:29:52.956] future_lapply() ...
[10:29:52.960] Number of chunks: 1
[10:29:52.960] getGlobalsAndPackagesXApply() ...
[10:29:52.961]  - future.globals: TRUE
[10:29:52.961] getGlobalsAndPackages() ...
[10:29:52.961] Searching for globals...
[10:29:52.964] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:52.964] Searching for globals ... DONE
[10:29:52.964] Resolving globals: FALSE
[10:29:52.965] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:52.965] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:52.966] - globals: [1] ‘FUN’
[10:29:52.966] 
[10:29:52.966] getGlobalsAndPackages() ... DONE
[10:29:52.966]  - globals found/used: [n=1] ‘FUN’
[10:29:52.966]  - needed namespaces: [n=0] 
[10:29:52.966] Finding globals ... DONE
[10:29:52.966]  - use_args: TRUE
[10:29:52.966]  - Getting '...' globals ...
[10:29:52.967] resolve() on list ...
[10:29:52.967]  recursive: 0
[10:29:52.967]  length: 1
[10:29:52.968]  elements: ‘...’
[10:29:52.968]  length: 0 (resolved future 1)
[10:29:52.968] resolve() on list ... DONE
[10:29:52.968]    - '...' content: [n=0] 
[10:29:52.968] List of 1
[10:29:52.968]  $ ...: list()
[10:29:52.968]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:52.968]  - attr(*, "where")=List of 1
[10:29:52.968]   ..$ ...:<environment: 0x556dd3cc58d0> 
[10:29:52.968]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:52.968]  - attr(*, "resolved")= logi TRUE
[10:29:52.968]  - attr(*, "total_size")= num NA
[10:29:52.972]  - Getting '...' globals ... DONE
[10:29:52.973] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:52.973] List of 2
[10:29:52.973]  $ ...future.FUN:function (object, ...)  
[10:29:52.973]  $ ...          : list()
[10:29:52.973]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:52.973]  - attr(*, "where")=List of 2
[10:29:52.973]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:52.973]   ..$ ...          :<environment: 0x556dd3cc58d0> 
[10:29:52.973]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:52.973]  - attr(*, "resolved")= logi FALSE
[10:29:52.973]  - attr(*, "total_size")= num 1240
[10:29:52.975] Packages to be attached in all futures: [n=0] 
[10:29:52.975] getGlobalsAndPackagesXApply() ... DONE
[10:29:52.976] Number of futures (= number of chunks): 1
[10:29:52.976] Launching 1 futures (chunks) ...
[10:29:52.976] Chunk #1 of 1 ...
[10:29:52.976]  - Finding globals in 'X' for chunk #1 ...
[10:29:52.976] getGlobalsAndPackages() ...
[10:29:52.976] Searching for globals...
[10:29:52.977] 
[10:29:52.977] Searching for globals ... DONE
[10:29:52.977] - globals: [0] <none>
[10:29:52.977] getGlobalsAndPackages() ... DONE
[10:29:52.977]    + additional globals found: [n=0] 
[10:29:52.977]    + additional namespaces needed: [n=0] 
[10:29:52.977]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:52.978]  - seeds: <none>
[10:29:52.978]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:52.978] getGlobalsAndPackages() ...
[10:29:52.978] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:52.978] Resolving globals: FALSE
[10:29:52.978] Tweak future expression to call with '...' arguments ...
[10:29:52.978] {
[10:29:52.978]     do.call(function(...) {
[10:29:52.978]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:52.978]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:52.978]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:52.978]             on.exit(options(oopts), add = TRUE)
[10:29:52.978]         }
[10:29:52.978]         {
[10:29:52.978]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:52.978]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:52.978]                 ...future.FUN(...future.X_jj, ...)
[10:29:52.978]             })
[10:29:52.978]         }
[10:29:52.978]     }, args = future.call.arguments)
[10:29:52.978] }
[10:29:52.979] Tweak future expression to call with '...' arguments ... DONE
[10:29:52.979] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:52.979] 
[10:29:52.979] getGlobalsAndPackages() ... DONE
[10:29:52.980] run() for ‘Future’ ...
[10:29:52.980] - state: ‘created’
[10:29:52.980] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:29:52.980] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:52.981] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:52.981]   - Field: ‘label’
[10:29:52.981]   - Field: ‘local’
[10:29:52.983]   - Field: ‘owner’
[10:29:52.983]   - Field: ‘envir’
[10:29:52.983]   - Field: ‘packages’
[10:29:52.983]   - Field: ‘gc’
[10:29:52.983]   - Field: ‘conditions’
[10:29:52.983]   - Field: ‘expr’
[10:29:52.984]   - Field: ‘uuid’
[10:29:52.984]   - Field: ‘seed’
[10:29:52.984]   - Field: ‘version’
[10:29:52.984]   - Field: ‘result’
[10:29:52.984]   - Field: ‘asynchronous’
[10:29:52.984]   - Field: ‘calls’
[10:29:52.984]   - Field: ‘globals’
[10:29:52.984]   - Field: ‘stdout’
[10:29:52.984]   - Field: ‘earlySignal’
[10:29:52.984]   - Field: ‘lazy’
[10:29:52.985]   - Field: ‘state’
[10:29:52.985] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:52.985] - Launch lazy future ...
[10:29:52.986] Packages needed by the future expression (n = 0): <none>
[10:29:52.986] Packages needed by future strategies (n = 0): <none>
[10:29:52.987] {
[10:29:52.987]     {
[10:29:52.987]         {
[10:29:52.987]             ...future.startTime <- base::Sys.time()
[10:29:52.987]             {
[10:29:52.987]                 {
[10:29:52.987]                   {
[10:29:52.987]                     base::local({
[10:29:52.987]                       has_future <- base::requireNamespace("future", 
[10:29:52.987]                         quietly = TRUE)
[10:29:52.987]                       if (has_future) {
[10:29:52.987]                         ns <- base::getNamespace("future")
[10:29:52.987]                         version <- ns[[".package"]][["version"]]
[10:29:52.987]                         if (is.null(version)) 
[10:29:52.987]                           version <- utils::packageVersion("future")
[10:29:52.987]                       }
[10:29:52.987]                       else {
[10:29:52.987]                         version <- NULL
[10:29:52.987]                       }
[10:29:52.987]                       if (!has_future || version < "1.8.0") {
[10:29:52.987]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:52.987]                           "", base::R.version$version.string), 
[10:29:52.987]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:52.987]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:52.987]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:52.987]                             "release", "version")], collapse = " "), 
[10:29:52.987]                           hostname = base::Sys.info()[["nodename"]])
[10:29:52.987]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:52.987]                           info)
[10:29:52.987]                         info <- base::paste(info, collapse = "; ")
[10:29:52.987]                         if (!has_future) {
[10:29:52.987]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:52.987]                             info)
[10:29:52.987]                         }
[10:29:52.987]                         else {
[10:29:52.987]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:52.987]                             info, version)
[10:29:52.987]                         }
[10:29:52.987]                         base::stop(msg)
[10:29:52.987]                       }
[10:29:52.987]                     })
[10:29:52.987]                   }
[10:29:52.987]                   ...future.strategy.old <- future::plan("list")
[10:29:52.987]                   options(future.plan = NULL)
[10:29:52.987]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:52.987]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:52.987]                 }
[10:29:52.987]                 ...future.workdir <- getwd()
[10:29:52.987]             }
[10:29:52.987]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:52.987]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:52.987]         }
[10:29:52.987]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:52.987]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:52.987]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:52.987]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:52.987]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:52.987]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:52.987]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:52.987]             base::names(...future.oldOptions))
[10:29:52.987]     }
[10:29:52.987]     if (FALSE) {
[10:29:52.987]     }
[10:29:52.987]     else {
[10:29:52.987]         if (TRUE) {
[10:29:52.987]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:52.987]                 open = "w")
[10:29:52.987]         }
[10:29:52.987]         else {
[10:29:52.987]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:52.987]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:52.987]         }
[10:29:52.987]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:52.987]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:52.987]             base::sink(type = "output", split = FALSE)
[10:29:52.987]             base::close(...future.stdout)
[10:29:52.987]         }, add = TRUE)
[10:29:52.987]     }
[10:29:52.987]     ...future.frame <- base::sys.nframe()
[10:29:52.987]     ...future.conditions <- base::list()
[10:29:52.987]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:52.987]     if (FALSE) {
[10:29:52.987]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:52.987]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:52.987]     }
[10:29:52.987]     ...future.result <- base::tryCatch({
[10:29:52.987]         base::withCallingHandlers({
[10:29:52.987]             ...future.value <- base::withVisible(base::local({
[10:29:52.987]                 do.call(function(...) {
[10:29:52.987]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:52.987]                   if (!identical(...future.globals.maxSize.org, 
[10:29:52.987]                     ...future.globals.maxSize)) {
[10:29:52.987]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:52.987]                     on.exit(options(oopts), add = TRUE)
[10:29:52.987]                   }
[10:29:52.987]                   {
[10:29:52.987]                     lapply(seq_along(...future.elements_ii), 
[10:29:52.987]                       FUN = function(jj) {
[10:29:52.987]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:52.987]                         ...future.FUN(...future.X_jj, ...)
[10:29:52.987]                       })
[10:29:52.987]                   }
[10:29:52.987]                 }, args = future.call.arguments)
[10:29:52.987]             }))
[10:29:52.987]             future::FutureResult(value = ...future.value$value, 
[10:29:52.987]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:52.987]                   ...future.rng), globalenv = if (FALSE) 
[10:29:52.987]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:52.987]                     ...future.globalenv.names))
[10:29:52.987]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:52.987]         }, condition = base::local({
[10:29:52.987]             c <- base::c
[10:29:52.987]             inherits <- base::inherits
[10:29:52.987]             invokeRestart <- base::invokeRestart
[10:29:52.987]             length <- base::length
[10:29:52.987]             list <- base::list
[10:29:52.987]             seq.int <- base::seq.int
[10:29:52.987]             signalCondition <- base::signalCondition
[10:29:52.987]             sys.calls <- base::sys.calls
[10:29:52.987]             `[[` <- base::`[[`
[10:29:52.987]             `+` <- base::`+`
[10:29:52.987]             `<<-` <- base::`<<-`
[10:29:52.987]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:52.987]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:52.987]                   3L)]
[10:29:52.987]             }
[10:29:52.987]             function(cond) {
[10:29:52.987]                 is_error <- inherits(cond, "error")
[10:29:52.987]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:52.987]                   NULL)
[10:29:52.987]                 if (is_error) {
[10:29:52.987]                   sessionInformation <- function() {
[10:29:52.987]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:52.987]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:52.987]                       search = base::search(), system = base::Sys.info())
[10:29:52.987]                   }
[10:29:52.987]                   ...future.conditions[[length(...future.conditions) + 
[10:29:52.987]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:52.987]                     cond$call), session = sessionInformation(), 
[10:29:52.987]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:52.987]                   signalCondition(cond)
[10:29:52.987]                 }
[10:29:52.987]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:52.987]                 "immediateCondition"))) {
[10:29:52.987]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:52.987]                   ...future.conditions[[length(...future.conditions) + 
[10:29:52.987]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:52.987]                   if (TRUE && !signal) {
[10:29:52.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:52.987]                     {
[10:29:52.987]                       inherits <- base::inherits
[10:29:52.987]                       invokeRestart <- base::invokeRestart
[10:29:52.987]                       is.null <- base::is.null
[10:29:52.987]                       muffled <- FALSE
[10:29:52.987]                       if (inherits(cond, "message")) {
[10:29:52.987]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:52.987]                         if (muffled) 
[10:29:52.987]                           invokeRestart("muffleMessage")
[10:29:52.987]                       }
[10:29:52.987]                       else if (inherits(cond, "warning")) {
[10:29:52.987]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:52.987]                         if (muffled) 
[10:29:52.987]                           invokeRestart("muffleWarning")
[10:29:52.987]                       }
[10:29:52.987]                       else if (inherits(cond, "condition")) {
[10:29:52.987]                         if (!is.null(pattern)) {
[10:29:52.987]                           computeRestarts <- base::computeRestarts
[10:29:52.987]                           grepl <- base::grepl
[10:29:52.987]                           restarts <- computeRestarts(cond)
[10:29:52.987]                           for (restart in restarts) {
[10:29:52.987]                             name <- restart$name
[10:29:52.987]                             if (is.null(name)) 
[10:29:52.987]                               next
[10:29:52.987]                             if (!grepl(pattern, name)) 
[10:29:52.987]                               next
[10:29:52.987]                             invokeRestart(restart)
[10:29:52.987]                             muffled <- TRUE
[10:29:52.987]                             break
[10:29:52.987]                           }
[10:29:52.987]                         }
[10:29:52.987]                       }
[10:29:52.987]                       invisible(muffled)
[10:29:52.987]                     }
[10:29:52.987]                     muffleCondition(cond, pattern = "^muffle")
[10:29:52.987]                   }
[10:29:52.987]                 }
[10:29:52.987]                 else {
[10:29:52.987]                   if (TRUE) {
[10:29:52.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:52.987]                     {
[10:29:52.987]                       inherits <- base::inherits
[10:29:52.987]                       invokeRestart <- base::invokeRestart
[10:29:52.987]                       is.null <- base::is.null
[10:29:52.987]                       muffled <- FALSE
[10:29:52.987]                       if (inherits(cond, "message")) {
[10:29:52.987]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:52.987]                         if (muffled) 
[10:29:52.987]                           invokeRestart("muffleMessage")
[10:29:52.987]                       }
[10:29:52.987]                       else if (inherits(cond, "warning")) {
[10:29:52.987]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:52.987]                         if (muffled) 
[10:29:52.987]                           invokeRestart("muffleWarning")
[10:29:52.987]                       }
[10:29:52.987]                       else if (inherits(cond, "condition")) {
[10:29:52.987]                         if (!is.null(pattern)) {
[10:29:52.987]                           computeRestarts <- base::computeRestarts
[10:29:52.987]                           grepl <- base::grepl
[10:29:52.987]                           restarts <- computeRestarts(cond)
[10:29:52.987]                           for (restart in restarts) {
[10:29:52.987]                             name <- restart$name
[10:29:52.987]                             if (is.null(name)) 
[10:29:52.987]                               next
[10:29:52.987]                             if (!grepl(pattern, name)) 
[10:29:52.987]                               next
[10:29:52.987]                             invokeRestart(restart)
[10:29:52.987]                             muffled <- TRUE
[10:29:52.987]                             break
[10:29:52.987]                           }
[10:29:52.987]                         }
[10:29:52.987]                       }
[10:29:52.987]                       invisible(muffled)
[10:29:52.987]                     }
[10:29:52.987]                     muffleCondition(cond, pattern = "^muffle")
[10:29:52.987]                   }
[10:29:52.987]                 }
[10:29:52.987]             }
[10:29:52.987]         }))
[10:29:52.987]     }, error = function(ex) {
[10:29:52.987]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:52.987]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:52.987]                 ...future.rng), started = ...future.startTime, 
[10:29:52.987]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:52.987]             version = "1.8"), class = "FutureResult")
[10:29:52.987]     }, finally = {
[10:29:52.987]         if (!identical(...future.workdir, getwd())) 
[10:29:52.987]             setwd(...future.workdir)
[10:29:52.987]         {
[10:29:52.987]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:52.987]                 ...future.oldOptions$nwarnings <- NULL
[10:29:52.987]             }
[10:29:52.987]             base::options(...future.oldOptions)
[10:29:52.987]             if (.Platform$OS.type == "windows") {
[10:29:52.987]                 old_names <- names(...future.oldEnvVars)
[10:29:52.987]                 envs <- base::Sys.getenv()
[10:29:52.987]                 names <- names(envs)
[10:29:52.987]                 common <- intersect(names, old_names)
[10:29:52.987]                 added <- setdiff(names, old_names)
[10:29:52.987]                 removed <- setdiff(old_names, names)
[10:29:52.987]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:52.987]                   envs[common]]
[10:29:52.987]                 NAMES <- toupper(changed)
[10:29:52.987]                 args <- list()
[10:29:52.987]                 for (kk in seq_along(NAMES)) {
[10:29:52.987]                   name <- changed[[kk]]
[10:29:52.987]                   NAME <- NAMES[[kk]]
[10:29:52.987]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:52.987]                     next
[10:29:52.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:52.987]                 }
[10:29:52.987]                 NAMES <- toupper(added)
[10:29:52.987]                 for (kk in seq_along(NAMES)) {
[10:29:52.987]                   name <- added[[kk]]
[10:29:52.987]                   NAME <- NAMES[[kk]]
[10:29:52.987]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:52.987]                     next
[10:29:52.987]                   args[[name]] <- ""
[10:29:52.987]                 }
[10:29:52.987]                 NAMES <- toupper(removed)
[10:29:52.987]                 for (kk in seq_along(NAMES)) {
[10:29:52.987]                   name <- removed[[kk]]
[10:29:52.987]                   NAME <- NAMES[[kk]]
[10:29:52.987]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:52.987]                     next
[10:29:52.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:52.987]                 }
[10:29:52.987]                 if (length(args) > 0) 
[10:29:52.987]                   base::do.call(base::Sys.setenv, args = args)
[10:29:52.987]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:52.987]             }
[10:29:52.987]             else {
[10:29:52.987]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:52.987]             }
[10:29:52.987]             {
[10:29:52.987]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:52.987]                   0L) {
[10:29:52.987]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:52.987]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:52.987]                   base::options(opts)
[10:29:52.987]                 }
[10:29:52.987]                 {
[10:29:52.987]                   {
[10:29:52.987]                     NULL
[10:29:52.987]                     RNGkind("Mersenne-Twister")
[10:29:52.987]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:52.987]                       inherits = FALSE)
[10:29:52.987]                   }
[10:29:52.987]                   options(future.plan = NULL)
[10:29:52.987]                   if (is.na(NA_character_)) 
[10:29:52.987]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:52.987]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:52.987]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:52.987]                     .init = FALSE)
[10:29:52.987]                 }
[10:29:52.987]             }
[10:29:52.987]         }
[10:29:52.987]     })
[10:29:52.987]     if (TRUE) {
[10:29:52.987]         base::sink(type = "output", split = FALSE)
[10:29:52.987]         if (TRUE) {
[10:29:52.987]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:52.987]         }
[10:29:52.987]         else {
[10:29:52.987]             ...future.result["stdout"] <- base::list(NULL)
[10:29:52.987]         }
[10:29:52.987]         base::close(...future.stdout)
[10:29:52.987]         ...future.stdout <- NULL
[10:29:52.987]     }
[10:29:52.987]     ...future.result$conditions <- ...future.conditions
[10:29:52.987]     ...future.result$finished <- base::Sys.time()
[10:29:52.987]     ...future.result
[10:29:52.987] }
[10:29:52.988] assign_globals() ...
[10:29:52.989] List of 5
[10:29:52.989]  $ ...future.FUN            :function (object, ...)  
[10:29:52.989]  $ future.call.arguments    : list()
[10:29:52.989]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:52.989]  $ ...future.elements_ii    :List of 3
[10:29:52.989]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:29:52.989]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:29:52.989]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:52.989]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:29:52.989]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:29:52.989]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:52.989]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:29:52.989]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:29:52.989]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:52.989]  $ ...future.seeds_ii       : NULL
[10:29:52.989]  $ ...future.globals.maxSize: NULL
[10:29:52.989]  - attr(*, "where")=List of 5
[10:29:52.989]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:52.989]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:52.989]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:52.989]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:52.989]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:52.989]  - attr(*, "resolved")= logi FALSE
[10:29:52.989]  - attr(*, "total_size")= num 1240
[10:29:52.989]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:52.989]  - attr(*, "already-done")= logi TRUE
[10:29:52.996] - copied ‘...future.FUN’ to environment
[10:29:52.996] - copied ‘future.call.arguments’ to environment
[10:29:52.996] - copied ‘...future.elements_ii’ to environment
[10:29:52.996] - copied ‘...future.seeds_ii’ to environment
[10:29:52.996] - copied ‘...future.globals.maxSize’ to environment
[10:29:52.996] assign_globals() ... done
[10:29:52.997] plan(): Setting new future strategy stack:
[10:29:52.997] List of future strategies:
[10:29:52.997] 1. sequential:
[10:29:52.997]    - args: function (..., envir = parent.frame())
[10:29:52.997]    - tweaked: FALSE
[10:29:52.997]    - call: NULL
[10:29:52.997] plan(): nbrOfWorkers() = 1
[10:29:52.999] plan(): Setting new future strategy stack:
[10:29:53.000] List of future strategies:
[10:29:53.000] 1. sequential:
[10:29:53.000]    - args: function (..., envir = parent.frame())
[10:29:53.000]    - tweaked: FALSE
[10:29:53.000]    - call: plan(strategy)
[10:29:53.000] plan(): nbrOfWorkers() = 1
[10:29:53.000] SequentialFuture started (and completed)
[10:29:53.001] - Launch lazy future ... done
[10:29:53.001] run() for ‘SequentialFuture’ ... done
[10:29:53.001] Created future:
[10:29:53.001] SequentialFuture:
[10:29:53.001] Label: ‘future_by-1’
[10:29:53.001] Expression:
[10:29:53.001] {
[10:29:53.001]     do.call(function(...) {
[10:29:53.001]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.001]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.001]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.001]             on.exit(options(oopts), add = TRUE)
[10:29:53.001]         }
[10:29:53.001]         {
[10:29:53.001]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.001]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.001]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.001]             })
[10:29:53.001]         }
[10:29:53.001]     }, args = future.call.arguments)
[10:29:53.001] }
[10:29:53.001] Lazy evaluation: FALSE
[10:29:53.001] Asynchronous evaluation: FALSE
[10:29:53.001] Local evaluation: TRUE
[10:29:53.001] Environment: R_GlobalEnv
[10:29:53.001] Capture standard output: TRUE
[10:29:53.001] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:53.001] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:53.001] Packages: <none>
[10:29:53.001] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:53.001] Resolved: TRUE
[10:29:53.001] Value: 4.62 KiB of class ‘list’
[10:29:53.001] Early signaling: FALSE
[10:29:53.001] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:53.001] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.003] Chunk #1 of 1 ... DONE
[10:29:53.003] Launching 1 futures (chunks) ... DONE
[10:29:53.003] Resolving 1 futures (chunks) ...
[10:29:53.003] resolve() on list ...
[10:29:53.003]  recursive: 0
[10:29:53.003]  length: 1
[10:29:53.003] 
[10:29:53.003] resolved() for ‘SequentialFuture’ ...
[10:29:53.004] - state: ‘finished’
[10:29:53.004] - run: TRUE
[10:29:53.004] - result: ‘FutureResult’
[10:29:53.004] resolved() for ‘SequentialFuture’ ... done
[10:29:53.004] Future #1
[10:29:53.004] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:53.004] - nx: 1
[10:29:53.004] - relay: TRUE
[10:29:53.005] - stdout: TRUE
[10:29:53.005] - signal: TRUE
[10:29:53.005] - resignal: FALSE
[10:29:53.005] - force: TRUE
[10:29:53.005] - relayed: [n=1] FALSE
[10:29:53.005] - queued futures: [n=1] FALSE
[10:29:53.005]  - until=1
[10:29:53.005]  - relaying element #1
[10:29:53.005] - relayed: [n=1] TRUE
[10:29:53.005] - queued futures: [n=1] TRUE
[10:29:53.006] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:53.006]  length: 0 (resolved future 1)
[10:29:53.006] Relaying remaining futures
[10:29:53.006] signalConditionsASAP(NULL, pos=0) ...
[10:29:53.006] - nx: 1
[10:29:53.006] - relay: TRUE
[10:29:53.006] - stdout: TRUE
[10:29:53.006] - signal: TRUE
[10:29:53.006] - resignal: FALSE
[10:29:53.006] - force: TRUE
[10:29:53.007] - relayed: [n=1] TRUE
[10:29:53.007] - queued futures: [n=1] TRUE
 - flush all
[10:29:53.007] - relayed: [n=1] TRUE
[10:29:53.007] - queued futures: [n=1] TRUE
[10:29:53.007] signalConditionsASAP(NULL, pos=0) ... done
[10:29:53.007] resolve() on list ... DONE
[10:29:53.007]  - Number of value chunks collected: 1
[10:29:53.007] Resolving 1 futures (chunks) ... DONE
[10:29:53.007] Reducing values from 1 chunks ...
[10:29:53.007]  - Number of values collected after concatenation: 3
[10:29:53.008]  - Number of values expected: 3
[10:29:53.008] Reducing values from 1 chunks ... DONE
[10:29:53.009] future_lapply() ... DONE
[10:29:53.009] future_by_internal() ... DONE
[10:29:53.010] future_by_internal() ...
[10:29:53.011] future_lapply() ...
[10:29:53.011] Number of chunks: 1
[10:29:53.011] getGlobalsAndPackagesXApply() ...
[10:29:53.011]  - future.globals: TRUE
[10:29:53.011] getGlobalsAndPackages() ...
[10:29:53.011] Searching for globals...
[10:29:53.012] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:53.013] Searching for globals ... DONE
[10:29:53.013] Resolving globals: FALSE
[10:29:53.013] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:53.013] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:53.013] - globals: [1] ‘FUN’
[10:29:53.014] 
[10:29:53.014] getGlobalsAndPackages() ... DONE
[10:29:53.014]  - globals found/used: [n=1] ‘FUN’
[10:29:53.014]  - needed namespaces: [n=0] 
[10:29:53.014] Finding globals ... DONE
[10:29:53.014]  - use_args: TRUE
[10:29:53.014]  - Getting '...' globals ...
[10:29:53.014] resolve() on list ...
[10:29:53.014]  recursive: 0
[10:29:53.015]  length: 1
[10:29:53.015]  elements: ‘...’
[10:29:53.015]  length: 0 (resolved future 1)
[10:29:53.015] resolve() on list ... DONE
[10:29:53.015]    - '...' content: [n=1] ‘digits’
[10:29:53.015] List of 1
[10:29:53.015]  $ ...:List of 1
[10:29:53.015]   ..$ digits: int 2
[10:29:53.015]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.015]  - attr(*, "where")=List of 1
[10:29:53.015]   ..$ ...:<environment: 0x556dd44794d8> 
[10:29:53.015]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.015]  - attr(*, "resolved")= logi TRUE
[10:29:53.015]  - attr(*, "total_size")= num NA
[10:29:53.018]  - Getting '...' globals ... DONE
[10:29:53.018] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:53.018] List of 2
[10:29:53.018]  $ ...future.FUN:function (object, ...)  
[10:29:53.018]  $ ...          :List of 1
[10:29:53.018]   ..$ digits: int 2
[10:29:53.018]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.018]  - attr(*, "where")=List of 2
[10:29:53.018]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:53.018]   ..$ ...          :<environment: 0x556dd44794d8> 
[10:29:53.018]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.018]  - attr(*, "resolved")= logi FALSE
[10:29:53.018]  - attr(*, "total_size")= num 1296
[10:29:53.021] Packages to be attached in all futures: [n=0] 
[10:29:53.021] getGlobalsAndPackagesXApply() ... DONE
[10:29:53.021] Number of futures (= number of chunks): 1
[10:29:53.022] Launching 1 futures (chunks) ...
[10:29:53.022] Chunk #1 of 1 ...
[10:29:53.022]  - Finding globals in 'X' for chunk #1 ...
[10:29:53.022] getGlobalsAndPackages() ...
[10:29:53.022] Searching for globals...
[10:29:53.022] 
[10:29:53.022] Searching for globals ... DONE
[10:29:53.022] - globals: [0] <none>
[10:29:53.022] getGlobalsAndPackages() ... DONE
[10:29:53.022]    + additional globals found: [n=0] 
[10:29:53.023]    + additional namespaces needed: [n=0] 
[10:29:53.023]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:53.023]  - seeds: <none>
[10:29:53.023]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.023] getGlobalsAndPackages() ...
[10:29:53.023] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.023] Resolving globals: FALSE
[10:29:53.023] Tweak future expression to call with '...' arguments ...
[10:29:53.023] {
[10:29:53.023]     do.call(function(...) {
[10:29:53.023]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.023]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.023]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.023]             on.exit(options(oopts), add = TRUE)
[10:29:53.023]         }
[10:29:53.023]         {
[10:29:53.023]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.023]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.023]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.023]             })
[10:29:53.023]         }
[10:29:53.023]     }, args = future.call.arguments)
[10:29:53.023] }
[10:29:53.024] Tweak future expression to call with '...' arguments ... DONE
[10:29:53.024] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.024] 
[10:29:53.024] getGlobalsAndPackages() ... DONE
[10:29:53.024] run() for ‘Future’ ...
[10:29:53.025] - state: ‘created’
[10:29:53.025] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:29:53.025] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.025] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:53.025]   - Field: ‘label’
[10:29:53.025]   - Field: ‘local’
[10:29:53.025]   - Field: ‘owner’
[10:29:53.025]   - Field: ‘envir’
[10:29:53.026]   - Field: ‘packages’
[10:29:53.026]   - Field: ‘gc’
[10:29:53.026]   - Field: ‘conditions’
[10:29:53.026]   - Field: ‘expr’
[10:29:53.026]   - Field: ‘uuid’
[10:29:53.026]   - Field: ‘seed’
[10:29:53.026]   - Field: ‘version’
[10:29:53.026]   - Field: ‘result’
[10:29:53.026]   - Field: ‘asynchronous’
[10:29:53.026]   - Field: ‘calls’
[10:29:53.026]   - Field: ‘globals’
[10:29:53.027]   - Field: ‘stdout’
[10:29:53.027]   - Field: ‘earlySignal’
[10:29:53.027]   - Field: ‘lazy’
[10:29:53.027]   - Field: ‘state’
[10:29:53.027] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:53.027] - Launch lazy future ...
[10:29:53.027] Packages needed by the future expression (n = 0): <none>
[10:29:53.027] Packages needed by future strategies (n = 0): <none>
[10:29:53.028] {
[10:29:53.028]     {
[10:29:53.028]         {
[10:29:53.028]             ...future.startTime <- base::Sys.time()
[10:29:53.028]             {
[10:29:53.028]                 {
[10:29:53.028]                   {
[10:29:53.028]                     base::local({
[10:29:53.028]                       has_future <- base::requireNamespace("future", 
[10:29:53.028]                         quietly = TRUE)
[10:29:53.028]                       if (has_future) {
[10:29:53.028]                         ns <- base::getNamespace("future")
[10:29:53.028]                         version <- ns[[".package"]][["version"]]
[10:29:53.028]                         if (is.null(version)) 
[10:29:53.028]                           version <- utils::packageVersion("future")
[10:29:53.028]                       }
[10:29:53.028]                       else {
[10:29:53.028]                         version <- NULL
[10:29:53.028]                       }
[10:29:53.028]                       if (!has_future || version < "1.8.0") {
[10:29:53.028]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:53.028]                           "", base::R.version$version.string), 
[10:29:53.028]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:53.028]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:53.028]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:53.028]                             "release", "version")], collapse = " "), 
[10:29:53.028]                           hostname = base::Sys.info()[["nodename"]])
[10:29:53.028]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:53.028]                           info)
[10:29:53.028]                         info <- base::paste(info, collapse = "; ")
[10:29:53.028]                         if (!has_future) {
[10:29:53.028]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:53.028]                             info)
[10:29:53.028]                         }
[10:29:53.028]                         else {
[10:29:53.028]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:53.028]                             info, version)
[10:29:53.028]                         }
[10:29:53.028]                         base::stop(msg)
[10:29:53.028]                       }
[10:29:53.028]                     })
[10:29:53.028]                   }
[10:29:53.028]                   ...future.strategy.old <- future::plan("list")
[10:29:53.028]                   options(future.plan = NULL)
[10:29:53.028]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.028]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:53.028]                 }
[10:29:53.028]                 ...future.workdir <- getwd()
[10:29:53.028]             }
[10:29:53.028]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:53.028]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:53.028]         }
[10:29:53.028]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:53.028]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:53.028]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:53.028]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:53.028]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:53.028]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:53.028]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:53.028]             base::names(...future.oldOptions))
[10:29:53.028]     }
[10:29:53.028]     if (FALSE) {
[10:29:53.028]     }
[10:29:53.028]     else {
[10:29:53.028]         if (TRUE) {
[10:29:53.028]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:53.028]                 open = "w")
[10:29:53.028]         }
[10:29:53.028]         else {
[10:29:53.028]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:53.028]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:53.028]         }
[10:29:53.028]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:53.028]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:53.028]             base::sink(type = "output", split = FALSE)
[10:29:53.028]             base::close(...future.stdout)
[10:29:53.028]         }, add = TRUE)
[10:29:53.028]     }
[10:29:53.028]     ...future.frame <- base::sys.nframe()
[10:29:53.028]     ...future.conditions <- base::list()
[10:29:53.028]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:53.028]     if (FALSE) {
[10:29:53.028]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:53.028]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:53.028]     }
[10:29:53.028]     ...future.result <- base::tryCatch({
[10:29:53.028]         base::withCallingHandlers({
[10:29:53.028]             ...future.value <- base::withVisible(base::local({
[10:29:53.028]                 do.call(function(...) {
[10:29:53.028]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.028]                   if (!identical(...future.globals.maxSize.org, 
[10:29:53.028]                     ...future.globals.maxSize)) {
[10:29:53.028]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.028]                     on.exit(options(oopts), add = TRUE)
[10:29:53.028]                   }
[10:29:53.028]                   {
[10:29:53.028]                     lapply(seq_along(...future.elements_ii), 
[10:29:53.028]                       FUN = function(jj) {
[10:29:53.028]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.028]                         ...future.FUN(...future.X_jj, ...)
[10:29:53.028]                       })
[10:29:53.028]                   }
[10:29:53.028]                 }, args = future.call.arguments)
[10:29:53.028]             }))
[10:29:53.028]             future::FutureResult(value = ...future.value$value, 
[10:29:53.028]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.028]                   ...future.rng), globalenv = if (FALSE) 
[10:29:53.028]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:53.028]                     ...future.globalenv.names))
[10:29:53.028]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:53.028]         }, condition = base::local({
[10:29:53.028]             c <- base::c
[10:29:53.028]             inherits <- base::inherits
[10:29:53.028]             invokeRestart <- base::invokeRestart
[10:29:53.028]             length <- base::length
[10:29:53.028]             list <- base::list
[10:29:53.028]             seq.int <- base::seq.int
[10:29:53.028]             signalCondition <- base::signalCondition
[10:29:53.028]             sys.calls <- base::sys.calls
[10:29:53.028]             `[[` <- base::`[[`
[10:29:53.028]             `+` <- base::`+`
[10:29:53.028]             `<<-` <- base::`<<-`
[10:29:53.028]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:53.028]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:53.028]                   3L)]
[10:29:53.028]             }
[10:29:53.028]             function(cond) {
[10:29:53.028]                 is_error <- inherits(cond, "error")
[10:29:53.028]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:53.028]                   NULL)
[10:29:53.028]                 if (is_error) {
[10:29:53.028]                   sessionInformation <- function() {
[10:29:53.028]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:53.028]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:53.028]                       search = base::search(), system = base::Sys.info())
[10:29:53.028]                   }
[10:29:53.028]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.028]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:53.028]                     cond$call), session = sessionInformation(), 
[10:29:53.028]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:53.028]                   signalCondition(cond)
[10:29:53.028]                 }
[10:29:53.028]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:53.028]                 "immediateCondition"))) {
[10:29:53.028]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:53.028]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.028]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:53.028]                   if (TRUE && !signal) {
[10:29:53.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.028]                     {
[10:29:53.028]                       inherits <- base::inherits
[10:29:53.028]                       invokeRestart <- base::invokeRestart
[10:29:53.028]                       is.null <- base::is.null
[10:29:53.028]                       muffled <- FALSE
[10:29:53.028]                       if (inherits(cond, "message")) {
[10:29:53.028]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.028]                         if (muffled) 
[10:29:53.028]                           invokeRestart("muffleMessage")
[10:29:53.028]                       }
[10:29:53.028]                       else if (inherits(cond, "warning")) {
[10:29:53.028]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.028]                         if (muffled) 
[10:29:53.028]                           invokeRestart("muffleWarning")
[10:29:53.028]                       }
[10:29:53.028]                       else if (inherits(cond, "condition")) {
[10:29:53.028]                         if (!is.null(pattern)) {
[10:29:53.028]                           computeRestarts <- base::computeRestarts
[10:29:53.028]                           grepl <- base::grepl
[10:29:53.028]                           restarts <- computeRestarts(cond)
[10:29:53.028]                           for (restart in restarts) {
[10:29:53.028]                             name <- restart$name
[10:29:53.028]                             if (is.null(name)) 
[10:29:53.028]                               next
[10:29:53.028]                             if (!grepl(pattern, name)) 
[10:29:53.028]                               next
[10:29:53.028]                             invokeRestart(restart)
[10:29:53.028]                             muffled <- TRUE
[10:29:53.028]                             break
[10:29:53.028]                           }
[10:29:53.028]                         }
[10:29:53.028]                       }
[10:29:53.028]                       invisible(muffled)
[10:29:53.028]                     }
[10:29:53.028]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.028]                   }
[10:29:53.028]                 }
[10:29:53.028]                 else {
[10:29:53.028]                   if (TRUE) {
[10:29:53.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.028]                     {
[10:29:53.028]                       inherits <- base::inherits
[10:29:53.028]                       invokeRestart <- base::invokeRestart
[10:29:53.028]                       is.null <- base::is.null
[10:29:53.028]                       muffled <- FALSE
[10:29:53.028]                       if (inherits(cond, "message")) {
[10:29:53.028]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.028]                         if (muffled) 
[10:29:53.028]                           invokeRestart("muffleMessage")
[10:29:53.028]                       }
[10:29:53.028]                       else if (inherits(cond, "warning")) {
[10:29:53.028]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.028]                         if (muffled) 
[10:29:53.028]                           invokeRestart("muffleWarning")
[10:29:53.028]                       }
[10:29:53.028]                       else if (inherits(cond, "condition")) {
[10:29:53.028]                         if (!is.null(pattern)) {
[10:29:53.028]                           computeRestarts <- base::computeRestarts
[10:29:53.028]                           grepl <- base::grepl
[10:29:53.028]                           restarts <- computeRestarts(cond)
[10:29:53.028]                           for (restart in restarts) {
[10:29:53.028]                             name <- restart$name
[10:29:53.028]                             if (is.null(name)) 
[10:29:53.028]                               next
[10:29:53.028]                             if (!grepl(pattern, name)) 
[10:29:53.028]                               next
[10:29:53.028]                             invokeRestart(restart)
[10:29:53.028]                             muffled <- TRUE
[10:29:53.028]                             break
[10:29:53.028]                           }
[10:29:53.028]                         }
[10:29:53.028]                       }
[10:29:53.028]                       invisible(muffled)
[10:29:53.028]                     }
[10:29:53.028]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.028]                   }
[10:29:53.028]                 }
[10:29:53.028]             }
[10:29:53.028]         }))
[10:29:53.028]     }, error = function(ex) {
[10:29:53.028]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:53.028]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.028]                 ...future.rng), started = ...future.startTime, 
[10:29:53.028]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:53.028]             version = "1.8"), class = "FutureResult")
[10:29:53.028]     }, finally = {
[10:29:53.028]         if (!identical(...future.workdir, getwd())) 
[10:29:53.028]             setwd(...future.workdir)
[10:29:53.028]         {
[10:29:53.028]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:53.028]                 ...future.oldOptions$nwarnings <- NULL
[10:29:53.028]             }
[10:29:53.028]             base::options(...future.oldOptions)
[10:29:53.028]             if (.Platform$OS.type == "windows") {
[10:29:53.028]                 old_names <- names(...future.oldEnvVars)
[10:29:53.028]                 envs <- base::Sys.getenv()
[10:29:53.028]                 names <- names(envs)
[10:29:53.028]                 common <- intersect(names, old_names)
[10:29:53.028]                 added <- setdiff(names, old_names)
[10:29:53.028]                 removed <- setdiff(old_names, names)
[10:29:53.028]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:53.028]                   envs[common]]
[10:29:53.028]                 NAMES <- toupper(changed)
[10:29:53.028]                 args <- list()
[10:29:53.028]                 for (kk in seq_along(NAMES)) {
[10:29:53.028]                   name <- changed[[kk]]
[10:29:53.028]                   NAME <- NAMES[[kk]]
[10:29:53.028]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.028]                     next
[10:29:53.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.028]                 }
[10:29:53.028]                 NAMES <- toupper(added)
[10:29:53.028]                 for (kk in seq_along(NAMES)) {
[10:29:53.028]                   name <- added[[kk]]
[10:29:53.028]                   NAME <- NAMES[[kk]]
[10:29:53.028]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.028]                     next
[10:29:53.028]                   args[[name]] <- ""
[10:29:53.028]                 }
[10:29:53.028]                 NAMES <- toupper(removed)
[10:29:53.028]                 for (kk in seq_along(NAMES)) {
[10:29:53.028]                   name <- removed[[kk]]
[10:29:53.028]                   NAME <- NAMES[[kk]]
[10:29:53.028]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.028]                     next
[10:29:53.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.028]                 }
[10:29:53.028]                 if (length(args) > 0) 
[10:29:53.028]                   base::do.call(base::Sys.setenv, args = args)
[10:29:53.028]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:53.028]             }
[10:29:53.028]             else {
[10:29:53.028]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:53.028]             }
[10:29:53.028]             {
[10:29:53.028]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:53.028]                   0L) {
[10:29:53.028]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:53.028]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:53.028]                   base::options(opts)
[10:29:53.028]                 }
[10:29:53.028]                 {
[10:29:53.028]                   {
[10:29:53.028]                     NULL
[10:29:53.028]                     RNGkind("Mersenne-Twister")
[10:29:53.028]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:53.028]                       inherits = FALSE)
[10:29:53.028]                   }
[10:29:53.028]                   options(future.plan = NULL)
[10:29:53.028]                   if (is.na(NA_character_)) 
[10:29:53.028]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.028]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:53.028]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:53.028]                     .init = FALSE)
[10:29:53.028]                 }
[10:29:53.028]             }
[10:29:53.028]         }
[10:29:53.028]     })
[10:29:53.028]     if (TRUE) {
[10:29:53.028]         base::sink(type = "output", split = FALSE)
[10:29:53.028]         if (TRUE) {
[10:29:53.028]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:53.028]         }
[10:29:53.028]         else {
[10:29:53.028]             ...future.result["stdout"] <- base::list(NULL)
[10:29:53.028]         }
[10:29:53.028]         base::close(...future.stdout)
[10:29:53.028]         ...future.stdout <- NULL
[10:29:53.028]     }
[10:29:53.028]     ...future.result$conditions <- ...future.conditions
[10:29:53.028]     ...future.result$finished <- base::Sys.time()
[10:29:53.028]     ...future.result
[10:29:53.028] }
[10:29:53.029] assign_globals() ...
[10:29:53.029] List of 5
[10:29:53.029]  $ ...future.FUN            :function (object, ...)  
[10:29:53.029]  $ future.call.arguments    :List of 1
[10:29:53.029]   ..$ digits: int 2
[10:29:53.029]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.029]  $ ...future.elements_ii    :List of 6
[10:29:53.029]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[10:29:53.029]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[10:29:53.029]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[10:29:53.029]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[10:29:53.029]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[10:29:53.029]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[10:29:53.029]  $ ...future.seeds_ii       : NULL
[10:29:53.029]  $ ...future.globals.maxSize: NULL
[10:29:53.029]  - attr(*, "where")=List of 5
[10:29:53.029]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:53.029]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:53.029]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:53.029]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:53.029]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:53.029]  - attr(*, "resolved")= logi FALSE
[10:29:53.029]  - attr(*, "total_size")= num 1296
[10:29:53.029]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.029]  - attr(*, "already-done")= logi TRUE
[10:29:53.038] - copied ‘...future.FUN’ to environment
[10:29:53.038] - copied ‘future.call.arguments’ to environment
[10:29:53.038] - copied ‘...future.elements_ii’ to environment
[10:29:53.038] - copied ‘...future.seeds_ii’ to environment
[10:29:53.038] - copied ‘...future.globals.maxSize’ to environment
[10:29:53.038] assign_globals() ... done
[10:29:53.039] plan(): Setting new future strategy stack:
[10:29:53.039] List of future strategies:
[10:29:53.039] 1. sequential:
[10:29:53.039]    - args: function (..., envir = parent.frame())
[10:29:53.039]    - tweaked: FALSE
[10:29:53.039]    - call: NULL
[10:29:53.039] plan(): nbrOfWorkers() = 1
[10:29:53.040] plan(): Setting new future strategy stack:
[10:29:53.040] List of future strategies:
[10:29:53.040] 1. sequential:
[10:29:53.040]    - args: function (..., envir = parent.frame())
[10:29:53.040]    - tweaked: FALSE
[10:29:53.040]    - call: plan(strategy)
[10:29:53.041] plan(): nbrOfWorkers() = 1
[10:29:53.041] SequentialFuture started (and completed)
[10:29:53.041] - Launch lazy future ... done
[10:29:53.041] run() for ‘SequentialFuture’ ... done
[10:29:53.041] Created future:
[10:29:53.041] SequentialFuture:
[10:29:53.041] Label: ‘future_by-1’
[10:29:53.041] Expression:
[10:29:53.041] {
[10:29:53.041]     do.call(function(...) {
[10:29:53.041]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.041]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.041]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.041]             on.exit(options(oopts), add = TRUE)
[10:29:53.041]         }
[10:29:53.041]         {
[10:29:53.041]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.041]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.041]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.041]             })
[10:29:53.041]         }
[10:29:53.041]     }, args = future.call.arguments)
[10:29:53.041] }
[10:29:53.041] Lazy evaluation: FALSE
[10:29:53.041] Asynchronous evaluation: FALSE
[10:29:53.041] Local evaluation: TRUE
[10:29:53.041] Environment: R_GlobalEnv
[10:29:53.041] Capture standard output: TRUE
[10:29:53.041] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:53.041] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:53.041] Packages: <none>
[10:29:53.041] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:53.041] Resolved: TRUE
[10:29:53.041] Value: 5.48 KiB of class ‘list’
[10:29:53.041] Early signaling: FALSE
[10:29:53.041] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:53.041] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.042] Chunk #1 of 1 ... DONE
[10:29:53.043] Launching 1 futures (chunks) ... DONE
[10:29:53.043] Resolving 1 futures (chunks) ...
[10:29:53.043] resolve() on list ...
[10:29:53.043]  recursive: 0
[10:29:53.043]  length: 1
[10:29:53.043] 
[10:29:53.043] resolved() for ‘SequentialFuture’ ...
[10:29:53.043] - state: ‘finished’
[10:29:53.043] - run: TRUE
[10:29:53.043] - result: ‘FutureResult’
[10:29:53.044] resolved() for ‘SequentialFuture’ ... done
[10:29:53.044] Future #1
[10:29:53.044] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:53.044] - nx: 1
[10:29:53.044] - relay: TRUE
[10:29:53.044] - stdout: TRUE
[10:29:53.044] - signal: TRUE
[10:29:53.044] - resignal: FALSE
[10:29:53.044] - force: TRUE
[10:29:53.044] - relayed: [n=1] FALSE
[10:29:53.044] - queued futures: [n=1] FALSE
[10:29:53.045]  - until=1
[10:29:53.045]  - relaying element #1
[10:29:53.045] - relayed: [n=1] TRUE
[10:29:53.045] - queued futures: [n=1] TRUE
[10:29:53.045] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:53.045]  length: 0 (resolved future 1)
[10:29:53.045] Relaying remaining futures
[10:29:53.045] signalConditionsASAP(NULL, pos=0) ...
[10:29:53.045] - nx: 1
[10:29:53.045] - relay: TRUE
[10:29:53.046] - stdout: TRUE
[10:29:53.046] - signal: TRUE
[10:29:53.046] - resignal: FALSE
[10:29:53.046] - force: TRUE
[10:29:53.046] - relayed: [n=1] TRUE
[10:29:53.046] - queued futures: [n=1] TRUE
 - flush all
[10:29:53.046] - relayed: [n=1] TRUE
[10:29:53.046] - queued futures: [n=1] TRUE
[10:29:53.046] signalConditionsASAP(NULL, pos=0) ... done
[10:29:53.046] resolve() on list ... DONE
[10:29:53.047]  - Number of value chunks collected: 1
[10:29:53.047] Resolving 1 futures (chunks) ... DONE
[10:29:53.047] Reducing values from 1 chunks ...
[10:29:53.047]  - Number of values collected after concatenation: 6
[10:29:53.047]  - Number of values expected: 6
[10:29:53.047] Reducing values from 1 chunks ... DONE
[10:29:53.047] future_lapply() ... DONE
[10:29:53.047] future_by_internal() ... DONE
[10:29:53.050] future_by_internal() ...
[10:29:53.051] future_lapply() ...
[10:29:53.052] Number of chunks: 1
[10:29:53.053] getGlobalsAndPackagesXApply() ...
[10:29:53.053]  - future.globals: TRUE
[10:29:53.053] getGlobalsAndPackages() ...
[10:29:53.053] Searching for globals...
[10:29:53.055] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:29:53.055] Searching for globals ... DONE
[10:29:53.055] Resolving globals: FALSE
[10:29:53.056] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[10:29:53.056] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[10:29:53.056] - globals: [1] ‘FUN’
[10:29:53.056] - packages: [1] ‘stats’
[10:29:53.056] getGlobalsAndPackages() ... DONE
[10:29:53.056]  - globals found/used: [n=1] ‘FUN’
[10:29:53.057]  - needed namespaces: [n=1] ‘stats’
[10:29:53.057] Finding globals ... DONE
[10:29:53.057]  - use_args: TRUE
[10:29:53.057]  - Getting '...' globals ...
[10:29:53.057] resolve() on list ...
[10:29:53.057]  recursive: 0
[10:29:53.057]  length: 1
[10:29:53.057]  elements: ‘...’
[10:29:53.058]  length: 0 (resolved future 1)
[10:29:53.058] resolve() on list ... DONE
[10:29:53.058]    - '...' content: [n=1] ‘singular.ok’
[10:29:53.058] List of 1
[10:29:53.058]  $ ...:List of 1
[10:29:53.058]   ..$ singular.ok: logi FALSE
[10:29:53.058]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.058]  - attr(*, "where")=List of 1
[10:29:53.058]   ..$ ...:<environment: 0x556dd5567f50> 
[10:29:53.058]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.058]  - attr(*, "resolved")= logi TRUE
[10:29:53.058]  - attr(*, "total_size")= num NA
[10:29:53.061]  - Getting '...' globals ... DONE
[10:29:53.061] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:53.061] List of 2
[10:29:53.061]  $ ...future.FUN:function (x, ...)  
[10:29:53.061]  $ ...          :List of 1
[10:29:53.061]   ..$ singular.ok: logi FALSE
[10:29:53.061]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.061]  - attr(*, "where")=List of 2
[10:29:53.061]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:53.061]   ..$ ...          :<environment: 0x556dd5567f50> 
[10:29:53.061]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.061]  - attr(*, "resolved")= logi FALSE
[10:29:53.061]  - attr(*, "total_size")= num 5384
[10:29:53.064] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:53.064] getGlobalsAndPackagesXApply() ... DONE
[10:29:53.064] Number of futures (= number of chunks): 1
[10:29:53.064] Launching 1 futures (chunks) ...
[10:29:53.065] Chunk #1 of 1 ...
[10:29:53.065]  - Finding globals in 'X' for chunk #1 ...
[10:29:53.065] getGlobalsAndPackages() ...
[10:29:53.065] Searching for globals...
[10:29:53.065] 
[10:29:53.065] Searching for globals ... DONE
[10:29:53.066] - globals: [0] <none>
[10:29:53.066] getGlobalsAndPackages() ... DONE
[10:29:53.066]    + additional globals found: [n=0] 
[10:29:53.066]    + additional namespaces needed: [n=0] 
[10:29:53.066]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:53.066]  - seeds: <none>
[10:29:53.066]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.066] getGlobalsAndPackages() ...
[10:29:53.066] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.066] Resolving globals: FALSE
[10:29:53.067] Tweak future expression to call with '...' arguments ...
[10:29:53.067] {
[10:29:53.067]     do.call(function(...) {
[10:29:53.067]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.067]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.067]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.067]             on.exit(options(oopts), add = TRUE)
[10:29:53.067]         }
[10:29:53.067]         {
[10:29:53.067]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.067]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.067]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.067]             })
[10:29:53.067]         }
[10:29:53.067]     }, args = future.call.arguments)
[10:29:53.067] }
[10:29:53.067] Tweak future expression to call with '...' arguments ... DONE
[10:29:53.067] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.067] 
[10:29:53.067] getGlobalsAndPackages() ... DONE
[10:29:53.068] run() for ‘Future’ ...
[10:29:53.068] - state: ‘created’
[10:29:53.068] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:29:53.068] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.068] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:53.069]   - Field: ‘label’
[10:29:53.069]   - Field: ‘local’
[10:29:53.069]   - Field: ‘owner’
[10:29:53.069]   - Field: ‘envir’
[10:29:53.069]   - Field: ‘packages’
[10:29:53.069]   - Field: ‘gc’
[10:29:53.069]   - Field: ‘conditions’
[10:29:53.069]   - Field: ‘expr’
[10:29:53.069]   - Field: ‘uuid’
[10:29:53.069]   - Field: ‘seed’
[10:29:53.070]   - Field: ‘version’
[10:29:53.070]   - Field: ‘result’
[10:29:53.070]   - Field: ‘asynchronous’
[10:29:53.070]   - Field: ‘calls’
[10:29:53.070]   - Field: ‘globals’
[10:29:53.070]   - Field: ‘stdout’
[10:29:53.070]   - Field: ‘earlySignal’
[10:29:53.070]   - Field: ‘lazy’
[10:29:53.070]   - Field: ‘state’
[10:29:53.070] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:53.071] - Launch lazy future ...
[10:29:53.071] Packages needed by the future expression (n = 1): ‘stats’
[10:29:53.071] Packages needed by future strategies (n = 0): <none>
[10:29:53.071] {
[10:29:53.071]     {
[10:29:53.071]         {
[10:29:53.071]             ...future.startTime <- base::Sys.time()
[10:29:53.071]             {
[10:29:53.071]                 {
[10:29:53.071]                   {
[10:29:53.071]                     {
[10:29:53.071]                       base::local({
[10:29:53.071]                         has_future <- base::requireNamespace("future", 
[10:29:53.071]                           quietly = TRUE)
[10:29:53.071]                         if (has_future) {
[10:29:53.071]                           ns <- base::getNamespace("future")
[10:29:53.071]                           version <- ns[[".package"]][["version"]]
[10:29:53.071]                           if (is.null(version)) 
[10:29:53.071]                             version <- utils::packageVersion("future")
[10:29:53.071]                         }
[10:29:53.071]                         else {
[10:29:53.071]                           version <- NULL
[10:29:53.071]                         }
[10:29:53.071]                         if (!has_future || version < "1.8.0") {
[10:29:53.071]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:53.071]                             "", base::R.version$version.string), 
[10:29:53.071]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:53.071]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:53.071]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:53.071]                               "release", "version")], collapse = " "), 
[10:29:53.071]                             hostname = base::Sys.info()[["nodename"]])
[10:29:53.071]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:53.071]                             info)
[10:29:53.071]                           info <- base::paste(info, collapse = "; ")
[10:29:53.071]                           if (!has_future) {
[10:29:53.071]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:53.071]                               info)
[10:29:53.071]                           }
[10:29:53.071]                           else {
[10:29:53.071]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:53.071]                               info, version)
[10:29:53.071]                           }
[10:29:53.071]                           base::stop(msg)
[10:29:53.071]                         }
[10:29:53.071]                       })
[10:29:53.071]                     }
[10:29:53.071]                     base::local({
[10:29:53.071]                       for (pkg in "stats") {
[10:29:53.071]                         base::loadNamespace(pkg)
[10:29:53.071]                         base::library(pkg, character.only = TRUE)
[10:29:53.071]                       }
[10:29:53.071]                     })
[10:29:53.071]                   }
[10:29:53.071]                   ...future.strategy.old <- future::plan("list")
[10:29:53.071]                   options(future.plan = NULL)
[10:29:53.071]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.071]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:53.071]                 }
[10:29:53.071]                 ...future.workdir <- getwd()
[10:29:53.071]             }
[10:29:53.071]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:53.071]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:53.071]         }
[10:29:53.071]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:53.071]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:53.071]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:53.071]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:53.071]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:53.071]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:53.071]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:53.071]             base::names(...future.oldOptions))
[10:29:53.071]     }
[10:29:53.071]     if (FALSE) {
[10:29:53.071]     }
[10:29:53.071]     else {
[10:29:53.071]         if (TRUE) {
[10:29:53.071]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:53.071]                 open = "w")
[10:29:53.071]         }
[10:29:53.071]         else {
[10:29:53.071]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:53.071]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:53.071]         }
[10:29:53.071]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:53.071]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:53.071]             base::sink(type = "output", split = FALSE)
[10:29:53.071]             base::close(...future.stdout)
[10:29:53.071]         }, add = TRUE)
[10:29:53.071]     }
[10:29:53.071]     ...future.frame <- base::sys.nframe()
[10:29:53.071]     ...future.conditions <- base::list()
[10:29:53.071]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:53.071]     if (FALSE) {
[10:29:53.071]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:53.071]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:53.071]     }
[10:29:53.071]     ...future.result <- base::tryCatch({
[10:29:53.071]         base::withCallingHandlers({
[10:29:53.071]             ...future.value <- base::withVisible(base::local({
[10:29:53.071]                 do.call(function(...) {
[10:29:53.071]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.071]                   if (!identical(...future.globals.maxSize.org, 
[10:29:53.071]                     ...future.globals.maxSize)) {
[10:29:53.071]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.071]                     on.exit(options(oopts), add = TRUE)
[10:29:53.071]                   }
[10:29:53.071]                   {
[10:29:53.071]                     lapply(seq_along(...future.elements_ii), 
[10:29:53.071]                       FUN = function(jj) {
[10:29:53.071]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.071]                         ...future.FUN(...future.X_jj, ...)
[10:29:53.071]                       })
[10:29:53.071]                   }
[10:29:53.071]                 }, args = future.call.arguments)
[10:29:53.071]             }))
[10:29:53.071]             future::FutureResult(value = ...future.value$value, 
[10:29:53.071]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.071]                   ...future.rng), globalenv = if (FALSE) 
[10:29:53.071]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:53.071]                     ...future.globalenv.names))
[10:29:53.071]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:53.071]         }, condition = base::local({
[10:29:53.071]             c <- base::c
[10:29:53.071]             inherits <- base::inherits
[10:29:53.071]             invokeRestart <- base::invokeRestart
[10:29:53.071]             length <- base::length
[10:29:53.071]             list <- base::list
[10:29:53.071]             seq.int <- base::seq.int
[10:29:53.071]             signalCondition <- base::signalCondition
[10:29:53.071]             sys.calls <- base::sys.calls
[10:29:53.071]             `[[` <- base::`[[`
[10:29:53.071]             `+` <- base::`+`
[10:29:53.071]             `<<-` <- base::`<<-`
[10:29:53.071]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:53.071]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:53.071]                   3L)]
[10:29:53.071]             }
[10:29:53.071]             function(cond) {
[10:29:53.071]                 is_error <- inherits(cond, "error")
[10:29:53.071]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:53.071]                   NULL)
[10:29:53.071]                 if (is_error) {
[10:29:53.071]                   sessionInformation <- function() {
[10:29:53.071]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:53.071]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:53.071]                       search = base::search(), system = base::Sys.info())
[10:29:53.071]                   }
[10:29:53.071]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.071]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:53.071]                     cond$call), session = sessionInformation(), 
[10:29:53.071]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:53.071]                   signalCondition(cond)
[10:29:53.071]                 }
[10:29:53.071]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:53.071]                 "immediateCondition"))) {
[10:29:53.071]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:53.071]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.071]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:53.071]                   if (TRUE && !signal) {
[10:29:53.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.071]                     {
[10:29:53.071]                       inherits <- base::inherits
[10:29:53.071]                       invokeRestart <- base::invokeRestart
[10:29:53.071]                       is.null <- base::is.null
[10:29:53.071]                       muffled <- FALSE
[10:29:53.071]                       if (inherits(cond, "message")) {
[10:29:53.071]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.071]                         if (muffled) 
[10:29:53.071]                           invokeRestart("muffleMessage")
[10:29:53.071]                       }
[10:29:53.071]                       else if (inherits(cond, "warning")) {
[10:29:53.071]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.071]                         if (muffled) 
[10:29:53.071]                           invokeRestart("muffleWarning")
[10:29:53.071]                       }
[10:29:53.071]                       else if (inherits(cond, "condition")) {
[10:29:53.071]                         if (!is.null(pattern)) {
[10:29:53.071]                           computeRestarts <- base::computeRestarts
[10:29:53.071]                           grepl <- base::grepl
[10:29:53.071]                           restarts <- computeRestarts(cond)
[10:29:53.071]                           for (restart in restarts) {
[10:29:53.071]                             name <- restart$name
[10:29:53.071]                             if (is.null(name)) 
[10:29:53.071]                               next
[10:29:53.071]                             if (!grepl(pattern, name)) 
[10:29:53.071]                               next
[10:29:53.071]                             invokeRestart(restart)
[10:29:53.071]                             muffled <- TRUE
[10:29:53.071]                             break
[10:29:53.071]                           }
[10:29:53.071]                         }
[10:29:53.071]                       }
[10:29:53.071]                       invisible(muffled)
[10:29:53.071]                     }
[10:29:53.071]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.071]                   }
[10:29:53.071]                 }
[10:29:53.071]                 else {
[10:29:53.071]                   if (TRUE) {
[10:29:53.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.071]                     {
[10:29:53.071]                       inherits <- base::inherits
[10:29:53.071]                       invokeRestart <- base::invokeRestart
[10:29:53.071]                       is.null <- base::is.null
[10:29:53.071]                       muffled <- FALSE
[10:29:53.071]                       if (inherits(cond, "message")) {
[10:29:53.071]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.071]                         if (muffled) 
[10:29:53.071]                           invokeRestart("muffleMessage")
[10:29:53.071]                       }
[10:29:53.071]                       else if (inherits(cond, "warning")) {
[10:29:53.071]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.071]                         if (muffled) 
[10:29:53.071]                           invokeRestart("muffleWarning")
[10:29:53.071]                       }
[10:29:53.071]                       else if (inherits(cond, "condition")) {
[10:29:53.071]                         if (!is.null(pattern)) {
[10:29:53.071]                           computeRestarts <- base::computeRestarts
[10:29:53.071]                           grepl <- base::grepl
[10:29:53.071]                           restarts <- computeRestarts(cond)
[10:29:53.071]                           for (restart in restarts) {
[10:29:53.071]                             name <- restart$name
[10:29:53.071]                             if (is.null(name)) 
[10:29:53.071]                               next
[10:29:53.071]                             if (!grepl(pattern, name)) 
[10:29:53.071]                               next
[10:29:53.071]                             invokeRestart(restart)
[10:29:53.071]                             muffled <- TRUE
[10:29:53.071]                             break
[10:29:53.071]                           }
[10:29:53.071]                         }
[10:29:53.071]                       }
[10:29:53.071]                       invisible(muffled)
[10:29:53.071]                     }
[10:29:53.071]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.071]                   }
[10:29:53.071]                 }
[10:29:53.071]             }
[10:29:53.071]         }))
[10:29:53.071]     }, error = function(ex) {
[10:29:53.071]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:53.071]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.071]                 ...future.rng), started = ...future.startTime, 
[10:29:53.071]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:53.071]             version = "1.8"), class = "FutureResult")
[10:29:53.071]     }, finally = {
[10:29:53.071]         if (!identical(...future.workdir, getwd())) 
[10:29:53.071]             setwd(...future.workdir)
[10:29:53.071]         {
[10:29:53.071]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:53.071]                 ...future.oldOptions$nwarnings <- NULL
[10:29:53.071]             }
[10:29:53.071]             base::options(...future.oldOptions)
[10:29:53.071]             if (.Platform$OS.type == "windows") {
[10:29:53.071]                 old_names <- names(...future.oldEnvVars)
[10:29:53.071]                 envs <- base::Sys.getenv()
[10:29:53.071]                 names <- names(envs)
[10:29:53.071]                 common <- intersect(names, old_names)
[10:29:53.071]                 added <- setdiff(names, old_names)
[10:29:53.071]                 removed <- setdiff(old_names, names)
[10:29:53.071]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:53.071]                   envs[common]]
[10:29:53.071]                 NAMES <- toupper(changed)
[10:29:53.071]                 args <- list()
[10:29:53.071]                 for (kk in seq_along(NAMES)) {
[10:29:53.071]                   name <- changed[[kk]]
[10:29:53.071]                   NAME <- NAMES[[kk]]
[10:29:53.071]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.071]                     next
[10:29:53.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.071]                 }
[10:29:53.071]                 NAMES <- toupper(added)
[10:29:53.071]                 for (kk in seq_along(NAMES)) {
[10:29:53.071]                   name <- added[[kk]]
[10:29:53.071]                   NAME <- NAMES[[kk]]
[10:29:53.071]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.071]                     next
[10:29:53.071]                   args[[name]] <- ""
[10:29:53.071]                 }
[10:29:53.071]                 NAMES <- toupper(removed)
[10:29:53.071]                 for (kk in seq_along(NAMES)) {
[10:29:53.071]                   name <- removed[[kk]]
[10:29:53.071]                   NAME <- NAMES[[kk]]
[10:29:53.071]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.071]                     next
[10:29:53.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.071]                 }
[10:29:53.071]                 if (length(args) > 0) 
[10:29:53.071]                   base::do.call(base::Sys.setenv, args = args)
[10:29:53.071]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:53.071]             }
[10:29:53.071]             else {
[10:29:53.071]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:53.071]             }
[10:29:53.071]             {
[10:29:53.071]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:53.071]                   0L) {
[10:29:53.071]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:53.071]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:53.071]                   base::options(opts)
[10:29:53.071]                 }
[10:29:53.071]                 {
[10:29:53.071]                   {
[10:29:53.071]                     NULL
[10:29:53.071]                     RNGkind("Mersenne-Twister")
[10:29:53.071]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:53.071]                       inherits = FALSE)
[10:29:53.071]                   }
[10:29:53.071]                   options(future.plan = NULL)
[10:29:53.071]                   if (is.na(NA_character_)) 
[10:29:53.071]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.071]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:53.071]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:53.071]                     .init = FALSE)
[10:29:53.071]                 }
[10:29:53.071]             }
[10:29:53.071]         }
[10:29:53.071]     })
[10:29:53.071]     if (TRUE) {
[10:29:53.071]         base::sink(type = "output", split = FALSE)
[10:29:53.071]         if (TRUE) {
[10:29:53.071]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:53.071]         }
[10:29:53.071]         else {
[10:29:53.071]             ...future.result["stdout"] <- base::list(NULL)
[10:29:53.071]         }
[10:29:53.071]         base::close(...future.stdout)
[10:29:53.071]         ...future.stdout <- NULL
[10:29:53.071]     }
[10:29:53.071]     ...future.result$conditions <- ...future.conditions
[10:29:53.071]     ...future.result$finished <- base::Sys.time()
[10:29:53.071]     ...future.result
[10:29:53.071] }
[10:29:53.073] assign_globals() ...
[10:29:53.073] List of 5
[10:29:53.073]  $ ...future.FUN            :function (x, ...)  
[10:29:53.073]  $ future.call.arguments    :List of 1
[10:29:53.073]   ..$ singular.ok: logi FALSE
[10:29:53.073]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.073]  $ ...future.elements_ii    :List of 3
[10:29:53.073]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.073]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:29:53.073]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.073]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:53.073]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.073]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:29:53.073]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.073]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:29:53.073]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.073]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:29:53.073]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.073]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:29:53.073]  $ ...future.seeds_ii       : NULL
[10:29:53.073]  $ ...future.globals.maxSize: NULL
[10:29:53.073]  - attr(*, "where")=List of 5
[10:29:53.073]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:53.073]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:53.073]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:53.073]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:53.073]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:53.073]  - attr(*, "resolved")= logi FALSE
[10:29:53.073]  - attr(*, "total_size")= num 5384
[10:29:53.073]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.073]  - attr(*, "already-done")= logi TRUE
[10:29:53.084] - reassign environment for ‘...future.FUN’
[10:29:53.084] - copied ‘...future.FUN’ to environment
[10:29:53.084] - copied ‘future.call.arguments’ to environment
[10:29:53.085] - copied ‘...future.elements_ii’ to environment
[10:29:53.085] - copied ‘...future.seeds_ii’ to environment
[10:29:53.085] - copied ‘...future.globals.maxSize’ to environment
[10:29:53.085] assign_globals() ... done
[10:29:53.085] plan(): Setting new future strategy stack:
[10:29:53.085] List of future strategies:
[10:29:53.085] 1. sequential:
[10:29:53.085]    - args: function (..., envir = parent.frame())
[10:29:53.085]    - tweaked: FALSE
[10:29:53.085]    - call: NULL
[10:29:53.086] plan(): nbrOfWorkers() = 1
[10:29:53.089] plan(): Setting new future strategy stack:
[10:29:53.089] List of future strategies:
[10:29:53.089] 1. sequential:
[10:29:53.089]    - args: function (..., envir = parent.frame())
[10:29:53.089]    - tweaked: FALSE
[10:29:53.089]    - call: plan(strategy)
[10:29:53.089] plan(): nbrOfWorkers() = 1
[10:29:53.089] SequentialFuture started (and completed)
[10:29:53.089] - Launch lazy future ... done
[10:29:53.090] run() for ‘SequentialFuture’ ... done
[10:29:53.090] Created future:
[10:29:53.090] SequentialFuture:
[10:29:53.090] Label: ‘future_by-1’
[10:29:53.090] Expression:
[10:29:53.090] {
[10:29:53.090]     do.call(function(...) {
[10:29:53.090]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.090]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.090]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.090]             on.exit(options(oopts), add = TRUE)
[10:29:53.090]         }
[10:29:53.090]         {
[10:29:53.090]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.090]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.090]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.090]             })
[10:29:53.090]         }
[10:29:53.090]     }, args = future.call.arguments)
[10:29:53.090] }
[10:29:53.090] Lazy evaluation: FALSE
[10:29:53.090] Asynchronous evaluation: FALSE
[10:29:53.090] Local evaluation: TRUE
[10:29:53.090] Environment: R_GlobalEnv
[10:29:53.090] Capture standard output: TRUE
[10:29:53.090] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:53.090] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:53.090] Packages: 1 packages (‘stats’)
[10:29:53.090] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:53.090] Resolved: TRUE
[10:29:53.090] Value: 26.06 KiB of class ‘list’
[10:29:53.090] Early signaling: FALSE
[10:29:53.090] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:53.090] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.091] Chunk #1 of 1 ... DONE
[10:29:53.091] Launching 1 futures (chunks) ... DONE
[10:29:53.091] Resolving 1 futures (chunks) ...
[10:29:53.092] resolve() on list ...
[10:29:53.092]  recursive: 0
[10:29:53.092]  length: 1
[10:29:53.092] 
[10:29:53.092] resolved() for ‘SequentialFuture’ ...
[10:29:53.092] - state: ‘finished’
[10:29:53.092] - run: TRUE
[10:29:53.092] - result: ‘FutureResult’
[10:29:53.092] resolved() for ‘SequentialFuture’ ... done
[10:29:53.092] Future #1
[10:29:53.093] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:53.093] - nx: 1
[10:29:53.093] - relay: TRUE
[10:29:53.093] - stdout: TRUE
[10:29:53.093] - signal: TRUE
[10:29:53.093] - resignal: FALSE
[10:29:53.093] - force: TRUE
[10:29:53.093] - relayed: [n=1] FALSE
[10:29:53.093] - queued futures: [n=1] FALSE
[10:29:53.093]  - until=1
[10:29:53.093]  - relaying element #1
[10:29:53.094] - relayed: [n=1] TRUE
[10:29:53.094] - queued futures: [n=1] TRUE
[10:29:53.094] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:53.094]  length: 0 (resolved future 1)
[10:29:53.094] Relaying remaining futures
[10:29:53.094] signalConditionsASAP(NULL, pos=0) ...
[10:29:53.094] - nx: 1
[10:29:53.094] - relay: TRUE
[10:29:53.094] - stdout: TRUE
[10:29:53.094] - signal: TRUE
[10:29:53.095] - resignal: FALSE
[10:29:53.095] - force: TRUE
[10:29:53.095] - relayed: [n=1] TRUE
[10:29:53.095] - queued futures: [n=1] TRUE
 - flush all
[10:29:53.095] - relayed: [n=1] TRUE
[10:29:53.095] - queued futures: [n=1] TRUE
[10:29:53.095] signalConditionsASAP(NULL, pos=0) ... done
[10:29:53.095] resolve() on list ... DONE
[10:29:53.095]  - Number of value chunks collected: 1
[10:29:53.095] Resolving 1 futures (chunks) ... DONE
[10:29:53.096] Reducing values from 1 chunks ...
[10:29:53.097]  - Number of values collected after concatenation: 3
[10:29:53.097]  - Number of values expected: 3
[10:29:53.097] Reducing values from 1 chunks ... DONE
[10:29:53.098] future_lapply() ... DONE
[10:29:53.098] future_by_internal() ... DONE
[10:29:53.102] future_by_internal() ...
[10:29:53.102] future_lapply() ...
[10:29:53.103] Number of chunks: 1
[10:29:53.103] getGlobalsAndPackagesXApply() ...
[10:29:53.103]  - future.globals: TRUE
[10:29:53.103] getGlobalsAndPackages() ...
[10:29:53.104] Searching for globals...
[10:29:53.105] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:29:53.105] Searching for globals ... DONE
[10:29:53.106] Resolving globals: FALSE
[10:29:53.106] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[10:29:53.106] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[10:29:53.107] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[10:29:53.107] - packages: [1] ‘stats’
[10:29:53.107] getGlobalsAndPackages() ... DONE
[10:29:53.107]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[10:29:53.107]  - needed namespaces: [n=1] ‘stats’
[10:29:53.107] Finding globals ... DONE
[10:29:53.107]  - use_args: TRUE
[10:29:53.107]  - Getting '...' globals ...
[10:29:53.108] resolve() on list ...
[10:29:53.108]  recursive: 0
[10:29:53.108]  length: 1
[10:29:53.108]  elements: ‘...’
[10:29:53.108]  length: 0 (resolved future 1)
[10:29:53.108] resolve() on list ... DONE
[10:29:53.108]    - '...' content: [n=0] 
[10:29:53.108] List of 1
[10:29:53.108]  $ ...: list()
[10:29:53.108]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.108]  - attr(*, "where")=List of 1
[10:29:53.108]   ..$ ...:<environment: 0x556dd314e8d0> 
[10:29:53.108]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.108]  - attr(*, "resolved")= logi TRUE
[10:29:53.108]  - attr(*, "total_size")= num NA
[10:29:53.111]  - Getting '...' globals ... DONE
[10:29:53.111] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[10:29:53.111] List of 4
[10:29:53.111]  $ ...future.FUN:function (x)  
[10:29:53.111]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:29:53.111]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:53.111]  $ ...          : list()
[10:29:53.111]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.111]  - attr(*, "where")=List of 4
[10:29:53.111]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:53.111]   ..$ breaks       :<environment: R_EmptyEnv> 
[10:29:53.111]   ..$ wool         :<environment: R_EmptyEnv> 
[10:29:53.111]   ..$ ...          :<environment: 0x556dd314e8d0> 
[10:29:53.111]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.111]  - attr(*, "resolved")= logi FALSE
[10:29:53.111]  - attr(*, "total_size")= num 2320
[10:29:53.116] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:53.116] getGlobalsAndPackagesXApply() ... DONE
[10:29:53.117] Number of futures (= number of chunks): 1
[10:29:53.117] Launching 1 futures (chunks) ...
[10:29:53.117] Chunk #1 of 1 ...
[10:29:53.117]  - Finding globals in 'X' for chunk #1 ...
[10:29:53.117] getGlobalsAndPackages() ...
[10:29:53.117] Searching for globals...
[10:29:53.118] 
[10:29:53.118] Searching for globals ... DONE
[10:29:53.118] - globals: [0] <none>
[10:29:53.118] getGlobalsAndPackages() ... DONE
[10:29:53.118]    + additional globals found: [n=0] 
[10:29:53.118]    + additional namespaces needed: [n=0] 
[10:29:53.118]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:53.118]  - seeds: <none>
[10:29:53.118]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.118] getGlobalsAndPackages() ...
[10:29:53.119] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.119] Resolving globals: FALSE
[10:29:53.119] Tweak future expression to call with '...' arguments ...
[10:29:53.119] {
[10:29:53.119]     do.call(function(...) {
[10:29:53.119]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.119]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.119]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.119]             on.exit(options(oopts), add = TRUE)
[10:29:53.119]         }
[10:29:53.119]         {
[10:29:53.119]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.119]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.119]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.119]             })
[10:29:53.119]         }
[10:29:53.119]     }, args = future.call.arguments)
[10:29:53.119] }
[10:29:53.119] Tweak future expression to call with '...' arguments ... DONE
[10:29:53.120] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.120] 
[10:29:53.120] getGlobalsAndPackages() ... DONE
[10:29:53.120] run() for ‘Future’ ...
[10:29:53.120] - state: ‘created’
[10:29:53.120] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:29:53.121] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.121] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:53.121]   - Field: ‘label’
[10:29:53.121]   - Field: ‘local’
[10:29:53.121]   - Field: ‘owner’
[10:29:53.121]   - Field: ‘envir’
[10:29:53.121]   - Field: ‘packages’
[10:29:53.121]   - Field: ‘gc’
[10:29:53.121]   - Field: ‘conditions’
[10:29:53.121]   - Field: ‘expr’
[10:29:53.122]   - Field: ‘uuid’
[10:29:53.122]   - Field: ‘seed’
[10:29:53.122]   - Field: ‘version’
[10:29:53.122]   - Field: ‘result’
[10:29:53.122]   - Field: ‘asynchronous’
[10:29:53.122]   - Field: ‘calls’
[10:29:53.122]   - Field: ‘globals’
[10:29:53.122]   - Field: ‘stdout’
[10:29:53.122]   - Field: ‘earlySignal’
[10:29:53.122]   - Field: ‘lazy’
[10:29:53.122]   - Field: ‘state’
[10:29:53.123] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:53.123] - Launch lazy future ...
[10:29:53.123] Packages needed by the future expression (n = 1): ‘stats’
[10:29:53.123] Packages needed by future strategies (n = 0): <none>
[10:29:53.123] {
[10:29:53.123]     {
[10:29:53.123]         {
[10:29:53.123]             ...future.startTime <- base::Sys.time()
[10:29:53.123]             {
[10:29:53.123]                 {
[10:29:53.123]                   {
[10:29:53.123]                     {
[10:29:53.123]                       base::local({
[10:29:53.123]                         has_future <- base::requireNamespace("future", 
[10:29:53.123]                           quietly = TRUE)
[10:29:53.123]                         if (has_future) {
[10:29:53.123]                           ns <- base::getNamespace("future")
[10:29:53.123]                           version <- ns[[".package"]][["version"]]
[10:29:53.123]                           if (is.null(version)) 
[10:29:53.123]                             version <- utils::packageVersion("future")
[10:29:53.123]                         }
[10:29:53.123]                         else {
[10:29:53.123]                           version <- NULL
[10:29:53.123]                         }
[10:29:53.123]                         if (!has_future || version < "1.8.0") {
[10:29:53.123]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:53.123]                             "", base::R.version$version.string), 
[10:29:53.123]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:53.123]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:53.123]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:53.123]                               "release", "version")], collapse = " "), 
[10:29:53.123]                             hostname = base::Sys.info()[["nodename"]])
[10:29:53.123]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:53.123]                             info)
[10:29:53.123]                           info <- base::paste(info, collapse = "; ")
[10:29:53.123]                           if (!has_future) {
[10:29:53.123]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:53.123]                               info)
[10:29:53.123]                           }
[10:29:53.123]                           else {
[10:29:53.123]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:53.123]                               info, version)
[10:29:53.123]                           }
[10:29:53.123]                           base::stop(msg)
[10:29:53.123]                         }
[10:29:53.123]                       })
[10:29:53.123]                     }
[10:29:53.123]                     base::local({
[10:29:53.123]                       for (pkg in "stats") {
[10:29:53.123]                         base::loadNamespace(pkg)
[10:29:53.123]                         base::library(pkg, character.only = TRUE)
[10:29:53.123]                       }
[10:29:53.123]                     })
[10:29:53.123]                   }
[10:29:53.123]                   ...future.strategy.old <- future::plan("list")
[10:29:53.123]                   options(future.plan = NULL)
[10:29:53.123]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.123]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:53.123]                 }
[10:29:53.123]                 ...future.workdir <- getwd()
[10:29:53.123]             }
[10:29:53.123]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:53.123]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:53.123]         }
[10:29:53.123]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:53.123]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:53.123]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:53.123]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:53.123]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:53.123]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:53.123]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:53.123]             base::names(...future.oldOptions))
[10:29:53.123]     }
[10:29:53.123]     if (FALSE) {
[10:29:53.123]     }
[10:29:53.123]     else {
[10:29:53.123]         if (TRUE) {
[10:29:53.123]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:53.123]                 open = "w")
[10:29:53.123]         }
[10:29:53.123]         else {
[10:29:53.123]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:53.123]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:53.123]         }
[10:29:53.123]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:53.123]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:53.123]             base::sink(type = "output", split = FALSE)
[10:29:53.123]             base::close(...future.stdout)
[10:29:53.123]         }, add = TRUE)
[10:29:53.123]     }
[10:29:53.123]     ...future.frame <- base::sys.nframe()
[10:29:53.123]     ...future.conditions <- base::list()
[10:29:53.123]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:53.123]     if (FALSE) {
[10:29:53.123]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:53.123]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:53.123]     }
[10:29:53.123]     ...future.result <- base::tryCatch({
[10:29:53.123]         base::withCallingHandlers({
[10:29:53.123]             ...future.value <- base::withVisible(base::local({
[10:29:53.123]                 do.call(function(...) {
[10:29:53.123]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.123]                   if (!identical(...future.globals.maxSize.org, 
[10:29:53.123]                     ...future.globals.maxSize)) {
[10:29:53.123]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.123]                     on.exit(options(oopts), add = TRUE)
[10:29:53.123]                   }
[10:29:53.123]                   {
[10:29:53.123]                     lapply(seq_along(...future.elements_ii), 
[10:29:53.123]                       FUN = function(jj) {
[10:29:53.123]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.123]                         ...future.FUN(...future.X_jj, ...)
[10:29:53.123]                       })
[10:29:53.123]                   }
[10:29:53.123]                 }, args = future.call.arguments)
[10:29:53.123]             }))
[10:29:53.123]             future::FutureResult(value = ...future.value$value, 
[10:29:53.123]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.123]                   ...future.rng), globalenv = if (FALSE) 
[10:29:53.123]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:53.123]                     ...future.globalenv.names))
[10:29:53.123]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:53.123]         }, condition = base::local({
[10:29:53.123]             c <- base::c
[10:29:53.123]             inherits <- base::inherits
[10:29:53.123]             invokeRestart <- base::invokeRestart
[10:29:53.123]             length <- base::length
[10:29:53.123]             list <- base::list
[10:29:53.123]             seq.int <- base::seq.int
[10:29:53.123]             signalCondition <- base::signalCondition
[10:29:53.123]             sys.calls <- base::sys.calls
[10:29:53.123]             `[[` <- base::`[[`
[10:29:53.123]             `+` <- base::`+`
[10:29:53.123]             `<<-` <- base::`<<-`
[10:29:53.123]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:53.123]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:53.123]                   3L)]
[10:29:53.123]             }
[10:29:53.123]             function(cond) {
[10:29:53.123]                 is_error <- inherits(cond, "error")
[10:29:53.123]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:53.123]                   NULL)
[10:29:53.123]                 if (is_error) {
[10:29:53.123]                   sessionInformation <- function() {
[10:29:53.123]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:53.123]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:53.123]                       search = base::search(), system = base::Sys.info())
[10:29:53.123]                   }
[10:29:53.123]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.123]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:53.123]                     cond$call), session = sessionInformation(), 
[10:29:53.123]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:53.123]                   signalCondition(cond)
[10:29:53.123]                 }
[10:29:53.123]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:53.123]                 "immediateCondition"))) {
[10:29:53.123]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:53.123]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.123]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:53.123]                   if (TRUE && !signal) {
[10:29:53.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.123]                     {
[10:29:53.123]                       inherits <- base::inherits
[10:29:53.123]                       invokeRestart <- base::invokeRestart
[10:29:53.123]                       is.null <- base::is.null
[10:29:53.123]                       muffled <- FALSE
[10:29:53.123]                       if (inherits(cond, "message")) {
[10:29:53.123]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.123]                         if (muffled) 
[10:29:53.123]                           invokeRestart("muffleMessage")
[10:29:53.123]                       }
[10:29:53.123]                       else if (inherits(cond, "warning")) {
[10:29:53.123]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.123]                         if (muffled) 
[10:29:53.123]                           invokeRestart("muffleWarning")
[10:29:53.123]                       }
[10:29:53.123]                       else if (inherits(cond, "condition")) {
[10:29:53.123]                         if (!is.null(pattern)) {
[10:29:53.123]                           computeRestarts <- base::computeRestarts
[10:29:53.123]                           grepl <- base::grepl
[10:29:53.123]                           restarts <- computeRestarts(cond)
[10:29:53.123]                           for (restart in restarts) {
[10:29:53.123]                             name <- restart$name
[10:29:53.123]                             if (is.null(name)) 
[10:29:53.123]                               next
[10:29:53.123]                             if (!grepl(pattern, name)) 
[10:29:53.123]                               next
[10:29:53.123]                             invokeRestart(restart)
[10:29:53.123]                             muffled <- TRUE
[10:29:53.123]                             break
[10:29:53.123]                           }
[10:29:53.123]                         }
[10:29:53.123]                       }
[10:29:53.123]                       invisible(muffled)
[10:29:53.123]                     }
[10:29:53.123]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.123]                   }
[10:29:53.123]                 }
[10:29:53.123]                 else {
[10:29:53.123]                   if (TRUE) {
[10:29:53.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.123]                     {
[10:29:53.123]                       inherits <- base::inherits
[10:29:53.123]                       invokeRestart <- base::invokeRestart
[10:29:53.123]                       is.null <- base::is.null
[10:29:53.123]                       muffled <- FALSE
[10:29:53.123]                       if (inherits(cond, "message")) {
[10:29:53.123]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.123]                         if (muffled) 
[10:29:53.123]                           invokeRestart("muffleMessage")
[10:29:53.123]                       }
[10:29:53.123]                       else if (inherits(cond, "warning")) {
[10:29:53.123]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.123]                         if (muffled) 
[10:29:53.123]                           invokeRestart("muffleWarning")
[10:29:53.123]                       }
[10:29:53.123]                       else if (inherits(cond, "condition")) {
[10:29:53.123]                         if (!is.null(pattern)) {
[10:29:53.123]                           computeRestarts <- base::computeRestarts
[10:29:53.123]                           grepl <- base::grepl
[10:29:53.123]                           restarts <- computeRestarts(cond)
[10:29:53.123]                           for (restart in restarts) {
[10:29:53.123]                             name <- restart$name
[10:29:53.123]                             if (is.null(name)) 
[10:29:53.123]                               next
[10:29:53.123]                             if (!grepl(pattern, name)) 
[10:29:53.123]                               next
[10:29:53.123]                             invokeRestart(restart)
[10:29:53.123]                             muffled <- TRUE
[10:29:53.123]                             break
[10:29:53.123]                           }
[10:29:53.123]                         }
[10:29:53.123]                       }
[10:29:53.123]                       invisible(muffled)
[10:29:53.123]                     }
[10:29:53.123]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.123]                   }
[10:29:53.123]                 }
[10:29:53.123]             }
[10:29:53.123]         }))
[10:29:53.123]     }, error = function(ex) {
[10:29:53.123]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:53.123]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.123]                 ...future.rng), started = ...future.startTime, 
[10:29:53.123]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:53.123]             version = "1.8"), class = "FutureResult")
[10:29:53.123]     }, finally = {
[10:29:53.123]         if (!identical(...future.workdir, getwd())) 
[10:29:53.123]             setwd(...future.workdir)
[10:29:53.123]         {
[10:29:53.123]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:53.123]                 ...future.oldOptions$nwarnings <- NULL
[10:29:53.123]             }
[10:29:53.123]             base::options(...future.oldOptions)
[10:29:53.123]             if (.Platform$OS.type == "windows") {
[10:29:53.123]                 old_names <- names(...future.oldEnvVars)
[10:29:53.123]                 envs <- base::Sys.getenv()
[10:29:53.123]                 names <- names(envs)
[10:29:53.123]                 common <- intersect(names, old_names)
[10:29:53.123]                 added <- setdiff(names, old_names)
[10:29:53.123]                 removed <- setdiff(old_names, names)
[10:29:53.123]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:53.123]                   envs[common]]
[10:29:53.123]                 NAMES <- toupper(changed)
[10:29:53.123]                 args <- list()
[10:29:53.123]                 for (kk in seq_along(NAMES)) {
[10:29:53.123]                   name <- changed[[kk]]
[10:29:53.123]                   NAME <- NAMES[[kk]]
[10:29:53.123]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.123]                     next
[10:29:53.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.123]                 }
[10:29:53.123]                 NAMES <- toupper(added)
[10:29:53.123]                 for (kk in seq_along(NAMES)) {
[10:29:53.123]                   name <- added[[kk]]
[10:29:53.123]                   NAME <- NAMES[[kk]]
[10:29:53.123]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.123]                     next
[10:29:53.123]                   args[[name]] <- ""
[10:29:53.123]                 }
[10:29:53.123]                 NAMES <- toupper(removed)
[10:29:53.123]                 for (kk in seq_along(NAMES)) {
[10:29:53.123]                   name <- removed[[kk]]
[10:29:53.123]                   NAME <- NAMES[[kk]]
[10:29:53.123]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.123]                     next
[10:29:53.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.123]                 }
[10:29:53.123]                 if (length(args) > 0) 
[10:29:53.123]                   base::do.call(base::Sys.setenv, args = args)
[10:29:53.123]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:53.123]             }
[10:29:53.123]             else {
[10:29:53.123]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:53.123]             }
[10:29:53.123]             {
[10:29:53.123]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:53.123]                   0L) {
[10:29:53.123]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:53.123]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:53.123]                   base::options(opts)
[10:29:53.123]                 }
[10:29:53.123]                 {
[10:29:53.123]                   {
[10:29:53.123]                     NULL
[10:29:53.123]                     RNGkind("Mersenne-Twister")
[10:29:53.123]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:53.123]                       inherits = FALSE)
[10:29:53.123]                   }
[10:29:53.123]                   options(future.plan = NULL)
[10:29:53.123]                   if (is.na(NA_character_)) 
[10:29:53.123]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.123]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:53.123]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:53.123]                     .init = FALSE)
[10:29:53.123]                 }
[10:29:53.123]             }
[10:29:53.123]         }
[10:29:53.123]     })
[10:29:53.123]     if (TRUE) {
[10:29:53.123]         base::sink(type = "output", split = FALSE)
[10:29:53.123]         if (TRUE) {
[10:29:53.123]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:53.123]         }
[10:29:53.123]         else {
[10:29:53.123]             ...future.result["stdout"] <- base::list(NULL)
[10:29:53.123]         }
[10:29:53.123]         base::close(...future.stdout)
[10:29:53.123]         ...future.stdout <- NULL
[10:29:53.123]     }
[10:29:53.123]     ...future.result$conditions <- ...future.conditions
[10:29:53.123]     ...future.result$finished <- base::Sys.time()
[10:29:53.123]     ...future.result
[10:29:53.123] }
[10:29:53.125] assign_globals() ...
[10:29:53.125] List of 7
[10:29:53.125]  $ ...future.FUN            :function (x)  
[10:29:53.125]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:29:53.125]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:53.125]  $ future.call.arguments    : list()
[10:29:53.125]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.125]  $ ...future.elements_ii    :List of 3
[10:29:53.125]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.125]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:29:53.125]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.125]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:53.125]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.125]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:29:53.125]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.125]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:29:53.125]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.125]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:29:53.125]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.125]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:29:53.125]  $ ...future.seeds_ii       : NULL
[10:29:53.125]  $ ...future.globals.maxSize: NULL
[10:29:53.125]  - attr(*, "where")=List of 7
[10:29:53.125]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:53.125]   ..$ breaks                   :<environment: R_EmptyEnv> 
[10:29:53.125]   ..$ wool                     :<environment: R_EmptyEnv> 
[10:29:53.125]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:53.125]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:53.125]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:53.125]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:53.125]  - attr(*, "resolved")= logi FALSE
[10:29:53.125]  - attr(*, "total_size")= num 2320
[10:29:53.125]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.125]  - attr(*, "already-done")= logi TRUE
[10:29:53.135] - reassign environment for ‘...future.FUN’
[10:29:53.135] - copied ‘...future.FUN’ to environment
[10:29:53.135] - copied ‘breaks’ to environment
[10:29:53.135] - copied ‘wool’ to environment
[10:29:53.135] - copied ‘future.call.arguments’ to environment
[10:29:53.135] - copied ‘...future.elements_ii’ to environment
[10:29:53.136] - copied ‘...future.seeds_ii’ to environment
[10:29:53.136] - copied ‘...future.globals.maxSize’ to environment
[10:29:53.136] assign_globals() ... done
[10:29:53.138] plan(): Setting new future strategy stack:
[10:29:53.138] List of future strategies:
[10:29:53.138] 1. sequential:
[10:29:53.138]    - args: function (..., envir = parent.frame())
[10:29:53.138]    - tweaked: FALSE
[10:29:53.138]    - call: NULL
[10:29:53.138] plan(): nbrOfWorkers() = 1
[10:29:53.141] plan(): Setting new future strategy stack:
[10:29:53.141] List of future strategies:
[10:29:53.141] 1. sequential:
[10:29:53.141]    - args: function (..., envir = parent.frame())
[10:29:53.141]    - tweaked: FALSE
[10:29:53.141]    - call: plan(strategy)
[10:29:53.141] plan(): nbrOfWorkers() = 1
[10:29:53.141] SequentialFuture started (and completed)
[10:29:53.142] - Launch lazy future ... done
[10:29:53.142] run() for ‘SequentialFuture’ ... done
[10:29:53.142] Created future:
[10:29:53.142] SequentialFuture:
[10:29:53.142] Label: ‘future_by-1’
[10:29:53.142] Expression:
[10:29:53.142] {
[10:29:53.142]     do.call(function(...) {
[10:29:53.142]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.142]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.142]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.142]             on.exit(options(oopts), add = TRUE)
[10:29:53.142]         }
[10:29:53.142]         {
[10:29:53.142]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.142]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.142]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.142]             })
[10:29:53.142]         }
[10:29:53.142]     }, args = future.call.arguments)
[10:29:53.142] }
[10:29:53.142] Lazy evaluation: FALSE
[10:29:53.142] Asynchronous evaluation: FALSE
[10:29:53.142] Local evaluation: TRUE
[10:29:53.142] Environment: 0x556dd2f23f20
[10:29:53.142] Capture standard output: TRUE
[10:29:53.142] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:53.142] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[10:29:53.142] Packages: 1 packages (‘stats’)
[10:29:53.142] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:53.142] Resolved: TRUE
[10:29:53.142] Value: 25.57 KiB of class ‘list’
[10:29:53.142] Early signaling: FALSE
[10:29:53.142] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:53.142] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.143] Chunk #1 of 1 ... DONE
[10:29:53.143] Launching 1 futures (chunks) ... DONE
[10:29:53.144] Resolving 1 futures (chunks) ...
[10:29:53.144] resolve() on list ...
[10:29:53.144]  recursive: 0
[10:29:53.144]  length: 1
[10:29:53.144] 
[10:29:53.144] resolved() for ‘SequentialFuture’ ...
[10:29:53.144] - state: ‘finished’
[10:29:53.144] - run: TRUE
[10:29:53.144] - result: ‘FutureResult’
[10:29:53.144] resolved() for ‘SequentialFuture’ ... done
[10:29:53.145] Future #1
[10:29:53.145] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:53.145] - nx: 1
[10:29:53.145] - relay: TRUE
[10:29:53.145] - stdout: TRUE
[10:29:53.145] - signal: TRUE
[10:29:53.145] - resignal: FALSE
[10:29:53.145] - force: TRUE
[10:29:53.145] - relayed: [n=1] FALSE
[10:29:53.145] - queued futures: [n=1] FALSE
[10:29:53.145]  - until=1
[10:29:53.146]  - relaying element #1
[10:29:53.146] - relayed: [n=1] TRUE
[10:29:53.146] - queued futures: [n=1] TRUE
[10:29:53.146] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:53.146]  length: 0 (resolved future 1)
[10:29:53.146] Relaying remaining futures
[10:29:53.146] signalConditionsASAP(NULL, pos=0) ...
[10:29:53.146] - nx: 1
[10:29:53.146] - relay: TRUE
[10:29:53.146] - stdout: TRUE
[10:29:53.147] - signal: TRUE
[10:29:53.147] - resignal: FALSE
[10:29:53.147] - force: TRUE
[10:29:53.147] - relayed: [n=1] TRUE
[10:29:53.147] - queued futures: [n=1] TRUE
 - flush all
[10:29:53.147] - relayed: [n=1] TRUE
[10:29:53.147] - queued futures: [n=1] TRUE
[10:29:53.147] signalConditionsASAP(NULL, pos=0) ... done
[10:29:53.147] resolve() on list ... DONE
[10:29:53.148]  - Number of value chunks collected: 1
[10:29:53.148] Resolving 1 futures (chunks) ... DONE
[10:29:53.148] Reducing values from 1 chunks ...
[10:29:53.148]  - Number of values collected after concatenation: 3
[10:29:53.148]  - Number of values expected: 3
[10:29:53.148] Reducing values from 1 chunks ... DONE
[10:29:53.148] future_lapply() ... DONE
[10:29:53.148] future_by_internal() ... DONE
[10:29:53.149] future_by_internal() ...
[10:29:53.149] future_lapply() ...
[10:29:53.149] Number of chunks: 1
[10:29:53.149] getGlobalsAndPackagesXApply() ...
[10:29:53.150]  - future.globals: TRUE
[10:29:53.150] getGlobalsAndPackages() ...
[10:29:53.150] Searching for globals...
[10:29:53.151] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:53.151] Searching for globals ... DONE
[10:29:53.151] Resolving globals: FALSE
[10:29:53.151] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:53.152] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:53.152] - globals: [1] ‘FUN’
[10:29:53.152] 
[10:29:53.152] getGlobalsAndPackages() ... DONE
[10:29:53.152]  - globals found/used: [n=1] ‘FUN’
[10:29:53.152]  - needed namespaces: [n=0] 
[10:29:53.152] Finding globals ... DONE
[10:29:53.152]  - use_args: TRUE
[10:29:53.152]  - Getting '...' globals ...
[10:29:53.153] resolve() on list ...
[10:29:53.153]  recursive: 0
[10:29:53.153]  length: 1
[10:29:53.153]  elements: ‘...’
[10:29:53.153]  length: 0 (resolved future 1)
[10:29:53.153] resolve() on list ... DONE
[10:29:53.153]    - '...' content: [n=0] 
[10:29:53.153] List of 1
[10:29:53.153]  $ ...: list()
[10:29:53.153]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.153]  - attr(*, "where")=List of 1
[10:29:53.153]   ..$ ...:<environment: 0x556dd5022490> 
[10:29:53.153]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.153]  - attr(*, "resolved")= logi TRUE
[10:29:53.153]  - attr(*, "total_size")= num NA
[10:29:53.156]  - Getting '...' globals ... DONE
[10:29:53.156] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:53.156] List of 2
[10:29:53.156]  $ ...future.FUN:function (object, ...)  
[10:29:53.156]  $ ...          : list()
[10:29:53.156]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.156]  - attr(*, "where")=List of 2
[10:29:53.156]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:53.156]   ..$ ...          :<environment: 0x556dd5022490> 
[10:29:53.156]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.156]  - attr(*, "resolved")= logi FALSE
[10:29:53.156]  - attr(*, "total_size")= num 1240
[10:29:53.160] Packages to be attached in all futures: [n=0] 
[10:29:53.160] getGlobalsAndPackagesXApply() ... DONE
[10:29:53.161] Number of futures (= number of chunks): 1
[10:29:53.161] Launching 1 futures (chunks) ...
[10:29:53.161] Chunk #1 of 1 ...
[10:29:53.161]  - Finding globals in 'X' for chunk #1 ...
[10:29:53.161] getGlobalsAndPackages() ...
[10:29:53.161] Searching for globals...
[10:29:53.162] 
[10:29:53.162] Searching for globals ... DONE
[10:29:53.162] - globals: [0] <none>
[10:29:53.162] getGlobalsAndPackages() ... DONE
[10:29:53.162]    + additional globals found: [n=0] 
[10:29:53.162]    + additional namespaces needed: [n=0] 
[10:29:53.162]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:53.162]  - seeds: <none>
[10:29:53.162]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.163] getGlobalsAndPackages() ...
[10:29:53.163] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.163] Resolving globals: FALSE
[10:29:53.163] Tweak future expression to call with '...' arguments ...
[10:29:53.163] {
[10:29:53.163]     do.call(function(...) {
[10:29:53.163]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.163]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.163]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.163]             on.exit(options(oopts), add = TRUE)
[10:29:53.163]         }
[10:29:53.163]         {
[10:29:53.163]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.163]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.163]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.163]             })
[10:29:53.163]         }
[10:29:53.163]     }, args = future.call.arguments)
[10:29:53.163] }
[10:29:53.163] Tweak future expression to call with '...' arguments ... DONE
[10:29:53.164] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.164] 
[10:29:53.164] getGlobalsAndPackages() ... DONE
[10:29:53.164] run() for ‘Future’ ...
[10:29:53.164] - state: ‘created’
[10:29:53.164] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:29:53.165] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.165] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:53.165]   - Field: ‘label’
[10:29:53.165]   - Field: ‘local’
[10:29:53.165]   - Field: ‘owner’
[10:29:53.165]   - Field: ‘envir’
[10:29:53.165]   - Field: ‘packages’
[10:29:53.165]   - Field: ‘gc’
[10:29:53.165]   - Field: ‘conditions’
[10:29:53.165]   - Field: ‘expr’
[10:29:53.166]   - Field: ‘uuid’
[10:29:53.166]   - Field: ‘seed’
[10:29:53.166]   - Field: ‘version’
[10:29:53.166]   - Field: ‘result’
[10:29:53.166]   - Field: ‘asynchronous’
[10:29:53.166]   - Field: ‘calls’
[10:29:53.166]   - Field: ‘globals’
[10:29:53.166]   - Field: ‘stdout’
[10:29:53.166]   - Field: ‘earlySignal’
[10:29:53.166]   - Field: ‘lazy’
[10:29:53.166]   - Field: ‘state’
[10:29:53.167] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:53.167] - Launch lazy future ...
[10:29:53.167] Packages needed by the future expression (n = 0): <none>
[10:29:53.167] Packages needed by future strategies (n = 0): <none>
[10:29:53.167] {
[10:29:53.167]     {
[10:29:53.167]         {
[10:29:53.167]             ...future.startTime <- base::Sys.time()
[10:29:53.167]             {
[10:29:53.167]                 {
[10:29:53.167]                   {
[10:29:53.167]                     base::local({
[10:29:53.167]                       has_future <- base::requireNamespace("future", 
[10:29:53.167]                         quietly = TRUE)
[10:29:53.167]                       if (has_future) {
[10:29:53.167]                         ns <- base::getNamespace("future")
[10:29:53.167]                         version <- ns[[".package"]][["version"]]
[10:29:53.167]                         if (is.null(version)) 
[10:29:53.167]                           version <- utils::packageVersion("future")
[10:29:53.167]                       }
[10:29:53.167]                       else {
[10:29:53.167]                         version <- NULL
[10:29:53.167]                       }
[10:29:53.167]                       if (!has_future || version < "1.8.0") {
[10:29:53.167]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:53.167]                           "", base::R.version$version.string), 
[10:29:53.167]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:53.167]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:53.167]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:53.167]                             "release", "version")], collapse = " "), 
[10:29:53.167]                           hostname = base::Sys.info()[["nodename"]])
[10:29:53.167]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:53.167]                           info)
[10:29:53.167]                         info <- base::paste(info, collapse = "; ")
[10:29:53.167]                         if (!has_future) {
[10:29:53.167]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:53.167]                             info)
[10:29:53.167]                         }
[10:29:53.167]                         else {
[10:29:53.167]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:53.167]                             info, version)
[10:29:53.167]                         }
[10:29:53.167]                         base::stop(msg)
[10:29:53.167]                       }
[10:29:53.167]                     })
[10:29:53.167]                   }
[10:29:53.167]                   ...future.strategy.old <- future::plan("list")
[10:29:53.167]                   options(future.plan = NULL)
[10:29:53.167]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.167]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:53.167]                 }
[10:29:53.167]                 ...future.workdir <- getwd()
[10:29:53.167]             }
[10:29:53.167]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:53.167]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:53.167]         }
[10:29:53.167]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:53.167]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:53.167]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:53.167]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:53.167]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:53.167]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:53.167]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:53.167]             base::names(...future.oldOptions))
[10:29:53.167]     }
[10:29:53.167]     if (FALSE) {
[10:29:53.167]     }
[10:29:53.167]     else {
[10:29:53.167]         if (TRUE) {
[10:29:53.167]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:53.167]                 open = "w")
[10:29:53.167]         }
[10:29:53.167]         else {
[10:29:53.167]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:53.167]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:53.167]         }
[10:29:53.167]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:53.167]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:53.167]             base::sink(type = "output", split = FALSE)
[10:29:53.167]             base::close(...future.stdout)
[10:29:53.167]         }, add = TRUE)
[10:29:53.167]     }
[10:29:53.167]     ...future.frame <- base::sys.nframe()
[10:29:53.167]     ...future.conditions <- base::list()
[10:29:53.167]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:53.167]     if (FALSE) {
[10:29:53.167]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:53.167]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:53.167]     }
[10:29:53.167]     ...future.result <- base::tryCatch({
[10:29:53.167]         base::withCallingHandlers({
[10:29:53.167]             ...future.value <- base::withVisible(base::local({
[10:29:53.167]                 do.call(function(...) {
[10:29:53.167]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.167]                   if (!identical(...future.globals.maxSize.org, 
[10:29:53.167]                     ...future.globals.maxSize)) {
[10:29:53.167]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.167]                     on.exit(options(oopts), add = TRUE)
[10:29:53.167]                   }
[10:29:53.167]                   {
[10:29:53.167]                     lapply(seq_along(...future.elements_ii), 
[10:29:53.167]                       FUN = function(jj) {
[10:29:53.167]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.167]                         ...future.FUN(...future.X_jj, ...)
[10:29:53.167]                       })
[10:29:53.167]                   }
[10:29:53.167]                 }, args = future.call.arguments)
[10:29:53.167]             }))
[10:29:53.167]             future::FutureResult(value = ...future.value$value, 
[10:29:53.167]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.167]                   ...future.rng), globalenv = if (FALSE) 
[10:29:53.167]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:53.167]                     ...future.globalenv.names))
[10:29:53.167]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:53.167]         }, condition = base::local({
[10:29:53.167]             c <- base::c
[10:29:53.167]             inherits <- base::inherits
[10:29:53.167]             invokeRestart <- base::invokeRestart
[10:29:53.167]             length <- base::length
[10:29:53.167]             list <- base::list
[10:29:53.167]             seq.int <- base::seq.int
[10:29:53.167]             signalCondition <- base::signalCondition
[10:29:53.167]             sys.calls <- base::sys.calls
[10:29:53.167]             `[[` <- base::`[[`
[10:29:53.167]             `+` <- base::`+`
[10:29:53.167]             `<<-` <- base::`<<-`
[10:29:53.167]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:53.167]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:53.167]                   3L)]
[10:29:53.167]             }
[10:29:53.167]             function(cond) {
[10:29:53.167]                 is_error <- inherits(cond, "error")
[10:29:53.167]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:53.167]                   NULL)
[10:29:53.167]                 if (is_error) {
[10:29:53.167]                   sessionInformation <- function() {
[10:29:53.167]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:53.167]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:53.167]                       search = base::search(), system = base::Sys.info())
[10:29:53.167]                   }
[10:29:53.167]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.167]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:53.167]                     cond$call), session = sessionInformation(), 
[10:29:53.167]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:53.167]                   signalCondition(cond)
[10:29:53.167]                 }
[10:29:53.167]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:53.167]                 "immediateCondition"))) {
[10:29:53.167]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:53.167]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.167]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:53.167]                   if (TRUE && !signal) {
[10:29:53.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.167]                     {
[10:29:53.167]                       inherits <- base::inherits
[10:29:53.167]                       invokeRestart <- base::invokeRestart
[10:29:53.167]                       is.null <- base::is.null
[10:29:53.167]                       muffled <- FALSE
[10:29:53.167]                       if (inherits(cond, "message")) {
[10:29:53.167]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.167]                         if (muffled) 
[10:29:53.167]                           invokeRestart("muffleMessage")
[10:29:53.167]                       }
[10:29:53.167]                       else if (inherits(cond, "warning")) {
[10:29:53.167]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.167]                         if (muffled) 
[10:29:53.167]                           invokeRestart("muffleWarning")
[10:29:53.167]                       }
[10:29:53.167]                       else if (inherits(cond, "condition")) {
[10:29:53.167]                         if (!is.null(pattern)) {
[10:29:53.167]                           computeRestarts <- base::computeRestarts
[10:29:53.167]                           grepl <- base::grepl
[10:29:53.167]                           restarts <- computeRestarts(cond)
[10:29:53.167]                           for (restart in restarts) {
[10:29:53.167]                             name <- restart$name
[10:29:53.167]                             if (is.null(name)) 
[10:29:53.167]                               next
[10:29:53.167]                             if (!grepl(pattern, name)) 
[10:29:53.167]                               next
[10:29:53.167]                             invokeRestart(restart)
[10:29:53.167]                             muffled <- TRUE
[10:29:53.167]                             break
[10:29:53.167]                           }
[10:29:53.167]                         }
[10:29:53.167]                       }
[10:29:53.167]                       invisible(muffled)
[10:29:53.167]                     }
[10:29:53.167]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.167]                   }
[10:29:53.167]                 }
[10:29:53.167]                 else {
[10:29:53.167]                   if (TRUE) {
[10:29:53.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.167]                     {
[10:29:53.167]                       inherits <- base::inherits
[10:29:53.167]                       invokeRestart <- base::invokeRestart
[10:29:53.167]                       is.null <- base::is.null
[10:29:53.167]                       muffled <- FALSE
[10:29:53.167]                       if (inherits(cond, "message")) {
[10:29:53.167]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.167]                         if (muffled) 
[10:29:53.167]                           invokeRestart("muffleMessage")
[10:29:53.167]                       }
[10:29:53.167]                       else if (inherits(cond, "warning")) {
[10:29:53.167]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.167]                         if (muffled) 
[10:29:53.167]                           invokeRestart("muffleWarning")
[10:29:53.167]                       }
[10:29:53.167]                       else if (inherits(cond, "condition")) {
[10:29:53.167]                         if (!is.null(pattern)) {
[10:29:53.167]                           computeRestarts <- base::computeRestarts
[10:29:53.167]                           grepl <- base::grepl
[10:29:53.167]                           restarts <- computeRestarts(cond)
[10:29:53.167]                           for (restart in restarts) {
[10:29:53.167]                             name <- restart$name
[10:29:53.167]                             if (is.null(name)) 
[10:29:53.167]                               next
[10:29:53.167]                             if (!grepl(pattern, name)) 
[10:29:53.167]                               next
[10:29:53.167]                             invokeRestart(restart)
[10:29:53.167]                             muffled <- TRUE
[10:29:53.167]                             break
[10:29:53.167]                           }
[10:29:53.167]                         }
[10:29:53.167]                       }
[10:29:53.167]                       invisible(muffled)
[10:29:53.167]                     }
[10:29:53.167]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.167]                   }
[10:29:53.167]                 }
[10:29:53.167]             }
[10:29:53.167]         }))
[10:29:53.167]     }, error = function(ex) {
[10:29:53.167]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:53.167]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.167]                 ...future.rng), started = ...future.startTime, 
[10:29:53.167]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:53.167]             version = "1.8"), class = "FutureResult")
[10:29:53.167]     }, finally = {
[10:29:53.167]         if (!identical(...future.workdir, getwd())) 
[10:29:53.167]             setwd(...future.workdir)
[10:29:53.167]         {
[10:29:53.167]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:53.167]                 ...future.oldOptions$nwarnings <- NULL
[10:29:53.167]             }
[10:29:53.167]             base::options(...future.oldOptions)
[10:29:53.167]             if (.Platform$OS.type == "windows") {
[10:29:53.167]                 old_names <- names(...future.oldEnvVars)
[10:29:53.167]                 envs <- base::Sys.getenv()
[10:29:53.167]                 names <- names(envs)
[10:29:53.167]                 common <- intersect(names, old_names)
[10:29:53.167]                 added <- setdiff(names, old_names)
[10:29:53.167]                 removed <- setdiff(old_names, names)
[10:29:53.167]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:53.167]                   envs[common]]
[10:29:53.167]                 NAMES <- toupper(changed)
[10:29:53.167]                 args <- list()
[10:29:53.167]                 for (kk in seq_along(NAMES)) {
[10:29:53.167]                   name <- changed[[kk]]
[10:29:53.167]                   NAME <- NAMES[[kk]]
[10:29:53.167]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.167]                     next
[10:29:53.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.167]                 }
[10:29:53.167]                 NAMES <- toupper(added)
[10:29:53.167]                 for (kk in seq_along(NAMES)) {
[10:29:53.167]                   name <- added[[kk]]
[10:29:53.167]                   NAME <- NAMES[[kk]]
[10:29:53.167]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.167]                     next
[10:29:53.167]                   args[[name]] <- ""
[10:29:53.167]                 }
[10:29:53.167]                 NAMES <- toupper(removed)
[10:29:53.167]                 for (kk in seq_along(NAMES)) {
[10:29:53.167]                   name <- removed[[kk]]
[10:29:53.167]                   NAME <- NAMES[[kk]]
[10:29:53.167]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.167]                     next
[10:29:53.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.167]                 }
[10:29:53.167]                 if (length(args) > 0) 
[10:29:53.167]                   base::do.call(base::Sys.setenv, args = args)
[10:29:53.167]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:53.167]             }
[10:29:53.167]             else {
[10:29:53.167]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:53.167]             }
[10:29:53.167]             {
[10:29:53.167]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:53.167]                   0L) {
[10:29:53.167]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:53.167]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:53.167]                   base::options(opts)
[10:29:53.167]                 }
[10:29:53.167]                 {
[10:29:53.167]                   {
[10:29:53.167]                     NULL
[10:29:53.167]                     RNGkind("Mersenne-Twister")
[10:29:53.167]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:53.167]                       inherits = FALSE)
[10:29:53.167]                   }
[10:29:53.167]                   options(future.plan = NULL)
[10:29:53.167]                   if (is.na(NA_character_)) 
[10:29:53.167]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.167]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:53.167]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:53.167]                     .init = FALSE)
[10:29:53.167]                 }
[10:29:53.167]             }
[10:29:53.167]         }
[10:29:53.167]     })
[10:29:53.167]     if (TRUE) {
[10:29:53.167]         base::sink(type = "output", split = FALSE)
[10:29:53.167]         if (TRUE) {
[10:29:53.167]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:53.167]         }
[10:29:53.167]         else {
[10:29:53.167]             ...future.result["stdout"] <- base::list(NULL)
[10:29:53.167]         }
[10:29:53.167]         base::close(...future.stdout)
[10:29:53.167]         ...future.stdout <- NULL
[10:29:53.167]     }
[10:29:53.167]     ...future.result$conditions <- ...future.conditions
[10:29:53.167]     ...future.result$finished <- base::Sys.time()
[10:29:53.167]     ...future.result
[10:29:53.167] }
[10:29:53.169] assign_globals() ...
[10:29:53.169] List of 5
[10:29:53.169]  $ ...future.FUN            :function (object, ...)  
[10:29:53.169]  $ future.call.arguments    : list()
[10:29:53.169]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.169]  $ ...future.elements_ii    :List of 3
[10:29:53.169]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.169]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:29:53.169]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.169]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:53.169]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.169]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:29:53.169]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.169]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:29:53.169]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.169]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:29:53.169]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.169]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:29:53.169]  $ ...future.seeds_ii       : NULL
[10:29:53.169]  $ ...future.globals.maxSize: NULL
[10:29:53.169]  - attr(*, "where")=List of 5
[10:29:53.169]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:53.169]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:53.169]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:53.169]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:53.169]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:53.169]  - attr(*, "resolved")= logi FALSE
[10:29:53.169]  - attr(*, "total_size")= num 1240
[10:29:53.169]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.169]  - attr(*, "already-done")= logi TRUE
[10:29:53.178] - copied ‘...future.FUN’ to environment
[10:29:53.179] - copied ‘future.call.arguments’ to environment
[10:29:53.180] - copied ‘...future.elements_ii’ to environment
[10:29:53.180] - copied ‘...future.seeds_ii’ to environment
[10:29:53.180] - copied ‘...future.globals.maxSize’ to environment
[10:29:53.180] assign_globals() ... done
[10:29:53.180] plan(): Setting new future strategy stack:
[10:29:53.180] List of future strategies:
[10:29:53.180] 1. sequential:
[10:29:53.180]    - args: function (..., envir = parent.frame())
[10:29:53.180]    - tweaked: FALSE
[10:29:53.180]    - call: NULL
[10:29:53.181] plan(): nbrOfWorkers() = 1
[10:29:53.183] plan(): Setting new future strategy stack:
[10:29:53.183] List of future strategies:
[10:29:53.183] 1. sequential:
[10:29:53.183]    - args: function (..., envir = parent.frame())
[10:29:53.183]    - tweaked: FALSE
[10:29:53.183]    - call: plan(strategy)
[10:29:53.183] plan(): nbrOfWorkers() = 1
[10:29:53.183] SequentialFuture started (and completed)
[10:29:53.184] - Launch lazy future ... done
[10:29:53.184] run() for ‘SequentialFuture’ ... done
[10:29:53.184] Created future:
[10:29:53.184] SequentialFuture:
[10:29:53.184] Label: ‘future_by-1’
[10:29:53.184] Expression:
[10:29:53.184] {
[10:29:53.184]     do.call(function(...) {
[10:29:53.184]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.184]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.184]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.184]             on.exit(options(oopts), add = TRUE)
[10:29:53.184]         }
[10:29:53.184]         {
[10:29:53.184]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.184]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.184]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.184]             })
[10:29:53.184]         }
[10:29:53.184]     }, args = future.call.arguments)
[10:29:53.184] }
[10:29:53.184] Lazy evaluation: FALSE
[10:29:53.184] Asynchronous evaluation: FALSE
[10:29:53.184] Local evaluation: TRUE
[10:29:53.184] Environment: 0x556dd4f4e410
[10:29:53.184] Capture standard output: TRUE
[10:29:53.184] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:53.184] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:53.184] Packages: <none>
[10:29:53.184] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:53.184] Resolved: TRUE
[10:29:53.184] Value: 5.37 KiB of class ‘list’
[10:29:53.184] Early signaling: FALSE
[10:29:53.184] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:53.184] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.185] Chunk #1 of 1 ... DONE
[10:29:53.185] Launching 1 futures (chunks) ... DONE
[10:29:53.185] Resolving 1 futures (chunks) ...
[10:29:53.186] resolve() on list ...
[10:29:53.186]  recursive: 0
[10:29:53.186]  length: 1
[10:29:53.186] 
[10:29:53.186] resolved() for ‘SequentialFuture’ ...
[10:29:53.186] - state: ‘finished’
[10:29:53.186] - run: TRUE
[10:29:53.186] - result: ‘FutureResult’
[10:29:53.186] resolved() for ‘SequentialFuture’ ... done
[10:29:53.186] Future #1
[10:29:53.187] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:53.187] - nx: 1
[10:29:53.187] - relay: TRUE
[10:29:53.187] - stdout: TRUE
[10:29:53.187] - signal: TRUE
[10:29:53.187] - resignal: FALSE
[10:29:53.187] - force: TRUE
[10:29:53.187] - relayed: [n=1] FALSE
[10:29:53.187] - queued futures: [n=1] FALSE
[10:29:53.187]  - until=1
[10:29:53.187]  - relaying element #1
[10:29:53.188] - relayed: [n=1] TRUE
[10:29:53.188] - queued futures: [n=1] TRUE
[10:29:53.188] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:53.188]  length: 0 (resolved future 1)
[10:29:53.188] Relaying remaining futures
[10:29:53.188] signalConditionsASAP(NULL, pos=0) ...
[10:29:53.188] - nx: 1
[10:29:53.188] - relay: TRUE
[10:29:53.188] - stdout: TRUE
[10:29:53.188] - signal: TRUE
[10:29:53.188] - resignal: FALSE
[10:29:53.189] - force: TRUE
[10:29:53.189] - relayed: [n=1] TRUE
[10:29:53.189] - queued futures: [n=1] TRUE
 - flush all
[10:29:53.189] - relayed: [n=1] TRUE
[10:29:53.189] - queued futures: [n=1] TRUE
[10:29:53.189] signalConditionsASAP(NULL, pos=0) ... done
[10:29:53.189] resolve() on list ... DONE
[10:29:53.189]  - Number of value chunks collected: 1
[10:29:53.189] Resolving 1 futures (chunks) ... DONE
[10:29:53.189] Reducing values from 1 chunks ...
[10:29:53.190]  - Number of values collected after concatenation: 3
[10:29:53.190]  - Number of values expected: 3
[10:29:53.190] Reducing values from 1 chunks ... DONE
[10:29:53.190] future_lapply() ... DONE
[10:29:53.190] future_by_internal() ... DONE
[10:29:53.192] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[10:29:53.192] future_lapply() ...
[10:29:53.193] Number of chunks: 1
[10:29:53.193] getGlobalsAndPackagesXApply() ...
[10:29:53.193]  - future.globals: TRUE
[10:29:53.193] getGlobalsAndPackages() ...
[10:29:53.193] Searching for globals...
[10:29:53.194] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:53.194] Searching for globals ... DONE
[10:29:53.195] Resolving globals: FALSE
[10:29:53.195] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:53.195] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:53.195] - globals: [1] ‘FUN’
[10:29:53.195] 
[10:29:53.196] getGlobalsAndPackages() ... DONE
[10:29:53.196]  - globals found/used: [n=1] ‘FUN’
[10:29:53.196]  - needed namespaces: [n=0] 
[10:29:53.196] Finding globals ... DONE
[10:29:53.196]  - use_args: TRUE
[10:29:53.196]  - Getting '...' globals ...
[10:29:53.196] resolve() on list ...
[10:29:53.196]  recursive: 0
[10:29:53.196]  length: 1
[10:29:53.197]  elements: ‘...’
[10:29:53.197]  length: 0 (resolved future 1)
[10:29:53.197] resolve() on list ... DONE
[10:29:53.197]    - '...' content: [n=0] 
[10:29:53.197] List of 1
[10:29:53.197]  $ ...: list()
[10:29:53.197]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.197]  - attr(*, "where")=List of 1
[10:29:53.197]   ..$ ...:<environment: 0x556dd5103168> 
[10:29:53.197]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.197]  - attr(*, "resolved")= logi TRUE
[10:29:53.197]  - attr(*, "total_size")= num NA
[10:29:53.201]  - Getting '...' globals ... DONE
[10:29:53.201] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:53.201] List of 2
[10:29:53.201]  $ ...future.FUN:function (object, ...)  
[10:29:53.201]  $ ...          : list()
[10:29:53.201]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.201]  - attr(*, "where")=List of 2
[10:29:53.201]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:53.201]   ..$ ...          :<environment: 0x556dd5103168> 
[10:29:53.201]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.201]  - attr(*, "resolved")= logi FALSE
[10:29:53.201]  - attr(*, "total_size")= num 1240
[10:29:53.204] Packages to be attached in all futures: [n=0] 
[10:29:53.204] getGlobalsAndPackagesXApply() ... DONE
[10:29:53.204] Number of futures (= number of chunks): 1
[10:29:53.204] Launching 1 futures (chunks) ...
[10:29:53.204] Chunk #1 of 1 ...
[10:29:53.204]  - Finding globals in 'X' for chunk #1 ...
[10:29:53.205] getGlobalsAndPackages() ...
[10:29:53.205] Searching for globals...
[10:29:53.205] 
[10:29:53.205] Searching for globals ... DONE
[10:29:53.205] - globals: [0] <none>
[10:29:53.205] getGlobalsAndPackages() ... DONE
[10:29:53.206]    + additional globals found: [n=0] 
[10:29:53.206]    + additional namespaces needed: [n=0] 
[10:29:53.206]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:53.206]  - seeds: <none>
[10:29:53.206]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.206] getGlobalsAndPackages() ...
[10:29:53.206] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.206] Resolving globals: FALSE
[10:29:53.206] Tweak future expression to call with '...' arguments ...
[10:29:53.206] {
[10:29:53.206]     do.call(function(...) {
[10:29:53.206]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.206]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.206]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.206]             on.exit(options(oopts), add = TRUE)
[10:29:53.206]         }
[10:29:53.206]         {
[10:29:53.206]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.206]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.206]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.206]             })
[10:29:53.206]         }
[10:29:53.206]     }, args = future.call.arguments)
[10:29:53.206] }
[10:29:53.207] Tweak future expression to call with '...' arguments ... DONE
[10:29:53.207] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.207] 
[10:29:53.207] getGlobalsAndPackages() ... DONE
[10:29:53.207] run() for ‘Future’ ...
[10:29:53.208] - state: ‘created’
[10:29:53.208] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:29:53.208] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.208] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:53.208]   - Field: ‘label’
[10:29:53.208]   - Field: ‘local’
[10:29:53.208]   - Field: ‘owner’
[10:29:53.209]   - Field: ‘envir’
[10:29:53.209]   - Field: ‘packages’
[10:29:53.209]   - Field: ‘gc’
[10:29:53.209]   - Field: ‘conditions’
[10:29:53.209]   - Field: ‘expr’
[10:29:53.209]   - Field: ‘uuid’
[10:29:53.209]   - Field: ‘seed’
[10:29:53.209]   - Field: ‘version’
[10:29:53.209]   - Field: ‘result’
[10:29:53.209]   - Field: ‘asynchronous’
[10:29:53.209]   - Field: ‘calls’
[10:29:53.210]   - Field: ‘globals’
[10:29:53.210]   - Field: ‘stdout’
[10:29:53.210]   - Field: ‘earlySignal’
[10:29:53.210]   - Field: ‘lazy’
[10:29:53.210]   - Field: ‘state’
[10:29:53.210] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:53.210] - Launch lazy future ...
[10:29:53.210] Packages needed by the future expression (n = 0): <none>
[10:29:53.210] Packages needed by future strategies (n = 0): <none>
[10:29:53.211] {
[10:29:53.211]     {
[10:29:53.211]         {
[10:29:53.211]             ...future.startTime <- base::Sys.time()
[10:29:53.211]             {
[10:29:53.211]                 {
[10:29:53.211]                   {
[10:29:53.211]                     base::local({
[10:29:53.211]                       has_future <- base::requireNamespace("future", 
[10:29:53.211]                         quietly = TRUE)
[10:29:53.211]                       if (has_future) {
[10:29:53.211]                         ns <- base::getNamespace("future")
[10:29:53.211]                         version <- ns[[".package"]][["version"]]
[10:29:53.211]                         if (is.null(version)) 
[10:29:53.211]                           version <- utils::packageVersion("future")
[10:29:53.211]                       }
[10:29:53.211]                       else {
[10:29:53.211]                         version <- NULL
[10:29:53.211]                       }
[10:29:53.211]                       if (!has_future || version < "1.8.0") {
[10:29:53.211]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:53.211]                           "", base::R.version$version.string), 
[10:29:53.211]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:53.211]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:53.211]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:53.211]                             "release", "version")], collapse = " "), 
[10:29:53.211]                           hostname = base::Sys.info()[["nodename"]])
[10:29:53.211]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:53.211]                           info)
[10:29:53.211]                         info <- base::paste(info, collapse = "; ")
[10:29:53.211]                         if (!has_future) {
[10:29:53.211]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:53.211]                             info)
[10:29:53.211]                         }
[10:29:53.211]                         else {
[10:29:53.211]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:53.211]                             info, version)
[10:29:53.211]                         }
[10:29:53.211]                         base::stop(msg)
[10:29:53.211]                       }
[10:29:53.211]                     })
[10:29:53.211]                   }
[10:29:53.211]                   ...future.strategy.old <- future::plan("list")
[10:29:53.211]                   options(future.plan = NULL)
[10:29:53.211]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.211]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:53.211]                 }
[10:29:53.211]                 ...future.workdir <- getwd()
[10:29:53.211]             }
[10:29:53.211]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:53.211]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:53.211]         }
[10:29:53.211]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:53.211]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:53.211]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:53.211]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:53.211]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:53.211]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:53.211]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:53.211]             base::names(...future.oldOptions))
[10:29:53.211]     }
[10:29:53.211]     if (FALSE) {
[10:29:53.211]     }
[10:29:53.211]     else {
[10:29:53.211]         if (TRUE) {
[10:29:53.211]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:53.211]                 open = "w")
[10:29:53.211]         }
[10:29:53.211]         else {
[10:29:53.211]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:53.211]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:53.211]         }
[10:29:53.211]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:53.211]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:53.211]             base::sink(type = "output", split = FALSE)
[10:29:53.211]             base::close(...future.stdout)
[10:29:53.211]         }, add = TRUE)
[10:29:53.211]     }
[10:29:53.211]     ...future.frame <- base::sys.nframe()
[10:29:53.211]     ...future.conditions <- base::list()
[10:29:53.211]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:53.211]     if (FALSE) {
[10:29:53.211]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:53.211]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:53.211]     }
[10:29:53.211]     ...future.result <- base::tryCatch({
[10:29:53.211]         base::withCallingHandlers({
[10:29:53.211]             ...future.value <- base::withVisible(base::local({
[10:29:53.211]                 do.call(function(...) {
[10:29:53.211]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.211]                   if (!identical(...future.globals.maxSize.org, 
[10:29:53.211]                     ...future.globals.maxSize)) {
[10:29:53.211]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.211]                     on.exit(options(oopts), add = TRUE)
[10:29:53.211]                   }
[10:29:53.211]                   {
[10:29:53.211]                     lapply(seq_along(...future.elements_ii), 
[10:29:53.211]                       FUN = function(jj) {
[10:29:53.211]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.211]                         ...future.FUN(...future.X_jj, ...)
[10:29:53.211]                       })
[10:29:53.211]                   }
[10:29:53.211]                 }, args = future.call.arguments)
[10:29:53.211]             }))
[10:29:53.211]             future::FutureResult(value = ...future.value$value, 
[10:29:53.211]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.211]                   ...future.rng), globalenv = if (FALSE) 
[10:29:53.211]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:53.211]                     ...future.globalenv.names))
[10:29:53.211]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:53.211]         }, condition = base::local({
[10:29:53.211]             c <- base::c
[10:29:53.211]             inherits <- base::inherits
[10:29:53.211]             invokeRestart <- base::invokeRestart
[10:29:53.211]             length <- base::length
[10:29:53.211]             list <- base::list
[10:29:53.211]             seq.int <- base::seq.int
[10:29:53.211]             signalCondition <- base::signalCondition
[10:29:53.211]             sys.calls <- base::sys.calls
[10:29:53.211]             `[[` <- base::`[[`
[10:29:53.211]             `+` <- base::`+`
[10:29:53.211]             `<<-` <- base::`<<-`
[10:29:53.211]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:53.211]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:53.211]                   3L)]
[10:29:53.211]             }
[10:29:53.211]             function(cond) {
[10:29:53.211]                 is_error <- inherits(cond, "error")
[10:29:53.211]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:53.211]                   NULL)
[10:29:53.211]                 if (is_error) {
[10:29:53.211]                   sessionInformation <- function() {
[10:29:53.211]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:53.211]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:53.211]                       search = base::search(), system = base::Sys.info())
[10:29:53.211]                   }
[10:29:53.211]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.211]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:53.211]                     cond$call), session = sessionInformation(), 
[10:29:53.211]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:53.211]                   signalCondition(cond)
[10:29:53.211]                 }
[10:29:53.211]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:53.211]                 "immediateCondition"))) {
[10:29:53.211]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:53.211]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.211]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:53.211]                   if (TRUE && !signal) {
[10:29:53.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.211]                     {
[10:29:53.211]                       inherits <- base::inherits
[10:29:53.211]                       invokeRestart <- base::invokeRestart
[10:29:53.211]                       is.null <- base::is.null
[10:29:53.211]                       muffled <- FALSE
[10:29:53.211]                       if (inherits(cond, "message")) {
[10:29:53.211]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.211]                         if (muffled) 
[10:29:53.211]                           invokeRestart("muffleMessage")
[10:29:53.211]                       }
[10:29:53.211]                       else if (inherits(cond, "warning")) {
[10:29:53.211]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.211]                         if (muffled) 
[10:29:53.211]                           invokeRestart("muffleWarning")
[10:29:53.211]                       }
[10:29:53.211]                       else if (inherits(cond, "condition")) {
[10:29:53.211]                         if (!is.null(pattern)) {
[10:29:53.211]                           computeRestarts <- base::computeRestarts
[10:29:53.211]                           grepl <- base::grepl
[10:29:53.211]                           restarts <- computeRestarts(cond)
[10:29:53.211]                           for (restart in restarts) {
[10:29:53.211]                             name <- restart$name
[10:29:53.211]                             if (is.null(name)) 
[10:29:53.211]                               next
[10:29:53.211]                             if (!grepl(pattern, name)) 
[10:29:53.211]                               next
[10:29:53.211]                             invokeRestart(restart)
[10:29:53.211]                             muffled <- TRUE
[10:29:53.211]                             break
[10:29:53.211]                           }
[10:29:53.211]                         }
[10:29:53.211]                       }
[10:29:53.211]                       invisible(muffled)
[10:29:53.211]                     }
[10:29:53.211]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.211]                   }
[10:29:53.211]                 }
[10:29:53.211]                 else {
[10:29:53.211]                   if (TRUE) {
[10:29:53.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.211]                     {
[10:29:53.211]                       inherits <- base::inherits
[10:29:53.211]                       invokeRestart <- base::invokeRestart
[10:29:53.211]                       is.null <- base::is.null
[10:29:53.211]                       muffled <- FALSE
[10:29:53.211]                       if (inherits(cond, "message")) {
[10:29:53.211]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.211]                         if (muffled) 
[10:29:53.211]                           invokeRestart("muffleMessage")
[10:29:53.211]                       }
[10:29:53.211]                       else if (inherits(cond, "warning")) {
[10:29:53.211]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.211]                         if (muffled) 
[10:29:53.211]                           invokeRestart("muffleWarning")
[10:29:53.211]                       }
[10:29:53.211]                       else if (inherits(cond, "condition")) {
[10:29:53.211]                         if (!is.null(pattern)) {
[10:29:53.211]                           computeRestarts <- base::computeRestarts
[10:29:53.211]                           grepl <- base::grepl
[10:29:53.211]                           restarts <- computeRestarts(cond)
[10:29:53.211]                           for (restart in restarts) {
[10:29:53.211]                             name <- restart$name
[10:29:53.211]                             if (is.null(name)) 
[10:29:53.211]                               next
[10:29:53.211]                             if (!grepl(pattern, name)) 
[10:29:53.211]                               next
[10:29:53.211]                             invokeRestart(restart)
[10:29:53.211]                             muffled <- TRUE
[10:29:53.211]                             break
[10:29:53.211]                           }
[10:29:53.211]                         }
[10:29:53.211]                       }
[10:29:53.211]                       invisible(muffled)
[10:29:53.211]                     }
[10:29:53.211]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.211]                   }
[10:29:53.211]                 }
[10:29:53.211]             }
[10:29:53.211]         }))
[10:29:53.211]     }, error = function(ex) {
[10:29:53.211]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:53.211]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.211]                 ...future.rng), started = ...future.startTime, 
[10:29:53.211]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:53.211]             version = "1.8"), class = "FutureResult")
[10:29:53.211]     }, finally = {
[10:29:53.211]         if (!identical(...future.workdir, getwd())) 
[10:29:53.211]             setwd(...future.workdir)
[10:29:53.211]         {
[10:29:53.211]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:53.211]                 ...future.oldOptions$nwarnings <- NULL
[10:29:53.211]             }
[10:29:53.211]             base::options(...future.oldOptions)
[10:29:53.211]             if (.Platform$OS.type == "windows") {
[10:29:53.211]                 old_names <- names(...future.oldEnvVars)
[10:29:53.211]                 envs <- base::Sys.getenv()
[10:29:53.211]                 names <- names(envs)
[10:29:53.211]                 common <- intersect(names, old_names)
[10:29:53.211]                 added <- setdiff(names, old_names)
[10:29:53.211]                 removed <- setdiff(old_names, names)
[10:29:53.211]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:53.211]                   envs[common]]
[10:29:53.211]                 NAMES <- toupper(changed)
[10:29:53.211]                 args <- list()
[10:29:53.211]                 for (kk in seq_along(NAMES)) {
[10:29:53.211]                   name <- changed[[kk]]
[10:29:53.211]                   NAME <- NAMES[[kk]]
[10:29:53.211]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.211]                     next
[10:29:53.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.211]                 }
[10:29:53.211]                 NAMES <- toupper(added)
[10:29:53.211]                 for (kk in seq_along(NAMES)) {
[10:29:53.211]                   name <- added[[kk]]
[10:29:53.211]                   NAME <- NAMES[[kk]]
[10:29:53.211]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.211]                     next
[10:29:53.211]                   args[[name]] <- ""
[10:29:53.211]                 }
[10:29:53.211]                 NAMES <- toupper(removed)
[10:29:53.211]                 for (kk in seq_along(NAMES)) {
[10:29:53.211]                   name <- removed[[kk]]
[10:29:53.211]                   NAME <- NAMES[[kk]]
[10:29:53.211]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.211]                     next
[10:29:53.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.211]                 }
[10:29:53.211]                 if (length(args) > 0) 
[10:29:53.211]                   base::do.call(base::Sys.setenv, args = args)
[10:29:53.211]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:53.211]             }
[10:29:53.211]             else {
[10:29:53.211]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:53.211]             }
[10:29:53.211]             {
[10:29:53.211]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:53.211]                   0L) {
[10:29:53.211]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:53.211]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:53.211]                   base::options(opts)
[10:29:53.211]                 }
[10:29:53.211]                 {
[10:29:53.211]                   {
[10:29:53.211]                     NULL
[10:29:53.211]                     RNGkind("Mersenne-Twister")
[10:29:53.211]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:53.211]                       inherits = FALSE)
[10:29:53.211]                   }
[10:29:53.211]                   options(future.plan = NULL)
[10:29:53.211]                   if (is.na(NA_character_)) 
[10:29:53.211]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.211]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:53.211]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:53.211]                     .init = FALSE)
[10:29:53.211]                 }
[10:29:53.211]             }
[10:29:53.211]         }
[10:29:53.211]     })
[10:29:53.211]     if (TRUE) {
[10:29:53.211]         base::sink(type = "output", split = FALSE)
[10:29:53.211]         if (TRUE) {
[10:29:53.211]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:53.211]         }
[10:29:53.211]         else {
[10:29:53.211]             ...future.result["stdout"] <- base::list(NULL)
[10:29:53.211]         }
[10:29:53.211]         base::close(...future.stdout)
[10:29:53.211]         ...future.stdout <- NULL
[10:29:53.211]     }
[10:29:53.211]     ...future.result$conditions <- ...future.conditions
[10:29:53.211]     ...future.result$finished <- base::Sys.time()
[10:29:53.211]     ...future.result
[10:29:53.211] }
[10:29:53.212] assign_globals() ...
[10:29:53.213] List of 5
[10:29:53.213]  $ ...future.FUN            :function (object, ...)  
[10:29:53.213]  $ future.call.arguments    : list()
[10:29:53.213]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.213]  $ ...future.elements_ii    :List of 3
[10:29:53.213]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.213]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:29:53.213]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.213]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:53.213]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.213]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:29:53.213]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.213]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:29:53.213]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.213]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:29:53.213]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.213]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:29:53.213]  $ ...future.seeds_ii       : NULL
[10:29:53.213]  $ ...future.globals.maxSize: NULL
[10:29:53.213]  - attr(*, "where")=List of 5
[10:29:53.213]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:53.213]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:53.213]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:53.213]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:53.213]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:53.213]  - attr(*, "resolved")= logi FALSE
[10:29:53.213]  - attr(*, "total_size")= num 1240
[10:29:53.213]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.213]  - attr(*, "already-done")= logi TRUE
[10:29:53.222] - copied ‘...future.FUN’ to environment
[10:29:53.222] - copied ‘future.call.arguments’ to environment
[10:29:53.223] - copied ‘...future.elements_ii’ to environment
[10:29:53.223] - copied ‘...future.seeds_ii’ to environment
[10:29:53.223] - copied ‘...future.globals.maxSize’ to environment
[10:29:53.223] assign_globals() ... done
[10:29:53.223] plan(): Setting new future strategy stack:
[10:29:53.223] List of future strategies:
[10:29:53.223] 1. sequential:
[10:29:53.223]    - args: function (..., envir = parent.frame())
[10:29:53.223]    - tweaked: FALSE
[10:29:53.223]    - call: NULL
[10:29:53.224] plan(): nbrOfWorkers() = 1
[10:29:53.226] plan(): Setting new future strategy stack:
[10:29:53.226] List of future strategies:
[10:29:53.226] 1. sequential:
[10:29:53.226]    - args: function (..., envir = parent.frame())
[10:29:53.226]    - tweaked: FALSE
[10:29:53.226]    - call: plan(strategy)
[10:29:53.226] plan(): nbrOfWorkers() = 1
[10:29:53.226] SequentialFuture started (and completed)
[10:29:53.226] - Launch lazy future ... done
[10:29:53.227] run() for ‘SequentialFuture’ ... done
[10:29:53.227] Created future:
[10:29:53.227] SequentialFuture:
[10:29:53.227] Label: ‘future_by-1’
[10:29:53.227] Expression:
[10:29:53.227] {
[10:29:53.227]     do.call(function(...) {
[10:29:53.227]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.227]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.227]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.227]             on.exit(options(oopts), add = TRUE)
[10:29:53.227]         }
[10:29:53.227]         {
[10:29:53.227]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.227]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.227]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.227]             })
[10:29:53.227]         }
[10:29:53.227]     }, args = future.call.arguments)
[10:29:53.227] }
[10:29:53.227] Lazy evaluation: FALSE
[10:29:53.227] Asynchronous evaluation: FALSE
[10:29:53.227] Local evaluation: TRUE
[10:29:53.227] Environment: 0x556dd5001bd0
[10:29:53.227] Capture standard output: TRUE
[10:29:53.227] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:53.227] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:53.227] Packages: <none>
[10:29:53.227] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:53.227] Resolved: TRUE
[10:29:53.227] Value: 5.37 KiB of class ‘list’
[10:29:53.227] Early signaling: FALSE
[10:29:53.227] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:53.227] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.228] Chunk #1 of 1 ... DONE
[10:29:53.228] Launching 1 futures (chunks) ... DONE
[10:29:53.228] Resolving 1 futures (chunks) ...
[10:29:53.228] resolve() on list ...
[10:29:53.228]  recursive: 0
[10:29:53.228]  length: 1
[10:29:53.229] 
[10:29:53.229] resolved() for ‘SequentialFuture’ ...
[10:29:53.229] - state: ‘finished’
[10:29:53.229] - run: TRUE
[10:29:53.229] - result: ‘FutureResult’
[10:29:53.229] resolved() for ‘SequentialFuture’ ... done
[10:29:53.229] Future #1
[10:29:53.229] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:53.229] - nx: 1
[10:29:53.229] - relay: TRUE
[10:29:53.230] - stdout: TRUE
[10:29:53.230] - signal: TRUE
[10:29:53.230] - resignal: FALSE
[10:29:53.230] - force: TRUE
[10:29:53.230] - relayed: [n=1] FALSE
[10:29:53.230] - queued futures: [n=1] FALSE
[10:29:53.230]  - until=1
[10:29:53.230]  - relaying element #1
[10:29:53.230] - relayed: [n=1] TRUE
[10:29:53.230] - queued futures: [n=1] TRUE
[10:29:53.230] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:53.231]  length: 0 (resolved future 1)
[10:29:53.231] Relaying remaining futures
[10:29:53.231] signalConditionsASAP(NULL, pos=0) ...
[10:29:53.231] - nx: 1
[10:29:53.231] - relay: TRUE
[10:29:53.231] - stdout: TRUE
[10:29:53.231] - signal: TRUE
[10:29:53.231] - resignal: FALSE
[10:29:53.231] - force: TRUE
[10:29:53.231] - relayed: [n=1] TRUE
[10:29:53.231] - queued futures: [n=1] TRUE
 - flush all
[10:29:53.232] - relayed: [n=1] TRUE
[10:29:53.232] - queued futures: [n=1] TRUE
[10:29:53.232] signalConditionsASAP(NULL, pos=0) ... done
[10:29:53.232] resolve() on list ... DONE
[10:29:53.232]  - Number of value chunks collected: 1
[10:29:53.232] Resolving 1 futures (chunks) ... DONE
[10:29:53.232] Reducing values from 1 chunks ...
[10:29:53.232]  - Number of values collected after concatenation: 3
[10:29:53.232]  - Number of values expected: 3
[10:29:53.232] Reducing values from 1 chunks ... DONE
[10:29:53.232] future_lapply() ... DONE
[10:29:53.233] future_by_internal() ... DONE
[10:29:53.233] future_by_internal() ...
- plan('multicore') ...
[10:29:53.234] plan(): Setting new future strategy stack:
[10:29:53.234] List of future strategies:
[10:29:53.234] 1. multicore:
[10:29:53.234]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:53.234]    - tweaked: FALSE
[10:29:53.234]    - call: plan(strategy)
[10:29:53.238] plan(): nbrOfWorkers() = 1
[10:29:53.238] future_by_internal() ...
[10:29:53.238] future_lapply() ...
[10:29:53.242] Number of chunks: 1
[10:29:53.242] getGlobalsAndPackagesXApply() ...
[10:29:53.242]  - future.globals: TRUE
[10:29:53.242] getGlobalsAndPackages() ...
[10:29:53.242] Searching for globals...
[10:29:53.243] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:53.245] Searching for globals ... DONE
[10:29:53.245] Resolving globals: FALSE
[10:29:53.246] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:53.246] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:53.246] - globals: [1] ‘FUN’
[10:29:53.246] 
[10:29:53.246] getGlobalsAndPackages() ... DONE
[10:29:53.246]  - globals found/used: [n=1] ‘FUN’
[10:29:53.246]  - needed namespaces: [n=0] 
[10:29:53.247] Finding globals ... DONE
[10:29:53.247]  - use_args: TRUE
[10:29:53.247]  - Getting '...' globals ...
[10:29:53.247] resolve() on list ...
[10:29:53.247]  recursive: 0
[10:29:53.247]  length: 1
[10:29:53.247]  elements: ‘...’
[10:29:53.247]  length: 0 (resolved future 1)
[10:29:53.247] resolve() on list ... DONE
[10:29:53.248]    - '...' content: [n=0] 
[10:29:53.248] List of 1
[10:29:53.248]  $ ...: list()
[10:29:53.248]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.248]  - attr(*, "where")=List of 1
[10:29:53.248]   ..$ ...:<environment: 0x556dd52bcb90> 
[10:29:53.248]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.248]  - attr(*, "resolved")= logi TRUE
[10:29:53.248]  - attr(*, "total_size")= num NA
[10:29:53.250]  - Getting '...' globals ... DONE
[10:29:53.250] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:53.250] List of 2
[10:29:53.250]  $ ...future.FUN:function (object, ...)  
[10:29:53.250]  $ ...          : list()
[10:29:53.250]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.250]  - attr(*, "where")=List of 2
[10:29:53.250]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:53.250]   ..$ ...          :<environment: 0x556dd52bcb90> 
[10:29:53.250]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.250]  - attr(*, "resolved")= logi FALSE
[10:29:53.250]  - attr(*, "total_size")= num 1240
[10:29:53.253] Packages to be attached in all futures: [n=0] 
[10:29:53.253] getGlobalsAndPackagesXApply() ... DONE
[10:29:53.253] Number of futures (= number of chunks): 1
[10:29:53.254] Launching 1 futures (chunks) ...
[10:29:53.254] Chunk #1 of 1 ...
[10:29:53.254]  - Finding globals in 'X' for chunk #1 ...
[10:29:53.254] getGlobalsAndPackages() ...
[10:29:53.254] Searching for globals...
[10:29:53.254] 
[10:29:53.255] Searching for globals ... DONE
[10:29:53.255] - globals: [0] <none>
[10:29:53.255] getGlobalsAndPackages() ... DONE
[10:29:53.255]    + additional globals found: [n=0] 
[10:29:53.255]    + additional namespaces needed: [n=0] 
[10:29:53.255]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:53.255]  - seeds: <none>
[10:29:53.255]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.255] getGlobalsAndPackages() ...
[10:29:53.255] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.256] Resolving globals: FALSE
[10:29:53.256] Tweak future expression to call with '...' arguments ...
[10:29:53.256] {
[10:29:53.256]     do.call(function(...) {
[10:29:53.256]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.256]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.256]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.256]             on.exit(options(oopts), add = TRUE)
[10:29:53.256]         }
[10:29:53.256]         {
[10:29:53.256]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.256]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.256]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.256]             })
[10:29:53.256]         }
[10:29:53.256]     }, args = future.call.arguments)
[10:29:53.256] }
[10:29:53.256] Tweak future expression to call with '...' arguments ... DONE
[10:29:53.256] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.257] 
[10:29:53.257] getGlobalsAndPackages() ... DONE
[10:29:53.257] run() for ‘Future’ ...
[10:29:53.257] - state: ‘created’
[10:29:53.257] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:53.261] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.261] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:53.261]   - Field: ‘label’
[10:29:53.261]   - Field: ‘local’
[10:29:53.261]   - Field: ‘owner’
[10:29:53.261]   - Field: ‘envir’
[10:29:53.261]   - Field: ‘packages’
[10:29:53.261]   - Field: ‘gc’
[10:29:53.262]   - Field: ‘conditions’
[10:29:53.262]   - Field: ‘expr’
[10:29:53.262]   - Field: ‘uuid’
[10:29:53.262]   - Field: ‘seed’
[10:29:53.262]   - Field: ‘version’
[10:29:53.262]   - Field: ‘result’
[10:29:53.262]   - Field: ‘asynchronous’
[10:29:53.262]   - Field: ‘calls’
[10:29:53.262]   - Field: ‘globals’
[10:29:53.262]   - Field: ‘stdout’
[10:29:53.262]   - Field: ‘earlySignal’
[10:29:53.263]   - Field: ‘lazy’
[10:29:53.263]   - Field: ‘state’
[10:29:53.263] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:53.263] - Launch lazy future ...
[10:29:53.263] Packages needed by the future expression (n = 0): <none>
[10:29:53.263] Packages needed by future strategies (n = 0): <none>
[10:29:53.264] {
[10:29:53.264]     {
[10:29:53.264]         {
[10:29:53.264]             ...future.startTime <- base::Sys.time()
[10:29:53.264]             {
[10:29:53.264]                 {
[10:29:53.264]                   {
[10:29:53.264]                     base::local({
[10:29:53.264]                       has_future <- base::requireNamespace("future", 
[10:29:53.264]                         quietly = TRUE)
[10:29:53.264]                       if (has_future) {
[10:29:53.264]                         ns <- base::getNamespace("future")
[10:29:53.264]                         version <- ns[[".package"]][["version"]]
[10:29:53.264]                         if (is.null(version)) 
[10:29:53.264]                           version <- utils::packageVersion("future")
[10:29:53.264]                       }
[10:29:53.264]                       else {
[10:29:53.264]                         version <- NULL
[10:29:53.264]                       }
[10:29:53.264]                       if (!has_future || version < "1.8.0") {
[10:29:53.264]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:53.264]                           "", base::R.version$version.string), 
[10:29:53.264]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:53.264]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:53.264]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:53.264]                             "release", "version")], collapse = " "), 
[10:29:53.264]                           hostname = base::Sys.info()[["nodename"]])
[10:29:53.264]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:53.264]                           info)
[10:29:53.264]                         info <- base::paste(info, collapse = "; ")
[10:29:53.264]                         if (!has_future) {
[10:29:53.264]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:53.264]                             info)
[10:29:53.264]                         }
[10:29:53.264]                         else {
[10:29:53.264]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:53.264]                             info, version)
[10:29:53.264]                         }
[10:29:53.264]                         base::stop(msg)
[10:29:53.264]                       }
[10:29:53.264]                     })
[10:29:53.264]                   }
[10:29:53.264]                   ...future.strategy.old <- future::plan("list")
[10:29:53.264]                   options(future.plan = NULL)
[10:29:53.264]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.264]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:53.264]                 }
[10:29:53.264]                 ...future.workdir <- getwd()
[10:29:53.264]             }
[10:29:53.264]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:53.264]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:53.264]         }
[10:29:53.264]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:53.264]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:53.264]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:53.264]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:53.264]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:53.264]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:53.264]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:53.264]             base::names(...future.oldOptions))
[10:29:53.264]     }
[10:29:53.264]     if (FALSE) {
[10:29:53.264]     }
[10:29:53.264]     else {
[10:29:53.264]         if (TRUE) {
[10:29:53.264]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:53.264]                 open = "w")
[10:29:53.264]         }
[10:29:53.264]         else {
[10:29:53.264]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:53.264]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:53.264]         }
[10:29:53.264]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:53.264]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:53.264]             base::sink(type = "output", split = FALSE)
[10:29:53.264]             base::close(...future.stdout)
[10:29:53.264]         }, add = TRUE)
[10:29:53.264]     }
[10:29:53.264]     ...future.frame <- base::sys.nframe()
[10:29:53.264]     ...future.conditions <- base::list()
[10:29:53.264]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:53.264]     if (FALSE) {
[10:29:53.264]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:53.264]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:53.264]     }
[10:29:53.264]     ...future.result <- base::tryCatch({
[10:29:53.264]         base::withCallingHandlers({
[10:29:53.264]             ...future.value <- base::withVisible(base::local({
[10:29:53.264]                 do.call(function(...) {
[10:29:53.264]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.264]                   if (!identical(...future.globals.maxSize.org, 
[10:29:53.264]                     ...future.globals.maxSize)) {
[10:29:53.264]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.264]                     on.exit(options(oopts), add = TRUE)
[10:29:53.264]                   }
[10:29:53.264]                   {
[10:29:53.264]                     lapply(seq_along(...future.elements_ii), 
[10:29:53.264]                       FUN = function(jj) {
[10:29:53.264]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.264]                         ...future.FUN(...future.X_jj, ...)
[10:29:53.264]                       })
[10:29:53.264]                   }
[10:29:53.264]                 }, args = future.call.arguments)
[10:29:53.264]             }))
[10:29:53.264]             future::FutureResult(value = ...future.value$value, 
[10:29:53.264]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.264]                   ...future.rng), globalenv = if (FALSE) 
[10:29:53.264]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:53.264]                     ...future.globalenv.names))
[10:29:53.264]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:53.264]         }, condition = base::local({
[10:29:53.264]             c <- base::c
[10:29:53.264]             inherits <- base::inherits
[10:29:53.264]             invokeRestart <- base::invokeRestart
[10:29:53.264]             length <- base::length
[10:29:53.264]             list <- base::list
[10:29:53.264]             seq.int <- base::seq.int
[10:29:53.264]             signalCondition <- base::signalCondition
[10:29:53.264]             sys.calls <- base::sys.calls
[10:29:53.264]             `[[` <- base::`[[`
[10:29:53.264]             `+` <- base::`+`
[10:29:53.264]             `<<-` <- base::`<<-`
[10:29:53.264]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:53.264]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:53.264]                   3L)]
[10:29:53.264]             }
[10:29:53.264]             function(cond) {
[10:29:53.264]                 is_error <- inherits(cond, "error")
[10:29:53.264]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:53.264]                   NULL)
[10:29:53.264]                 if (is_error) {
[10:29:53.264]                   sessionInformation <- function() {
[10:29:53.264]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:53.264]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:53.264]                       search = base::search(), system = base::Sys.info())
[10:29:53.264]                   }
[10:29:53.264]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.264]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:53.264]                     cond$call), session = sessionInformation(), 
[10:29:53.264]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:53.264]                   signalCondition(cond)
[10:29:53.264]                 }
[10:29:53.264]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:53.264]                 "immediateCondition"))) {
[10:29:53.264]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:53.264]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.264]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:53.264]                   if (TRUE && !signal) {
[10:29:53.264]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.264]                     {
[10:29:53.264]                       inherits <- base::inherits
[10:29:53.264]                       invokeRestart <- base::invokeRestart
[10:29:53.264]                       is.null <- base::is.null
[10:29:53.264]                       muffled <- FALSE
[10:29:53.264]                       if (inherits(cond, "message")) {
[10:29:53.264]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.264]                         if (muffled) 
[10:29:53.264]                           invokeRestart("muffleMessage")
[10:29:53.264]                       }
[10:29:53.264]                       else if (inherits(cond, "warning")) {
[10:29:53.264]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.264]                         if (muffled) 
[10:29:53.264]                           invokeRestart("muffleWarning")
[10:29:53.264]                       }
[10:29:53.264]                       else if (inherits(cond, "condition")) {
[10:29:53.264]                         if (!is.null(pattern)) {
[10:29:53.264]                           computeRestarts <- base::computeRestarts
[10:29:53.264]                           grepl <- base::grepl
[10:29:53.264]                           restarts <- computeRestarts(cond)
[10:29:53.264]                           for (restart in restarts) {
[10:29:53.264]                             name <- restart$name
[10:29:53.264]                             if (is.null(name)) 
[10:29:53.264]                               next
[10:29:53.264]                             if (!grepl(pattern, name)) 
[10:29:53.264]                               next
[10:29:53.264]                             invokeRestart(restart)
[10:29:53.264]                             muffled <- TRUE
[10:29:53.264]                             break
[10:29:53.264]                           }
[10:29:53.264]                         }
[10:29:53.264]                       }
[10:29:53.264]                       invisible(muffled)
[10:29:53.264]                     }
[10:29:53.264]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.264]                   }
[10:29:53.264]                 }
[10:29:53.264]                 else {
[10:29:53.264]                   if (TRUE) {
[10:29:53.264]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.264]                     {
[10:29:53.264]                       inherits <- base::inherits
[10:29:53.264]                       invokeRestart <- base::invokeRestart
[10:29:53.264]                       is.null <- base::is.null
[10:29:53.264]                       muffled <- FALSE
[10:29:53.264]                       if (inherits(cond, "message")) {
[10:29:53.264]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.264]                         if (muffled) 
[10:29:53.264]                           invokeRestart("muffleMessage")
[10:29:53.264]                       }
[10:29:53.264]                       else if (inherits(cond, "warning")) {
[10:29:53.264]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.264]                         if (muffled) 
[10:29:53.264]                           invokeRestart("muffleWarning")
[10:29:53.264]                       }
[10:29:53.264]                       else if (inherits(cond, "condition")) {
[10:29:53.264]                         if (!is.null(pattern)) {
[10:29:53.264]                           computeRestarts <- base::computeRestarts
[10:29:53.264]                           grepl <- base::grepl
[10:29:53.264]                           restarts <- computeRestarts(cond)
[10:29:53.264]                           for (restart in restarts) {
[10:29:53.264]                             name <- restart$name
[10:29:53.264]                             if (is.null(name)) 
[10:29:53.264]                               next
[10:29:53.264]                             if (!grepl(pattern, name)) 
[10:29:53.264]                               next
[10:29:53.264]                             invokeRestart(restart)
[10:29:53.264]                             muffled <- TRUE
[10:29:53.264]                             break
[10:29:53.264]                           }
[10:29:53.264]                         }
[10:29:53.264]                       }
[10:29:53.264]                       invisible(muffled)
[10:29:53.264]                     }
[10:29:53.264]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.264]                   }
[10:29:53.264]                 }
[10:29:53.264]             }
[10:29:53.264]         }))
[10:29:53.264]     }, error = function(ex) {
[10:29:53.264]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:53.264]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.264]                 ...future.rng), started = ...future.startTime, 
[10:29:53.264]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:53.264]             version = "1.8"), class = "FutureResult")
[10:29:53.264]     }, finally = {
[10:29:53.264]         if (!identical(...future.workdir, getwd())) 
[10:29:53.264]             setwd(...future.workdir)
[10:29:53.264]         {
[10:29:53.264]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:53.264]                 ...future.oldOptions$nwarnings <- NULL
[10:29:53.264]             }
[10:29:53.264]             base::options(...future.oldOptions)
[10:29:53.264]             if (.Platform$OS.type == "windows") {
[10:29:53.264]                 old_names <- names(...future.oldEnvVars)
[10:29:53.264]                 envs <- base::Sys.getenv()
[10:29:53.264]                 names <- names(envs)
[10:29:53.264]                 common <- intersect(names, old_names)
[10:29:53.264]                 added <- setdiff(names, old_names)
[10:29:53.264]                 removed <- setdiff(old_names, names)
[10:29:53.264]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:53.264]                   envs[common]]
[10:29:53.264]                 NAMES <- toupper(changed)
[10:29:53.264]                 args <- list()
[10:29:53.264]                 for (kk in seq_along(NAMES)) {
[10:29:53.264]                   name <- changed[[kk]]
[10:29:53.264]                   NAME <- NAMES[[kk]]
[10:29:53.264]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.264]                     next
[10:29:53.264]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.264]                 }
[10:29:53.264]                 NAMES <- toupper(added)
[10:29:53.264]                 for (kk in seq_along(NAMES)) {
[10:29:53.264]                   name <- added[[kk]]
[10:29:53.264]                   NAME <- NAMES[[kk]]
[10:29:53.264]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.264]                     next
[10:29:53.264]                   args[[name]] <- ""
[10:29:53.264]                 }
[10:29:53.264]                 NAMES <- toupper(removed)
[10:29:53.264]                 for (kk in seq_along(NAMES)) {
[10:29:53.264]                   name <- removed[[kk]]
[10:29:53.264]                   NAME <- NAMES[[kk]]
[10:29:53.264]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.264]                     next
[10:29:53.264]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.264]                 }
[10:29:53.264]                 if (length(args) > 0) 
[10:29:53.264]                   base::do.call(base::Sys.setenv, args = args)
[10:29:53.264]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:53.264]             }
[10:29:53.264]             else {
[10:29:53.264]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:53.264]             }
[10:29:53.264]             {
[10:29:53.264]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:53.264]                   0L) {
[10:29:53.264]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:53.264]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:53.264]                   base::options(opts)
[10:29:53.264]                 }
[10:29:53.264]                 {
[10:29:53.264]                   {
[10:29:53.264]                     NULL
[10:29:53.264]                     RNGkind("Mersenne-Twister")
[10:29:53.264]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:53.264]                       inherits = FALSE)
[10:29:53.264]                   }
[10:29:53.264]                   options(future.plan = NULL)
[10:29:53.264]                   if (is.na(NA_character_)) 
[10:29:53.264]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.264]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:53.264]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:53.264]                     .init = FALSE)
[10:29:53.264]                 }
[10:29:53.264]             }
[10:29:53.264]         }
[10:29:53.264]     })
[10:29:53.264]     if (TRUE) {
[10:29:53.264]         base::sink(type = "output", split = FALSE)
[10:29:53.264]         if (TRUE) {
[10:29:53.264]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:53.264]         }
[10:29:53.264]         else {
[10:29:53.264]             ...future.result["stdout"] <- base::list(NULL)
[10:29:53.264]         }
[10:29:53.264]         base::close(...future.stdout)
[10:29:53.264]         ...future.stdout <- NULL
[10:29:53.264]     }
[10:29:53.264]     ...future.result$conditions <- ...future.conditions
[10:29:53.264]     ...future.result$finished <- base::Sys.time()
[10:29:53.264]     ...future.result
[10:29:53.264] }
[10:29:53.265] assign_globals() ...
[10:29:53.265] List of 5
[10:29:53.265]  $ ...future.FUN            :function (object, ...)  
[10:29:53.265]  $ future.call.arguments    : list()
[10:29:53.265]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.265]  $ ...future.elements_ii    :List of 3
[10:29:53.265]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:29:53.265]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:29:53.265]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.265]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:29:53.265]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:29:53.265]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.265]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:29:53.265]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:29:53.265]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.265]  $ ...future.seeds_ii       : NULL
[10:29:53.265]  $ ...future.globals.maxSize: NULL
[10:29:53.265]  - attr(*, "where")=List of 5
[10:29:53.265]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:53.265]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:53.265]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:53.265]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:53.265]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:53.265]  - attr(*, "resolved")= logi FALSE
[10:29:53.265]  - attr(*, "total_size")= num 1240
[10:29:53.265]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.265]  - attr(*, "already-done")= logi TRUE
[10:29:53.275] - copied ‘...future.FUN’ to environment
[10:29:53.275] - copied ‘future.call.arguments’ to environment
[10:29:53.275] - copied ‘...future.elements_ii’ to environment
[10:29:53.275] - copied ‘...future.seeds_ii’ to environment
[10:29:53.275] - copied ‘...future.globals.maxSize’ to environment
[10:29:53.275] assign_globals() ... done
[10:29:53.275] plan(): Setting new future strategy stack:
[10:29:53.275] List of future strategies:
[10:29:53.275] 1. sequential:
[10:29:53.275]    - args: function (..., envir = parent.frame())
[10:29:53.275]    - tweaked: FALSE
[10:29:53.275]    - call: NULL
[10:29:53.276] plan(): nbrOfWorkers() = 1
[10:29:53.278] plan(): Setting new future strategy stack:
[10:29:53.278] List of future strategies:
[10:29:53.278] 1. multicore:
[10:29:53.278]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:53.278]    - tweaked: FALSE
[10:29:53.278]    - call: plan(strategy)
[10:29:53.281] plan(): nbrOfWorkers() = 1
[10:29:53.282] SequentialFuture started (and completed)
[10:29:53.282] - Launch lazy future ... done
[10:29:53.282] run() for ‘SequentialFuture’ ... done
[10:29:53.282] Created future:
[10:29:53.282] SequentialFuture:
[10:29:53.282] Label: ‘future_by-1’
[10:29:53.282] Expression:
[10:29:53.282] {
[10:29:53.282]     do.call(function(...) {
[10:29:53.282]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.282]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.282]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.282]             on.exit(options(oopts), add = TRUE)
[10:29:53.282]         }
[10:29:53.282]         {
[10:29:53.282]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.282]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.282]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.282]             })
[10:29:53.282]         }
[10:29:53.282]     }, args = future.call.arguments)
[10:29:53.282] }
[10:29:53.282] Lazy evaluation: FALSE
[10:29:53.282] Asynchronous evaluation: FALSE
[10:29:53.282] Local evaluation: TRUE
[10:29:53.282] Environment: R_GlobalEnv
[10:29:53.282] Capture standard output: TRUE
[10:29:53.282] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:53.282] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:53.282] Packages: <none>
[10:29:53.282] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:53.282] Resolved: TRUE
[10:29:53.282] Value: 4.62 KiB of class ‘list’
[10:29:53.282] Early signaling: FALSE
[10:29:53.282] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:53.282] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.283] Chunk #1 of 1 ... DONE
[10:29:53.283] Launching 1 futures (chunks) ... DONE
[10:29:53.283] Resolving 1 futures (chunks) ...
[10:29:53.283] resolve() on list ...
[10:29:53.284]  recursive: 0
[10:29:53.284]  length: 1
[10:29:53.284] 
[10:29:53.284] resolved() for ‘SequentialFuture’ ...
[10:29:53.284] - state: ‘finished’
[10:29:53.284] - run: TRUE
[10:29:53.284] - result: ‘FutureResult’
[10:29:53.284] resolved() for ‘SequentialFuture’ ... done
[10:29:53.284] Future #1
[10:29:53.284] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:53.285] - nx: 1
[10:29:53.285] - relay: TRUE
[10:29:53.285] - stdout: TRUE
[10:29:53.285] - signal: TRUE
[10:29:53.285] - resignal: FALSE
[10:29:53.285] - force: TRUE
[10:29:53.285] - relayed: [n=1] FALSE
[10:29:53.285] - queued futures: [n=1] FALSE
[10:29:53.285]  - until=1
[10:29:53.285]  - relaying element #1
[10:29:53.286] - relayed: [n=1] TRUE
[10:29:53.286] - queued futures: [n=1] TRUE
[10:29:53.286] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:53.286]  length: 0 (resolved future 1)
[10:29:53.286] Relaying remaining futures
[10:29:53.286] signalConditionsASAP(NULL, pos=0) ...
[10:29:53.286] - nx: 1
[10:29:53.286] - relay: TRUE
[10:29:53.286] - stdout: TRUE
[10:29:53.286] - signal: TRUE
[10:29:53.286] - resignal: FALSE
[10:29:53.286] - force: TRUE
[10:29:53.287] - relayed: [n=1] TRUE
[10:29:53.287] - queued futures: [n=1] TRUE
 - flush all
[10:29:53.287] - relayed: [n=1] TRUE
[10:29:53.287] - queued futures: [n=1] TRUE
[10:29:53.287] signalConditionsASAP(NULL, pos=0) ... done
[10:29:53.287] resolve() on list ... DONE
[10:29:53.287]  - Number of value chunks collected: 1
[10:29:53.287] Resolving 1 futures (chunks) ... DONE
[10:29:53.287] Reducing values from 1 chunks ...
[10:29:53.287]  - Number of values collected after concatenation: 3
[10:29:53.288]  - Number of values expected: 3
[10:29:53.288] Reducing values from 1 chunks ... DONE
[10:29:53.288] future_lapply() ... DONE
[10:29:53.288] future_by_internal() ... DONE
[10:29:53.288] future_by_internal() ...
[10:29:53.288] future_lapply() ...
[10:29:53.293] Number of chunks: 1
[10:29:53.294] getGlobalsAndPackagesXApply() ...
[10:29:53.294]  - future.globals: TRUE
[10:29:53.294] getGlobalsAndPackages() ...
[10:29:53.294] Searching for globals...
[10:29:53.295] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:53.295] Searching for globals ... DONE
[10:29:53.295] Resolving globals: FALSE
[10:29:53.296] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:53.296] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:53.296] - globals: [1] ‘FUN’
[10:29:53.296] 
[10:29:53.296] getGlobalsAndPackages() ... DONE
[10:29:53.296]  - globals found/used: [n=1] ‘FUN’
[10:29:53.296]  - needed namespaces: [n=0] 
[10:29:53.296] Finding globals ... DONE
[10:29:53.297]  - use_args: TRUE
[10:29:53.297]  - Getting '...' globals ...
[10:29:53.297] resolve() on list ...
[10:29:53.297]  recursive: 0
[10:29:53.297]  length: 1
[10:29:53.297]  elements: ‘...’
[10:29:53.297]  length: 0 (resolved future 1)
[10:29:53.297] resolve() on list ... DONE
[10:29:53.298]    - '...' content: [n=1] ‘digits’
[10:29:53.298] List of 1
[10:29:53.298]  $ ...:List of 1
[10:29:53.298]   ..$ digits: int 2
[10:29:53.298]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.298]  - attr(*, "where")=List of 1
[10:29:53.298]   ..$ ...:<environment: 0x556dd5465320> 
[10:29:53.298]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.298]  - attr(*, "resolved")= logi TRUE
[10:29:53.298]  - attr(*, "total_size")= num NA
[10:29:53.300]  - Getting '...' globals ... DONE
[10:29:53.301] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:53.301] List of 2
[10:29:53.301]  $ ...future.FUN:function (object, ...)  
[10:29:53.301]  $ ...          :List of 1
[10:29:53.301]   ..$ digits: int 2
[10:29:53.301]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.301]  - attr(*, "where")=List of 2
[10:29:53.301]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:53.301]   ..$ ...          :<environment: 0x556dd5465320> 
[10:29:53.301]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.301]  - attr(*, "resolved")= logi FALSE
[10:29:53.301]  - attr(*, "total_size")= num 1296
[10:29:53.304] Packages to be attached in all futures: [n=0] 
[10:29:53.304] getGlobalsAndPackagesXApply() ... DONE
[10:29:53.304] Number of futures (= number of chunks): 1
[10:29:53.304] Launching 1 futures (chunks) ...
[10:29:53.304] Chunk #1 of 1 ...
[10:29:53.304]  - Finding globals in 'X' for chunk #1 ...
[10:29:53.305] getGlobalsAndPackages() ...
[10:29:53.305] Searching for globals...
[10:29:53.305] 
[10:29:53.305] Searching for globals ... DONE
[10:29:53.305] - globals: [0] <none>
[10:29:53.305] getGlobalsAndPackages() ... DONE
[10:29:53.305]    + additional globals found: [n=0] 
[10:29:53.305]    + additional namespaces needed: [n=0] 
[10:29:53.305]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:53.306]  - seeds: <none>
[10:29:53.306]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.306] getGlobalsAndPackages() ...
[10:29:53.306] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.306] Resolving globals: FALSE
[10:29:53.306] Tweak future expression to call with '...' arguments ...
[10:29:53.306] {
[10:29:53.306]     do.call(function(...) {
[10:29:53.306]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.306]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.306]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.306]             on.exit(options(oopts), add = TRUE)
[10:29:53.306]         }
[10:29:53.306]         {
[10:29:53.306]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.306]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.306]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.306]             })
[10:29:53.306]         }
[10:29:53.306]     }, args = future.call.arguments)
[10:29:53.306] }
[10:29:53.306] Tweak future expression to call with '...' arguments ... DONE
[10:29:53.307] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.307] 
[10:29:53.307] getGlobalsAndPackages() ... DONE
[10:29:53.307] run() for ‘Future’ ...
[10:29:53.307] - state: ‘created’
[10:29:53.307] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:53.311] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.311] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:53.311]   - Field: ‘label’
[10:29:53.311]   - Field: ‘local’
[10:29:53.311]   - Field: ‘owner’
[10:29:53.311]   - Field: ‘envir’
[10:29:53.312]   - Field: ‘packages’
[10:29:53.312]   - Field: ‘gc’
[10:29:53.312]   - Field: ‘conditions’
[10:29:53.312]   - Field: ‘expr’
[10:29:53.312]   - Field: ‘uuid’
[10:29:53.312]   - Field: ‘seed’
[10:29:53.312]   - Field: ‘version’
[10:29:53.312]   - Field: ‘result’
[10:29:53.312]   - Field: ‘asynchronous’
[10:29:53.312]   - Field: ‘calls’
[10:29:53.313]   - Field: ‘globals’
[10:29:53.313]   - Field: ‘stdout’
[10:29:53.313]   - Field: ‘earlySignal’
[10:29:53.314]   - Field: ‘lazy’
[10:29:53.315]   - Field: ‘state’
[10:29:53.315] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:53.315] - Launch lazy future ...
[10:29:53.315] Packages needed by the future expression (n = 0): <none>
[10:29:53.315] Packages needed by future strategies (n = 0): <none>
[10:29:53.316] {
[10:29:53.316]     {
[10:29:53.316]         {
[10:29:53.316]             ...future.startTime <- base::Sys.time()
[10:29:53.316]             {
[10:29:53.316]                 {
[10:29:53.316]                   {
[10:29:53.316]                     base::local({
[10:29:53.316]                       has_future <- base::requireNamespace("future", 
[10:29:53.316]                         quietly = TRUE)
[10:29:53.316]                       if (has_future) {
[10:29:53.316]                         ns <- base::getNamespace("future")
[10:29:53.316]                         version <- ns[[".package"]][["version"]]
[10:29:53.316]                         if (is.null(version)) 
[10:29:53.316]                           version <- utils::packageVersion("future")
[10:29:53.316]                       }
[10:29:53.316]                       else {
[10:29:53.316]                         version <- NULL
[10:29:53.316]                       }
[10:29:53.316]                       if (!has_future || version < "1.8.0") {
[10:29:53.316]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:53.316]                           "", base::R.version$version.string), 
[10:29:53.316]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:53.316]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:53.316]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:53.316]                             "release", "version")], collapse = " "), 
[10:29:53.316]                           hostname = base::Sys.info()[["nodename"]])
[10:29:53.316]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:53.316]                           info)
[10:29:53.316]                         info <- base::paste(info, collapse = "; ")
[10:29:53.316]                         if (!has_future) {
[10:29:53.316]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:53.316]                             info)
[10:29:53.316]                         }
[10:29:53.316]                         else {
[10:29:53.316]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:53.316]                             info, version)
[10:29:53.316]                         }
[10:29:53.316]                         base::stop(msg)
[10:29:53.316]                       }
[10:29:53.316]                     })
[10:29:53.316]                   }
[10:29:53.316]                   ...future.strategy.old <- future::plan("list")
[10:29:53.316]                   options(future.plan = NULL)
[10:29:53.316]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.316]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:53.316]                 }
[10:29:53.316]                 ...future.workdir <- getwd()
[10:29:53.316]             }
[10:29:53.316]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:53.316]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:53.316]         }
[10:29:53.316]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:53.316]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:53.316]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:53.316]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:53.316]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:53.316]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:53.316]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:53.316]             base::names(...future.oldOptions))
[10:29:53.316]     }
[10:29:53.316]     if (FALSE) {
[10:29:53.316]     }
[10:29:53.316]     else {
[10:29:53.316]         if (TRUE) {
[10:29:53.316]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:53.316]                 open = "w")
[10:29:53.316]         }
[10:29:53.316]         else {
[10:29:53.316]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:53.316]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:53.316]         }
[10:29:53.316]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:53.316]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:53.316]             base::sink(type = "output", split = FALSE)
[10:29:53.316]             base::close(...future.stdout)
[10:29:53.316]         }, add = TRUE)
[10:29:53.316]     }
[10:29:53.316]     ...future.frame <- base::sys.nframe()
[10:29:53.316]     ...future.conditions <- base::list()
[10:29:53.316]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:53.316]     if (FALSE) {
[10:29:53.316]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:53.316]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:53.316]     }
[10:29:53.316]     ...future.result <- base::tryCatch({
[10:29:53.316]         base::withCallingHandlers({
[10:29:53.316]             ...future.value <- base::withVisible(base::local({
[10:29:53.316]                 do.call(function(...) {
[10:29:53.316]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.316]                   if (!identical(...future.globals.maxSize.org, 
[10:29:53.316]                     ...future.globals.maxSize)) {
[10:29:53.316]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.316]                     on.exit(options(oopts), add = TRUE)
[10:29:53.316]                   }
[10:29:53.316]                   {
[10:29:53.316]                     lapply(seq_along(...future.elements_ii), 
[10:29:53.316]                       FUN = function(jj) {
[10:29:53.316]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.316]                         ...future.FUN(...future.X_jj, ...)
[10:29:53.316]                       })
[10:29:53.316]                   }
[10:29:53.316]                 }, args = future.call.arguments)
[10:29:53.316]             }))
[10:29:53.316]             future::FutureResult(value = ...future.value$value, 
[10:29:53.316]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.316]                   ...future.rng), globalenv = if (FALSE) 
[10:29:53.316]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:53.316]                     ...future.globalenv.names))
[10:29:53.316]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:53.316]         }, condition = base::local({
[10:29:53.316]             c <- base::c
[10:29:53.316]             inherits <- base::inherits
[10:29:53.316]             invokeRestart <- base::invokeRestart
[10:29:53.316]             length <- base::length
[10:29:53.316]             list <- base::list
[10:29:53.316]             seq.int <- base::seq.int
[10:29:53.316]             signalCondition <- base::signalCondition
[10:29:53.316]             sys.calls <- base::sys.calls
[10:29:53.316]             `[[` <- base::`[[`
[10:29:53.316]             `+` <- base::`+`
[10:29:53.316]             `<<-` <- base::`<<-`
[10:29:53.316]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:53.316]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:53.316]                   3L)]
[10:29:53.316]             }
[10:29:53.316]             function(cond) {
[10:29:53.316]                 is_error <- inherits(cond, "error")
[10:29:53.316]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:53.316]                   NULL)
[10:29:53.316]                 if (is_error) {
[10:29:53.316]                   sessionInformation <- function() {
[10:29:53.316]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:53.316]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:53.316]                       search = base::search(), system = base::Sys.info())
[10:29:53.316]                   }
[10:29:53.316]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.316]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:53.316]                     cond$call), session = sessionInformation(), 
[10:29:53.316]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:53.316]                   signalCondition(cond)
[10:29:53.316]                 }
[10:29:53.316]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:53.316]                 "immediateCondition"))) {
[10:29:53.316]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:53.316]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.316]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:53.316]                   if (TRUE && !signal) {
[10:29:53.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.316]                     {
[10:29:53.316]                       inherits <- base::inherits
[10:29:53.316]                       invokeRestart <- base::invokeRestart
[10:29:53.316]                       is.null <- base::is.null
[10:29:53.316]                       muffled <- FALSE
[10:29:53.316]                       if (inherits(cond, "message")) {
[10:29:53.316]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.316]                         if (muffled) 
[10:29:53.316]                           invokeRestart("muffleMessage")
[10:29:53.316]                       }
[10:29:53.316]                       else if (inherits(cond, "warning")) {
[10:29:53.316]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.316]                         if (muffled) 
[10:29:53.316]                           invokeRestart("muffleWarning")
[10:29:53.316]                       }
[10:29:53.316]                       else if (inherits(cond, "condition")) {
[10:29:53.316]                         if (!is.null(pattern)) {
[10:29:53.316]                           computeRestarts <- base::computeRestarts
[10:29:53.316]                           grepl <- base::grepl
[10:29:53.316]                           restarts <- computeRestarts(cond)
[10:29:53.316]                           for (restart in restarts) {
[10:29:53.316]                             name <- restart$name
[10:29:53.316]                             if (is.null(name)) 
[10:29:53.316]                               next
[10:29:53.316]                             if (!grepl(pattern, name)) 
[10:29:53.316]                               next
[10:29:53.316]                             invokeRestart(restart)
[10:29:53.316]                             muffled <- TRUE
[10:29:53.316]                             break
[10:29:53.316]                           }
[10:29:53.316]                         }
[10:29:53.316]                       }
[10:29:53.316]                       invisible(muffled)
[10:29:53.316]                     }
[10:29:53.316]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.316]                   }
[10:29:53.316]                 }
[10:29:53.316]                 else {
[10:29:53.316]                   if (TRUE) {
[10:29:53.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.316]                     {
[10:29:53.316]                       inherits <- base::inherits
[10:29:53.316]                       invokeRestart <- base::invokeRestart
[10:29:53.316]                       is.null <- base::is.null
[10:29:53.316]                       muffled <- FALSE
[10:29:53.316]                       if (inherits(cond, "message")) {
[10:29:53.316]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.316]                         if (muffled) 
[10:29:53.316]                           invokeRestart("muffleMessage")
[10:29:53.316]                       }
[10:29:53.316]                       else if (inherits(cond, "warning")) {
[10:29:53.316]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.316]                         if (muffled) 
[10:29:53.316]                           invokeRestart("muffleWarning")
[10:29:53.316]                       }
[10:29:53.316]                       else if (inherits(cond, "condition")) {
[10:29:53.316]                         if (!is.null(pattern)) {
[10:29:53.316]                           computeRestarts <- base::computeRestarts
[10:29:53.316]                           grepl <- base::grepl
[10:29:53.316]                           restarts <- computeRestarts(cond)
[10:29:53.316]                           for (restart in restarts) {
[10:29:53.316]                             name <- restart$name
[10:29:53.316]                             if (is.null(name)) 
[10:29:53.316]                               next
[10:29:53.316]                             if (!grepl(pattern, name)) 
[10:29:53.316]                               next
[10:29:53.316]                             invokeRestart(restart)
[10:29:53.316]                             muffled <- TRUE
[10:29:53.316]                             break
[10:29:53.316]                           }
[10:29:53.316]                         }
[10:29:53.316]                       }
[10:29:53.316]                       invisible(muffled)
[10:29:53.316]                     }
[10:29:53.316]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.316]                   }
[10:29:53.316]                 }
[10:29:53.316]             }
[10:29:53.316]         }))
[10:29:53.316]     }, error = function(ex) {
[10:29:53.316]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:53.316]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.316]                 ...future.rng), started = ...future.startTime, 
[10:29:53.316]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:53.316]             version = "1.8"), class = "FutureResult")
[10:29:53.316]     }, finally = {
[10:29:53.316]         if (!identical(...future.workdir, getwd())) 
[10:29:53.316]             setwd(...future.workdir)
[10:29:53.316]         {
[10:29:53.316]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:53.316]                 ...future.oldOptions$nwarnings <- NULL
[10:29:53.316]             }
[10:29:53.316]             base::options(...future.oldOptions)
[10:29:53.316]             if (.Platform$OS.type == "windows") {
[10:29:53.316]                 old_names <- names(...future.oldEnvVars)
[10:29:53.316]                 envs <- base::Sys.getenv()
[10:29:53.316]                 names <- names(envs)
[10:29:53.316]                 common <- intersect(names, old_names)
[10:29:53.316]                 added <- setdiff(names, old_names)
[10:29:53.316]                 removed <- setdiff(old_names, names)
[10:29:53.316]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:53.316]                   envs[common]]
[10:29:53.316]                 NAMES <- toupper(changed)
[10:29:53.316]                 args <- list()
[10:29:53.316]                 for (kk in seq_along(NAMES)) {
[10:29:53.316]                   name <- changed[[kk]]
[10:29:53.316]                   NAME <- NAMES[[kk]]
[10:29:53.316]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.316]                     next
[10:29:53.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.316]                 }
[10:29:53.316]                 NAMES <- toupper(added)
[10:29:53.316]                 for (kk in seq_along(NAMES)) {
[10:29:53.316]                   name <- added[[kk]]
[10:29:53.316]                   NAME <- NAMES[[kk]]
[10:29:53.316]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.316]                     next
[10:29:53.316]                   args[[name]] <- ""
[10:29:53.316]                 }
[10:29:53.316]                 NAMES <- toupper(removed)
[10:29:53.316]                 for (kk in seq_along(NAMES)) {
[10:29:53.316]                   name <- removed[[kk]]
[10:29:53.316]                   NAME <- NAMES[[kk]]
[10:29:53.316]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.316]                     next
[10:29:53.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.316]                 }
[10:29:53.316]                 if (length(args) > 0) 
[10:29:53.316]                   base::do.call(base::Sys.setenv, args = args)
[10:29:53.316]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:53.316]             }
[10:29:53.316]             else {
[10:29:53.316]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:53.316]             }
[10:29:53.316]             {
[10:29:53.316]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:53.316]                   0L) {
[10:29:53.316]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:53.316]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:53.316]                   base::options(opts)
[10:29:53.316]                 }
[10:29:53.316]                 {
[10:29:53.316]                   {
[10:29:53.316]                     NULL
[10:29:53.316]                     RNGkind("Mersenne-Twister")
[10:29:53.316]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:53.316]                       inherits = FALSE)
[10:29:53.316]                   }
[10:29:53.316]                   options(future.plan = NULL)
[10:29:53.316]                   if (is.na(NA_character_)) 
[10:29:53.316]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.316]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:53.316]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:53.316]                     .init = FALSE)
[10:29:53.316]                 }
[10:29:53.316]             }
[10:29:53.316]         }
[10:29:53.316]     })
[10:29:53.316]     if (TRUE) {
[10:29:53.316]         base::sink(type = "output", split = FALSE)
[10:29:53.316]         if (TRUE) {
[10:29:53.316]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:53.316]         }
[10:29:53.316]         else {
[10:29:53.316]             ...future.result["stdout"] <- base::list(NULL)
[10:29:53.316]         }
[10:29:53.316]         base::close(...future.stdout)
[10:29:53.316]         ...future.stdout <- NULL
[10:29:53.316]     }
[10:29:53.316]     ...future.result$conditions <- ...future.conditions
[10:29:53.316]     ...future.result$finished <- base::Sys.time()
[10:29:53.316]     ...future.result
[10:29:53.316] }
[10:29:53.317] assign_globals() ...
[10:29:53.317] List of 5
[10:29:53.317]  $ ...future.FUN            :function (object, ...)  
[10:29:53.317]  $ future.call.arguments    :List of 1
[10:29:53.317]   ..$ digits: int 2
[10:29:53.317]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.317]  $ ...future.elements_ii    :List of 6
[10:29:53.317]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[10:29:53.317]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[10:29:53.317]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[10:29:53.317]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[10:29:53.317]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[10:29:53.317]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[10:29:53.317]  $ ...future.seeds_ii       : NULL
[10:29:53.317]  $ ...future.globals.maxSize: NULL
[10:29:53.317]  - attr(*, "where")=List of 5
[10:29:53.317]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:53.317]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:53.317]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:53.317]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:53.317]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:53.317]  - attr(*, "resolved")= logi FALSE
[10:29:53.317]  - attr(*, "total_size")= num 1296
[10:29:53.317]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.317]  - attr(*, "already-done")= logi TRUE
[10:29:53.324] - copied ‘...future.FUN’ to environment
[10:29:53.324] - copied ‘future.call.arguments’ to environment
[10:29:53.324] - copied ‘...future.elements_ii’ to environment
[10:29:53.324] - copied ‘...future.seeds_ii’ to environment
[10:29:53.324] - copied ‘...future.globals.maxSize’ to environment
[10:29:53.324] assign_globals() ... done
[10:29:53.325] plan(): Setting new future strategy stack:
[10:29:53.325] List of future strategies:
[10:29:53.325] 1. sequential:
[10:29:53.325]    - args: function (..., envir = parent.frame())
[10:29:53.325]    - tweaked: FALSE
[10:29:53.325]    - call: NULL
[10:29:53.325] plan(): nbrOfWorkers() = 1
[10:29:53.326] plan(): Setting new future strategy stack:
[10:29:53.327] List of future strategies:
[10:29:53.327] 1. multicore:
[10:29:53.327]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:53.327]    - tweaked: FALSE
[10:29:53.327]    - call: plan(strategy)
[10:29:53.330] plan(): nbrOfWorkers() = 1
[10:29:53.330] SequentialFuture started (and completed)
[10:29:53.330] - Launch lazy future ... done
[10:29:53.330] run() for ‘SequentialFuture’ ... done
[10:29:53.331] Created future:
[10:29:53.331] SequentialFuture:
[10:29:53.331] Label: ‘future_by-1’
[10:29:53.331] Expression:
[10:29:53.331] {
[10:29:53.331]     do.call(function(...) {
[10:29:53.331]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.331]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.331]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.331]             on.exit(options(oopts), add = TRUE)
[10:29:53.331]         }
[10:29:53.331]         {
[10:29:53.331]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.331]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.331]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.331]             })
[10:29:53.331]         }
[10:29:53.331]     }, args = future.call.arguments)
[10:29:53.331] }
[10:29:53.331] Lazy evaluation: FALSE
[10:29:53.331] Asynchronous evaluation: FALSE
[10:29:53.331] Local evaluation: TRUE
[10:29:53.331] Environment: R_GlobalEnv
[10:29:53.331] Capture standard output: TRUE
[10:29:53.331] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:53.331] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:53.331] Packages: <none>
[10:29:53.331] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:53.331] Resolved: TRUE
[10:29:53.331] Value: 5.48 KiB of class ‘list’
[10:29:53.331] Early signaling: FALSE
[10:29:53.331] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:53.331] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.332] Chunk #1 of 1 ... DONE
[10:29:53.332] Launching 1 futures (chunks) ... DONE
[10:29:53.332] Resolving 1 futures (chunks) ...
[10:29:53.332] resolve() on list ...
[10:29:53.332]  recursive: 0
[10:29:53.332]  length: 1
[10:29:53.332] 
[10:29:53.332] resolved() for ‘SequentialFuture’ ...
[10:29:53.332] - state: ‘finished’
[10:29:53.332] - run: TRUE
[10:29:53.333] - result: ‘FutureResult’
[10:29:53.333] resolved() for ‘SequentialFuture’ ... done
[10:29:53.333] Future #1
[10:29:53.333] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:53.333] - nx: 1
[10:29:53.333] - relay: TRUE
[10:29:53.333] - stdout: TRUE
[10:29:53.333] - signal: TRUE
[10:29:53.333] - resignal: FALSE
[10:29:53.333] - force: TRUE
[10:29:53.334] - relayed: [n=1] FALSE
[10:29:53.334] - queued futures: [n=1] FALSE
[10:29:53.334]  - until=1
[10:29:53.334]  - relaying element #1
[10:29:53.334] - relayed: [n=1] TRUE
[10:29:53.334] - queued futures: [n=1] TRUE
[10:29:53.334] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:53.334]  length: 0 (resolved future 1)
[10:29:53.334] Relaying remaining futures
[10:29:53.334] signalConditionsASAP(NULL, pos=0) ...
[10:29:53.335] - nx: 1
[10:29:53.335] - relay: TRUE
[10:29:53.335] - stdout: TRUE
[10:29:53.335] - signal: TRUE
[10:29:53.335] - resignal: FALSE
[10:29:53.335] - force: TRUE
[10:29:53.335] - relayed: [n=1] TRUE
[10:29:53.335] - queued futures: [n=1] TRUE
 - flush all
[10:29:53.335] - relayed: [n=1] TRUE
[10:29:53.335] - queued futures: [n=1] TRUE
[10:29:53.335] signalConditionsASAP(NULL, pos=0) ... done
[10:29:53.336] resolve() on list ... DONE
[10:29:53.363]  - Number of value chunks collected: 1
[10:29:53.364] Resolving 1 futures (chunks) ... DONE
[10:29:53.364] Reducing values from 1 chunks ...
[10:29:53.364]  - Number of values collected after concatenation: 6
[10:29:53.364]  - Number of values expected: 6
[10:29:53.364] Reducing values from 1 chunks ... DONE
[10:29:53.364] future_lapply() ... DONE
[10:29:53.364] future_by_internal() ... DONE
[10:29:53.366] future_by_internal() ...
[10:29:53.366] future_lapply() ...
[10:29:53.370] Number of chunks: 1
[10:29:53.370] getGlobalsAndPackagesXApply() ...
[10:29:53.370]  - future.globals: TRUE
[10:29:53.371] getGlobalsAndPackages() ...
[10:29:53.371] Searching for globals...
[10:29:53.372] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:29:53.372] Searching for globals ... DONE
[10:29:53.372] Resolving globals: FALSE
[10:29:53.373] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[10:29:53.373] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[10:29:53.373] - globals: [1] ‘FUN’
[10:29:53.374] - packages: [1] ‘stats’
[10:29:53.374] getGlobalsAndPackages() ... DONE
[10:29:53.374]  - globals found/used: [n=1] ‘FUN’
[10:29:53.374]  - needed namespaces: [n=1] ‘stats’
[10:29:53.374] Finding globals ... DONE
[10:29:53.374]  - use_args: TRUE
[10:29:53.374]  - Getting '...' globals ...
[10:29:53.374] resolve() on list ...
[10:29:53.375]  recursive: 0
[10:29:53.375]  length: 1
[10:29:53.375]  elements: ‘...’
[10:29:53.375]  length: 0 (resolved future 1)
[10:29:53.375] resolve() on list ... DONE
[10:29:53.375]    - '...' content: [n=1] ‘singular.ok’
[10:29:53.375] List of 1
[10:29:53.375]  $ ...:List of 1
[10:29:53.375]   ..$ singular.ok: logi FALSE
[10:29:53.375]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.375]  - attr(*, "where")=List of 1
[10:29:53.375]   ..$ ...:<environment: 0x556dd450f950> 
[10:29:53.375]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.375]  - attr(*, "resolved")= logi TRUE
[10:29:53.375]  - attr(*, "total_size")= num NA
[10:29:53.378]  - Getting '...' globals ... DONE
[10:29:53.378] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:53.378] List of 2
[10:29:53.378]  $ ...future.FUN:function (x, ...)  
[10:29:53.378]  $ ...          :List of 1
[10:29:53.378]   ..$ singular.ok: logi FALSE
[10:29:53.378]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.378]  - attr(*, "where")=List of 2
[10:29:53.378]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:53.378]   ..$ ...          :<environment: 0x556dd450f950> 
[10:29:53.378]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.378]  - attr(*, "resolved")= logi FALSE
[10:29:53.378]  - attr(*, "total_size")= num 5384
[10:29:53.382] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:53.382] getGlobalsAndPackagesXApply() ... DONE
[10:29:53.382] Number of futures (= number of chunks): 1
[10:29:53.382] Launching 1 futures (chunks) ...
[10:29:53.382] Chunk #1 of 1 ...
[10:29:53.382]  - Finding globals in 'X' for chunk #1 ...
[10:29:53.382] getGlobalsAndPackages() ...
[10:29:53.382] Searching for globals...
[10:29:53.383] 
[10:29:53.383] Searching for globals ... DONE
[10:29:53.383] - globals: [0] <none>
[10:29:53.383] getGlobalsAndPackages() ... DONE
[10:29:53.383]    + additional globals found: [n=0] 
[10:29:53.383]    + additional namespaces needed: [n=0] 
[10:29:53.383]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:53.383]  - seeds: <none>
[10:29:53.384]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.384] getGlobalsAndPackages() ...
[10:29:53.384] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.384] Resolving globals: FALSE
[10:29:53.384] Tweak future expression to call with '...' arguments ...
[10:29:53.384] {
[10:29:53.384]     do.call(function(...) {
[10:29:53.384]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.384]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.384]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.384]             on.exit(options(oopts), add = TRUE)
[10:29:53.384]         }
[10:29:53.384]         {
[10:29:53.384]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.384]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.384]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.384]             })
[10:29:53.384]         }
[10:29:53.384]     }, args = future.call.arguments)
[10:29:53.384] }
[10:29:53.384] Tweak future expression to call with '...' arguments ... DONE
[10:29:53.385] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.385] 
[10:29:53.385] getGlobalsAndPackages() ... DONE
[10:29:53.385] run() for ‘Future’ ...
[10:29:53.385] - state: ‘created’
[10:29:53.386] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:53.389] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.391] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:53.391]   - Field: ‘label’
[10:29:53.391]   - Field: ‘local’
[10:29:53.391]   - Field: ‘owner’
[10:29:53.391]   - Field: ‘envir’
[10:29:53.391]   - Field: ‘packages’
[10:29:53.391]   - Field: ‘gc’
[10:29:53.392]   - Field: ‘conditions’
[10:29:53.392]   - Field: ‘expr’
[10:29:53.392]   - Field: ‘uuid’
[10:29:53.392]   - Field: ‘seed’
[10:29:53.392]   - Field: ‘version’
[10:29:53.392]   - Field: ‘result’
[10:29:53.392]   - Field: ‘asynchronous’
[10:29:53.392]   - Field: ‘calls’
[10:29:53.392]   - Field: ‘globals’
[10:29:53.392]   - Field: ‘stdout’
[10:29:53.393]   - Field: ‘earlySignal’
[10:29:53.393]   - Field: ‘lazy’
[10:29:53.393]   - Field: ‘state’
[10:29:53.393] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:53.393] - Launch lazy future ...
[10:29:53.393] Packages needed by the future expression (n = 1): ‘stats’
[10:29:53.393] Packages needed by future strategies (n = 0): <none>
[10:29:53.394] {
[10:29:53.394]     {
[10:29:53.394]         {
[10:29:53.394]             ...future.startTime <- base::Sys.time()
[10:29:53.394]             {
[10:29:53.394]                 {
[10:29:53.394]                   {
[10:29:53.394]                     {
[10:29:53.394]                       base::local({
[10:29:53.394]                         has_future <- base::requireNamespace("future", 
[10:29:53.394]                           quietly = TRUE)
[10:29:53.394]                         if (has_future) {
[10:29:53.394]                           ns <- base::getNamespace("future")
[10:29:53.394]                           version <- ns[[".package"]][["version"]]
[10:29:53.394]                           if (is.null(version)) 
[10:29:53.394]                             version <- utils::packageVersion("future")
[10:29:53.394]                         }
[10:29:53.394]                         else {
[10:29:53.394]                           version <- NULL
[10:29:53.394]                         }
[10:29:53.394]                         if (!has_future || version < "1.8.0") {
[10:29:53.394]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:53.394]                             "", base::R.version$version.string), 
[10:29:53.394]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:53.394]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:53.394]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:53.394]                               "release", "version")], collapse = " "), 
[10:29:53.394]                             hostname = base::Sys.info()[["nodename"]])
[10:29:53.394]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:53.394]                             info)
[10:29:53.394]                           info <- base::paste(info, collapse = "; ")
[10:29:53.394]                           if (!has_future) {
[10:29:53.394]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:53.394]                               info)
[10:29:53.394]                           }
[10:29:53.394]                           else {
[10:29:53.394]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:53.394]                               info, version)
[10:29:53.394]                           }
[10:29:53.394]                           base::stop(msg)
[10:29:53.394]                         }
[10:29:53.394]                       })
[10:29:53.394]                     }
[10:29:53.394]                     base::local({
[10:29:53.394]                       for (pkg in "stats") {
[10:29:53.394]                         base::loadNamespace(pkg)
[10:29:53.394]                         base::library(pkg, character.only = TRUE)
[10:29:53.394]                       }
[10:29:53.394]                     })
[10:29:53.394]                   }
[10:29:53.394]                   ...future.strategy.old <- future::plan("list")
[10:29:53.394]                   options(future.plan = NULL)
[10:29:53.394]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.394]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:53.394]                 }
[10:29:53.394]                 ...future.workdir <- getwd()
[10:29:53.394]             }
[10:29:53.394]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:53.394]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:53.394]         }
[10:29:53.394]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:53.394]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:53.394]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:53.394]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:53.394]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:53.394]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:53.394]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:53.394]             base::names(...future.oldOptions))
[10:29:53.394]     }
[10:29:53.394]     if (FALSE) {
[10:29:53.394]     }
[10:29:53.394]     else {
[10:29:53.394]         if (TRUE) {
[10:29:53.394]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:53.394]                 open = "w")
[10:29:53.394]         }
[10:29:53.394]         else {
[10:29:53.394]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:53.394]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:53.394]         }
[10:29:53.394]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:53.394]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:53.394]             base::sink(type = "output", split = FALSE)
[10:29:53.394]             base::close(...future.stdout)
[10:29:53.394]         }, add = TRUE)
[10:29:53.394]     }
[10:29:53.394]     ...future.frame <- base::sys.nframe()
[10:29:53.394]     ...future.conditions <- base::list()
[10:29:53.394]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:53.394]     if (FALSE) {
[10:29:53.394]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:53.394]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:53.394]     }
[10:29:53.394]     ...future.result <- base::tryCatch({
[10:29:53.394]         base::withCallingHandlers({
[10:29:53.394]             ...future.value <- base::withVisible(base::local({
[10:29:53.394]                 do.call(function(...) {
[10:29:53.394]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.394]                   if (!identical(...future.globals.maxSize.org, 
[10:29:53.394]                     ...future.globals.maxSize)) {
[10:29:53.394]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.394]                     on.exit(options(oopts), add = TRUE)
[10:29:53.394]                   }
[10:29:53.394]                   {
[10:29:53.394]                     lapply(seq_along(...future.elements_ii), 
[10:29:53.394]                       FUN = function(jj) {
[10:29:53.394]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.394]                         ...future.FUN(...future.X_jj, ...)
[10:29:53.394]                       })
[10:29:53.394]                   }
[10:29:53.394]                 }, args = future.call.arguments)
[10:29:53.394]             }))
[10:29:53.394]             future::FutureResult(value = ...future.value$value, 
[10:29:53.394]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.394]                   ...future.rng), globalenv = if (FALSE) 
[10:29:53.394]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:53.394]                     ...future.globalenv.names))
[10:29:53.394]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:53.394]         }, condition = base::local({
[10:29:53.394]             c <- base::c
[10:29:53.394]             inherits <- base::inherits
[10:29:53.394]             invokeRestart <- base::invokeRestart
[10:29:53.394]             length <- base::length
[10:29:53.394]             list <- base::list
[10:29:53.394]             seq.int <- base::seq.int
[10:29:53.394]             signalCondition <- base::signalCondition
[10:29:53.394]             sys.calls <- base::sys.calls
[10:29:53.394]             `[[` <- base::`[[`
[10:29:53.394]             `+` <- base::`+`
[10:29:53.394]             `<<-` <- base::`<<-`
[10:29:53.394]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:53.394]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:53.394]                   3L)]
[10:29:53.394]             }
[10:29:53.394]             function(cond) {
[10:29:53.394]                 is_error <- inherits(cond, "error")
[10:29:53.394]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:53.394]                   NULL)
[10:29:53.394]                 if (is_error) {
[10:29:53.394]                   sessionInformation <- function() {
[10:29:53.394]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:53.394]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:53.394]                       search = base::search(), system = base::Sys.info())
[10:29:53.394]                   }
[10:29:53.394]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.394]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:53.394]                     cond$call), session = sessionInformation(), 
[10:29:53.394]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:53.394]                   signalCondition(cond)
[10:29:53.394]                 }
[10:29:53.394]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:53.394]                 "immediateCondition"))) {
[10:29:53.394]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:53.394]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.394]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:53.394]                   if (TRUE && !signal) {
[10:29:53.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.394]                     {
[10:29:53.394]                       inherits <- base::inherits
[10:29:53.394]                       invokeRestart <- base::invokeRestart
[10:29:53.394]                       is.null <- base::is.null
[10:29:53.394]                       muffled <- FALSE
[10:29:53.394]                       if (inherits(cond, "message")) {
[10:29:53.394]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.394]                         if (muffled) 
[10:29:53.394]                           invokeRestart("muffleMessage")
[10:29:53.394]                       }
[10:29:53.394]                       else if (inherits(cond, "warning")) {
[10:29:53.394]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.394]                         if (muffled) 
[10:29:53.394]                           invokeRestart("muffleWarning")
[10:29:53.394]                       }
[10:29:53.394]                       else if (inherits(cond, "condition")) {
[10:29:53.394]                         if (!is.null(pattern)) {
[10:29:53.394]                           computeRestarts <- base::computeRestarts
[10:29:53.394]                           grepl <- base::grepl
[10:29:53.394]                           restarts <- computeRestarts(cond)
[10:29:53.394]                           for (restart in restarts) {
[10:29:53.394]                             name <- restart$name
[10:29:53.394]                             if (is.null(name)) 
[10:29:53.394]                               next
[10:29:53.394]                             if (!grepl(pattern, name)) 
[10:29:53.394]                               next
[10:29:53.394]                             invokeRestart(restart)
[10:29:53.394]                             muffled <- TRUE
[10:29:53.394]                             break
[10:29:53.394]                           }
[10:29:53.394]                         }
[10:29:53.394]                       }
[10:29:53.394]                       invisible(muffled)
[10:29:53.394]                     }
[10:29:53.394]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.394]                   }
[10:29:53.394]                 }
[10:29:53.394]                 else {
[10:29:53.394]                   if (TRUE) {
[10:29:53.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.394]                     {
[10:29:53.394]                       inherits <- base::inherits
[10:29:53.394]                       invokeRestart <- base::invokeRestart
[10:29:53.394]                       is.null <- base::is.null
[10:29:53.394]                       muffled <- FALSE
[10:29:53.394]                       if (inherits(cond, "message")) {
[10:29:53.394]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.394]                         if (muffled) 
[10:29:53.394]                           invokeRestart("muffleMessage")
[10:29:53.394]                       }
[10:29:53.394]                       else if (inherits(cond, "warning")) {
[10:29:53.394]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.394]                         if (muffled) 
[10:29:53.394]                           invokeRestart("muffleWarning")
[10:29:53.394]                       }
[10:29:53.394]                       else if (inherits(cond, "condition")) {
[10:29:53.394]                         if (!is.null(pattern)) {
[10:29:53.394]                           computeRestarts <- base::computeRestarts
[10:29:53.394]                           grepl <- base::grepl
[10:29:53.394]                           restarts <- computeRestarts(cond)
[10:29:53.394]                           for (restart in restarts) {
[10:29:53.394]                             name <- restart$name
[10:29:53.394]                             if (is.null(name)) 
[10:29:53.394]                               next
[10:29:53.394]                             if (!grepl(pattern, name)) 
[10:29:53.394]                               next
[10:29:53.394]                             invokeRestart(restart)
[10:29:53.394]                             muffled <- TRUE
[10:29:53.394]                             break
[10:29:53.394]                           }
[10:29:53.394]                         }
[10:29:53.394]                       }
[10:29:53.394]                       invisible(muffled)
[10:29:53.394]                     }
[10:29:53.394]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.394]                   }
[10:29:53.394]                 }
[10:29:53.394]             }
[10:29:53.394]         }))
[10:29:53.394]     }, error = function(ex) {
[10:29:53.394]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:53.394]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.394]                 ...future.rng), started = ...future.startTime, 
[10:29:53.394]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:53.394]             version = "1.8"), class = "FutureResult")
[10:29:53.394]     }, finally = {
[10:29:53.394]         if (!identical(...future.workdir, getwd())) 
[10:29:53.394]             setwd(...future.workdir)
[10:29:53.394]         {
[10:29:53.394]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:53.394]                 ...future.oldOptions$nwarnings <- NULL
[10:29:53.394]             }
[10:29:53.394]             base::options(...future.oldOptions)
[10:29:53.394]             if (.Platform$OS.type == "windows") {
[10:29:53.394]                 old_names <- names(...future.oldEnvVars)
[10:29:53.394]                 envs <- base::Sys.getenv()
[10:29:53.394]                 names <- names(envs)
[10:29:53.394]                 common <- intersect(names, old_names)
[10:29:53.394]                 added <- setdiff(names, old_names)
[10:29:53.394]                 removed <- setdiff(old_names, names)
[10:29:53.394]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:53.394]                   envs[common]]
[10:29:53.394]                 NAMES <- toupper(changed)
[10:29:53.394]                 args <- list()
[10:29:53.394]                 for (kk in seq_along(NAMES)) {
[10:29:53.394]                   name <- changed[[kk]]
[10:29:53.394]                   NAME <- NAMES[[kk]]
[10:29:53.394]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.394]                     next
[10:29:53.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.394]                 }
[10:29:53.394]                 NAMES <- toupper(added)
[10:29:53.394]                 for (kk in seq_along(NAMES)) {
[10:29:53.394]                   name <- added[[kk]]
[10:29:53.394]                   NAME <- NAMES[[kk]]
[10:29:53.394]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.394]                     next
[10:29:53.394]                   args[[name]] <- ""
[10:29:53.394]                 }
[10:29:53.394]                 NAMES <- toupper(removed)
[10:29:53.394]                 for (kk in seq_along(NAMES)) {
[10:29:53.394]                   name <- removed[[kk]]
[10:29:53.394]                   NAME <- NAMES[[kk]]
[10:29:53.394]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.394]                     next
[10:29:53.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.394]                 }
[10:29:53.394]                 if (length(args) > 0) 
[10:29:53.394]                   base::do.call(base::Sys.setenv, args = args)
[10:29:53.394]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:53.394]             }
[10:29:53.394]             else {
[10:29:53.394]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:53.394]             }
[10:29:53.394]             {
[10:29:53.394]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:53.394]                   0L) {
[10:29:53.394]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:53.394]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:53.394]                   base::options(opts)
[10:29:53.394]                 }
[10:29:53.394]                 {
[10:29:53.394]                   {
[10:29:53.394]                     NULL
[10:29:53.394]                     RNGkind("Mersenne-Twister")
[10:29:53.394]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:53.394]                       inherits = FALSE)
[10:29:53.394]                   }
[10:29:53.394]                   options(future.plan = NULL)
[10:29:53.394]                   if (is.na(NA_character_)) 
[10:29:53.394]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.394]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:53.394]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:53.394]                     .init = FALSE)
[10:29:53.394]                 }
[10:29:53.394]             }
[10:29:53.394]         }
[10:29:53.394]     })
[10:29:53.394]     if (TRUE) {
[10:29:53.394]         base::sink(type = "output", split = FALSE)
[10:29:53.394]         if (TRUE) {
[10:29:53.394]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:53.394]         }
[10:29:53.394]         else {
[10:29:53.394]             ...future.result["stdout"] <- base::list(NULL)
[10:29:53.394]         }
[10:29:53.394]         base::close(...future.stdout)
[10:29:53.394]         ...future.stdout <- NULL
[10:29:53.394]     }
[10:29:53.394]     ...future.result$conditions <- ...future.conditions
[10:29:53.394]     ...future.result$finished <- base::Sys.time()
[10:29:53.394]     ...future.result
[10:29:53.394] }
[10:29:53.396] assign_globals() ...
[10:29:53.396] List of 5
[10:29:53.396]  $ ...future.FUN            :function (x, ...)  
[10:29:53.396]  $ future.call.arguments    :List of 1
[10:29:53.396]   ..$ singular.ok: logi FALSE
[10:29:53.396]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.396]  $ ...future.elements_ii    :List of 3
[10:29:53.396]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.396]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:29:53.396]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.396]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:53.396]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.396]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:29:53.396]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.396]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:29:53.396]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.396]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:29:53.396]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.396]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:29:53.396]  $ ...future.seeds_ii       : NULL
[10:29:53.396]  $ ...future.globals.maxSize: NULL
[10:29:53.396]  - attr(*, "where")=List of 5
[10:29:53.396]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:53.396]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:53.396]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:53.396]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:53.396]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:53.396]  - attr(*, "resolved")= logi FALSE
[10:29:53.396]  - attr(*, "total_size")= num 5384
[10:29:53.396]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.396]  - attr(*, "already-done")= logi TRUE
[10:29:53.405] - reassign environment for ‘...future.FUN’
[10:29:53.405] - copied ‘...future.FUN’ to environment
[10:29:53.405] - copied ‘future.call.arguments’ to environment
[10:29:53.405] - copied ‘...future.elements_ii’ to environment
[10:29:53.406] - copied ‘...future.seeds_ii’ to environment
[10:29:53.406] - copied ‘...future.globals.maxSize’ to environment
[10:29:53.406] assign_globals() ... done
[10:29:53.406] plan(): Setting new future strategy stack:
[10:29:53.406] List of future strategies:
[10:29:53.406] 1. sequential:
[10:29:53.406]    - args: function (..., envir = parent.frame())
[10:29:53.406]    - tweaked: FALSE
[10:29:53.406]    - call: NULL
[10:29:53.407] plan(): nbrOfWorkers() = 1
[10:29:53.410] plan(): Setting new future strategy stack:
[10:29:53.410] List of future strategies:
[10:29:53.410] 1. multicore:
[10:29:53.410]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:53.410]    - tweaked: FALSE
[10:29:53.410]    - call: plan(strategy)
[10:29:53.413] plan(): nbrOfWorkers() = 1
[10:29:53.414] SequentialFuture started (and completed)
[10:29:53.414] - Launch lazy future ... done
[10:29:53.414] run() for ‘SequentialFuture’ ... done
[10:29:53.414] Created future:
[10:29:53.414] SequentialFuture:
[10:29:53.414] Label: ‘future_by-1’
[10:29:53.414] Expression:
[10:29:53.414] {
[10:29:53.414]     do.call(function(...) {
[10:29:53.414]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.414]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.414]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.414]             on.exit(options(oopts), add = TRUE)
[10:29:53.414]         }
[10:29:53.414]         {
[10:29:53.414]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.414]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.414]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.414]             })
[10:29:53.414]         }
[10:29:53.414]     }, args = future.call.arguments)
[10:29:53.414] }
[10:29:53.414] Lazy evaluation: FALSE
[10:29:53.414] Asynchronous evaluation: FALSE
[10:29:53.414] Local evaluation: TRUE
[10:29:53.414] Environment: R_GlobalEnv
[10:29:53.414] Capture standard output: TRUE
[10:29:53.414] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:53.414] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:53.414] Packages: 1 packages (‘stats’)
[10:29:53.414] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:53.414] Resolved: TRUE
[10:29:53.414] Value: 26.06 KiB of class ‘list’
[10:29:53.414] Early signaling: FALSE
[10:29:53.414] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:53.414] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.416] Chunk #1 of 1 ... DONE
[10:29:53.416] Launching 1 futures (chunks) ... DONE
[10:29:53.416] Resolving 1 futures (chunks) ...
[10:29:53.416] resolve() on list ...
[10:29:53.416]  recursive: 0
[10:29:53.418]  length: 1
[10:29:53.418] 
[10:29:53.418] resolved() for ‘SequentialFuture’ ...
[10:29:53.418] - state: ‘finished’
[10:29:53.418] - run: TRUE
[10:29:53.418] - result: ‘FutureResult’
[10:29:53.419] resolved() for ‘SequentialFuture’ ... done
[10:29:53.419] Future #1
[10:29:53.419] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:53.419] - nx: 1
[10:29:53.419] - relay: TRUE
[10:29:53.419] - stdout: TRUE
[10:29:53.419] - signal: TRUE
[10:29:53.419] - resignal: FALSE
[10:29:53.419] - force: TRUE
[10:29:53.420] - relayed: [n=1] FALSE
[10:29:53.420] - queued futures: [n=1] FALSE
[10:29:53.420]  - until=1
[10:29:53.420]  - relaying element #1
[10:29:53.420] - relayed: [n=1] TRUE
[10:29:53.420] - queued futures: [n=1] TRUE
[10:29:53.420] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:53.420]  length: 0 (resolved future 1)
[10:29:53.421] Relaying remaining futures
[10:29:53.421] signalConditionsASAP(NULL, pos=0) ...
[10:29:53.421] - nx: 1
[10:29:53.421] - relay: TRUE
[10:29:53.421] - stdout: TRUE
[10:29:53.421] - signal: TRUE
[10:29:53.421] - resignal: FALSE
[10:29:53.421] - force: TRUE
[10:29:53.421] - relayed: [n=1] TRUE
[10:29:53.421] - queued futures: [n=1] TRUE
 - flush all
[10:29:53.421] - relayed: [n=1] TRUE
[10:29:53.422] - queued futures: [n=1] TRUE
[10:29:53.422] signalConditionsASAP(NULL, pos=0) ... done
[10:29:53.422] resolve() on list ... DONE
[10:29:53.422]  - Number of value chunks collected: 1
[10:29:53.422] Resolving 1 futures (chunks) ... DONE
[10:29:53.422] Reducing values from 1 chunks ...
[10:29:53.422]  - Number of values collected after concatenation: 3
[10:29:53.422]  - Number of values expected: 3
[10:29:53.422] Reducing values from 1 chunks ... DONE
[10:29:53.422] future_lapply() ... DONE
[10:29:53.423] future_by_internal() ... DONE
[10:29:53.427] future_by_internal() ...
[10:29:53.427] future_lapply() ...
[10:29:53.431] Number of chunks: 1
[10:29:53.431] getGlobalsAndPackagesXApply() ...
[10:29:53.431]  - future.globals: TRUE
[10:29:53.431] getGlobalsAndPackages() ...
[10:29:53.431] Searching for globals...
[10:29:53.433] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:29:53.433] Searching for globals ... DONE
[10:29:53.433] Resolving globals: FALSE
[10:29:53.434] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[10:29:53.434] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[10:29:53.434] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[10:29:53.435] - packages: [1] ‘stats’
[10:29:53.435] getGlobalsAndPackages() ... DONE
[10:29:53.435]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[10:29:53.435]  - needed namespaces: [n=1] ‘stats’
[10:29:53.435] Finding globals ... DONE
[10:29:53.435]  - use_args: TRUE
[10:29:53.435]  - Getting '...' globals ...
[10:29:53.435] resolve() on list ...
[10:29:53.435]  recursive: 0
[10:29:53.436]  length: 1
[10:29:53.436]  elements: ‘...’
[10:29:53.436]  length: 0 (resolved future 1)
[10:29:53.436] resolve() on list ... DONE
[10:29:53.436]    - '...' content: [n=0] 
[10:29:53.436] List of 1
[10:29:53.436]  $ ...: list()
[10:29:53.436]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.436]  - attr(*, "where")=List of 1
[10:29:53.436]   ..$ ...:<environment: 0x556dd4d77408> 
[10:29:53.436]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.436]  - attr(*, "resolved")= logi TRUE
[10:29:53.436]  - attr(*, "total_size")= num NA
[10:29:53.439]  - Getting '...' globals ... DONE
[10:29:53.439] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[10:29:53.439] List of 4
[10:29:53.439]  $ ...future.FUN:function (x)  
[10:29:53.439]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:29:53.439]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:53.439]  $ ...          : list()
[10:29:53.439]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.439]  - attr(*, "where")=List of 4
[10:29:53.439]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:53.439]   ..$ breaks       :<environment: R_EmptyEnv> 
[10:29:53.439]   ..$ wool         :<environment: R_EmptyEnv> 
[10:29:53.439]   ..$ ...          :<environment: 0x556dd4d77408> 
[10:29:53.439]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.439]  - attr(*, "resolved")= logi FALSE
[10:29:53.439]  - attr(*, "total_size")= num 2320
[10:29:53.444] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:53.444] getGlobalsAndPackagesXApply() ... DONE
[10:29:53.445] Number of futures (= number of chunks): 1
[10:29:53.445] Launching 1 futures (chunks) ...
[10:29:53.445] Chunk #1 of 1 ...
[10:29:53.445]  - Finding globals in 'X' for chunk #1 ...
[10:29:53.445] getGlobalsAndPackages() ...
[10:29:53.445] Searching for globals...
[10:29:53.446] 
[10:29:53.446] Searching for globals ... DONE
[10:29:53.446] - globals: [0] <none>
[10:29:53.446] getGlobalsAndPackages() ... DONE
[10:29:53.446]    + additional globals found: [n=0] 
[10:29:53.446]    + additional namespaces needed: [n=0] 
[10:29:53.446]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:53.446]  - seeds: <none>
[10:29:53.446]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.447] getGlobalsAndPackages() ...
[10:29:53.447] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.447] Resolving globals: FALSE
[10:29:53.447] Tweak future expression to call with '...' arguments ...
[10:29:53.447] {
[10:29:53.447]     do.call(function(...) {
[10:29:53.447]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.447]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.447]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.447]             on.exit(options(oopts), add = TRUE)
[10:29:53.447]         }
[10:29:53.447]         {
[10:29:53.447]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.447]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.447]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.447]             })
[10:29:53.447]         }
[10:29:53.447]     }, args = future.call.arguments)
[10:29:53.447] }
[10:29:53.447] Tweak future expression to call with '...' arguments ... DONE
[10:29:53.448] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.448] 
[10:29:53.448] getGlobalsAndPackages() ... DONE
[10:29:53.448] run() for ‘Future’ ...
[10:29:53.448] - state: ‘created’
[10:29:53.448] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:53.452] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.452] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:53.452]   - Field: ‘label’
[10:29:53.452]   - Field: ‘local’
[10:29:53.452]   - Field: ‘owner’
[10:29:53.452]   - Field: ‘envir’
[10:29:53.452]   - Field: ‘packages’
[10:29:53.453]   - Field: ‘gc’
[10:29:53.453]   - Field: ‘conditions’
[10:29:53.453]   - Field: ‘expr’
[10:29:53.453]   - Field: ‘uuid’
[10:29:53.453]   - Field: ‘seed’
[10:29:53.453]   - Field: ‘version’
[10:29:53.453]   - Field: ‘result’
[10:29:53.453]   - Field: ‘asynchronous’
[10:29:53.453]   - Field: ‘calls’
[10:29:53.453]   - Field: ‘globals’
[10:29:53.454]   - Field: ‘stdout’
[10:29:53.454]   - Field: ‘earlySignal’
[10:29:53.454]   - Field: ‘lazy’
[10:29:53.454]   - Field: ‘state’
[10:29:53.454] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:53.454] - Launch lazy future ...
[10:29:53.454] Packages needed by the future expression (n = 1): ‘stats’
[10:29:53.454] Packages needed by future strategies (n = 0): <none>
[10:29:53.455] {
[10:29:53.455]     {
[10:29:53.455]         {
[10:29:53.455]             ...future.startTime <- base::Sys.time()
[10:29:53.455]             {
[10:29:53.455]                 {
[10:29:53.455]                   {
[10:29:53.455]                     {
[10:29:53.455]                       base::local({
[10:29:53.455]                         has_future <- base::requireNamespace("future", 
[10:29:53.455]                           quietly = TRUE)
[10:29:53.455]                         if (has_future) {
[10:29:53.455]                           ns <- base::getNamespace("future")
[10:29:53.455]                           version <- ns[[".package"]][["version"]]
[10:29:53.455]                           if (is.null(version)) 
[10:29:53.455]                             version <- utils::packageVersion("future")
[10:29:53.455]                         }
[10:29:53.455]                         else {
[10:29:53.455]                           version <- NULL
[10:29:53.455]                         }
[10:29:53.455]                         if (!has_future || version < "1.8.0") {
[10:29:53.455]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:53.455]                             "", base::R.version$version.string), 
[10:29:53.455]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:53.455]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:53.455]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:53.455]                               "release", "version")], collapse = " "), 
[10:29:53.455]                             hostname = base::Sys.info()[["nodename"]])
[10:29:53.455]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:53.455]                             info)
[10:29:53.455]                           info <- base::paste(info, collapse = "; ")
[10:29:53.455]                           if (!has_future) {
[10:29:53.455]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:53.455]                               info)
[10:29:53.455]                           }
[10:29:53.455]                           else {
[10:29:53.455]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:53.455]                               info, version)
[10:29:53.455]                           }
[10:29:53.455]                           base::stop(msg)
[10:29:53.455]                         }
[10:29:53.455]                       })
[10:29:53.455]                     }
[10:29:53.455]                     base::local({
[10:29:53.455]                       for (pkg in "stats") {
[10:29:53.455]                         base::loadNamespace(pkg)
[10:29:53.455]                         base::library(pkg, character.only = TRUE)
[10:29:53.455]                       }
[10:29:53.455]                     })
[10:29:53.455]                   }
[10:29:53.455]                   ...future.strategy.old <- future::plan("list")
[10:29:53.455]                   options(future.plan = NULL)
[10:29:53.455]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.455]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:53.455]                 }
[10:29:53.455]                 ...future.workdir <- getwd()
[10:29:53.455]             }
[10:29:53.455]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:53.455]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:53.455]         }
[10:29:53.455]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:53.455]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:53.455]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:53.455]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:53.455]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:53.455]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:53.455]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:53.455]             base::names(...future.oldOptions))
[10:29:53.455]     }
[10:29:53.455]     if (FALSE) {
[10:29:53.455]     }
[10:29:53.455]     else {
[10:29:53.455]         if (TRUE) {
[10:29:53.455]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:53.455]                 open = "w")
[10:29:53.455]         }
[10:29:53.455]         else {
[10:29:53.455]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:53.455]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:53.455]         }
[10:29:53.455]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:53.455]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:53.455]             base::sink(type = "output", split = FALSE)
[10:29:53.455]             base::close(...future.stdout)
[10:29:53.455]         }, add = TRUE)
[10:29:53.455]     }
[10:29:53.455]     ...future.frame <- base::sys.nframe()
[10:29:53.455]     ...future.conditions <- base::list()
[10:29:53.455]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:53.455]     if (FALSE) {
[10:29:53.455]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:53.455]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:53.455]     }
[10:29:53.455]     ...future.result <- base::tryCatch({
[10:29:53.455]         base::withCallingHandlers({
[10:29:53.455]             ...future.value <- base::withVisible(base::local({
[10:29:53.455]                 do.call(function(...) {
[10:29:53.455]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.455]                   if (!identical(...future.globals.maxSize.org, 
[10:29:53.455]                     ...future.globals.maxSize)) {
[10:29:53.455]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.455]                     on.exit(options(oopts), add = TRUE)
[10:29:53.455]                   }
[10:29:53.455]                   {
[10:29:53.455]                     lapply(seq_along(...future.elements_ii), 
[10:29:53.455]                       FUN = function(jj) {
[10:29:53.455]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.455]                         ...future.FUN(...future.X_jj, ...)
[10:29:53.455]                       })
[10:29:53.455]                   }
[10:29:53.455]                 }, args = future.call.arguments)
[10:29:53.455]             }))
[10:29:53.455]             future::FutureResult(value = ...future.value$value, 
[10:29:53.455]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.455]                   ...future.rng), globalenv = if (FALSE) 
[10:29:53.455]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:53.455]                     ...future.globalenv.names))
[10:29:53.455]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:53.455]         }, condition = base::local({
[10:29:53.455]             c <- base::c
[10:29:53.455]             inherits <- base::inherits
[10:29:53.455]             invokeRestart <- base::invokeRestart
[10:29:53.455]             length <- base::length
[10:29:53.455]             list <- base::list
[10:29:53.455]             seq.int <- base::seq.int
[10:29:53.455]             signalCondition <- base::signalCondition
[10:29:53.455]             sys.calls <- base::sys.calls
[10:29:53.455]             `[[` <- base::`[[`
[10:29:53.455]             `+` <- base::`+`
[10:29:53.455]             `<<-` <- base::`<<-`
[10:29:53.455]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:53.455]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:53.455]                   3L)]
[10:29:53.455]             }
[10:29:53.455]             function(cond) {
[10:29:53.455]                 is_error <- inherits(cond, "error")
[10:29:53.455]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:53.455]                   NULL)
[10:29:53.455]                 if (is_error) {
[10:29:53.455]                   sessionInformation <- function() {
[10:29:53.455]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:53.455]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:53.455]                       search = base::search(), system = base::Sys.info())
[10:29:53.455]                   }
[10:29:53.455]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.455]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:53.455]                     cond$call), session = sessionInformation(), 
[10:29:53.455]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:53.455]                   signalCondition(cond)
[10:29:53.455]                 }
[10:29:53.455]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:53.455]                 "immediateCondition"))) {
[10:29:53.455]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:53.455]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.455]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:53.455]                   if (TRUE && !signal) {
[10:29:53.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.455]                     {
[10:29:53.455]                       inherits <- base::inherits
[10:29:53.455]                       invokeRestart <- base::invokeRestart
[10:29:53.455]                       is.null <- base::is.null
[10:29:53.455]                       muffled <- FALSE
[10:29:53.455]                       if (inherits(cond, "message")) {
[10:29:53.455]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.455]                         if (muffled) 
[10:29:53.455]                           invokeRestart("muffleMessage")
[10:29:53.455]                       }
[10:29:53.455]                       else if (inherits(cond, "warning")) {
[10:29:53.455]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.455]                         if (muffled) 
[10:29:53.455]                           invokeRestart("muffleWarning")
[10:29:53.455]                       }
[10:29:53.455]                       else if (inherits(cond, "condition")) {
[10:29:53.455]                         if (!is.null(pattern)) {
[10:29:53.455]                           computeRestarts <- base::computeRestarts
[10:29:53.455]                           grepl <- base::grepl
[10:29:53.455]                           restarts <- computeRestarts(cond)
[10:29:53.455]                           for (restart in restarts) {
[10:29:53.455]                             name <- restart$name
[10:29:53.455]                             if (is.null(name)) 
[10:29:53.455]                               next
[10:29:53.455]                             if (!grepl(pattern, name)) 
[10:29:53.455]                               next
[10:29:53.455]                             invokeRestart(restart)
[10:29:53.455]                             muffled <- TRUE
[10:29:53.455]                             break
[10:29:53.455]                           }
[10:29:53.455]                         }
[10:29:53.455]                       }
[10:29:53.455]                       invisible(muffled)
[10:29:53.455]                     }
[10:29:53.455]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.455]                   }
[10:29:53.455]                 }
[10:29:53.455]                 else {
[10:29:53.455]                   if (TRUE) {
[10:29:53.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.455]                     {
[10:29:53.455]                       inherits <- base::inherits
[10:29:53.455]                       invokeRestart <- base::invokeRestart
[10:29:53.455]                       is.null <- base::is.null
[10:29:53.455]                       muffled <- FALSE
[10:29:53.455]                       if (inherits(cond, "message")) {
[10:29:53.455]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.455]                         if (muffled) 
[10:29:53.455]                           invokeRestart("muffleMessage")
[10:29:53.455]                       }
[10:29:53.455]                       else if (inherits(cond, "warning")) {
[10:29:53.455]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.455]                         if (muffled) 
[10:29:53.455]                           invokeRestart("muffleWarning")
[10:29:53.455]                       }
[10:29:53.455]                       else if (inherits(cond, "condition")) {
[10:29:53.455]                         if (!is.null(pattern)) {
[10:29:53.455]                           computeRestarts <- base::computeRestarts
[10:29:53.455]                           grepl <- base::grepl
[10:29:53.455]                           restarts <- computeRestarts(cond)
[10:29:53.455]                           for (restart in restarts) {
[10:29:53.455]                             name <- restart$name
[10:29:53.455]                             if (is.null(name)) 
[10:29:53.455]                               next
[10:29:53.455]                             if (!grepl(pattern, name)) 
[10:29:53.455]                               next
[10:29:53.455]                             invokeRestart(restart)
[10:29:53.455]                             muffled <- TRUE
[10:29:53.455]                             break
[10:29:53.455]                           }
[10:29:53.455]                         }
[10:29:53.455]                       }
[10:29:53.455]                       invisible(muffled)
[10:29:53.455]                     }
[10:29:53.455]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.455]                   }
[10:29:53.455]                 }
[10:29:53.455]             }
[10:29:53.455]         }))
[10:29:53.455]     }, error = function(ex) {
[10:29:53.455]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:53.455]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.455]                 ...future.rng), started = ...future.startTime, 
[10:29:53.455]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:53.455]             version = "1.8"), class = "FutureResult")
[10:29:53.455]     }, finally = {
[10:29:53.455]         if (!identical(...future.workdir, getwd())) 
[10:29:53.455]             setwd(...future.workdir)
[10:29:53.455]         {
[10:29:53.455]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:53.455]                 ...future.oldOptions$nwarnings <- NULL
[10:29:53.455]             }
[10:29:53.455]             base::options(...future.oldOptions)
[10:29:53.455]             if (.Platform$OS.type == "windows") {
[10:29:53.455]                 old_names <- names(...future.oldEnvVars)
[10:29:53.455]                 envs <- base::Sys.getenv()
[10:29:53.455]                 names <- names(envs)
[10:29:53.455]                 common <- intersect(names, old_names)
[10:29:53.455]                 added <- setdiff(names, old_names)
[10:29:53.455]                 removed <- setdiff(old_names, names)
[10:29:53.455]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:53.455]                   envs[common]]
[10:29:53.455]                 NAMES <- toupper(changed)
[10:29:53.455]                 args <- list()
[10:29:53.455]                 for (kk in seq_along(NAMES)) {
[10:29:53.455]                   name <- changed[[kk]]
[10:29:53.455]                   NAME <- NAMES[[kk]]
[10:29:53.455]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.455]                     next
[10:29:53.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.455]                 }
[10:29:53.455]                 NAMES <- toupper(added)
[10:29:53.455]                 for (kk in seq_along(NAMES)) {
[10:29:53.455]                   name <- added[[kk]]
[10:29:53.455]                   NAME <- NAMES[[kk]]
[10:29:53.455]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.455]                     next
[10:29:53.455]                   args[[name]] <- ""
[10:29:53.455]                 }
[10:29:53.455]                 NAMES <- toupper(removed)
[10:29:53.455]                 for (kk in seq_along(NAMES)) {
[10:29:53.455]                   name <- removed[[kk]]
[10:29:53.455]                   NAME <- NAMES[[kk]]
[10:29:53.455]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.455]                     next
[10:29:53.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.455]                 }
[10:29:53.455]                 if (length(args) > 0) 
[10:29:53.455]                   base::do.call(base::Sys.setenv, args = args)
[10:29:53.455]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:53.455]             }
[10:29:53.455]             else {
[10:29:53.455]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:53.455]             }
[10:29:53.455]             {
[10:29:53.455]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:53.455]                   0L) {
[10:29:53.455]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:53.455]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:53.455]                   base::options(opts)
[10:29:53.455]                 }
[10:29:53.455]                 {
[10:29:53.455]                   {
[10:29:53.455]                     NULL
[10:29:53.455]                     RNGkind("Mersenne-Twister")
[10:29:53.455]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:53.455]                       inherits = FALSE)
[10:29:53.455]                   }
[10:29:53.455]                   options(future.plan = NULL)
[10:29:53.455]                   if (is.na(NA_character_)) 
[10:29:53.455]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.455]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:53.455]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:53.455]                     .init = FALSE)
[10:29:53.455]                 }
[10:29:53.455]             }
[10:29:53.455]         }
[10:29:53.455]     })
[10:29:53.455]     if (TRUE) {
[10:29:53.455]         base::sink(type = "output", split = FALSE)
[10:29:53.455]         if (TRUE) {
[10:29:53.455]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:53.455]         }
[10:29:53.455]         else {
[10:29:53.455]             ...future.result["stdout"] <- base::list(NULL)
[10:29:53.455]         }
[10:29:53.455]         base::close(...future.stdout)
[10:29:53.455]         ...future.stdout <- NULL
[10:29:53.455]     }
[10:29:53.455]     ...future.result$conditions <- ...future.conditions
[10:29:53.455]     ...future.result$finished <- base::Sys.time()
[10:29:53.455]     ...future.result
[10:29:53.455] }
[10:29:53.457] assign_globals() ...
[10:29:53.457] List of 7
[10:29:53.457]  $ ...future.FUN            :function (x)  
[10:29:53.457]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:29:53.457]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:53.457]  $ future.call.arguments    : list()
[10:29:53.457]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.457]  $ ...future.elements_ii    :List of 3
[10:29:53.457]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.457]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:29:53.457]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.457]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:53.457]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.457]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:29:53.457]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.457]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:29:53.457]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.457]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:29:53.457]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.457]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:29:53.457]  $ ...future.seeds_ii       : NULL
[10:29:53.457]  $ ...future.globals.maxSize: NULL
[10:29:53.457]  - attr(*, "where")=List of 7
[10:29:53.457]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:53.457]   ..$ breaks                   :<environment: R_EmptyEnv> 
[10:29:53.457]   ..$ wool                     :<environment: R_EmptyEnv> 
[10:29:53.457]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:53.457]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:53.457]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:53.457]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:53.457]  - attr(*, "resolved")= logi FALSE
[10:29:53.457]  - attr(*, "total_size")= num 2320
[10:29:53.457]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.457]  - attr(*, "already-done")= logi TRUE
[10:29:53.468] - reassign environment for ‘...future.FUN’
[10:29:53.468] - copied ‘...future.FUN’ to environment
[10:29:53.468] - copied ‘breaks’ to environment
[10:29:53.468] - copied ‘wool’ to environment
[10:29:53.468] - copied ‘future.call.arguments’ to environment
[10:29:53.469] - copied ‘...future.elements_ii’ to environment
[10:29:53.469] - copied ‘...future.seeds_ii’ to environment
[10:29:53.469] - copied ‘...future.globals.maxSize’ to environment
[10:29:53.469] assign_globals() ... done
[10:29:53.469] plan(): Setting new future strategy stack:
[10:29:53.469] List of future strategies:
[10:29:53.469] 1. sequential:
[10:29:53.469]    - args: function (..., envir = parent.frame())
[10:29:53.469]    - tweaked: FALSE
[10:29:53.469]    - call: NULL
[10:29:53.470] plan(): nbrOfWorkers() = 1
[10:29:53.473] plan(): Setting new future strategy stack:
[10:29:53.473] List of future strategies:
[10:29:53.473] 1. multicore:
[10:29:53.473]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:53.473]    - tweaked: FALSE
[10:29:53.473]    - call: plan(strategy)
[10:29:53.476] plan(): nbrOfWorkers() = 1
[10:29:53.477] SequentialFuture started (and completed)
[10:29:53.477] - Launch lazy future ... done
[10:29:53.477] run() for ‘SequentialFuture’ ... done
[10:29:53.477] Created future:
[10:29:53.477] SequentialFuture:
[10:29:53.477] Label: ‘future_by-1’
[10:29:53.477] Expression:
[10:29:53.477] {
[10:29:53.477]     do.call(function(...) {
[10:29:53.477]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.477]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.477]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.477]             on.exit(options(oopts), add = TRUE)
[10:29:53.477]         }
[10:29:53.477]         {
[10:29:53.477]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.477]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.477]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.477]             })
[10:29:53.477]         }
[10:29:53.477]     }, args = future.call.arguments)
[10:29:53.477] }
[10:29:53.477] Lazy evaluation: FALSE
[10:29:53.477] Asynchronous evaluation: FALSE
[10:29:53.477] Local evaluation: TRUE
[10:29:53.477] Environment: 0x556dd4d20538
[10:29:53.477] Capture standard output: TRUE
[10:29:53.477] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:53.477] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[10:29:53.477] Packages: 1 packages (‘stats’)
[10:29:53.477] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:53.477] Resolved: TRUE
[10:29:53.477] Value: 25.57 KiB of class ‘list’
[10:29:53.477] Early signaling: FALSE
[10:29:53.477] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:53.477] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.479] Chunk #1 of 1 ... DONE
[10:29:53.479] Launching 1 futures (chunks) ... DONE
[10:29:53.479] Resolving 1 futures (chunks) ...
[10:29:53.479] resolve() on list ...
[10:29:53.479]  recursive: 0
[10:29:53.479]  length: 1
[10:29:53.479] 
[10:29:53.479] resolved() for ‘SequentialFuture’ ...
[10:29:53.480] - state: ‘finished’
[10:29:53.480] - run: TRUE
[10:29:53.480] - result: ‘FutureResult’
[10:29:53.480] resolved() for ‘SequentialFuture’ ... done
[10:29:53.480] Future #1
[10:29:53.480] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:53.480] - nx: 1
[10:29:53.480] - relay: TRUE
[10:29:53.480] - stdout: TRUE
[10:29:53.480] - signal: TRUE
[10:29:53.480] - resignal: FALSE
[10:29:53.481] - force: TRUE
[10:29:53.481] - relayed: [n=1] FALSE
[10:29:53.481] - queued futures: [n=1] FALSE
[10:29:53.481]  - until=1
[10:29:53.481]  - relaying element #1
[10:29:53.481] - relayed: [n=1] TRUE
[10:29:53.481] - queued futures: [n=1] TRUE
[10:29:53.481] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:53.481]  length: 0 (resolved future 1)
[10:29:53.482] Relaying remaining futures
[10:29:53.482] signalConditionsASAP(NULL, pos=0) ...
[10:29:53.482] - nx: 1
[10:29:53.482] - relay: TRUE
[10:29:53.482] - stdout: TRUE
[10:29:53.482] - signal: TRUE
[10:29:53.482] - resignal: FALSE
[10:29:53.482] - force: TRUE
[10:29:53.482] - relayed: [n=1] TRUE
[10:29:53.482] - queued futures: [n=1] TRUE
 - flush all
[10:29:53.482] - relayed: [n=1] TRUE
[10:29:53.483] - queued futures: [n=1] TRUE
[10:29:53.483] signalConditionsASAP(NULL, pos=0) ... done
[10:29:53.483] resolve() on list ... DONE
[10:29:53.483]  - Number of value chunks collected: 1
[10:29:53.483] Resolving 1 futures (chunks) ... DONE
[10:29:53.483] Reducing values from 1 chunks ...
[10:29:53.483]  - Number of values collected after concatenation: 3
[10:29:53.483]  - Number of values expected: 3
[10:29:53.483] Reducing values from 1 chunks ... DONE
[10:29:53.483] future_lapply() ... DONE
[10:29:53.483] future_by_internal() ... DONE
[10:29:53.484] future_by_internal() ...
[10:29:53.484] future_lapply() ...
[10:29:53.488] Number of chunks: 1
[10:29:53.488] getGlobalsAndPackagesXApply() ...
[10:29:53.488]  - future.globals: TRUE
[10:29:53.488] getGlobalsAndPackages() ...
[10:29:53.488] Searching for globals...
[10:29:53.489] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:53.489] Searching for globals ... DONE
[10:29:53.489] Resolving globals: FALSE
[10:29:53.490] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:53.490] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:53.490] - globals: [1] ‘FUN’
[10:29:53.490] 
[10:29:53.491] getGlobalsAndPackages() ... DONE
[10:29:53.491]  - globals found/used: [n=1] ‘FUN’
[10:29:53.491]  - needed namespaces: [n=0] 
[10:29:53.491] Finding globals ... DONE
[10:29:53.491]  - use_args: TRUE
[10:29:53.491]  - Getting '...' globals ...
[10:29:53.493] resolve() on list ...
[10:29:53.493]  recursive: 0
[10:29:53.493]  length: 1
[10:29:53.493]  elements: ‘...’
[10:29:53.493]  length: 0 (resolved future 1)
[10:29:53.494] resolve() on list ... DONE
[10:29:53.494]    - '...' content: [n=0] 
[10:29:53.494] List of 1
[10:29:53.494]  $ ...: list()
[10:29:53.494]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.494]  - attr(*, "where")=List of 1
[10:29:53.494]   ..$ ...:<environment: 0x556dd51d16b0> 
[10:29:53.494]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.494]  - attr(*, "resolved")= logi TRUE
[10:29:53.494]  - attr(*, "total_size")= num NA
[10:29:53.496]  - Getting '...' globals ... DONE
[10:29:53.497] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:53.497] List of 2
[10:29:53.497]  $ ...future.FUN:function (object, ...)  
[10:29:53.497]  $ ...          : list()
[10:29:53.497]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.497]  - attr(*, "where")=List of 2
[10:29:53.497]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:53.497]   ..$ ...          :<environment: 0x556dd51d16b0> 
[10:29:53.497]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.497]  - attr(*, "resolved")= logi FALSE
[10:29:53.497]  - attr(*, "total_size")= num 1240
[10:29:53.499] Packages to be attached in all futures: [n=0] 
[10:29:53.500] getGlobalsAndPackagesXApply() ... DONE
[10:29:53.500] Number of futures (= number of chunks): 1
[10:29:53.500] Launching 1 futures (chunks) ...
[10:29:53.500] Chunk #1 of 1 ...
[10:29:53.500]  - Finding globals in 'X' for chunk #1 ...
[10:29:53.500] getGlobalsAndPackages() ...
[10:29:53.500] Searching for globals...
[10:29:53.501] 
[10:29:53.501] Searching for globals ... DONE
[10:29:53.501] - globals: [0] <none>
[10:29:53.501] getGlobalsAndPackages() ... DONE
[10:29:53.501]    + additional globals found: [n=0] 
[10:29:53.501]    + additional namespaces needed: [n=0] 
[10:29:53.501]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:53.502]  - seeds: <none>
[10:29:53.502]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.502] getGlobalsAndPackages() ...
[10:29:53.502] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.502] Resolving globals: FALSE
[10:29:53.502] Tweak future expression to call with '...' arguments ...
[10:29:53.502] {
[10:29:53.502]     do.call(function(...) {
[10:29:53.502]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.502]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.502]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.502]             on.exit(options(oopts), add = TRUE)
[10:29:53.502]         }
[10:29:53.502]         {
[10:29:53.502]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.502]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.502]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.502]             })
[10:29:53.502]         }
[10:29:53.502]     }, args = future.call.arguments)
[10:29:53.502] }
[10:29:53.502] Tweak future expression to call with '...' arguments ... DONE
[10:29:53.503] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.503] 
[10:29:53.503] getGlobalsAndPackages() ... DONE
[10:29:53.503] run() for ‘Future’ ...
[10:29:53.503] - state: ‘created’
[10:29:53.503] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:53.507] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.507] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:53.507]   - Field: ‘label’
[10:29:53.507]   - Field: ‘local’
[10:29:53.507]   - Field: ‘owner’
[10:29:53.508]   - Field: ‘envir’
[10:29:53.508]   - Field: ‘packages’
[10:29:53.508]   - Field: ‘gc’
[10:29:53.508]   - Field: ‘conditions’
[10:29:53.508]   - Field: ‘expr’
[10:29:53.508]   - Field: ‘uuid’
[10:29:53.508]   - Field: ‘seed’
[10:29:53.508]   - Field: ‘version’
[10:29:53.508]   - Field: ‘result’
[10:29:53.508]   - Field: ‘asynchronous’
[10:29:53.508]   - Field: ‘calls’
[10:29:53.509]   - Field: ‘globals’
[10:29:53.509]   - Field: ‘stdout’
[10:29:53.509]   - Field: ‘earlySignal’
[10:29:53.509]   - Field: ‘lazy’
[10:29:53.509]   - Field: ‘state’
[10:29:53.509] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:53.509] - Launch lazy future ...
[10:29:53.509] Packages needed by the future expression (n = 0): <none>
[10:29:53.509] Packages needed by future strategies (n = 0): <none>
[10:29:53.510] {
[10:29:53.510]     {
[10:29:53.510]         {
[10:29:53.510]             ...future.startTime <- base::Sys.time()
[10:29:53.510]             {
[10:29:53.510]                 {
[10:29:53.510]                   {
[10:29:53.510]                     base::local({
[10:29:53.510]                       has_future <- base::requireNamespace("future", 
[10:29:53.510]                         quietly = TRUE)
[10:29:53.510]                       if (has_future) {
[10:29:53.510]                         ns <- base::getNamespace("future")
[10:29:53.510]                         version <- ns[[".package"]][["version"]]
[10:29:53.510]                         if (is.null(version)) 
[10:29:53.510]                           version <- utils::packageVersion("future")
[10:29:53.510]                       }
[10:29:53.510]                       else {
[10:29:53.510]                         version <- NULL
[10:29:53.510]                       }
[10:29:53.510]                       if (!has_future || version < "1.8.0") {
[10:29:53.510]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:53.510]                           "", base::R.version$version.string), 
[10:29:53.510]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:53.510]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:53.510]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:53.510]                             "release", "version")], collapse = " "), 
[10:29:53.510]                           hostname = base::Sys.info()[["nodename"]])
[10:29:53.510]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:53.510]                           info)
[10:29:53.510]                         info <- base::paste(info, collapse = "; ")
[10:29:53.510]                         if (!has_future) {
[10:29:53.510]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:53.510]                             info)
[10:29:53.510]                         }
[10:29:53.510]                         else {
[10:29:53.510]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:53.510]                             info, version)
[10:29:53.510]                         }
[10:29:53.510]                         base::stop(msg)
[10:29:53.510]                       }
[10:29:53.510]                     })
[10:29:53.510]                   }
[10:29:53.510]                   ...future.strategy.old <- future::plan("list")
[10:29:53.510]                   options(future.plan = NULL)
[10:29:53.510]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.510]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:53.510]                 }
[10:29:53.510]                 ...future.workdir <- getwd()
[10:29:53.510]             }
[10:29:53.510]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:53.510]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:53.510]         }
[10:29:53.510]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:53.510]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:53.510]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:53.510]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:53.510]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:53.510]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:53.510]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:53.510]             base::names(...future.oldOptions))
[10:29:53.510]     }
[10:29:53.510]     if (FALSE) {
[10:29:53.510]     }
[10:29:53.510]     else {
[10:29:53.510]         if (TRUE) {
[10:29:53.510]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:53.510]                 open = "w")
[10:29:53.510]         }
[10:29:53.510]         else {
[10:29:53.510]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:53.510]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:53.510]         }
[10:29:53.510]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:53.510]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:53.510]             base::sink(type = "output", split = FALSE)
[10:29:53.510]             base::close(...future.stdout)
[10:29:53.510]         }, add = TRUE)
[10:29:53.510]     }
[10:29:53.510]     ...future.frame <- base::sys.nframe()
[10:29:53.510]     ...future.conditions <- base::list()
[10:29:53.510]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:53.510]     if (FALSE) {
[10:29:53.510]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:53.510]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:53.510]     }
[10:29:53.510]     ...future.result <- base::tryCatch({
[10:29:53.510]         base::withCallingHandlers({
[10:29:53.510]             ...future.value <- base::withVisible(base::local({
[10:29:53.510]                 do.call(function(...) {
[10:29:53.510]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.510]                   if (!identical(...future.globals.maxSize.org, 
[10:29:53.510]                     ...future.globals.maxSize)) {
[10:29:53.510]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.510]                     on.exit(options(oopts), add = TRUE)
[10:29:53.510]                   }
[10:29:53.510]                   {
[10:29:53.510]                     lapply(seq_along(...future.elements_ii), 
[10:29:53.510]                       FUN = function(jj) {
[10:29:53.510]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.510]                         ...future.FUN(...future.X_jj, ...)
[10:29:53.510]                       })
[10:29:53.510]                   }
[10:29:53.510]                 }, args = future.call.arguments)
[10:29:53.510]             }))
[10:29:53.510]             future::FutureResult(value = ...future.value$value, 
[10:29:53.510]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.510]                   ...future.rng), globalenv = if (FALSE) 
[10:29:53.510]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:53.510]                     ...future.globalenv.names))
[10:29:53.510]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:53.510]         }, condition = base::local({
[10:29:53.510]             c <- base::c
[10:29:53.510]             inherits <- base::inherits
[10:29:53.510]             invokeRestart <- base::invokeRestart
[10:29:53.510]             length <- base::length
[10:29:53.510]             list <- base::list
[10:29:53.510]             seq.int <- base::seq.int
[10:29:53.510]             signalCondition <- base::signalCondition
[10:29:53.510]             sys.calls <- base::sys.calls
[10:29:53.510]             `[[` <- base::`[[`
[10:29:53.510]             `+` <- base::`+`
[10:29:53.510]             `<<-` <- base::`<<-`
[10:29:53.510]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:53.510]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:53.510]                   3L)]
[10:29:53.510]             }
[10:29:53.510]             function(cond) {
[10:29:53.510]                 is_error <- inherits(cond, "error")
[10:29:53.510]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:53.510]                   NULL)
[10:29:53.510]                 if (is_error) {
[10:29:53.510]                   sessionInformation <- function() {
[10:29:53.510]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:53.510]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:53.510]                       search = base::search(), system = base::Sys.info())
[10:29:53.510]                   }
[10:29:53.510]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.510]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:53.510]                     cond$call), session = sessionInformation(), 
[10:29:53.510]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:53.510]                   signalCondition(cond)
[10:29:53.510]                 }
[10:29:53.510]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:53.510]                 "immediateCondition"))) {
[10:29:53.510]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:53.510]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.510]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:53.510]                   if (TRUE && !signal) {
[10:29:53.510]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.510]                     {
[10:29:53.510]                       inherits <- base::inherits
[10:29:53.510]                       invokeRestart <- base::invokeRestart
[10:29:53.510]                       is.null <- base::is.null
[10:29:53.510]                       muffled <- FALSE
[10:29:53.510]                       if (inherits(cond, "message")) {
[10:29:53.510]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.510]                         if (muffled) 
[10:29:53.510]                           invokeRestart("muffleMessage")
[10:29:53.510]                       }
[10:29:53.510]                       else if (inherits(cond, "warning")) {
[10:29:53.510]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.510]                         if (muffled) 
[10:29:53.510]                           invokeRestart("muffleWarning")
[10:29:53.510]                       }
[10:29:53.510]                       else if (inherits(cond, "condition")) {
[10:29:53.510]                         if (!is.null(pattern)) {
[10:29:53.510]                           computeRestarts <- base::computeRestarts
[10:29:53.510]                           grepl <- base::grepl
[10:29:53.510]                           restarts <- computeRestarts(cond)
[10:29:53.510]                           for (restart in restarts) {
[10:29:53.510]                             name <- restart$name
[10:29:53.510]                             if (is.null(name)) 
[10:29:53.510]                               next
[10:29:53.510]                             if (!grepl(pattern, name)) 
[10:29:53.510]                               next
[10:29:53.510]                             invokeRestart(restart)
[10:29:53.510]                             muffled <- TRUE
[10:29:53.510]                             break
[10:29:53.510]                           }
[10:29:53.510]                         }
[10:29:53.510]                       }
[10:29:53.510]                       invisible(muffled)
[10:29:53.510]                     }
[10:29:53.510]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.510]                   }
[10:29:53.510]                 }
[10:29:53.510]                 else {
[10:29:53.510]                   if (TRUE) {
[10:29:53.510]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.510]                     {
[10:29:53.510]                       inherits <- base::inherits
[10:29:53.510]                       invokeRestart <- base::invokeRestart
[10:29:53.510]                       is.null <- base::is.null
[10:29:53.510]                       muffled <- FALSE
[10:29:53.510]                       if (inherits(cond, "message")) {
[10:29:53.510]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.510]                         if (muffled) 
[10:29:53.510]                           invokeRestart("muffleMessage")
[10:29:53.510]                       }
[10:29:53.510]                       else if (inherits(cond, "warning")) {
[10:29:53.510]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.510]                         if (muffled) 
[10:29:53.510]                           invokeRestart("muffleWarning")
[10:29:53.510]                       }
[10:29:53.510]                       else if (inherits(cond, "condition")) {
[10:29:53.510]                         if (!is.null(pattern)) {
[10:29:53.510]                           computeRestarts <- base::computeRestarts
[10:29:53.510]                           grepl <- base::grepl
[10:29:53.510]                           restarts <- computeRestarts(cond)
[10:29:53.510]                           for (restart in restarts) {
[10:29:53.510]                             name <- restart$name
[10:29:53.510]                             if (is.null(name)) 
[10:29:53.510]                               next
[10:29:53.510]                             if (!grepl(pattern, name)) 
[10:29:53.510]                               next
[10:29:53.510]                             invokeRestart(restart)
[10:29:53.510]                             muffled <- TRUE
[10:29:53.510]                             break
[10:29:53.510]                           }
[10:29:53.510]                         }
[10:29:53.510]                       }
[10:29:53.510]                       invisible(muffled)
[10:29:53.510]                     }
[10:29:53.510]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.510]                   }
[10:29:53.510]                 }
[10:29:53.510]             }
[10:29:53.510]         }))
[10:29:53.510]     }, error = function(ex) {
[10:29:53.510]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:53.510]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.510]                 ...future.rng), started = ...future.startTime, 
[10:29:53.510]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:53.510]             version = "1.8"), class = "FutureResult")
[10:29:53.510]     }, finally = {
[10:29:53.510]         if (!identical(...future.workdir, getwd())) 
[10:29:53.510]             setwd(...future.workdir)
[10:29:53.510]         {
[10:29:53.510]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:53.510]                 ...future.oldOptions$nwarnings <- NULL
[10:29:53.510]             }
[10:29:53.510]             base::options(...future.oldOptions)
[10:29:53.510]             if (.Platform$OS.type == "windows") {
[10:29:53.510]                 old_names <- names(...future.oldEnvVars)
[10:29:53.510]                 envs <- base::Sys.getenv()
[10:29:53.510]                 names <- names(envs)
[10:29:53.510]                 common <- intersect(names, old_names)
[10:29:53.510]                 added <- setdiff(names, old_names)
[10:29:53.510]                 removed <- setdiff(old_names, names)
[10:29:53.510]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:53.510]                   envs[common]]
[10:29:53.510]                 NAMES <- toupper(changed)
[10:29:53.510]                 args <- list()
[10:29:53.510]                 for (kk in seq_along(NAMES)) {
[10:29:53.510]                   name <- changed[[kk]]
[10:29:53.510]                   NAME <- NAMES[[kk]]
[10:29:53.510]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.510]                     next
[10:29:53.510]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.510]                 }
[10:29:53.510]                 NAMES <- toupper(added)
[10:29:53.510]                 for (kk in seq_along(NAMES)) {
[10:29:53.510]                   name <- added[[kk]]
[10:29:53.510]                   NAME <- NAMES[[kk]]
[10:29:53.510]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.510]                     next
[10:29:53.510]                   args[[name]] <- ""
[10:29:53.510]                 }
[10:29:53.510]                 NAMES <- toupper(removed)
[10:29:53.510]                 for (kk in seq_along(NAMES)) {
[10:29:53.510]                   name <- removed[[kk]]
[10:29:53.510]                   NAME <- NAMES[[kk]]
[10:29:53.510]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.510]                     next
[10:29:53.510]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.510]                 }
[10:29:53.510]                 if (length(args) > 0) 
[10:29:53.510]                   base::do.call(base::Sys.setenv, args = args)
[10:29:53.510]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:53.510]             }
[10:29:53.510]             else {
[10:29:53.510]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:53.510]             }
[10:29:53.510]             {
[10:29:53.510]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:53.510]                   0L) {
[10:29:53.510]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:53.510]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:53.510]                   base::options(opts)
[10:29:53.510]                 }
[10:29:53.510]                 {
[10:29:53.510]                   {
[10:29:53.510]                     NULL
[10:29:53.510]                     RNGkind("Mersenne-Twister")
[10:29:53.510]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:53.510]                       inherits = FALSE)
[10:29:53.510]                   }
[10:29:53.510]                   options(future.plan = NULL)
[10:29:53.510]                   if (is.na(NA_character_)) 
[10:29:53.510]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.510]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:53.510]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:53.510]                     .init = FALSE)
[10:29:53.510]                 }
[10:29:53.510]             }
[10:29:53.510]         }
[10:29:53.510]     })
[10:29:53.510]     if (TRUE) {
[10:29:53.510]         base::sink(type = "output", split = FALSE)
[10:29:53.510]         if (TRUE) {
[10:29:53.510]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:53.510]         }
[10:29:53.510]         else {
[10:29:53.510]             ...future.result["stdout"] <- base::list(NULL)
[10:29:53.510]         }
[10:29:53.510]         base::close(...future.stdout)
[10:29:53.510]         ...future.stdout <- NULL
[10:29:53.510]     }
[10:29:53.510]     ...future.result$conditions <- ...future.conditions
[10:29:53.510]     ...future.result$finished <- base::Sys.time()
[10:29:53.510]     ...future.result
[10:29:53.510] }
[10:29:53.512] assign_globals() ...
[10:29:53.512] List of 5
[10:29:53.512]  $ ...future.FUN            :function (object, ...)  
[10:29:53.512]  $ future.call.arguments    : list()
[10:29:53.512]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.512]  $ ...future.elements_ii    :List of 3
[10:29:53.512]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.512]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:29:53.512]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.512]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:53.512]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.512]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:29:53.512]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.512]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:29:53.512]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.512]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:29:53.512]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.512]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:29:53.512]  $ ...future.seeds_ii       : NULL
[10:29:53.512]  $ ...future.globals.maxSize: NULL
[10:29:53.512]  - attr(*, "where")=List of 5
[10:29:53.512]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:53.512]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:53.512]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:53.512]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:53.512]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:53.512]  - attr(*, "resolved")= logi FALSE
[10:29:53.512]  - attr(*, "total_size")= num 1240
[10:29:53.512]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.512]  - attr(*, "already-done")= logi TRUE
[10:29:53.522] - copied ‘...future.FUN’ to environment
[10:29:53.522] - copied ‘future.call.arguments’ to environment
[10:29:53.522] - copied ‘...future.elements_ii’ to environment
[10:29:53.522] - copied ‘...future.seeds_ii’ to environment
[10:29:53.522] - copied ‘...future.globals.maxSize’ to environment
[10:29:53.522] assign_globals() ... done
[10:29:53.523] plan(): Setting new future strategy stack:
[10:29:53.523] List of future strategies:
[10:29:53.523] 1. sequential:
[10:29:53.523]    - args: function (..., envir = parent.frame())
[10:29:53.523]    - tweaked: FALSE
[10:29:53.523]    - call: NULL
[10:29:53.523] plan(): nbrOfWorkers() = 1
[10:29:53.525] plan(): Setting new future strategy stack:
[10:29:53.526] List of future strategies:
[10:29:53.526] 1. multicore:
[10:29:53.526]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:53.526]    - tweaked: FALSE
[10:29:53.526]    - call: plan(strategy)
[10:29:53.529] plan(): nbrOfWorkers() = 1
[10:29:53.529] SequentialFuture started (and completed)
[10:29:53.529] - Launch lazy future ... done
[10:29:53.530] run() for ‘SequentialFuture’ ... done
[10:29:53.530] Created future:
[10:29:53.530] SequentialFuture:
[10:29:53.530] Label: ‘future_by-1’
[10:29:53.530] Expression:
[10:29:53.530] {
[10:29:53.530]     do.call(function(...) {
[10:29:53.530]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.530]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.530]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.530]             on.exit(options(oopts), add = TRUE)
[10:29:53.530]         }
[10:29:53.530]         {
[10:29:53.530]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.530]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.530]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.530]             })
[10:29:53.530]         }
[10:29:53.530]     }, args = future.call.arguments)
[10:29:53.530] }
[10:29:53.530] Lazy evaluation: FALSE
[10:29:53.530] Asynchronous evaluation: FALSE
[10:29:53.530] Local evaluation: TRUE
[10:29:53.530] Environment: 0x556dd51726d8
[10:29:53.530] Capture standard output: TRUE
[10:29:53.530] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:53.530] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:53.530] Packages: <none>
[10:29:53.530] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:53.530] Resolved: TRUE
[10:29:53.530] Value: 5.37 KiB of class ‘list’
[10:29:53.530] Early signaling: FALSE
[10:29:53.530] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:53.530] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.531] Chunk #1 of 1 ... DONE
[10:29:53.531] Launching 1 futures (chunks) ... DONE
[10:29:53.531] Resolving 1 futures (chunks) ...
[10:29:53.531] resolve() on list ...
[10:29:53.531]  recursive: 0
[10:29:53.532]  length: 1
[10:29:53.532] 
[10:29:53.532] resolved() for ‘SequentialFuture’ ...
[10:29:53.532] - state: ‘finished’
[10:29:53.532] - run: TRUE
[10:29:53.532] - result: ‘FutureResult’
[10:29:53.532] resolved() for ‘SequentialFuture’ ... done
[10:29:53.532] Future #1
[10:29:53.532] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:53.532] - nx: 1
[10:29:53.533] - relay: TRUE
[10:29:53.533] - stdout: TRUE
[10:29:53.533] - signal: TRUE
[10:29:53.533] - resignal: FALSE
[10:29:53.533] - force: TRUE
[10:29:53.533] - relayed: [n=1] FALSE
[10:29:53.533] - queued futures: [n=1] FALSE
[10:29:53.533]  - until=1
[10:29:53.533]  - relaying element #1
[10:29:53.533] - relayed: [n=1] TRUE
[10:29:53.534] - queued futures: [n=1] TRUE
[10:29:53.534] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:53.534]  length: 0 (resolved future 1)
[10:29:53.534] Relaying remaining futures
[10:29:53.534] signalConditionsASAP(NULL, pos=0) ...
[10:29:53.534] - nx: 1
[10:29:53.534] - relay: TRUE
[10:29:53.534] - stdout: TRUE
[10:29:53.534] - signal: TRUE
[10:29:53.534] - resignal: FALSE
[10:29:53.534] - force: TRUE
[10:29:53.534] - relayed: [n=1] TRUE
[10:29:53.535] - queued futures: [n=1] TRUE
 - flush all
[10:29:53.535] - relayed: [n=1] TRUE
[10:29:53.535] - queued futures: [n=1] TRUE
[10:29:53.535] signalConditionsASAP(NULL, pos=0) ... done
[10:29:53.535] resolve() on list ... DONE
[10:29:53.535]  - Number of value chunks collected: 1
[10:29:53.535] Resolving 1 futures (chunks) ... DONE
[10:29:53.535] Reducing values from 1 chunks ...
[10:29:53.535]  - Number of values collected after concatenation: 3
[10:29:53.535]  - Number of values expected: 3
[10:29:53.536] Reducing values from 1 chunks ... DONE
[10:29:53.536] future_lapply() ... DONE
[10:29:53.536] future_by_internal() ... DONE
[10:29:53.537] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[10:29:53.537] future_lapply() ...
[10:29:53.540] Number of chunks: 1
[10:29:53.541] getGlobalsAndPackagesXApply() ...
[10:29:53.541]  - future.globals: TRUE
[10:29:53.541] getGlobalsAndPackages() ...
[10:29:53.541] Searching for globals...
[10:29:53.542] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:53.542] Searching for globals ... DONE
[10:29:53.542] Resolving globals: FALSE
[10:29:53.543] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:53.544] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:53.544] - globals: [1] ‘FUN’
[10:29:53.545] 
[10:29:53.545] getGlobalsAndPackages() ... DONE
[10:29:53.545]  - globals found/used: [n=1] ‘FUN’
[10:29:53.545]  - needed namespaces: [n=0] 
[10:29:53.545] Finding globals ... DONE
[10:29:53.545]  - use_args: TRUE
[10:29:53.545]  - Getting '...' globals ...
[10:29:53.546] resolve() on list ...
[10:29:53.546]  recursive: 0
[10:29:53.546]  length: 1
[10:29:53.546]  elements: ‘...’
[10:29:53.546]  length: 0 (resolved future 1)
[10:29:53.546] resolve() on list ... DONE
[10:29:53.546]    - '...' content: [n=0] 
[10:29:53.546] List of 1
[10:29:53.546]  $ ...: list()
[10:29:53.546]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.546]  - attr(*, "where")=List of 1
[10:29:53.546]   ..$ ...:<environment: 0x556dd5273020> 
[10:29:53.546]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.546]  - attr(*, "resolved")= logi TRUE
[10:29:53.546]  - attr(*, "total_size")= num NA
[10:29:53.549]  - Getting '...' globals ... DONE
[10:29:53.549] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:53.549] List of 2
[10:29:53.549]  $ ...future.FUN:function (object, ...)  
[10:29:53.549]  $ ...          : list()
[10:29:53.549]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.549]  - attr(*, "where")=List of 2
[10:29:53.549]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:53.549]   ..$ ...          :<environment: 0x556dd5273020> 
[10:29:53.549]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.549]  - attr(*, "resolved")= logi FALSE
[10:29:53.549]  - attr(*, "total_size")= num 1240
[10:29:53.552] Packages to be attached in all futures: [n=0] 
[10:29:53.552] getGlobalsAndPackagesXApply() ... DONE
[10:29:53.552] Number of futures (= number of chunks): 1
[10:29:53.552] Launching 1 futures (chunks) ...
[10:29:53.552] Chunk #1 of 1 ...
[10:29:53.552]  - Finding globals in 'X' for chunk #1 ...
[10:29:53.552] getGlobalsAndPackages() ...
[10:29:53.552] Searching for globals...
[10:29:53.553] 
[10:29:53.553] Searching for globals ... DONE
[10:29:53.553] - globals: [0] <none>
[10:29:53.553] getGlobalsAndPackages() ... DONE
[10:29:53.553]    + additional globals found: [n=0] 
[10:29:53.553]    + additional namespaces needed: [n=0] 
[10:29:53.554]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:53.554]  - seeds: <none>
[10:29:53.554]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.554] getGlobalsAndPackages() ...
[10:29:53.554] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.554] Resolving globals: FALSE
[10:29:53.554] Tweak future expression to call with '...' arguments ...
[10:29:53.554] {
[10:29:53.554]     do.call(function(...) {
[10:29:53.554]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.554]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.554]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.554]             on.exit(options(oopts), add = TRUE)
[10:29:53.554]         }
[10:29:53.554]         {
[10:29:53.554]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.554]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.554]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.554]             })
[10:29:53.554]         }
[10:29:53.554]     }, args = future.call.arguments)
[10:29:53.554] }
[10:29:53.554] Tweak future expression to call with '...' arguments ... DONE
[10:29:53.555] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.555] 
[10:29:53.555] getGlobalsAndPackages() ... DONE
[10:29:53.555] run() for ‘Future’ ...
[10:29:53.555] - state: ‘created’
[10:29:53.556] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:53.559] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.559] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:53.559]   - Field: ‘label’
[10:29:53.559]   - Field: ‘local’
[10:29:53.559]   - Field: ‘owner’
[10:29:53.560]   - Field: ‘envir’
[10:29:53.560]   - Field: ‘packages’
[10:29:53.560]   - Field: ‘gc’
[10:29:53.560]   - Field: ‘conditions’
[10:29:53.560]   - Field: ‘expr’
[10:29:53.560]   - Field: ‘uuid’
[10:29:53.560]   - Field: ‘seed’
[10:29:53.560]   - Field: ‘version’
[10:29:53.560]   - Field: ‘result’
[10:29:53.560]   - Field: ‘asynchronous’
[10:29:53.560]   - Field: ‘calls’
[10:29:53.561]   - Field: ‘globals’
[10:29:53.561]   - Field: ‘stdout’
[10:29:53.561]   - Field: ‘earlySignal’
[10:29:53.561]   - Field: ‘lazy’
[10:29:53.561]   - Field: ‘state’
[10:29:53.561] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:53.561] - Launch lazy future ...
[10:29:53.561] Packages needed by the future expression (n = 0): <none>
[10:29:53.561] Packages needed by future strategies (n = 0): <none>
[10:29:53.562] {
[10:29:53.562]     {
[10:29:53.562]         {
[10:29:53.562]             ...future.startTime <- base::Sys.time()
[10:29:53.562]             {
[10:29:53.562]                 {
[10:29:53.562]                   {
[10:29:53.562]                     base::local({
[10:29:53.562]                       has_future <- base::requireNamespace("future", 
[10:29:53.562]                         quietly = TRUE)
[10:29:53.562]                       if (has_future) {
[10:29:53.562]                         ns <- base::getNamespace("future")
[10:29:53.562]                         version <- ns[[".package"]][["version"]]
[10:29:53.562]                         if (is.null(version)) 
[10:29:53.562]                           version <- utils::packageVersion("future")
[10:29:53.562]                       }
[10:29:53.562]                       else {
[10:29:53.562]                         version <- NULL
[10:29:53.562]                       }
[10:29:53.562]                       if (!has_future || version < "1.8.0") {
[10:29:53.562]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:53.562]                           "", base::R.version$version.string), 
[10:29:53.562]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:53.562]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:53.562]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:53.562]                             "release", "version")], collapse = " "), 
[10:29:53.562]                           hostname = base::Sys.info()[["nodename"]])
[10:29:53.562]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:53.562]                           info)
[10:29:53.562]                         info <- base::paste(info, collapse = "; ")
[10:29:53.562]                         if (!has_future) {
[10:29:53.562]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:53.562]                             info)
[10:29:53.562]                         }
[10:29:53.562]                         else {
[10:29:53.562]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:53.562]                             info, version)
[10:29:53.562]                         }
[10:29:53.562]                         base::stop(msg)
[10:29:53.562]                       }
[10:29:53.562]                     })
[10:29:53.562]                   }
[10:29:53.562]                   ...future.strategy.old <- future::plan("list")
[10:29:53.562]                   options(future.plan = NULL)
[10:29:53.562]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.562]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:53.562]                 }
[10:29:53.562]                 ...future.workdir <- getwd()
[10:29:53.562]             }
[10:29:53.562]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:53.562]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:53.562]         }
[10:29:53.562]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:53.562]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:53.562]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:53.562]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:53.562]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:53.562]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:53.562]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:53.562]             base::names(...future.oldOptions))
[10:29:53.562]     }
[10:29:53.562]     if (FALSE) {
[10:29:53.562]     }
[10:29:53.562]     else {
[10:29:53.562]         if (TRUE) {
[10:29:53.562]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:53.562]                 open = "w")
[10:29:53.562]         }
[10:29:53.562]         else {
[10:29:53.562]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:53.562]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:53.562]         }
[10:29:53.562]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:53.562]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:53.562]             base::sink(type = "output", split = FALSE)
[10:29:53.562]             base::close(...future.stdout)
[10:29:53.562]         }, add = TRUE)
[10:29:53.562]     }
[10:29:53.562]     ...future.frame <- base::sys.nframe()
[10:29:53.562]     ...future.conditions <- base::list()
[10:29:53.562]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:53.562]     if (FALSE) {
[10:29:53.562]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:53.562]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:53.562]     }
[10:29:53.562]     ...future.result <- base::tryCatch({
[10:29:53.562]         base::withCallingHandlers({
[10:29:53.562]             ...future.value <- base::withVisible(base::local({
[10:29:53.562]                 do.call(function(...) {
[10:29:53.562]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.562]                   if (!identical(...future.globals.maxSize.org, 
[10:29:53.562]                     ...future.globals.maxSize)) {
[10:29:53.562]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.562]                     on.exit(options(oopts), add = TRUE)
[10:29:53.562]                   }
[10:29:53.562]                   {
[10:29:53.562]                     lapply(seq_along(...future.elements_ii), 
[10:29:53.562]                       FUN = function(jj) {
[10:29:53.562]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.562]                         ...future.FUN(...future.X_jj, ...)
[10:29:53.562]                       })
[10:29:53.562]                   }
[10:29:53.562]                 }, args = future.call.arguments)
[10:29:53.562]             }))
[10:29:53.562]             future::FutureResult(value = ...future.value$value, 
[10:29:53.562]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.562]                   ...future.rng), globalenv = if (FALSE) 
[10:29:53.562]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:53.562]                     ...future.globalenv.names))
[10:29:53.562]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:53.562]         }, condition = base::local({
[10:29:53.562]             c <- base::c
[10:29:53.562]             inherits <- base::inherits
[10:29:53.562]             invokeRestart <- base::invokeRestart
[10:29:53.562]             length <- base::length
[10:29:53.562]             list <- base::list
[10:29:53.562]             seq.int <- base::seq.int
[10:29:53.562]             signalCondition <- base::signalCondition
[10:29:53.562]             sys.calls <- base::sys.calls
[10:29:53.562]             `[[` <- base::`[[`
[10:29:53.562]             `+` <- base::`+`
[10:29:53.562]             `<<-` <- base::`<<-`
[10:29:53.562]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:53.562]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:53.562]                   3L)]
[10:29:53.562]             }
[10:29:53.562]             function(cond) {
[10:29:53.562]                 is_error <- inherits(cond, "error")
[10:29:53.562]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:53.562]                   NULL)
[10:29:53.562]                 if (is_error) {
[10:29:53.562]                   sessionInformation <- function() {
[10:29:53.562]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:53.562]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:53.562]                       search = base::search(), system = base::Sys.info())
[10:29:53.562]                   }
[10:29:53.562]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.562]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:53.562]                     cond$call), session = sessionInformation(), 
[10:29:53.562]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:53.562]                   signalCondition(cond)
[10:29:53.562]                 }
[10:29:53.562]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:53.562]                 "immediateCondition"))) {
[10:29:53.562]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:53.562]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.562]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:53.562]                   if (TRUE && !signal) {
[10:29:53.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.562]                     {
[10:29:53.562]                       inherits <- base::inherits
[10:29:53.562]                       invokeRestart <- base::invokeRestart
[10:29:53.562]                       is.null <- base::is.null
[10:29:53.562]                       muffled <- FALSE
[10:29:53.562]                       if (inherits(cond, "message")) {
[10:29:53.562]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.562]                         if (muffled) 
[10:29:53.562]                           invokeRestart("muffleMessage")
[10:29:53.562]                       }
[10:29:53.562]                       else if (inherits(cond, "warning")) {
[10:29:53.562]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.562]                         if (muffled) 
[10:29:53.562]                           invokeRestart("muffleWarning")
[10:29:53.562]                       }
[10:29:53.562]                       else if (inherits(cond, "condition")) {
[10:29:53.562]                         if (!is.null(pattern)) {
[10:29:53.562]                           computeRestarts <- base::computeRestarts
[10:29:53.562]                           grepl <- base::grepl
[10:29:53.562]                           restarts <- computeRestarts(cond)
[10:29:53.562]                           for (restart in restarts) {
[10:29:53.562]                             name <- restart$name
[10:29:53.562]                             if (is.null(name)) 
[10:29:53.562]                               next
[10:29:53.562]                             if (!grepl(pattern, name)) 
[10:29:53.562]                               next
[10:29:53.562]                             invokeRestart(restart)
[10:29:53.562]                             muffled <- TRUE
[10:29:53.562]                             break
[10:29:53.562]                           }
[10:29:53.562]                         }
[10:29:53.562]                       }
[10:29:53.562]                       invisible(muffled)
[10:29:53.562]                     }
[10:29:53.562]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.562]                   }
[10:29:53.562]                 }
[10:29:53.562]                 else {
[10:29:53.562]                   if (TRUE) {
[10:29:53.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.562]                     {
[10:29:53.562]                       inherits <- base::inherits
[10:29:53.562]                       invokeRestart <- base::invokeRestart
[10:29:53.562]                       is.null <- base::is.null
[10:29:53.562]                       muffled <- FALSE
[10:29:53.562]                       if (inherits(cond, "message")) {
[10:29:53.562]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.562]                         if (muffled) 
[10:29:53.562]                           invokeRestart("muffleMessage")
[10:29:53.562]                       }
[10:29:53.562]                       else if (inherits(cond, "warning")) {
[10:29:53.562]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.562]                         if (muffled) 
[10:29:53.562]                           invokeRestart("muffleWarning")
[10:29:53.562]                       }
[10:29:53.562]                       else if (inherits(cond, "condition")) {
[10:29:53.562]                         if (!is.null(pattern)) {
[10:29:53.562]                           computeRestarts <- base::computeRestarts
[10:29:53.562]                           grepl <- base::grepl
[10:29:53.562]                           restarts <- computeRestarts(cond)
[10:29:53.562]                           for (restart in restarts) {
[10:29:53.562]                             name <- restart$name
[10:29:53.562]                             if (is.null(name)) 
[10:29:53.562]                               next
[10:29:53.562]                             if (!grepl(pattern, name)) 
[10:29:53.562]                               next
[10:29:53.562]                             invokeRestart(restart)
[10:29:53.562]                             muffled <- TRUE
[10:29:53.562]                             break
[10:29:53.562]                           }
[10:29:53.562]                         }
[10:29:53.562]                       }
[10:29:53.562]                       invisible(muffled)
[10:29:53.562]                     }
[10:29:53.562]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.562]                   }
[10:29:53.562]                 }
[10:29:53.562]             }
[10:29:53.562]         }))
[10:29:53.562]     }, error = function(ex) {
[10:29:53.562]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:53.562]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.562]                 ...future.rng), started = ...future.startTime, 
[10:29:53.562]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:53.562]             version = "1.8"), class = "FutureResult")
[10:29:53.562]     }, finally = {
[10:29:53.562]         if (!identical(...future.workdir, getwd())) 
[10:29:53.562]             setwd(...future.workdir)
[10:29:53.562]         {
[10:29:53.562]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:53.562]                 ...future.oldOptions$nwarnings <- NULL
[10:29:53.562]             }
[10:29:53.562]             base::options(...future.oldOptions)
[10:29:53.562]             if (.Platform$OS.type == "windows") {
[10:29:53.562]                 old_names <- names(...future.oldEnvVars)
[10:29:53.562]                 envs <- base::Sys.getenv()
[10:29:53.562]                 names <- names(envs)
[10:29:53.562]                 common <- intersect(names, old_names)
[10:29:53.562]                 added <- setdiff(names, old_names)
[10:29:53.562]                 removed <- setdiff(old_names, names)
[10:29:53.562]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:53.562]                   envs[common]]
[10:29:53.562]                 NAMES <- toupper(changed)
[10:29:53.562]                 args <- list()
[10:29:53.562]                 for (kk in seq_along(NAMES)) {
[10:29:53.562]                   name <- changed[[kk]]
[10:29:53.562]                   NAME <- NAMES[[kk]]
[10:29:53.562]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.562]                     next
[10:29:53.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.562]                 }
[10:29:53.562]                 NAMES <- toupper(added)
[10:29:53.562]                 for (kk in seq_along(NAMES)) {
[10:29:53.562]                   name <- added[[kk]]
[10:29:53.562]                   NAME <- NAMES[[kk]]
[10:29:53.562]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.562]                     next
[10:29:53.562]                   args[[name]] <- ""
[10:29:53.562]                 }
[10:29:53.562]                 NAMES <- toupper(removed)
[10:29:53.562]                 for (kk in seq_along(NAMES)) {
[10:29:53.562]                   name <- removed[[kk]]
[10:29:53.562]                   NAME <- NAMES[[kk]]
[10:29:53.562]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.562]                     next
[10:29:53.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.562]                 }
[10:29:53.562]                 if (length(args) > 0) 
[10:29:53.562]                   base::do.call(base::Sys.setenv, args = args)
[10:29:53.562]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:53.562]             }
[10:29:53.562]             else {
[10:29:53.562]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:53.562]             }
[10:29:53.562]             {
[10:29:53.562]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:53.562]                   0L) {
[10:29:53.562]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:53.562]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:53.562]                   base::options(opts)
[10:29:53.562]                 }
[10:29:53.562]                 {
[10:29:53.562]                   {
[10:29:53.562]                     NULL
[10:29:53.562]                     RNGkind("Mersenne-Twister")
[10:29:53.562]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:53.562]                       inherits = FALSE)
[10:29:53.562]                   }
[10:29:53.562]                   options(future.plan = NULL)
[10:29:53.562]                   if (is.na(NA_character_)) 
[10:29:53.562]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.562]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:53.562]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:53.562]                     .init = FALSE)
[10:29:53.562]                 }
[10:29:53.562]             }
[10:29:53.562]         }
[10:29:53.562]     })
[10:29:53.562]     if (TRUE) {
[10:29:53.562]         base::sink(type = "output", split = FALSE)
[10:29:53.562]         if (TRUE) {
[10:29:53.562]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:53.562]         }
[10:29:53.562]         else {
[10:29:53.562]             ...future.result["stdout"] <- base::list(NULL)
[10:29:53.562]         }
[10:29:53.562]         base::close(...future.stdout)
[10:29:53.562]         ...future.stdout <- NULL
[10:29:53.562]     }
[10:29:53.562]     ...future.result$conditions <- ...future.conditions
[10:29:53.562]     ...future.result$finished <- base::Sys.time()
[10:29:53.562]     ...future.result
[10:29:53.562] }
[10:29:53.564] assign_globals() ...
[10:29:53.564] List of 5
[10:29:53.564]  $ ...future.FUN            :function (object, ...)  
[10:29:53.564]  $ future.call.arguments    : list()
[10:29:53.564]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.564]  $ ...future.elements_ii    :List of 3
[10:29:53.564]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.564]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:29:53.564]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.564]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:53.564]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.564]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:29:53.564]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.564]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:29:53.564]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.564]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:29:53.564]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.564]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:29:53.564]  $ ...future.seeds_ii       : NULL
[10:29:53.564]  $ ...future.globals.maxSize: NULL
[10:29:53.564]  - attr(*, "where")=List of 5
[10:29:53.564]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:53.564]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:53.564]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:53.564]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:53.564]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:53.564]  - attr(*, "resolved")= logi FALSE
[10:29:53.564]  - attr(*, "total_size")= num 1240
[10:29:53.564]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.564]  - attr(*, "already-done")= logi TRUE
[10:29:53.574] - copied ‘...future.FUN’ to environment
[10:29:53.574] - copied ‘future.call.arguments’ to environment
[10:29:53.574] - copied ‘...future.elements_ii’ to environment
[10:29:53.574] - copied ‘...future.seeds_ii’ to environment
[10:29:53.574] - copied ‘...future.globals.maxSize’ to environment
[10:29:53.574] assign_globals() ... done
[10:29:53.575] plan(): Setting new future strategy stack:
[10:29:53.575] List of future strategies:
[10:29:53.575] 1. sequential:
[10:29:53.575]    - args: function (..., envir = parent.frame())
[10:29:53.575]    - tweaked: FALSE
[10:29:53.575]    - call: NULL
[10:29:53.575] plan(): nbrOfWorkers() = 1
[10:29:53.577] plan(): Setting new future strategy stack:
[10:29:53.577] List of future strategies:
[10:29:53.577] 1. multicore:
[10:29:53.577]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:53.577]    - tweaked: FALSE
[10:29:53.577]    - call: plan(strategy)
[10:29:53.581] plan(): nbrOfWorkers() = 1
[10:29:53.581] SequentialFuture started (and completed)
[10:29:53.581] - Launch lazy future ... done
[10:29:53.581] run() for ‘SequentialFuture’ ... done
[10:29:53.581] Created future:
[10:29:53.581] SequentialFuture:
[10:29:53.581] Label: ‘future_by-1’
[10:29:53.581] Expression:
[10:29:53.581] {
[10:29:53.581]     do.call(function(...) {
[10:29:53.581]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.581]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.581]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.581]             on.exit(options(oopts), add = TRUE)
[10:29:53.581]         }
[10:29:53.581]         {
[10:29:53.581]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.581]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.581]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.581]             })
[10:29:53.581]         }
[10:29:53.581]     }, args = future.call.arguments)
[10:29:53.581] }
[10:29:53.581] Lazy evaluation: FALSE
[10:29:53.581] Asynchronous evaluation: FALSE
[10:29:53.581] Local evaluation: TRUE
[10:29:53.581] Environment: 0x556dd52175d0
[10:29:53.581] Capture standard output: TRUE
[10:29:53.581] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:53.581] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:53.581] Packages: <none>
[10:29:53.581] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:53.581] Resolved: TRUE
[10:29:53.581] Value: 5.37 KiB of class ‘list’
[10:29:53.581] Early signaling: FALSE
[10:29:53.581] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:53.581] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.583] Chunk #1 of 1 ... DONE
[10:29:53.583] Launching 1 futures (chunks) ... DONE
[10:29:53.583] Resolving 1 futures (chunks) ...
[10:29:53.583] resolve() on list ...
[10:29:53.583]  recursive: 0
[10:29:53.583]  length: 1
[10:29:53.583] 
[10:29:53.583] resolved() for ‘SequentialFuture’ ...
[10:29:53.583] - state: ‘finished’
[10:29:53.583] - run: TRUE
[10:29:53.583] - result: ‘FutureResult’
[10:29:53.584] resolved() for ‘SequentialFuture’ ... done
[10:29:53.584] Future #1
[10:29:53.584] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:53.584] - nx: 1
[10:29:53.584] - relay: TRUE
[10:29:53.584] - stdout: TRUE
[10:29:53.584] - signal: TRUE
[10:29:53.584] - resignal: FALSE
[10:29:53.584] - force: TRUE
[10:29:53.584] - relayed: [n=1] FALSE
[10:29:53.584] - queued futures: [n=1] FALSE
[10:29:53.585]  - until=1
[10:29:53.585]  - relaying element #1
[10:29:53.585] - relayed: [n=1] TRUE
[10:29:53.585] - queued futures: [n=1] TRUE
[10:29:53.585] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:53.585]  length: 0 (resolved future 1)
[10:29:53.585] Relaying remaining futures
[10:29:53.585] signalConditionsASAP(NULL, pos=0) ...
[10:29:53.585] - nx: 1
[10:29:53.585] - relay: TRUE
[10:29:53.586] - stdout: TRUE
[10:29:53.586] - signal: TRUE
[10:29:53.586] - resignal: FALSE
[10:29:53.586] - force: TRUE
[10:29:53.586] - relayed: [n=1] TRUE
[10:29:53.586] - queued futures: [n=1] TRUE
 - flush all
[10:29:53.586] - relayed: [n=1] TRUE
[10:29:53.586] - queued futures: [n=1] TRUE
[10:29:53.586] signalConditionsASAP(NULL, pos=0) ... done
[10:29:53.586] resolve() on list ... DONE
[10:29:53.587]  - Number of value chunks collected: 1
[10:29:53.587] Resolving 1 futures (chunks) ... DONE
[10:29:53.587] Reducing values from 1 chunks ...
[10:29:53.587]  - Number of values collected after concatenation: 3
[10:29:53.587]  - Number of values expected: 3
[10:29:53.587] Reducing values from 1 chunks ... DONE
[10:29:53.587] future_lapply() ... DONE
[10:29:53.587] future_by_internal() ... DONE
[10:29:53.588] future_by_internal() ...
- plan('multisession') ...
[10:29:53.588] plan(): Setting new future strategy stack:
[10:29:53.589] List of future strategies:
[10:29:53.589] 1. multisession:
[10:29:53.589]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:29:53.589]    - tweaked: FALSE
[10:29:53.589]    - call: plan(strategy)
[10:29:53.589] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:29:53.589] multisession:
[10:29:53.589] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:29:53.589] - tweaked: FALSE
[10:29:53.589] - call: plan(strategy)
[10:29:53.594] getGlobalsAndPackages() ...
[10:29:53.594] Not searching for globals
[10:29:53.594] - globals: [0] <none>
[10:29:53.594] getGlobalsAndPackages() ... DONE
[10:29:53.595] Packages needed by the future expression (n = 0): <none>
[10:29:53.595] Packages needed by future strategies (n = 0): <none>
[10:29:53.595] {
[10:29:53.595]     {
[10:29:53.595]         {
[10:29:53.595]             ...future.startTime <- base::Sys.time()
[10:29:53.595]             {
[10:29:53.595]                 {
[10:29:53.595]                   {
[10:29:53.595]                     base::local({
[10:29:53.595]                       has_future <- base::requireNamespace("future", 
[10:29:53.595]                         quietly = TRUE)
[10:29:53.595]                       if (has_future) {
[10:29:53.595]                         ns <- base::getNamespace("future")
[10:29:53.595]                         version <- ns[[".package"]][["version"]]
[10:29:53.595]                         if (is.null(version)) 
[10:29:53.595]                           version <- utils::packageVersion("future")
[10:29:53.595]                       }
[10:29:53.595]                       else {
[10:29:53.595]                         version <- NULL
[10:29:53.595]                       }
[10:29:53.595]                       if (!has_future || version < "1.8.0") {
[10:29:53.595]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:53.595]                           "", base::R.version$version.string), 
[10:29:53.595]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:53.595]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:53.595]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:53.595]                             "release", "version")], collapse = " "), 
[10:29:53.595]                           hostname = base::Sys.info()[["nodename"]])
[10:29:53.595]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:53.595]                           info)
[10:29:53.595]                         info <- base::paste(info, collapse = "; ")
[10:29:53.595]                         if (!has_future) {
[10:29:53.595]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:53.595]                             info)
[10:29:53.595]                         }
[10:29:53.595]                         else {
[10:29:53.595]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:53.595]                             info, version)
[10:29:53.595]                         }
[10:29:53.595]                         base::stop(msg)
[10:29:53.595]                       }
[10:29:53.595]                     })
[10:29:53.595]                   }
[10:29:53.595]                   ...future.strategy.old <- future::plan("list")
[10:29:53.595]                   options(future.plan = NULL)
[10:29:53.595]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.595]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:53.595]                 }
[10:29:53.595]                 ...future.workdir <- getwd()
[10:29:53.595]             }
[10:29:53.595]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:53.595]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:53.595]         }
[10:29:53.595]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:53.595]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:53.595]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:53.595]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:53.595]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:53.595]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:53.595]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:53.595]             base::names(...future.oldOptions))
[10:29:53.595]     }
[10:29:53.595]     if (FALSE) {
[10:29:53.595]     }
[10:29:53.595]     else {
[10:29:53.595]         if (TRUE) {
[10:29:53.595]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:53.595]                 open = "w")
[10:29:53.595]         }
[10:29:53.595]         else {
[10:29:53.595]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:53.595]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:53.595]         }
[10:29:53.595]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:53.595]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:53.595]             base::sink(type = "output", split = FALSE)
[10:29:53.595]             base::close(...future.stdout)
[10:29:53.595]         }, add = TRUE)
[10:29:53.595]     }
[10:29:53.595]     ...future.frame <- base::sys.nframe()
[10:29:53.595]     ...future.conditions <- base::list()
[10:29:53.595]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:53.595]     if (FALSE) {
[10:29:53.595]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:53.595]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:53.595]     }
[10:29:53.595]     ...future.result <- base::tryCatch({
[10:29:53.595]         base::withCallingHandlers({
[10:29:53.595]             ...future.value <- base::withVisible(base::local(NA))
[10:29:53.595]             future::FutureResult(value = ...future.value$value, 
[10:29:53.595]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.595]                   ...future.rng), globalenv = if (FALSE) 
[10:29:53.595]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:53.595]                     ...future.globalenv.names))
[10:29:53.595]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:53.595]         }, condition = base::local({
[10:29:53.595]             c <- base::c
[10:29:53.595]             inherits <- base::inherits
[10:29:53.595]             invokeRestart <- base::invokeRestart
[10:29:53.595]             length <- base::length
[10:29:53.595]             list <- base::list
[10:29:53.595]             seq.int <- base::seq.int
[10:29:53.595]             signalCondition <- base::signalCondition
[10:29:53.595]             sys.calls <- base::sys.calls
[10:29:53.595]             `[[` <- base::`[[`
[10:29:53.595]             `+` <- base::`+`
[10:29:53.595]             `<<-` <- base::`<<-`
[10:29:53.595]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:53.595]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:53.595]                   3L)]
[10:29:53.595]             }
[10:29:53.595]             function(cond) {
[10:29:53.595]                 is_error <- inherits(cond, "error")
[10:29:53.595]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:53.595]                   NULL)
[10:29:53.595]                 if (is_error) {
[10:29:53.595]                   sessionInformation <- function() {
[10:29:53.595]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:53.595]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:53.595]                       search = base::search(), system = base::Sys.info())
[10:29:53.595]                   }
[10:29:53.595]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.595]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:53.595]                     cond$call), session = sessionInformation(), 
[10:29:53.595]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:53.595]                   signalCondition(cond)
[10:29:53.595]                 }
[10:29:53.595]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:53.595]                 "immediateCondition"))) {
[10:29:53.595]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:53.595]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.595]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:53.595]                   if (TRUE && !signal) {
[10:29:53.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.595]                     {
[10:29:53.595]                       inherits <- base::inherits
[10:29:53.595]                       invokeRestart <- base::invokeRestart
[10:29:53.595]                       is.null <- base::is.null
[10:29:53.595]                       muffled <- FALSE
[10:29:53.595]                       if (inherits(cond, "message")) {
[10:29:53.595]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.595]                         if (muffled) 
[10:29:53.595]                           invokeRestart("muffleMessage")
[10:29:53.595]                       }
[10:29:53.595]                       else if (inherits(cond, "warning")) {
[10:29:53.595]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.595]                         if (muffled) 
[10:29:53.595]                           invokeRestart("muffleWarning")
[10:29:53.595]                       }
[10:29:53.595]                       else if (inherits(cond, "condition")) {
[10:29:53.595]                         if (!is.null(pattern)) {
[10:29:53.595]                           computeRestarts <- base::computeRestarts
[10:29:53.595]                           grepl <- base::grepl
[10:29:53.595]                           restarts <- computeRestarts(cond)
[10:29:53.595]                           for (restart in restarts) {
[10:29:53.595]                             name <- restart$name
[10:29:53.595]                             if (is.null(name)) 
[10:29:53.595]                               next
[10:29:53.595]                             if (!grepl(pattern, name)) 
[10:29:53.595]                               next
[10:29:53.595]                             invokeRestart(restart)
[10:29:53.595]                             muffled <- TRUE
[10:29:53.595]                             break
[10:29:53.595]                           }
[10:29:53.595]                         }
[10:29:53.595]                       }
[10:29:53.595]                       invisible(muffled)
[10:29:53.595]                     }
[10:29:53.595]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.595]                   }
[10:29:53.595]                 }
[10:29:53.595]                 else {
[10:29:53.595]                   if (TRUE) {
[10:29:53.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.595]                     {
[10:29:53.595]                       inherits <- base::inherits
[10:29:53.595]                       invokeRestart <- base::invokeRestart
[10:29:53.595]                       is.null <- base::is.null
[10:29:53.595]                       muffled <- FALSE
[10:29:53.595]                       if (inherits(cond, "message")) {
[10:29:53.595]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.595]                         if (muffled) 
[10:29:53.595]                           invokeRestart("muffleMessage")
[10:29:53.595]                       }
[10:29:53.595]                       else if (inherits(cond, "warning")) {
[10:29:53.595]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.595]                         if (muffled) 
[10:29:53.595]                           invokeRestart("muffleWarning")
[10:29:53.595]                       }
[10:29:53.595]                       else if (inherits(cond, "condition")) {
[10:29:53.595]                         if (!is.null(pattern)) {
[10:29:53.595]                           computeRestarts <- base::computeRestarts
[10:29:53.595]                           grepl <- base::grepl
[10:29:53.595]                           restarts <- computeRestarts(cond)
[10:29:53.595]                           for (restart in restarts) {
[10:29:53.595]                             name <- restart$name
[10:29:53.595]                             if (is.null(name)) 
[10:29:53.595]                               next
[10:29:53.595]                             if (!grepl(pattern, name)) 
[10:29:53.595]                               next
[10:29:53.595]                             invokeRestart(restart)
[10:29:53.595]                             muffled <- TRUE
[10:29:53.595]                             break
[10:29:53.595]                           }
[10:29:53.595]                         }
[10:29:53.595]                       }
[10:29:53.595]                       invisible(muffled)
[10:29:53.595]                     }
[10:29:53.595]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.595]                   }
[10:29:53.595]                 }
[10:29:53.595]             }
[10:29:53.595]         }))
[10:29:53.595]     }, error = function(ex) {
[10:29:53.595]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:53.595]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.595]                 ...future.rng), started = ...future.startTime, 
[10:29:53.595]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:53.595]             version = "1.8"), class = "FutureResult")
[10:29:53.595]     }, finally = {
[10:29:53.595]         if (!identical(...future.workdir, getwd())) 
[10:29:53.595]             setwd(...future.workdir)
[10:29:53.595]         {
[10:29:53.595]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:53.595]                 ...future.oldOptions$nwarnings <- NULL
[10:29:53.595]             }
[10:29:53.595]             base::options(...future.oldOptions)
[10:29:53.595]             if (.Platform$OS.type == "windows") {
[10:29:53.595]                 old_names <- names(...future.oldEnvVars)
[10:29:53.595]                 envs <- base::Sys.getenv()
[10:29:53.595]                 names <- names(envs)
[10:29:53.595]                 common <- intersect(names, old_names)
[10:29:53.595]                 added <- setdiff(names, old_names)
[10:29:53.595]                 removed <- setdiff(old_names, names)
[10:29:53.595]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:53.595]                   envs[common]]
[10:29:53.595]                 NAMES <- toupper(changed)
[10:29:53.595]                 args <- list()
[10:29:53.595]                 for (kk in seq_along(NAMES)) {
[10:29:53.595]                   name <- changed[[kk]]
[10:29:53.595]                   NAME <- NAMES[[kk]]
[10:29:53.595]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.595]                     next
[10:29:53.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.595]                 }
[10:29:53.595]                 NAMES <- toupper(added)
[10:29:53.595]                 for (kk in seq_along(NAMES)) {
[10:29:53.595]                   name <- added[[kk]]
[10:29:53.595]                   NAME <- NAMES[[kk]]
[10:29:53.595]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.595]                     next
[10:29:53.595]                   args[[name]] <- ""
[10:29:53.595]                 }
[10:29:53.595]                 NAMES <- toupper(removed)
[10:29:53.595]                 for (kk in seq_along(NAMES)) {
[10:29:53.595]                   name <- removed[[kk]]
[10:29:53.595]                   NAME <- NAMES[[kk]]
[10:29:53.595]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.595]                     next
[10:29:53.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.595]                 }
[10:29:53.595]                 if (length(args) > 0) 
[10:29:53.595]                   base::do.call(base::Sys.setenv, args = args)
[10:29:53.595]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:53.595]             }
[10:29:53.595]             else {
[10:29:53.595]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:53.595]             }
[10:29:53.595]             {
[10:29:53.595]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:53.595]                   0L) {
[10:29:53.595]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:53.595]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:53.595]                   base::options(opts)
[10:29:53.595]                 }
[10:29:53.595]                 {
[10:29:53.595]                   {
[10:29:53.595]                     NULL
[10:29:53.595]                     RNGkind("Mersenne-Twister")
[10:29:53.595]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:53.595]                       inherits = FALSE)
[10:29:53.595]                   }
[10:29:53.595]                   options(future.plan = NULL)
[10:29:53.595]                   if (is.na(NA_character_)) 
[10:29:53.595]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.595]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:53.595]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:53.595]                     .init = FALSE)
[10:29:53.595]                 }
[10:29:53.595]             }
[10:29:53.595]         }
[10:29:53.595]     })
[10:29:53.595]     if (TRUE) {
[10:29:53.595]         base::sink(type = "output", split = FALSE)
[10:29:53.595]         if (TRUE) {
[10:29:53.595]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:53.595]         }
[10:29:53.595]         else {
[10:29:53.595]             ...future.result["stdout"] <- base::list(NULL)
[10:29:53.595]         }
[10:29:53.595]         base::close(...future.stdout)
[10:29:53.595]         ...future.stdout <- NULL
[10:29:53.595]     }
[10:29:53.595]     ...future.result$conditions <- ...future.conditions
[10:29:53.595]     ...future.result$finished <- base::Sys.time()
[10:29:53.595]     ...future.result
[10:29:53.595] }
[10:29:53.597] plan(): Setting new future strategy stack:
[10:29:53.597] List of future strategies:
[10:29:53.597] 1. sequential:
[10:29:53.597]    - args: function (..., envir = parent.frame())
[10:29:53.597]    - tweaked: FALSE
[10:29:53.597]    - call: NULL
[10:29:53.597] plan(): nbrOfWorkers() = 1
[10:29:53.598] plan(): Setting new future strategy stack:
[10:29:53.598] List of future strategies:
[10:29:53.598] 1. multisession:
[10:29:53.598]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:29:53.598]    - tweaked: FALSE
[10:29:53.598]    - call: plan(strategy)
[10:29:53.602] plan(): nbrOfWorkers() = 1
[10:29:53.602] SequentialFuture started (and completed)
[10:29:53.602] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:29:53.605] plan(): nbrOfWorkers() = 1
[10:29:53.605] future_by_internal() ...
[10:29:53.606] future_lapply() ...
[10:29:53.609] Number of chunks: 1
[10:29:53.609] getGlobalsAndPackagesXApply() ...
[10:29:53.609]  - future.globals: TRUE
[10:29:53.609] getGlobalsAndPackages() ...
[10:29:53.610] Searching for globals...
[10:29:53.611] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:53.611] Searching for globals ... DONE
[10:29:53.611] Resolving globals: FALSE
[10:29:53.611] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:53.612] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:53.612] - globals: [1] ‘FUN’
[10:29:53.612] 
[10:29:53.612] getGlobalsAndPackages() ... DONE
[10:29:53.612]  - globals found/used: [n=1] ‘FUN’
[10:29:53.612]  - needed namespaces: [n=0] 
[10:29:53.612] Finding globals ... DONE
[10:29:53.612]  - use_args: TRUE
[10:29:53.612]  - Getting '...' globals ...
[10:29:53.613] resolve() on list ...
[10:29:53.613]  recursive: 0
[10:29:53.613]  length: 1
[10:29:53.613]  elements: ‘...’
[10:29:53.613]  length: 0 (resolved future 1)
[10:29:53.613] resolve() on list ... DONE
[10:29:53.613]    - '...' content: [n=0] 
[10:29:53.613] List of 1
[10:29:53.613]  $ ...: list()
[10:29:53.613]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.613]  - attr(*, "where")=List of 1
[10:29:53.613]   ..$ ...:<environment: 0x556dd368c058> 
[10:29:53.613]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.613]  - attr(*, "resolved")= logi TRUE
[10:29:53.613]  - attr(*, "total_size")= num NA
[10:29:53.616]  - Getting '...' globals ... DONE
[10:29:53.616] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:53.616] List of 2
[10:29:53.616]  $ ...future.FUN:function (object, ...)  
[10:29:53.616]  $ ...          : list()
[10:29:53.616]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.616]  - attr(*, "where")=List of 2
[10:29:53.616]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:53.616]   ..$ ...          :<environment: 0x556dd368c058> 
[10:29:53.616]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.616]  - attr(*, "resolved")= logi FALSE
[10:29:53.616]  - attr(*, "total_size")= num 1240
[10:29:53.619] Packages to be attached in all futures: [n=0] 
[10:29:53.619] getGlobalsAndPackagesXApply() ... DONE
[10:29:53.619] Number of futures (= number of chunks): 1
[10:29:53.619] Launching 1 futures (chunks) ...
[10:29:53.619] Chunk #1 of 1 ...
[10:29:53.619]  - Finding globals in 'X' for chunk #1 ...
[10:29:53.619] getGlobalsAndPackages() ...
[10:29:53.619] Searching for globals...
[10:29:53.620] 
[10:29:53.620] Searching for globals ... DONE
[10:29:53.620] - globals: [0] <none>
[10:29:53.620] getGlobalsAndPackages() ... DONE
[10:29:53.620]    + additional globals found: [n=0] 
[10:29:53.620]    + additional namespaces needed: [n=0] 
[10:29:53.621]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:53.621]  - seeds: <none>
[10:29:53.621]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.621] getGlobalsAndPackages() ...
[10:29:53.621] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.621] Resolving globals: FALSE
[10:29:53.623] Tweak future expression to call with '...' arguments ...
[10:29:53.623] {
[10:29:53.623]     do.call(function(...) {
[10:29:53.623]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.623]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.623]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.623]             on.exit(options(oopts), add = TRUE)
[10:29:53.623]         }
[10:29:53.623]         {
[10:29:53.623]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.623]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.623]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.623]             })
[10:29:53.623]         }
[10:29:53.623]     }, args = future.call.arguments)
[10:29:53.623] }
[10:29:53.623] Tweak future expression to call with '...' arguments ... DONE
[10:29:53.623] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.624] 
[10:29:53.624] getGlobalsAndPackages() ... DONE
[10:29:53.624] run() for ‘Future’ ...
[10:29:53.624] - state: ‘created’
[10:29:53.624] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:53.628] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.628] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:53.628]   - Field: ‘label’
[10:29:53.628]   - Field: ‘local’
[10:29:53.628]   - Field: ‘owner’
[10:29:53.628]   - Field: ‘envir’
[10:29:53.628]   - Field: ‘packages’
[10:29:53.629]   - Field: ‘gc’
[10:29:53.629]   - Field: ‘conditions’
[10:29:53.629]   - Field: ‘expr’
[10:29:53.629]   - Field: ‘uuid’
[10:29:53.629]   - Field: ‘seed’
[10:29:53.629]   - Field: ‘version’
[10:29:53.629]   - Field: ‘result’
[10:29:53.629]   - Field: ‘asynchronous’
[10:29:53.629]   - Field: ‘calls’
[10:29:53.629]   - Field: ‘globals’
[10:29:53.630]   - Field: ‘stdout’
[10:29:53.630]   - Field: ‘earlySignal’
[10:29:53.630]   - Field: ‘lazy’
[10:29:53.630]   - Field: ‘state’
[10:29:53.630] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:53.630] - Launch lazy future ...
[10:29:53.630] Packages needed by the future expression (n = 0): <none>
[10:29:53.630] Packages needed by future strategies (n = 0): <none>
[10:29:53.631] {
[10:29:53.631]     {
[10:29:53.631]         {
[10:29:53.631]             ...future.startTime <- base::Sys.time()
[10:29:53.631]             {
[10:29:53.631]                 {
[10:29:53.631]                   {
[10:29:53.631]                     base::local({
[10:29:53.631]                       has_future <- base::requireNamespace("future", 
[10:29:53.631]                         quietly = TRUE)
[10:29:53.631]                       if (has_future) {
[10:29:53.631]                         ns <- base::getNamespace("future")
[10:29:53.631]                         version <- ns[[".package"]][["version"]]
[10:29:53.631]                         if (is.null(version)) 
[10:29:53.631]                           version <- utils::packageVersion("future")
[10:29:53.631]                       }
[10:29:53.631]                       else {
[10:29:53.631]                         version <- NULL
[10:29:53.631]                       }
[10:29:53.631]                       if (!has_future || version < "1.8.0") {
[10:29:53.631]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:53.631]                           "", base::R.version$version.string), 
[10:29:53.631]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:53.631]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:53.631]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:53.631]                             "release", "version")], collapse = " "), 
[10:29:53.631]                           hostname = base::Sys.info()[["nodename"]])
[10:29:53.631]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:53.631]                           info)
[10:29:53.631]                         info <- base::paste(info, collapse = "; ")
[10:29:53.631]                         if (!has_future) {
[10:29:53.631]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:53.631]                             info)
[10:29:53.631]                         }
[10:29:53.631]                         else {
[10:29:53.631]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:53.631]                             info, version)
[10:29:53.631]                         }
[10:29:53.631]                         base::stop(msg)
[10:29:53.631]                       }
[10:29:53.631]                     })
[10:29:53.631]                   }
[10:29:53.631]                   ...future.strategy.old <- future::plan("list")
[10:29:53.631]                   options(future.plan = NULL)
[10:29:53.631]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.631]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:53.631]                 }
[10:29:53.631]                 ...future.workdir <- getwd()
[10:29:53.631]             }
[10:29:53.631]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:53.631]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:53.631]         }
[10:29:53.631]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:53.631]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:53.631]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:53.631]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:53.631]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:53.631]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:53.631]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:53.631]             base::names(...future.oldOptions))
[10:29:53.631]     }
[10:29:53.631]     if (FALSE) {
[10:29:53.631]     }
[10:29:53.631]     else {
[10:29:53.631]         if (TRUE) {
[10:29:53.631]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:53.631]                 open = "w")
[10:29:53.631]         }
[10:29:53.631]         else {
[10:29:53.631]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:53.631]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:53.631]         }
[10:29:53.631]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:53.631]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:53.631]             base::sink(type = "output", split = FALSE)
[10:29:53.631]             base::close(...future.stdout)
[10:29:53.631]         }, add = TRUE)
[10:29:53.631]     }
[10:29:53.631]     ...future.frame <- base::sys.nframe()
[10:29:53.631]     ...future.conditions <- base::list()
[10:29:53.631]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:53.631]     if (FALSE) {
[10:29:53.631]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:53.631]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:53.631]     }
[10:29:53.631]     ...future.result <- base::tryCatch({
[10:29:53.631]         base::withCallingHandlers({
[10:29:53.631]             ...future.value <- base::withVisible(base::local({
[10:29:53.631]                 do.call(function(...) {
[10:29:53.631]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.631]                   if (!identical(...future.globals.maxSize.org, 
[10:29:53.631]                     ...future.globals.maxSize)) {
[10:29:53.631]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.631]                     on.exit(options(oopts), add = TRUE)
[10:29:53.631]                   }
[10:29:53.631]                   {
[10:29:53.631]                     lapply(seq_along(...future.elements_ii), 
[10:29:53.631]                       FUN = function(jj) {
[10:29:53.631]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.631]                         ...future.FUN(...future.X_jj, ...)
[10:29:53.631]                       })
[10:29:53.631]                   }
[10:29:53.631]                 }, args = future.call.arguments)
[10:29:53.631]             }))
[10:29:53.631]             future::FutureResult(value = ...future.value$value, 
[10:29:53.631]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.631]                   ...future.rng), globalenv = if (FALSE) 
[10:29:53.631]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:53.631]                     ...future.globalenv.names))
[10:29:53.631]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:53.631]         }, condition = base::local({
[10:29:53.631]             c <- base::c
[10:29:53.631]             inherits <- base::inherits
[10:29:53.631]             invokeRestart <- base::invokeRestart
[10:29:53.631]             length <- base::length
[10:29:53.631]             list <- base::list
[10:29:53.631]             seq.int <- base::seq.int
[10:29:53.631]             signalCondition <- base::signalCondition
[10:29:53.631]             sys.calls <- base::sys.calls
[10:29:53.631]             `[[` <- base::`[[`
[10:29:53.631]             `+` <- base::`+`
[10:29:53.631]             `<<-` <- base::`<<-`
[10:29:53.631]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:53.631]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:53.631]                   3L)]
[10:29:53.631]             }
[10:29:53.631]             function(cond) {
[10:29:53.631]                 is_error <- inherits(cond, "error")
[10:29:53.631]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:53.631]                   NULL)
[10:29:53.631]                 if (is_error) {
[10:29:53.631]                   sessionInformation <- function() {
[10:29:53.631]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:53.631]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:53.631]                       search = base::search(), system = base::Sys.info())
[10:29:53.631]                   }
[10:29:53.631]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.631]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:53.631]                     cond$call), session = sessionInformation(), 
[10:29:53.631]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:53.631]                   signalCondition(cond)
[10:29:53.631]                 }
[10:29:53.631]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:53.631]                 "immediateCondition"))) {
[10:29:53.631]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:53.631]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.631]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:53.631]                   if (TRUE && !signal) {
[10:29:53.631]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.631]                     {
[10:29:53.631]                       inherits <- base::inherits
[10:29:53.631]                       invokeRestart <- base::invokeRestart
[10:29:53.631]                       is.null <- base::is.null
[10:29:53.631]                       muffled <- FALSE
[10:29:53.631]                       if (inherits(cond, "message")) {
[10:29:53.631]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.631]                         if (muffled) 
[10:29:53.631]                           invokeRestart("muffleMessage")
[10:29:53.631]                       }
[10:29:53.631]                       else if (inherits(cond, "warning")) {
[10:29:53.631]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.631]                         if (muffled) 
[10:29:53.631]                           invokeRestart("muffleWarning")
[10:29:53.631]                       }
[10:29:53.631]                       else if (inherits(cond, "condition")) {
[10:29:53.631]                         if (!is.null(pattern)) {
[10:29:53.631]                           computeRestarts <- base::computeRestarts
[10:29:53.631]                           grepl <- base::grepl
[10:29:53.631]                           restarts <- computeRestarts(cond)
[10:29:53.631]                           for (restart in restarts) {
[10:29:53.631]                             name <- restart$name
[10:29:53.631]                             if (is.null(name)) 
[10:29:53.631]                               next
[10:29:53.631]                             if (!grepl(pattern, name)) 
[10:29:53.631]                               next
[10:29:53.631]                             invokeRestart(restart)
[10:29:53.631]                             muffled <- TRUE
[10:29:53.631]                             break
[10:29:53.631]                           }
[10:29:53.631]                         }
[10:29:53.631]                       }
[10:29:53.631]                       invisible(muffled)
[10:29:53.631]                     }
[10:29:53.631]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.631]                   }
[10:29:53.631]                 }
[10:29:53.631]                 else {
[10:29:53.631]                   if (TRUE) {
[10:29:53.631]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.631]                     {
[10:29:53.631]                       inherits <- base::inherits
[10:29:53.631]                       invokeRestart <- base::invokeRestart
[10:29:53.631]                       is.null <- base::is.null
[10:29:53.631]                       muffled <- FALSE
[10:29:53.631]                       if (inherits(cond, "message")) {
[10:29:53.631]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.631]                         if (muffled) 
[10:29:53.631]                           invokeRestart("muffleMessage")
[10:29:53.631]                       }
[10:29:53.631]                       else if (inherits(cond, "warning")) {
[10:29:53.631]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.631]                         if (muffled) 
[10:29:53.631]                           invokeRestart("muffleWarning")
[10:29:53.631]                       }
[10:29:53.631]                       else if (inherits(cond, "condition")) {
[10:29:53.631]                         if (!is.null(pattern)) {
[10:29:53.631]                           computeRestarts <- base::computeRestarts
[10:29:53.631]                           grepl <- base::grepl
[10:29:53.631]                           restarts <- computeRestarts(cond)
[10:29:53.631]                           for (restart in restarts) {
[10:29:53.631]                             name <- restart$name
[10:29:53.631]                             if (is.null(name)) 
[10:29:53.631]                               next
[10:29:53.631]                             if (!grepl(pattern, name)) 
[10:29:53.631]                               next
[10:29:53.631]                             invokeRestart(restart)
[10:29:53.631]                             muffled <- TRUE
[10:29:53.631]                             break
[10:29:53.631]                           }
[10:29:53.631]                         }
[10:29:53.631]                       }
[10:29:53.631]                       invisible(muffled)
[10:29:53.631]                     }
[10:29:53.631]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.631]                   }
[10:29:53.631]                 }
[10:29:53.631]             }
[10:29:53.631]         }))
[10:29:53.631]     }, error = function(ex) {
[10:29:53.631]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:53.631]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.631]                 ...future.rng), started = ...future.startTime, 
[10:29:53.631]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:53.631]             version = "1.8"), class = "FutureResult")
[10:29:53.631]     }, finally = {
[10:29:53.631]         if (!identical(...future.workdir, getwd())) 
[10:29:53.631]             setwd(...future.workdir)
[10:29:53.631]         {
[10:29:53.631]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:53.631]                 ...future.oldOptions$nwarnings <- NULL
[10:29:53.631]             }
[10:29:53.631]             base::options(...future.oldOptions)
[10:29:53.631]             if (.Platform$OS.type == "windows") {
[10:29:53.631]                 old_names <- names(...future.oldEnvVars)
[10:29:53.631]                 envs <- base::Sys.getenv()
[10:29:53.631]                 names <- names(envs)
[10:29:53.631]                 common <- intersect(names, old_names)
[10:29:53.631]                 added <- setdiff(names, old_names)
[10:29:53.631]                 removed <- setdiff(old_names, names)
[10:29:53.631]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:53.631]                   envs[common]]
[10:29:53.631]                 NAMES <- toupper(changed)
[10:29:53.631]                 args <- list()
[10:29:53.631]                 for (kk in seq_along(NAMES)) {
[10:29:53.631]                   name <- changed[[kk]]
[10:29:53.631]                   NAME <- NAMES[[kk]]
[10:29:53.631]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.631]                     next
[10:29:53.631]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.631]                 }
[10:29:53.631]                 NAMES <- toupper(added)
[10:29:53.631]                 for (kk in seq_along(NAMES)) {
[10:29:53.631]                   name <- added[[kk]]
[10:29:53.631]                   NAME <- NAMES[[kk]]
[10:29:53.631]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.631]                     next
[10:29:53.631]                   args[[name]] <- ""
[10:29:53.631]                 }
[10:29:53.631]                 NAMES <- toupper(removed)
[10:29:53.631]                 for (kk in seq_along(NAMES)) {
[10:29:53.631]                   name <- removed[[kk]]
[10:29:53.631]                   NAME <- NAMES[[kk]]
[10:29:53.631]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.631]                     next
[10:29:53.631]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.631]                 }
[10:29:53.631]                 if (length(args) > 0) 
[10:29:53.631]                   base::do.call(base::Sys.setenv, args = args)
[10:29:53.631]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:53.631]             }
[10:29:53.631]             else {
[10:29:53.631]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:53.631]             }
[10:29:53.631]             {
[10:29:53.631]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:53.631]                   0L) {
[10:29:53.631]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:53.631]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:53.631]                   base::options(opts)
[10:29:53.631]                 }
[10:29:53.631]                 {
[10:29:53.631]                   {
[10:29:53.631]                     NULL
[10:29:53.631]                     RNGkind("Mersenne-Twister")
[10:29:53.631]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:53.631]                       inherits = FALSE)
[10:29:53.631]                   }
[10:29:53.631]                   options(future.plan = NULL)
[10:29:53.631]                   if (is.na(NA_character_)) 
[10:29:53.631]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.631]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:53.631]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:53.631]                     .init = FALSE)
[10:29:53.631]                 }
[10:29:53.631]             }
[10:29:53.631]         }
[10:29:53.631]     })
[10:29:53.631]     if (TRUE) {
[10:29:53.631]         base::sink(type = "output", split = FALSE)
[10:29:53.631]         if (TRUE) {
[10:29:53.631]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:53.631]         }
[10:29:53.631]         else {
[10:29:53.631]             ...future.result["stdout"] <- base::list(NULL)
[10:29:53.631]         }
[10:29:53.631]         base::close(...future.stdout)
[10:29:53.631]         ...future.stdout <- NULL
[10:29:53.631]     }
[10:29:53.631]     ...future.result$conditions <- ...future.conditions
[10:29:53.631]     ...future.result$finished <- base::Sys.time()
[10:29:53.631]     ...future.result
[10:29:53.631] }
[10:29:53.633] assign_globals() ...
[10:29:53.633] List of 5
[10:29:53.633]  $ ...future.FUN            :function (object, ...)  
[10:29:53.633]  $ future.call.arguments    : list()
[10:29:53.633]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.633]  $ ...future.elements_ii    :List of 3
[10:29:53.633]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:29:53.633]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:29:53.633]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.633]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:29:53.633]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:29:53.633]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.633]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:29:53.633]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:29:53.633]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.633]  $ ...future.seeds_ii       : NULL
[10:29:53.633]  $ ...future.globals.maxSize: NULL
[10:29:53.633]  - attr(*, "where")=List of 5
[10:29:53.633]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:53.633]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:53.633]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:53.633]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:53.633]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:53.633]  - attr(*, "resolved")= logi FALSE
[10:29:53.633]  - attr(*, "total_size")= num 1240
[10:29:53.633]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.633]  - attr(*, "already-done")= logi TRUE
[10:29:53.640] - copied ‘...future.FUN’ to environment
[10:29:53.640] - copied ‘future.call.arguments’ to environment
[10:29:53.641] - copied ‘...future.elements_ii’ to environment
[10:29:53.641] - copied ‘...future.seeds_ii’ to environment
[10:29:53.641] - copied ‘...future.globals.maxSize’ to environment
[10:29:53.641] assign_globals() ... done
[10:29:53.641] plan(): Setting new future strategy stack:
[10:29:53.641] List of future strategies:
[10:29:53.641] 1. sequential:
[10:29:53.641]    - args: function (..., envir = parent.frame())
[10:29:53.641]    - tweaked: FALSE
[10:29:53.641]    - call: NULL
[10:29:53.642] plan(): nbrOfWorkers() = 1
[10:29:53.644] plan(): Setting new future strategy stack:
[10:29:53.644] List of future strategies:
[10:29:53.644] 1. multisession:
[10:29:53.644]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:29:53.644]    - tweaked: FALSE
[10:29:53.644]    - call: plan(strategy)
[10:29:53.647] plan(): nbrOfWorkers() = 1
[10:29:53.648] SequentialFuture started (and completed)
[10:29:53.648] - Launch lazy future ... done
[10:29:53.648] run() for ‘SequentialFuture’ ... done
[10:29:53.648] Created future:
[10:29:53.648] SequentialFuture:
[10:29:53.648] Label: ‘future_by-1’
[10:29:53.648] Expression:
[10:29:53.648] {
[10:29:53.648]     do.call(function(...) {
[10:29:53.648]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.648]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.648]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.648]             on.exit(options(oopts), add = TRUE)
[10:29:53.648]         }
[10:29:53.648]         {
[10:29:53.648]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.648]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.648]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.648]             })
[10:29:53.648]         }
[10:29:53.648]     }, args = future.call.arguments)
[10:29:53.648] }
[10:29:53.648] Lazy evaluation: FALSE
[10:29:53.648] Asynchronous evaluation: FALSE
[10:29:53.648] Local evaluation: TRUE
[10:29:53.648] Environment: R_GlobalEnv
[10:29:53.648] Capture standard output: TRUE
[10:29:53.648] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:53.648] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:53.648] Packages: <none>
[10:29:53.648] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:53.648] Resolved: TRUE
[10:29:53.648] Value: 4.62 KiB of class ‘list’
[10:29:53.648] Early signaling: FALSE
[10:29:53.648] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:53.648] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.651] Chunk #1 of 1 ... DONE
[10:29:53.652] Launching 1 futures (chunks) ... DONE
[10:29:53.652] Resolving 1 futures (chunks) ...
[10:29:53.652] resolve() on list ...
[10:29:53.652]  recursive: 0
[10:29:53.652]  length: 1
[10:29:53.652] 
[10:29:53.652] resolved() for ‘SequentialFuture’ ...
[10:29:53.652] - state: ‘finished’
[10:29:53.653] - run: TRUE
[10:29:53.653] - result: ‘FutureResult’
[10:29:53.653] resolved() for ‘SequentialFuture’ ... done
[10:29:53.653] Future #1
[10:29:53.653] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:53.653] - nx: 1
[10:29:53.653] - relay: TRUE
[10:29:53.653] - stdout: TRUE
[10:29:53.654] - signal: TRUE
[10:29:53.654] - resignal: FALSE
[10:29:53.654] - force: TRUE
[10:29:53.654] - relayed: [n=1] FALSE
[10:29:53.654] - queued futures: [n=1] FALSE
[10:29:53.654]  - until=1
[10:29:53.654]  - relaying element #1
[10:29:53.654] - relayed: [n=1] TRUE
[10:29:53.654] - queued futures: [n=1] TRUE
[10:29:53.655] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:53.655]  length: 0 (resolved future 1)
[10:29:53.655] Relaying remaining futures
[10:29:53.655] signalConditionsASAP(NULL, pos=0) ...
[10:29:53.655] - nx: 1
[10:29:53.655] - relay: TRUE
[10:29:53.655] - stdout: TRUE
[10:29:53.655] - signal: TRUE
[10:29:53.655] - resignal: FALSE
[10:29:53.655] - force: TRUE
[10:29:53.655] - relayed: [n=1] TRUE
[10:29:53.656] - queued futures: [n=1] TRUE
 - flush all
[10:29:53.656] - relayed: [n=1] TRUE
[10:29:53.656] - queued futures: [n=1] TRUE
[10:29:53.656] signalConditionsASAP(NULL, pos=0) ... done
[10:29:53.656] resolve() on list ... DONE
[10:29:53.656]  - Number of value chunks collected: 1
[10:29:53.656] Resolving 1 futures (chunks) ... DONE
[10:29:53.656] Reducing values from 1 chunks ...
[10:29:53.656]  - Number of values collected after concatenation: 3
[10:29:53.657]  - Number of values expected: 3
[10:29:53.657] Reducing values from 1 chunks ... DONE
[10:29:53.657] future_lapply() ... DONE
[10:29:53.657] future_by_internal() ... DONE
[10:29:53.657] future_by_internal() ...
[10:29:53.657] future_lapply() ...
[10:29:53.661] Number of chunks: 1
[10:29:53.662] getGlobalsAndPackagesXApply() ...
[10:29:53.662]  - future.globals: TRUE
[10:29:53.662] getGlobalsAndPackages() ...
[10:29:53.662] Searching for globals...
[10:29:53.663] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:53.663] Searching for globals ... DONE
[10:29:53.663] Resolving globals: FALSE
[10:29:53.664] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:53.664] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:53.664] - globals: [1] ‘FUN’
[10:29:53.664] 
[10:29:53.664] getGlobalsAndPackages() ... DONE
[10:29:53.664]  - globals found/used: [n=1] ‘FUN’
[10:29:53.665]  - needed namespaces: [n=0] 
[10:29:53.665] Finding globals ... DONE
[10:29:53.665]  - use_args: TRUE
[10:29:53.665]  - Getting '...' globals ...
[10:29:53.665] resolve() on list ...
[10:29:53.665]  recursive: 0
[10:29:53.665]  length: 1
[10:29:53.666]  elements: ‘...’
[10:29:53.666]  length: 0 (resolved future 1)
[10:29:53.666] resolve() on list ... DONE
[10:29:53.666]    - '...' content: [n=1] ‘digits’
[10:29:53.666] List of 1
[10:29:53.666]  $ ...:List of 1
[10:29:53.666]   ..$ digits: int 2
[10:29:53.666]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.666]  - attr(*, "where")=List of 1
[10:29:53.666]   ..$ ...:<environment: 0x556dd36652b8> 
[10:29:53.666]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.666]  - attr(*, "resolved")= logi TRUE
[10:29:53.666]  - attr(*, "total_size")= num NA
[10:29:53.669]  - Getting '...' globals ... DONE
[10:29:53.669] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:53.669] List of 2
[10:29:53.669]  $ ...future.FUN:function (object, ...)  
[10:29:53.669]  $ ...          :List of 1
[10:29:53.669]   ..$ digits: int 2
[10:29:53.669]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.669]  - attr(*, "where")=List of 2
[10:29:53.669]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:53.669]   ..$ ...          :<environment: 0x556dd36652b8> 
[10:29:53.669]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.669]  - attr(*, "resolved")= logi FALSE
[10:29:53.669]  - attr(*, "total_size")= num 1296
[10:29:53.673] Packages to be attached in all futures: [n=0] 
[10:29:53.673] getGlobalsAndPackagesXApply() ... DONE
[10:29:53.673] Number of futures (= number of chunks): 1
[10:29:53.673] Launching 1 futures (chunks) ...
[10:29:53.673] Chunk #1 of 1 ...
[10:29:53.673]  - Finding globals in 'X' for chunk #1 ...
[10:29:53.673] getGlobalsAndPackages() ...
[10:29:53.674] Searching for globals...
[10:29:53.674] 
[10:29:53.674] Searching for globals ... DONE
[10:29:53.674] - globals: [0] <none>
[10:29:53.676] getGlobalsAndPackages() ... DONE
[10:29:53.676]    + additional globals found: [n=0] 
[10:29:53.676]    + additional namespaces needed: [n=0] 
[10:29:53.676]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:53.676]  - seeds: <none>
[10:29:53.677]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.677] getGlobalsAndPackages() ...
[10:29:53.677] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.677] Resolving globals: FALSE
[10:29:53.677] Tweak future expression to call with '...' arguments ...
[10:29:53.677] {
[10:29:53.677]     do.call(function(...) {
[10:29:53.677]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.677]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.677]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.677]             on.exit(options(oopts), add = TRUE)
[10:29:53.677]         }
[10:29:53.677]         {
[10:29:53.677]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.677]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.677]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.677]             })
[10:29:53.677]         }
[10:29:53.677]     }, args = future.call.arguments)
[10:29:53.677] }
[10:29:53.678] Tweak future expression to call with '...' arguments ... DONE
[10:29:53.678] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.678] 
[10:29:53.678] getGlobalsAndPackages() ... DONE
[10:29:53.679] run() for ‘Future’ ...
[10:29:53.679] - state: ‘created’
[10:29:53.679] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:53.683] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.683] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:53.683]   - Field: ‘label’
[10:29:53.683]   - Field: ‘local’
[10:29:53.683]   - Field: ‘owner’
[10:29:53.683]   - Field: ‘envir’
[10:29:53.683]   - Field: ‘packages’
[10:29:53.683]   - Field: ‘gc’
[10:29:53.684]   - Field: ‘conditions’
[10:29:53.684]   - Field: ‘expr’
[10:29:53.684]   - Field: ‘uuid’
[10:29:53.684]   - Field: ‘seed’
[10:29:53.684]   - Field: ‘version’
[10:29:53.684]   - Field: ‘result’
[10:29:53.684]   - Field: ‘asynchronous’
[10:29:53.684]   - Field: ‘calls’
[10:29:53.684]   - Field: ‘globals’
[10:29:53.684]   - Field: ‘stdout’
[10:29:53.684]   - Field: ‘earlySignal’
[10:29:53.685]   - Field: ‘lazy’
[10:29:53.685]   - Field: ‘state’
[10:29:53.685] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:53.685] - Launch lazy future ...
[10:29:53.685] Packages needed by the future expression (n = 0): <none>
[10:29:53.685] Packages needed by future strategies (n = 0): <none>
[10:29:53.686] {
[10:29:53.686]     {
[10:29:53.686]         {
[10:29:53.686]             ...future.startTime <- base::Sys.time()
[10:29:53.686]             {
[10:29:53.686]                 {
[10:29:53.686]                   {
[10:29:53.686]                     base::local({
[10:29:53.686]                       has_future <- base::requireNamespace("future", 
[10:29:53.686]                         quietly = TRUE)
[10:29:53.686]                       if (has_future) {
[10:29:53.686]                         ns <- base::getNamespace("future")
[10:29:53.686]                         version <- ns[[".package"]][["version"]]
[10:29:53.686]                         if (is.null(version)) 
[10:29:53.686]                           version <- utils::packageVersion("future")
[10:29:53.686]                       }
[10:29:53.686]                       else {
[10:29:53.686]                         version <- NULL
[10:29:53.686]                       }
[10:29:53.686]                       if (!has_future || version < "1.8.0") {
[10:29:53.686]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:53.686]                           "", base::R.version$version.string), 
[10:29:53.686]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:53.686]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:53.686]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:53.686]                             "release", "version")], collapse = " "), 
[10:29:53.686]                           hostname = base::Sys.info()[["nodename"]])
[10:29:53.686]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:53.686]                           info)
[10:29:53.686]                         info <- base::paste(info, collapse = "; ")
[10:29:53.686]                         if (!has_future) {
[10:29:53.686]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:53.686]                             info)
[10:29:53.686]                         }
[10:29:53.686]                         else {
[10:29:53.686]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:53.686]                             info, version)
[10:29:53.686]                         }
[10:29:53.686]                         base::stop(msg)
[10:29:53.686]                       }
[10:29:53.686]                     })
[10:29:53.686]                   }
[10:29:53.686]                   ...future.strategy.old <- future::plan("list")
[10:29:53.686]                   options(future.plan = NULL)
[10:29:53.686]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.686]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:53.686]                 }
[10:29:53.686]                 ...future.workdir <- getwd()
[10:29:53.686]             }
[10:29:53.686]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:53.686]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:53.686]         }
[10:29:53.686]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:53.686]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:53.686]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:53.686]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:53.686]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:53.686]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:53.686]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:53.686]             base::names(...future.oldOptions))
[10:29:53.686]     }
[10:29:53.686]     if (FALSE) {
[10:29:53.686]     }
[10:29:53.686]     else {
[10:29:53.686]         if (TRUE) {
[10:29:53.686]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:53.686]                 open = "w")
[10:29:53.686]         }
[10:29:53.686]         else {
[10:29:53.686]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:53.686]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:53.686]         }
[10:29:53.686]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:53.686]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:53.686]             base::sink(type = "output", split = FALSE)
[10:29:53.686]             base::close(...future.stdout)
[10:29:53.686]         }, add = TRUE)
[10:29:53.686]     }
[10:29:53.686]     ...future.frame <- base::sys.nframe()
[10:29:53.686]     ...future.conditions <- base::list()
[10:29:53.686]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:53.686]     if (FALSE) {
[10:29:53.686]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:53.686]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:53.686]     }
[10:29:53.686]     ...future.result <- base::tryCatch({
[10:29:53.686]         base::withCallingHandlers({
[10:29:53.686]             ...future.value <- base::withVisible(base::local({
[10:29:53.686]                 do.call(function(...) {
[10:29:53.686]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.686]                   if (!identical(...future.globals.maxSize.org, 
[10:29:53.686]                     ...future.globals.maxSize)) {
[10:29:53.686]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.686]                     on.exit(options(oopts), add = TRUE)
[10:29:53.686]                   }
[10:29:53.686]                   {
[10:29:53.686]                     lapply(seq_along(...future.elements_ii), 
[10:29:53.686]                       FUN = function(jj) {
[10:29:53.686]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.686]                         ...future.FUN(...future.X_jj, ...)
[10:29:53.686]                       })
[10:29:53.686]                   }
[10:29:53.686]                 }, args = future.call.arguments)
[10:29:53.686]             }))
[10:29:53.686]             future::FutureResult(value = ...future.value$value, 
[10:29:53.686]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.686]                   ...future.rng), globalenv = if (FALSE) 
[10:29:53.686]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:53.686]                     ...future.globalenv.names))
[10:29:53.686]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:53.686]         }, condition = base::local({
[10:29:53.686]             c <- base::c
[10:29:53.686]             inherits <- base::inherits
[10:29:53.686]             invokeRestart <- base::invokeRestart
[10:29:53.686]             length <- base::length
[10:29:53.686]             list <- base::list
[10:29:53.686]             seq.int <- base::seq.int
[10:29:53.686]             signalCondition <- base::signalCondition
[10:29:53.686]             sys.calls <- base::sys.calls
[10:29:53.686]             `[[` <- base::`[[`
[10:29:53.686]             `+` <- base::`+`
[10:29:53.686]             `<<-` <- base::`<<-`
[10:29:53.686]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:53.686]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:53.686]                   3L)]
[10:29:53.686]             }
[10:29:53.686]             function(cond) {
[10:29:53.686]                 is_error <- inherits(cond, "error")
[10:29:53.686]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:53.686]                   NULL)
[10:29:53.686]                 if (is_error) {
[10:29:53.686]                   sessionInformation <- function() {
[10:29:53.686]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:53.686]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:53.686]                       search = base::search(), system = base::Sys.info())
[10:29:53.686]                   }
[10:29:53.686]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.686]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:53.686]                     cond$call), session = sessionInformation(), 
[10:29:53.686]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:53.686]                   signalCondition(cond)
[10:29:53.686]                 }
[10:29:53.686]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:53.686]                 "immediateCondition"))) {
[10:29:53.686]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:53.686]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.686]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:53.686]                   if (TRUE && !signal) {
[10:29:53.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.686]                     {
[10:29:53.686]                       inherits <- base::inherits
[10:29:53.686]                       invokeRestart <- base::invokeRestart
[10:29:53.686]                       is.null <- base::is.null
[10:29:53.686]                       muffled <- FALSE
[10:29:53.686]                       if (inherits(cond, "message")) {
[10:29:53.686]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.686]                         if (muffled) 
[10:29:53.686]                           invokeRestart("muffleMessage")
[10:29:53.686]                       }
[10:29:53.686]                       else if (inherits(cond, "warning")) {
[10:29:53.686]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.686]                         if (muffled) 
[10:29:53.686]                           invokeRestart("muffleWarning")
[10:29:53.686]                       }
[10:29:53.686]                       else if (inherits(cond, "condition")) {
[10:29:53.686]                         if (!is.null(pattern)) {
[10:29:53.686]                           computeRestarts <- base::computeRestarts
[10:29:53.686]                           grepl <- base::grepl
[10:29:53.686]                           restarts <- computeRestarts(cond)
[10:29:53.686]                           for (restart in restarts) {
[10:29:53.686]                             name <- restart$name
[10:29:53.686]                             if (is.null(name)) 
[10:29:53.686]                               next
[10:29:53.686]                             if (!grepl(pattern, name)) 
[10:29:53.686]                               next
[10:29:53.686]                             invokeRestart(restart)
[10:29:53.686]                             muffled <- TRUE
[10:29:53.686]                             break
[10:29:53.686]                           }
[10:29:53.686]                         }
[10:29:53.686]                       }
[10:29:53.686]                       invisible(muffled)
[10:29:53.686]                     }
[10:29:53.686]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.686]                   }
[10:29:53.686]                 }
[10:29:53.686]                 else {
[10:29:53.686]                   if (TRUE) {
[10:29:53.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.686]                     {
[10:29:53.686]                       inherits <- base::inherits
[10:29:53.686]                       invokeRestart <- base::invokeRestart
[10:29:53.686]                       is.null <- base::is.null
[10:29:53.686]                       muffled <- FALSE
[10:29:53.686]                       if (inherits(cond, "message")) {
[10:29:53.686]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.686]                         if (muffled) 
[10:29:53.686]                           invokeRestart("muffleMessage")
[10:29:53.686]                       }
[10:29:53.686]                       else if (inherits(cond, "warning")) {
[10:29:53.686]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.686]                         if (muffled) 
[10:29:53.686]                           invokeRestart("muffleWarning")
[10:29:53.686]                       }
[10:29:53.686]                       else if (inherits(cond, "condition")) {
[10:29:53.686]                         if (!is.null(pattern)) {
[10:29:53.686]                           computeRestarts <- base::computeRestarts
[10:29:53.686]                           grepl <- base::grepl
[10:29:53.686]                           restarts <- computeRestarts(cond)
[10:29:53.686]                           for (restart in restarts) {
[10:29:53.686]                             name <- restart$name
[10:29:53.686]                             if (is.null(name)) 
[10:29:53.686]                               next
[10:29:53.686]                             if (!grepl(pattern, name)) 
[10:29:53.686]                               next
[10:29:53.686]                             invokeRestart(restart)
[10:29:53.686]                             muffled <- TRUE
[10:29:53.686]                             break
[10:29:53.686]                           }
[10:29:53.686]                         }
[10:29:53.686]                       }
[10:29:53.686]                       invisible(muffled)
[10:29:53.686]                     }
[10:29:53.686]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.686]                   }
[10:29:53.686]                 }
[10:29:53.686]             }
[10:29:53.686]         }))
[10:29:53.686]     }, error = function(ex) {
[10:29:53.686]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:53.686]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.686]                 ...future.rng), started = ...future.startTime, 
[10:29:53.686]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:53.686]             version = "1.8"), class = "FutureResult")
[10:29:53.686]     }, finally = {
[10:29:53.686]         if (!identical(...future.workdir, getwd())) 
[10:29:53.686]             setwd(...future.workdir)
[10:29:53.686]         {
[10:29:53.686]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:53.686]                 ...future.oldOptions$nwarnings <- NULL
[10:29:53.686]             }
[10:29:53.686]             base::options(...future.oldOptions)
[10:29:53.686]             if (.Platform$OS.type == "windows") {
[10:29:53.686]                 old_names <- names(...future.oldEnvVars)
[10:29:53.686]                 envs <- base::Sys.getenv()
[10:29:53.686]                 names <- names(envs)
[10:29:53.686]                 common <- intersect(names, old_names)
[10:29:53.686]                 added <- setdiff(names, old_names)
[10:29:53.686]                 removed <- setdiff(old_names, names)
[10:29:53.686]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:53.686]                   envs[common]]
[10:29:53.686]                 NAMES <- toupper(changed)
[10:29:53.686]                 args <- list()
[10:29:53.686]                 for (kk in seq_along(NAMES)) {
[10:29:53.686]                   name <- changed[[kk]]
[10:29:53.686]                   NAME <- NAMES[[kk]]
[10:29:53.686]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.686]                     next
[10:29:53.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.686]                 }
[10:29:53.686]                 NAMES <- toupper(added)
[10:29:53.686]                 for (kk in seq_along(NAMES)) {
[10:29:53.686]                   name <- added[[kk]]
[10:29:53.686]                   NAME <- NAMES[[kk]]
[10:29:53.686]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.686]                     next
[10:29:53.686]                   args[[name]] <- ""
[10:29:53.686]                 }
[10:29:53.686]                 NAMES <- toupper(removed)
[10:29:53.686]                 for (kk in seq_along(NAMES)) {
[10:29:53.686]                   name <- removed[[kk]]
[10:29:53.686]                   NAME <- NAMES[[kk]]
[10:29:53.686]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.686]                     next
[10:29:53.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.686]                 }
[10:29:53.686]                 if (length(args) > 0) 
[10:29:53.686]                   base::do.call(base::Sys.setenv, args = args)
[10:29:53.686]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:53.686]             }
[10:29:53.686]             else {
[10:29:53.686]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:53.686]             }
[10:29:53.686]             {
[10:29:53.686]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:53.686]                   0L) {
[10:29:53.686]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:53.686]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:53.686]                   base::options(opts)
[10:29:53.686]                 }
[10:29:53.686]                 {
[10:29:53.686]                   {
[10:29:53.686]                     NULL
[10:29:53.686]                     RNGkind("Mersenne-Twister")
[10:29:53.686]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:53.686]                       inherits = FALSE)
[10:29:53.686]                   }
[10:29:53.686]                   options(future.plan = NULL)
[10:29:53.686]                   if (is.na(NA_character_)) 
[10:29:53.686]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.686]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:53.686]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:53.686]                     .init = FALSE)
[10:29:53.686]                 }
[10:29:53.686]             }
[10:29:53.686]         }
[10:29:53.686]     })
[10:29:53.686]     if (TRUE) {
[10:29:53.686]         base::sink(type = "output", split = FALSE)
[10:29:53.686]         if (TRUE) {
[10:29:53.686]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:53.686]         }
[10:29:53.686]         else {
[10:29:53.686]             ...future.result["stdout"] <- base::list(NULL)
[10:29:53.686]         }
[10:29:53.686]         base::close(...future.stdout)
[10:29:53.686]         ...future.stdout <- NULL
[10:29:53.686]     }
[10:29:53.686]     ...future.result$conditions <- ...future.conditions
[10:29:53.686]     ...future.result$finished <- base::Sys.time()
[10:29:53.686]     ...future.result
[10:29:53.686] }
[10:29:53.687] assign_globals() ...
[10:29:53.688] List of 5
[10:29:53.688]  $ ...future.FUN            :function (object, ...)  
[10:29:53.688]  $ future.call.arguments    :List of 1
[10:29:53.688]   ..$ digits: int 2
[10:29:53.688]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.688]  $ ...future.elements_ii    :List of 6
[10:29:53.688]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[10:29:53.688]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[10:29:53.688]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[10:29:53.688]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[10:29:53.688]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[10:29:53.688]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[10:29:53.688]  $ ...future.seeds_ii       : NULL
[10:29:53.688]  $ ...future.globals.maxSize: NULL
[10:29:53.688]  - attr(*, "where")=List of 5
[10:29:53.688]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:53.688]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:53.688]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:53.688]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:53.688]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:53.688]  - attr(*, "resolved")= logi FALSE
[10:29:53.688]  - attr(*, "total_size")= num 1296
[10:29:53.688]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.688]  - attr(*, "already-done")= logi TRUE
[10:29:53.695] - copied ‘...future.FUN’ to environment
[10:29:53.695] - copied ‘future.call.arguments’ to environment
[10:29:53.695] - copied ‘...future.elements_ii’ to environment
[10:29:53.695] - copied ‘...future.seeds_ii’ to environment
[10:29:53.695] - copied ‘...future.globals.maxSize’ to environment
[10:29:53.695] assign_globals() ... done
[10:29:53.695] plan(): Setting new future strategy stack:
[10:29:53.695] List of future strategies:
[10:29:53.695] 1. sequential:
[10:29:53.695]    - args: function (..., envir = parent.frame())
[10:29:53.695]    - tweaked: FALSE
[10:29:53.695]    - call: NULL
[10:29:53.696] plan(): nbrOfWorkers() = 1
[10:29:53.697] plan(): Setting new future strategy stack:
[10:29:53.697] List of future strategies:
[10:29:53.697] 1. multisession:
[10:29:53.697]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:29:53.697]    - tweaked: FALSE
[10:29:53.697]    - call: plan(strategy)
[10:29:53.701] plan(): nbrOfWorkers() = 1
[10:29:53.701] SequentialFuture started (and completed)
[10:29:53.701] - Launch lazy future ... done
[10:29:53.702] run() for ‘SequentialFuture’ ... done
[10:29:53.702] Created future:
[10:29:53.702] SequentialFuture:
[10:29:53.702] Label: ‘future_by-1’
[10:29:53.702] Expression:
[10:29:53.702] {
[10:29:53.702]     do.call(function(...) {
[10:29:53.702]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.702]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.702]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.702]             on.exit(options(oopts), add = TRUE)
[10:29:53.702]         }
[10:29:53.702]         {
[10:29:53.702]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.702]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.702]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.702]             })
[10:29:53.702]         }
[10:29:53.702]     }, args = future.call.arguments)
[10:29:53.702] }
[10:29:53.702] Lazy evaluation: FALSE
[10:29:53.702] Asynchronous evaluation: FALSE
[10:29:53.702] Local evaluation: TRUE
[10:29:53.702] Environment: R_GlobalEnv
[10:29:53.702] Capture standard output: TRUE
[10:29:53.702] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:53.702] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:53.702] Packages: <none>
[10:29:53.702] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:53.702] Resolved: TRUE
[10:29:53.702] Value: 5.48 KiB of class ‘list’
[10:29:53.702] Early signaling: FALSE
[10:29:53.702] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:53.702] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.703] Chunk #1 of 1 ... DONE
[10:29:53.703] Launching 1 futures (chunks) ... DONE
[10:29:53.705] Resolving 1 futures (chunks) ...
[10:29:53.705] resolve() on list ...
[10:29:53.705]  recursive: 0
[10:29:53.706]  length: 1
[10:29:53.706] 
[10:29:53.706] resolved() for ‘SequentialFuture’ ...
[10:29:53.706] - state: ‘finished’
[10:29:53.706] - run: TRUE
[10:29:53.706] - result: ‘FutureResult’
[10:29:53.706] resolved() for ‘SequentialFuture’ ... done
[10:29:53.706] Future #1
[10:29:53.707] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:53.707] - nx: 1
[10:29:53.707] - relay: TRUE
[10:29:53.707] - stdout: TRUE
[10:29:53.707] - signal: TRUE
[10:29:53.707] - resignal: FALSE
[10:29:53.707] - force: TRUE
[10:29:53.707] - relayed: [n=1] FALSE
[10:29:53.707] - queued futures: [n=1] FALSE
[10:29:53.708]  - until=1
[10:29:53.708]  - relaying element #1
[10:29:53.708] - relayed: [n=1] TRUE
[10:29:53.708] - queued futures: [n=1] TRUE
[10:29:53.708] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:53.708]  length: 0 (resolved future 1)
[10:29:53.708] Relaying remaining futures
[10:29:53.708] signalConditionsASAP(NULL, pos=0) ...
[10:29:53.709] - nx: 1
[10:29:53.709] - relay: TRUE
[10:29:53.709] - stdout: TRUE
[10:29:53.709] - signal: TRUE
[10:29:53.709] - resignal: FALSE
[10:29:53.709] - force: TRUE
[10:29:53.709] - relayed: [n=1] TRUE
[10:29:53.709] - queued futures: [n=1] TRUE
 - flush all
[10:29:53.709] - relayed: [n=1] TRUE
[10:29:53.709] - queued futures: [n=1] TRUE
[10:29:53.710] signalConditionsASAP(NULL, pos=0) ... done
[10:29:53.710] resolve() on list ... DONE
[10:29:53.710]  - Number of value chunks collected: 1
[10:29:53.710] Resolving 1 futures (chunks) ... DONE
[10:29:53.710] Reducing values from 1 chunks ...
[10:29:53.710]  - Number of values collected after concatenation: 6
[10:29:53.710]  - Number of values expected: 6
[10:29:53.710] Reducing values from 1 chunks ... DONE
[10:29:53.710] future_lapply() ... DONE
[10:29:53.711] future_by_internal() ... DONE
[10:29:53.712] future_by_internal() ...
[10:29:53.712] future_lapply() ...
[10:29:53.716] Number of chunks: 1
[10:29:53.716] getGlobalsAndPackagesXApply() ...
[10:29:53.716]  - future.globals: TRUE
[10:29:53.716] getGlobalsAndPackages() ...
[10:29:53.716] Searching for globals...
[10:29:53.718] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:29:53.718] Searching for globals ... DONE
[10:29:53.718] Resolving globals: FALSE
[10:29:53.719] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[10:29:53.719] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[10:29:53.719] - globals: [1] ‘FUN’
[10:29:53.720] - packages: [1] ‘stats’
[10:29:53.720] getGlobalsAndPackages() ... DONE
[10:29:53.720]  - globals found/used: [n=1] ‘FUN’
[10:29:53.720]  - needed namespaces: [n=1] ‘stats’
[10:29:53.720] Finding globals ... DONE
[10:29:53.720]  - use_args: TRUE
[10:29:53.720]  - Getting '...' globals ...
[10:29:53.720] resolve() on list ...
[10:29:53.721]  recursive: 0
[10:29:53.721]  length: 1
[10:29:53.721]  elements: ‘...’
[10:29:53.721]  length: 0 (resolved future 1)
[10:29:53.721] resolve() on list ... DONE
[10:29:53.721]    - '...' content: [n=1] ‘singular.ok’
[10:29:53.721] List of 1
[10:29:53.721]  $ ...:List of 1
[10:29:53.721]   ..$ singular.ok: logi FALSE
[10:29:53.721]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.721]  - attr(*, "where")=List of 1
[10:29:53.721]   ..$ ...:<environment: 0x556dd2def900> 
[10:29:53.721]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.721]  - attr(*, "resolved")= logi TRUE
[10:29:53.721]  - attr(*, "total_size")= num NA
[10:29:53.724]  - Getting '...' globals ... DONE
[10:29:53.724] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:53.725] List of 2
[10:29:53.725]  $ ...future.FUN:function (x, ...)  
[10:29:53.725]  $ ...          :List of 1
[10:29:53.725]   ..$ singular.ok: logi FALSE
[10:29:53.725]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.725]  - attr(*, "where")=List of 2
[10:29:53.725]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:53.725]   ..$ ...          :<environment: 0x556dd2def900> 
[10:29:53.725]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.725]  - attr(*, "resolved")= logi FALSE
[10:29:53.725]  - attr(*, "total_size")= num 5384
[10:29:53.730] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:53.730] getGlobalsAndPackagesXApply() ... DONE
[10:29:53.730] Number of futures (= number of chunks): 1
[10:29:53.730] Launching 1 futures (chunks) ...
[10:29:53.731] Chunk #1 of 1 ...
[10:29:53.731]  - Finding globals in 'X' for chunk #1 ...
[10:29:53.731] getGlobalsAndPackages() ...
[10:29:53.731] Searching for globals...
[10:29:53.731] 
[10:29:53.732] Searching for globals ... DONE
[10:29:53.732] - globals: [0] <none>
[10:29:53.732] getGlobalsAndPackages() ... DONE
[10:29:53.732]    + additional globals found: [n=0] 
[10:29:53.732]    + additional namespaces needed: [n=0] 
[10:29:53.732]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:53.732]  - seeds: <none>
[10:29:53.732]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.732] getGlobalsAndPackages() ...
[10:29:53.732] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.733] Resolving globals: FALSE
[10:29:53.733] Tweak future expression to call with '...' arguments ...
[10:29:53.733] {
[10:29:53.733]     do.call(function(...) {
[10:29:53.733]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.733]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.733]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.733]             on.exit(options(oopts), add = TRUE)
[10:29:53.733]         }
[10:29:53.733]         {
[10:29:53.733]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.733]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.733]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.733]             })
[10:29:53.733]         }
[10:29:53.733]     }, args = future.call.arguments)
[10:29:53.733] }
[10:29:53.733] Tweak future expression to call with '...' arguments ... DONE
[10:29:53.734] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.734] 
[10:29:53.734] getGlobalsAndPackages() ... DONE
[10:29:53.734] run() for ‘Future’ ...
[10:29:53.734] - state: ‘created’
[10:29:53.734] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:53.738] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.738] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:53.738]   - Field: ‘label’
[10:29:53.738]   - Field: ‘local’
[10:29:53.738]   - Field: ‘owner’
[10:29:53.739]   - Field: ‘envir’
[10:29:53.739]   - Field: ‘packages’
[10:29:53.739]   - Field: ‘gc’
[10:29:53.739]   - Field: ‘conditions’
[10:29:53.739]   - Field: ‘expr’
[10:29:53.739]   - Field: ‘uuid’
[10:29:53.739]   - Field: ‘seed’
[10:29:53.739]   - Field: ‘version’
[10:29:53.739]   - Field: ‘result’
[10:29:53.739]   - Field: ‘asynchronous’
[10:29:53.739]   - Field: ‘calls’
[10:29:53.740]   - Field: ‘globals’
[10:29:53.740]   - Field: ‘stdout’
[10:29:53.740]   - Field: ‘earlySignal’
[10:29:53.740]   - Field: ‘lazy’
[10:29:53.740]   - Field: ‘state’
[10:29:53.740] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:53.740] - Launch lazy future ...
[10:29:53.740] Packages needed by the future expression (n = 1): ‘stats’
[10:29:53.741] Packages needed by future strategies (n = 0): <none>
[10:29:53.741] {
[10:29:53.741]     {
[10:29:53.741]         {
[10:29:53.741]             ...future.startTime <- base::Sys.time()
[10:29:53.741]             {
[10:29:53.741]                 {
[10:29:53.741]                   {
[10:29:53.741]                     {
[10:29:53.741]                       base::local({
[10:29:53.741]                         has_future <- base::requireNamespace("future", 
[10:29:53.741]                           quietly = TRUE)
[10:29:53.741]                         if (has_future) {
[10:29:53.741]                           ns <- base::getNamespace("future")
[10:29:53.741]                           version <- ns[[".package"]][["version"]]
[10:29:53.741]                           if (is.null(version)) 
[10:29:53.741]                             version <- utils::packageVersion("future")
[10:29:53.741]                         }
[10:29:53.741]                         else {
[10:29:53.741]                           version <- NULL
[10:29:53.741]                         }
[10:29:53.741]                         if (!has_future || version < "1.8.0") {
[10:29:53.741]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:53.741]                             "", base::R.version$version.string), 
[10:29:53.741]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:53.741]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:53.741]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:53.741]                               "release", "version")], collapse = " "), 
[10:29:53.741]                             hostname = base::Sys.info()[["nodename"]])
[10:29:53.741]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:53.741]                             info)
[10:29:53.741]                           info <- base::paste(info, collapse = "; ")
[10:29:53.741]                           if (!has_future) {
[10:29:53.741]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:53.741]                               info)
[10:29:53.741]                           }
[10:29:53.741]                           else {
[10:29:53.741]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:53.741]                               info, version)
[10:29:53.741]                           }
[10:29:53.741]                           base::stop(msg)
[10:29:53.741]                         }
[10:29:53.741]                       })
[10:29:53.741]                     }
[10:29:53.741]                     base::local({
[10:29:53.741]                       for (pkg in "stats") {
[10:29:53.741]                         base::loadNamespace(pkg)
[10:29:53.741]                         base::library(pkg, character.only = TRUE)
[10:29:53.741]                       }
[10:29:53.741]                     })
[10:29:53.741]                   }
[10:29:53.741]                   ...future.strategy.old <- future::plan("list")
[10:29:53.741]                   options(future.plan = NULL)
[10:29:53.741]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.741]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:53.741]                 }
[10:29:53.741]                 ...future.workdir <- getwd()
[10:29:53.741]             }
[10:29:53.741]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:53.741]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:53.741]         }
[10:29:53.741]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:53.741]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:53.741]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:53.741]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:53.741]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:53.741]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:53.741]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:53.741]             base::names(...future.oldOptions))
[10:29:53.741]     }
[10:29:53.741]     if (FALSE) {
[10:29:53.741]     }
[10:29:53.741]     else {
[10:29:53.741]         if (TRUE) {
[10:29:53.741]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:53.741]                 open = "w")
[10:29:53.741]         }
[10:29:53.741]         else {
[10:29:53.741]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:53.741]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:53.741]         }
[10:29:53.741]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:53.741]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:53.741]             base::sink(type = "output", split = FALSE)
[10:29:53.741]             base::close(...future.stdout)
[10:29:53.741]         }, add = TRUE)
[10:29:53.741]     }
[10:29:53.741]     ...future.frame <- base::sys.nframe()
[10:29:53.741]     ...future.conditions <- base::list()
[10:29:53.741]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:53.741]     if (FALSE) {
[10:29:53.741]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:53.741]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:53.741]     }
[10:29:53.741]     ...future.result <- base::tryCatch({
[10:29:53.741]         base::withCallingHandlers({
[10:29:53.741]             ...future.value <- base::withVisible(base::local({
[10:29:53.741]                 do.call(function(...) {
[10:29:53.741]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.741]                   if (!identical(...future.globals.maxSize.org, 
[10:29:53.741]                     ...future.globals.maxSize)) {
[10:29:53.741]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.741]                     on.exit(options(oopts), add = TRUE)
[10:29:53.741]                   }
[10:29:53.741]                   {
[10:29:53.741]                     lapply(seq_along(...future.elements_ii), 
[10:29:53.741]                       FUN = function(jj) {
[10:29:53.741]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.741]                         ...future.FUN(...future.X_jj, ...)
[10:29:53.741]                       })
[10:29:53.741]                   }
[10:29:53.741]                 }, args = future.call.arguments)
[10:29:53.741]             }))
[10:29:53.741]             future::FutureResult(value = ...future.value$value, 
[10:29:53.741]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.741]                   ...future.rng), globalenv = if (FALSE) 
[10:29:53.741]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:53.741]                     ...future.globalenv.names))
[10:29:53.741]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:53.741]         }, condition = base::local({
[10:29:53.741]             c <- base::c
[10:29:53.741]             inherits <- base::inherits
[10:29:53.741]             invokeRestart <- base::invokeRestart
[10:29:53.741]             length <- base::length
[10:29:53.741]             list <- base::list
[10:29:53.741]             seq.int <- base::seq.int
[10:29:53.741]             signalCondition <- base::signalCondition
[10:29:53.741]             sys.calls <- base::sys.calls
[10:29:53.741]             `[[` <- base::`[[`
[10:29:53.741]             `+` <- base::`+`
[10:29:53.741]             `<<-` <- base::`<<-`
[10:29:53.741]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:53.741]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:53.741]                   3L)]
[10:29:53.741]             }
[10:29:53.741]             function(cond) {
[10:29:53.741]                 is_error <- inherits(cond, "error")
[10:29:53.741]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:53.741]                   NULL)
[10:29:53.741]                 if (is_error) {
[10:29:53.741]                   sessionInformation <- function() {
[10:29:53.741]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:53.741]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:53.741]                       search = base::search(), system = base::Sys.info())
[10:29:53.741]                   }
[10:29:53.741]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.741]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:53.741]                     cond$call), session = sessionInformation(), 
[10:29:53.741]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:53.741]                   signalCondition(cond)
[10:29:53.741]                 }
[10:29:53.741]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:53.741]                 "immediateCondition"))) {
[10:29:53.741]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:53.741]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.741]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:53.741]                   if (TRUE && !signal) {
[10:29:53.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.741]                     {
[10:29:53.741]                       inherits <- base::inherits
[10:29:53.741]                       invokeRestart <- base::invokeRestart
[10:29:53.741]                       is.null <- base::is.null
[10:29:53.741]                       muffled <- FALSE
[10:29:53.741]                       if (inherits(cond, "message")) {
[10:29:53.741]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.741]                         if (muffled) 
[10:29:53.741]                           invokeRestart("muffleMessage")
[10:29:53.741]                       }
[10:29:53.741]                       else if (inherits(cond, "warning")) {
[10:29:53.741]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.741]                         if (muffled) 
[10:29:53.741]                           invokeRestart("muffleWarning")
[10:29:53.741]                       }
[10:29:53.741]                       else if (inherits(cond, "condition")) {
[10:29:53.741]                         if (!is.null(pattern)) {
[10:29:53.741]                           computeRestarts <- base::computeRestarts
[10:29:53.741]                           grepl <- base::grepl
[10:29:53.741]                           restarts <- computeRestarts(cond)
[10:29:53.741]                           for (restart in restarts) {
[10:29:53.741]                             name <- restart$name
[10:29:53.741]                             if (is.null(name)) 
[10:29:53.741]                               next
[10:29:53.741]                             if (!grepl(pattern, name)) 
[10:29:53.741]                               next
[10:29:53.741]                             invokeRestart(restart)
[10:29:53.741]                             muffled <- TRUE
[10:29:53.741]                             break
[10:29:53.741]                           }
[10:29:53.741]                         }
[10:29:53.741]                       }
[10:29:53.741]                       invisible(muffled)
[10:29:53.741]                     }
[10:29:53.741]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.741]                   }
[10:29:53.741]                 }
[10:29:53.741]                 else {
[10:29:53.741]                   if (TRUE) {
[10:29:53.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.741]                     {
[10:29:53.741]                       inherits <- base::inherits
[10:29:53.741]                       invokeRestart <- base::invokeRestart
[10:29:53.741]                       is.null <- base::is.null
[10:29:53.741]                       muffled <- FALSE
[10:29:53.741]                       if (inherits(cond, "message")) {
[10:29:53.741]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.741]                         if (muffled) 
[10:29:53.741]                           invokeRestart("muffleMessage")
[10:29:53.741]                       }
[10:29:53.741]                       else if (inherits(cond, "warning")) {
[10:29:53.741]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.741]                         if (muffled) 
[10:29:53.741]                           invokeRestart("muffleWarning")
[10:29:53.741]                       }
[10:29:53.741]                       else if (inherits(cond, "condition")) {
[10:29:53.741]                         if (!is.null(pattern)) {
[10:29:53.741]                           computeRestarts <- base::computeRestarts
[10:29:53.741]                           grepl <- base::grepl
[10:29:53.741]                           restarts <- computeRestarts(cond)
[10:29:53.741]                           for (restart in restarts) {
[10:29:53.741]                             name <- restart$name
[10:29:53.741]                             if (is.null(name)) 
[10:29:53.741]                               next
[10:29:53.741]                             if (!grepl(pattern, name)) 
[10:29:53.741]                               next
[10:29:53.741]                             invokeRestart(restart)
[10:29:53.741]                             muffled <- TRUE
[10:29:53.741]                             break
[10:29:53.741]                           }
[10:29:53.741]                         }
[10:29:53.741]                       }
[10:29:53.741]                       invisible(muffled)
[10:29:53.741]                     }
[10:29:53.741]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.741]                   }
[10:29:53.741]                 }
[10:29:53.741]             }
[10:29:53.741]         }))
[10:29:53.741]     }, error = function(ex) {
[10:29:53.741]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:53.741]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.741]                 ...future.rng), started = ...future.startTime, 
[10:29:53.741]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:53.741]             version = "1.8"), class = "FutureResult")
[10:29:53.741]     }, finally = {
[10:29:53.741]         if (!identical(...future.workdir, getwd())) 
[10:29:53.741]             setwd(...future.workdir)
[10:29:53.741]         {
[10:29:53.741]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:53.741]                 ...future.oldOptions$nwarnings <- NULL
[10:29:53.741]             }
[10:29:53.741]             base::options(...future.oldOptions)
[10:29:53.741]             if (.Platform$OS.type == "windows") {
[10:29:53.741]                 old_names <- names(...future.oldEnvVars)
[10:29:53.741]                 envs <- base::Sys.getenv()
[10:29:53.741]                 names <- names(envs)
[10:29:53.741]                 common <- intersect(names, old_names)
[10:29:53.741]                 added <- setdiff(names, old_names)
[10:29:53.741]                 removed <- setdiff(old_names, names)
[10:29:53.741]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:53.741]                   envs[common]]
[10:29:53.741]                 NAMES <- toupper(changed)
[10:29:53.741]                 args <- list()
[10:29:53.741]                 for (kk in seq_along(NAMES)) {
[10:29:53.741]                   name <- changed[[kk]]
[10:29:53.741]                   NAME <- NAMES[[kk]]
[10:29:53.741]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.741]                     next
[10:29:53.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.741]                 }
[10:29:53.741]                 NAMES <- toupper(added)
[10:29:53.741]                 for (kk in seq_along(NAMES)) {
[10:29:53.741]                   name <- added[[kk]]
[10:29:53.741]                   NAME <- NAMES[[kk]]
[10:29:53.741]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.741]                     next
[10:29:53.741]                   args[[name]] <- ""
[10:29:53.741]                 }
[10:29:53.741]                 NAMES <- toupper(removed)
[10:29:53.741]                 for (kk in seq_along(NAMES)) {
[10:29:53.741]                   name <- removed[[kk]]
[10:29:53.741]                   NAME <- NAMES[[kk]]
[10:29:53.741]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.741]                     next
[10:29:53.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.741]                 }
[10:29:53.741]                 if (length(args) > 0) 
[10:29:53.741]                   base::do.call(base::Sys.setenv, args = args)
[10:29:53.741]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:53.741]             }
[10:29:53.741]             else {
[10:29:53.741]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:53.741]             }
[10:29:53.741]             {
[10:29:53.741]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:53.741]                   0L) {
[10:29:53.741]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:53.741]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:53.741]                   base::options(opts)
[10:29:53.741]                 }
[10:29:53.741]                 {
[10:29:53.741]                   {
[10:29:53.741]                     NULL
[10:29:53.741]                     RNGkind("Mersenne-Twister")
[10:29:53.741]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:53.741]                       inherits = FALSE)
[10:29:53.741]                   }
[10:29:53.741]                   options(future.plan = NULL)
[10:29:53.741]                   if (is.na(NA_character_)) 
[10:29:53.741]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.741]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:53.741]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:53.741]                     .init = FALSE)
[10:29:53.741]                 }
[10:29:53.741]             }
[10:29:53.741]         }
[10:29:53.741]     })
[10:29:53.741]     if (TRUE) {
[10:29:53.741]         base::sink(type = "output", split = FALSE)
[10:29:53.741]         if (TRUE) {
[10:29:53.741]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:53.741]         }
[10:29:53.741]         else {
[10:29:53.741]             ...future.result["stdout"] <- base::list(NULL)
[10:29:53.741]         }
[10:29:53.741]         base::close(...future.stdout)
[10:29:53.741]         ...future.stdout <- NULL
[10:29:53.741]     }
[10:29:53.741]     ...future.result$conditions <- ...future.conditions
[10:29:53.741]     ...future.result$finished <- base::Sys.time()
[10:29:53.741]     ...future.result
[10:29:53.741] }
[10:29:53.743] assign_globals() ...
[10:29:53.743] List of 5
[10:29:53.743]  $ ...future.FUN            :function (x, ...)  
[10:29:53.743]  $ future.call.arguments    :List of 1
[10:29:53.743]   ..$ singular.ok: logi FALSE
[10:29:53.743]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.743]  $ ...future.elements_ii    :List of 3
[10:29:53.743]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.743]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:29:53.743]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.743]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:53.743]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.743]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:29:53.743]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.743]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:29:53.743]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.743]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:29:53.743]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.743]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:29:53.743]  $ ...future.seeds_ii       : NULL
[10:29:53.743]  $ ...future.globals.maxSize: NULL
[10:29:53.743]  - attr(*, "where")=List of 5
[10:29:53.743]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:53.743]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:53.743]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:53.743]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:53.743]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:53.743]  - attr(*, "resolved")= logi FALSE
[10:29:53.743]  - attr(*, "total_size")= num 5384
[10:29:53.743]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.743]  - attr(*, "already-done")= logi TRUE
[10:29:53.754] - reassign environment for ‘...future.FUN’
[10:29:53.754] - copied ‘...future.FUN’ to environment
[10:29:53.755] - copied ‘future.call.arguments’ to environment
[10:29:53.755] - copied ‘...future.elements_ii’ to environment
[10:29:53.755] - copied ‘...future.seeds_ii’ to environment
[10:29:53.755] - copied ‘...future.globals.maxSize’ to environment
[10:29:53.755] assign_globals() ... done
[10:29:53.756] plan(): Setting new future strategy stack:
[10:29:53.756] List of future strategies:
[10:29:53.756] 1. sequential:
[10:29:53.756]    - args: function (..., envir = parent.frame())
[10:29:53.756]    - tweaked: FALSE
[10:29:53.756]    - call: NULL
[10:29:53.756] plan(): nbrOfWorkers() = 1
[10:29:53.759] plan(): Setting new future strategy stack:
[10:29:53.759] List of future strategies:
[10:29:53.759] 1. multisession:
[10:29:53.759]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:29:53.759]    - tweaked: FALSE
[10:29:53.759]    - call: plan(strategy)
[10:29:53.763] plan(): nbrOfWorkers() = 1
[10:29:53.763] SequentialFuture started (and completed)
[10:29:53.763] - Launch lazy future ... done
[10:29:53.764] run() for ‘SequentialFuture’ ... done
[10:29:53.764] Created future:
[10:29:53.764] SequentialFuture:
[10:29:53.764] Label: ‘future_by-1’
[10:29:53.764] Expression:
[10:29:53.764] {
[10:29:53.764]     do.call(function(...) {
[10:29:53.764]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.764]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.764]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.764]             on.exit(options(oopts), add = TRUE)
[10:29:53.764]         }
[10:29:53.764]         {
[10:29:53.764]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.764]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.764]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.764]             })
[10:29:53.764]         }
[10:29:53.764]     }, args = future.call.arguments)
[10:29:53.764] }
[10:29:53.764] Lazy evaluation: FALSE
[10:29:53.764] Asynchronous evaluation: FALSE
[10:29:53.764] Local evaluation: TRUE
[10:29:53.764] Environment: R_GlobalEnv
[10:29:53.764] Capture standard output: TRUE
[10:29:53.764] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:53.764] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:53.764] Packages: 1 packages (‘stats’)
[10:29:53.764] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:53.764] Resolved: TRUE
[10:29:53.764] Value: 26.06 KiB of class ‘list’
[10:29:53.764] Early signaling: FALSE
[10:29:53.764] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:53.764] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.765] Chunk #1 of 1 ... DONE
[10:29:53.765] Launching 1 futures (chunks) ... DONE
[10:29:53.766] Resolving 1 futures (chunks) ...
[10:29:53.766] resolve() on list ...
[10:29:53.766]  recursive: 0
[10:29:53.766]  length: 1
[10:29:53.766] 
[10:29:53.766] resolved() for ‘SequentialFuture’ ...
[10:29:53.766] - state: ‘finished’
[10:29:53.766] - run: TRUE
[10:29:53.766] - result: ‘FutureResult’
[10:29:53.766] resolved() for ‘SequentialFuture’ ... done
[10:29:53.767] Future #1
[10:29:53.767] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:53.767] - nx: 1
[10:29:53.767] - relay: TRUE
[10:29:53.767] - stdout: TRUE
[10:29:53.767] - signal: TRUE
[10:29:53.767] - resignal: FALSE
[10:29:53.767] - force: TRUE
[10:29:53.767] - relayed: [n=1] FALSE
[10:29:53.767] - queued futures: [n=1] FALSE
[10:29:53.767]  - until=1
[10:29:53.768]  - relaying element #1
[10:29:53.768] - relayed: [n=1] TRUE
[10:29:53.768] - queued futures: [n=1] TRUE
[10:29:53.768] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:53.768]  length: 0 (resolved future 1)
[10:29:53.768] Relaying remaining futures
[10:29:53.768] signalConditionsASAP(NULL, pos=0) ...
[10:29:53.768] - nx: 1
[10:29:53.768] - relay: TRUE
[10:29:53.768] - stdout: TRUE
[10:29:53.769] - signal: TRUE
[10:29:53.769] - resignal: FALSE
[10:29:53.769] - force: TRUE
[10:29:53.769] - relayed: [n=1] TRUE
[10:29:53.769] - queued futures: [n=1] TRUE
 - flush all
[10:29:53.769] - relayed: [n=1] TRUE
[10:29:53.769] - queued futures: [n=1] TRUE
[10:29:53.769] signalConditionsASAP(NULL, pos=0) ... done
[10:29:53.769] resolve() on list ... DONE
[10:29:53.770]  - Number of value chunks collected: 1
[10:29:53.770] Resolving 1 futures (chunks) ... DONE
[10:29:53.770] Reducing values from 1 chunks ...
[10:29:53.770]  - Number of values collected after concatenation: 3
[10:29:53.770]  - Number of values expected: 3
[10:29:53.770] Reducing values from 1 chunks ... DONE
[10:29:53.770] future_lapply() ... DONE
[10:29:53.770] future_by_internal() ... DONE
[10:29:53.776] future_by_internal() ...
[10:29:53.776] future_lapply() ...
[10:29:53.781] Number of chunks: 1
[10:29:53.781] getGlobalsAndPackagesXApply() ...
[10:29:53.781]  - future.globals: TRUE
[10:29:53.781] getGlobalsAndPackages() ...
[10:29:53.781] Searching for globals...
[10:29:53.783] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:29:53.783] Searching for globals ... DONE
[10:29:53.783] Resolving globals: FALSE
[10:29:53.784] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[10:29:53.784] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[10:29:53.784] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[10:29:53.784] - packages: [1] ‘stats’
[10:29:53.784] getGlobalsAndPackages() ... DONE
[10:29:53.785]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[10:29:53.785]  - needed namespaces: [n=1] ‘stats’
[10:29:53.785] Finding globals ... DONE
[10:29:53.785]  - use_args: TRUE
[10:29:53.785]  - Getting '...' globals ...
[10:29:53.785] resolve() on list ...
[10:29:53.785]  recursive: 0
[10:29:53.785]  length: 1
[10:29:53.786]  elements: ‘...’
[10:29:53.786]  length: 0 (resolved future 1)
[10:29:53.786] resolve() on list ... DONE
[10:29:53.786]    - '...' content: [n=0] 
[10:29:53.786] List of 1
[10:29:53.786]  $ ...: list()
[10:29:53.786]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.786]  - attr(*, "where")=List of 1
[10:29:53.786]   ..$ ...:<environment: 0x556dd3c3c038> 
[10:29:53.786]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.786]  - attr(*, "resolved")= logi TRUE
[10:29:53.786]  - attr(*, "total_size")= num NA
[10:29:53.789]  - Getting '...' globals ... DONE
[10:29:53.789] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[10:29:53.789] List of 4
[10:29:53.789]  $ ...future.FUN:function (x)  
[10:29:53.789]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:29:53.789]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:53.789]  $ ...          : list()
[10:29:53.789]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.789]  - attr(*, "where")=List of 4
[10:29:53.789]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:53.789]   ..$ breaks       :<environment: R_EmptyEnv> 
[10:29:53.789]   ..$ wool         :<environment: R_EmptyEnv> 
[10:29:53.789]   ..$ ...          :<environment: 0x556dd3c3c038> 
[10:29:53.789]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.789]  - attr(*, "resolved")= logi FALSE
[10:29:53.789]  - attr(*, "total_size")= num 2320
[10:29:53.793] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:53.793] getGlobalsAndPackagesXApply() ... DONE
[10:29:53.793] Number of futures (= number of chunks): 1
[10:29:53.793] Launching 1 futures (chunks) ...
[10:29:53.793] Chunk #1 of 1 ...
[10:29:53.794]  - Finding globals in 'X' for chunk #1 ...
[10:29:53.794] getGlobalsAndPackages() ...
[10:29:53.794] Searching for globals...
[10:29:53.794] 
[10:29:53.794] Searching for globals ... DONE
[10:29:53.794] - globals: [0] <none>
[10:29:53.795] getGlobalsAndPackages() ... DONE
[10:29:53.795]    + additional globals found: [n=0] 
[10:29:53.795]    + additional namespaces needed: [n=0] 
[10:29:53.795]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:53.795]  - seeds: <none>
[10:29:53.795]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.795] getGlobalsAndPackages() ...
[10:29:53.795] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.795] Resolving globals: FALSE
[10:29:53.795] Tweak future expression to call with '...' arguments ...
[10:29:53.796] {
[10:29:53.796]     do.call(function(...) {
[10:29:53.796]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.796]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.796]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.796]             on.exit(options(oopts), add = TRUE)
[10:29:53.796]         }
[10:29:53.796]         {
[10:29:53.796]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.796]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.796]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.796]             })
[10:29:53.796]         }
[10:29:53.796]     }, args = future.call.arguments)
[10:29:53.796] }
[10:29:53.796] Tweak future expression to call with '...' arguments ... DONE
[10:29:53.796] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.796] 
[10:29:53.796] getGlobalsAndPackages() ... DONE
[10:29:53.797] run() for ‘Future’ ...
[10:29:53.797] - state: ‘created’
[10:29:53.797] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:53.802] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.802] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:53.803]   - Field: ‘label’
[10:29:53.803]   - Field: ‘local’
[10:29:53.803]   - Field: ‘owner’
[10:29:53.803]   - Field: ‘envir’
[10:29:53.803]   - Field: ‘packages’
[10:29:53.803]   - Field: ‘gc’
[10:29:53.803]   - Field: ‘conditions’
[10:29:53.803]   - Field: ‘expr’
[10:29:53.803]   - Field: ‘uuid’
[10:29:53.804]   - Field: ‘seed’
[10:29:53.804]   - Field: ‘version’
[10:29:53.804]   - Field: ‘result’
[10:29:53.804]   - Field: ‘asynchronous’
[10:29:53.804]   - Field: ‘calls’
[10:29:53.804]   - Field: ‘globals’
[10:29:53.804]   - Field: ‘stdout’
[10:29:53.804]   - Field: ‘earlySignal’
[10:29:53.804]   - Field: ‘lazy’
[10:29:53.804]   - Field: ‘state’
[10:29:53.805] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:53.805] - Launch lazy future ...
[10:29:53.805] Packages needed by the future expression (n = 1): ‘stats’
[10:29:53.805] Packages needed by future strategies (n = 0): <none>
[10:29:53.806] {
[10:29:53.806]     {
[10:29:53.806]         {
[10:29:53.806]             ...future.startTime <- base::Sys.time()
[10:29:53.806]             {
[10:29:53.806]                 {
[10:29:53.806]                   {
[10:29:53.806]                     {
[10:29:53.806]                       base::local({
[10:29:53.806]                         has_future <- base::requireNamespace("future", 
[10:29:53.806]                           quietly = TRUE)
[10:29:53.806]                         if (has_future) {
[10:29:53.806]                           ns <- base::getNamespace("future")
[10:29:53.806]                           version <- ns[[".package"]][["version"]]
[10:29:53.806]                           if (is.null(version)) 
[10:29:53.806]                             version <- utils::packageVersion("future")
[10:29:53.806]                         }
[10:29:53.806]                         else {
[10:29:53.806]                           version <- NULL
[10:29:53.806]                         }
[10:29:53.806]                         if (!has_future || version < "1.8.0") {
[10:29:53.806]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:53.806]                             "", base::R.version$version.string), 
[10:29:53.806]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:53.806]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:53.806]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:53.806]                               "release", "version")], collapse = " "), 
[10:29:53.806]                             hostname = base::Sys.info()[["nodename"]])
[10:29:53.806]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:53.806]                             info)
[10:29:53.806]                           info <- base::paste(info, collapse = "; ")
[10:29:53.806]                           if (!has_future) {
[10:29:53.806]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:53.806]                               info)
[10:29:53.806]                           }
[10:29:53.806]                           else {
[10:29:53.806]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:53.806]                               info, version)
[10:29:53.806]                           }
[10:29:53.806]                           base::stop(msg)
[10:29:53.806]                         }
[10:29:53.806]                       })
[10:29:53.806]                     }
[10:29:53.806]                     base::local({
[10:29:53.806]                       for (pkg in "stats") {
[10:29:53.806]                         base::loadNamespace(pkg)
[10:29:53.806]                         base::library(pkg, character.only = TRUE)
[10:29:53.806]                       }
[10:29:53.806]                     })
[10:29:53.806]                   }
[10:29:53.806]                   ...future.strategy.old <- future::plan("list")
[10:29:53.806]                   options(future.plan = NULL)
[10:29:53.806]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.806]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:53.806]                 }
[10:29:53.806]                 ...future.workdir <- getwd()
[10:29:53.806]             }
[10:29:53.806]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:53.806]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:53.806]         }
[10:29:53.806]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:53.806]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:53.806]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:53.806]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:53.806]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:53.806]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:53.806]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:53.806]             base::names(...future.oldOptions))
[10:29:53.806]     }
[10:29:53.806]     if (FALSE) {
[10:29:53.806]     }
[10:29:53.806]     else {
[10:29:53.806]         if (TRUE) {
[10:29:53.806]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:53.806]                 open = "w")
[10:29:53.806]         }
[10:29:53.806]         else {
[10:29:53.806]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:53.806]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:53.806]         }
[10:29:53.806]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:53.806]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:53.806]             base::sink(type = "output", split = FALSE)
[10:29:53.806]             base::close(...future.stdout)
[10:29:53.806]         }, add = TRUE)
[10:29:53.806]     }
[10:29:53.806]     ...future.frame <- base::sys.nframe()
[10:29:53.806]     ...future.conditions <- base::list()
[10:29:53.806]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:53.806]     if (FALSE) {
[10:29:53.806]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:53.806]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:53.806]     }
[10:29:53.806]     ...future.result <- base::tryCatch({
[10:29:53.806]         base::withCallingHandlers({
[10:29:53.806]             ...future.value <- base::withVisible(base::local({
[10:29:53.806]                 do.call(function(...) {
[10:29:53.806]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.806]                   if (!identical(...future.globals.maxSize.org, 
[10:29:53.806]                     ...future.globals.maxSize)) {
[10:29:53.806]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.806]                     on.exit(options(oopts), add = TRUE)
[10:29:53.806]                   }
[10:29:53.806]                   {
[10:29:53.806]                     lapply(seq_along(...future.elements_ii), 
[10:29:53.806]                       FUN = function(jj) {
[10:29:53.806]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.806]                         ...future.FUN(...future.X_jj, ...)
[10:29:53.806]                       })
[10:29:53.806]                   }
[10:29:53.806]                 }, args = future.call.arguments)
[10:29:53.806]             }))
[10:29:53.806]             future::FutureResult(value = ...future.value$value, 
[10:29:53.806]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.806]                   ...future.rng), globalenv = if (FALSE) 
[10:29:53.806]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:53.806]                     ...future.globalenv.names))
[10:29:53.806]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:53.806]         }, condition = base::local({
[10:29:53.806]             c <- base::c
[10:29:53.806]             inherits <- base::inherits
[10:29:53.806]             invokeRestart <- base::invokeRestart
[10:29:53.806]             length <- base::length
[10:29:53.806]             list <- base::list
[10:29:53.806]             seq.int <- base::seq.int
[10:29:53.806]             signalCondition <- base::signalCondition
[10:29:53.806]             sys.calls <- base::sys.calls
[10:29:53.806]             `[[` <- base::`[[`
[10:29:53.806]             `+` <- base::`+`
[10:29:53.806]             `<<-` <- base::`<<-`
[10:29:53.806]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:53.806]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:53.806]                   3L)]
[10:29:53.806]             }
[10:29:53.806]             function(cond) {
[10:29:53.806]                 is_error <- inherits(cond, "error")
[10:29:53.806]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:53.806]                   NULL)
[10:29:53.806]                 if (is_error) {
[10:29:53.806]                   sessionInformation <- function() {
[10:29:53.806]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:53.806]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:53.806]                       search = base::search(), system = base::Sys.info())
[10:29:53.806]                   }
[10:29:53.806]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.806]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:53.806]                     cond$call), session = sessionInformation(), 
[10:29:53.806]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:53.806]                   signalCondition(cond)
[10:29:53.806]                 }
[10:29:53.806]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:53.806]                 "immediateCondition"))) {
[10:29:53.806]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:53.806]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.806]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:53.806]                   if (TRUE && !signal) {
[10:29:53.806]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.806]                     {
[10:29:53.806]                       inherits <- base::inherits
[10:29:53.806]                       invokeRestart <- base::invokeRestart
[10:29:53.806]                       is.null <- base::is.null
[10:29:53.806]                       muffled <- FALSE
[10:29:53.806]                       if (inherits(cond, "message")) {
[10:29:53.806]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.806]                         if (muffled) 
[10:29:53.806]                           invokeRestart("muffleMessage")
[10:29:53.806]                       }
[10:29:53.806]                       else if (inherits(cond, "warning")) {
[10:29:53.806]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.806]                         if (muffled) 
[10:29:53.806]                           invokeRestart("muffleWarning")
[10:29:53.806]                       }
[10:29:53.806]                       else if (inherits(cond, "condition")) {
[10:29:53.806]                         if (!is.null(pattern)) {
[10:29:53.806]                           computeRestarts <- base::computeRestarts
[10:29:53.806]                           grepl <- base::grepl
[10:29:53.806]                           restarts <- computeRestarts(cond)
[10:29:53.806]                           for (restart in restarts) {
[10:29:53.806]                             name <- restart$name
[10:29:53.806]                             if (is.null(name)) 
[10:29:53.806]                               next
[10:29:53.806]                             if (!grepl(pattern, name)) 
[10:29:53.806]                               next
[10:29:53.806]                             invokeRestart(restart)
[10:29:53.806]                             muffled <- TRUE
[10:29:53.806]                             break
[10:29:53.806]                           }
[10:29:53.806]                         }
[10:29:53.806]                       }
[10:29:53.806]                       invisible(muffled)
[10:29:53.806]                     }
[10:29:53.806]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.806]                   }
[10:29:53.806]                 }
[10:29:53.806]                 else {
[10:29:53.806]                   if (TRUE) {
[10:29:53.806]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.806]                     {
[10:29:53.806]                       inherits <- base::inherits
[10:29:53.806]                       invokeRestart <- base::invokeRestart
[10:29:53.806]                       is.null <- base::is.null
[10:29:53.806]                       muffled <- FALSE
[10:29:53.806]                       if (inherits(cond, "message")) {
[10:29:53.806]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.806]                         if (muffled) 
[10:29:53.806]                           invokeRestart("muffleMessage")
[10:29:53.806]                       }
[10:29:53.806]                       else if (inherits(cond, "warning")) {
[10:29:53.806]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.806]                         if (muffled) 
[10:29:53.806]                           invokeRestart("muffleWarning")
[10:29:53.806]                       }
[10:29:53.806]                       else if (inherits(cond, "condition")) {
[10:29:53.806]                         if (!is.null(pattern)) {
[10:29:53.806]                           computeRestarts <- base::computeRestarts
[10:29:53.806]                           grepl <- base::grepl
[10:29:53.806]                           restarts <- computeRestarts(cond)
[10:29:53.806]                           for (restart in restarts) {
[10:29:53.806]                             name <- restart$name
[10:29:53.806]                             if (is.null(name)) 
[10:29:53.806]                               next
[10:29:53.806]                             if (!grepl(pattern, name)) 
[10:29:53.806]                               next
[10:29:53.806]                             invokeRestart(restart)
[10:29:53.806]                             muffled <- TRUE
[10:29:53.806]                             break
[10:29:53.806]                           }
[10:29:53.806]                         }
[10:29:53.806]                       }
[10:29:53.806]                       invisible(muffled)
[10:29:53.806]                     }
[10:29:53.806]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.806]                   }
[10:29:53.806]                 }
[10:29:53.806]             }
[10:29:53.806]         }))
[10:29:53.806]     }, error = function(ex) {
[10:29:53.806]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:53.806]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.806]                 ...future.rng), started = ...future.startTime, 
[10:29:53.806]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:53.806]             version = "1.8"), class = "FutureResult")
[10:29:53.806]     }, finally = {
[10:29:53.806]         if (!identical(...future.workdir, getwd())) 
[10:29:53.806]             setwd(...future.workdir)
[10:29:53.806]         {
[10:29:53.806]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:53.806]                 ...future.oldOptions$nwarnings <- NULL
[10:29:53.806]             }
[10:29:53.806]             base::options(...future.oldOptions)
[10:29:53.806]             if (.Platform$OS.type == "windows") {
[10:29:53.806]                 old_names <- names(...future.oldEnvVars)
[10:29:53.806]                 envs <- base::Sys.getenv()
[10:29:53.806]                 names <- names(envs)
[10:29:53.806]                 common <- intersect(names, old_names)
[10:29:53.806]                 added <- setdiff(names, old_names)
[10:29:53.806]                 removed <- setdiff(old_names, names)
[10:29:53.806]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:53.806]                   envs[common]]
[10:29:53.806]                 NAMES <- toupper(changed)
[10:29:53.806]                 args <- list()
[10:29:53.806]                 for (kk in seq_along(NAMES)) {
[10:29:53.806]                   name <- changed[[kk]]
[10:29:53.806]                   NAME <- NAMES[[kk]]
[10:29:53.806]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.806]                     next
[10:29:53.806]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.806]                 }
[10:29:53.806]                 NAMES <- toupper(added)
[10:29:53.806]                 for (kk in seq_along(NAMES)) {
[10:29:53.806]                   name <- added[[kk]]
[10:29:53.806]                   NAME <- NAMES[[kk]]
[10:29:53.806]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.806]                     next
[10:29:53.806]                   args[[name]] <- ""
[10:29:53.806]                 }
[10:29:53.806]                 NAMES <- toupper(removed)
[10:29:53.806]                 for (kk in seq_along(NAMES)) {
[10:29:53.806]                   name <- removed[[kk]]
[10:29:53.806]                   NAME <- NAMES[[kk]]
[10:29:53.806]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.806]                     next
[10:29:53.806]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.806]                 }
[10:29:53.806]                 if (length(args) > 0) 
[10:29:53.806]                   base::do.call(base::Sys.setenv, args = args)
[10:29:53.806]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:53.806]             }
[10:29:53.806]             else {
[10:29:53.806]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:53.806]             }
[10:29:53.806]             {
[10:29:53.806]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:53.806]                   0L) {
[10:29:53.806]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:53.806]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:53.806]                   base::options(opts)
[10:29:53.806]                 }
[10:29:53.806]                 {
[10:29:53.806]                   {
[10:29:53.806]                     NULL
[10:29:53.806]                     RNGkind("Mersenne-Twister")
[10:29:53.806]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:53.806]                       inherits = FALSE)
[10:29:53.806]                   }
[10:29:53.806]                   options(future.plan = NULL)
[10:29:53.806]                   if (is.na(NA_character_)) 
[10:29:53.806]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.806]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:53.806]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:53.806]                     .init = FALSE)
[10:29:53.806]                 }
[10:29:53.806]             }
[10:29:53.806]         }
[10:29:53.806]     })
[10:29:53.806]     if (TRUE) {
[10:29:53.806]         base::sink(type = "output", split = FALSE)
[10:29:53.806]         if (TRUE) {
[10:29:53.806]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:53.806]         }
[10:29:53.806]         else {
[10:29:53.806]             ...future.result["stdout"] <- base::list(NULL)
[10:29:53.806]         }
[10:29:53.806]         base::close(...future.stdout)
[10:29:53.806]         ...future.stdout <- NULL
[10:29:53.806]     }
[10:29:53.806]     ...future.result$conditions <- ...future.conditions
[10:29:53.806]     ...future.result$finished <- base::Sys.time()
[10:29:53.806]     ...future.result
[10:29:53.806] }
[10:29:53.807] assign_globals() ...
[10:29:53.807] List of 7
[10:29:53.807]  $ ...future.FUN            :function (x)  
[10:29:53.807]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:29:53.807]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:53.807]  $ future.call.arguments    : list()
[10:29:53.807]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.807]  $ ...future.elements_ii    :List of 3
[10:29:53.807]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.807]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:29:53.807]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.807]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:53.807]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.807]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:29:53.807]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.807]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:29:53.807]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.807]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:29:53.807]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.807]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:29:53.807]  $ ...future.seeds_ii       : NULL
[10:29:53.807]  $ ...future.globals.maxSize: NULL
[10:29:53.807]  - attr(*, "where")=List of 7
[10:29:53.807]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:53.807]   ..$ breaks                   :<environment: R_EmptyEnv> 
[10:29:53.807]   ..$ wool                     :<environment: R_EmptyEnv> 
[10:29:53.807]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:53.807]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:53.807]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:53.807]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:53.807]  - attr(*, "resolved")= logi FALSE
[10:29:53.807]  - attr(*, "total_size")= num 2320
[10:29:53.807]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.807]  - attr(*, "already-done")= logi TRUE
[10:29:53.817] - reassign environment for ‘...future.FUN’
[10:29:53.817] - copied ‘...future.FUN’ to environment
[10:29:53.818] - copied ‘breaks’ to environment
[10:29:53.818] - copied ‘wool’ to environment
[10:29:53.818] - copied ‘future.call.arguments’ to environment
[10:29:53.818] - copied ‘...future.elements_ii’ to environment
[10:29:53.818] - copied ‘...future.seeds_ii’ to environment
[10:29:53.818] - copied ‘...future.globals.maxSize’ to environment
[10:29:53.818] assign_globals() ... done
[10:29:53.819] plan(): Setting new future strategy stack:
[10:29:53.819] List of future strategies:
[10:29:53.819] 1. sequential:
[10:29:53.819]    - args: function (..., envir = parent.frame())
[10:29:53.819]    - tweaked: FALSE
[10:29:53.819]    - call: NULL
[10:29:53.819] plan(): nbrOfWorkers() = 1
[10:29:53.824] plan(): Setting new future strategy stack:
[10:29:53.824] List of future strategies:
[10:29:53.824] 1. multisession:
[10:29:53.824]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:29:53.824]    - tweaked: FALSE
[10:29:53.824]    - call: plan(strategy)
[10:29:53.828] plan(): nbrOfWorkers() = 1
[10:29:53.828] SequentialFuture started (and completed)
[10:29:53.828] - Launch lazy future ... done
[10:29:53.828] run() for ‘SequentialFuture’ ... done
[10:29:53.828] Created future:
[10:29:53.828] SequentialFuture:
[10:29:53.828] Label: ‘future_by-1’
[10:29:53.828] Expression:
[10:29:53.828] {
[10:29:53.828]     do.call(function(...) {
[10:29:53.828]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.828]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.828]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.828]             on.exit(options(oopts), add = TRUE)
[10:29:53.828]         }
[10:29:53.828]         {
[10:29:53.828]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.828]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.828]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.828]             })
[10:29:53.828]         }
[10:29:53.828]     }, args = future.call.arguments)
[10:29:53.828] }
[10:29:53.828] Lazy evaluation: FALSE
[10:29:53.828] Asynchronous evaluation: FALSE
[10:29:53.828] Local evaluation: TRUE
[10:29:53.828] Environment: 0x556dd543aa38
[10:29:53.828] Capture standard output: TRUE
[10:29:53.828] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:53.828] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[10:29:53.828] Packages: 1 packages (‘stats’)
[10:29:53.828] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:53.828] Resolved: TRUE
[10:29:53.828] Value: 25.57 KiB of class ‘list’
[10:29:53.828] Early signaling: FALSE
[10:29:53.828] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:53.828] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.830] Chunk #1 of 1 ... DONE
[10:29:53.830] Launching 1 futures (chunks) ... DONE
[10:29:53.830] Resolving 1 futures (chunks) ...
[10:29:53.830] resolve() on list ...
[10:29:53.830]  recursive: 0
[10:29:53.831]  length: 1
[10:29:53.831] 
[10:29:53.831] resolved() for ‘SequentialFuture’ ...
[10:29:53.831] - state: ‘finished’
[10:29:53.831] - run: TRUE
[10:29:53.831] - result: ‘FutureResult’
[10:29:53.831] resolved() for ‘SequentialFuture’ ... done
[10:29:53.831] Future #1
[10:29:53.831] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:53.831] - nx: 1
[10:29:53.832] - relay: TRUE
[10:29:53.832] - stdout: TRUE
[10:29:53.832] - signal: TRUE
[10:29:53.832] - resignal: FALSE
[10:29:53.832] - force: TRUE
[10:29:53.832] - relayed: [n=1] FALSE
[10:29:53.832] - queued futures: [n=1] FALSE
[10:29:53.832]  - until=1
[10:29:53.832]  - relaying element #1
[10:29:53.832] - relayed: [n=1] TRUE
[10:29:53.833] - queued futures: [n=1] TRUE
[10:29:53.833] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:53.833]  length: 0 (resolved future 1)
[10:29:53.833] Relaying remaining futures
[10:29:53.833] signalConditionsASAP(NULL, pos=0) ...
[10:29:53.833] - nx: 1
[10:29:53.833] - relay: TRUE
[10:29:53.833] - stdout: TRUE
[10:29:53.833] - signal: TRUE
[10:29:53.833] - resignal: FALSE
[10:29:53.833] - force: TRUE
[10:29:53.833] - relayed: [n=1] TRUE
[10:29:53.834] - queued futures: [n=1] TRUE
 - flush all
[10:29:53.834] - relayed: [n=1] TRUE
[10:29:53.834] - queued futures: [n=1] TRUE
[10:29:53.834] signalConditionsASAP(NULL, pos=0) ... done
[10:29:53.834] resolve() on list ... DONE
[10:29:53.834]  - Number of value chunks collected: 1
[10:29:53.834] Resolving 1 futures (chunks) ... DONE
[10:29:53.834] Reducing values from 1 chunks ...
[10:29:53.834]  - Number of values collected after concatenation: 3
[10:29:53.835]  - Number of values expected: 3
[10:29:53.835] Reducing values from 1 chunks ... DONE
[10:29:53.835] future_lapply() ... DONE
[10:29:53.835] future_by_internal() ... DONE
[10:29:53.835] future_by_internal() ...
[10:29:53.836] future_lapply() ...
[10:29:53.839] Number of chunks: 1
[10:29:53.840] getGlobalsAndPackagesXApply() ...
[10:29:53.840]  - future.globals: TRUE
[10:29:53.840] getGlobalsAndPackages() ...
[10:29:53.840] Searching for globals...
[10:29:53.841] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:53.841] Searching for globals ... DONE
[10:29:53.842] Resolving globals: FALSE
[10:29:53.842] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:53.842] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:53.842] - globals: [1] ‘FUN’
[10:29:53.842] 
[10:29:53.843] getGlobalsAndPackages() ... DONE
[10:29:53.843]  - globals found/used: [n=1] ‘FUN’
[10:29:53.843]  - needed namespaces: [n=0] 
[10:29:53.843] Finding globals ... DONE
[10:29:53.843]  - use_args: TRUE
[10:29:53.843]  - Getting '...' globals ...
[10:29:53.843] resolve() on list ...
[10:29:53.843]  recursive: 0
[10:29:53.844]  length: 1
[10:29:53.844]  elements: ‘...’
[10:29:53.844]  length: 0 (resolved future 1)
[10:29:53.844] resolve() on list ... DONE
[10:29:53.844]    - '...' content: [n=0] 
[10:29:53.844] List of 1
[10:29:53.844]  $ ...: list()
[10:29:53.844]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.844]  - attr(*, "where")=List of 1
[10:29:53.844]   ..$ ...:<environment: 0x556dd4d29140> 
[10:29:53.844]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.844]  - attr(*, "resolved")= logi TRUE
[10:29:53.844]  - attr(*, "total_size")= num NA
[10:29:53.847]  - Getting '...' globals ... DONE
[10:29:53.847] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:53.847] List of 2
[10:29:53.847]  $ ...future.FUN:function (object, ...)  
[10:29:53.847]  $ ...          : list()
[10:29:53.847]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.847]  - attr(*, "where")=List of 2
[10:29:53.847]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:53.847]   ..$ ...          :<environment: 0x556dd4d29140> 
[10:29:53.847]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.847]  - attr(*, "resolved")= logi FALSE
[10:29:53.847]  - attr(*, "total_size")= num 1240
[10:29:53.851] Packages to be attached in all futures: [n=0] 
[10:29:53.852] getGlobalsAndPackagesXApply() ... DONE
[10:29:53.852] Number of futures (= number of chunks): 1
[10:29:53.852] Launching 1 futures (chunks) ...
[10:29:53.852] Chunk #1 of 1 ...
[10:29:53.852]  - Finding globals in 'X' for chunk #1 ...
[10:29:53.852] getGlobalsAndPackages() ...
[10:29:53.852] Searching for globals...
[10:29:53.853] 
[10:29:53.853] Searching for globals ... DONE
[10:29:53.853] - globals: [0] <none>
[10:29:53.853] getGlobalsAndPackages() ... DONE
[10:29:53.853]    + additional globals found: [n=0] 
[10:29:53.853]    + additional namespaces needed: [n=0] 
[10:29:53.854]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:53.854]  - seeds: <none>
[10:29:53.854]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.854] getGlobalsAndPackages() ...
[10:29:53.854] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.854] Resolving globals: FALSE
[10:29:53.854] Tweak future expression to call with '...' arguments ...
[10:29:53.854] {
[10:29:53.854]     do.call(function(...) {
[10:29:53.854]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.854]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.854]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.854]             on.exit(options(oopts), add = TRUE)
[10:29:53.854]         }
[10:29:53.854]         {
[10:29:53.854]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.854]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.854]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.854]             })
[10:29:53.854]         }
[10:29:53.854]     }, args = future.call.arguments)
[10:29:53.854] }
[10:29:53.855] Tweak future expression to call with '...' arguments ... DONE
[10:29:53.855] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.855] 
[10:29:53.855] getGlobalsAndPackages() ... DONE
[10:29:53.855] run() for ‘Future’ ...
[10:29:53.855] - state: ‘created’
[10:29:53.856] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:53.859] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.859] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:53.859]   - Field: ‘label’
[10:29:53.859]   - Field: ‘local’
[10:29:53.859]   - Field: ‘owner’
[10:29:53.860]   - Field: ‘envir’
[10:29:53.860]   - Field: ‘packages’
[10:29:53.860]   - Field: ‘gc’
[10:29:53.860]   - Field: ‘conditions’
[10:29:53.860]   - Field: ‘expr’
[10:29:53.860]   - Field: ‘uuid’
[10:29:53.860]   - Field: ‘seed’
[10:29:53.860]   - Field: ‘version’
[10:29:53.860]   - Field: ‘result’
[10:29:53.860]   - Field: ‘asynchronous’
[10:29:53.861]   - Field: ‘calls’
[10:29:53.861]   - Field: ‘globals’
[10:29:53.861]   - Field: ‘stdout’
[10:29:53.861]   - Field: ‘earlySignal’
[10:29:53.861]   - Field: ‘lazy’
[10:29:53.861]   - Field: ‘state’
[10:29:53.861] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:53.861] - Launch lazy future ...
[10:29:53.861] Packages needed by the future expression (n = 0): <none>
[10:29:53.862] Packages needed by future strategies (n = 0): <none>
[10:29:53.862] {
[10:29:53.862]     {
[10:29:53.862]         {
[10:29:53.862]             ...future.startTime <- base::Sys.time()
[10:29:53.862]             {
[10:29:53.862]                 {
[10:29:53.862]                   {
[10:29:53.862]                     base::local({
[10:29:53.862]                       has_future <- base::requireNamespace("future", 
[10:29:53.862]                         quietly = TRUE)
[10:29:53.862]                       if (has_future) {
[10:29:53.862]                         ns <- base::getNamespace("future")
[10:29:53.862]                         version <- ns[[".package"]][["version"]]
[10:29:53.862]                         if (is.null(version)) 
[10:29:53.862]                           version <- utils::packageVersion("future")
[10:29:53.862]                       }
[10:29:53.862]                       else {
[10:29:53.862]                         version <- NULL
[10:29:53.862]                       }
[10:29:53.862]                       if (!has_future || version < "1.8.0") {
[10:29:53.862]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:53.862]                           "", base::R.version$version.string), 
[10:29:53.862]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:53.862]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:53.862]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:53.862]                             "release", "version")], collapse = " "), 
[10:29:53.862]                           hostname = base::Sys.info()[["nodename"]])
[10:29:53.862]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:53.862]                           info)
[10:29:53.862]                         info <- base::paste(info, collapse = "; ")
[10:29:53.862]                         if (!has_future) {
[10:29:53.862]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:53.862]                             info)
[10:29:53.862]                         }
[10:29:53.862]                         else {
[10:29:53.862]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:53.862]                             info, version)
[10:29:53.862]                         }
[10:29:53.862]                         base::stop(msg)
[10:29:53.862]                       }
[10:29:53.862]                     })
[10:29:53.862]                   }
[10:29:53.862]                   ...future.strategy.old <- future::plan("list")
[10:29:53.862]                   options(future.plan = NULL)
[10:29:53.862]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.862]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:53.862]                 }
[10:29:53.862]                 ...future.workdir <- getwd()
[10:29:53.862]             }
[10:29:53.862]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:53.862]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:53.862]         }
[10:29:53.862]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:53.862]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:53.862]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:53.862]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:53.862]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:53.862]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:53.862]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:53.862]             base::names(...future.oldOptions))
[10:29:53.862]     }
[10:29:53.862]     if (FALSE) {
[10:29:53.862]     }
[10:29:53.862]     else {
[10:29:53.862]         if (TRUE) {
[10:29:53.862]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:53.862]                 open = "w")
[10:29:53.862]         }
[10:29:53.862]         else {
[10:29:53.862]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:53.862]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:53.862]         }
[10:29:53.862]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:53.862]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:53.862]             base::sink(type = "output", split = FALSE)
[10:29:53.862]             base::close(...future.stdout)
[10:29:53.862]         }, add = TRUE)
[10:29:53.862]     }
[10:29:53.862]     ...future.frame <- base::sys.nframe()
[10:29:53.862]     ...future.conditions <- base::list()
[10:29:53.862]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:53.862]     if (FALSE) {
[10:29:53.862]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:53.862]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:53.862]     }
[10:29:53.862]     ...future.result <- base::tryCatch({
[10:29:53.862]         base::withCallingHandlers({
[10:29:53.862]             ...future.value <- base::withVisible(base::local({
[10:29:53.862]                 do.call(function(...) {
[10:29:53.862]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.862]                   if (!identical(...future.globals.maxSize.org, 
[10:29:53.862]                     ...future.globals.maxSize)) {
[10:29:53.862]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.862]                     on.exit(options(oopts), add = TRUE)
[10:29:53.862]                   }
[10:29:53.862]                   {
[10:29:53.862]                     lapply(seq_along(...future.elements_ii), 
[10:29:53.862]                       FUN = function(jj) {
[10:29:53.862]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.862]                         ...future.FUN(...future.X_jj, ...)
[10:29:53.862]                       })
[10:29:53.862]                   }
[10:29:53.862]                 }, args = future.call.arguments)
[10:29:53.862]             }))
[10:29:53.862]             future::FutureResult(value = ...future.value$value, 
[10:29:53.862]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.862]                   ...future.rng), globalenv = if (FALSE) 
[10:29:53.862]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:53.862]                     ...future.globalenv.names))
[10:29:53.862]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:53.862]         }, condition = base::local({
[10:29:53.862]             c <- base::c
[10:29:53.862]             inherits <- base::inherits
[10:29:53.862]             invokeRestart <- base::invokeRestart
[10:29:53.862]             length <- base::length
[10:29:53.862]             list <- base::list
[10:29:53.862]             seq.int <- base::seq.int
[10:29:53.862]             signalCondition <- base::signalCondition
[10:29:53.862]             sys.calls <- base::sys.calls
[10:29:53.862]             `[[` <- base::`[[`
[10:29:53.862]             `+` <- base::`+`
[10:29:53.862]             `<<-` <- base::`<<-`
[10:29:53.862]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:53.862]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:53.862]                   3L)]
[10:29:53.862]             }
[10:29:53.862]             function(cond) {
[10:29:53.862]                 is_error <- inherits(cond, "error")
[10:29:53.862]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:53.862]                   NULL)
[10:29:53.862]                 if (is_error) {
[10:29:53.862]                   sessionInformation <- function() {
[10:29:53.862]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:53.862]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:53.862]                       search = base::search(), system = base::Sys.info())
[10:29:53.862]                   }
[10:29:53.862]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.862]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:53.862]                     cond$call), session = sessionInformation(), 
[10:29:53.862]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:53.862]                   signalCondition(cond)
[10:29:53.862]                 }
[10:29:53.862]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:53.862]                 "immediateCondition"))) {
[10:29:53.862]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:53.862]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.862]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:53.862]                   if (TRUE && !signal) {
[10:29:53.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.862]                     {
[10:29:53.862]                       inherits <- base::inherits
[10:29:53.862]                       invokeRestart <- base::invokeRestart
[10:29:53.862]                       is.null <- base::is.null
[10:29:53.862]                       muffled <- FALSE
[10:29:53.862]                       if (inherits(cond, "message")) {
[10:29:53.862]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.862]                         if (muffled) 
[10:29:53.862]                           invokeRestart("muffleMessage")
[10:29:53.862]                       }
[10:29:53.862]                       else if (inherits(cond, "warning")) {
[10:29:53.862]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.862]                         if (muffled) 
[10:29:53.862]                           invokeRestart("muffleWarning")
[10:29:53.862]                       }
[10:29:53.862]                       else if (inherits(cond, "condition")) {
[10:29:53.862]                         if (!is.null(pattern)) {
[10:29:53.862]                           computeRestarts <- base::computeRestarts
[10:29:53.862]                           grepl <- base::grepl
[10:29:53.862]                           restarts <- computeRestarts(cond)
[10:29:53.862]                           for (restart in restarts) {
[10:29:53.862]                             name <- restart$name
[10:29:53.862]                             if (is.null(name)) 
[10:29:53.862]                               next
[10:29:53.862]                             if (!grepl(pattern, name)) 
[10:29:53.862]                               next
[10:29:53.862]                             invokeRestart(restart)
[10:29:53.862]                             muffled <- TRUE
[10:29:53.862]                             break
[10:29:53.862]                           }
[10:29:53.862]                         }
[10:29:53.862]                       }
[10:29:53.862]                       invisible(muffled)
[10:29:53.862]                     }
[10:29:53.862]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.862]                   }
[10:29:53.862]                 }
[10:29:53.862]                 else {
[10:29:53.862]                   if (TRUE) {
[10:29:53.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.862]                     {
[10:29:53.862]                       inherits <- base::inherits
[10:29:53.862]                       invokeRestart <- base::invokeRestart
[10:29:53.862]                       is.null <- base::is.null
[10:29:53.862]                       muffled <- FALSE
[10:29:53.862]                       if (inherits(cond, "message")) {
[10:29:53.862]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.862]                         if (muffled) 
[10:29:53.862]                           invokeRestart("muffleMessage")
[10:29:53.862]                       }
[10:29:53.862]                       else if (inherits(cond, "warning")) {
[10:29:53.862]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.862]                         if (muffled) 
[10:29:53.862]                           invokeRestart("muffleWarning")
[10:29:53.862]                       }
[10:29:53.862]                       else if (inherits(cond, "condition")) {
[10:29:53.862]                         if (!is.null(pattern)) {
[10:29:53.862]                           computeRestarts <- base::computeRestarts
[10:29:53.862]                           grepl <- base::grepl
[10:29:53.862]                           restarts <- computeRestarts(cond)
[10:29:53.862]                           for (restart in restarts) {
[10:29:53.862]                             name <- restart$name
[10:29:53.862]                             if (is.null(name)) 
[10:29:53.862]                               next
[10:29:53.862]                             if (!grepl(pattern, name)) 
[10:29:53.862]                               next
[10:29:53.862]                             invokeRestart(restart)
[10:29:53.862]                             muffled <- TRUE
[10:29:53.862]                             break
[10:29:53.862]                           }
[10:29:53.862]                         }
[10:29:53.862]                       }
[10:29:53.862]                       invisible(muffled)
[10:29:53.862]                     }
[10:29:53.862]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.862]                   }
[10:29:53.862]                 }
[10:29:53.862]             }
[10:29:53.862]         }))
[10:29:53.862]     }, error = function(ex) {
[10:29:53.862]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:53.862]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.862]                 ...future.rng), started = ...future.startTime, 
[10:29:53.862]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:53.862]             version = "1.8"), class = "FutureResult")
[10:29:53.862]     }, finally = {
[10:29:53.862]         if (!identical(...future.workdir, getwd())) 
[10:29:53.862]             setwd(...future.workdir)
[10:29:53.862]         {
[10:29:53.862]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:53.862]                 ...future.oldOptions$nwarnings <- NULL
[10:29:53.862]             }
[10:29:53.862]             base::options(...future.oldOptions)
[10:29:53.862]             if (.Platform$OS.type == "windows") {
[10:29:53.862]                 old_names <- names(...future.oldEnvVars)
[10:29:53.862]                 envs <- base::Sys.getenv()
[10:29:53.862]                 names <- names(envs)
[10:29:53.862]                 common <- intersect(names, old_names)
[10:29:53.862]                 added <- setdiff(names, old_names)
[10:29:53.862]                 removed <- setdiff(old_names, names)
[10:29:53.862]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:53.862]                   envs[common]]
[10:29:53.862]                 NAMES <- toupper(changed)
[10:29:53.862]                 args <- list()
[10:29:53.862]                 for (kk in seq_along(NAMES)) {
[10:29:53.862]                   name <- changed[[kk]]
[10:29:53.862]                   NAME <- NAMES[[kk]]
[10:29:53.862]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.862]                     next
[10:29:53.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.862]                 }
[10:29:53.862]                 NAMES <- toupper(added)
[10:29:53.862]                 for (kk in seq_along(NAMES)) {
[10:29:53.862]                   name <- added[[kk]]
[10:29:53.862]                   NAME <- NAMES[[kk]]
[10:29:53.862]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.862]                     next
[10:29:53.862]                   args[[name]] <- ""
[10:29:53.862]                 }
[10:29:53.862]                 NAMES <- toupper(removed)
[10:29:53.862]                 for (kk in seq_along(NAMES)) {
[10:29:53.862]                   name <- removed[[kk]]
[10:29:53.862]                   NAME <- NAMES[[kk]]
[10:29:53.862]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.862]                     next
[10:29:53.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.862]                 }
[10:29:53.862]                 if (length(args) > 0) 
[10:29:53.862]                   base::do.call(base::Sys.setenv, args = args)
[10:29:53.862]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:53.862]             }
[10:29:53.862]             else {
[10:29:53.862]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:53.862]             }
[10:29:53.862]             {
[10:29:53.862]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:53.862]                   0L) {
[10:29:53.862]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:53.862]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:53.862]                   base::options(opts)
[10:29:53.862]                 }
[10:29:53.862]                 {
[10:29:53.862]                   {
[10:29:53.862]                     NULL
[10:29:53.862]                     RNGkind("Mersenne-Twister")
[10:29:53.862]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:53.862]                       inherits = FALSE)
[10:29:53.862]                   }
[10:29:53.862]                   options(future.plan = NULL)
[10:29:53.862]                   if (is.na(NA_character_)) 
[10:29:53.862]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.862]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:53.862]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:53.862]                     .init = FALSE)
[10:29:53.862]                 }
[10:29:53.862]             }
[10:29:53.862]         }
[10:29:53.862]     })
[10:29:53.862]     if (TRUE) {
[10:29:53.862]         base::sink(type = "output", split = FALSE)
[10:29:53.862]         if (TRUE) {
[10:29:53.862]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:53.862]         }
[10:29:53.862]         else {
[10:29:53.862]             ...future.result["stdout"] <- base::list(NULL)
[10:29:53.862]         }
[10:29:53.862]         base::close(...future.stdout)
[10:29:53.862]         ...future.stdout <- NULL
[10:29:53.862]     }
[10:29:53.862]     ...future.result$conditions <- ...future.conditions
[10:29:53.862]     ...future.result$finished <- base::Sys.time()
[10:29:53.862]     ...future.result
[10:29:53.862] }
[10:29:53.864] assign_globals() ...
[10:29:53.864] List of 5
[10:29:53.864]  $ ...future.FUN            :function (object, ...)  
[10:29:53.864]  $ future.call.arguments    : list()
[10:29:53.864]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.864]  $ ...future.elements_ii    :List of 3
[10:29:53.864]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.864]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:29:53.864]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.864]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:53.864]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.864]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:29:53.864]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.864]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:29:53.864]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.864]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:29:53.864]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.864]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:29:53.864]  $ ...future.seeds_ii       : NULL
[10:29:53.864]  $ ...future.globals.maxSize: NULL
[10:29:53.864]  - attr(*, "where")=List of 5
[10:29:53.864]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:53.864]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:53.864]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:53.864]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:53.864]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:53.864]  - attr(*, "resolved")= logi FALSE
[10:29:53.864]  - attr(*, "total_size")= num 1240
[10:29:53.864]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.864]  - attr(*, "already-done")= logi TRUE
[10:29:53.874] - copied ‘...future.FUN’ to environment
[10:29:53.874] - copied ‘future.call.arguments’ to environment
[10:29:53.874] - copied ‘...future.elements_ii’ to environment
[10:29:53.874] - copied ‘...future.seeds_ii’ to environment
[10:29:53.875] - copied ‘...future.globals.maxSize’ to environment
[10:29:53.875] assign_globals() ... done
[10:29:53.875] plan(): Setting new future strategy stack:
[10:29:53.875] List of future strategies:
[10:29:53.875] 1. sequential:
[10:29:53.875]    - args: function (..., envir = parent.frame())
[10:29:53.875]    - tweaked: FALSE
[10:29:53.875]    - call: NULL
[10:29:53.875] plan(): nbrOfWorkers() = 1
[10:29:53.878] plan(): Setting new future strategy stack:
[10:29:53.878] List of future strategies:
[10:29:53.878] 1. multisession:
[10:29:53.878]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:29:53.878]    - tweaked: FALSE
[10:29:53.878]    - call: plan(strategy)
[10:29:53.881] plan(): nbrOfWorkers() = 1
[10:29:53.881] SequentialFuture started (and completed)
[10:29:53.882] - Launch lazy future ... done
[10:29:53.882] run() for ‘SequentialFuture’ ... done
[10:29:53.882] Created future:
[10:29:53.882] SequentialFuture:
[10:29:53.882] Label: ‘future_by-1’
[10:29:53.882] Expression:
[10:29:53.882] {
[10:29:53.882]     do.call(function(...) {
[10:29:53.882]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.882]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.882]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.882]             on.exit(options(oopts), add = TRUE)
[10:29:53.882]         }
[10:29:53.882]         {
[10:29:53.882]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.882]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.882]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.882]             })
[10:29:53.882]         }
[10:29:53.882]     }, args = future.call.arguments)
[10:29:53.882] }
[10:29:53.882] Lazy evaluation: FALSE
[10:29:53.882] Asynchronous evaluation: FALSE
[10:29:53.882] Local evaluation: TRUE
[10:29:53.882] Environment: 0x556dd48ef420
[10:29:53.882] Capture standard output: TRUE
[10:29:53.882] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:53.882] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:53.882] Packages: <none>
[10:29:53.882] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:53.882] Resolved: TRUE
[10:29:53.882] Value: 5.37 KiB of class ‘list’
[10:29:53.882] Early signaling: FALSE
[10:29:53.882] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:53.882] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.883] Chunk #1 of 1 ... DONE
[10:29:53.883] Launching 1 futures (chunks) ... DONE
[10:29:53.883] Resolving 1 futures (chunks) ...
[10:29:53.883] resolve() on list ...
[10:29:53.884]  recursive: 0
[10:29:53.884]  length: 1
[10:29:53.884] 
[10:29:53.884] resolved() for ‘SequentialFuture’ ...
[10:29:53.884] - state: ‘finished’
[10:29:53.884] - run: TRUE
[10:29:53.884] - result: ‘FutureResult’
[10:29:53.884] resolved() for ‘SequentialFuture’ ... done
[10:29:53.884] Future #1
[10:29:53.884] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:53.885] - nx: 1
[10:29:53.885] - relay: TRUE
[10:29:53.885] - stdout: TRUE
[10:29:53.885] - signal: TRUE
[10:29:53.885] - resignal: FALSE
[10:29:53.885] - force: TRUE
[10:29:53.885] - relayed: [n=1] FALSE
[10:29:53.885] - queued futures: [n=1] FALSE
[10:29:53.885]  - until=1
[10:29:53.885]  - relaying element #1
[10:29:53.886] - relayed: [n=1] TRUE
[10:29:53.886] - queued futures: [n=1] TRUE
[10:29:53.886] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:53.886]  length: 0 (resolved future 1)
[10:29:53.886] Relaying remaining futures
[10:29:53.886] signalConditionsASAP(NULL, pos=0) ...
[10:29:53.886] - nx: 1
[10:29:53.886] - relay: TRUE
[10:29:53.886] - stdout: TRUE
[10:29:53.886] - signal: TRUE
[10:29:53.886] - resignal: FALSE
[10:29:53.887] - force: TRUE
[10:29:53.887] - relayed: [n=1] TRUE
[10:29:53.887] - queued futures: [n=1] TRUE
 - flush all
[10:29:53.887] - relayed: [n=1] TRUE
[10:29:53.887] - queued futures: [n=1] TRUE
[10:29:53.887] signalConditionsASAP(NULL, pos=0) ... done
[10:29:53.887] resolve() on list ... DONE
[10:29:53.887]  - Number of value chunks collected: 1
[10:29:53.887] Resolving 1 futures (chunks) ... DONE
[10:29:53.887] Reducing values from 1 chunks ...
[10:29:53.887]  - Number of values collected after concatenation: 3
[10:29:53.888]  - Number of values expected: 3
[10:29:53.888] Reducing values from 1 chunks ... DONE
[10:29:53.888] future_lapply() ... DONE
[10:29:53.888] future_by_internal() ... DONE
[10:29:53.889] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[10:29:53.889] future_lapply() ...
[10:29:53.893] Number of chunks: 1
[10:29:53.893] getGlobalsAndPackagesXApply() ...
[10:29:53.893]  - future.globals: TRUE
[10:29:53.893] getGlobalsAndPackages() ...
[10:29:53.893] Searching for globals...
[10:29:53.894] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:53.894] Searching for globals ... DONE
[10:29:53.894] Resolving globals: FALSE
[10:29:53.898] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:53.898] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:53.898] - globals: [1] ‘FUN’
[10:29:53.898] 
[10:29:53.898] getGlobalsAndPackages() ... DONE
[10:29:53.899]  - globals found/used: [n=1] ‘FUN’
[10:29:53.899]  - needed namespaces: [n=0] 
[10:29:53.899] Finding globals ... DONE
[10:29:53.899]  - use_args: TRUE
[10:29:53.899]  - Getting '...' globals ...
[10:29:53.899] resolve() on list ...
[10:29:53.900]  recursive: 0
[10:29:53.900]  length: 1
[10:29:53.900]  elements: ‘...’
[10:29:53.900]  length: 0 (resolved future 1)
[10:29:53.900] resolve() on list ... DONE
[10:29:53.900]    - '...' content: [n=0] 
[10:29:53.900] List of 1
[10:29:53.900]  $ ...: list()
[10:29:53.900]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.900]  - attr(*, "where")=List of 1
[10:29:53.900]   ..$ ...:<environment: 0x556dd5171910> 
[10:29:53.900]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.900]  - attr(*, "resolved")= logi TRUE
[10:29:53.900]  - attr(*, "total_size")= num NA
[10:29:53.903]  - Getting '...' globals ... DONE
[10:29:53.903] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:53.903] List of 2
[10:29:53.903]  $ ...future.FUN:function (object, ...)  
[10:29:53.903]  $ ...          : list()
[10:29:53.903]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.903]  - attr(*, "where")=List of 2
[10:29:53.903]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:53.903]   ..$ ...          :<environment: 0x556dd5171910> 
[10:29:53.903]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.903]  - attr(*, "resolved")= logi FALSE
[10:29:53.903]  - attr(*, "total_size")= num 1240
[10:29:53.906] Packages to be attached in all futures: [n=0] 
[10:29:53.906] getGlobalsAndPackagesXApply() ... DONE
[10:29:53.906] Number of futures (= number of chunks): 1
[10:29:53.906] Launching 1 futures (chunks) ...
[10:29:53.906] Chunk #1 of 1 ...
[10:29:53.907]  - Finding globals in 'X' for chunk #1 ...
[10:29:53.907] getGlobalsAndPackages() ...
[10:29:53.907] Searching for globals...
[10:29:53.907] 
[10:29:53.907] Searching for globals ... DONE
[10:29:53.907] - globals: [0] <none>
[10:29:53.908] getGlobalsAndPackages() ... DONE
[10:29:53.908]    + additional globals found: [n=0] 
[10:29:53.908]    + additional namespaces needed: [n=0] 
[10:29:53.908]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:53.908]  - seeds: <none>
[10:29:53.908]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.908] getGlobalsAndPackages() ...
[10:29:53.908] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.908] Resolving globals: FALSE
[10:29:53.908] Tweak future expression to call with '...' arguments ...
[10:29:53.909] {
[10:29:53.909]     do.call(function(...) {
[10:29:53.909]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.909]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.909]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.909]             on.exit(options(oopts), add = TRUE)
[10:29:53.909]         }
[10:29:53.909]         {
[10:29:53.909]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.909]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.909]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.909]             })
[10:29:53.909]         }
[10:29:53.909]     }, args = future.call.arguments)
[10:29:53.909] }
[10:29:53.909] Tweak future expression to call with '...' arguments ... DONE
[10:29:53.909] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.909] 
[10:29:53.909] getGlobalsAndPackages() ... DONE
[10:29:53.910] run() for ‘Future’ ...
[10:29:53.910] - state: ‘created’
[10:29:53.910] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:53.913] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.913] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:53.914]   - Field: ‘label’
[10:29:53.914]   - Field: ‘local’
[10:29:53.914]   - Field: ‘owner’
[10:29:53.914]   - Field: ‘envir’
[10:29:53.914]   - Field: ‘packages’
[10:29:53.914]   - Field: ‘gc’
[10:29:53.914]   - Field: ‘conditions’
[10:29:53.914]   - Field: ‘expr’
[10:29:53.914]   - Field: ‘uuid’
[10:29:53.914]   - Field: ‘seed’
[10:29:53.915]   - Field: ‘version’
[10:29:53.915]   - Field: ‘result’
[10:29:53.915]   - Field: ‘asynchronous’
[10:29:53.915]   - Field: ‘calls’
[10:29:53.915]   - Field: ‘globals’
[10:29:53.915]   - Field: ‘stdout’
[10:29:53.915]   - Field: ‘earlySignal’
[10:29:53.915]   - Field: ‘lazy’
[10:29:53.915]   - Field: ‘state’
[10:29:53.915] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:53.915] - Launch lazy future ...
[10:29:53.916] Packages needed by the future expression (n = 0): <none>
[10:29:53.916] Packages needed by future strategies (n = 0): <none>
[10:29:53.916] {
[10:29:53.916]     {
[10:29:53.916]         {
[10:29:53.916]             ...future.startTime <- base::Sys.time()
[10:29:53.916]             {
[10:29:53.916]                 {
[10:29:53.916]                   {
[10:29:53.916]                     base::local({
[10:29:53.916]                       has_future <- base::requireNamespace("future", 
[10:29:53.916]                         quietly = TRUE)
[10:29:53.916]                       if (has_future) {
[10:29:53.916]                         ns <- base::getNamespace("future")
[10:29:53.916]                         version <- ns[[".package"]][["version"]]
[10:29:53.916]                         if (is.null(version)) 
[10:29:53.916]                           version <- utils::packageVersion("future")
[10:29:53.916]                       }
[10:29:53.916]                       else {
[10:29:53.916]                         version <- NULL
[10:29:53.916]                       }
[10:29:53.916]                       if (!has_future || version < "1.8.0") {
[10:29:53.916]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:53.916]                           "", base::R.version$version.string), 
[10:29:53.916]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:53.916]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:53.916]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:53.916]                             "release", "version")], collapse = " "), 
[10:29:53.916]                           hostname = base::Sys.info()[["nodename"]])
[10:29:53.916]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:53.916]                           info)
[10:29:53.916]                         info <- base::paste(info, collapse = "; ")
[10:29:53.916]                         if (!has_future) {
[10:29:53.916]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:53.916]                             info)
[10:29:53.916]                         }
[10:29:53.916]                         else {
[10:29:53.916]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:53.916]                             info, version)
[10:29:53.916]                         }
[10:29:53.916]                         base::stop(msg)
[10:29:53.916]                       }
[10:29:53.916]                     })
[10:29:53.916]                   }
[10:29:53.916]                   ...future.strategy.old <- future::plan("list")
[10:29:53.916]                   options(future.plan = NULL)
[10:29:53.916]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.916]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:53.916]                 }
[10:29:53.916]                 ...future.workdir <- getwd()
[10:29:53.916]             }
[10:29:53.916]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:53.916]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:53.916]         }
[10:29:53.916]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:53.916]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:53.916]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:53.916]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:53.916]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:53.916]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:53.916]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:53.916]             base::names(...future.oldOptions))
[10:29:53.916]     }
[10:29:53.916]     if (FALSE) {
[10:29:53.916]     }
[10:29:53.916]     else {
[10:29:53.916]         if (TRUE) {
[10:29:53.916]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:53.916]                 open = "w")
[10:29:53.916]         }
[10:29:53.916]         else {
[10:29:53.916]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:53.916]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:53.916]         }
[10:29:53.916]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:53.916]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:53.916]             base::sink(type = "output", split = FALSE)
[10:29:53.916]             base::close(...future.stdout)
[10:29:53.916]         }, add = TRUE)
[10:29:53.916]     }
[10:29:53.916]     ...future.frame <- base::sys.nframe()
[10:29:53.916]     ...future.conditions <- base::list()
[10:29:53.916]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:53.916]     if (FALSE) {
[10:29:53.916]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:53.916]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:53.916]     }
[10:29:53.916]     ...future.result <- base::tryCatch({
[10:29:53.916]         base::withCallingHandlers({
[10:29:53.916]             ...future.value <- base::withVisible(base::local({
[10:29:53.916]                 do.call(function(...) {
[10:29:53.916]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.916]                   if (!identical(...future.globals.maxSize.org, 
[10:29:53.916]                     ...future.globals.maxSize)) {
[10:29:53.916]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.916]                     on.exit(options(oopts), add = TRUE)
[10:29:53.916]                   }
[10:29:53.916]                   {
[10:29:53.916]                     lapply(seq_along(...future.elements_ii), 
[10:29:53.916]                       FUN = function(jj) {
[10:29:53.916]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.916]                         ...future.FUN(...future.X_jj, ...)
[10:29:53.916]                       })
[10:29:53.916]                   }
[10:29:53.916]                 }, args = future.call.arguments)
[10:29:53.916]             }))
[10:29:53.916]             future::FutureResult(value = ...future.value$value, 
[10:29:53.916]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.916]                   ...future.rng), globalenv = if (FALSE) 
[10:29:53.916]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:53.916]                     ...future.globalenv.names))
[10:29:53.916]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:53.916]         }, condition = base::local({
[10:29:53.916]             c <- base::c
[10:29:53.916]             inherits <- base::inherits
[10:29:53.916]             invokeRestart <- base::invokeRestart
[10:29:53.916]             length <- base::length
[10:29:53.916]             list <- base::list
[10:29:53.916]             seq.int <- base::seq.int
[10:29:53.916]             signalCondition <- base::signalCondition
[10:29:53.916]             sys.calls <- base::sys.calls
[10:29:53.916]             `[[` <- base::`[[`
[10:29:53.916]             `+` <- base::`+`
[10:29:53.916]             `<<-` <- base::`<<-`
[10:29:53.916]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:53.916]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:53.916]                   3L)]
[10:29:53.916]             }
[10:29:53.916]             function(cond) {
[10:29:53.916]                 is_error <- inherits(cond, "error")
[10:29:53.916]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:53.916]                   NULL)
[10:29:53.916]                 if (is_error) {
[10:29:53.916]                   sessionInformation <- function() {
[10:29:53.916]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:53.916]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:53.916]                       search = base::search(), system = base::Sys.info())
[10:29:53.916]                   }
[10:29:53.916]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.916]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:53.916]                     cond$call), session = sessionInformation(), 
[10:29:53.916]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:53.916]                   signalCondition(cond)
[10:29:53.916]                 }
[10:29:53.916]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:53.916]                 "immediateCondition"))) {
[10:29:53.916]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:53.916]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.916]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:53.916]                   if (TRUE && !signal) {
[10:29:53.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.916]                     {
[10:29:53.916]                       inherits <- base::inherits
[10:29:53.916]                       invokeRestart <- base::invokeRestart
[10:29:53.916]                       is.null <- base::is.null
[10:29:53.916]                       muffled <- FALSE
[10:29:53.916]                       if (inherits(cond, "message")) {
[10:29:53.916]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.916]                         if (muffled) 
[10:29:53.916]                           invokeRestart("muffleMessage")
[10:29:53.916]                       }
[10:29:53.916]                       else if (inherits(cond, "warning")) {
[10:29:53.916]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.916]                         if (muffled) 
[10:29:53.916]                           invokeRestart("muffleWarning")
[10:29:53.916]                       }
[10:29:53.916]                       else if (inherits(cond, "condition")) {
[10:29:53.916]                         if (!is.null(pattern)) {
[10:29:53.916]                           computeRestarts <- base::computeRestarts
[10:29:53.916]                           grepl <- base::grepl
[10:29:53.916]                           restarts <- computeRestarts(cond)
[10:29:53.916]                           for (restart in restarts) {
[10:29:53.916]                             name <- restart$name
[10:29:53.916]                             if (is.null(name)) 
[10:29:53.916]                               next
[10:29:53.916]                             if (!grepl(pattern, name)) 
[10:29:53.916]                               next
[10:29:53.916]                             invokeRestart(restart)
[10:29:53.916]                             muffled <- TRUE
[10:29:53.916]                             break
[10:29:53.916]                           }
[10:29:53.916]                         }
[10:29:53.916]                       }
[10:29:53.916]                       invisible(muffled)
[10:29:53.916]                     }
[10:29:53.916]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.916]                   }
[10:29:53.916]                 }
[10:29:53.916]                 else {
[10:29:53.916]                   if (TRUE) {
[10:29:53.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.916]                     {
[10:29:53.916]                       inherits <- base::inherits
[10:29:53.916]                       invokeRestart <- base::invokeRestart
[10:29:53.916]                       is.null <- base::is.null
[10:29:53.916]                       muffled <- FALSE
[10:29:53.916]                       if (inherits(cond, "message")) {
[10:29:53.916]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.916]                         if (muffled) 
[10:29:53.916]                           invokeRestart("muffleMessage")
[10:29:53.916]                       }
[10:29:53.916]                       else if (inherits(cond, "warning")) {
[10:29:53.916]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.916]                         if (muffled) 
[10:29:53.916]                           invokeRestart("muffleWarning")
[10:29:53.916]                       }
[10:29:53.916]                       else if (inherits(cond, "condition")) {
[10:29:53.916]                         if (!is.null(pattern)) {
[10:29:53.916]                           computeRestarts <- base::computeRestarts
[10:29:53.916]                           grepl <- base::grepl
[10:29:53.916]                           restarts <- computeRestarts(cond)
[10:29:53.916]                           for (restart in restarts) {
[10:29:53.916]                             name <- restart$name
[10:29:53.916]                             if (is.null(name)) 
[10:29:53.916]                               next
[10:29:53.916]                             if (!grepl(pattern, name)) 
[10:29:53.916]                               next
[10:29:53.916]                             invokeRestart(restart)
[10:29:53.916]                             muffled <- TRUE
[10:29:53.916]                             break
[10:29:53.916]                           }
[10:29:53.916]                         }
[10:29:53.916]                       }
[10:29:53.916]                       invisible(muffled)
[10:29:53.916]                     }
[10:29:53.916]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.916]                   }
[10:29:53.916]                 }
[10:29:53.916]             }
[10:29:53.916]         }))
[10:29:53.916]     }, error = function(ex) {
[10:29:53.916]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:53.916]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.916]                 ...future.rng), started = ...future.startTime, 
[10:29:53.916]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:53.916]             version = "1.8"), class = "FutureResult")
[10:29:53.916]     }, finally = {
[10:29:53.916]         if (!identical(...future.workdir, getwd())) 
[10:29:53.916]             setwd(...future.workdir)
[10:29:53.916]         {
[10:29:53.916]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:53.916]                 ...future.oldOptions$nwarnings <- NULL
[10:29:53.916]             }
[10:29:53.916]             base::options(...future.oldOptions)
[10:29:53.916]             if (.Platform$OS.type == "windows") {
[10:29:53.916]                 old_names <- names(...future.oldEnvVars)
[10:29:53.916]                 envs <- base::Sys.getenv()
[10:29:53.916]                 names <- names(envs)
[10:29:53.916]                 common <- intersect(names, old_names)
[10:29:53.916]                 added <- setdiff(names, old_names)
[10:29:53.916]                 removed <- setdiff(old_names, names)
[10:29:53.916]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:53.916]                   envs[common]]
[10:29:53.916]                 NAMES <- toupper(changed)
[10:29:53.916]                 args <- list()
[10:29:53.916]                 for (kk in seq_along(NAMES)) {
[10:29:53.916]                   name <- changed[[kk]]
[10:29:53.916]                   NAME <- NAMES[[kk]]
[10:29:53.916]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.916]                     next
[10:29:53.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.916]                 }
[10:29:53.916]                 NAMES <- toupper(added)
[10:29:53.916]                 for (kk in seq_along(NAMES)) {
[10:29:53.916]                   name <- added[[kk]]
[10:29:53.916]                   NAME <- NAMES[[kk]]
[10:29:53.916]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.916]                     next
[10:29:53.916]                   args[[name]] <- ""
[10:29:53.916]                 }
[10:29:53.916]                 NAMES <- toupper(removed)
[10:29:53.916]                 for (kk in seq_along(NAMES)) {
[10:29:53.916]                   name <- removed[[kk]]
[10:29:53.916]                   NAME <- NAMES[[kk]]
[10:29:53.916]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.916]                     next
[10:29:53.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.916]                 }
[10:29:53.916]                 if (length(args) > 0) 
[10:29:53.916]                   base::do.call(base::Sys.setenv, args = args)
[10:29:53.916]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:53.916]             }
[10:29:53.916]             else {
[10:29:53.916]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:53.916]             }
[10:29:53.916]             {
[10:29:53.916]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:53.916]                   0L) {
[10:29:53.916]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:53.916]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:53.916]                   base::options(opts)
[10:29:53.916]                 }
[10:29:53.916]                 {
[10:29:53.916]                   {
[10:29:53.916]                     NULL
[10:29:53.916]                     RNGkind("Mersenne-Twister")
[10:29:53.916]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:53.916]                       inherits = FALSE)
[10:29:53.916]                   }
[10:29:53.916]                   options(future.plan = NULL)
[10:29:53.916]                   if (is.na(NA_character_)) 
[10:29:53.916]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.916]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:53.916]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:53.916]                     .init = FALSE)
[10:29:53.916]                 }
[10:29:53.916]             }
[10:29:53.916]         }
[10:29:53.916]     })
[10:29:53.916]     if (TRUE) {
[10:29:53.916]         base::sink(type = "output", split = FALSE)
[10:29:53.916]         if (TRUE) {
[10:29:53.916]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:53.916]         }
[10:29:53.916]         else {
[10:29:53.916]             ...future.result["stdout"] <- base::list(NULL)
[10:29:53.916]         }
[10:29:53.916]         base::close(...future.stdout)
[10:29:53.916]         ...future.stdout <- NULL
[10:29:53.916]     }
[10:29:53.916]     ...future.result$conditions <- ...future.conditions
[10:29:53.916]     ...future.result$finished <- base::Sys.time()
[10:29:53.916]     ...future.result
[10:29:53.916] }
[10:29:53.918] assign_globals() ...
[10:29:53.918] List of 5
[10:29:53.918]  $ ...future.FUN            :function (object, ...)  
[10:29:53.918]  $ future.call.arguments    : list()
[10:29:53.918]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.918]  $ ...future.elements_ii    :List of 3
[10:29:53.918]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.918]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:29:53.918]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.918]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:53.918]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.918]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:29:53.918]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.918]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:29:53.918]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:53.918]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:29:53.918]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.918]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:29:53.918]  $ ...future.seeds_ii       : NULL
[10:29:53.918]  $ ...future.globals.maxSize: NULL
[10:29:53.918]  - attr(*, "where")=List of 5
[10:29:53.918]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:53.918]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:53.918]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:53.918]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:53.918]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:53.918]  - attr(*, "resolved")= logi FALSE
[10:29:53.918]  - attr(*, "total_size")= num 1240
[10:29:53.918]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.918]  - attr(*, "already-done")= logi TRUE
[10:29:53.929] - copied ‘...future.FUN’ to environment
[10:29:53.929] - copied ‘future.call.arguments’ to environment
[10:29:53.929] - copied ‘...future.elements_ii’ to environment
[10:29:53.930] - copied ‘...future.seeds_ii’ to environment
[10:29:53.930] - copied ‘...future.globals.maxSize’ to environment
[10:29:53.930] assign_globals() ... done
[10:29:53.930] plan(): Setting new future strategy stack:
[10:29:53.930] List of future strategies:
[10:29:53.930] 1. sequential:
[10:29:53.930]    - args: function (..., envir = parent.frame())
[10:29:53.930]    - tweaked: FALSE
[10:29:53.930]    - call: NULL
[10:29:53.931] plan(): nbrOfWorkers() = 1
[10:29:53.933] plan(): Setting new future strategy stack:
[10:29:53.933] List of future strategies:
[10:29:53.933] 1. multisession:
[10:29:53.933]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:29:53.933]    - tweaked: FALSE
[10:29:53.933]    - call: plan(strategy)
[10:29:53.936] plan(): nbrOfWorkers() = 1
[10:29:53.936] SequentialFuture started (and completed)
[10:29:53.936] - Launch lazy future ... done
[10:29:53.937] run() for ‘SequentialFuture’ ... done
[10:29:53.937] Created future:
[10:29:53.937] SequentialFuture:
[10:29:53.937] Label: ‘future_by-1’
[10:29:53.937] Expression:
[10:29:53.937] {
[10:29:53.937]     do.call(function(...) {
[10:29:53.937]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.937]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.937]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.937]             on.exit(options(oopts), add = TRUE)
[10:29:53.937]         }
[10:29:53.937]         {
[10:29:53.937]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.937]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.937]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.937]             })
[10:29:53.937]         }
[10:29:53.937]     }, args = future.call.arguments)
[10:29:53.937] }
[10:29:53.937] Lazy evaluation: FALSE
[10:29:53.937] Asynchronous evaluation: FALSE
[10:29:53.937] Local evaluation: TRUE
[10:29:53.937] Environment: 0x556dd512d338
[10:29:53.937] Capture standard output: TRUE
[10:29:53.937] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:53.937] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:53.937] Packages: <none>
[10:29:53.937] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:53.937] Resolved: TRUE
[10:29:53.937] Value: 5.37 KiB of class ‘list’
[10:29:53.937] Early signaling: FALSE
[10:29:53.937] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:53.937] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.938] Chunk #1 of 1 ... DONE
[10:29:53.938] Launching 1 futures (chunks) ... DONE
[10:29:53.938] Resolving 1 futures (chunks) ...
[10:29:53.938] resolve() on list ...
[10:29:53.939]  recursive: 0
[10:29:53.939]  length: 1
[10:29:53.939] 
[10:29:53.939] resolved() for ‘SequentialFuture’ ...
[10:29:53.939] - state: ‘finished’
[10:29:53.939] - run: TRUE
[10:29:53.939] - result: ‘FutureResult’
[10:29:53.939] resolved() for ‘SequentialFuture’ ... done
[10:29:53.939] Future #1
[10:29:53.939] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:53.940] - nx: 1
[10:29:53.940] - relay: TRUE
[10:29:53.940] - stdout: TRUE
[10:29:53.940] - signal: TRUE
[10:29:53.940] - resignal: FALSE
[10:29:53.940] - force: TRUE
[10:29:53.940] - relayed: [n=1] FALSE
[10:29:53.940] - queued futures: [n=1] FALSE
[10:29:53.940]  - until=1
[10:29:53.940]  - relaying element #1
[10:29:53.941] - relayed: [n=1] TRUE
[10:29:53.941] - queued futures: [n=1] TRUE
[10:29:53.941] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:53.941]  length: 0 (resolved future 1)
[10:29:53.941] Relaying remaining futures
[10:29:53.941] signalConditionsASAP(NULL, pos=0) ...
[10:29:53.941] - nx: 1
[10:29:53.941] - relay: TRUE
[10:29:53.941] - stdout: TRUE
[10:29:53.941] - signal: TRUE
[10:29:53.941] - resignal: FALSE
[10:29:53.942] - force: TRUE
[10:29:53.942] - relayed: [n=1] TRUE
[10:29:53.942] - queued futures: [n=1] TRUE
 - flush all
[10:29:53.942] - relayed: [n=1] TRUE
[10:29:53.942] - queued futures: [n=1] TRUE
[10:29:53.942] signalConditionsASAP(NULL, pos=0) ... done
[10:29:53.942] resolve() on list ... DONE
[10:29:53.942]  - Number of value chunks collected: 1
[10:29:53.942] Resolving 1 futures (chunks) ... DONE
[10:29:53.942] Reducing values from 1 chunks ...
[10:29:53.942]  - Number of values collected after concatenation: 3
[10:29:53.943]  - Number of values expected: 3
[10:29:53.943] Reducing values from 1 chunks ... DONE
[10:29:53.943] future_lapply() ... DONE
[10:29:53.943] future_by_internal() ... DONE
[10:29:53.944] future_by_internal() ...
Testing with 1 cores ... DONE
Testing with 2 cores ...
- plan('sequential') ...
[10:29:53.944] plan(): Setting new future strategy stack:
[10:29:53.945] List of future strategies:
[10:29:53.945] 1. sequential:
[10:29:53.945]    - args: function (..., envir = parent.frame())
[10:29:53.945]    - tweaked: FALSE
[10:29:53.945]    - call: plan(strategy)
[10:29:53.945] plan(): nbrOfWorkers() = 1
[10:29:53.945] future_by_internal() ...
[10:29:53.945] future_lapply() ...
[10:29:53.947] Number of chunks: 1
[10:29:53.948] getGlobalsAndPackagesXApply() ...
[10:29:53.948]  - future.globals: TRUE
[10:29:53.948] getGlobalsAndPackages() ...
[10:29:53.948] Searching for globals...
[10:29:53.949] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:53.949] Searching for globals ... DONE
[10:29:53.949] Resolving globals: FALSE
[10:29:53.950] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:53.950] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:53.950] - globals: [1] ‘FUN’
[10:29:53.950] 
[10:29:53.950] getGlobalsAndPackages() ... DONE
[10:29:53.950]  - globals found/used: [n=1] ‘FUN’
[10:29:53.951]  - needed namespaces: [n=0] 
[10:29:53.951] Finding globals ... DONE
[10:29:53.951]  - use_args: TRUE
[10:29:53.951]  - Getting '...' globals ...
[10:29:53.951] resolve() on list ...
[10:29:53.951]  recursive: 0
[10:29:53.951]  length: 1
[10:29:53.951]  elements: ‘...’
[10:29:53.952]  length: 0 (resolved future 1)
[10:29:53.952] resolve() on list ... DONE
[10:29:53.952]    - '...' content: [n=0] 
[10:29:53.952] List of 1
[10:29:53.952]  $ ...: list()
[10:29:53.952]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.952]  - attr(*, "where")=List of 1
[10:29:53.952]   ..$ ...:<environment: 0x556dd53f8ba8> 
[10:29:53.952]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.952]  - attr(*, "resolved")= logi TRUE
[10:29:53.952]  - attr(*, "total_size")= num NA
[10:29:53.954]  - Getting '...' globals ... DONE
[10:29:53.955] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:53.955] List of 2
[10:29:53.955]  $ ...future.FUN:function (object, ...)  
[10:29:53.955]  $ ...          : list()
[10:29:53.955]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.955]  - attr(*, "where")=List of 2
[10:29:53.955]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:53.955]   ..$ ...          :<environment: 0x556dd53f8ba8> 
[10:29:53.955]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.955]  - attr(*, "resolved")= logi FALSE
[10:29:53.955]  - attr(*, "total_size")= num 1240
[10:29:53.957] Packages to be attached in all futures: [n=0] 
[10:29:53.957] getGlobalsAndPackagesXApply() ... DONE
[10:29:53.958] Number of futures (= number of chunks): 1
[10:29:53.958] Launching 1 futures (chunks) ...
[10:29:53.958] Chunk #1 of 1 ...
[10:29:53.958]  - Finding globals in 'X' for chunk #1 ...
[10:29:53.958] getGlobalsAndPackages() ...
[10:29:53.958] Searching for globals...
[10:29:53.959] 
[10:29:53.959] Searching for globals ... DONE
[10:29:53.959] - globals: [0] <none>
[10:29:53.959] getGlobalsAndPackages() ... DONE
[10:29:53.959]    + additional globals found: [n=0] 
[10:29:53.959]    + additional namespaces needed: [n=0] 
[10:29:53.959]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:53.959]  - seeds: <none>
[10:29:53.959]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.959] getGlobalsAndPackages() ...
[10:29:53.960] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.960] Resolving globals: FALSE
[10:29:53.960] Tweak future expression to call with '...' arguments ...
[10:29:53.960] {
[10:29:53.960]     do.call(function(...) {
[10:29:53.960]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.960]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.960]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.960]             on.exit(options(oopts), add = TRUE)
[10:29:53.960]         }
[10:29:53.960]         {
[10:29:53.960]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.960]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.960]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.960]             })
[10:29:53.960]         }
[10:29:53.960]     }, args = future.call.arguments)
[10:29:53.960] }
[10:29:53.960] Tweak future expression to call with '...' arguments ... DONE
[10:29:53.960] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:53.961] 
[10:29:53.961] getGlobalsAndPackages() ... DONE
[10:29:53.961] run() for ‘Future’ ...
[10:29:53.961] - state: ‘created’
[10:29:53.961] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:29:53.961] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.962] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:53.962]   - Field: ‘label’
[10:29:53.962]   - Field: ‘local’
[10:29:53.962]   - Field: ‘owner’
[10:29:53.962]   - Field: ‘envir’
[10:29:53.962]   - Field: ‘packages’
[10:29:53.962]   - Field: ‘gc’
[10:29:53.962]   - Field: ‘conditions’
[10:29:53.962]   - Field: ‘expr’
[10:29:53.962]   - Field: ‘uuid’
[10:29:53.962]   - Field: ‘seed’
[10:29:53.963]   - Field: ‘version’
[10:29:53.963]   - Field: ‘result’
[10:29:53.963]   - Field: ‘asynchronous’
[10:29:53.963]   - Field: ‘calls’
[10:29:53.963]   - Field: ‘globals’
[10:29:53.963]   - Field: ‘stdout’
[10:29:53.963]   - Field: ‘earlySignal’
[10:29:53.963]   - Field: ‘lazy’
[10:29:53.963]   - Field: ‘state’
[10:29:53.963] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:53.963] - Launch lazy future ...
[10:29:53.964] Packages needed by the future expression (n = 0): <none>
[10:29:53.964] Packages needed by future strategies (n = 0): <none>
[10:29:53.964] {
[10:29:53.964]     {
[10:29:53.964]         {
[10:29:53.964]             ...future.startTime <- base::Sys.time()
[10:29:53.964]             {
[10:29:53.964]                 {
[10:29:53.964]                   {
[10:29:53.964]                     base::local({
[10:29:53.964]                       has_future <- base::requireNamespace("future", 
[10:29:53.964]                         quietly = TRUE)
[10:29:53.964]                       if (has_future) {
[10:29:53.964]                         ns <- base::getNamespace("future")
[10:29:53.964]                         version <- ns[[".package"]][["version"]]
[10:29:53.964]                         if (is.null(version)) 
[10:29:53.964]                           version <- utils::packageVersion("future")
[10:29:53.964]                       }
[10:29:53.964]                       else {
[10:29:53.964]                         version <- NULL
[10:29:53.964]                       }
[10:29:53.964]                       if (!has_future || version < "1.8.0") {
[10:29:53.964]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:53.964]                           "", base::R.version$version.string), 
[10:29:53.964]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:53.964]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:53.964]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:53.964]                             "release", "version")], collapse = " "), 
[10:29:53.964]                           hostname = base::Sys.info()[["nodename"]])
[10:29:53.964]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:53.964]                           info)
[10:29:53.964]                         info <- base::paste(info, collapse = "; ")
[10:29:53.964]                         if (!has_future) {
[10:29:53.964]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:53.964]                             info)
[10:29:53.964]                         }
[10:29:53.964]                         else {
[10:29:53.964]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:53.964]                             info, version)
[10:29:53.964]                         }
[10:29:53.964]                         base::stop(msg)
[10:29:53.964]                       }
[10:29:53.964]                     })
[10:29:53.964]                   }
[10:29:53.964]                   ...future.strategy.old <- future::plan("list")
[10:29:53.964]                   options(future.plan = NULL)
[10:29:53.964]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.964]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:53.964]                 }
[10:29:53.964]                 ...future.workdir <- getwd()
[10:29:53.964]             }
[10:29:53.964]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:53.964]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:53.964]         }
[10:29:53.964]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:53.964]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:53.964]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:53.964]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:53.964]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:53.964]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:53.964]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:53.964]             base::names(...future.oldOptions))
[10:29:53.964]     }
[10:29:53.964]     if (FALSE) {
[10:29:53.964]     }
[10:29:53.964]     else {
[10:29:53.964]         if (TRUE) {
[10:29:53.964]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:53.964]                 open = "w")
[10:29:53.964]         }
[10:29:53.964]         else {
[10:29:53.964]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:53.964]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:53.964]         }
[10:29:53.964]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:53.964]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:53.964]             base::sink(type = "output", split = FALSE)
[10:29:53.964]             base::close(...future.stdout)
[10:29:53.964]         }, add = TRUE)
[10:29:53.964]     }
[10:29:53.964]     ...future.frame <- base::sys.nframe()
[10:29:53.964]     ...future.conditions <- base::list()
[10:29:53.964]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:53.964]     if (FALSE) {
[10:29:53.964]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:53.964]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:53.964]     }
[10:29:53.964]     ...future.result <- base::tryCatch({
[10:29:53.964]         base::withCallingHandlers({
[10:29:53.964]             ...future.value <- base::withVisible(base::local({
[10:29:53.964]                 do.call(function(...) {
[10:29:53.964]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.964]                   if (!identical(...future.globals.maxSize.org, 
[10:29:53.964]                     ...future.globals.maxSize)) {
[10:29:53.964]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.964]                     on.exit(options(oopts), add = TRUE)
[10:29:53.964]                   }
[10:29:53.964]                   {
[10:29:53.964]                     lapply(seq_along(...future.elements_ii), 
[10:29:53.964]                       FUN = function(jj) {
[10:29:53.964]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.964]                         ...future.FUN(...future.X_jj, ...)
[10:29:53.964]                       })
[10:29:53.964]                   }
[10:29:53.964]                 }, args = future.call.arguments)
[10:29:53.964]             }))
[10:29:53.964]             future::FutureResult(value = ...future.value$value, 
[10:29:53.964]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.964]                   ...future.rng), globalenv = if (FALSE) 
[10:29:53.964]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:53.964]                     ...future.globalenv.names))
[10:29:53.964]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:53.964]         }, condition = base::local({
[10:29:53.964]             c <- base::c
[10:29:53.964]             inherits <- base::inherits
[10:29:53.964]             invokeRestart <- base::invokeRestart
[10:29:53.964]             length <- base::length
[10:29:53.964]             list <- base::list
[10:29:53.964]             seq.int <- base::seq.int
[10:29:53.964]             signalCondition <- base::signalCondition
[10:29:53.964]             sys.calls <- base::sys.calls
[10:29:53.964]             `[[` <- base::`[[`
[10:29:53.964]             `+` <- base::`+`
[10:29:53.964]             `<<-` <- base::`<<-`
[10:29:53.964]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:53.964]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:53.964]                   3L)]
[10:29:53.964]             }
[10:29:53.964]             function(cond) {
[10:29:53.964]                 is_error <- inherits(cond, "error")
[10:29:53.964]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:53.964]                   NULL)
[10:29:53.964]                 if (is_error) {
[10:29:53.964]                   sessionInformation <- function() {
[10:29:53.964]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:53.964]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:53.964]                       search = base::search(), system = base::Sys.info())
[10:29:53.964]                   }
[10:29:53.964]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.964]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:53.964]                     cond$call), session = sessionInformation(), 
[10:29:53.964]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:53.964]                   signalCondition(cond)
[10:29:53.964]                 }
[10:29:53.964]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:53.964]                 "immediateCondition"))) {
[10:29:53.964]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:53.964]                   ...future.conditions[[length(...future.conditions) + 
[10:29:53.964]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:53.964]                   if (TRUE && !signal) {
[10:29:53.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.964]                     {
[10:29:53.964]                       inherits <- base::inherits
[10:29:53.964]                       invokeRestart <- base::invokeRestart
[10:29:53.964]                       is.null <- base::is.null
[10:29:53.964]                       muffled <- FALSE
[10:29:53.964]                       if (inherits(cond, "message")) {
[10:29:53.964]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.964]                         if (muffled) 
[10:29:53.964]                           invokeRestart("muffleMessage")
[10:29:53.964]                       }
[10:29:53.964]                       else if (inherits(cond, "warning")) {
[10:29:53.964]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.964]                         if (muffled) 
[10:29:53.964]                           invokeRestart("muffleWarning")
[10:29:53.964]                       }
[10:29:53.964]                       else if (inherits(cond, "condition")) {
[10:29:53.964]                         if (!is.null(pattern)) {
[10:29:53.964]                           computeRestarts <- base::computeRestarts
[10:29:53.964]                           grepl <- base::grepl
[10:29:53.964]                           restarts <- computeRestarts(cond)
[10:29:53.964]                           for (restart in restarts) {
[10:29:53.964]                             name <- restart$name
[10:29:53.964]                             if (is.null(name)) 
[10:29:53.964]                               next
[10:29:53.964]                             if (!grepl(pattern, name)) 
[10:29:53.964]                               next
[10:29:53.964]                             invokeRestart(restart)
[10:29:53.964]                             muffled <- TRUE
[10:29:53.964]                             break
[10:29:53.964]                           }
[10:29:53.964]                         }
[10:29:53.964]                       }
[10:29:53.964]                       invisible(muffled)
[10:29:53.964]                     }
[10:29:53.964]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.964]                   }
[10:29:53.964]                 }
[10:29:53.964]                 else {
[10:29:53.964]                   if (TRUE) {
[10:29:53.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:53.964]                     {
[10:29:53.964]                       inherits <- base::inherits
[10:29:53.964]                       invokeRestart <- base::invokeRestart
[10:29:53.964]                       is.null <- base::is.null
[10:29:53.964]                       muffled <- FALSE
[10:29:53.964]                       if (inherits(cond, "message")) {
[10:29:53.964]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:53.964]                         if (muffled) 
[10:29:53.964]                           invokeRestart("muffleMessage")
[10:29:53.964]                       }
[10:29:53.964]                       else if (inherits(cond, "warning")) {
[10:29:53.964]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:53.964]                         if (muffled) 
[10:29:53.964]                           invokeRestart("muffleWarning")
[10:29:53.964]                       }
[10:29:53.964]                       else if (inherits(cond, "condition")) {
[10:29:53.964]                         if (!is.null(pattern)) {
[10:29:53.964]                           computeRestarts <- base::computeRestarts
[10:29:53.964]                           grepl <- base::grepl
[10:29:53.964]                           restarts <- computeRestarts(cond)
[10:29:53.964]                           for (restart in restarts) {
[10:29:53.964]                             name <- restart$name
[10:29:53.964]                             if (is.null(name)) 
[10:29:53.964]                               next
[10:29:53.964]                             if (!grepl(pattern, name)) 
[10:29:53.964]                               next
[10:29:53.964]                             invokeRestart(restart)
[10:29:53.964]                             muffled <- TRUE
[10:29:53.964]                             break
[10:29:53.964]                           }
[10:29:53.964]                         }
[10:29:53.964]                       }
[10:29:53.964]                       invisible(muffled)
[10:29:53.964]                     }
[10:29:53.964]                     muffleCondition(cond, pattern = "^muffle")
[10:29:53.964]                   }
[10:29:53.964]                 }
[10:29:53.964]             }
[10:29:53.964]         }))
[10:29:53.964]     }, error = function(ex) {
[10:29:53.964]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:53.964]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:53.964]                 ...future.rng), started = ...future.startTime, 
[10:29:53.964]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:53.964]             version = "1.8"), class = "FutureResult")
[10:29:53.964]     }, finally = {
[10:29:53.964]         if (!identical(...future.workdir, getwd())) 
[10:29:53.964]             setwd(...future.workdir)
[10:29:53.964]         {
[10:29:53.964]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:53.964]                 ...future.oldOptions$nwarnings <- NULL
[10:29:53.964]             }
[10:29:53.964]             base::options(...future.oldOptions)
[10:29:53.964]             if (.Platform$OS.type == "windows") {
[10:29:53.964]                 old_names <- names(...future.oldEnvVars)
[10:29:53.964]                 envs <- base::Sys.getenv()
[10:29:53.964]                 names <- names(envs)
[10:29:53.964]                 common <- intersect(names, old_names)
[10:29:53.964]                 added <- setdiff(names, old_names)
[10:29:53.964]                 removed <- setdiff(old_names, names)
[10:29:53.964]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:53.964]                   envs[common]]
[10:29:53.964]                 NAMES <- toupper(changed)
[10:29:53.964]                 args <- list()
[10:29:53.964]                 for (kk in seq_along(NAMES)) {
[10:29:53.964]                   name <- changed[[kk]]
[10:29:53.964]                   NAME <- NAMES[[kk]]
[10:29:53.964]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.964]                     next
[10:29:53.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.964]                 }
[10:29:53.964]                 NAMES <- toupper(added)
[10:29:53.964]                 for (kk in seq_along(NAMES)) {
[10:29:53.964]                   name <- added[[kk]]
[10:29:53.964]                   NAME <- NAMES[[kk]]
[10:29:53.964]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.964]                     next
[10:29:53.964]                   args[[name]] <- ""
[10:29:53.964]                 }
[10:29:53.964]                 NAMES <- toupper(removed)
[10:29:53.964]                 for (kk in seq_along(NAMES)) {
[10:29:53.964]                   name <- removed[[kk]]
[10:29:53.964]                   NAME <- NAMES[[kk]]
[10:29:53.964]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:53.964]                     next
[10:29:53.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:53.964]                 }
[10:29:53.964]                 if (length(args) > 0) 
[10:29:53.964]                   base::do.call(base::Sys.setenv, args = args)
[10:29:53.964]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:53.964]             }
[10:29:53.964]             else {
[10:29:53.964]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:53.964]             }
[10:29:53.964]             {
[10:29:53.964]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:53.964]                   0L) {
[10:29:53.964]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:53.964]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:53.964]                   base::options(opts)
[10:29:53.964]                 }
[10:29:53.964]                 {
[10:29:53.964]                   {
[10:29:53.964]                     NULL
[10:29:53.964]                     RNGkind("Mersenne-Twister")
[10:29:53.964]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:53.964]                       inherits = FALSE)
[10:29:53.964]                   }
[10:29:53.964]                   options(future.plan = NULL)
[10:29:53.964]                   if (is.na(NA_character_)) 
[10:29:53.964]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:53.964]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:53.964]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:53.964]                     .init = FALSE)
[10:29:53.964]                 }
[10:29:53.964]             }
[10:29:53.964]         }
[10:29:53.964]     })
[10:29:53.964]     if (TRUE) {
[10:29:53.964]         base::sink(type = "output", split = FALSE)
[10:29:53.964]         if (TRUE) {
[10:29:53.964]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:53.964]         }
[10:29:53.964]         else {
[10:29:53.964]             ...future.result["stdout"] <- base::list(NULL)
[10:29:53.964]         }
[10:29:53.964]         base::close(...future.stdout)
[10:29:53.964]         ...future.stdout <- NULL
[10:29:53.964]     }
[10:29:53.964]     ...future.result$conditions <- ...future.conditions
[10:29:53.964]     ...future.result$finished <- base::Sys.time()
[10:29:53.964]     ...future.result
[10:29:53.964] }
[10:29:53.966] assign_globals() ...
[10:29:53.966] List of 5
[10:29:53.966]  $ ...future.FUN            :function (object, ...)  
[10:29:53.966]  $ future.call.arguments    : list()
[10:29:53.966]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.966]  $ ...future.elements_ii    :List of 3
[10:29:53.966]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:29:53.966]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:29:53.966]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.966]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:29:53.966]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:29:53.966]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.966]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:29:53.966]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:29:53.966]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:53.966]  $ ...future.seeds_ii       : NULL
[10:29:53.966]  $ ...future.globals.maxSize: NULL
[10:29:53.966]  - attr(*, "where")=List of 5
[10:29:53.966]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:53.966]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:53.966]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:53.966]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:53.966]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:53.966]  - attr(*, "resolved")= logi FALSE
[10:29:53.966]  - attr(*, "total_size")= num 1240
[10:29:53.966]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.966]  - attr(*, "already-done")= logi TRUE
[10:29:53.975] - copied ‘...future.FUN’ to environment
[10:29:53.975] - copied ‘future.call.arguments’ to environment
[10:29:53.975] - copied ‘...future.elements_ii’ to environment
[10:29:53.975] - copied ‘...future.seeds_ii’ to environment
[10:29:53.975] - copied ‘...future.globals.maxSize’ to environment
[10:29:53.976] assign_globals() ... done
[10:29:53.976] plan(): Setting new future strategy stack:
[10:29:53.976] List of future strategies:
[10:29:53.976] 1. sequential:
[10:29:53.976]    - args: function (..., envir = parent.frame())
[10:29:53.976]    - tweaked: FALSE
[10:29:53.976]    - call: NULL
[10:29:53.976] plan(): nbrOfWorkers() = 1
[10:29:53.978] plan(): Setting new future strategy stack:
[10:29:53.978] List of future strategies:
[10:29:53.978] 1. sequential:
[10:29:53.978]    - args: function (..., envir = parent.frame())
[10:29:53.978]    - tweaked: FALSE
[10:29:53.978]    - call: plan(strategy)
[10:29:53.979] plan(): nbrOfWorkers() = 1
[10:29:53.979] SequentialFuture started (and completed)
[10:29:53.979] - Launch lazy future ... done
[10:29:53.979] run() for ‘SequentialFuture’ ... done
[10:29:53.979] Created future:
[10:29:53.979] SequentialFuture:
[10:29:53.979] Label: ‘future_by-1’
[10:29:53.979] Expression:
[10:29:53.979] {
[10:29:53.979]     do.call(function(...) {
[10:29:53.979]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:53.979]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:53.979]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:53.979]             on.exit(options(oopts), add = TRUE)
[10:29:53.979]         }
[10:29:53.979]         {
[10:29:53.979]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:53.979]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:53.979]                 ...future.FUN(...future.X_jj, ...)
[10:29:53.979]             })
[10:29:53.979]         }
[10:29:53.979]     }, args = future.call.arguments)
[10:29:53.979] }
[10:29:53.979] Lazy evaluation: FALSE
[10:29:53.979] Asynchronous evaluation: FALSE
[10:29:53.979] Local evaluation: TRUE
[10:29:53.979] Environment: R_GlobalEnv
[10:29:53.979] Capture standard output: TRUE
[10:29:53.979] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:53.979] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:53.979] Packages: <none>
[10:29:53.979] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:53.979] Resolved: TRUE
[10:29:53.979] Value: 4.62 KiB of class ‘list’
[10:29:53.979] Early signaling: FALSE
[10:29:53.979] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:53.979] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:53.980] Chunk #1 of 1 ... DONE
[10:29:53.980] Launching 1 futures (chunks) ... DONE
[10:29:53.980] Resolving 1 futures (chunks) ...
[10:29:53.981] resolve() on list ...
[10:29:53.981]  recursive: 0
[10:29:53.981]  length: 1
[10:29:53.981] 
[10:29:53.981] resolved() for ‘SequentialFuture’ ...
[10:29:53.981] - state: ‘finished’
[10:29:53.981] - run: TRUE
[10:29:53.981] - result: ‘FutureResult’
[10:29:53.981] resolved() for ‘SequentialFuture’ ... done
[10:29:53.981] Future #1
[10:29:53.982] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:53.982] - nx: 1
[10:29:53.982] - relay: TRUE
[10:29:53.982] - stdout: TRUE
[10:29:53.982] - signal: TRUE
[10:29:53.982] - resignal: FALSE
[10:29:53.982] - force: TRUE
[10:29:53.982] - relayed: [n=1] FALSE
[10:29:53.982] - queued futures: [n=1] FALSE
[10:29:53.982]  - until=1
[10:29:53.982]  - relaying element #1
[10:29:53.983] - relayed: [n=1] TRUE
[10:29:53.983] - queued futures: [n=1] TRUE
[10:29:53.983] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:53.983]  length: 0 (resolved future 1)
[10:29:53.983] Relaying remaining futures
[10:29:53.983] signalConditionsASAP(NULL, pos=0) ...
[10:29:53.983] - nx: 1
[10:29:53.983] - relay: TRUE
[10:29:53.983] - stdout: TRUE
[10:29:53.983] - signal: TRUE
[10:29:53.983] - resignal: FALSE
[10:29:53.984] - force: TRUE
[10:29:53.984] - relayed: [n=1] TRUE
[10:29:53.984] - queued futures: [n=1] TRUE
 - flush all
[10:29:53.984] - relayed: [n=1] TRUE
[10:29:53.984] - queued futures: [n=1] TRUE
[10:29:53.984] signalConditionsASAP(NULL, pos=0) ... done
[10:29:53.984] resolve() on list ... DONE
[10:29:53.984]  - Number of value chunks collected: 1
[10:29:53.984] Resolving 1 futures (chunks) ... DONE
[10:29:53.984] Reducing values from 1 chunks ...
[10:29:53.985]  - Number of values collected after concatenation: 3
[10:29:53.985]  - Number of values expected: 3
[10:29:53.985] Reducing values from 1 chunks ... DONE
[10:29:53.985] future_lapply() ... DONE
[10:29:53.985] future_by_internal() ... DONE
[10:29:53.985] future_by_internal() ...
[10:29:53.985] future_lapply() ...
[10:29:53.986] Number of chunks: 1
[10:29:53.986] getGlobalsAndPackagesXApply() ...
[10:29:53.986]  - future.globals: TRUE
[10:29:53.986] getGlobalsAndPackages() ...
[10:29:53.986] Searching for globals...
[10:29:53.987] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:53.987] Searching for globals ... DONE
[10:29:53.988] Resolving globals: FALSE
[10:29:53.988] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:53.988] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:53.988] - globals: [1] ‘FUN’
[10:29:53.988] 
[10:29:53.988] getGlobalsAndPackages() ... DONE
[10:29:53.989]  - globals found/used: [n=1] ‘FUN’
[10:29:53.990]  - needed namespaces: [n=0] 
[10:29:53.990] Finding globals ... DONE
[10:29:53.990]  - use_args: TRUE
[10:29:53.990]  - Getting '...' globals ...
[10:29:53.991] resolve() on list ...
[10:29:53.991]  recursive: 0
[10:29:53.991]  length: 1
[10:29:53.991]  elements: ‘...’
[10:29:53.991]  length: 0 (resolved future 1)
[10:29:53.991] resolve() on list ... DONE
[10:29:53.991]    - '...' content: [n=1] ‘digits’
[10:29:53.991] List of 1
[10:29:53.991]  $ ...:List of 1
[10:29:53.991]   ..$ digits: int 2
[10:29:53.991]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.991]  - attr(*, "where")=List of 1
[10:29:53.991]   ..$ ...:<environment: 0x556dd513c158> 
[10:29:53.991]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.991]  - attr(*, "resolved")= logi TRUE
[10:29:53.991]  - attr(*, "total_size")= num NA
[10:29:53.995]  - Getting '...' globals ... DONE
[10:29:53.995] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:53.995] List of 2
[10:29:53.995]  $ ...future.FUN:function (object, ...)  
[10:29:53.995]  $ ...          :List of 1
[10:29:53.995]   ..$ digits: int 2
[10:29:53.995]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:53.995]  - attr(*, "where")=List of 2
[10:29:53.995]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:53.995]   ..$ ...          :<environment: 0x556dd513c158> 
[10:29:53.995]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:53.995]  - attr(*, "resolved")= logi FALSE
[10:29:53.995]  - attr(*, "total_size")= num 1296
[10:29:53.998] Packages to be attached in all futures: [n=0] 
[10:29:53.998] getGlobalsAndPackagesXApply() ... DONE
[10:29:53.998] Number of futures (= number of chunks): 1
[10:29:53.998] Launching 1 futures (chunks) ...
[10:29:53.998] Chunk #1 of 1 ...
[10:29:53.998]  - Finding globals in 'X' for chunk #1 ...
[10:29:53.999] getGlobalsAndPackages() ...
[10:29:53.999] Searching for globals...
[10:29:53.999] 
[10:29:53.999] Searching for globals ... DONE
[10:29:53.999] - globals: [0] <none>
[10:29:53.999] getGlobalsAndPackages() ... DONE
[10:29:53.999]    + additional globals found: [n=0] 
[10:29:53.999]    + additional namespaces needed: [n=0] 
[10:29:53.999]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:53.999]  - seeds: <none>
[10:29:54.000]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.000] getGlobalsAndPackages() ...
[10:29:54.000] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.000] Resolving globals: FALSE
[10:29:54.000] Tweak future expression to call with '...' arguments ...
[10:29:54.000] {
[10:29:54.000]     do.call(function(...) {
[10:29:54.000]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.000]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.000]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.000]             on.exit(options(oopts), add = TRUE)
[10:29:54.000]         }
[10:29:54.000]         {
[10:29:54.000]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.000]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.000]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.000]             })
[10:29:54.000]         }
[10:29:54.000]     }, args = future.call.arguments)
[10:29:54.000] }
[10:29:54.000] Tweak future expression to call with '...' arguments ... DONE
[10:29:54.001] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.001] 
[10:29:54.001] getGlobalsAndPackages() ... DONE
[10:29:54.001] run() for ‘Future’ ...
[10:29:54.001] - state: ‘created’
[10:29:54.001] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:29:54.002] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:54.002] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:54.002]   - Field: ‘label’
[10:29:54.002]   - Field: ‘local’
[10:29:54.002]   - Field: ‘owner’
[10:29:54.002]   - Field: ‘envir’
[10:29:54.002]   - Field: ‘packages’
[10:29:54.002]   - Field: ‘gc’
[10:29:54.002]   - Field: ‘conditions’
[10:29:54.002]   - Field: ‘expr’
[10:29:54.003]   - Field: ‘uuid’
[10:29:54.003]   - Field: ‘seed’
[10:29:54.003]   - Field: ‘version’
[10:29:54.003]   - Field: ‘result’
[10:29:54.003]   - Field: ‘asynchronous’
[10:29:54.003]   - Field: ‘calls’
[10:29:54.003]   - Field: ‘globals’
[10:29:54.003]   - Field: ‘stdout’
[10:29:54.003]   - Field: ‘earlySignal’
[10:29:54.003]   - Field: ‘lazy’
[10:29:54.003]   - Field: ‘state’
[10:29:54.004] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:54.004] - Launch lazy future ...
[10:29:54.004] Packages needed by the future expression (n = 0): <none>
[10:29:54.004] Packages needed by future strategies (n = 0): <none>
[10:29:54.004] {
[10:29:54.004]     {
[10:29:54.004]         {
[10:29:54.004]             ...future.startTime <- base::Sys.time()
[10:29:54.004]             {
[10:29:54.004]                 {
[10:29:54.004]                   {
[10:29:54.004]                     base::local({
[10:29:54.004]                       has_future <- base::requireNamespace("future", 
[10:29:54.004]                         quietly = TRUE)
[10:29:54.004]                       if (has_future) {
[10:29:54.004]                         ns <- base::getNamespace("future")
[10:29:54.004]                         version <- ns[[".package"]][["version"]]
[10:29:54.004]                         if (is.null(version)) 
[10:29:54.004]                           version <- utils::packageVersion("future")
[10:29:54.004]                       }
[10:29:54.004]                       else {
[10:29:54.004]                         version <- NULL
[10:29:54.004]                       }
[10:29:54.004]                       if (!has_future || version < "1.8.0") {
[10:29:54.004]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:54.004]                           "", base::R.version$version.string), 
[10:29:54.004]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:54.004]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:54.004]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:54.004]                             "release", "version")], collapse = " "), 
[10:29:54.004]                           hostname = base::Sys.info()[["nodename"]])
[10:29:54.004]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:54.004]                           info)
[10:29:54.004]                         info <- base::paste(info, collapse = "; ")
[10:29:54.004]                         if (!has_future) {
[10:29:54.004]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:54.004]                             info)
[10:29:54.004]                         }
[10:29:54.004]                         else {
[10:29:54.004]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:54.004]                             info, version)
[10:29:54.004]                         }
[10:29:54.004]                         base::stop(msg)
[10:29:54.004]                       }
[10:29:54.004]                     })
[10:29:54.004]                   }
[10:29:54.004]                   ...future.strategy.old <- future::plan("list")
[10:29:54.004]                   options(future.plan = NULL)
[10:29:54.004]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.004]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:54.004]                 }
[10:29:54.004]                 ...future.workdir <- getwd()
[10:29:54.004]             }
[10:29:54.004]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:54.004]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:54.004]         }
[10:29:54.004]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:54.004]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:54.004]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:54.004]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:54.004]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:54.004]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:54.004]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:54.004]             base::names(...future.oldOptions))
[10:29:54.004]     }
[10:29:54.004]     if (FALSE) {
[10:29:54.004]     }
[10:29:54.004]     else {
[10:29:54.004]         if (TRUE) {
[10:29:54.004]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:54.004]                 open = "w")
[10:29:54.004]         }
[10:29:54.004]         else {
[10:29:54.004]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:54.004]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:54.004]         }
[10:29:54.004]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:54.004]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:54.004]             base::sink(type = "output", split = FALSE)
[10:29:54.004]             base::close(...future.stdout)
[10:29:54.004]         }, add = TRUE)
[10:29:54.004]     }
[10:29:54.004]     ...future.frame <- base::sys.nframe()
[10:29:54.004]     ...future.conditions <- base::list()
[10:29:54.004]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:54.004]     if (FALSE) {
[10:29:54.004]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:54.004]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:54.004]     }
[10:29:54.004]     ...future.result <- base::tryCatch({
[10:29:54.004]         base::withCallingHandlers({
[10:29:54.004]             ...future.value <- base::withVisible(base::local({
[10:29:54.004]                 do.call(function(...) {
[10:29:54.004]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.004]                   if (!identical(...future.globals.maxSize.org, 
[10:29:54.004]                     ...future.globals.maxSize)) {
[10:29:54.004]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.004]                     on.exit(options(oopts), add = TRUE)
[10:29:54.004]                   }
[10:29:54.004]                   {
[10:29:54.004]                     lapply(seq_along(...future.elements_ii), 
[10:29:54.004]                       FUN = function(jj) {
[10:29:54.004]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.004]                         ...future.FUN(...future.X_jj, ...)
[10:29:54.004]                       })
[10:29:54.004]                   }
[10:29:54.004]                 }, args = future.call.arguments)
[10:29:54.004]             }))
[10:29:54.004]             future::FutureResult(value = ...future.value$value, 
[10:29:54.004]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.004]                   ...future.rng), globalenv = if (FALSE) 
[10:29:54.004]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:54.004]                     ...future.globalenv.names))
[10:29:54.004]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:54.004]         }, condition = base::local({
[10:29:54.004]             c <- base::c
[10:29:54.004]             inherits <- base::inherits
[10:29:54.004]             invokeRestart <- base::invokeRestart
[10:29:54.004]             length <- base::length
[10:29:54.004]             list <- base::list
[10:29:54.004]             seq.int <- base::seq.int
[10:29:54.004]             signalCondition <- base::signalCondition
[10:29:54.004]             sys.calls <- base::sys.calls
[10:29:54.004]             `[[` <- base::`[[`
[10:29:54.004]             `+` <- base::`+`
[10:29:54.004]             `<<-` <- base::`<<-`
[10:29:54.004]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:54.004]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:54.004]                   3L)]
[10:29:54.004]             }
[10:29:54.004]             function(cond) {
[10:29:54.004]                 is_error <- inherits(cond, "error")
[10:29:54.004]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:54.004]                   NULL)
[10:29:54.004]                 if (is_error) {
[10:29:54.004]                   sessionInformation <- function() {
[10:29:54.004]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:54.004]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:54.004]                       search = base::search(), system = base::Sys.info())
[10:29:54.004]                   }
[10:29:54.004]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.004]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:54.004]                     cond$call), session = sessionInformation(), 
[10:29:54.004]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:54.004]                   signalCondition(cond)
[10:29:54.004]                 }
[10:29:54.004]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:54.004]                 "immediateCondition"))) {
[10:29:54.004]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:54.004]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.004]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:54.004]                   if (TRUE && !signal) {
[10:29:54.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.004]                     {
[10:29:54.004]                       inherits <- base::inherits
[10:29:54.004]                       invokeRestart <- base::invokeRestart
[10:29:54.004]                       is.null <- base::is.null
[10:29:54.004]                       muffled <- FALSE
[10:29:54.004]                       if (inherits(cond, "message")) {
[10:29:54.004]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.004]                         if (muffled) 
[10:29:54.004]                           invokeRestart("muffleMessage")
[10:29:54.004]                       }
[10:29:54.004]                       else if (inherits(cond, "warning")) {
[10:29:54.004]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.004]                         if (muffled) 
[10:29:54.004]                           invokeRestart("muffleWarning")
[10:29:54.004]                       }
[10:29:54.004]                       else if (inherits(cond, "condition")) {
[10:29:54.004]                         if (!is.null(pattern)) {
[10:29:54.004]                           computeRestarts <- base::computeRestarts
[10:29:54.004]                           grepl <- base::grepl
[10:29:54.004]                           restarts <- computeRestarts(cond)
[10:29:54.004]                           for (restart in restarts) {
[10:29:54.004]                             name <- restart$name
[10:29:54.004]                             if (is.null(name)) 
[10:29:54.004]                               next
[10:29:54.004]                             if (!grepl(pattern, name)) 
[10:29:54.004]                               next
[10:29:54.004]                             invokeRestart(restart)
[10:29:54.004]                             muffled <- TRUE
[10:29:54.004]                             break
[10:29:54.004]                           }
[10:29:54.004]                         }
[10:29:54.004]                       }
[10:29:54.004]                       invisible(muffled)
[10:29:54.004]                     }
[10:29:54.004]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.004]                   }
[10:29:54.004]                 }
[10:29:54.004]                 else {
[10:29:54.004]                   if (TRUE) {
[10:29:54.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.004]                     {
[10:29:54.004]                       inherits <- base::inherits
[10:29:54.004]                       invokeRestart <- base::invokeRestart
[10:29:54.004]                       is.null <- base::is.null
[10:29:54.004]                       muffled <- FALSE
[10:29:54.004]                       if (inherits(cond, "message")) {
[10:29:54.004]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.004]                         if (muffled) 
[10:29:54.004]                           invokeRestart("muffleMessage")
[10:29:54.004]                       }
[10:29:54.004]                       else if (inherits(cond, "warning")) {
[10:29:54.004]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.004]                         if (muffled) 
[10:29:54.004]                           invokeRestart("muffleWarning")
[10:29:54.004]                       }
[10:29:54.004]                       else if (inherits(cond, "condition")) {
[10:29:54.004]                         if (!is.null(pattern)) {
[10:29:54.004]                           computeRestarts <- base::computeRestarts
[10:29:54.004]                           grepl <- base::grepl
[10:29:54.004]                           restarts <- computeRestarts(cond)
[10:29:54.004]                           for (restart in restarts) {
[10:29:54.004]                             name <- restart$name
[10:29:54.004]                             if (is.null(name)) 
[10:29:54.004]                               next
[10:29:54.004]                             if (!grepl(pattern, name)) 
[10:29:54.004]                               next
[10:29:54.004]                             invokeRestart(restart)
[10:29:54.004]                             muffled <- TRUE
[10:29:54.004]                             break
[10:29:54.004]                           }
[10:29:54.004]                         }
[10:29:54.004]                       }
[10:29:54.004]                       invisible(muffled)
[10:29:54.004]                     }
[10:29:54.004]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.004]                   }
[10:29:54.004]                 }
[10:29:54.004]             }
[10:29:54.004]         }))
[10:29:54.004]     }, error = function(ex) {
[10:29:54.004]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:54.004]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.004]                 ...future.rng), started = ...future.startTime, 
[10:29:54.004]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:54.004]             version = "1.8"), class = "FutureResult")
[10:29:54.004]     }, finally = {
[10:29:54.004]         if (!identical(...future.workdir, getwd())) 
[10:29:54.004]             setwd(...future.workdir)
[10:29:54.004]         {
[10:29:54.004]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:54.004]                 ...future.oldOptions$nwarnings <- NULL
[10:29:54.004]             }
[10:29:54.004]             base::options(...future.oldOptions)
[10:29:54.004]             if (.Platform$OS.type == "windows") {
[10:29:54.004]                 old_names <- names(...future.oldEnvVars)
[10:29:54.004]                 envs <- base::Sys.getenv()
[10:29:54.004]                 names <- names(envs)
[10:29:54.004]                 common <- intersect(names, old_names)
[10:29:54.004]                 added <- setdiff(names, old_names)
[10:29:54.004]                 removed <- setdiff(old_names, names)
[10:29:54.004]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:54.004]                   envs[common]]
[10:29:54.004]                 NAMES <- toupper(changed)
[10:29:54.004]                 args <- list()
[10:29:54.004]                 for (kk in seq_along(NAMES)) {
[10:29:54.004]                   name <- changed[[kk]]
[10:29:54.004]                   NAME <- NAMES[[kk]]
[10:29:54.004]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.004]                     next
[10:29:54.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.004]                 }
[10:29:54.004]                 NAMES <- toupper(added)
[10:29:54.004]                 for (kk in seq_along(NAMES)) {
[10:29:54.004]                   name <- added[[kk]]
[10:29:54.004]                   NAME <- NAMES[[kk]]
[10:29:54.004]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.004]                     next
[10:29:54.004]                   args[[name]] <- ""
[10:29:54.004]                 }
[10:29:54.004]                 NAMES <- toupper(removed)
[10:29:54.004]                 for (kk in seq_along(NAMES)) {
[10:29:54.004]                   name <- removed[[kk]]
[10:29:54.004]                   NAME <- NAMES[[kk]]
[10:29:54.004]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.004]                     next
[10:29:54.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.004]                 }
[10:29:54.004]                 if (length(args) > 0) 
[10:29:54.004]                   base::do.call(base::Sys.setenv, args = args)
[10:29:54.004]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:54.004]             }
[10:29:54.004]             else {
[10:29:54.004]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:54.004]             }
[10:29:54.004]             {
[10:29:54.004]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:54.004]                   0L) {
[10:29:54.004]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:54.004]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:54.004]                   base::options(opts)
[10:29:54.004]                 }
[10:29:54.004]                 {
[10:29:54.004]                   {
[10:29:54.004]                     NULL
[10:29:54.004]                     RNGkind("Mersenne-Twister")
[10:29:54.004]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:54.004]                       inherits = FALSE)
[10:29:54.004]                   }
[10:29:54.004]                   options(future.plan = NULL)
[10:29:54.004]                   if (is.na(NA_character_)) 
[10:29:54.004]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.004]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:54.004]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:54.004]                     .init = FALSE)
[10:29:54.004]                 }
[10:29:54.004]             }
[10:29:54.004]         }
[10:29:54.004]     })
[10:29:54.004]     if (TRUE) {
[10:29:54.004]         base::sink(type = "output", split = FALSE)
[10:29:54.004]         if (TRUE) {
[10:29:54.004]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:54.004]         }
[10:29:54.004]         else {
[10:29:54.004]             ...future.result["stdout"] <- base::list(NULL)
[10:29:54.004]         }
[10:29:54.004]         base::close(...future.stdout)
[10:29:54.004]         ...future.stdout <- NULL
[10:29:54.004]     }
[10:29:54.004]     ...future.result$conditions <- ...future.conditions
[10:29:54.004]     ...future.result$finished <- base::Sys.time()
[10:29:54.004]     ...future.result
[10:29:54.004] }
[10:29:54.006] assign_globals() ...
[10:29:54.006] List of 5
[10:29:54.006]  $ ...future.FUN            :function (object, ...)  
[10:29:54.006]  $ future.call.arguments    :List of 1
[10:29:54.006]   ..$ digits: int 2
[10:29:54.006]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.006]  $ ...future.elements_ii    :List of 6
[10:29:54.006]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[10:29:54.006]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[10:29:54.006]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[10:29:54.006]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[10:29:54.006]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[10:29:54.006]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[10:29:54.006]  $ ...future.seeds_ii       : NULL
[10:29:54.006]  $ ...future.globals.maxSize: NULL
[10:29:54.006]  - attr(*, "where")=List of 5
[10:29:54.006]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:54.006]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:54.006]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:54.006]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:54.006]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:54.006]  - attr(*, "resolved")= logi FALSE
[10:29:54.006]  - attr(*, "total_size")= num 1296
[10:29:54.006]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.006]  - attr(*, "already-done")= logi TRUE
[10:29:54.014] - copied ‘...future.FUN’ to environment
[10:29:54.014] - copied ‘future.call.arguments’ to environment
[10:29:54.014] - copied ‘...future.elements_ii’ to environment
[10:29:54.014] - copied ‘...future.seeds_ii’ to environment
[10:29:54.014] - copied ‘...future.globals.maxSize’ to environment
[10:29:54.014] assign_globals() ... done
[10:29:54.015] plan(): Setting new future strategy stack:
[10:29:54.015] List of future strategies:
[10:29:54.015] 1. sequential:
[10:29:54.015]    - args: function (..., envir = parent.frame())
[10:29:54.015]    - tweaked: FALSE
[10:29:54.015]    - call: NULL
[10:29:54.015] plan(): nbrOfWorkers() = 1
[10:29:54.016] plan(): Setting new future strategy stack:
[10:29:54.017] List of future strategies:
[10:29:54.017] 1. sequential:
[10:29:54.017]    - args: function (..., envir = parent.frame())
[10:29:54.017]    - tweaked: FALSE
[10:29:54.017]    - call: plan(strategy)
[10:29:54.017] plan(): nbrOfWorkers() = 1
[10:29:54.017] SequentialFuture started (and completed)
[10:29:54.017] - Launch lazy future ... done
[10:29:54.017] run() for ‘SequentialFuture’ ... done
[10:29:54.017] Created future:
[10:29:54.017] SequentialFuture:
[10:29:54.017] Label: ‘future_by-1’
[10:29:54.017] Expression:
[10:29:54.017] {
[10:29:54.017]     do.call(function(...) {
[10:29:54.017]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.017]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.017]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.017]             on.exit(options(oopts), add = TRUE)
[10:29:54.017]         }
[10:29:54.017]         {
[10:29:54.017]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.017]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.017]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.017]             })
[10:29:54.017]         }
[10:29:54.017]     }, args = future.call.arguments)
[10:29:54.017] }
[10:29:54.017] Lazy evaluation: FALSE
[10:29:54.017] Asynchronous evaluation: FALSE
[10:29:54.017] Local evaluation: TRUE
[10:29:54.017] Environment: R_GlobalEnv
[10:29:54.017] Capture standard output: TRUE
[10:29:54.017] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:54.017] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:54.017] Packages: <none>
[10:29:54.017] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:54.017] Resolved: TRUE
[10:29:54.017] Value: 5.48 KiB of class ‘list’
[10:29:54.017] Early signaling: FALSE
[10:29:54.017] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:54.017] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:54.019] Chunk #1 of 1 ... DONE
[10:29:54.019] Launching 1 futures (chunks) ... DONE
[10:29:54.019] Resolving 1 futures (chunks) ...
[10:29:54.019] resolve() on list ...
[10:29:54.019]  recursive: 0
[10:29:54.019]  length: 1
[10:29:54.019] 
[10:29:54.019] resolved() for ‘SequentialFuture’ ...
[10:29:54.019] - state: ‘finished’
[10:29:54.019] - run: TRUE
[10:29:54.019] - result: ‘FutureResult’
[10:29:54.020] resolved() for ‘SequentialFuture’ ... done
[10:29:54.020] Future #1
[10:29:54.020] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:54.020] - nx: 1
[10:29:54.020] - relay: TRUE
[10:29:54.020] - stdout: TRUE
[10:29:54.020] - signal: TRUE
[10:29:54.020] - resignal: FALSE
[10:29:54.020] - force: TRUE
[10:29:54.020] - relayed: [n=1] FALSE
[10:29:54.020] - queued futures: [n=1] FALSE
[10:29:54.021]  - until=1
[10:29:54.021]  - relaying element #1
[10:29:54.021] - relayed: [n=1] TRUE
[10:29:54.021] - queued futures: [n=1] TRUE
[10:29:54.021] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:54.021]  length: 0 (resolved future 1)
[10:29:54.021] Relaying remaining futures
[10:29:54.021] signalConditionsASAP(NULL, pos=0) ...
[10:29:54.021] - nx: 1
[10:29:54.021] - relay: TRUE
[10:29:54.022] - stdout: TRUE
[10:29:54.022] - signal: TRUE
[10:29:54.022] - resignal: FALSE
[10:29:54.022] - force: TRUE
[10:29:54.022] - relayed: [n=1] TRUE
[10:29:54.022] - queued futures: [n=1] TRUE
 - flush all
[10:29:54.022] - relayed: [n=1] TRUE
[10:29:54.022] - queued futures: [n=1] TRUE
[10:29:54.022] signalConditionsASAP(NULL, pos=0) ... done
[10:29:54.022] resolve() on list ... DONE
[10:29:54.023]  - Number of value chunks collected: 1
[10:29:54.023] Resolving 1 futures (chunks) ... DONE
[10:29:54.023] Reducing values from 1 chunks ...
[10:29:54.023]  - Number of values collected after concatenation: 6
[10:29:54.023]  - Number of values expected: 6
[10:29:54.023] Reducing values from 1 chunks ... DONE
[10:29:54.023] future_lapply() ... DONE
[10:29:54.023] future_by_internal() ... DONE
[10:29:54.024] future_by_internal() ...
[10:29:54.024] future_lapply() ...
[10:29:54.025] Number of chunks: 1
[10:29:54.025] getGlobalsAndPackagesXApply() ...
[10:29:54.026]  - future.globals: TRUE
[10:29:54.026] getGlobalsAndPackages() ...
[10:29:54.026] Searching for globals...
[10:29:54.027] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:29:54.027] Searching for globals ... DONE
[10:29:54.027] Resolving globals: FALSE
[10:29:54.028] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[10:29:54.028] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[10:29:54.028] - globals: [1] ‘FUN’
[10:29:54.028] - packages: [1] ‘stats’
[10:29:54.029] getGlobalsAndPackages() ... DONE
[10:29:54.029]  - globals found/used: [n=1] ‘FUN’
[10:29:54.029]  - needed namespaces: [n=1] ‘stats’
[10:29:54.029] Finding globals ... DONE
[10:29:54.029]  - use_args: TRUE
[10:29:54.031]  - Getting '...' globals ...
[10:29:54.031] resolve() on list ...
[10:29:54.031]  recursive: 0
[10:29:54.031]  length: 1
[10:29:54.031]  elements: ‘...’
[10:29:54.031]  length: 0 (resolved future 1)
[10:29:54.031] resolve() on list ... DONE
[10:29:54.032]    - '...' content: [n=1] ‘singular.ok’
[10:29:54.032] List of 1
[10:29:54.032]  $ ...:List of 1
[10:29:54.032]   ..$ singular.ok: logi FALSE
[10:29:54.032]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.032]  - attr(*, "where")=List of 1
[10:29:54.032]   ..$ ...:<environment: 0x556dd5011888> 
[10:29:54.032]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.032]  - attr(*, "resolved")= logi TRUE
[10:29:54.032]  - attr(*, "total_size")= num NA
[10:29:54.035]  - Getting '...' globals ... DONE
[10:29:54.035] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:54.035] List of 2
[10:29:54.035]  $ ...future.FUN:function (x, ...)  
[10:29:54.035]  $ ...          :List of 1
[10:29:54.035]   ..$ singular.ok: logi FALSE
[10:29:54.035]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.035]  - attr(*, "where")=List of 2
[10:29:54.035]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:54.035]   ..$ ...          :<environment: 0x556dd5011888> 
[10:29:54.035]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.035]  - attr(*, "resolved")= logi FALSE
[10:29:54.035]  - attr(*, "total_size")= num 5384
[10:29:54.038] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:54.038] getGlobalsAndPackagesXApply() ... DONE
[10:29:54.038] Number of futures (= number of chunks): 1
[10:29:54.038] Launching 1 futures (chunks) ...
[10:29:54.039] Chunk #1 of 1 ...
[10:29:54.039]  - Finding globals in 'X' for chunk #1 ...
[10:29:54.039] getGlobalsAndPackages() ...
[10:29:54.039] Searching for globals...
[10:29:54.039] 
[10:29:54.039] Searching for globals ... DONE
[10:29:54.040] - globals: [0] <none>
[10:29:54.040] getGlobalsAndPackages() ... DONE
[10:29:54.040]    + additional globals found: [n=0] 
[10:29:54.040]    + additional namespaces needed: [n=0] 
[10:29:54.040]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:54.040]  - seeds: <none>
[10:29:54.040]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.040] getGlobalsAndPackages() ...
[10:29:54.040] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.040] Resolving globals: FALSE
[10:29:54.041] Tweak future expression to call with '...' arguments ...
[10:29:54.041] {
[10:29:54.041]     do.call(function(...) {
[10:29:54.041]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.041]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.041]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.041]             on.exit(options(oopts), add = TRUE)
[10:29:54.041]         }
[10:29:54.041]         {
[10:29:54.041]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.041]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.041]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.041]             })
[10:29:54.041]         }
[10:29:54.041]     }, args = future.call.arguments)
[10:29:54.041] }
[10:29:54.041] Tweak future expression to call with '...' arguments ... DONE
[10:29:54.041] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.041] 
[10:29:54.041] getGlobalsAndPackages() ... DONE
[10:29:54.042] run() for ‘Future’ ...
[10:29:54.042] - state: ‘created’
[10:29:54.042] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:29:54.042] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:54.042] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:54.042]   - Field: ‘label’
[10:29:54.043]   - Field: ‘local’
[10:29:54.043]   - Field: ‘owner’
[10:29:54.043]   - Field: ‘envir’
[10:29:54.043]   - Field: ‘packages’
[10:29:54.043]   - Field: ‘gc’
[10:29:54.043]   - Field: ‘conditions’
[10:29:54.043]   - Field: ‘expr’
[10:29:54.043]   - Field: ‘uuid’
[10:29:54.043]   - Field: ‘seed’
[10:29:54.043]   - Field: ‘version’
[10:29:54.043]   - Field: ‘result’
[10:29:54.043]   - Field: ‘asynchronous’
[10:29:54.044]   - Field: ‘calls’
[10:29:54.044]   - Field: ‘globals’
[10:29:54.044]   - Field: ‘stdout’
[10:29:54.044]   - Field: ‘earlySignal’
[10:29:54.044]   - Field: ‘lazy’
[10:29:54.044]   - Field: ‘state’
[10:29:54.044] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:54.044] - Launch lazy future ...
[10:29:54.044] Packages needed by the future expression (n = 1): ‘stats’
[10:29:54.045] Packages needed by future strategies (n = 0): <none>
[10:29:54.045] {
[10:29:54.045]     {
[10:29:54.045]         {
[10:29:54.045]             ...future.startTime <- base::Sys.time()
[10:29:54.045]             {
[10:29:54.045]                 {
[10:29:54.045]                   {
[10:29:54.045]                     {
[10:29:54.045]                       base::local({
[10:29:54.045]                         has_future <- base::requireNamespace("future", 
[10:29:54.045]                           quietly = TRUE)
[10:29:54.045]                         if (has_future) {
[10:29:54.045]                           ns <- base::getNamespace("future")
[10:29:54.045]                           version <- ns[[".package"]][["version"]]
[10:29:54.045]                           if (is.null(version)) 
[10:29:54.045]                             version <- utils::packageVersion("future")
[10:29:54.045]                         }
[10:29:54.045]                         else {
[10:29:54.045]                           version <- NULL
[10:29:54.045]                         }
[10:29:54.045]                         if (!has_future || version < "1.8.0") {
[10:29:54.045]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:54.045]                             "", base::R.version$version.string), 
[10:29:54.045]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:54.045]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:54.045]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:54.045]                               "release", "version")], collapse = " "), 
[10:29:54.045]                             hostname = base::Sys.info()[["nodename"]])
[10:29:54.045]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:54.045]                             info)
[10:29:54.045]                           info <- base::paste(info, collapse = "; ")
[10:29:54.045]                           if (!has_future) {
[10:29:54.045]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:54.045]                               info)
[10:29:54.045]                           }
[10:29:54.045]                           else {
[10:29:54.045]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:54.045]                               info, version)
[10:29:54.045]                           }
[10:29:54.045]                           base::stop(msg)
[10:29:54.045]                         }
[10:29:54.045]                       })
[10:29:54.045]                     }
[10:29:54.045]                     base::local({
[10:29:54.045]                       for (pkg in "stats") {
[10:29:54.045]                         base::loadNamespace(pkg)
[10:29:54.045]                         base::library(pkg, character.only = TRUE)
[10:29:54.045]                       }
[10:29:54.045]                     })
[10:29:54.045]                   }
[10:29:54.045]                   ...future.strategy.old <- future::plan("list")
[10:29:54.045]                   options(future.plan = NULL)
[10:29:54.045]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.045]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:54.045]                 }
[10:29:54.045]                 ...future.workdir <- getwd()
[10:29:54.045]             }
[10:29:54.045]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:54.045]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:54.045]         }
[10:29:54.045]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:54.045]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:54.045]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:54.045]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:54.045]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:54.045]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:54.045]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:54.045]             base::names(...future.oldOptions))
[10:29:54.045]     }
[10:29:54.045]     if (FALSE) {
[10:29:54.045]     }
[10:29:54.045]     else {
[10:29:54.045]         if (TRUE) {
[10:29:54.045]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:54.045]                 open = "w")
[10:29:54.045]         }
[10:29:54.045]         else {
[10:29:54.045]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:54.045]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:54.045]         }
[10:29:54.045]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:54.045]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:54.045]             base::sink(type = "output", split = FALSE)
[10:29:54.045]             base::close(...future.stdout)
[10:29:54.045]         }, add = TRUE)
[10:29:54.045]     }
[10:29:54.045]     ...future.frame <- base::sys.nframe()
[10:29:54.045]     ...future.conditions <- base::list()
[10:29:54.045]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:54.045]     if (FALSE) {
[10:29:54.045]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:54.045]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:54.045]     }
[10:29:54.045]     ...future.result <- base::tryCatch({
[10:29:54.045]         base::withCallingHandlers({
[10:29:54.045]             ...future.value <- base::withVisible(base::local({
[10:29:54.045]                 do.call(function(...) {
[10:29:54.045]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.045]                   if (!identical(...future.globals.maxSize.org, 
[10:29:54.045]                     ...future.globals.maxSize)) {
[10:29:54.045]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.045]                     on.exit(options(oopts), add = TRUE)
[10:29:54.045]                   }
[10:29:54.045]                   {
[10:29:54.045]                     lapply(seq_along(...future.elements_ii), 
[10:29:54.045]                       FUN = function(jj) {
[10:29:54.045]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.045]                         ...future.FUN(...future.X_jj, ...)
[10:29:54.045]                       })
[10:29:54.045]                   }
[10:29:54.045]                 }, args = future.call.arguments)
[10:29:54.045]             }))
[10:29:54.045]             future::FutureResult(value = ...future.value$value, 
[10:29:54.045]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.045]                   ...future.rng), globalenv = if (FALSE) 
[10:29:54.045]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:54.045]                     ...future.globalenv.names))
[10:29:54.045]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:54.045]         }, condition = base::local({
[10:29:54.045]             c <- base::c
[10:29:54.045]             inherits <- base::inherits
[10:29:54.045]             invokeRestart <- base::invokeRestart
[10:29:54.045]             length <- base::length
[10:29:54.045]             list <- base::list
[10:29:54.045]             seq.int <- base::seq.int
[10:29:54.045]             signalCondition <- base::signalCondition
[10:29:54.045]             sys.calls <- base::sys.calls
[10:29:54.045]             `[[` <- base::`[[`
[10:29:54.045]             `+` <- base::`+`
[10:29:54.045]             `<<-` <- base::`<<-`
[10:29:54.045]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:54.045]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:54.045]                   3L)]
[10:29:54.045]             }
[10:29:54.045]             function(cond) {
[10:29:54.045]                 is_error <- inherits(cond, "error")
[10:29:54.045]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:54.045]                   NULL)
[10:29:54.045]                 if (is_error) {
[10:29:54.045]                   sessionInformation <- function() {
[10:29:54.045]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:54.045]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:54.045]                       search = base::search(), system = base::Sys.info())
[10:29:54.045]                   }
[10:29:54.045]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.045]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:54.045]                     cond$call), session = sessionInformation(), 
[10:29:54.045]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:54.045]                   signalCondition(cond)
[10:29:54.045]                 }
[10:29:54.045]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:54.045]                 "immediateCondition"))) {
[10:29:54.045]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:54.045]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.045]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:54.045]                   if (TRUE && !signal) {
[10:29:54.045]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.045]                     {
[10:29:54.045]                       inherits <- base::inherits
[10:29:54.045]                       invokeRestart <- base::invokeRestart
[10:29:54.045]                       is.null <- base::is.null
[10:29:54.045]                       muffled <- FALSE
[10:29:54.045]                       if (inherits(cond, "message")) {
[10:29:54.045]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.045]                         if (muffled) 
[10:29:54.045]                           invokeRestart("muffleMessage")
[10:29:54.045]                       }
[10:29:54.045]                       else if (inherits(cond, "warning")) {
[10:29:54.045]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.045]                         if (muffled) 
[10:29:54.045]                           invokeRestart("muffleWarning")
[10:29:54.045]                       }
[10:29:54.045]                       else if (inherits(cond, "condition")) {
[10:29:54.045]                         if (!is.null(pattern)) {
[10:29:54.045]                           computeRestarts <- base::computeRestarts
[10:29:54.045]                           grepl <- base::grepl
[10:29:54.045]                           restarts <- computeRestarts(cond)
[10:29:54.045]                           for (restart in restarts) {
[10:29:54.045]                             name <- restart$name
[10:29:54.045]                             if (is.null(name)) 
[10:29:54.045]                               next
[10:29:54.045]                             if (!grepl(pattern, name)) 
[10:29:54.045]                               next
[10:29:54.045]                             invokeRestart(restart)
[10:29:54.045]                             muffled <- TRUE
[10:29:54.045]                             break
[10:29:54.045]                           }
[10:29:54.045]                         }
[10:29:54.045]                       }
[10:29:54.045]                       invisible(muffled)
[10:29:54.045]                     }
[10:29:54.045]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.045]                   }
[10:29:54.045]                 }
[10:29:54.045]                 else {
[10:29:54.045]                   if (TRUE) {
[10:29:54.045]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.045]                     {
[10:29:54.045]                       inherits <- base::inherits
[10:29:54.045]                       invokeRestart <- base::invokeRestart
[10:29:54.045]                       is.null <- base::is.null
[10:29:54.045]                       muffled <- FALSE
[10:29:54.045]                       if (inherits(cond, "message")) {
[10:29:54.045]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.045]                         if (muffled) 
[10:29:54.045]                           invokeRestart("muffleMessage")
[10:29:54.045]                       }
[10:29:54.045]                       else if (inherits(cond, "warning")) {
[10:29:54.045]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.045]                         if (muffled) 
[10:29:54.045]                           invokeRestart("muffleWarning")
[10:29:54.045]                       }
[10:29:54.045]                       else if (inherits(cond, "condition")) {
[10:29:54.045]                         if (!is.null(pattern)) {
[10:29:54.045]                           computeRestarts <- base::computeRestarts
[10:29:54.045]                           grepl <- base::grepl
[10:29:54.045]                           restarts <- computeRestarts(cond)
[10:29:54.045]                           for (restart in restarts) {
[10:29:54.045]                             name <- restart$name
[10:29:54.045]                             if (is.null(name)) 
[10:29:54.045]                               next
[10:29:54.045]                             if (!grepl(pattern, name)) 
[10:29:54.045]                               next
[10:29:54.045]                             invokeRestart(restart)
[10:29:54.045]                             muffled <- TRUE
[10:29:54.045]                             break
[10:29:54.045]                           }
[10:29:54.045]                         }
[10:29:54.045]                       }
[10:29:54.045]                       invisible(muffled)
[10:29:54.045]                     }
[10:29:54.045]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.045]                   }
[10:29:54.045]                 }
[10:29:54.045]             }
[10:29:54.045]         }))
[10:29:54.045]     }, error = function(ex) {
[10:29:54.045]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:54.045]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.045]                 ...future.rng), started = ...future.startTime, 
[10:29:54.045]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:54.045]             version = "1.8"), class = "FutureResult")
[10:29:54.045]     }, finally = {
[10:29:54.045]         if (!identical(...future.workdir, getwd())) 
[10:29:54.045]             setwd(...future.workdir)
[10:29:54.045]         {
[10:29:54.045]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:54.045]                 ...future.oldOptions$nwarnings <- NULL
[10:29:54.045]             }
[10:29:54.045]             base::options(...future.oldOptions)
[10:29:54.045]             if (.Platform$OS.type == "windows") {
[10:29:54.045]                 old_names <- names(...future.oldEnvVars)
[10:29:54.045]                 envs <- base::Sys.getenv()
[10:29:54.045]                 names <- names(envs)
[10:29:54.045]                 common <- intersect(names, old_names)
[10:29:54.045]                 added <- setdiff(names, old_names)
[10:29:54.045]                 removed <- setdiff(old_names, names)
[10:29:54.045]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:54.045]                   envs[common]]
[10:29:54.045]                 NAMES <- toupper(changed)
[10:29:54.045]                 args <- list()
[10:29:54.045]                 for (kk in seq_along(NAMES)) {
[10:29:54.045]                   name <- changed[[kk]]
[10:29:54.045]                   NAME <- NAMES[[kk]]
[10:29:54.045]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.045]                     next
[10:29:54.045]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.045]                 }
[10:29:54.045]                 NAMES <- toupper(added)
[10:29:54.045]                 for (kk in seq_along(NAMES)) {
[10:29:54.045]                   name <- added[[kk]]
[10:29:54.045]                   NAME <- NAMES[[kk]]
[10:29:54.045]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.045]                     next
[10:29:54.045]                   args[[name]] <- ""
[10:29:54.045]                 }
[10:29:54.045]                 NAMES <- toupper(removed)
[10:29:54.045]                 for (kk in seq_along(NAMES)) {
[10:29:54.045]                   name <- removed[[kk]]
[10:29:54.045]                   NAME <- NAMES[[kk]]
[10:29:54.045]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.045]                     next
[10:29:54.045]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.045]                 }
[10:29:54.045]                 if (length(args) > 0) 
[10:29:54.045]                   base::do.call(base::Sys.setenv, args = args)
[10:29:54.045]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:54.045]             }
[10:29:54.045]             else {
[10:29:54.045]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:54.045]             }
[10:29:54.045]             {
[10:29:54.045]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:54.045]                   0L) {
[10:29:54.045]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:54.045]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:54.045]                   base::options(opts)
[10:29:54.045]                 }
[10:29:54.045]                 {
[10:29:54.045]                   {
[10:29:54.045]                     NULL
[10:29:54.045]                     RNGkind("Mersenne-Twister")
[10:29:54.045]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:54.045]                       inherits = FALSE)
[10:29:54.045]                   }
[10:29:54.045]                   options(future.plan = NULL)
[10:29:54.045]                   if (is.na(NA_character_)) 
[10:29:54.045]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.045]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:54.045]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:54.045]                     .init = FALSE)
[10:29:54.045]                 }
[10:29:54.045]             }
[10:29:54.045]         }
[10:29:54.045]     })
[10:29:54.045]     if (TRUE) {
[10:29:54.045]         base::sink(type = "output", split = FALSE)
[10:29:54.045]         if (TRUE) {
[10:29:54.045]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:54.045]         }
[10:29:54.045]         else {
[10:29:54.045]             ...future.result["stdout"] <- base::list(NULL)
[10:29:54.045]         }
[10:29:54.045]         base::close(...future.stdout)
[10:29:54.045]         ...future.stdout <- NULL
[10:29:54.045]     }
[10:29:54.045]     ...future.result$conditions <- ...future.conditions
[10:29:54.045]     ...future.result$finished <- base::Sys.time()
[10:29:54.045]     ...future.result
[10:29:54.045] }
[10:29:54.047] assign_globals() ...
[10:29:54.047] List of 5
[10:29:54.047]  $ ...future.FUN            :function (x, ...)  
[10:29:54.047]  $ future.call.arguments    :List of 1
[10:29:54.047]   ..$ singular.ok: logi FALSE
[10:29:54.047]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.047]  $ ...future.elements_ii    :List of 3
[10:29:54.047]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:54.047]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:29:54.047]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:54.047]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:54.047]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:54.047]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:29:54.047]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:54.047]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:29:54.047]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:54.047]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:29:54.047]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:54.047]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:29:54.047]  $ ...future.seeds_ii       : NULL
[10:29:54.047]  $ ...future.globals.maxSize: NULL
[10:29:54.047]  - attr(*, "where")=List of 5
[10:29:54.047]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:54.047]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:54.047]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:54.047]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:54.047]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:54.047]  - attr(*, "resolved")= logi FALSE
[10:29:54.047]  - attr(*, "total_size")= num 5384
[10:29:54.047]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.047]  - attr(*, "already-done")= logi TRUE
[10:29:54.057] - reassign environment for ‘...future.FUN’
[10:29:54.057] - copied ‘...future.FUN’ to environment
[10:29:54.058] - copied ‘future.call.arguments’ to environment
[10:29:54.058] - copied ‘...future.elements_ii’ to environment
[10:29:54.058] - copied ‘...future.seeds_ii’ to environment
[10:29:54.058] - copied ‘...future.globals.maxSize’ to environment
[10:29:54.058] assign_globals() ... done
[10:29:54.058] plan(): Setting new future strategy stack:
[10:29:54.058] List of future strategies:
[10:29:54.058] 1. sequential:
[10:29:54.058]    - args: function (..., envir = parent.frame())
[10:29:54.058]    - tweaked: FALSE
[10:29:54.058]    - call: NULL
[10:29:54.059] plan(): nbrOfWorkers() = 1
[10:29:54.062] plan(): Setting new future strategy stack:
[10:29:54.062] List of future strategies:
[10:29:54.062] 1. sequential:
[10:29:54.062]    - args: function (..., envir = parent.frame())
[10:29:54.062]    - tweaked: FALSE
[10:29:54.062]    - call: plan(strategy)
[10:29:54.062] plan(): nbrOfWorkers() = 1
[10:29:54.062] SequentialFuture started (and completed)
[10:29:54.062] - Launch lazy future ... done
[10:29:54.062] run() for ‘SequentialFuture’ ... done
[10:29:54.062] Created future:
[10:29:54.063] SequentialFuture:
[10:29:54.063] Label: ‘future_by-1’
[10:29:54.063] Expression:
[10:29:54.063] {
[10:29:54.063]     do.call(function(...) {
[10:29:54.063]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.063]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.063]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.063]             on.exit(options(oopts), add = TRUE)
[10:29:54.063]         }
[10:29:54.063]         {
[10:29:54.063]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.063]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.063]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.063]             })
[10:29:54.063]         }
[10:29:54.063]     }, args = future.call.arguments)
[10:29:54.063] }
[10:29:54.063] Lazy evaluation: FALSE
[10:29:54.063] Asynchronous evaluation: FALSE
[10:29:54.063] Local evaluation: TRUE
[10:29:54.063] Environment: R_GlobalEnv
[10:29:54.063] Capture standard output: TRUE
[10:29:54.063] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:54.063] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:54.063] Packages: 1 packages (‘stats’)
[10:29:54.063] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:54.063] Resolved: TRUE
[10:29:54.063] Value: 26.06 KiB of class ‘list’
[10:29:54.063] Early signaling: FALSE
[10:29:54.063] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:54.063] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:54.064] Chunk #1 of 1 ... DONE
[10:29:54.064] Launching 1 futures (chunks) ... DONE
[10:29:54.064] Resolving 1 futures (chunks) ...
[10:29:54.064] resolve() on list ...
[10:29:54.064]  recursive: 0
[10:29:54.064]  length: 1
[10:29:54.064] 
[10:29:54.065] resolved() for ‘SequentialFuture’ ...
[10:29:54.065] - state: ‘finished’
[10:29:54.065] - run: TRUE
[10:29:54.065] - result: ‘FutureResult’
[10:29:54.065] resolved() for ‘SequentialFuture’ ... done
[10:29:54.065] Future #1
[10:29:54.065] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:54.065] - nx: 1
[10:29:54.065] - relay: TRUE
[10:29:54.065] - stdout: TRUE
[10:29:54.066] - signal: TRUE
[10:29:54.066] - resignal: FALSE
[10:29:54.066] - force: TRUE
[10:29:54.066] - relayed: [n=1] FALSE
[10:29:54.066] - queued futures: [n=1] FALSE
[10:29:54.066]  - until=1
[10:29:54.066]  - relaying element #1
[10:29:54.066] - relayed: [n=1] TRUE
[10:29:54.066] - queued futures: [n=1] TRUE
[10:29:54.066] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:54.067]  length: 0 (resolved future 1)
[10:29:54.067] Relaying remaining futures
[10:29:54.067] signalConditionsASAP(NULL, pos=0) ...
[10:29:54.067] - nx: 1
[10:29:54.067] - relay: TRUE
[10:29:54.067] - stdout: TRUE
[10:29:54.067] - signal: TRUE
[10:29:54.067] - resignal: FALSE
[10:29:54.067] - force: TRUE
[10:29:54.067] - relayed: [n=1] TRUE
[10:29:54.067] - queued futures: [n=1] TRUE
 - flush all
[10:29:54.067] - relayed: [n=1] TRUE
[10:29:54.068] - queued futures: [n=1] TRUE
[10:29:54.068] signalConditionsASAP(NULL, pos=0) ... done
[10:29:54.068] resolve() on list ... DONE
[10:29:54.068]  - Number of value chunks collected: 1
[10:29:54.068] Resolving 1 futures (chunks) ... DONE
[10:29:54.068] Reducing values from 1 chunks ...
[10:29:54.068]  - Number of values collected after concatenation: 3
[10:29:54.068]  - Number of values expected: 3
[10:29:54.068] Reducing values from 1 chunks ... DONE
[10:29:54.068] future_lapply() ... DONE
[10:29:54.068] future_by_internal() ... DONE
[10:29:54.074] future_by_internal() ...
[10:29:54.074] future_lapply() ...
[10:29:54.075] Number of chunks: 1
[10:29:54.075] getGlobalsAndPackagesXApply() ...
[10:29:54.075]  - future.globals: TRUE
[10:29:54.075] getGlobalsAndPackages() ...
[10:29:54.075] Searching for globals...
[10:29:54.077] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:29:54.077] Searching for globals ... DONE
[10:29:54.077] Resolving globals: FALSE
[10:29:54.078] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[10:29:54.078] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[10:29:54.079] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[10:29:54.079] - packages: [1] ‘stats’
[10:29:54.079] getGlobalsAndPackages() ... DONE
[10:29:54.079]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[10:29:54.079]  - needed namespaces: [n=1] ‘stats’
[10:29:54.079] Finding globals ... DONE
[10:29:54.079]  - use_args: TRUE
[10:29:54.079]  - Getting '...' globals ...
[10:29:54.080] resolve() on list ...
[10:29:54.080]  recursive: 0
[10:29:54.080]  length: 1
[10:29:54.080]  elements: ‘...’
[10:29:54.080]  length: 0 (resolved future 1)
[10:29:54.080] resolve() on list ... DONE
[10:29:54.080]    - '...' content: [n=0] 
[10:29:54.080] List of 1
[10:29:54.080]  $ ...: list()
[10:29:54.080]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.080]  - attr(*, "where")=List of 1
[10:29:54.080]   ..$ ...:<environment: 0x556dd4026ab0> 
[10:29:54.080]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.080]  - attr(*, "resolved")= logi TRUE
[10:29:54.080]  - attr(*, "total_size")= num NA
[10:29:54.083]  - Getting '...' globals ... DONE
[10:29:54.083] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[10:29:54.083] List of 4
[10:29:54.083]  $ ...future.FUN:function (x)  
[10:29:54.083]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:29:54.083]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:54.083]  $ ...          : list()
[10:29:54.083]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.083]  - attr(*, "where")=List of 4
[10:29:54.083]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:54.083]   ..$ breaks       :<environment: R_EmptyEnv> 
[10:29:54.083]   ..$ wool         :<environment: R_EmptyEnv> 
[10:29:54.083]   ..$ ...          :<environment: 0x556dd4026ab0> 
[10:29:54.083]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.083]  - attr(*, "resolved")= logi FALSE
[10:29:54.083]  - attr(*, "total_size")= num 2320
[10:29:54.088] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:54.089] getGlobalsAndPackagesXApply() ... DONE
[10:29:54.089] Number of futures (= number of chunks): 1
[10:29:54.089] Launching 1 futures (chunks) ...
[10:29:54.089] Chunk #1 of 1 ...
[10:29:54.089]  - Finding globals in 'X' for chunk #1 ...
[10:29:54.089] getGlobalsAndPackages() ...
[10:29:54.089] Searching for globals...
[10:29:54.090] 
[10:29:54.090] Searching for globals ... DONE
[10:29:54.090] - globals: [0] <none>
[10:29:54.090] getGlobalsAndPackages() ... DONE
[10:29:54.090]    + additional globals found: [n=0] 
[10:29:54.091]    + additional namespaces needed: [n=0] 
[10:29:54.091]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:54.091]  - seeds: <none>
[10:29:54.091]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.091] getGlobalsAndPackages() ...
[10:29:54.091] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.091] Resolving globals: FALSE
[10:29:54.091] Tweak future expression to call with '...' arguments ...
[10:29:54.092] {
[10:29:54.092]     do.call(function(...) {
[10:29:54.092]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.092]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.092]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.092]             on.exit(options(oopts), add = TRUE)
[10:29:54.092]         }
[10:29:54.092]         {
[10:29:54.092]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.092]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.092]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.092]             })
[10:29:54.092]         }
[10:29:54.092]     }, args = future.call.arguments)
[10:29:54.092] }
[10:29:54.092] Tweak future expression to call with '...' arguments ... DONE
[10:29:54.092] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.092] 
[10:29:54.092] getGlobalsAndPackages() ... DONE
[10:29:54.093] run() for ‘Future’ ...
[10:29:54.093] - state: ‘created’
[10:29:54.093] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:29:54.093] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:54.094] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:54.094]   - Field: ‘label’
[10:29:54.094]   - Field: ‘local’
[10:29:54.094]   - Field: ‘owner’
[10:29:54.094]   - Field: ‘envir’
[10:29:54.094]   - Field: ‘packages’
[10:29:54.094]   - Field: ‘gc’
[10:29:54.094]   - Field: ‘conditions’
[10:29:54.094]   - Field: ‘expr’
[10:29:54.094]   - Field: ‘uuid’
[10:29:54.094]   - Field: ‘seed’
[10:29:54.095]   - Field: ‘version’
[10:29:54.095]   - Field: ‘result’
[10:29:54.095]   - Field: ‘asynchronous’
[10:29:54.095]   - Field: ‘calls’
[10:29:54.095]   - Field: ‘globals’
[10:29:54.095]   - Field: ‘stdout’
[10:29:54.095]   - Field: ‘earlySignal’
[10:29:54.095]   - Field: ‘lazy’
[10:29:54.095]   - Field: ‘state’
[10:29:54.095] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:54.096] - Launch lazy future ...
[10:29:54.096] Packages needed by the future expression (n = 1): ‘stats’
[10:29:54.096] Packages needed by future strategies (n = 0): <none>
[10:29:54.096] {
[10:29:54.096]     {
[10:29:54.096]         {
[10:29:54.096]             ...future.startTime <- base::Sys.time()
[10:29:54.096]             {
[10:29:54.096]                 {
[10:29:54.096]                   {
[10:29:54.096]                     {
[10:29:54.096]                       base::local({
[10:29:54.096]                         has_future <- base::requireNamespace("future", 
[10:29:54.096]                           quietly = TRUE)
[10:29:54.096]                         if (has_future) {
[10:29:54.096]                           ns <- base::getNamespace("future")
[10:29:54.096]                           version <- ns[[".package"]][["version"]]
[10:29:54.096]                           if (is.null(version)) 
[10:29:54.096]                             version <- utils::packageVersion("future")
[10:29:54.096]                         }
[10:29:54.096]                         else {
[10:29:54.096]                           version <- NULL
[10:29:54.096]                         }
[10:29:54.096]                         if (!has_future || version < "1.8.0") {
[10:29:54.096]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:54.096]                             "", base::R.version$version.string), 
[10:29:54.096]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:54.096]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:54.096]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:54.096]                               "release", "version")], collapse = " "), 
[10:29:54.096]                             hostname = base::Sys.info()[["nodename"]])
[10:29:54.096]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:54.096]                             info)
[10:29:54.096]                           info <- base::paste(info, collapse = "; ")
[10:29:54.096]                           if (!has_future) {
[10:29:54.096]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:54.096]                               info)
[10:29:54.096]                           }
[10:29:54.096]                           else {
[10:29:54.096]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:54.096]                               info, version)
[10:29:54.096]                           }
[10:29:54.096]                           base::stop(msg)
[10:29:54.096]                         }
[10:29:54.096]                       })
[10:29:54.096]                     }
[10:29:54.096]                     base::local({
[10:29:54.096]                       for (pkg in "stats") {
[10:29:54.096]                         base::loadNamespace(pkg)
[10:29:54.096]                         base::library(pkg, character.only = TRUE)
[10:29:54.096]                       }
[10:29:54.096]                     })
[10:29:54.096]                   }
[10:29:54.096]                   ...future.strategy.old <- future::plan("list")
[10:29:54.096]                   options(future.plan = NULL)
[10:29:54.096]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.096]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:54.096]                 }
[10:29:54.096]                 ...future.workdir <- getwd()
[10:29:54.096]             }
[10:29:54.096]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:54.096]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:54.096]         }
[10:29:54.096]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:54.096]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:54.096]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:54.096]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:54.096]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:54.096]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:54.096]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:54.096]             base::names(...future.oldOptions))
[10:29:54.096]     }
[10:29:54.096]     if (FALSE) {
[10:29:54.096]     }
[10:29:54.096]     else {
[10:29:54.096]         if (TRUE) {
[10:29:54.096]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:54.096]                 open = "w")
[10:29:54.096]         }
[10:29:54.096]         else {
[10:29:54.096]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:54.096]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:54.096]         }
[10:29:54.096]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:54.096]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:54.096]             base::sink(type = "output", split = FALSE)
[10:29:54.096]             base::close(...future.stdout)
[10:29:54.096]         }, add = TRUE)
[10:29:54.096]     }
[10:29:54.096]     ...future.frame <- base::sys.nframe()
[10:29:54.096]     ...future.conditions <- base::list()
[10:29:54.096]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:54.096]     if (FALSE) {
[10:29:54.096]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:54.096]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:54.096]     }
[10:29:54.096]     ...future.result <- base::tryCatch({
[10:29:54.096]         base::withCallingHandlers({
[10:29:54.096]             ...future.value <- base::withVisible(base::local({
[10:29:54.096]                 do.call(function(...) {
[10:29:54.096]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.096]                   if (!identical(...future.globals.maxSize.org, 
[10:29:54.096]                     ...future.globals.maxSize)) {
[10:29:54.096]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.096]                     on.exit(options(oopts), add = TRUE)
[10:29:54.096]                   }
[10:29:54.096]                   {
[10:29:54.096]                     lapply(seq_along(...future.elements_ii), 
[10:29:54.096]                       FUN = function(jj) {
[10:29:54.096]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.096]                         ...future.FUN(...future.X_jj, ...)
[10:29:54.096]                       })
[10:29:54.096]                   }
[10:29:54.096]                 }, args = future.call.arguments)
[10:29:54.096]             }))
[10:29:54.096]             future::FutureResult(value = ...future.value$value, 
[10:29:54.096]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.096]                   ...future.rng), globalenv = if (FALSE) 
[10:29:54.096]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:54.096]                     ...future.globalenv.names))
[10:29:54.096]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:54.096]         }, condition = base::local({
[10:29:54.096]             c <- base::c
[10:29:54.096]             inherits <- base::inherits
[10:29:54.096]             invokeRestart <- base::invokeRestart
[10:29:54.096]             length <- base::length
[10:29:54.096]             list <- base::list
[10:29:54.096]             seq.int <- base::seq.int
[10:29:54.096]             signalCondition <- base::signalCondition
[10:29:54.096]             sys.calls <- base::sys.calls
[10:29:54.096]             `[[` <- base::`[[`
[10:29:54.096]             `+` <- base::`+`
[10:29:54.096]             `<<-` <- base::`<<-`
[10:29:54.096]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:54.096]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:54.096]                   3L)]
[10:29:54.096]             }
[10:29:54.096]             function(cond) {
[10:29:54.096]                 is_error <- inherits(cond, "error")
[10:29:54.096]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:54.096]                   NULL)
[10:29:54.096]                 if (is_error) {
[10:29:54.096]                   sessionInformation <- function() {
[10:29:54.096]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:54.096]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:54.096]                       search = base::search(), system = base::Sys.info())
[10:29:54.096]                   }
[10:29:54.096]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.096]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:54.096]                     cond$call), session = sessionInformation(), 
[10:29:54.096]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:54.096]                   signalCondition(cond)
[10:29:54.096]                 }
[10:29:54.096]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:54.096]                 "immediateCondition"))) {
[10:29:54.096]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:54.096]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.096]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:54.096]                   if (TRUE && !signal) {
[10:29:54.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.096]                     {
[10:29:54.096]                       inherits <- base::inherits
[10:29:54.096]                       invokeRestart <- base::invokeRestart
[10:29:54.096]                       is.null <- base::is.null
[10:29:54.096]                       muffled <- FALSE
[10:29:54.096]                       if (inherits(cond, "message")) {
[10:29:54.096]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.096]                         if (muffled) 
[10:29:54.096]                           invokeRestart("muffleMessage")
[10:29:54.096]                       }
[10:29:54.096]                       else if (inherits(cond, "warning")) {
[10:29:54.096]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.096]                         if (muffled) 
[10:29:54.096]                           invokeRestart("muffleWarning")
[10:29:54.096]                       }
[10:29:54.096]                       else if (inherits(cond, "condition")) {
[10:29:54.096]                         if (!is.null(pattern)) {
[10:29:54.096]                           computeRestarts <- base::computeRestarts
[10:29:54.096]                           grepl <- base::grepl
[10:29:54.096]                           restarts <- computeRestarts(cond)
[10:29:54.096]                           for (restart in restarts) {
[10:29:54.096]                             name <- restart$name
[10:29:54.096]                             if (is.null(name)) 
[10:29:54.096]                               next
[10:29:54.096]                             if (!grepl(pattern, name)) 
[10:29:54.096]                               next
[10:29:54.096]                             invokeRestart(restart)
[10:29:54.096]                             muffled <- TRUE
[10:29:54.096]                             break
[10:29:54.096]                           }
[10:29:54.096]                         }
[10:29:54.096]                       }
[10:29:54.096]                       invisible(muffled)
[10:29:54.096]                     }
[10:29:54.096]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.096]                   }
[10:29:54.096]                 }
[10:29:54.096]                 else {
[10:29:54.096]                   if (TRUE) {
[10:29:54.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.096]                     {
[10:29:54.096]                       inherits <- base::inherits
[10:29:54.096]                       invokeRestart <- base::invokeRestart
[10:29:54.096]                       is.null <- base::is.null
[10:29:54.096]                       muffled <- FALSE
[10:29:54.096]                       if (inherits(cond, "message")) {
[10:29:54.096]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.096]                         if (muffled) 
[10:29:54.096]                           invokeRestart("muffleMessage")
[10:29:54.096]                       }
[10:29:54.096]                       else if (inherits(cond, "warning")) {
[10:29:54.096]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.096]                         if (muffled) 
[10:29:54.096]                           invokeRestart("muffleWarning")
[10:29:54.096]                       }
[10:29:54.096]                       else if (inherits(cond, "condition")) {
[10:29:54.096]                         if (!is.null(pattern)) {
[10:29:54.096]                           computeRestarts <- base::computeRestarts
[10:29:54.096]                           grepl <- base::grepl
[10:29:54.096]                           restarts <- computeRestarts(cond)
[10:29:54.096]                           for (restart in restarts) {
[10:29:54.096]                             name <- restart$name
[10:29:54.096]                             if (is.null(name)) 
[10:29:54.096]                               next
[10:29:54.096]                             if (!grepl(pattern, name)) 
[10:29:54.096]                               next
[10:29:54.096]                             invokeRestart(restart)
[10:29:54.096]                             muffled <- TRUE
[10:29:54.096]                             break
[10:29:54.096]                           }
[10:29:54.096]                         }
[10:29:54.096]                       }
[10:29:54.096]                       invisible(muffled)
[10:29:54.096]                     }
[10:29:54.096]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.096]                   }
[10:29:54.096]                 }
[10:29:54.096]             }
[10:29:54.096]         }))
[10:29:54.096]     }, error = function(ex) {
[10:29:54.096]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:54.096]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.096]                 ...future.rng), started = ...future.startTime, 
[10:29:54.096]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:54.096]             version = "1.8"), class = "FutureResult")
[10:29:54.096]     }, finally = {
[10:29:54.096]         if (!identical(...future.workdir, getwd())) 
[10:29:54.096]             setwd(...future.workdir)
[10:29:54.096]         {
[10:29:54.096]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:54.096]                 ...future.oldOptions$nwarnings <- NULL
[10:29:54.096]             }
[10:29:54.096]             base::options(...future.oldOptions)
[10:29:54.096]             if (.Platform$OS.type == "windows") {
[10:29:54.096]                 old_names <- names(...future.oldEnvVars)
[10:29:54.096]                 envs <- base::Sys.getenv()
[10:29:54.096]                 names <- names(envs)
[10:29:54.096]                 common <- intersect(names, old_names)
[10:29:54.096]                 added <- setdiff(names, old_names)
[10:29:54.096]                 removed <- setdiff(old_names, names)
[10:29:54.096]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:54.096]                   envs[common]]
[10:29:54.096]                 NAMES <- toupper(changed)
[10:29:54.096]                 args <- list()
[10:29:54.096]                 for (kk in seq_along(NAMES)) {
[10:29:54.096]                   name <- changed[[kk]]
[10:29:54.096]                   NAME <- NAMES[[kk]]
[10:29:54.096]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.096]                     next
[10:29:54.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.096]                 }
[10:29:54.096]                 NAMES <- toupper(added)
[10:29:54.096]                 for (kk in seq_along(NAMES)) {
[10:29:54.096]                   name <- added[[kk]]
[10:29:54.096]                   NAME <- NAMES[[kk]]
[10:29:54.096]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.096]                     next
[10:29:54.096]                   args[[name]] <- ""
[10:29:54.096]                 }
[10:29:54.096]                 NAMES <- toupper(removed)
[10:29:54.096]                 for (kk in seq_along(NAMES)) {
[10:29:54.096]                   name <- removed[[kk]]
[10:29:54.096]                   NAME <- NAMES[[kk]]
[10:29:54.096]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.096]                     next
[10:29:54.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.096]                 }
[10:29:54.096]                 if (length(args) > 0) 
[10:29:54.096]                   base::do.call(base::Sys.setenv, args = args)
[10:29:54.096]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:54.096]             }
[10:29:54.096]             else {
[10:29:54.096]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:54.096]             }
[10:29:54.096]             {
[10:29:54.096]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:54.096]                   0L) {
[10:29:54.096]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:54.096]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:54.096]                   base::options(opts)
[10:29:54.096]                 }
[10:29:54.096]                 {
[10:29:54.096]                   {
[10:29:54.096]                     NULL
[10:29:54.096]                     RNGkind("Mersenne-Twister")
[10:29:54.096]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:54.096]                       inherits = FALSE)
[10:29:54.096]                   }
[10:29:54.096]                   options(future.plan = NULL)
[10:29:54.096]                   if (is.na(NA_character_)) 
[10:29:54.096]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.096]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:54.096]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:54.096]                     .init = FALSE)
[10:29:54.096]                 }
[10:29:54.096]             }
[10:29:54.096]         }
[10:29:54.096]     })
[10:29:54.096]     if (TRUE) {
[10:29:54.096]         base::sink(type = "output", split = FALSE)
[10:29:54.096]         if (TRUE) {
[10:29:54.096]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:54.096]         }
[10:29:54.096]         else {
[10:29:54.096]             ...future.result["stdout"] <- base::list(NULL)
[10:29:54.096]         }
[10:29:54.096]         base::close(...future.stdout)
[10:29:54.096]         ...future.stdout <- NULL
[10:29:54.096]     }
[10:29:54.096]     ...future.result$conditions <- ...future.conditions
[10:29:54.096]     ...future.result$finished <- base::Sys.time()
[10:29:54.096]     ...future.result
[10:29:54.096] }
[10:29:54.098] assign_globals() ...
[10:29:54.098] List of 7
[10:29:54.098]  $ ...future.FUN            :function (x)  
[10:29:54.098]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:29:54.098]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:54.098]  $ future.call.arguments    : list()
[10:29:54.098]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.098]  $ ...future.elements_ii    :List of 3
[10:29:54.098]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:54.098]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:29:54.098]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:54.098]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:54.098]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:54.098]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:29:54.098]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:54.098]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:29:54.098]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:54.098]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:29:54.098]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:54.098]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:29:54.098]  $ ...future.seeds_ii       : NULL
[10:29:54.098]  $ ...future.globals.maxSize: NULL
[10:29:54.098]  - attr(*, "where")=List of 7
[10:29:54.098]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:54.098]   ..$ breaks                   :<environment: R_EmptyEnv> 
[10:29:54.098]   ..$ wool                     :<environment: R_EmptyEnv> 
[10:29:54.098]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:54.098]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:54.098]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:54.098]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:54.098]  - attr(*, "resolved")= logi FALSE
[10:29:54.098]  - attr(*, "total_size")= num 2320
[10:29:54.098]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.098]  - attr(*, "already-done")= logi TRUE
[10:29:54.108] - reassign environment for ‘...future.FUN’
[10:29:54.108] - copied ‘...future.FUN’ to environment
[10:29:54.108] - copied ‘breaks’ to environment
[10:29:54.109] - copied ‘wool’ to environment
[10:29:54.109] - copied ‘future.call.arguments’ to environment
[10:29:54.109] - copied ‘...future.elements_ii’ to environment
[10:29:54.109] - copied ‘...future.seeds_ii’ to environment
[10:29:54.110] - copied ‘...future.globals.maxSize’ to environment
[10:29:54.110] assign_globals() ... done
[10:29:54.110] plan(): Setting new future strategy stack:
[10:29:54.110] List of future strategies:
[10:29:54.110] 1. sequential:
[10:29:54.110]    - args: function (..., envir = parent.frame())
[10:29:54.110]    - tweaked: FALSE
[10:29:54.110]    - call: NULL
[10:29:54.110] plan(): nbrOfWorkers() = 1
[10:29:54.113] plan(): Setting new future strategy stack:
[10:29:54.113] List of future strategies:
[10:29:54.113] 1. sequential:
[10:29:54.113]    - args: function (..., envir = parent.frame())
[10:29:54.113]    - tweaked: FALSE
[10:29:54.113]    - call: plan(strategy)
[10:29:54.114] plan(): nbrOfWorkers() = 1
[10:29:54.114] SequentialFuture started (and completed)
[10:29:54.114] - Launch lazy future ... done
[10:29:54.114] run() for ‘SequentialFuture’ ... done
[10:29:54.114] Created future:
[10:29:54.114] SequentialFuture:
[10:29:54.114] Label: ‘future_by-1’
[10:29:54.114] Expression:
[10:29:54.114] {
[10:29:54.114]     do.call(function(...) {
[10:29:54.114]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.114]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.114]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.114]             on.exit(options(oopts), add = TRUE)
[10:29:54.114]         }
[10:29:54.114]         {
[10:29:54.114]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.114]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.114]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.114]             })
[10:29:54.114]         }
[10:29:54.114]     }, args = future.call.arguments)
[10:29:54.114] }
[10:29:54.114] Lazy evaluation: FALSE
[10:29:54.114] Asynchronous evaluation: FALSE
[10:29:54.114] Local evaluation: TRUE
[10:29:54.114] Environment: 0x556dd4470268
[10:29:54.114] Capture standard output: TRUE
[10:29:54.114] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:54.114] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[10:29:54.114] Packages: 1 packages (‘stats’)
[10:29:54.114] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:54.114] Resolved: TRUE
[10:29:54.114] Value: 25.57 KiB of class ‘list’
[10:29:54.114] Early signaling: FALSE
[10:29:54.114] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:54.114] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:54.116] Chunk #1 of 1 ... DONE
[10:29:54.116] Launching 1 futures (chunks) ... DONE
[10:29:54.116] Resolving 1 futures (chunks) ...
[10:29:54.116] resolve() on list ...
[10:29:54.116]  recursive: 0
[10:29:54.116]  length: 1
[10:29:54.116] 
[10:29:54.117] resolved() for ‘SequentialFuture’ ...
[10:29:54.117] - state: ‘finished’
[10:29:54.117] - run: TRUE
[10:29:54.117] - result: ‘FutureResult’
[10:29:54.117] resolved() for ‘SequentialFuture’ ... done
[10:29:54.117] Future #1
[10:29:54.117] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:54.117] - nx: 1
[10:29:54.117] - relay: TRUE
[10:29:54.117] - stdout: TRUE
[10:29:54.118] - signal: TRUE
[10:29:54.118] - resignal: FALSE
[10:29:54.118] - force: TRUE
[10:29:54.118] - relayed: [n=1] FALSE
[10:29:54.118] - queued futures: [n=1] FALSE
[10:29:54.118]  - until=1
[10:29:54.118]  - relaying element #1
[10:29:54.118] - relayed: [n=1] TRUE
[10:29:54.118] - queued futures: [n=1] TRUE
[10:29:54.118] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:54.119]  length: 0 (resolved future 1)
[10:29:54.119] Relaying remaining futures
[10:29:54.119] signalConditionsASAP(NULL, pos=0) ...
[10:29:54.119] - nx: 1
[10:29:54.119] - relay: TRUE
[10:29:54.119] - stdout: TRUE
[10:29:54.119] - signal: TRUE
[10:29:54.119] - resignal: FALSE
[10:29:54.119] - force: TRUE
[10:29:54.119] - relayed: [n=1] TRUE
[10:29:54.119] - queued futures: [n=1] TRUE
 - flush all
[10:29:54.119] - relayed: [n=1] TRUE
[10:29:54.120] - queued futures: [n=1] TRUE
[10:29:54.120] signalConditionsASAP(NULL, pos=0) ... done
[10:29:54.120] resolve() on list ... DONE
[10:29:54.120]  - Number of value chunks collected: 1
[10:29:54.120] Resolving 1 futures (chunks) ... DONE
[10:29:54.120] Reducing values from 1 chunks ...
[10:29:54.120]  - Number of values collected after concatenation: 3
[10:29:54.120]  - Number of values expected: 3
[10:29:54.120] Reducing values from 1 chunks ... DONE
[10:29:54.120] future_lapply() ... DONE
[10:29:54.120] future_by_internal() ... DONE
[10:29:54.121] future_by_internal() ...
[10:29:54.121] future_lapply() ...
[10:29:54.122] Number of chunks: 1
[10:29:54.122] getGlobalsAndPackagesXApply() ...
[10:29:54.122]  - future.globals: TRUE
[10:29:54.122] getGlobalsAndPackages() ...
[10:29:54.122] Searching for globals...
[10:29:54.123] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:54.123] Searching for globals ... DONE
[10:29:54.123] Resolving globals: FALSE
[10:29:54.124] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:54.124] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:54.124] - globals: [1] ‘FUN’
[10:29:54.124] 
[10:29:54.124] getGlobalsAndPackages() ... DONE
[10:29:54.124]  - globals found/used: [n=1] ‘FUN’
[10:29:54.124]  - needed namespaces: [n=0] 
[10:29:54.124] Finding globals ... DONE
[10:29:54.125]  - use_args: TRUE
[10:29:54.125]  - Getting '...' globals ...
[10:29:54.125] resolve() on list ...
[10:29:54.125]  recursive: 0
[10:29:54.125]  length: 1
[10:29:54.125]  elements: ‘...’
[10:29:54.125]  length: 0 (resolved future 1)
[10:29:54.125] resolve() on list ... DONE
[10:29:54.125]    - '...' content: [n=0] 
[10:29:54.126] List of 1
[10:29:54.126]  $ ...: list()
[10:29:54.126]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.126]  - attr(*, "where")=List of 1
[10:29:54.126]   ..$ ...:<environment: 0x556dd4e00de0> 
[10:29:54.126]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.126]  - attr(*, "resolved")= logi TRUE
[10:29:54.126]  - attr(*, "total_size")= num NA
[10:29:54.130]  - Getting '...' globals ... DONE
[10:29:54.130] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:54.130] List of 2
[10:29:54.130]  $ ...future.FUN:function (object, ...)  
[10:29:54.130]  $ ...          : list()
[10:29:54.130]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.130]  - attr(*, "where")=List of 2
[10:29:54.130]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:54.130]   ..$ ...          :<environment: 0x556dd4e00de0> 
[10:29:54.130]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.130]  - attr(*, "resolved")= logi FALSE
[10:29:54.130]  - attr(*, "total_size")= num 1240
[10:29:54.133] Packages to be attached in all futures: [n=0] 
[10:29:54.133] getGlobalsAndPackagesXApply() ... DONE
[10:29:54.133] Number of futures (= number of chunks): 1
[10:29:54.133] Launching 1 futures (chunks) ...
[10:29:54.133] Chunk #1 of 1 ...
[10:29:54.134]  - Finding globals in 'X' for chunk #1 ...
[10:29:54.134] getGlobalsAndPackages() ...
[10:29:54.134] Searching for globals...
[10:29:54.134] 
[10:29:54.134] Searching for globals ... DONE
[10:29:54.134] - globals: [0] <none>
[10:29:54.134] getGlobalsAndPackages() ... DONE
[10:29:54.135]    + additional globals found: [n=0] 
[10:29:54.135]    + additional namespaces needed: [n=0] 
[10:29:54.135]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:54.135]  - seeds: <none>
[10:29:54.135]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.135] getGlobalsAndPackages() ...
[10:29:54.135] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.135] Resolving globals: FALSE
[10:29:54.135] Tweak future expression to call with '...' arguments ...
[10:29:54.136] {
[10:29:54.136]     do.call(function(...) {
[10:29:54.136]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.136]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.136]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.136]             on.exit(options(oopts), add = TRUE)
[10:29:54.136]         }
[10:29:54.136]         {
[10:29:54.136]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.136]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.136]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.136]             })
[10:29:54.136]         }
[10:29:54.136]     }, args = future.call.arguments)
[10:29:54.136] }
[10:29:54.136] Tweak future expression to call with '...' arguments ... DONE
[10:29:54.136] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.136] 
[10:29:54.136] getGlobalsAndPackages() ... DONE
[10:29:54.137] run() for ‘Future’ ...
[10:29:54.137] - state: ‘created’
[10:29:54.137] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:29:54.137] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:54.137] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:54.137]   - Field: ‘label’
[10:29:54.137]   - Field: ‘local’
[10:29:54.138]   - Field: ‘owner’
[10:29:54.138]   - Field: ‘envir’
[10:29:54.138]   - Field: ‘packages’
[10:29:54.138]   - Field: ‘gc’
[10:29:54.138]   - Field: ‘conditions’
[10:29:54.138]   - Field: ‘expr’
[10:29:54.138]   - Field: ‘uuid’
[10:29:54.138]   - Field: ‘seed’
[10:29:54.138]   - Field: ‘version’
[10:29:54.138]   - Field: ‘result’
[10:29:54.138]   - Field: ‘asynchronous’
[10:29:54.139]   - Field: ‘calls’
[10:29:54.139]   - Field: ‘globals’
[10:29:54.139]   - Field: ‘stdout’
[10:29:54.139]   - Field: ‘earlySignal’
[10:29:54.139]   - Field: ‘lazy’
[10:29:54.139]   - Field: ‘state’
[10:29:54.139] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:54.139] - Launch lazy future ...
[10:29:54.139] Packages needed by the future expression (n = 0): <none>
[10:29:54.140] Packages needed by future strategies (n = 0): <none>
[10:29:54.140] {
[10:29:54.140]     {
[10:29:54.140]         {
[10:29:54.140]             ...future.startTime <- base::Sys.time()
[10:29:54.140]             {
[10:29:54.140]                 {
[10:29:54.140]                   {
[10:29:54.140]                     base::local({
[10:29:54.140]                       has_future <- base::requireNamespace("future", 
[10:29:54.140]                         quietly = TRUE)
[10:29:54.140]                       if (has_future) {
[10:29:54.140]                         ns <- base::getNamespace("future")
[10:29:54.140]                         version <- ns[[".package"]][["version"]]
[10:29:54.140]                         if (is.null(version)) 
[10:29:54.140]                           version <- utils::packageVersion("future")
[10:29:54.140]                       }
[10:29:54.140]                       else {
[10:29:54.140]                         version <- NULL
[10:29:54.140]                       }
[10:29:54.140]                       if (!has_future || version < "1.8.0") {
[10:29:54.140]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:54.140]                           "", base::R.version$version.string), 
[10:29:54.140]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:54.140]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:54.140]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:54.140]                             "release", "version")], collapse = " "), 
[10:29:54.140]                           hostname = base::Sys.info()[["nodename"]])
[10:29:54.140]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:54.140]                           info)
[10:29:54.140]                         info <- base::paste(info, collapse = "; ")
[10:29:54.140]                         if (!has_future) {
[10:29:54.140]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:54.140]                             info)
[10:29:54.140]                         }
[10:29:54.140]                         else {
[10:29:54.140]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:54.140]                             info, version)
[10:29:54.140]                         }
[10:29:54.140]                         base::stop(msg)
[10:29:54.140]                       }
[10:29:54.140]                     })
[10:29:54.140]                   }
[10:29:54.140]                   ...future.strategy.old <- future::plan("list")
[10:29:54.140]                   options(future.plan = NULL)
[10:29:54.140]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.140]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:54.140]                 }
[10:29:54.140]                 ...future.workdir <- getwd()
[10:29:54.140]             }
[10:29:54.140]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:54.140]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:54.140]         }
[10:29:54.140]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:54.140]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:54.140]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:54.140]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:54.140]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:54.140]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:54.140]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:54.140]             base::names(...future.oldOptions))
[10:29:54.140]     }
[10:29:54.140]     if (FALSE) {
[10:29:54.140]     }
[10:29:54.140]     else {
[10:29:54.140]         if (TRUE) {
[10:29:54.140]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:54.140]                 open = "w")
[10:29:54.140]         }
[10:29:54.140]         else {
[10:29:54.140]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:54.140]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:54.140]         }
[10:29:54.140]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:54.140]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:54.140]             base::sink(type = "output", split = FALSE)
[10:29:54.140]             base::close(...future.stdout)
[10:29:54.140]         }, add = TRUE)
[10:29:54.140]     }
[10:29:54.140]     ...future.frame <- base::sys.nframe()
[10:29:54.140]     ...future.conditions <- base::list()
[10:29:54.140]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:54.140]     if (FALSE) {
[10:29:54.140]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:54.140]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:54.140]     }
[10:29:54.140]     ...future.result <- base::tryCatch({
[10:29:54.140]         base::withCallingHandlers({
[10:29:54.140]             ...future.value <- base::withVisible(base::local({
[10:29:54.140]                 do.call(function(...) {
[10:29:54.140]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.140]                   if (!identical(...future.globals.maxSize.org, 
[10:29:54.140]                     ...future.globals.maxSize)) {
[10:29:54.140]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.140]                     on.exit(options(oopts), add = TRUE)
[10:29:54.140]                   }
[10:29:54.140]                   {
[10:29:54.140]                     lapply(seq_along(...future.elements_ii), 
[10:29:54.140]                       FUN = function(jj) {
[10:29:54.140]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.140]                         ...future.FUN(...future.X_jj, ...)
[10:29:54.140]                       })
[10:29:54.140]                   }
[10:29:54.140]                 }, args = future.call.arguments)
[10:29:54.140]             }))
[10:29:54.140]             future::FutureResult(value = ...future.value$value, 
[10:29:54.140]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.140]                   ...future.rng), globalenv = if (FALSE) 
[10:29:54.140]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:54.140]                     ...future.globalenv.names))
[10:29:54.140]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:54.140]         }, condition = base::local({
[10:29:54.140]             c <- base::c
[10:29:54.140]             inherits <- base::inherits
[10:29:54.140]             invokeRestart <- base::invokeRestart
[10:29:54.140]             length <- base::length
[10:29:54.140]             list <- base::list
[10:29:54.140]             seq.int <- base::seq.int
[10:29:54.140]             signalCondition <- base::signalCondition
[10:29:54.140]             sys.calls <- base::sys.calls
[10:29:54.140]             `[[` <- base::`[[`
[10:29:54.140]             `+` <- base::`+`
[10:29:54.140]             `<<-` <- base::`<<-`
[10:29:54.140]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:54.140]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:54.140]                   3L)]
[10:29:54.140]             }
[10:29:54.140]             function(cond) {
[10:29:54.140]                 is_error <- inherits(cond, "error")
[10:29:54.140]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:54.140]                   NULL)
[10:29:54.140]                 if (is_error) {
[10:29:54.140]                   sessionInformation <- function() {
[10:29:54.140]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:54.140]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:54.140]                       search = base::search(), system = base::Sys.info())
[10:29:54.140]                   }
[10:29:54.140]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.140]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:54.140]                     cond$call), session = sessionInformation(), 
[10:29:54.140]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:54.140]                   signalCondition(cond)
[10:29:54.140]                 }
[10:29:54.140]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:54.140]                 "immediateCondition"))) {
[10:29:54.140]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:54.140]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.140]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:54.140]                   if (TRUE && !signal) {
[10:29:54.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.140]                     {
[10:29:54.140]                       inherits <- base::inherits
[10:29:54.140]                       invokeRestart <- base::invokeRestart
[10:29:54.140]                       is.null <- base::is.null
[10:29:54.140]                       muffled <- FALSE
[10:29:54.140]                       if (inherits(cond, "message")) {
[10:29:54.140]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.140]                         if (muffled) 
[10:29:54.140]                           invokeRestart("muffleMessage")
[10:29:54.140]                       }
[10:29:54.140]                       else if (inherits(cond, "warning")) {
[10:29:54.140]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.140]                         if (muffled) 
[10:29:54.140]                           invokeRestart("muffleWarning")
[10:29:54.140]                       }
[10:29:54.140]                       else if (inherits(cond, "condition")) {
[10:29:54.140]                         if (!is.null(pattern)) {
[10:29:54.140]                           computeRestarts <- base::computeRestarts
[10:29:54.140]                           grepl <- base::grepl
[10:29:54.140]                           restarts <- computeRestarts(cond)
[10:29:54.140]                           for (restart in restarts) {
[10:29:54.140]                             name <- restart$name
[10:29:54.140]                             if (is.null(name)) 
[10:29:54.140]                               next
[10:29:54.140]                             if (!grepl(pattern, name)) 
[10:29:54.140]                               next
[10:29:54.140]                             invokeRestart(restart)
[10:29:54.140]                             muffled <- TRUE
[10:29:54.140]                             break
[10:29:54.140]                           }
[10:29:54.140]                         }
[10:29:54.140]                       }
[10:29:54.140]                       invisible(muffled)
[10:29:54.140]                     }
[10:29:54.140]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.140]                   }
[10:29:54.140]                 }
[10:29:54.140]                 else {
[10:29:54.140]                   if (TRUE) {
[10:29:54.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.140]                     {
[10:29:54.140]                       inherits <- base::inherits
[10:29:54.140]                       invokeRestart <- base::invokeRestart
[10:29:54.140]                       is.null <- base::is.null
[10:29:54.140]                       muffled <- FALSE
[10:29:54.140]                       if (inherits(cond, "message")) {
[10:29:54.140]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.140]                         if (muffled) 
[10:29:54.140]                           invokeRestart("muffleMessage")
[10:29:54.140]                       }
[10:29:54.140]                       else if (inherits(cond, "warning")) {
[10:29:54.140]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.140]                         if (muffled) 
[10:29:54.140]                           invokeRestart("muffleWarning")
[10:29:54.140]                       }
[10:29:54.140]                       else if (inherits(cond, "condition")) {
[10:29:54.140]                         if (!is.null(pattern)) {
[10:29:54.140]                           computeRestarts <- base::computeRestarts
[10:29:54.140]                           grepl <- base::grepl
[10:29:54.140]                           restarts <- computeRestarts(cond)
[10:29:54.140]                           for (restart in restarts) {
[10:29:54.140]                             name <- restart$name
[10:29:54.140]                             if (is.null(name)) 
[10:29:54.140]                               next
[10:29:54.140]                             if (!grepl(pattern, name)) 
[10:29:54.140]                               next
[10:29:54.140]                             invokeRestart(restart)
[10:29:54.140]                             muffled <- TRUE
[10:29:54.140]                             break
[10:29:54.140]                           }
[10:29:54.140]                         }
[10:29:54.140]                       }
[10:29:54.140]                       invisible(muffled)
[10:29:54.140]                     }
[10:29:54.140]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.140]                   }
[10:29:54.140]                 }
[10:29:54.140]             }
[10:29:54.140]         }))
[10:29:54.140]     }, error = function(ex) {
[10:29:54.140]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:54.140]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.140]                 ...future.rng), started = ...future.startTime, 
[10:29:54.140]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:54.140]             version = "1.8"), class = "FutureResult")
[10:29:54.140]     }, finally = {
[10:29:54.140]         if (!identical(...future.workdir, getwd())) 
[10:29:54.140]             setwd(...future.workdir)
[10:29:54.140]         {
[10:29:54.140]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:54.140]                 ...future.oldOptions$nwarnings <- NULL
[10:29:54.140]             }
[10:29:54.140]             base::options(...future.oldOptions)
[10:29:54.140]             if (.Platform$OS.type == "windows") {
[10:29:54.140]                 old_names <- names(...future.oldEnvVars)
[10:29:54.140]                 envs <- base::Sys.getenv()
[10:29:54.140]                 names <- names(envs)
[10:29:54.140]                 common <- intersect(names, old_names)
[10:29:54.140]                 added <- setdiff(names, old_names)
[10:29:54.140]                 removed <- setdiff(old_names, names)
[10:29:54.140]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:54.140]                   envs[common]]
[10:29:54.140]                 NAMES <- toupper(changed)
[10:29:54.140]                 args <- list()
[10:29:54.140]                 for (kk in seq_along(NAMES)) {
[10:29:54.140]                   name <- changed[[kk]]
[10:29:54.140]                   NAME <- NAMES[[kk]]
[10:29:54.140]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.140]                     next
[10:29:54.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.140]                 }
[10:29:54.140]                 NAMES <- toupper(added)
[10:29:54.140]                 for (kk in seq_along(NAMES)) {
[10:29:54.140]                   name <- added[[kk]]
[10:29:54.140]                   NAME <- NAMES[[kk]]
[10:29:54.140]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.140]                     next
[10:29:54.140]                   args[[name]] <- ""
[10:29:54.140]                 }
[10:29:54.140]                 NAMES <- toupper(removed)
[10:29:54.140]                 for (kk in seq_along(NAMES)) {
[10:29:54.140]                   name <- removed[[kk]]
[10:29:54.140]                   NAME <- NAMES[[kk]]
[10:29:54.140]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.140]                     next
[10:29:54.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.140]                 }
[10:29:54.140]                 if (length(args) > 0) 
[10:29:54.140]                   base::do.call(base::Sys.setenv, args = args)
[10:29:54.140]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:54.140]             }
[10:29:54.140]             else {
[10:29:54.140]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:54.140]             }
[10:29:54.140]             {
[10:29:54.140]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:54.140]                   0L) {
[10:29:54.140]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:54.140]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:54.140]                   base::options(opts)
[10:29:54.140]                 }
[10:29:54.140]                 {
[10:29:54.140]                   {
[10:29:54.140]                     NULL
[10:29:54.140]                     RNGkind("Mersenne-Twister")
[10:29:54.140]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:54.140]                       inherits = FALSE)
[10:29:54.140]                   }
[10:29:54.140]                   options(future.plan = NULL)
[10:29:54.140]                   if (is.na(NA_character_)) 
[10:29:54.140]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.140]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:54.140]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:54.140]                     .init = FALSE)
[10:29:54.140]                 }
[10:29:54.140]             }
[10:29:54.140]         }
[10:29:54.140]     })
[10:29:54.140]     if (TRUE) {
[10:29:54.140]         base::sink(type = "output", split = FALSE)
[10:29:54.140]         if (TRUE) {
[10:29:54.140]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:54.140]         }
[10:29:54.140]         else {
[10:29:54.140]             ...future.result["stdout"] <- base::list(NULL)
[10:29:54.140]         }
[10:29:54.140]         base::close(...future.stdout)
[10:29:54.140]         ...future.stdout <- NULL
[10:29:54.140]     }
[10:29:54.140]     ...future.result$conditions <- ...future.conditions
[10:29:54.140]     ...future.result$finished <- base::Sys.time()
[10:29:54.140]     ...future.result
[10:29:54.140] }
[10:29:54.142] assign_globals() ...
[10:29:54.142] List of 5
[10:29:54.142]  $ ...future.FUN            :function (object, ...)  
[10:29:54.142]  $ future.call.arguments    : list()
[10:29:54.142]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.142]  $ ...future.elements_ii    :List of 3
[10:29:54.142]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:54.142]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:29:54.142]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:54.142]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:54.142]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:54.142]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:29:54.142]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:54.142]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:29:54.142]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:54.142]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:29:54.142]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:54.142]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:29:54.142]  $ ...future.seeds_ii       : NULL
[10:29:54.142]  $ ...future.globals.maxSize: NULL
[10:29:54.142]  - attr(*, "where")=List of 5
[10:29:54.142]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:54.142]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:54.142]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:54.142]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:54.142]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:54.142]  - attr(*, "resolved")= logi FALSE
[10:29:54.142]  - attr(*, "total_size")= num 1240
[10:29:54.142]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.142]  - attr(*, "already-done")= logi TRUE
[10:29:54.152] - copied ‘...future.FUN’ to environment
[10:29:54.152] - copied ‘future.call.arguments’ to environment
[10:29:54.152] - copied ‘...future.elements_ii’ to environment
[10:29:54.152] - copied ‘...future.seeds_ii’ to environment
[10:29:54.152] - copied ‘...future.globals.maxSize’ to environment
[10:29:54.152] assign_globals() ... done
[10:29:54.152] plan(): Setting new future strategy stack:
[10:29:54.153] List of future strategies:
[10:29:54.153] 1. sequential:
[10:29:54.153]    - args: function (..., envir = parent.frame())
[10:29:54.153]    - tweaked: FALSE
[10:29:54.153]    - call: NULL
[10:29:54.153] plan(): nbrOfWorkers() = 1
[10:29:54.155] plan(): Setting new future strategy stack:
[10:29:54.155] List of future strategies:
[10:29:54.155] 1. sequential:
[10:29:54.155]    - args: function (..., envir = parent.frame())
[10:29:54.155]    - tweaked: FALSE
[10:29:54.155]    - call: plan(strategy)
[10:29:54.155] plan(): nbrOfWorkers() = 1
[10:29:54.156] SequentialFuture started (and completed)
[10:29:54.156] - Launch lazy future ... done
[10:29:54.156] run() for ‘SequentialFuture’ ... done
[10:29:54.156] Created future:
[10:29:54.156] SequentialFuture:
[10:29:54.156] Label: ‘future_by-1’
[10:29:54.156] Expression:
[10:29:54.156] {
[10:29:54.156]     do.call(function(...) {
[10:29:54.156]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.156]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.156]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.156]             on.exit(options(oopts), add = TRUE)
[10:29:54.156]         }
[10:29:54.156]         {
[10:29:54.156]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.156]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.156]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.156]             })
[10:29:54.156]         }
[10:29:54.156]     }, args = future.call.arguments)
[10:29:54.156] }
[10:29:54.156] Lazy evaluation: FALSE
[10:29:54.156] Asynchronous evaluation: FALSE
[10:29:54.156] Local evaluation: TRUE
[10:29:54.156] Environment: 0x556dd4d8e998
[10:29:54.156] Capture standard output: TRUE
[10:29:54.156] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:54.156] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:54.156] Packages: <none>
[10:29:54.156] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:54.156] Resolved: TRUE
[10:29:54.156] Value: 5.37 KiB of class ‘list’
[10:29:54.156] Early signaling: FALSE
[10:29:54.156] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:54.156] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:54.157] Chunk #1 of 1 ... DONE
[10:29:54.157] Launching 1 futures (chunks) ... DONE
[10:29:54.157] Resolving 1 futures (chunks) ...
[10:29:54.158] resolve() on list ...
[10:29:54.158]  recursive: 0
[10:29:54.158]  length: 1
[10:29:54.158] 
[10:29:54.158] resolved() for ‘SequentialFuture’ ...
[10:29:54.158] - state: ‘finished’
[10:29:54.158] - run: TRUE
[10:29:54.158] - result: ‘FutureResult’
[10:29:54.158] resolved() for ‘SequentialFuture’ ... done
[10:29:54.158] Future #1
[10:29:54.159] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:54.159] - nx: 1
[10:29:54.159] - relay: TRUE
[10:29:54.159] - stdout: TRUE
[10:29:54.159] - signal: TRUE
[10:29:54.159] - resignal: FALSE
[10:29:54.159] - force: TRUE
[10:29:54.159] - relayed: [n=1] FALSE
[10:29:54.159] - queued futures: [n=1] FALSE
[10:29:54.159]  - until=1
[10:29:54.159]  - relaying element #1
[10:29:54.160] - relayed: [n=1] TRUE
[10:29:54.160] - queued futures: [n=1] TRUE
[10:29:54.160] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:54.160]  length: 0 (resolved future 1)
[10:29:54.160] Relaying remaining futures
[10:29:54.160] signalConditionsASAP(NULL, pos=0) ...
[10:29:54.160] - nx: 1
[10:29:54.160] - relay: TRUE
[10:29:54.160] - stdout: TRUE
[10:29:54.160] - signal: TRUE
[10:29:54.160] - resignal: FALSE
[10:29:54.160] - force: TRUE
[10:29:54.161] - relayed: [n=1] TRUE
[10:29:54.161] - queued futures: [n=1] TRUE
 - flush all
[10:29:54.161] - relayed: [n=1] TRUE
[10:29:54.161] - queued futures: [n=1] TRUE
[10:29:54.161] signalConditionsASAP(NULL, pos=0) ... done
[10:29:54.161] resolve() on list ... DONE
[10:29:54.161]  - Number of value chunks collected: 1
[10:29:54.161] Resolving 1 futures (chunks) ... DONE
[10:29:54.161] Reducing values from 1 chunks ...
[10:29:54.161]  - Number of values collected after concatenation: 3
[10:29:54.162]  - Number of values expected: 3
[10:29:54.162] Reducing values from 1 chunks ... DONE
[10:29:54.162] future_lapply() ... DONE
[10:29:54.162] future_by_internal() ... DONE
[10:29:54.163] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[10:29:54.163] future_lapply() ...
[10:29:54.164] Number of chunks: 1
[10:29:54.164] getGlobalsAndPackagesXApply() ...
[10:29:54.164]  - future.globals: TRUE
[10:29:54.164] getGlobalsAndPackages() ...
[10:29:54.164] Searching for globals...
[10:29:54.165] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:54.165] Searching for globals ... DONE
[10:29:54.165] Resolving globals: FALSE
[10:29:54.165] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:54.166] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:54.166] - globals: [1] ‘FUN’
[10:29:54.166] 
[10:29:54.166] getGlobalsAndPackages() ... DONE
[10:29:54.166]  - globals found/used: [n=1] ‘FUN’
[10:29:54.166]  - needed namespaces: [n=0] 
[10:29:54.168] Finding globals ... DONE
[10:29:54.168]  - use_args: TRUE
[10:29:54.168]  - Getting '...' globals ...
[10:29:54.168] resolve() on list ...
[10:29:54.168]  recursive: 0
[10:29:54.168]  length: 1
[10:29:54.168]  elements: ‘...’
[10:29:54.169]  length: 0 (resolved future 1)
[10:29:54.169] resolve() on list ... DONE
[10:29:54.169]    - '...' content: [n=0] 
[10:29:54.169] List of 1
[10:29:54.169]  $ ...: list()
[10:29:54.169]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.169]  - attr(*, "where")=List of 1
[10:29:54.169]   ..$ ...:<environment: 0x556dd50b2a90> 
[10:29:54.169]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.169]  - attr(*, "resolved")= logi TRUE
[10:29:54.169]  - attr(*, "total_size")= num NA
[10:29:54.172]  - Getting '...' globals ... DONE
[10:29:54.172] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:54.172] List of 2
[10:29:54.172]  $ ...future.FUN:function (object, ...)  
[10:29:54.172]  $ ...          : list()
[10:29:54.172]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.172]  - attr(*, "where")=List of 2
[10:29:54.172]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:54.172]   ..$ ...          :<environment: 0x556dd50b2a90> 
[10:29:54.172]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.172]  - attr(*, "resolved")= logi FALSE
[10:29:54.172]  - attr(*, "total_size")= num 1240
[10:29:54.174] Packages to be attached in all futures: [n=0] 
[10:29:54.174] getGlobalsAndPackagesXApply() ... DONE
[10:29:54.175] Number of futures (= number of chunks): 1
[10:29:54.175] Launching 1 futures (chunks) ...
[10:29:54.175] Chunk #1 of 1 ...
[10:29:54.175]  - Finding globals in 'X' for chunk #1 ...
[10:29:54.175] getGlobalsAndPackages() ...
[10:29:54.175] Searching for globals...
[10:29:54.176] 
[10:29:54.176] Searching for globals ... DONE
[10:29:54.176] - globals: [0] <none>
[10:29:54.176] getGlobalsAndPackages() ... DONE
[10:29:54.176]    + additional globals found: [n=0] 
[10:29:54.176]    + additional namespaces needed: [n=0] 
[10:29:54.176]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:54.176]  - seeds: <none>
[10:29:54.176]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.176] getGlobalsAndPackages() ...
[10:29:54.176] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.177] Resolving globals: FALSE
[10:29:54.177] Tweak future expression to call with '...' arguments ...
[10:29:54.177] {
[10:29:54.177]     do.call(function(...) {
[10:29:54.177]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.177]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.177]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.177]             on.exit(options(oopts), add = TRUE)
[10:29:54.177]         }
[10:29:54.177]         {
[10:29:54.177]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.177]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.177]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.177]             })
[10:29:54.177]         }
[10:29:54.177]     }, args = future.call.arguments)
[10:29:54.177] }
[10:29:54.177] Tweak future expression to call with '...' arguments ... DONE
[10:29:54.177] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.177] 
[10:29:54.178] getGlobalsAndPackages() ... DONE
[10:29:54.178] run() for ‘Future’ ...
[10:29:54.178] - state: ‘created’
[10:29:54.178] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:29:54.178] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:54.178] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:54.179]   - Field: ‘label’
[10:29:54.179]   - Field: ‘local’
[10:29:54.179]   - Field: ‘owner’
[10:29:54.179]   - Field: ‘envir’
[10:29:54.179]   - Field: ‘packages’
[10:29:54.179]   - Field: ‘gc’
[10:29:54.179]   - Field: ‘conditions’
[10:29:54.179]   - Field: ‘expr’
[10:29:54.179]   - Field: ‘uuid’
[10:29:54.179]   - Field: ‘seed’
[10:29:54.179]   - Field: ‘version’
[10:29:54.180]   - Field: ‘result’
[10:29:54.180]   - Field: ‘asynchronous’
[10:29:54.180]   - Field: ‘calls’
[10:29:54.180]   - Field: ‘globals’
[10:29:54.180]   - Field: ‘stdout’
[10:29:54.180]   - Field: ‘earlySignal’
[10:29:54.180]   - Field: ‘lazy’
[10:29:54.180]   - Field: ‘state’
[10:29:54.180] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:54.180] - Launch lazy future ...
[10:29:54.181] Packages needed by the future expression (n = 0): <none>
[10:29:54.181] Packages needed by future strategies (n = 0): <none>
[10:29:54.181] {
[10:29:54.181]     {
[10:29:54.181]         {
[10:29:54.181]             ...future.startTime <- base::Sys.time()
[10:29:54.181]             {
[10:29:54.181]                 {
[10:29:54.181]                   {
[10:29:54.181]                     base::local({
[10:29:54.181]                       has_future <- base::requireNamespace("future", 
[10:29:54.181]                         quietly = TRUE)
[10:29:54.181]                       if (has_future) {
[10:29:54.181]                         ns <- base::getNamespace("future")
[10:29:54.181]                         version <- ns[[".package"]][["version"]]
[10:29:54.181]                         if (is.null(version)) 
[10:29:54.181]                           version <- utils::packageVersion("future")
[10:29:54.181]                       }
[10:29:54.181]                       else {
[10:29:54.181]                         version <- NULL
[10:29:54.181]                       }
[10:29:54.181]                       if (!has_future || version < "1.8.0") {
[10:29:54.181]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:54.181]                           "", base::R.version$version.string), 
[10:29:54.181]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:54.181]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:54.181]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:54.181]                             "release", "version")], collapse = " "), 
[10:29:54.181]                           hostname = base::Sys.info()[["nodename"]])
[10:29:54.181]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:54.181]                           info)
[10:29:54.181]                         info <- base::paste(info, collapse = "; ")
[10:29:54.181]                         if (!has_future) {
[10:29:54.181]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:54.181]                             info)
[10:29:54.181]                         }
[10:29:54.181]                         else {
[10:29:54.181]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:54.181]                             info, version)
[10:29:54.181]                         }
[10:29:54.181]                         base::stop(msg)
[10:29:54.181]                       }
[10:29:54.181]                     })
[10:29:54.181]                   }
[10:29:54.181]                   ...future.strategy.old <- future::plan("list")
[10:29:54.181]                   options(future.plan = NULL)
[10:29:54.181]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.181]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:54.181]                 }
[10:29:54.181]                 ...future.workdir <- getwd()
[10:29:54.181]             }
[10:29:54.181]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:54.181]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:54.181]         }
[10:29:54.181]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:54.181]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:54.181]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:54.181]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:54.181]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:54.181]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:54.181]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:54.181]             base::names(...future.oldOptions))
[10:29:54.181]     }
[10:29:54.181]     if (FALSE) {
[10:29:54.181]     }
[10:29:54.181]     else {
[10:29:54.181]         if (TRUE) {
[10:29:54.181]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:54.181]                 open = "w")
[10:29:54.181]         }
[10:29:54.181]         else {
[10:29:54.181]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:54.181]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:54.181]         }
[10:29:54.181]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:54.181]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:54.181]             base::sink(type = "output", split = FALSE)
[10:29:54.181]             base::close(...future.stdout)
[10:29:54.181]         }, add = TRUE)
[10:29:54.181]     }
[10:29:54.181]     ...future.frame <- base::sys.nframe()
[10:29:54.181]     ...future.conditions <- base::list()
[10:29:54.181]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:54.181]     if (FALSE) {
[10:29:54.181]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:54.181]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:54.181]     }
[10:29:54.181]     ...future.result <- base::tryCatch({
[10:29:54.181]         base::withCallingHandlers({
[10:29:54.181]             ...future.value <- base::withVisible(base::local({
[10:29:54.181]                 do.call(function(...) {
[10:29:54.181]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.181]                   if (!identical(...future.globals.maxSize.org, 
[10:29:54.181]                     ...future.globals.maxSize)) {
[10:29:54.181]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.181]                     on.exit(options(oopts), add = TRUE)
[10:29:54.181]                   }
[10:29:54.181]                   {
[10:29:54.181]                     lapply(seq_along(...future.elements_ii), 
[10:29:54.181]                       FUN = function(jj) {
[10:29:54.181]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.181]                         ...future.FUN(...future.X_jj, ...)
[10:29:54.181]                       })
[10:29:54.181]                   }
[10:29:54.181]                 }, args = future.call.arguments)
[10:29:54.181]             }))
[10:29:54.181]             future::FutureResult(value = ...future.value$value, 
[10:29:54.181]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.181]                   ...future.rng), globalenv = if (FALSE) 
[10:29:54.181]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:54.181]                     ...future.globalenv.names))
[10:29:54.181]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:54.181]         }, condition = base::local({
[10:29:54.181]             c <- base::c
[10:29:54.181]             inherits <- base::inherits
[10:29:54.181]             invokeRestart <- base::invokeRestart
[10:29:54.181]             length <- base::length
[10:29:54.181]             list <- base::list
[10:29:54.181]             seq.int <- base::seq.int
[10:29:54.181]             signalCondition <- base::signalCondition
[10:29:54.181]             sys.calls <- base::sys.calls
[10:29:54.181]             `[[` <- base::`[[`
[10:29:54.181]             `+` <- base::`+`
[10:29:54.181]             `<<-` <- base::`<<-`
[10:29:54.181]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:54.181]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:54.181]                   3L)]
[10:29:54.181]             }
[10:29:54.181]             function(cond) {
[10:29:54.181]                 is_error <- inherits(cond, "error")
[10:29:54.181]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:54.181]                   NULL)
[10:29:54.181]                 if (is_error) {
[10:29:54.181]                   sessionInformation <- function() {
[10:29:54.181]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:54.181]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:54.181]                       search = base::search(), system = base::Sys.info())
[10:29:54.181]                   }
[10:29:54.181]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.181]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:54.181]                     cond$call), session = sessionInformation(), 
[10:29:54.181]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:54.181]                   signalCondition(cond)
[10:29:54.181]                 }
[10:29:54.181]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:54.181]                 "immediateCondition"))) {
[10:29:54.181]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:54.181]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.181]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:54.181]                   if (TRUE && !signal) {
[10:29:54.181]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.181]                     {
[10:29:54.181]                       inherits <- base::inherits
[10:29:54.181]                       invokeRestart <- base::invokeRestart
[10:29:54.181]                       is.null <- base::is.null
[10:29:54.181]                       muffled <- FALSE
[10:29:54.181]                       if (inherits(cond, "message")) {
[10:29:54.181]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.181]                         if (muffled) 
[10:29:54.181]                           invokeRestart("muffleMessage")
[10:29:54.181]                       }
[10:29:54.181]                       else if (inherits(cond, "warning")) {
[10:29:54.181]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.181]                         if (muffled) 
[10:29:54.181]                           invokeRestart("muffleWarning")
[10:29:54.181]                       }
[10:29:54.181]                       else if (inherits(cond, "condition")) {
[10:29:54.181]                         if (!is.null(pattern)) {
[10:29:54.181]                           computeRestarts <- base::computeRestarts
[10:29:54.181]                           grepl <- base::grepl
[10:29:54.181]                           restarts <- computeRestarts(cond)
[10:29:54.181]                           for (restart in restarts) {
[10:29:54.181]                             name <- restart$name
[10:29:54.181]                             if (is.null(name)) 
[10:29:54.181]                               next
[10:29:54.181]                             if (!grepl(pattern, name)) 
[10:29:54.181]                               next
[10:29:54.181]                             invokeRestart(restart)
[10:29:54.181]                             muffled <- TRUE
[10:29:54.181]                             break
[10:29:54.181]                           }
[10:29:54.181]                         }
[10:29:54.181]                       }
[10:29:54.181]                       invisible(muffled)
[10:29:54.181]                     }
[10:29:54.181]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.181]                   }
[10:29:54.181]                 }
[10:29:54.181]                 else {
[10:29:54.181]                   if (TRUE) {
[10:29:54.181]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.181]                     {
[10:29:54.181]                       inherits <- base::inherits
[10:29:54.181]                       invokeRestart <- base::invokeRestart
[10:29:54.181]                       is.null <- base::is.null
[10:29:54.181]                       muffled <- FALSE
[10:29:54.181]                       if (inherits(cond, "message")) {
[10:29:54.181]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.181]                         if (muffled) 
[10:29:54.181]                           invokeRestart("muffleMessage")
[10:29:54.181]                       }
[10:29:54.181]                       else if (inherits(cond, "warning")) {
[10:29:54.181]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.181]                         if (muffled) 
[10:29:54.181]                           invokeRestart("muffleWarning")
[10:29:54.181]                       }
[10:29:54.181]                       else if (inherits(cond, "condition")) {
[10:29:54.181]                         if (!is.null(pattern)) {
[10:29:54.181]                           computeRestarts <- base::computeRestarts
[10:29:54.181]                           grepl <- base::grepl
[10:29:54.181]                           restarts <- computeRestarts(cond)
[10:29:54.181]                           for (restart in restarts) {
[10:29:54.181]                             name <- restart$name
[10:29:54.181]                             if (is.null(name)) 
[10:29:54.181]                               next
[10:29:54.181]                             if (!grepl(pattern, name)) 
[10:29:54.181]                               next
[10:29:54.181]                             invokeRestart(restart)
[10:29:54.181]                             muffled <- TRUE
[10:29:54.181]                             break
[10:29:54.181]                           }
[10:29:54.181]                         }
[10:29:54.181]                       }
[10:29:54.181]                       invisible(muffled)
[10:29:54.181]                     }
[10:29:54.181]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.181]                   }
[10:29:54.181]                 }
[10:29:54.181]             }
[10:29:54.181]         }))
[10:29:54.181]     }, error = function(ex) {
[10:29:54.181]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:54.181]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.181]                 ...future.rng), started = ...future.startTime, 
[10:29:54.181]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:54.181]             version = "1.8"), class = "FutureResult")
[10:29:54.181]     }, finally = {
[10:29:54.181]         if (!identical(...future.workdir, getwd())) 
[10:29:54.181]             setwd(...future.workdir)
[10:29:54.181]         {
[10:29:54.181]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:54.181]                 ...future.oldOptions$nwarnings <- NULL
[10:29:54.181]             }
[10:29:54.181]             base::options(...future.oldOptions)
[10:29:54.181]             if (.Platform$OS.type == "windows") {
[10:29:54.181]                 old_names <- names(...future.oldEnvVars)
[10:29:54.181]                 envs <- base::Sys.getenv()
[10:29:54.181]                 names <- names(envs)
[10:29:54.181]                 common <- intersect(names, old_names)
[10:29:54.181]                 added <- setdiff(names, old_names)
[10:29:54.181]                 removed <- setdiff(old_names, names)
[10:29:54.181]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:54.181]                   envs[common]]
[10:29:54.181]                 NAMES <- toupper(changed)
[10:29:54.181]                 args <- list()
[10:29:54.181]                 for (kk in seq_along(NAMES)) {
[10:29:54.181]                   name <- changed[[kk]]
[10:29:54.181]                   NAME <- NAMES[[kk]]
[10:29:54.181]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.181]                     next
[10:29:54.181]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.181]                 }
[10:29:54.181]                 NAMES <- toupper(added)
[10:29:54.181]                 for (kk in seq_along(NAMES)) {
[10:29:54.181]                   name <- added[[kk]]
[10:29:54.181]                   NAME <- NAMES[[kk]]
[10:29:54.181]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.181]                     next
[10:29:54.181]                   args[[name]] <- ""
[10:29:54.181]                 }
[10:29:54.181]                 NAMES <- toupper(removed)
[10:29:54.181]                 for (kk in seq_along(NAMES)) {
[10:29:54.181]                   name <- removed[[kk]]
[10:29:54.181]                   NAME <- NAMES[[kk]]
[10:29:54.181]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.181]                     next
[10:29:54.181]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.181]                 }
[10:29:54.181]                 if (length(args) > 0) 
[10:29:54.181]                   base::do.call(base::Sys.setenv, args = args)
[10:29:54.181]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:54.181]             }
[10:29:54.181]             else {
[10:29:54.181]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:54.181]             }
[10:29:54.181]             {
[10:29:54.181]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:54.181]                   0L) {
[10:29:54.181]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:54.181]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:54.181]                   base::options(opts)
[10:29:54.181]                 }
[10:29:54.181]                 {
[10:29:54.181]                   {
[10:29:54.181]                     NULL
[10:29:54.181]                     RNGkind("Mersenne-Twister")
[10:29:54.181]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:54.181]                       inherits = FALSE)
[10:29:54.181]                   }
[10:29:54.181]                   options(future.plan = NULL)
[10:29:54.181]                   if (is.na(NA_character_)) 
[10:29:54.181]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.181]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:54.181]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:54.181]                     .init = FALSE)
[10:29:54.181]                 }
[10:29:54.181]             }
[10:29:54.181]         }
[10:29:54.181]     })
[10:29:54.181]     if (TRUE) {
[10:29:54.181]         base::sink(type = "output", split = FALSE)
[10:29:54.181]         if (TRUE) {
[10:29:54.181]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:54.181]         }
[10:29:54.181]         else {
[10:29:54.181]             ...future.result["stdout"] <- base::list(NULL)
[10:29:54.181]         }
[10:29:54.181]         base::close(...future.stdout)
[10:29:54.181]         ...future.stdout <- NULL
[10:29:54.181]     }
[10:29:54.181]     ...future.result$conditions <- ...future.conditions
[10:29:54.181]     ...future.result$finished <- base::Sys.time()
[10:29:54.181]     ...future.result
[10:29:54.181] }
[10:29:54.183] assign_globals() ...
[10:29:54.183] List of 5
[10:29:54.183]  $ ...future.FUN            :function (object, ...)  
[10:29:54.183]  $ future.call.arguments    : list()
[10:29:54.183]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.183]  $ ...future.elements_ii    :List of 3
[10:29:54.183]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:54.183]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:29:54.183]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:54.183]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:54.183]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:54.183]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:29:54.183]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:54.183]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:29:54.183]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:54.183]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:29:54.183]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:54.183]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:29:54.183]  $ ...future.seeds_ii       : NULL
[10:29:54.183]  $ ...future.globals.maxSize: NULL
[10:29:54.183]  - attr(*, "where")=List of 5
[10:29:54.183]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:54.183]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:54.183]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:54.183]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:54.183]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:54.183]  - attr(*, "resolved")= logi FALSE
[10:29:54.183]  - attr(*, "total_size")= num 1240
[10:29:54.183]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.183]  - attr(*, "already-done")= logi TRUE
[10:29:54.193] - copied ‘...future.FUN’ to environment
[10:29:54.193] - copied ‘future.call.arguments’ to environment
[10:29:54.193] - copied ‘...future.elements_ii’ to environment
[10:29:54.193] - copied ‘...future.seeds_ii’ to environment
[10:29:54.193] - copied ‘...future.globals.maxSize’ to environment
[10:29:54.193] assign_globals() ... done
[10:29:54.193] plan(): Setting new future strategy stack:
[10:29:54.193] List of future strategies:
[10:29:54.193] 1. sequential:
[10:29:54.193]    - args: function (..., envir = parent.frame())
[10:29:54.193]    - tweaked: FALSE
[10:29:54.193]    - call: NULL
[10:29:54.194] plan(): nbrOfWorkers() = 1
[10:29:54.196] plan(): Setting new future strategy stack:
[10:29:54.196] List of future strategies:
[10:29:54.196] 1. sequential:
[10:29:54.196]    - args: function (..., envir = parent.frame())
[10:29:54.196]    - tweaked: FALSE
[10:29:54.196]    - call: plan(strategy)
[10:29:54.196] plan(): nbrOfWorkers() = 1
[10:29:54.196] SequentialFuture started (and completed)
[10:29:54.197] - Launch lazy future ... done
[10:29:54.197] run() for ‘SequentialFuture’ ... done
[10:29:54.197] Created future:
[10:29:54.197] SequentialFuture:
[10:29:54.197] Label: ‘future_by-1’
[10:29:54.197] Expression:
[10:29:54.197] {
[10:29:54.197]     do.call(function(...) {
[10:29:54.197]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.197]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.197]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.197]             on.exit(options(oopts), add = TRUE)
[10:29:54.197]         }
[10:29:54.197]         {
[10:29:54.197]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.197]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.197]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.197]             })
[10:29:54.197]         }
[10:29:54.197]     }, args = future.call.arguments)
[10:29:54.197] }
[10:29:54.197] Lazy evaluation: FALSE
[10:29:54.197] Asynchronous evaluation: FALSE
[10:29:54.197] Local evaluation: TRUE
[10:29:54.197] Environment: 0x556dd5064608
[10:29:54.197] Capture standard output: TRUE
[10:29:54.197] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:54.197] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:54.197] Packages: <none>
[10:29:54.197] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:54.197] Resolved: TRUE
[10:29:54.197] Value: 5.37 KiB of class ‘list’
[10:29:54.197] Early signaling: FALSE
[10:29:54.197] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:54.197] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:54.198] Chunk #1 of 1 ... DONE
[10:29:54.198] Launching 1 futures (chunks) ... DONE
[10:29:54.198] Resolving 1 futures (chunks) ...
[10:29:54.198] resolve() on list ...
[10:29:54.198]  recursive: 0
[10:29:54.199]  length: 1
[10:29:54.199] 
[10:29:54.199] resolved() for ‘SequentialFuture’ ...
[10:29:54.199] - state: ‘finished’
[10:29:54.199] - run: TRUE
[10:29:54.199] - result: ‘FutureResult’
[10:29:54.199] resolved() for ‘SequentialFuture’ ... done
[10:29:54.199] Future #1
[10:29:54.199] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:54.199] - nx: 1
[10:29:54.199] - relay: TRUE
[10:29:54.200] - stdout: TRUE
[10:29:54.200] - signal: TRUE
[10:29:54.200] - resignal: FALSE
[10:29:54.200] - force: TRUE
[10:29:54.200] - relayed: [n=1] FALSE
[10:29:54.200] - queued futures: [n=1] FALSE
[10:29:54.200]  - until=1
[10:29:54.200]  - relaying element #1
[10:29:54.200] - relayed: [n=1] TRUE
[10:29:54.200] - queued futures: [n=1] TRUE
[10:29:54.200] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:54.201]  length: 0 (resolved future 1)
[10:29:54.201] Relaying remaining futures
[10:29:54.201] signalConditionsASAP(NULL, pos=0) ...
[10:29:54.201] - nx: 1
[10:29:54.201] - relay: TRUE
[10:29:54.201] - stdout: TRUE
[10:29:54.201] - signal: TRUE
[10:29:54.201] - resignal: FALSE
[10:29:54.201] - force: TRUE
[10:29:54.201] - relayed: [n=1] TRUE
[10:29:54.201] - queued futures: [n=1] TRUE
 - flush all
[10:29:54.202] - relayed: [n=1] TRUE
[10:29:54.202] - queued futures: [n=1] TRUE
[10:29:54.202] signalConditionsASAP(NULL, pos=0) ... done
[10:29:54.202] resolve() on list ... DONE
[10:29:54.202]  - Number of value chunks collected: 1
[10:29:54.202] Resolving 1 futures (chunks) ... DONE
[10:29:54.202] Reducing values from 1 chunks ...
[10:29:54.202]  - Number of values collected after concatenation: 3
[10:29:54.202]  - Number of values expected: 3
[10:29:54.202] Reducing values from 1 chunks ... DONE
[10:29:54.202] future_lapply() ... DONE
[10:29:54.203] future_by_internal() ... DONE
[10:29:54.203] future_by_internal() ...
- plan('multicore') ...
[10:29:54.205] plan(): Setting new future strategy stack:
[10:29:54.205] List of future strategies:
[10:29:54.205] 1. multicore:
[10:29:54.205]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:54.205]    - tweaked: FALSE
[10:29:54.205]    - call: plan(strategy)
[10:29:54.209] plan(): nbrOfWorkers() = 2
[10:29:54.209] future_by_internal() ...
[10:29:54.209] future_lapply() ...
[10:29:54.214] Number of chunks: 2
[10:29:54.214] getGlobalsAndPackagesXApply() ...
[10:29:54.214]  - future.globals: TRUE
[10:29:54.214] getGlobalsAndPackages() ...
[10:29:54.214] Searching for globals...
[10:29:54.215] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:54.215] Searching for globals ... DONE
[10:29:54.215] Resolving globals: FALSE
[10:29:54.216] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:54.216] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:54.216] - globals: [1] ‘FUN’
[10:29:54.216] 
[10:29:54.216] getGlobalsAndPackages() ... DONE
[10:29:54.216]  - globals found/used: [n=1] ‘FUN’
[10:29:54.217]  - needed namespaces: [n=0] 
[10:29:54.217] Finding globals ... DONE
[10:29:54.217]  - use_args: TRUE
[10:29:54.217]  - Getting '...' globals ...
[10:29:54.217] resolve() on list ...
[10:29:54.217]  recursive: 0
[10:29:54.217]  length: 1
[10:29:54.217]  elements: ‘...’
[10:29:54.218]  length: 0 (resolved future 1)
[10:29:54.218] resolve() on list ... DONE
[10:29:54.218]    - '...' content: [n=0] 
[10:29:54.218] List of 1
[10:29:54.218]  $ ...: list()
[10:29:54.218]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.218]  - attr(*, "where")=List of 1
[10:29:54.218]   ..$ ...:<environment: 0x556dd36e0358> 
[10:29:54.218]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.218]  - attr(*, "resolved")= logi TRUE
[10:29:54.218]  - attr(*, "total_size")= num NA
[10:29:54.220]  - Getting '...' globals ... DONE
[10:29:54.220] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:54.220] List of 2
[10:29:54.220]  $ ...future.FUN:function (object, ...)  
[10:29:54.220]  $ ...          : list()
[10:29:54.220]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.220]  - attr(*, "where")=List of 2
[10:29:54.220]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:54.220]   ..$ ...          :<environment: 0x556dd36e0358> 
[10:29:54.220]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.220]  - attr(*, "resolved")= logi FALSE
[10:29:54.220]  - attr(*, "total_size")= num 1240
[10:29:54.223] Packages to be attached in all futures: [n=0] 
[10:29:54.223] getGlobalsAndPackagesXApply() ... DONE
[10:29:54.223] Number of futures (= number of chunks): 2
[10:29:54.223] Launching 2 futures (chunks) ...
[10:29:54.223] Chunk #1 of 2 ...
[10:29:54.224]  - Finding globals in 'X' for chunk #1 ...
[10:29:54.224] getGlobalsAndPackages() ...
[10:29:54.224] Searching for globals...
[10:29:54.224] 
[10:29:54.224] Searching for globals ... DONE
[10:29:54.224] - globals: [0] <none>
[10:29:54.224] getGlobalsAndPackages() ... DONE
[10:29:54.224]    + additional globals found: [n=0] 
[10:29:54.225]    + additional namespaces needed: [n=0] 
[10:29:54.225]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:54.225]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:54.225]  - seeds: <none>
[10:29:54.225]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.225] getGlobalsAndPackages() ...
[10:29:54.225] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.225] Resolving globals: FALSE
[10:29:54.225] Tweak future expression to call with '...' arguments ...
[10:29:54.226] {
[10:29:54.226]     do.call(function(...) {
[10:29:54.226]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.226]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.226]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.226]             on.exit(options(oopts), add = TRUE)
[10:29:54.226]         }
[10:29:54.226]         {
[10:29:54.226]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.226]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.226]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.226]             })
[10:29:54.226]         }
[10:29:54.226]     }, args = future.call.arguments)
[10:29:54.226] }
[10:29:54.226] Tweak future expression to call with '...' arguments ... DONE
[10:29:54.226] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.226] 
[10:29:54.226] getGlobalsAndPackages() ... DONE
[10:29:54.227] run() for ‘Future’ ...
[10:29:54.227] - state: ‘created’
[10:29:54.227] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:54.232] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:54.232] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:54.232]   - Field: ‘label’
[10:29:54.232]   - Field: ‘local’
[10:29:54.232]   - Field: ‘owner’
[10:29:54.232]   - Field: ‘envir’
[10:29:54.232]   - Field: ‘workers’
[10:29:54.232]   - Field: ‘packages’
[10:29:54.233]   - Field: ‘gc’
[10:29:54.233]   - Field: ‘job’
[10:29:54.233]   - Field: ‘conditions’
[10:29:54.233]   - Field: ‘expr’
[10:29:54.233]   - Field: ‘uuid’
[10:29:54.233]   - Field: ‘seed’
[10:29:54.233]   - Field: ‘version’
[10:29:54.233]   - Field: ‘result’
[10:29:54.233]   - Field: ‘asynchronous’
[10:29:54.233]   - Field: ‘calls’
[10:29:54.234]   - Field: ‘globals’
[10:29:54.234]   - Field: ‘stdout’
[10:29:54.234]   - Field: ‘earlySignal’
[10:29:54.234]   - Field: ‘lazy’
[10:29:54.234]   - Field: ‘state’
[10:29:54.234] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:54.234] - Launch lazy future ...
[10:29:54.235] Packages needed by the future expression (n = 0): <none>
[10:29:54.235] Packages needed by future strategies (n = 0): <none>
[10:29:54.236] {
[10:29:54.236]     {
[10:29:54.236]         {
[10:29:54.236]             ...future.startTime <- base::Sys.time()
[10:29:54.236]             {
[10:29:54.236]                 {
[10:29:54.236]                   {
[10:29:54.236]                     {
[10:29:54.236]                       base::local({
[10:29:54.236]                         has_future <- base::requireNamespace("future", 
[10:29:54.236]                           quietly = TRUE)
[10:29:54.236]                         if (has_future) {
[10:29:54.236]                           ns <- base::getNamespace("future")
[10:29:54.236]                           version <- ns[[".package"]][["version"]]
[10:29:54.236]                           if (is.null(version)) 
[10:29:54.236]                             version <- utils::packageVersion("future")
[10:29:54.236]                         }
[10:29:54.236]                         else {
[10:29:54.236]                           version <- NULL
[10:29:54.236]                         }
[10:29:54.236]                         if (!has_future || version < "1.8.0") {
[10:29:54.236]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:54.236]                             "", base::R.version$version.string), 
[10:29:54.236]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:54.236]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:54.236]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:54.236]                               "release", "version")], collapse = " "), 
[10:29:54.236]                             hostname = base::Sys.info()[["nodename"]])
[10:29:54.236]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:54.236]                             info)
[10:29:54.236]                           info <- base::paste(info, collapse = "; ")
[10:29:54.236]                           if (!has_future) {
[10:29:54.236]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:54.236]                               info)
[10:29:54.236]                           }
[10:29:54.236]                           else {
[10:29:54.236]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:54.236]                               info, version)
[10:29:54.236]                           }
[10:29:54.236]                           base::stop(msg)
[10:29:54.236]                         }
[10:29:54.236]                       })
[10:29:54.236]                     }
[10:29:54.236]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:54.236]                     base::options(mc.cores = 1L)
[10:29:54.236]                   }
[10:29:54.236]                   ...future.strategy.old <- future::plan("list")
[10:29:54.236]                   options(future.plan = NULL)
[10:29:54.236]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.236]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:54.236]                 }
[10:29:54.236]                 ...future.workdir <- getwd()
[10:29:54.236]             }
[10:29:54.236]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:54.236]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:54.236]         }
[10:29:54.236]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:54.236]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:54.236]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:54.236]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:54.236]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:54.236]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:54.236]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:54.236]             base::names(...future.oldOptions))
[10:29:54.236]     }
[10:29:54.236]     if (FALSE) {
[10:29:54.236]     }
[10:29:54.236]     else {
[10:29:54.236]         if (TRUE) {
[10:29:54.236]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:54.236]                 open = "w")
[10:29:54.236]         }
[10:29:54.236]         else {
[10:29:54.236]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:54.236]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:54.236]         }
[10:29:54.236]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:54.236]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:54.236]             base::sink(type = "output", split = FALSE)
[10:29:54.236]             base::close(...future.stdout)
[10:29:54.236]         }, add = TRUE)
[10:29:54.236]     }
[10:29:54.236]     ...future.frame <- base::sys.nframe()
[10:29:54.236]     ...future.conditions <- base::list()
[10:29:54.236]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:54.236]     if (FALSE) {
[10:29:54.236]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:54.236]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:54.236]     }
[10:29:54.236]     ...future.result <- base::tryCatch({
[10:29:54.236]         base::withCallingHandlers({
[10:29:54.236]             ...future.value <- base::withVisible(base::local({
[10:29:54.236]                 withCallingHandlers({
[10:29:54.236]                   {
[10:29:54.236]                     do.call(function(...) {
[10:29:54.236]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.236]                       if (!identical(...future.globals.maxSize.org, 
[10:29:54.236]                         ...future.globals.maxSize)) {
[10:29:54.236]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.236]                         on.exit(options(oopts), add = TRUE)
[10:29:54.236]                       }
[10:29:54.236]                       {
[10:29:54.236]                         lapply(seq_along(...future.elements_ii), 
[10:29:54.236]                           FUN = function(jj) {
[10:29:54.236]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.236]                             ...future.FUN(...future.X_jj, ...)
[10:29:54.236]                           })
[10:29:54.236]                       }
[10:29:54.236]                     }, args = future.call.arguments)
[10:29:54.236]                   }
[10:29:54.236]                 }, immediateCondition = function(cond) {
[10:29:54.236]                   save_rds <- function (object, pathname, ...) 
[10:29:54.236]                   {
[10:29:54.236]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:54.236]                     if (file_test("-f", pathname_tmp)) {
[10:29:54.236]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.236]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:54.236]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.236]                         fi_tmp[["mtime"]])
[10:29:54.236]                     }
[10:29:54.236]                     tryCatch({
[10:29:54.236]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:54.236]                     }, error = function(ex) {
[10:29:54.236]                       msg <- conditionMessage(ex)
[10:29:54.236]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.236]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:54.236]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.236]                         fi_tmp[["mtime"]], msg)
[10:29:54.236]                       ex$message <- msg
[10:29:54.236]                       stop(ex)
[10:29:54.236]                     })
[10:29:54.236]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:54.236]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:54.236]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:54.236]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.236]                       fi <- file.info(pathname)
[10:29:54.236]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:54.236]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.236]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:54.236]                         fi[["size"]], fi[["mtime"]])
[10:29:54.236]                       stop(msg)
[10:29:54.236]                     }
[10:29:54.236]                     invisible(pathname)
[10:29:54.236]                   }
[10:29:54.236]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:54.236]                     rootPath = tempdir()) 
[10:29:54.236]                   {
[10:29:54.236]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:54.236]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:54.236]                       tmpdir = path, fileext = ".rds")
[10:29:54.236]                     save_rds(obj, file)
[10:29:54.236]                   }
[10:29:54.236]                   saveImmediateCondition(cond, path = "/tmp/Rtmp11FQBX/.future/immediateConditions")
[10:29:54.236]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.236]                   {
[10:29:54.236]                     inherits <- base::inherits
[10:29:54.236]                     invokeRestart <- base::invokeRestart
[10:29:54.236]                     is.null <- base::is.null
[10:29:54.236]                     muffled <- FALSE
[10:29:54.236]                     if (inherits(cond, "message")) {
[10:29:54.236]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:54.236]                       if (muffled) 
[10:29:54.236]                         invokeRestart("muffleMessage")
[10:29:54.236]                     }
[10:29:54.236]                     else if (inherits(cond, "warning")) {
[10:29:54.236]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:54.236]                       if (muffled) 
[10:29:54.236]                         invokeRestart("muffleWarning")
[10:29:54.236]                     }
[10:29:54.236]                     else if (inherits(cond, "condition")) {
[10:29:54.236]                       if (!is.null(pattern)) {
[10:29:54.236]                         computeRestarts <- base::computeRestarts
[10:29:54.236]                         grepl <- base::grepl
[10:29:54.236]                         restarts <- computeRestarts(cond)
[10:29:54.236]                         for (restart in restarts) {
[10:29:54.236]                           name <- restart$name
[10:29:54.236]                           if (is.null(name)) 
[10:29:54.236]                             next
[10:29:54.236]                           if (!grepl(pattern, name)) 
[10:29:54.236]                             next
[10:29:54.236]                           invokeRestart(restart)
[10:29:54.236]                           muffled <- TRUE
[10:29:54.236]                           break
[10:29:54.236]                         }
[10:29:54.236]                       }
[10:29:54.236]                     }
[10:29:54.236]                     invisible(muffled)
[10:29:54.236]                   }
[10:29:54.236]                   muffleCondition(cond)
[10:29:54.236]                 })
[10:29:54.236]             }))
[10:29:54.236]             future::FutureResult(value = ...future.value$value, 
[10:29:54.236]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.236]                   ...future.rng), globalenv = if (FALSE) 
[10:29:54.236]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:54.236]                     ...future.globalenv.names))
[10:29:54.236]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:54.236]         }, condition = base::local({
[10:29:54.236]             c <- base::c
[10:29:54.236]             inherits <- base::inherits
[10:29:54.236]             invokeRestart <- base::invokeRestart
[10:29:54.236]             length <- base::length
[10:29:54.236]             list <- base::list
[10:29:54.236]             seq.int <- base::seq.int
[10:29:54.236]             signalCondition <- base::signalCondition
[10:29:54.236]             sys.calls <- base::sys.calls
[10:29:54.236]             `[[` <- base::`[[`
[10:29:54.236]             `+` <- base::`+`
[10:29:54.236]             `<<-` <- base::`<<-`
[10:29:54.236]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:54.236]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:54.236]                   3L)]
[10:29:54.236]             }
[10:29:54.236]             function(cond) {
[10:29:54.236]                 is_error <- inherits(cond, "error")
[10:29:54.236]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:54.236]                   NULL)
[10:29:54.236]                 if (is_error) {
[10:29:54.236]                   sessionInformation <- function() {
[10:29:54.236]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:54.236]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:54.236]                       search = base::search(), system = base::Sys.info())
[10:29:54.236]                   }
[10:29:54.236]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.236]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:54.236]                     cond$call), session = sessionInformation(), 
[10:29:54.236]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:54.236]                   signalCondition(cond)
[10:29:54.236]                 }
[10:29:54.236]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:54.236]                 "immediateCondition"))) {
[10:29:54.236]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:54.236]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.236]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:54.236]                   if (TRUE && !signal) {
[10:29:54.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.236]                     {
[10:29:54.236]                       inherits <- base::inherits
[10:29:54.236]                       invokeRestart <- base::invokeRestart
[10:29:54.236]                       is.null <- base::is.null
[10:29:54.236]                       muffled <- FALSE
[10:29:54.236]                       if (inherits(cond, "message")) {
[10:29:54.236]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.236]                         if (muffled) 
[10:29:54.236]                           invokeRestart("muffleMessage")
[10:29:54.236]                       }
[10:29:54.236]                       else if (inherits(cond, "warning")) {
[10:29:54.236]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.236]                         if (muffled) 
[10:29:54.236]                           invokeRestart("muffleWarning")
[10:29:54.236]                       }
[10:29:54.236]                       else if (inherits(cond, "condition")) {
[10:29:54.236]                         if (!is.null(pattern)) {
[10:29:54.236]                           computeRestarts <- base::computeRestarts
[10:29:54.236]                           grepl <- base::grepl
[10:29:54.236]                           restarts <- computeRestarts(cond)
[10:29:54.236]                           for (restart in restarts) {
[10:29:54.236]                             name <- restart$name
[10:29:54.236]                             if (is.null(name)) 
[10:29:54.236]                               next
[10:29:54.236]                             if (!grepl(pattern, name)) 
[10:29:54.236]                               next
[10:29:54.236]                             invokeRestart(restart)
[10:29:54.236]                             muffled <- TRUE
[10:29:54.236]                             break
[10:29:54.236]                           }
[10:29:54.236]                         }
[10:29:54.236]                       }
[10:29:54.236]                       invisible(muffled)
[10:29:54.236]                     }
[10:29:54.236]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.236]                   }
[10:29:54.236]                 }
[10:29:54.236]                 else {
[10:29:54.236]                   if (TRUE) {
[10:29:54.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.236]                     {
[10:29:54.236]                       inherits <- base::inherits
[10:29:54.236]                       invokeRestart <- base::invokeRestart
[10:29:54.236]                       is.null <- base::is.null
[10:29:54.236]                       muffled <- FALSE
[10:29:54.236]                       if (inherits(cond, "message")) {
[10:29:54.236]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.236]                         if (muffled) 
[10:29:54.236]                           invokeRestart("muffleMessage")
[10:29:54.236]                       }
[10:29:54.236]                       else if (inherits(cond, "warning")) {
[10:29:54.236]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.236]                         if (muffled) 
[10:29:54.236]                           invokeRestart("muffleWarning")
[10:29:54.236]                       }
[10:29:54.236]                       else if (inherits(cond, "condition")) {
[10:29:54.236]                         if (!is.null(pattern)) {
[10:29:54.236]                           computeRestarts <- base::computeRestarts
[10:29:54.236]                           grepl <- base::grepl
[10:29:54.236]                           restarts <- computeRestarts(cond)
[10:29:54.236]                           for (restart in restarts) {
[10:29:54.236]                             name <- restart$name
[10:29:54.236]                             if (is.null(name)) 
[10:29:54.236]                               next
[10:29:54.236]                             if (!grepl(pattern, name)) 
[10:29:54.236]                               next
[10:29:54.236]                             invokeRestart(restart)
[10:29:54.236]                             muffled <- TRUE
[10:29:54.236]                             break
[10:29:54.236]                           }
[10:29:54.236]                         }
[10:29:54.236]                       }
[10:29:54.236]                       invisible(muffled)
[10:29:54.236]                     }
[10:29:54.236]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.236]                   }
[10:29:54.236]                 }
[10:29:54.236]             }
[10:29:54.236]         }))
[10:29:54.236]     }, error = function(ex) {
[10:29:54.236]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:54.236]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.236]                 ...future.rng), started = ...future.startTime, 
[10:29:54.236]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:54.236]             version = "1.8"), class = "FutureResult")
[10:29:54.236]     }, finally = {
[10:29:54.236]         if (!identical(...future.workdir, getwd())) 
[10:29:54.236]             setwd(...future.workdir)
[10:29:54.236]         {
[10:29:54.236]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:54.236]                 ...future.oldOptions$nwarnings <- NULL
[10:29:54.236]             }
[10:29:54.236]             base::options(...future.oldOptions)
[10:29:54.236]             if (.Platform$OS.type == "windows") {
[10:29:54.236]                 old_names <- names(...future.oldEnvVars)
[10:29:54.236]                 envs <- base::Sys.getenv()
[10:29:54.236]                 names <- names(envs)
[10:29:54.236]                 common <- intersect(names, old_names)
[10:29:54.236]                 added <- setdiff(names, old_names)
[10:29:54.236]                 removed <- setdiff(old_names, names)
[10:29:54.236]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:54.236]                   envs[common]]
[10:29:54.236]                 NAMES <- toupper(changed)
[10:29:54.236]                 args <- list()
[10:29:54.236]                 for (kk in seq_along(NAMES)) {
[10:29:54.236]                   name <- changed[[kk]]
[10:29:54.236]                   NAME <- NAMES[[kk]]
[10:29:54.236]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.236]                     next
[10:29:54.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.236]                 }
[10:29:54.236]                 NAMES <- toupper(added)
[10:29:54.236]                 for (kk in seq_along(NAMES)) {
[10:29:54.236]                   name <- added[[kk]]
[10:29:54.236]                   NAME <- NAMES[[kk]]
[10:29:54.236]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.236]                     next
[10:29:54.236]                   args[[name]] <- ""
[10:29:54.236]                 }
[10:29:54.236]                 NAMES <- toupper(removed)
[10:29:54.236]                 for (kk in seq_along(NAMES)) {
[10:29:54.236]                   name <- removed[[kk]]
[10:29:54.236]                   NAME <- NAMES[[kk]]
[10:29:54.236]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.236]                     next
[10:29:54.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.236]                 }
[10:29:54.236]                 if (length(args) > 0) 
[10:29:54.236]                   base::do.call(base::Sys.setenv, args = args)
[10:29:54.236]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:54.236]             }
[10:29:54.236]             else {
[10:29:54.236]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:54.236]             }
[10:29:54.236]             {
[10:29:54.236]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:54.236]                   0L) {
[10:29:54.236]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:54.236]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:54.236]                   base::options(opts)
[10:29:54.236]                 }
[10:29:54.236]                 {
[10:29:54.236]                   {
[10:29:54.236]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:54.236]                     NULL
[10:29:54.236]                   }
[10:29:54.236]                   options(future.plan = NULL)
[10:29:54.236]                   if (is.na(NA_character_)) 
[10:29:54.236]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.236]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:54.236]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:54.236]                     .init = FALSE)
[10:29:54.236]                 }
[10:29:54.236]             }
[10:29:54.236]         }
[10:29:54.236]     })
[10:29:54.236]     if (TRUE) {
[10:29:54.236]         base::sink(type = "output", split = FALSE)
[10:29:54.236]         if (TRUE) {
[10:29:54.236]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:54.236]         }
[10:29:54.236]         else {
[10:29:54.236]             ...future.result["stdout"] <- base::list(NULL)
[10:29:54.236]         }
[10:29:54.236]         base::close(...future.stdout)
[10:29:54.236]         ...future.stdout <- NULL
[10:29:54.236]     }
[10:29:54.236]     ...future.result$conditions <- ...future.conditions
[10:29:54.236]     ...future.result$finished <- base::Sys.time()
[10:29:54.236]     ...future.result
[10:29:54.236] }
[10:29:54.238] assign_globals() ...
[10:29:54.238] List of 5
[10:29:54.238]  $ ...future.FUN            :function (object, ...)  
[10:29:54.238]  $ future.call.arguments    : list()
[10:29:54.238]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.238]  $ ...future.elements_ii    :List of 1
[10:29:54.238]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:29:54.238]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:29:54.238]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:54.238]  $ ...future.seeds_ii       : NULL
[10:29:54.238]  $ ...future.globals.maxSize: NULL
[10:29:54.238]  - attr(*, "where")=List of 5
[10:29:54.238]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:54.238]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:54.238]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:54.238]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:54.238]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:54.238]  - attr(*, "resolved")= logi FALSE
[10:29:54.238]  - attr(*, "total_size")= num 1240
[10:29:54.238]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.238]  - attr(*, "already-done")= logi TRUE
[10:29:54.243] - copied ‘...future.FUN’ to environment
[10:29:54.244] - copied ‘future.call.arguments’ to environment
[10:29:54.244] - copied ‘...future.elements_ii’ to environment
[10:29:54.244] - copied ‘...future.seeds_ii’ to environment
[10:29:54.244] - copied ‘...future.globals.maxSize’ to environment
[10:29:54.244] assign_globals() ... done
[10:29:54.244] requestCore(): workers = 2
[10:29:54.247] MulticoreFuture started
[10:29:54.248] - Launch lazy future ... done
[10:29:54.248] run() for ‘MulticoreFuture’ ... done
[10:29:54.248] plan(): Setting new future strategy stack:
[10:29:54.248] Created future:
[10:29:54.248] List of future strategies:
[10:29:54.248] 1. sequential:
[10:29:54.248]    - args: function (..., envir = parent.frame())
[10:29:54.248]    - tweaked: FALSE
[10:29:54.248]    - call: NULL
[10:29:54.249] plan(): nbrOfWorkers() = 1
[10:29:54.253] plan(): Setting new future strategy stack:
[10:29:54.253] List of future strategies:
[10:29:54.253] 1. multicore:
[10:29:54.253]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:54.253]    - tweaked: FALSE
[10:29:54.253]    - call: plan(strategy)
[10:29:54.258] plan(): nbrOfWorkers() = 2
[10:29:54.249] MulticoreFuture:
[10:29:54.249] Label: ‘future_by-1’
[10:29:54.249] Expression:
[10:29:54.249] {
[10:29:54.249]     do.call(function(...) {
[10:29:54.249]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.249]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.249]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.249]             on.exit(options(oopts), add = TRUE)
[10:29:54.249]         }
[10:29:54.249]         {
[10:29:54.249]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.249]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.249]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.249]             })
[10:29:54.249]         }
[10:29:54.249]     }, args = future.call.arguments)
[10:29:54.249] }
[10:29:54.249] Lazy evaluation: FALSE
[10:29:54.249] Asynchronous evaluation: TRUE
[10:29:54.249] Local evaluation: TRUE
[10:29:54.249] Environment: R_GlobalEnv
[10:29:54.249] Capture standard output: TRUE
[10:29:54.249] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:54.249] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:54.249] Packages: <none>
[10:29:54.249] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:54.249] Resolved: TRUE
[10:29:54.249] Value: <not collected>
[10:29:54.249] Conditions captured: <none>
[10:29:54.249] Early signaling: FALSE
[10:29:54.249] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:54.249] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:54.259] Chunk #1 of 2 ... DONE
[10:29:54.260] Chunk #2 of 2 ...
[10:29:54.260]  - Finding globals in 'X' for chunk #2 ...
[10:29:54.260] getGlobalsAndPackages() ...
[10:29:54.260] Searching for globals...
[10:29:54.261] 
[10:29:54.261] Searching for globals ... DONE
[10:29:54.261] - globals: [0] <none>
[10:29:54.261] getGlobalsAndPackages() ... DONE
[10:29:54.261]    + additional globals found: [n=0] 
[10:29:54.262]    + additional namespaces needed: [n=0] 
[10:29:54.262]  - Finding globals in 'X' for chunk #2 ... DONE
[10:29:54.262]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:54.262]  - seeds: <none>
[10:29:54.262]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.262] getGlobalsAndPackages() ...
[10:29:54.262] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.263] Resolving globals: FALSE
[10:29:54.263] Tweak future expression to call with '...' arguments ...
[10:29:54.263] {
[10:29:54.263]     do.call(function(...) {
[10:29:54.263]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.263]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.263]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.263]             on.exit(options(oopts), add = TRUE)
[10:29:54.263]         }
[10:29:54.263]         {
[10:29:54.263]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.263]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.263]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.263]             })
[10:29:54.263]         }
[10:29:54.263]     }, args = future.call.arguments)
[10:29:54.263] }
[10:29:54.263] Tweak future expression to call with '...' arguments ... DONE
[10:29:54.264] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.264] 
[10:29:54.264] getGlobalsAndPackages() ... DONE
[10:29:54.265] run() for ‘Future’ ...
[10:29:54.269] - state: ‘created’
[10:29:54.270] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:54.276] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:54.276] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:54.276]   - Field: ‘label’
[10:29:54.277]   - Field: ‘local’
[10:29:54.277]   - Field: ‘owner’
[10:29:54.277]   - Field: ‘envir’
[10:29:54.277]   - Field: ‘workers’
[10:29:54.278]   - Field: ‘packages’
[10:29:54.278]   - Field: ‘gc’
[10:29:54.278]   - Field: ‘job’
[10:29:54.278]   - Field: ‘conditions’
[10:29:54.279]   - Field: ‘expr’
[10:29:54.279]   - Field: ‘uuid’
[10:29:54.279]   - Field: ‘seed’
[10:29:54.279]   - Field: ‘version’
[10:29:54.279]   - Field: ‘result’
[10:29:54.279]   - Field: ‘asynchronous’
[10:29:54.280]   - Field: ‘calls’
[10:29:54.280]   - Field: ‘globals’
[10:29:54.280]   - Field: ‘stdout’
[10:29:54.280]   - Field: ‘earlySignal’
[10:29:54.280]   - Field: ‘lazy’
[10:29:54.280]   - Field: ‘state’
[10:29:54.281] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:54.281] - Launch lazy future ...
[10:29:54.281] Packages needed by the future expression (n = 0): <none>
[10:29:54.282] Packages needed by future strategies (n = 0): <none>
[10:29:54.283] {
[10:29:54.283]     {
[10:29:54.283]         {
[10:29:54.283]             ...future.startTime <- base::Sys.time()
[10:29:54.283]             {
[10:29:54.283]                 {
[10:29:54.283]                   {
[10:29:54.283]                     {
[10:29:54.283]                       base::local({
[10:29:54.283]                         has_future <- base::requireNamespace("future", 
[10:29:54.283]                           quietly = TRUE)
[10:29:54.283]                         if (has_future) {
[10:29:54.283]                           ns <- base::getNamespace("future")
[10:29:54.283]                           version <- ns[[".package"]][["version"]]
[10:29:54.283]                           if (is.null(version)) 
[10:29:54.283]                             version <- utils::packageVersion("future")
[10:29:54.283]                         }
[10:29:54.283]                         else {
[10:29:54.283]                           version <- NULL
[10:29:54.283]                         }
[10:29:54.283]                         if (!has_future || version < "1.8.0") {
[10:29:54.283]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:54.283]                             "", base::R.version$version.string), 
[10:29:54.283]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:54.283]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:54.283]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:54.283]                               "release", "version")], collapse = " "), 
[10:29:54.283]                             hostname = base::Sys.info()[["nodename"]])
[10:29:54.283]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:54.283]                             info)
[10:29:54.283]                           info <- base::paste(info, collapse = "; ")
[10:29:54.283]                           if (!has_future) {
[10:29:54.283]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:54.283]                               info)
[10:29:54.283]                           }
[10:29:54.283]                           else {
[10:29:54.283]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:54.283]                               info, version)
[10:29:54.283]                           }
[10:29:54.283]                           base::stop(msg)
[10:29:54.283]                         }
[10:29:54.283]                       })
[10:29:54.283]                     }
[10:29:54.283]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:54.283]                     base::options(mc.cores = 1L)
[10:29:54.283]                   }
[10:29:54.283]                   ...future.strategy.old <- future::plan("list")
[10:29:54.283]                   options(future.plan = NULL)
[10:29:54.283]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.283]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:54.283]                 }
[10:29:54.283]                 ...future.workdir <- getwd()
[10:29:54.283]             }
[10:29:54.283]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:54.283]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:54.283]         }
[10:29:54.283]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:54.283]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:54.283]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:54.283]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:54.283]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:54.283]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:54.283]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:54.283]             base::names(...future.oldOptions))
[10:29:54.283]     }
[10:29:54.283]     if (FALSE) {
[10:29:54.283]     }
[10:29:54.283]     else {
[10:29:54.283]         if (TRUE) {
[10:29:54.283]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:54.283]                 open = "w")
[10:29:54.283]         }
[10:29:54.283]         else {
[10:29:54.283]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:54.283]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:54.283]         }
[10:29:54.283]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:54.283]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:54.283]             base::sink(type = "output", split = FALSE)
[10:29:54.283]             base::close(...future.stdout)
[10:29:54.283]         }, add = TRUE)
[10:29:54.283]     }
[10:29:54.283]     ...future.frame <- base::sys.nframe()
[10:29:54.283]     ...future.conditions <- base::list()
[10:29:54.283]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:54.283]     if (FALSE) {
[10:29:54.283]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:54.283]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:54.283]     }
[10:29:54.283]     ...future.result <- base::tryCatch({
[10:29:54.283]         base::withCallingHandlers({
[10:29:54.283]             ...future.value <- base::withVisible(base::local({
[10:29:54.283]                 withCallingHandlers({
[10:29:54.283]                   {
[10:29:54.283]                     do.call(function(...) {
[10:29:54.283]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.283]                       if (!identical(...future.globals.maxSize.org, 
[10:29:54.283]                         ...future.globals.maxSize)) {
[10:29:54.283]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.283]                         on.exit(options(oopts), add = TRUE)
[10:29:54.283]                       }
[10:29:54.283]                       {
[10:29:54.283]                         lapply(seq_along(...future.elements_ii), 
[10:29:54.283]                           FUN = function(jj) {
[10:29:54.283]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.283]                             ...future.FUN(...future.X_jj, ...)
[10:29:54.283]                           })
[10:29:54.283]                       }
[10:29:54.283]                     }, args = future.call.arguments)
[10:29:54.283]                   }
[10:29:54.283]                 }, immediateCondition = function(cond) {
[10:29:54.283]                   save_rds <- function (object, pathname, ...) 
[10:29:54.283]                   {
[10:29:54.283]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:54.283]                     if (file_test("-f", pathname_tmp)) {
[10:29:54.283]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.283]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:54.283]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.283]                         fi_tmp[["mtime"]])
[10:29:54.283]                     }
[10:29:54.283]                     tryCatch({
[10:29:54.283]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:54.283]                     }, error = function(ex) {
[10:29:54.283]                       msg <- conditionMessage(ex)
[10:29:54.283]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.283]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:54.283]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.283]                         fi_tmp[["mtime"]], msg)
[10:29:54.283]                       ex$message <- msg
[10:29:54.283]                       stop(ex)
[10:29:54.283]                     })
[10:29:54.283]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:54.283]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:54.283]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:54.283]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.283]                       fi <- file.info(pathname)
[10:29:54.283]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:54.283]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.283]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:54.283]                         fi[["size"]], fi[["mtime"]])
[10:29:54.283]                       stop(msg)
[10:29:54.283]                     }
[10:29:54.283]                     invisible(pathname)
[10:29:54.283]                   }
[10:29:54.283]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:54.283]                     rootPath = tempdir()) 
[10:29:54.283]                   {
[10:29:54.283]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:54.283]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:54.283]                       tmpdir = path, fileext = ".rds")
[10:29:54.283]                     save_rds(obj, file)
[10:29:54.283]                   }
[10:29:54.283]                   saveImmediateCondition(cond, path = "/tmp/Rtmp11FQBX/.future/immediateConditions")
[10:29:54.283]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.283]                   {
[10:29:54.283]                     inherits <- base::inherits
[10:29:54.283]                     invokeRestart <- base::invokeRestart
[10:29:54.283]                     is.null <- base::is.null
[10:29:54.283]                     muffled <- FALSE
[10:29:54.283]                     if (inherits(cond, "message")) {
[10:29:54.283]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:54.283]                       if (muffled) 
[10:29:54.283]                         invokeRestart("muffleMessage")
[10:29:54.283]                     }
[10:29:54.283]                     else if (inherits(cond, "warning")) {
[10:29:54.283]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:54.283]                       if (muffled) 
[10:29:54.283]                         invokeRestart("muffleWarning")
[10:29:54.283]                     }
[10:29:54.283]                     else if (inherits(cond, "condition")) {
[10:29:54.283]                       if (!is.null(pattern)) {
[10:29:54.283]                         computeRestarts <- base::computeRestarts
[10:29:54.283]                         grepl <- base::grepl
[10:29:54.283]                         restarts <- computeRestarts(cond)
[10:29:54.283]                         for (restart in restarts) {
[10:29:54.283]                           name <- restart$name
[10:29:54.283]                           if (is.null(name)) 
[10:29:54.283]                             next
[10:29:54.283]                           if (!grepl(pattern, name)) 
[10:29:54.283]                             next
[10:29:54.283]                           invokeRestart(restart)
[10:29:54.283]                           muffled <- TRUE
[10:29:54.283]                           break
[10:29:54.283]                         }
[10:29:54.283]                       }
[10:29:54.283]                     }
[10:29:54.283]                     invisible(muffled)
[10:29:54.283]                   }
[10:29:54.283]                   muffleCondition(cond)
[10:29:54.283]                 })
[10:29:54.283]             }))
[10:29:54.283]             future::FutureResult(value = ...future.value$value, 
[10:29:54.283]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.283]                   ...future.rng), globalenv = if (FALSE) 
[10:29:54.283]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:54.283]                     ...future.globalenv.names))
[10:29:54.283]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:54.283]         }, condition = base::local({
[10:29:54.283]             c <- base::c
[10:29:54.283]             inherits <- base::inherits
[10:29:54.283]             invokeRestart <- base::invokeRestart
[10:29:54.283]             length <- base::length
[10:29:54.283]             list <- base::list
[10:29:54.283]             seq.int <- base::seq.int
[10:29:54.283]             signalCondition <- base::signalCondition
[10:29:54.283]             sys.calls <- base::sys.calls
[10:29:54.283]             `[[` <- base::`[[`
[10:29:54.283]             `+` <- base::`+`
[10:29:54.283]             `<<-` <- base::`<<-`
[10:29:54.283]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:54.283]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:54.283]                   3L)]
[10:29:54.283]             }
[10:29:54.283]             function(cond) {
[10:29:54.283]                 is_error <- inherits(cond, "error")
[10:29:54.283]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:54.283]                   NULL)
[10:29:54.283]                 if (is_error) {
[10:29:54.283]                   sessionInformation <- function() {
[10:29:54.283]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:54.283]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:54.283]                       search = base::search(), system = base::Sys.info())
[10:29:54.283]                   }
[10:29:54.283]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.283]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:54.283]                     cond$call), session = sessionInformation(), 
[10:29:54.283]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:54.283]                   signalCondition(cond)
[10:29:54.283]                 }
[10:29:54.283]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:54.283]                 "immediateCondition"))) {
[10:29:54.283]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:54.283]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.283]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:54.283]                   if (TRUE && !signal) {
[10:29:54.283]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.283]                     {
[10:29:54.283]                       inherits <- base::inherits
[10:29:54.283]                       invokeRestart <- base::invokeRestart
[10:29:54.283]                       is.null <- base::is.null
[10:29:54.283]                       muffled <- FALSE
[10:29:54.283]                       if (inherits(cond, "message")) {
[10:29:54.283]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.283]                         if (muffled) 
[10:29:54.283]                           invokeRestart("muffleMessage")
[10:29:54.283]                       }
[10:29:54.283]                       else if (inherits(cond, "warning")) {
[10:29:54.283]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.283]                         if (muffled) 
[10:29:54.283]                           invokeRestart("muffleWarning")
[10:29:54.283]                       }
[10:29:54.283]                       else if (inherits(cond, "condition")) {
[10:29:54.283]                         if (!is.null(pattern)) {
[10:29:54.283]                           computeRestarts <- base::computeRestarts
[10:29:54.283]                           grepl <- base::grepl
[10:29:54.283]                           restarts <- computeRestarts(cond)
[10:29:54.283]                           for (restart in restarts) {
[10:29:54.283]                             name <- restart$name
[10:29:54.283]                             if (is.null(name)) 
[10:29:54.283]                               next
[10:29:54.283]                             if (!grepl(pattern, name)) 
[10:29:54.283]                               next
[10:29:54.283]                             invokeRestart(restart)
[10:29:54.283]                             muffled <- TRUE
[10:29:54.283]                             break
[10:29:54.283]                           }
[10:29:54.283]                         }
[10:29:54.283]                       }
[10:29:54.283]                       invisible(muffled)
[10:29:54.283]                     }
[10:29:54.283]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.283]                   }
[10:29:54.283]                 }
[10:29:54.283]                 else {
[10:29:54.283]                   if (TRUE) {
[10:29:54.283]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.283]                     {
[10:29:54.283]                       inherits <- base::inherits
[10:29:54.283]                       invokeRestart <- base::invokeRestart
[10:29:54.283]                       is.null <- base::is.null
[10:29:54.283]                       muffled <- FALSE
[10:29:54.283]                       if (inherits(cond, "message")) {
[10:29:54.283]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.283]                         if (muffled) 
[10:29:54.283]                           invokeRestart("muffleMessage")
[10:29:54.283]                       }
[10:29:54.283]                       else if (inherits(cond, "warning")) {
[10:29:54.283]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.283]                         if (muffled) 
[10:29:54.283]                           invokeRestart("muffleWarning")
[10:29:54.283]                       }
[10:29:54.283]                       else if (inherits(cond, "condition")) {
[10:29:54.283]                         if (!is.null(pattern)) {
[10:29:54.283]                           computeRestarts <- base::computeRestarts
[10:29:54.283]                           grepl <- base::grepl
[10:29:54.283]                           restarts <- computeRestarts(cond)
[10:29:54.283]                           for (restart in restarts) {
[10:29:54.283]                             name <- restart$name
[10:29:54.283]                             if (is.null(name)) 
[10:29:54.283]                               next
[10:29:54.283]                             if (!grepl(pattern, name)) 
[10:29:54.283]                               next
[10:29:54.283]                             invokeRestart(restart)
[10:29:54.283]                             muffled <- TRUE
[10:29:54.283]                             break
[10:29:54.283]                           }
[10:29:54.283]                         }
[10:29:54.283]                       }
[10:29:54.283]                       invisible(muffled)
[10:29:54.283]                     }
[10:29:54.283]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.283]                   }
[10:29:54.283]                 }
[10:29:54.283]             }
[10:29:54.283]         }))
[10:29:54.283]     }, error = function(ex) {
[10:29:54.283]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:54.283]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.283]                 ...future.rng), started = ...future.startTime, 
[10:29:54.283]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:54.283]             version = "1.8"), class = "FutureResult")
[10:29:54.283]     }, finally = {
[10:29:54.283]         if (!identical(...future.workdir, getwd())) 
[10:29:54.283]             setwd(...future.workdir)
[10:29:54.283]         {
[10:29:54.283]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:54.283]                 ...future.oldOptions$nwarnings <- NULL
[10:29:54.283]             }
[10:29:54.283]             base::options(...future.oldOptions)
[10:29:54.283]             if (.Platform$OS.type == "windows") {
[10:29:54.283]                 old_names <- names(...future.oldEnvVars)
[10:29:54.283]                 envs <- base::Sys.getenv()
[10:29:54.283]                 names <- names(envs)
[10:29:54.283]                 common <- intersect(names, old_names)
[10:29:54.283]                 added <- setdiff(names, old_names)
[10:29:54.283]                 removed <- setdiff(old_names, names)
[10:29:54.283]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:54.283]                   envs[common]]
[10:29:54.283]                 NAMES <- toupper(changed)
[10:29:54.283]                 args <- list()
[10:29:54.283]                 for (kk in seq_along(NAMES)) {
[10:29:54.283]                   name <- changed[[kk]]
[10:29:54.283]                   NAME <- NAMES[[kk]]
[10:29:54.283]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.283]                     next
[10:29:54.283]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.283]                 }
[10:29:54.283]                 NAMES <- toupper(added)
[10:29:54.283]                 for (kk in seq_along(NAMES)) {
[10:29:54.283]                   name <- added[[kk]]
[10:29:54.283]                   NAME <- NAMES[[kk]]
[10:29:54.283]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.283]                     next
[10:29:54.283]                   args[[name]] <- ""
[10:29:54.283]                 }
[10:29:54.283]                 NAMES <- toupper(removed)
[10:29:54.283]                 for (kk in seq_along(NAMES)) {
[10:29:54.283]                   name <- removed[[kk]]
[10:29:54.283]                   NAME <- NAMES[[kk]]
[10:29:54.283]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.283]                     next
[10:29:54.283]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.283]                 }
[10:29:54.283]                 if (length(args) > 0) 
[10:29:54.283]                   base::do.call(base::Sys.setenv, args = args)
[10:29:54.283]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:54.283]             }
[10:29:54.283]             else {
[10:29:54.283]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:54.283]             }
[10:29:54.283]             {
[10:29:54.283]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:54.283]                   0L) {
[10:29:54.283]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:54.283]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:54.283]                   base::options(opts)
[10:29:54.283]                 }
[10:29:54.283]                 {
[10:29:54.283]                   {
[10:29:54.283]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:54.283]                     NULL
[10:29:54.283]                   }
[10:29:54.283]                   options(future.plan = NULL)
[10:29:54.283]                   if (is.na(NA_character_)) 
[10:29:54.283]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.283]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:54.283]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:54.283]                     .init = FALSE)
[10:29:54.283]                 }
[10:29:54.283]             }
[10:29:54.283]         }
[10:29:54.283]     })
[10:29:54.283]     if (TRUE) {
[10:29:54.283]         base::sink(type = "output", split = FALSE)
[10:29:54.283]         if (TRUE) {
[10:29:54.283]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:54.283]         }
[10:29:54.283]         else {
[10:29:54.283]             ...future.result["stdout"] <- base::list(NULL)
[10:29:54.283]         }
[10:29:54.283]         base::close(...future.stdout)
[10:29:54.283]         ...future.stdout <- NULL
[10:29:54.283]     }
[10:29:54.283]     ...future.result$conditions <- ...future.conditions
[10:29:54.283]     ...future.result$finished <- base::Sys.time()
[10:29:54.283]     ...future.result
[10:29:54.283] }
[10:29:54.285] assign_globals() ...
[10:29:54.286] List of 5
[10:29:54.286]  $ ...future.FUN            :function (object, ...)  
[10:29:54.286]  $ future.call.arguments    : list()
[10:29:54.286]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.286]  $ ...future.elements_ii    :List of 2
[10:29:54.286]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:29:54.286]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:29:54.286]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:54.286]   ..$ :'data.frame':	18 obs. of  2 variables:
[10:29:54.286]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:29:54.286]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:54.286]  $ ...future.seeds_ii       : NULL
[10:29:54.286]  $ ...future.globals.maxSize: NULL
[10:29:54.286]  - attr(*, "where")=List of 5
[10:29:54.286]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:54.286]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:54.286]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:54.286]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:54.286]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:54.286]  - attr(*, "resolved")= logi FALSE
[10:29:54.286]  - attr(*, "total_size")= num 1240
[10:29:54.286]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.286]  - attr(*, "already-done")= logi TRUE
[10:29:54.294] - copied ‘...future.FUN’ to environment
[10:29:54.294] - copied ‘future.call.arguments’ to environment
[10:29:54.294] - copied ‘...future.elements_ii’ to environment
[10:29:54.295] - copied ‘...future.seeds_ii’ to environment
[10:29:54.295] - copied ‘...future.globals.maxSize’ to environment
[10:29:54.295] assign_globals() ... done
[10:29:54.295] requestCore(): workers = 2
[10:29:54.300] MulticoreFuture started
[10:29:54.300] - Launch lazy future ... done
[10:29:54.300] run() for ‘MulticoreFuture’ ... done
[10:29:54.301] Created future:
[10:29:54.301] plan(): Setting new future strategy stack:
[10:29:54.301] List of future strategies:
[10:29:54.301] 1. sequential:
[10:29:54.301]    - args: function (..., envir = parent.frame())
[10:29:54.301]    - tweaked: FALSE
[10:29:54.301]    - call: NULL
[10:29:54.302] plan(): nbrOfWorkers() = 1
[10:29:54.316] plan(): Setting new future strategy stack:
[10:29:54.316] List of future strategies:
[10:29:54.316] 1. multicore:
[10:29:54.316]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:54.316]    - tweaked: FALSE
[10:29:54.316]    - call: plan(strategy)
[10:29:54.321] plan(): nbrOfWorkers() = 2
[10:29:54.301] MulticoreFuture:
[10:29:54.301] Label: ‘future_by-2’
[10:29:54.301] Expression:
[10:29:54.301] {
[10:29:54.301]     do.call(function(...) {
[10:29:54.301]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.301]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.301]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.301]             on.exit(options(oopts), add = TRUE)
[10:29:54.301]         }
[10:29:54.301]         {
[10:29:54.301]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.301]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.301]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.301]             })
[10:29:54.301]         }
[10:29:54.301]     }, args = future.call.arguments)
[10:29:54.301] }
[10:29:54.301] Lazy evaluation: FALSE
[10:29:54.301] Asynchronous evaluation: TRUE
[10:29:54.301] Local evaluation: TRUE
[10:29:54.301] Environment: R_GlobalEnv
[10:29:54.301] Capture standard output: TRUE
[10:29:54.301] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:54.301] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:54.301] Packages: <none>
[10:29:54.301] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:54.301] Resolved: TRUE
[10:29:54.301] Value: <not collected>
[10:29:54.301] Conditions captured: <none>
[10:29:54.301] Early signaling: FALSE
[10:29:54.301] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:54.301] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:54.322] Chunk #2 of 2 ... DONE
[10:29:54.322] Launching 2 futures (chunks) ... DONE
[10:29:54.323] Resolving 2 futures (chunks) ...
[10:29:54.323] resolve() on list ...
[10:29:54.323]  recursive: 0
[10:29:54.323]  length: 2
[10:29:54.323] 
[10:29:54.324] Future #1
[10:29:54.324] result() for MulticoreFuture ...
[10:29:54.326] result() for MulticoreFuture ...
[10:29:54.326] result() for MulticoreFuture ... done
[10:29:54.326] result() for MulticoreFuture ... done
[10:29:54.326] result() for MulticoreFuture ...
[10:29:54.327] result() for MulticoreFuture ... done
[10:29:54.327] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:29:54.327] - nx: 2
[10:29:54.327] - relay: TRUE
[10:29:54.327] - stdout: TRUE
[10:29:54.328] - signal: TRUE
[10:29:54.328] - resignal: FALSE
[10:29:54.328] - force: TRUE
[10:29:54.328] - relayed: [n=2] FALSE, FALSE
[10:29:54.328] - queued futures: [n=2] FALSE, FALSE
[10:29:54.329]  - until=1
[10:29:54.329]  - relaying element #1
[10:29:54.329] result() for MulticoreFuture ...
[10:29:54.329] result() for MulticoreFuture ... done
[10:29:54.329] result() for MulticoreFuture ...
[10:29:54.330] result() for MulticoreFuture ... done
[10:29:54.330] result() for MulticoreFuture ...
[10:29:54.330] result() for MulticoreFuture ... done
[10:29:54.330] result() for MulticoreFuture ...
[10:29:54.331] result() for MulticoreFuture ... done
[10:29:54.331] - relayed: [n=2] TRUE, FALSE
[10:29:54.331] - queued futures: [n=2] TRUE, FALSE
[10:29:54.331] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:29:54.331]  length: 1 (resolved future 1)
[10:29:54.332] Future #2
[10:29:54.332] result() for MulticoreFuture ...
[10:29:54.333] result() for MulticoreFuture ...
[10:29:54.333] result() for MulticoreFuture ... done
[10:29:54.333] result() for MulticoreFuture ... done
[10:29:54.333] result() for MulticoreFuture ...
[10:29:54.334] result() for MulticoreFuture ... done
[10:29:54.334] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:29:54.334] - nx: 2
[10:29:54.334] - relay: TRUE
[10:29:54.334] - stdout: TRUE
[10:29:54.334] - signal: TRUE
[10:29:54.335] - resignal: FALSE
[10:29:54.335] - force: TRUE
[10:29:54.335] - relayed: [n=2] TRUE, FALSE
[10:29:54.335] - queued futures: [n=2] TRUE, FALSE
[10:29:54.335]  - until=2
[10:29:54.335]  - relaying element #2
[10:29:54.335] result() for MulticoreFuture ...
[10:29:54.336] result() for MulticoreFuture ... done
[10:29:54.336] result() for MulticoreFuture ...
[10:29:54.336] result() for MulticoreFuture ... done
[10:29:54.336] result() for MulticoreFuture ...
[10:29:54.336] result() for MulticoreFuture ... done
[10:29:54.336] result() for MulticoreFuture ...
[10:29:54.337] result() for MulticoreFuture ... done
[10:29:54.337] - relayed: [n=2] TRUE, TRUE
[10:29:54.337] - queued futures: [n=2] TRUE, TRUE
[10:29:54.337] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:29:54.337]  length: 0 (resolved future 2)
[10:29:54.337] Relaying remaining futures
[10:29:54.337] signalConditionsASAP(NULL, pos=0) ...
[10:29:54.337] - nx: 2
[10:29:54.337] - relay: TRUE
[10:29:54.338] - stdout: TRUE
[10:29:54.338] - signal: TRUE
[10:29:54.338] - resignal: FALSE
[10:29:54.338] - force: TRUE
[10:29:54.338] - relayed: [n=2] TRUE, TRUE
[10:29:54.338] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:54.338] - relayed: [n=2] TRUE, TRUE
[10:29:54.338] - queued futures: [n=2] TRUE, TRUE
[10:29:54.338] signalConditionsASAP(NULL, pos=0) ... done
[10:29:54.338] resolve() on list ... DONE
[10:29:54.339] result() for MulticoreFuture ...
[10:29:54.339] result() for MulticoreFuture ... done
[10:29:54.339] result() for MulticoreFuture ...
[10:29:54.339] result() for MulticoreFuture ... done
[10:29:54.339] result() for MulticoreFuture ...
[10:29:54.339] result() for MulticoreFuture ... done
[10:29:54.339] result() for MulticoreFuture ...
[10:29:54.339] result() for MulticoreFuture ... done
[10:29:54.339]  - Number of value chunks collected: 2
[10:29:54.340] Resolving 2 futures (chunks) ... DONE
[10:29:54.340] Reducing values from 2 chunks ...
[10:29:54.340]  - Number of values collected after concatenation: 3
[10:29:54.340]  - Number of values expected: 3
[10:29:54.340] Reducing values from 2 chunks ... DONE
[10:29:54.340] future_lapply() ... DONE
[10:29:54.340] future_by_internal() ... DONE
[10:29:54.341] future_by_internal() ...
[10:29:54.341] future_lapply() ...
[10:29:54.345] Number of chunks: 2
[10:29:54.346] getGlobalsAndPackagesXApply() ...
[10:29:54.346]  - future.globals: TRUE
[10:29:54.346] getGlobalsAndPackages() ...
[10:29:54.346] Searching for globals...
[10:29:54.347] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:54.347] Searching for globals ... DONE
[10:29:54.347] Resolving globals: FALSE
[10:29:54.348] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:54.348] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:54.348] - globals: [1] ‘FUN’
[10:29:54.349] 
[10:29:54.349] getGlobalsAndPackages() ... DONE
[10:29:54.349]  - globals found/used: [n=1] ‘FUN’
[10:29:54.349]  - needed namespaces: [n=0] 
[10:29:54.349] Finding globals ... DONE
[10:29:54.349]  - use_args: TRUE
[10:29:54.349]  - Getting '...' globals ...
[10:29:54.350] resolve() on list ...
[10:29:54.350]  recursive: 0
[10:29:54.350]  length: 1
[10:29:54.350]  elements: ‘...’
[10:29:54.350]  length: 0 (resolved future 1)
[10:29:54.350] resolve() on list ... DONE
[10:29:54.350]    - '...' content: [n=1] ‘digits’
[10:29:54.350] List of 1
[10:29:54.350]  $ ...:List of 1
[10:29:54.350]   ..$ digits: int 2
[10:29:54.350]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.350]  - attr(*, "where")=List of 1
[10:29:54.350]   ..$ ...:<environment: 0x556dd3554670> 
[10:29:54.350]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.350]  - attr(*, "resolved")= logi TRUE
[10:29:54.350]  - attr(*, "total_size")= num NA
[10:29:54.356]  - Getting '...' globals ... DONE
[10:29:54.357] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:54.357] List of 2
[10:29:54.357]  $ ...future.FUN:function (object, ...)  
[10:29:54.357]  $ ...          :List of 1
[10:29:54.357]   ..$ digits: int 2
[10:29:54.357]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.357]  - attr(*, "where")=List of 2
[10:29:54.357]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:54.357]   ..$ ...          :<environment: 0x556dd3554670> 
[10:29:54.357]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.357]  - attr(*, "resolved")= logi FALSE
[10:29:54.357]  - attr(*, "total_size")= num 1296
[10:29:54.361] Packages to be attached in all futures: [n=0] 
[10:29:54.361] getGlobalsAndPackagesXApply() ... DONE
[10:29:54.361] Number of futures (= number of chunks): 2
[10:29:54.361] Launching 2 futures (chunks) ...
[10:29:54.361] Chunk #1 of 2 ...
[10:29:54.361]  - Finding globals in 'X' for chunk #1 ...
[10:29:54.361] getGlobalsAndPackages() ...
[10:29:54.362] Searching for globals...
[10:29:54.362] 
[10:29:54.362] Searching for globals ... DONE
[10:29:54.362] - globals: [0] <none>
[10:29:54.362] getGlobalsAndPackages() ... DONE
[10:29:54.362]    + additional globals found: [n=0] 
[10:29:54.362]    + additional namespaces needed: [n=0] 
[10:29:54.362]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:54.362]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:54.363]  - seeds: <none>
[10:29:54.363]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.363] getGlobalsAndPackages() ...
[10:29:54.363] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.363] Resolving globals: FALSE
[10:29:54.363] Tweak future expression to call with '...' arguments ...
[10:29:54.363] {
[10:29:54.363]     do.call(function(...) {
[10:29:54.363]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.363]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.363]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.363]             on.exit(options(oopts), add = TRUE)
[10:29:54.363]         }
[10:29:54.363]         {
[10:29:54.363]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.363]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.363]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.363]             })
[10:29:54.363]         }
[10:29:54.363]     }, args = future.call.arguments)
[10:29:54.363] }
[10:29:54.364] Tweak future expression to call with '...' arguments ... DONE
[10:29:54.364] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.364] 
[10:29:54.364] getGlobalsAndPackages() ... DONE
[10:29:54.364] run() for ‘Future’ ...
[10:29:54.365] - state: ‘created’
[10:29:54.365] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:54.369] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:54.369] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:54.369]   - Field: ‘label’
[10:29:54.369]   - Field: ‘local’
[10:29:54.369]   - Field: ‘owner’
[10:29:54.369]   - Field: ‘envir’
[10:29:54.370]   - Field: ‘workers’
[10:29:54.370]   - Field: ‘packages’
[10:29:54.370]   - Field: ‘gc’
[10:29:54.370]   - Field: ‘job’
[10:29:54.370]   - Field: ‘conditions’
[10:29:54.370]   - Field: ‘expr’
[10:29:54.370]   - Field: ‘uuid’
[10:29:54.370]   - Field: ‘seed’
[10:29:54.370]   - Field: ‘version’
[10:29:54.370]   - Field: ‘result’
[10:29:54.371]   - Field: ‘asynchronous’
[10:29:54.371]   - Field: ‘calls’
[10:29:54.371]   - Field: ‘globals’
[10:29:54.371]   - Field: ‘stdout’
[10:29:54.371]   - Field: ‘earlySignal’
[10:29:54.371]   - Field: ‘lazy’
[10:29:54.371]   - Field: ‘state’
[10:29:54.371] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:54.371] - Launch lazy future ...
[10:29:54.372] Packages needed by the future expression (n = 0): <none>
[10:29:54.372] Packages needed by future strategies (n = 0): <none>
[10:29:54.372] {
[10:29:54.372]     {
[10:29:54.372]         {
[10:29:54.372]             ...future.startTime <- base::Sys.time()
[10:29:54.372]             {
[10:29:54.372]                 {
[10:29:54.372]                   {
[10:29:54.372]                     {
[10:29:54.372]                       base::local({
[10:29:54.372]                         has_future <- base::requireNamespace("future", 
[10:29:54.372]                           quietly = TRUE)
[10:29:54.372]                         if (has_future) {
[10:29:54.372]                           ns <- base::getNamespace("future")
[10:29:54.372]                           version <- ns[[".package"]][["version"]]
[10:29:54.372]                           if (is.null(version)) 
[10:29:54.372]                             version <- utils::packageVersion("future")
[10:29:54.372]                         }
[10:29:54.372]                         else {
[10:29:54.372]                           version <- NULL
[10:29:54.372]                         }
[10:29:54.372]                         if (!has_future || version < "1.8.0") {
[10:29:54.372]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:54.372]                             "", base::R.version$version.string), 
[10:29:54.372]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:54.372]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:54.372]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:54.372]                               "release", "version")], collapse = " "), 
[10:29:54.372]                             hostname = base::Sys.info()[["nodename"]])
[10:29:54.372]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:54.372]                             info)
[10:29:54.372]                           info <- base::paste(info, collapse = "; ")
[10:29:54.372]                           if (!has_future) {
[10:29:54.372]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:54.372]                               info)
[10:29:54.372]                           }
[10:29:54.372]                           else {
[10:29:54.372]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:54.372]                               info, version)
[10:29:54.372]                           }
[10:29:54.372]                           base::stop(msg)
[10:29:54.372]                         }
[10:29:54.372]                       })
[10:29:54.372]                     }
[10:29:54.372]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:54.372]                     base::options(mc.cores = 1L)
[10:29:54.372]                   }
[10:29:54.372]                   ...future.strategy.old <- future::plan("list")
[10:29:54.372]                   options(future.plan = NULL)
[10:29:54.372]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.372]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:54.372]                 }
[10:29:54.372]                 ...future.workdir <- getwd()
[10:29:54.372]             }
[10:29:54.372]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:54.372]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:54.372]         }
[10:29:54.372]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:54.372]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:54.372]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:54.372]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:54.372]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:54.372]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:54.372]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:54.372]             base::names(...future.oldOptions))
[10:29:54.372]     }
[10:29:54.372]     if (FALSE) {
[10:29:54.372]     }
[10:29:54.372]     else {
[10:29:54.372]         if (TRUE) {
[10:29:54.372]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:54.372]                 open = "w")
[10:29:54.372]         }
[10:29:54.372]         else {
[10:29:54.372]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:54.372]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:54.372]         }
[10:29:54.372]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:54.372]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:54.372]             base::sink(type = "output", split = FALSE)
[10:29:54.372]             base::close(...future.stdout)
[10:29:54.372]         }, add = TRUE)
[10:29:54.372]     }
[10:29:54.372]     ...future.frame <- base::sys.nframe()
[10:29:54.372]     ...future.conditions <- base::list()
[10:29:54.372]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:54.372]     if (FALSE) {
[10:29:54.372]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:54.372]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:54.372]     }
[10:29:54.372]     ...future.result <- base::tryCatch({
[10:29:54.372]         base::withCallingHandlers({
[10:29:54.372]             ...future.value <- base::withVisible(base::local({
[10:29:54.372]                 withCallingHandlers({
[10:29:54.372]                   {
[10:29:54.372]                     do.call(function(...) {
[10:29:54.372]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.372]                       if (!identical(...future.globals.maxSize.org, 
[10:29:54.372]                         ...future.globals.maxSize)) {
[10:29:54.372]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.372]                         on.exit(options(oopts), add = TRUE)
[10:29:54.372]                       }
[10:29:54.372]                       {
[10:29:54.372]                         lapply(seq_along(...future.elements_ii), 
[10:29:54.372]                           FUN = function(jj) {
[10:29:54.372]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.372]                             ...future.FUN(...future.X_jj, ...)
[10:29:54.372]                           })
[10:29:54.372]                       }
[10:29:54.372]                     }, args = future.call.arguments)
[10:29:54.372]                   }
[10:29:54.372]                 }, immediateCondition = function(cond) {
[10:29:54.372]                   save_rds <- function (object, pathname, ...) 
[10:29:54.372]                   {
[10:29:54.372]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:54.372]                     if (file_test("-f", pathname_tmp)) {
[10:29:54.372]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.372]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:54.372]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.372]                         fi_tmp[["mtime"]])
[10:29:54.372]                     }
[10:29:54.372]                     tryCatch({
[10:29:54.372]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:54.372]                     }, error = function(ex) {
[10:29:54.372]                       msg <- conditionMessage(ex)
[10:29:54.372]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.372]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:54.372]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.372]                         fi_tmp[["mtime"]], msg)
[10:29:54.372]                       ex$message <- msg
[10:29:54.372]                       stop(ex)
[10:29:54.372]                     })
[10:29:54.372]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:54.372]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:54.372]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:54.372]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.372]                       fi <- file.info(pathname)
[10:29:54.372]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:54.372]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.372]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:54.372]                         fi[["size"]], fi[["mtime"]])
[10:29:54.372]                       stop(msg)
[10:29:54.372]                     }
[10:29:54.372]                     invisible(pathname)
[10:29:54.372]                   }
[10:29:54.372]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:54.372]                     rootPath = tempdir()) 
[10:29:54.372]                   {
[10:29:54.372]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:54.372]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:54.372]                       tmpdir = path, fileext = ".rds")
[10:29:54.372]                     save_rds(obj, file)
[10:29:54.372]                   }
[10:29:54.372]                   saveImmediateCondition(cond, path = "/tmp/Rtmp11FQBX/.future/immediateConditions")
[10:29:54.372]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.372]                   {
[10:29:54.372]                     inherits <- base::inherits
[10:29:54.372]                     invokeRestart <- base::invokeRestart
[10:29:54.372]                     is.null <- base::is.null
[10:29:54.372]                     muffled <- FALSE
[10:29:54.372]                     if (inherits(cond, "message")) {
[10:29:54.372]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:54.372]                       if (muffled) 
[10:29:54.372]                         invokeRestart("muffleMessage")
[10:29:54.372]                     }
[10:29:54.372]                     else if (inherits(cond, "warning")) {
[10:29:54.372]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:54.372]                       if (muffled) 
[10:29:54.372]                         invokeRestart("muffleWarning")
[10:29:54.372]                     }
[10:29:54.372]                     else if (inherits(cond, "condition")) {
[10:29:54.372]                       if (!is.null(pattern)) {
[10:29:54.372]                         computeRestarts <- base::computeRestarts
[10:29:54.372]                         grepl <- base::grepl
[10:29:54.372]                         restarts <- computeRestarts(cond)
[10:29:54.372]                         for (restart in restarts) {
[10:29:54.372]                           name <- restart$name
[10:29:54.372]                           if (is.null(name)) 
[10:29:54.372]                             next
[10:29:54.372]                           if (!grepl(pattern, name)) 
[10:29:54.372]                             next
[10:29:54.372]                           invokeRestart(restart)
[10:29:54.372]                           muffled <- TRUE
[10:29:54.372]                           break
[10:29:54.372]                         }
[10:29:54.372]                       }
[10:29:54.372]                     }
[10:29:54.372]                     invisible(muffled)
[10:29:54.372]                   }
[10:29:54.372]                   muffleCondition(cond)
[10:29:54.372]                 })
[10:29:54.372]             }))
[10:29:54.372]             future::FutureResult(value = ...future.value$value, 
[10:29:54.372]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.372]                   ...future.rng), globalenv = if (FALSE) 
[10:29:54.372]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:54.372]                     ...future.globalenv.names))
[10:29:54.372]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:54.372]         }, condition = base::local({
[10:29:54.372]             c <- base::c
[10:29:54.372]             inherits <- base::inherits
[10:29:54.372]             invokeRestart <- base::invokeRestart
[10:29:54.372]             length <- base::length
[10:29:54.372]             list <- base::list
[10:29:54.372]             seq.int <- base::seq.int
[10:29:54.372]             signalCondition <- base::signalCondition
[10:29:54.372]             sys.calls <- base::sys.calls
[10:29:54.372]             `[[` <- base::`[[`
[10:29:54.372]             `+` <- base::`+`
[10:29:54.372]             `<<-` <- base::`<<-`
[10:29:54.372]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:54.372]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:54.372]                   3L)]
[10:29:54.372]             }
[10:29:54.372]             function(cond) {
[10:29:54.372]                 is_error <- inherits(cond, "error")
[10:29:54.372]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:54.372]                   NULL)
[10:29:54.372]                 if (is_error) {
[10:29:54.372]                   sessionInformation <- function() {
[10:29:54.372]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:54.372]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:54.372]                       search = base::search(), system = base::Sys.info())
[10:29:54.372]                   }
[10:29:54.372]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.372]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:54.372]                     cond$call), session = sessionInformation(), 
[10:29:54.372]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:54.372]                   signalCondition(cond)
[10:29:54.372]                 }
[10:29:54.372]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:54.372]                 "immediateCondition"))) {
[10:29:54.372]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:54.372]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.372]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:54.372]                   if (TRUE && !signal) {
[10:29:54.372]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.372]                     {
[10:29:54.372]                       inherits <- base::inherits
[10:29:54.372]                       invokeRestart <- base::invokeRestart
[10:29:54.372]                       is.null <- base::is.null
[10:29:54.372]                       muffled <- FALSE
[10:29:54.372]                       if (inherits(cond, "message")) {
[10:29:54.372]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.372]                         if (muffled) 
[10:29:54.372]                           invokeRestart("muffleMessage")
[10:29:54.372]                       }
[10:29:54.372]                       else if (inherits(cond, "warning")) {
[10:29:54.372]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.372]                         if (muffled) 
[10:29:54.372]                           invokeRestart("muffleWarning")
[10:29:54.372]                       }
[10:29:54.372]                       else if (inherits(cond, "condition")) {
[10:29:54.372]                         if (!is.null(pattern)) {
[10:29:54.372]                           computeRestarts <- base::computeRestarts
[10:29:54.372]                           grepl <- base::grepl
[10:29:54.372]                           restarts <- computeRestarts(cond)
[10:29:54.372]                           for (restart in restarts) {
[10:29:54.372]                             name <- restart$name
[10:29:54.372]                             if (is.null(name)) 
[10:29:54.372]                               next
[10:29:54.372]                             if (!grepl(pattern, name)) 
[10:29:54.372]                               next
[10:29:54.372]                             invokeRestart(restart)
[10:29:54.372]                             muffled <- TRUE
[10:29:54.372]                             break
[10:29:54.372]                           }
[10:29:54.372]                         }
[10:29:54.372]                       }
[10:29:54.372]                       invisible(muffled)
[10:29:54.372]                     }
[10:29:54.372]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.372]                   }
[10:29:54.372]                 }
[10:29:54.372]                 else {
[10:29:54.372]                   if (TRUE) {
[10:29:54.372]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.372]                     {
[10:29:54.372]                       inherits <- base::inherits
[10:29:54.372]                       invokeRestart <- base::invokeRestart
[10:29:54.372]                       is.null <- base::is.null
[10:29:54.372]                       muffled <- FALSE
[10:29:54.372]                       if (inherits(cond, "message")) {
[10:29:54.372]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.372]                         if (muffled) 
[10:29:54.372]                           invokeRestart("muffleMessage")
[10:29:54.372]                       }
[10:29:54.372]                       else if (inherits(cond, "warning")) {
[10:29:54.372]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.372]                         if (muffled) 
[10:29:54.372]                           invokeRestart("muffleWarning")
[10:29:54.372]                       }
[10:29:54.372]                       else if (inherits(cond, "condition")) {
[10:29:54.372]                         if (!is.null(pattern)) {
[10:29:54.372]                           computeRestarts <- base::computeRestarts
[10:29:54.372]                           grepl <- base::grepl
[10:29:54.372]                           restarts <- computeRestarts(cond)
[10:29:54.372]                           for (restart in restarts) {
[10:29:54.372]                             name <- restart$name
[10:29:54.372]                             if (is.null(name)) 
[10:29:54.372]                               next
[10:29:54.372]                             if (!grepl(pattern, name)) 
[10:29:54.372]                               next
[10:29:54.372]                             invokeRestart(restart)
[10:29:54.372]                             muffled <- TRUE
[10:29:54.372]                             break
[10:29:54.372]                           }
[10:29:54.372]                         }
[10:29:54.372]                       }
[10:29:54.372]                       invisible(muffled)
[10:29:54.372]                     }
[10:29:54.372]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.372]                   }
[10:29:54.372]                 }
[10:29:54.372]             }
[10:29:54.372]         }))
[10:29:54.372]     }, error = function(ex) {
[10:29:54.372]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:54.372]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.372]                 ...future.rng), started = ...future.startTime, 
[10:29:54.372]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:54.372]             version = "1.8"), class = "FutureResult")
[10:29:54.372]     }, finally = {
[10:29:54.372]         if (!identical(...future.workdir, getwd())) 
[10:29:54.372]             setwd(...future.workdir)
[10:29:54.372]         {
[10:29:54.372]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:54.372]                 ...future.oldOptions$nwarnings <- NULL
[10:29:54.372]             }
[10:29:54.372]             base::options(...future.oldOptions)
[10:29:54.372]             if (.Platform$OS.type == "windows") {
[10:29:54.372]                 old_names <- names(...future.oldEnvVars)
[10:29:54.372]                 envs <- base::Sys.getenv()
[10:29:54.372]                 names <- names(envs)
[10:29:54.372]                 common <- intersect(names, old_names)
[10:29:54.372]                 added <- setdiff(names, old_names)
[10:29:54.372]                 removed <- setdiff(old_names, names)
[10:29:54.372]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:54.372]                   envs[common]]
[10:29:54.372]                 NAMES <- toupper(changed)
[10:29:54.372]                 args <- list()
[10:29:54.372]                 for (kk in seq_along(NAMES)) {
[10:29:54.372]                   name <- changed[[kk]]
[10:29:54.372]                   NAME <- NAMES[[kk]]
[10:29:54.372]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.372]                     next
[10:29:54.372]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.372]                 }
[10:29:54.372]                 NAMES <- toupper(added)
[10:29:54.372]                 for (kk in seq_along(NAMES)) {
[10:29:54.372]                   name <- added[[kk]]
[10:29:54.372]                   NAME <- NAMES[[kk]]
[10:29:54.372]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.372]                     next
[10:29:54.372]                   args[[name]] <- ""
[10:29:54.372]                 }
[10:29:54.372]                 NAMES <- toupper(removed)
[10:29:54.372]                 for (kk in seq_along(NAMES)) {
[10:29:54.372]                   name <- removed[[kk]]
[10:29:54.372]                   NAME <- NAMES[[kk]]
[10:29:54.372]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.372]                     next
[10:29:54.372]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.372]                 }
[10:29:54.372]                 if (length(args) > 0) 
[10:29:54.372]                   base::do.call(base::Sys.setenv, args = args)
[10:29:54.372]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:54.372]             }
[10:29:54.372]             else {
[10:29:54.372]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:54.372]             }
[10:29:54.372]             {
[10:29:54.372]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:54.372]                   0L) {
[10:29:54.372]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:54.372]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:54.372]                   base::options(opts)
[10:29:54.372]                 }
[10:29:54.372]                 {
[10:29:54.372]                   {
[10:29:54.372]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:54.372]                     NULL
[10:29:54.372]                   }
[10:29:54.372]                   options(future.plan = NULL)
[10:29:54.372]                   if (is.na(NA_character_)) 
[10:29:54.372]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.372]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:54.372]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:54.372]                     .init = FALSE)
[10:29:54.372]                 }
[10:29:54.372]             }
[10:29:54.372]         }
[10:29:54.372]     })
[10:29:54.372]     if (TRUE) {
[10:29:54.372]         base::sink(type = "output", split = FALSE)
[10:29:54.372]         if (TRUE) {
[10:29:54.372]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:54.372]         }
[10:29:54.372]         else {
[10:29:54.372]             ...future.result["stdout"] <- base::list(NULL)
[10:29:54.372]         }
[10:29:54.372]         base::close(...future.stdout)
[10:29:54.372]         ...future.stdout <- NULL
[10:29:54.372]     }
[10:29:54.372]     ...future.result$conditions <- ...future.conditions
[10:29:54.372]     ...future.result$finished <- base::Sys.time()
[10:29:54.372]     ...future.result
[10:29:54.372] }
[10:29:54.375] assign_globals() ...
[10:29:54.375] List of 5
[10:29:54.375]  $ ...future.FUN            :function (object, ...)  
[10:29:54.375]  $ future.call.arguments    :List of 1
[10:29:54.375]   ..$ digits: int 2
[10:29:54.375]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.375]  $ ...future.elements_ii    :List of 3
[10:29:54.375]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[10:29:54.375]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[10:29:54.375]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[10:29:54.375]  $ ...future.seeds_ii       : NULL
[10:29:54.375]  $ ...future.globals.maxSize: NULL
[10:29:54.375]  - attr(*, "where")=List of 5
[10:29:54.375]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:54.375]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:54.375]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:54.375]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:54.375]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:54.375]  - attr(*, "resolved")= logi FALSE
[10:29:54.375]  - attr(*, "total_size")= num 1296
[10:29:54.375]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.375]  - attr(*, "already-done")= logi TRUE
[10:29:54.384] - copied ‘...future.FUN’ to environment
[10:29:54.384] - copied ‘future.call.arguments’ to environment
[10:29:54.385] - copied ‘...future.elements_ii’ to environment
[10:29:54.385] - copied ‘...future.seeds_ii’ to environment
[10:29:54.385] - copied ‘...future.globals.maxSize’ to environment
[10:29:54.385] assign_globals() ... done
[10:29:54.385] requestCore(): workers = 2
[10:29:54.388] MulticoreFuture started
[10:29:54.389] - Launch lazy future ... done
[10:29:54.389] run() for ‘MulticoreFuture’ ... done
[10:29:54.389] plan(): Setting new future strategy stack:
[10:29:54.390] Created future:
[10:29:54.390] List of future strategies:
[10:29:54.390] 1. sequential:
[10:29:54.390]    - args: function (..., envir = parent.frame())
[10:29:54.390]    - tweaked: FALSE
[10:29:54.390]    - call: NULL
[10:29:54.391] plan(): nbrOfWorkers() = 1
[10:29:54.396] plan(): Setting new future strategy stack:
[10:29:54.396] List of future strategies:
[10:29:54.396] 1. multicore:
[10:29:54.396]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:54.396]    - tweaked: FALSE
[10:29:54.396]    - call: plan(strategy)
[10:29:54.403] plan(): nbrOfWorkers() = 2
[10:29:54.390] MulticoreFuture:
[10:29:54.390] Label: ‘future_by-1’
[10:29:54.390] Expression:
[10:29:54.390] {
[10:29:54.390]     do.call(function(...) {
[10:29:54.390]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.390]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.390]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.390]             on.exit(options(oopts), add = TRUE)
[10:29:54.390]         }
[10:29:54.390]         {
[10:29:54.390]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.390]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.390]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.390]             })
[10:29:54.390]         }
[10:29:54.390]     }, args = future.call.arguments)
[10:29:54.390] }
[10:29:54.390] Lazy evaluation: FALSE
[10:29:54.390] Asynchronous evaluation: TRUE
[10:29:54.390] Local evaluation: TRUE
[10:29:54.390] Environment: R_GlobalEnv
[10:29:54.390] Capture standard output: TRUE
[10:29:54.390] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:54.390] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:54.390] Packages: <none>
[10:29:54.390] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:54.390] Resolved: TRUE
[10:29:54.390] Value: <not collected>
[10:29:54.390] Conditions captured: <none>
[10:29:54.390] Early signaling: FALSE
[10:29:54.390] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:54.390] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:54.404] Chunk #1 of 2 ... DONE
[10:29:54.404] Chunk #2 of 2 ...
[10:29:54.404]  - Finding globals in 'X' for chunk #2 ...
[10:29:54.404] getGlobalsAndPackages() ...
[10:29:54.405] Searching for globals...
[10:29:54.405] 
[10:29:54.405] Searching for globals ... DONE
[10:29:54.405] - globals: [0] <none>
[10:29:54.406] getGlobalsAndPackages() ... DONE
[10:29:54.406]    + additional globals found: [n=0] 
[10:29:54.406]    + additional namespaces needed: [n=0] 
[10:29:54.406]  - Finding globals in 'X' for chunk #2 ... DONE
[10:29:54.406]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:54.406]  - seeds: <none>
[10:29:54.407]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.407] getGlobalsAndPackages() ...
[10:29:54.407] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.407] Resolving globals: FALSE
[10:29:54.407] Tweak future expression to call with '...' arguments ...
[10:29:54.408] {
[10:29:54.408]     do.call(function(...) {
[10:29:54.408]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.408]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.408]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.408]             on.exit(options(oopts), add = TRUE)
[10:29:54.408]         }
[10:29:54.408]         {
[10:29:54.408]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.408]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.408]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.408]             })
[10:29:54.408]         }
[10:29:54.408]     }, args = future.call.arguments)
[10:29:54.408] }
[10:29:54.408] Tweak future expression to call with '...' arguments ... DONE
[10:29:54.409] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.409] 
[10:29:54.409] getGlobalsAndPackages() ... DONE
[10:29:54.410] run() for ‘Future’ ...
[10:29:54.410] - state: ‘created’
[10:29:54.410] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:54.415] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:54.415] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:54.415]   - Field: ‘label’
[10:29:54.415]   - Field: ‘local’
[10:29:54.416]   - Field: ‘owner’
[10:29:54.416]   - Field: ‘envir’
[10:29:54.416]   - Field: ‘workers’
[10:29:54.416]   - Field: ‘packages’
[10:29:54.416]   - Field: ‘gc’
[10:29:54.416]   - Field: ‘job’
[10:29:54.416]   - Field: ‘conditions’
[10:29:54.416]   - Field: ‘expr’
[10:29:54.417]   - Field: ‘uuid’
[10:29:54.417]   - Field: ‘seed’
[10:29:54.417]   - Field: ‘version’
[10:29:54.417]   - Field: ‘result’
[10:29:54.417]   - Field: ‘asynchronous’
[10:29:54.417]   - Field: ‘calls’
[10:29:54.418]   - Field: ‘globals’
[10:29:54.418]   - Field: ‘stdout’
[10:29:54.418]   - Field: ‘earlySignal’
[10:29:54.418]   - Field: ‘lazy’
[10:29:54.418]   - Field: ‘state’
[10:29:54.418] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:54.418] - Launch lazy future ...
[10:29:54.419] Packages needed by the future expression (n = 0): <none>
[10:29:54.419] Packages needed by future strategies (n = 0): <none>
[10:29:54.420] {
[10:29:54.420]     {
[10:29:54.420]         {
[10:29:54.420]             ...future.startTime <- base::Sys.time()
[10:29:54.420]             {
[10:29:54.420]                 {
[10:29:54.420]                   {
[10:29:54.420]                     {
[10:29:54.420]                       base::local({
[10:29:54.420]                         has_future <- base::requireNamespace("future", 
[10:29:54.420]                           quietly = TRUE)
[10:29:54.420]                         if (has_future) {
[10:29:54.420]                           ns <- base::getNamespace("future")
[10:29:54.420]                           version <- ns[[".package"]][["version"]]
[10:29:54.420]                           if (is.null(version)) 
[10:29:54.420]                             version <- utils::packageVersion("future")
[10:29:54.420]                         }
[10:29:54.420]                         else {
[10:29:54.420]                           version <- NULL
[10:29:54.420]                         }
[10:29:54.420]                         if (!has_future || version < "1.8.0") {
[10:29:54.420]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:54.420]                             "", base::R.version$version.string), 
[10:29:54.420]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:54.420]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:54.420]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:54.420]                               "release", "version")], collapse = " "), 
[10:29:54.420]                             hostname = base::Sys.info()[["nodename"]])
[10:29:54.420]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:54.420]                             info)
[10:29:54.420]                           info <- base::paste(info, collapse = "; ")
[10:29:54.420]                           if (!has_future) {
[10:29:54.420]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:54.420]                               info)
[10:29:54.420]                           }
[10:29:54.420]                           else {
[10:29:54.420]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:54.420]                               info, version)
[10:29:54.420]                           }
[10:29:54.420]                           base::stop(msg)
[10:29:54.420]                         }
[10:29:54.420]                       })
[10:29:54.420]                     }
[10:29:54.420]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:54.420]                     base::options(mc.cores = 1L)
[10:29:54.420]                   }
[10:29:54.420]                   ...future.strategy.old <- future::plan("list")
[10:29:54.420]                   options(future.plan = NULL)
[10:29:54.420]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.420]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:54.420]                 }
[10:29:54.420]                 ...future.workdir <- getwd()
[10:29:54.420]             }
[10:29:54.420]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:54.420]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:54.420]         }
[10:29:54.420]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:54.420]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:54.420]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:54.420]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:54.420]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:54.420]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:54.420]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:54.420]             base::names(...future.oldOptions))
[10:29:54.420]     }
[10:29:54.420]     if (FALSE) {
[10:29:54.420]     }
[10:29:54.420]     else {
[10:29:54.420]         if (TRUE) {
[10:29:54.420]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:54.420]                 open = "w")
[10:29:54.420]         }
[10:29:54.420]         else {
[10:29:54.420]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:54.420]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:54.420]         }
[10:29:54.420]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:54.420]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:54.420]             base::sink(type = "output", split = FALSE)
[10:29:54.420]             base::close(...future.stdout)
[10:29:54.420]         }, add = TRUE)
[10:29:54.420]     }
[10:29:54.420]     ...future.frame <- base::sys.nframe()
[10:29:54.420]     ...future.conditions <- base::list()
[10:29:54.420]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:54.420]     if (FALSE) {
[10:29:54.420]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:54.420]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:54.420]     }
[10:29:54.420]     ...future.result <- base::tryCatch({
[10:29:54.420]         base::withCallingHandlers({
[10:29:54.420]             ...future.value <- base::withVisible(base::local({
[10:29:54.420]                 withCallingHandlers({
[10:29:54.420]                   {
[10:29:54.420]                     do.call(function(...) {
[10:29:54.420]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.420]                       if (!identical(...future.globals.maxSize.org, 
[10:29:54.420]                         ...future.globals.maxSize)) {
[10:29:54.420]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.420]                         on.exit(options(oopts), add = TRUE)
[10:29:54.420]                       }
[10:29:54.420]                       {
[10:29:54.420]                         lapply(seq_along(...future.elements_ii), 
[10:29:54.420]                           FUN = function(jj) {
[10:29:54.420]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.420]                             ...future.FUN(...future.X_jj, ...)
[10:29:54.420]                           })
[10:29:54.420]                       }
[10:29:54.420]                     }, args = future.call.arguments)
[10:29:54.420]                   }
[10:29:54.420]                 }, immediateCondition = function(cond) {
[10:29:54.420]                   save_rds <- function (object, pathname, ...) 
[10:29:54.420]                   {
[10:29:54.420]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:54.420]                     if (file_test("-f", pathname_tmp)) {
[10:29:54.420]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.420]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:54.420]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.420]                         fi_tmp[["mtime"]])
[10:29:54.420]                     }
[10:29:54.420]                     tryCatch({
[10:29:54.420]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:54.420]                     }, error = function(ex) {
[10:29:54.420]                       msg <- conditionMessage(ex)
[10:29:54.420]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.420]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:54.420]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.420]                         fi_tmp[["mtime"]], msg)
[10:29:54.420]                       ex$message <- msg
[10:29:54.420]                       stop(ex)
[10:29:54.420]                     })
[10:29:54.420]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:54.420]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:54.420]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:54.420]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.420]                       fi <- file.info(pathname)
[10:29:54.420]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:54.420]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.420]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:54.420]                         fi[["size"]], fi[["mtime"]])
[10:29:54.420]                       stop(msg)
[10:29:54.420]                     }
[10:29:54.420]                     invisible(pathname)
[10:29:54.420]                   }
[10:29:54.420]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:54.420]                     rootPath = tempdir()) 
[10:29:54.420]                   {
[10:29:54.420]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:54.420]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:54.420]                       tmpdir = path, fileext = ".rds")
[10:29:54.420]                     save_rds(obj, file)
[10:29:54.420]                   }
[10:29:54.420]                   saveImmediateCondition(cond, path = "/tmp/Rtmp11FQBX/.future/immediateConditions")
[10:29:54.420]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.420]                   {
[10:29:54.420]                     inherits <- base::inherits
[10:29:54.420]                     invokeRestart <- base::invokeRestart
[10:29:54.420]                     is.null <- base::is.null
[10:29:54.420]                     muffled <- FALSE
[10:29:54.420]                     if (inherits(cond, "message")) {
[10:29:54.420]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:54.420]                       if (muffled) 
[10:29:54.420]                         invokeRestart("muffleMessage")
[10:29:54.420]                     }
[10:29:54.420]                     else if (inherits(cond, "warning")) {
[10:29:54.420]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:54.420]                       if (muffled) 
[10:29:54.420]                         invokeRestart("muffleWarning")
[10:29:54.420]                     }
[10:29:54.420]                     else if (inherits(cond, "condition")) {
[10:29:54.420]                       if (!is.null(pattern)) {
[10:29:54.420]                         computeRestarts <- base::computeRestarts
[10:29:54.420]                         grepl <- base::grepl
[10:29:54.420]                         restarts <- computeRestarts(cond)
[10:29:54.420]                         for (restart in restarts) {
[10:29:54.420]                           name <- restart$name
[10:29:54.420]                           if (is.null(name)) 
[10:29:54.420]                             next
[10:29:54.420]                           if (!grepl(pattern, name)) 
[10:29:54.420]                             next
[10:29:54.420]                           invokeRestart(restart)
[10:29:54.420]                           muffled <- TRUE
[10:29:54.420]                           break
[10:29:54.420]                         }
[10:29:54.420]                       }
[10:29:54.420]                     }
[10:29:54.420]                     invisible(muffled)
[10:29:54.420]                   }
[10:29:54.420]                   muffleCondition(cond)
[10:29:54.420]                 })
[10:29:54.420]             }))
[10:29:54.420]             future::FutureResult(value = ...future.value$value, 
[10:29:54.420]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.420]                   ...future.rng), globalenv = if (FALSE) 
[10:29:54.420]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:54.420]                     ...future.globalenv.names))
[10:29:54.420]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:54.420]         }, condition = base::local({
[10:29:54.420]             c <- base::c
[10:29:54.420]             inherits <- base::inherits
[10:29:54.420]             invokeRestart <- base::invokeRestart
[10:29:54.420]             length <- base::length
[10:29:54.420]             list <- base::list
[10:29:54.420]             seq.int <- base::seq.int
[10:29:54.420]             signalCondition <- base::signalCondition
[10:29:54.420]             sys.calls <- base::sys.calls
[10:29:54.420]             `[[` <- base::`[[`
[10:29:54.420]             `+` <- base::`+`
[10:29:54.420]             `<<-` <- base::`<<-`
[10:29:54.420]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:54.420]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:54.420]                   3L)]
[10:29:54.420]             }
[10:29:54.420]             function(cond) {
[10:29:54.420]                 is_error <- inherits(cond, "error")
[10:29:54.420]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:54.420]                   NULL)
[10:29:54.420]                 if (is_error) {
[10:29:54.420]                   sessionInformation <- function() {
[10:29:54.420]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:54.420]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:54.420]                       search = base::search(), system = base::Sys.info())
[10:29:54.420]                   }
[10:29:54.420]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.420]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:54.420]                     cond$call), session = sessionInformation(), 
[10:29:54.420]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:54.420]                   signalCondition(cond)
[10:29:54.420]                 }
[10:29:54.420]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:54.420]                 "immediateCondition"))) {
[10:29:54.420]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:54.420]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.420]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:54.420]                   if (TRUE && !signal) {
[10:29:54.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.420]                     {
[10:29:54.420]                       inherits <- base::inherits
[10:29:54.420]                       invokeRestart <- base::invokeRestart
[10:29:54.420]                       is.null <- base::is.null
[10:29:54.420]                       muffled <- FALSE
[10:29:54.420]                       if (inherits(cond, "message")) {
[10:29:54.420]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.420]                         if (muffled) 
[10:29:54.420]                           invokeRestart("muffleMessage")
[10:29:54.420]                       }
[10:29:54.420]                       else if (inherits(cond, "warning")) {
[10:29:54.420]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.420]                         if (muffled) 
[10:29:54.420]                           invokeRestart("muffleWarning")
[10:29:54.420]                       }
[10:29:54.420]                       else if (inherits(cond, "condition")) {
[10:29:54.420]                         if (!is.null(pattern)) {
[10:29:54.420]                           computeRestarts <- base::computeRestarts
[10:29:54.420]                           grepl <- base::grepl
[10:29:54.420]                           restarts <- computeRestarts(cond)
[10:29:54.420]                           for (restart in restarts) {
[10:29:54.420]                             name <- restart$name
[10:29:54.420]                             if (is.null(name)) 
[10:29:54.420]                               next
[10:29:54.420]                             if (!grepl(pattern, name)) 
[10:29:54.420]                               next
[10:29:54.420]                             invokeRestart(restart)
[10:29:54.420]                             muffled <- TRUE
[10:29:54.420]                             break
[10:29:54.420]                           }
[10:29:54.420]                         }
[10:29:54.420]                       }
[10:29:54.420]                       invisible(muffled)
[10:29:54.420]                     }
[10:29:54.420]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.420]                   }
[10:29:54.420]                 }
[10:29:54.420]                 else {
[10:29:54.420]                   if (TRUE) {
[10:29:54.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.420]                     {
[10:29:54.420]                       inherits <- base::inherits
[10:29:54.420]                       invokeRestart <- base::invokeRestart
[10:29:54.420]                       is.null <- base::is.null
[10:29:54.420]                       muffled <- FALSE
[10:29:54.420]                       if (inherits(cond, "message")) {
[10:29:54.420]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.420]                         if (muffled) 
[10:29:54.420]                           invokeRestart("muffleMessage")
[10:29:54.420]                       }
[10:29:54.420]                       else if (inherits(cond, "warning")) {
[10:29:54.420]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.420]                         if (muffled) 
[10:29:54.420]                           invokeRestart("muffleWarning")
[10:29:54.420]                       }
[10:29:54.420]                       else if (inherits(cond, "condition")) {
[10:29:54.420]                         if (!is.null(pattern)) {
[10:29:54.420]                           computeRestarts <- base::computeRestarts
[10:29:54.420]                           grepl <- base::grepl
[10:29:54.420]                           restarts <- computeRestarts(cond)
[10:29:54.420]                           for (restart in restarts) {
[10:29:54.420]                             name <- restart$name
[10:29:54.420]                             if (is.null(name)) 
[10:29:54.420]                               next
[10:29:54.420]                             if (!grepl(pattern, name)) 
[10:29:54.420]                               next
[10:29:54.420]                             invokeRestart(restart)
[10:29:54.420]                             muffled <- TRUE
[10:29:54.420]                             break
[10:29:54.420]                           }
[10:29:54.420]                         }
[10:29:54.420]                       }
[10:29:54.420]                       invisible(muffled)
[10:29:54.420]                     }
[10:29:54.420]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.420]                   }
[10:29:54.420]                 }
[10:29:54.420]             }
[10:29:54.420]         }))
[10:29:54.420]     }, error = function(ex) {
[10:29:54.420]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:54.420]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.420]                 ...future.rng), started = ...future.startTime, 
[10:29:54.420]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:54.420]             version = "1.8"), class = "FutureResult")
[10:29:54.420]     }, finally = {
[10:29:54.420]         if (!identical(...future.workdir, getwd())) 
[10:29:54.420]             setwd(...future.workdir)
[10:29:54.420]         {
[10:29:54.420]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:54.420]                 ...future.oldOptions$nwarnings <- NULL
[10:29:54.420]             }
[10:29:54.420]             base::options(...future.oldOptions)
[10:29:54.420]             if (.Platform$OS.type == "windows") {
[10:29:54.420]                 old_names <- names(...future.oldEnvVars)
[10:29:54.420]                 envs <- base::Sys.getenv()
[10:29:54.420]                 names <- names(envs)
[10:29:54.420]                 common <- intersect(names, old_names)
[10:29:54.420]                 added <- setdiff(names, old_names)
[10:29:54.420]                 removed <- setdiff(old_names, names)
[10:29:54.420]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:54.420]                   envs[common]]
[10:29:54.420]                 NAMES <- toupper(changed)
[10:29:54.420]                 args <- list()
[10:29:54.420]                 for (kk in seq_along(NAMES)) {
[10:29:54.420]                   name <- changed[[kk]]
[10:29:54.420]                   NAME <- NAMES[[kk]]
[10:29:54.420]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.420]                     next
[10:29:54.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.420]                 }
[10:29:54.420]                 NAMES <- toupper(added)
[10:29:54.420]                 for (kk in seq_along(NAMES)) {
[10:29:54.420]                   name <- added[[kk]]
[10:29:54.420]                   NAME <- NAMES[[kk]]
[10:29:54.420]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.420]                     next
[10:29:54.420]                   args[[name]] <- ""
[10:29:54.420]                 }
[10:29:54.420]                 NAMES <- toupper(removed)
[10:29:54.420]                 for (kk in seq_along(NAMES)) {
[10:29:54.420]                   name <- removed[[kk]]
[10:29:54.420]                   NAME <- NAMES[[kk]]
[10:29:54.420]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.420]                     next
[10:29:54.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.420]                 }
[10:29:54.420]                 if (length(args) > 0) 
[10:29:54.420]                   base::do.call(base::Sys.setenv, args = args)
[10:29:54.420]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:54.420]             }
[10:29:54.420]             else {
[10:29:54.420]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:54.420]             }
[10:29:54.420]             {
[10:29:54.420]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:54.420]                   0L) {
[10:29:54.420]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:54.420]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:54.420]                   base::options(opts)
[10:29:54.420]                 }
[10:29:54.420]                 {
[10:29:54.420]                   {
[10:29:54.420]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:54.420]                     NULL
[10:29:54.420]                   }
[10:29:54.420]                   options(future.plan = NULL)
[10:29:54.420]                   if (is.na(NA_character_)) 
[10:29:54.420]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.420]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:54.420]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:54.420]                     .init = FALSE)
[10:29:54.420]                 }
[10:29:54.420]             }
[10:29:54.420]         }
[10:29:54.420]     })
[10:29:54.420]     if (TRUE) {
[10:29:54.420]         base::sink(type = "output", split = FALSE)
[10:29:54.420]         if (TRUE) {
[10:29:54.420]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:54.420]         }
[10:29:54.420]         else {
[10:29:54.420]             ...future.result["stdout"] <- base::list(NULL)
[10:29:54.420]         }
[10:29:54.420]         base::close(...future.stdout)
[10:29:54.420]         ...future.stdout <- NULL
[10:29:54.420]     }
[10:29:54.420]     ...future.result$conditions <- ...future.conditions
[10:29:54.420]     ...future.result$finished <- base::Sys.time()
[10:29:54.420]     ...future.result
[10:29:54.420] }
[10:29:54.423] assign_globals() ...
[10:29:54.423] List of 5
[10:29:54.423]  $ ...future.FUN            :function (object, ...)  
[10:29:54.423]  $ future.call.arguments    :List of 1
[10:29:54.423]   ..$ digits: int 2
[10:29:54.423]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.423]  $ ...future.elements_ii    :List of 3
[10:29:54.423]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[10:29:54.423]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[10:29:54.423]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[10:29:54.423]  $ ...future.seeds_ii       : NULL
[10:29:54.423]  $ ...future.globals.maxSize: NULL
[10:29:54.423]  - attr(*, "where")=List of 5
[10:29:54.423]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:54.423]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:54.423]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:54.423]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:54.423]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:54.423]  - attr(*, "resolved")= logi FALSE
[10:29:54.423]  - attr(*, "total_size")= num 1296
[10:29:54.423]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.423]  - attr(*, "already-done")= logi TRUE
[10:29:54.434] - copied ‘...future.FUN’ to environment
[10:29:54.434] - copied ‘future.call.arguments’ to environment
[10:29:54.434] - copied ‘...future.elements_ii’ to environment
[10:29:54.434] - copied ‘...future.seeds_ii’ to environment
[10:29:54.435] - copied ‘...future.globals.maxSize’ to environment
[10:29:54.435] assign_globals() ... done
[10:29:54.435] requestCore(): workers = 2
[10:29:54.437] MulticoreFuture started
[10:29:54.438] - Launch lazy future ... done
[10:29:54.439] run() for ‘MulticoreFuture’ ... done
[10:29:54.439] plan(): Setting new future strategy stack:
[10:29:54.440] Created future:
[10:29:54.439] List of future strategies:
[10:29:54.439] 1. sequential:
[10:29:54.439]    - args: function (..., envir = parent.frame())
[10:29:54.439]    - tweaked: FALSE
[10:29:54.439]    - call: NULL
[10:29:54.441] plan(): nbrOfWorkers() = 1
[10:29:54.445] plan(): Setting new future strategy stack:
[10:29:54.446] List of future strategies:
[10:29:54.446] 1. multicore:
[10:29:54.446]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:54.446]    - tweaked: FALSE
[10:29:54.446]    - call: plan(strategy)
[10:29:54.452] plan(): nbrOfWorkers() = 2
[10:29:54.440] MulticoreFuture:
[10:29:54.440] Label: ‘future_by-2’
[10:29:54.440] Expression:
[10:29:54.440] {
[10:29:54.440]     do.call(function(...) {
[10:29:54.440]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.440]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.440]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.440]             on.exit(options(oopts), add = TRUE)
[10:29:54.440]         }
[10:29:54.440]         {
[10:29:54.440]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.440]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.440]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.440]             })
[10:29:54.440]         }
[10:29:54.440]     }, args = future.call.arguments)
[10:29:54.440] }
[10:29:54.440] Lazy evaluation: FALSE
[10:29:54.440] Asynchronous evaluation: TRUE
[10:29:54.440] Local evaluation: TRUE
[10:29:54.440] Environment: R_GlobalEnv
[10:29:54.440] Capture standard output: TRUE
[10:29:54.440] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:54.440] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:54.440] Packages: <none>
[10:29:54.440] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:54.440] Resolved: TRUE
[10:29:54.440] Value: <not collected>
[10:29:54.440] Conditions captured: <none>
[10:29:54.440] Early signaling: FALSE
[10:29:54.440] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:54.440] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:54.454] Chunk #2 of 2 ... DONE
[10:29:54.454] Launching 2 futures (chunks) ... DONE
[10:29:54.454] Resolving 2 futures (chunks) ...
[10:29:54.454] resolve() on list ...
[10:29:54.455]  recursive: 0
[10:29:54.455]  length: 2
[10:29:54.455] 
[10:29:54.455] Future #1
[10:29:54.456] result() for MulticoreFuture ...
[10:29:54.457] result() for MulticoreFuture ...
[10:29:54.457] result() for MulticoreFuture ... done
[10:29:54.457] result() for MulticoreFuture ... done
[10:29:54.457] result() for MulticoreFuture ...
[10:29:54.458] result() for MulticoreFuture ... done
[10:29:54.458] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:29:54.458] - nx: 2
[10:29:54.458] - relay: TRUE
[10:29:54.459] - stdout: TRUE
[10:29:54.459] - signal: TRUE
[10:29:54.459] - resignal: FALSE
[10:29:54.459] - force: TRUE
[10:29:54.460] - relayed: [n=2] FALSE, FALSE
[10:29:54.460] - queued futures: [n=2] FALSE, FALSE
[10:29:54.460]  - until=1
[10:29:54.460]  - relaying element #1
[10:29:54.460] result() for MulticoreFuture ...
[10:29:54.461] result() for MulticoreFuture ... done
[10:29:54.461] result() for MulticoreFuture ...
[10:29:54.461] result() for MulticoreFuture ... done
[10:29:54.461] result() for MulticoreFuture ...
[10:29:54.462] result() for MulticoreFuture ... done
[10:29:54.462] result() for MulticoreFuture ...
[10:29:54.462] result() for MulticoreFuture ... done
[10:29:54.462] - relayed: [n=2] TRUE, FALSE
[10:29:54.462] - queued futures: [n=2] TRUE, FALSE
[10:29:54.462] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:29:54.463]  length: 1 (resolved future 1)
[10:29:54.463] Future #2
[10:29:54.463] result() for MulticoreFuture ...
[10:29:54.464] result() for MulticoreFuture ...
[10:29:54.464] result() for MulticoreFuture ... done
[10:29:54.464] result() for MulticoreFuture ... done
[10:29:54.464] result() for MulticoreFuture ...
[10:29:54.464] result() for MulticoreFuture ... done
[10:29:54.465] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:29:54.465] - nx: 2
[10:29:54.465] - relay: TRUE
[10:29:54.465] - stdout: TRUE
[10:29:54.465] - signal: TRUE
[10:29:54.465] - resignal: FALSE
[10:29:54.465] - force: TRUE
[10:29:54.465] - relayed: [n=2] TRUE, FALSE
[10:29:54.465] - queued futures: [n=2] TRUE, FALSE
[10:29:54.466]  - until=2
[10:29:54.466]  - relaying element #2
[10:29:54.466] result() for MulticoreFuture ...
[10:29:54.466] result() for MulticoreFuture ... done
[10:29:54.466] result() for MulticoreFuture ...
[10:29:54.466] result() for MulticoreFuture ... done
[10:29:54.466] result() for MulticoreFuture ...
[10:29:54.467] result() for MulticoreFuture ... done
[10:29:54.467] result() for MulticoreFuture ...
[10:29:54.467] result() for MulticoreFuture ... done
[10:29:54.467] - relayed: [n=2] TRUE, TRUE
[10:29:54.467] - queued futures: [n=2] TRUE, TRUE
[10:29:54.467] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:29:54.467]  length: 0 (resolved future 2)
[10:29:54.467] Relaying remaining futures
[10:29:54.467] signalConditionsASAP(NULL, pos=0) ...
[10:29:54.468] - nx: 2
[10:29:54.468] - relay: TRUE
[10:29:54.468] - stdout: TRUE
[10:29:54.468] - signal: TRUE
[10:29:54.468] - resignal: FALSE
[10:29:54.468] - force: TRUE
[10:29:54.468] - relayed: [n=2] TRUE, TRUE
[10:29:54.468] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:54.468] - relayed: [n=2] TRUE, TRUE
[10:29:54.468] - queued futures: [n=2] TRUE, TRUE
[10:29:54.469] signalConditionsASAP(NULL, pos=0) ... done
[10:29:54.469] resolve() on list ... DONE
[10:29:54.469] result() for MulticoreFuture ...
[10:29:54.469] result() for MulticoreFuture ... done
[10:29:54.469] result() for MulticoreFuture ...
[10:29:54.469] result() for MulticoreFuture ... done
[10:29:54.469] result() for MulticoreFuture ...
[10:29:54.469] result() for MulticoreFuture ... done
[10:29:54.470] result() for MulticoreFuture ...
[10:29:54.470] result() for MulticoreFuture ... done
[10:29:54.470]  - Number of value chunks collected: 2
[10:29:54.470] Resolving 2 futures (chunks) ... DONE
[10:29:54.470] Reducing values from 2 chunks ...
[10:29:54.470]  - Number of values collected after concatenation: 6
[10:29:54.470]  - Number of values expected: 6
[10:29:54.470] Reducing values from 2 chunks ... DONE
[10:29:54.470] future_lapply() ... DONE
[10:29:54.471] future_by_internal() ... DONE
[10:29:54.472] future_by_internal() ...
[10:29:54.472] future_lapply() ...
[10:29:54.480] Number of chunks: 2
[10:29:54.481] getGlobalsAndPackagesXApply() ...
[10:29:54.481]  - future.globals: TRUE
[10:29:54.481] getGlobalsAndPackages() ...
[10:29:54.481] Searching for globals...
[10:29:54.483] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:29:54.483] Searching for globals ... DONE
[10:29:54.483] Resolving globals: FALSE
[10:29:54.484] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[10:29:54.484] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[10:29:54.485] - globals: [1] ‘FUN’
[10:29:54.485] - packages: [1] ‘stats’
[10:29:54.485] getGlobalsAndPackages() ... DONE
[10:29:54.485]  - globals found/used: [n=1] ‘FUN’
[10:29:54.485]  - needed namespaces: [n=1] ‘stats’
[10:29:54.485] Finding globals ... DONE
[10:29:54.485]  - use_args: TRUE
[10:29:54.486]  - Getting '...' globals ...
[10:29:54.486] resolve() on list ...
[10:29:54.486]  recursive: 0
[10:29:54.486]  length: 1
[10:29:54.486]  elements: ‘...’
[10:29:54.487]  length: 0 (resolved future 1)
[10:29:54.487] resolve() on list ... DONE
[10:29:54.487]    - '...' content: [n=1] ‘singular.ok’
[10:29:54.487] List of 1
[10:29:54.487]  $ ...:List of 1
[10:29:54.487]   ..$ singular.ok: logi FALSE
[10:29:54.487]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.487]  - attr(*, "where")=List of 1
[10:29:54.487]   ..$ ...:<environment: 0x556dd5113db8> 
[10:29:54.487]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.487]  - attr(*, "resolved")= logi TRUE
[10:29:54.487]  - attr(*, "total_size")= num NA
[10:29:54.490]  - Getting '...' globals ... DONE
[10:29:54.490] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:54.490] List of 2
[10:29:54.490]  $ ...future.FUN:function (x, ...)  
[10:29:54.490]  $ ...          :List of 1
[10:29:54.490]   ..$ singular.ok: logi FALSE
[10:29:54.490]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.490]  - attr(*, "where")=List of 2
[10:29:54.490]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:54.490]   ..$ ...          :<environment: 0x556dd5113db8> 
[10:29:54.490]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.490]  - attr(*, "resolved")= logi FALSE
[10:29:54.490]  - attr(*, "total_size")= num 5384
[10:29:54.494] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:54.494] getGlobalsAndPackagesXApply() ... DONE
[10:29:54.494] Number of futures (= number of chunks): 2
[10:29:54.494] Launching 2 futures (chunks) ...
[10:29:54.494] Chunk #1 of 2 ...
[10:29:54.494]  - Finding globals in 'X' for chunk #1 ...
[10:29:54.494] getGlobalsAndPackages() ...
[10:29:54.495] Searching for globals...
[10:29:54.495] 
[10:29:54.495] Searching for globals ... DONE
[10:29:54.495] - globals: [0] <none>
[10:29:54.495] getGlobalsAndPackages() ... DONE
[10:29:54.495]    + additional globals found: [n=0] 
[10:29:54.495]    + additional namespaces needed: [n=0] 
[10:29:54.495]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:54.496]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:54.496]  - seeds: <none>
[10:29:54.496]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.496] getGlobalsAndPackages() ...
[10:29:54.496] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.496] Resolving globals: FALSE
[10:29:54.496] Tweak future expression to call with '...' arguments ...
[10:29:54.496] {
[10:29:54.496]     do.call(function(...) {
[10:29:54.496]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.496]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.496]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.496]             on.exit(options(oopts), add = TRUE)
[10:29:54.496]         }
[10:29:54.496]         {
[10:29:54.496]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.496]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.496]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.496]             })
[10:29:54.496]         }
[10:29:54.496]     }, args = future.call.arguments)
[10:29:54.496] }
[10:29:54.497] Tweak future expression to call with '...' arguments ... DONE
[10:29:54.497] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.497] 
[10:29:54.497] getGlobalsAndPackages() ... DONE
[10:29:54.497] run() for ‘Future’ ...
[10:29:54.498] - state: ‘created’
[10:29:54.498] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:54.501] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:54.502] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:54.502]   - Field: ‘label’
[10:29:54.502]   - Field: ‘local’
[10:29:54.502]   - Field: ‘owner’
[10:29:54.504]   - Field: ‘envir’
[10:29:54.504]   - Field: ‘workers’
[10:29:54.504]   - Field: ‘packages’
[10:29:54.504]   - Field: ‘gc’
[10:29:54.504]   - Field: ‘job’
[10:29:54.504]   - Field: ‘conditions’
[10:29:54.505]   - Field: ‘expr’
[10:29:54.505]   - Field: ‘uuid’
[10:29:54.505]   - Field: ‘seed’
[10:29:54.505]   - Field: ‘version’
[10:29:54.505]   - Field: ‘result’
[10:29:54.505]   - Field: ‘asynchronous’
[10:29:54.505]   - Field: ‘calls’
[10:29:54.505]   - Field: ‘globals’
[10:29:54.505]   - Field: ‘stdout’
[10:29:54.506]   - Field: ‘earlySignal’
[10:29:54.506]   - Field: ‘lazy’
[10:29:54.506]   - Field: ‘state’
[10:29:54.506] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:54.506] - Launch lazy future ...
[10:29:54.506] Packages needed by the future expression (n = 1): ‘stats’
[10:29:54.506] Packages needed by future strategies (n = 0): <none>
[10:29:54.507] {
[10:29:54.507]     {
[10:29:54.507]         {
[10:29:54.507]             ...future.startTime <- base::Sys.time()
[10:29:54.507]             {
[10:29:54.507]                 {
[10:29:54.507]                   {
[10:29:54.507]                     {
[10:29:54.507]                       {
[10:29:54.507]                         base::local({
[10:29:54.507]                           has_future <- base::requireNamespace("future", 
[10:29:54.507]                             quietly = TRUE)
[10:29:54.507]                           if (has_future) {
[10:29:54.507]                             ns <- base::getNamespace("future")
[10:29:54.507]                             version <- ns[[".package"]][["version"]]
[10:29:54.507]                             if (is.null(version)) 
[10:29:54.507]                               version <- utils::packageVersion("future")
[10:29:54.507]                           }
[10:29:54.507]                           else {
[10:29:54.507]                             version <- NULL
[10:29:54.507]                           }
[10:29:54.507]                           if (!has_future || version < "1.8.0") {
[10:29:54.507]                             info <- base::c(r_version = base::gsub("R version ", 
[10:29:54.507]                               "", base::R.version$version.string), 
[10:29:54.507]                               platform = base::sprintf("%s (%s-bit)", 
[10:29:54.507]                                 base::R.version$platform, 8 * 
[10:29:54.507]                                   base::.Machine$sizeof.pointer), 
[10:29:54.507]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:54.507]                                 "release", "version")], collapse = " "), 
[10:29:54.507]                               hostname = base::Sys.info()[["nodename"]])
[10:29:54.507]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:29:54.507]                               info)
[10:29:54.507]                             info <- base::paste(info, collapse = "; ")
[10:29:54.507]                             if (!has_future) {
[10:29:54.507]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:54.507]                                 info)
[10:29:54.507]                             }
[10:29:54.507]                             else {
[10:29:54.507]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:54.507]                                 info, version)
[10:29:54.507]                             }
[10:29:54.507]                             base::stop(msg)
[10:29:54.507]                           }
[10:29:54.507]                         })
[10:29:54.507]                       }
[10:29:54.507]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:54.507]                       base::options(mc.cores = 1L)
[10:29:54.507]                     }
[10:29:54.507]                     base::local({
[10:29:54.507]                       for (pkg in "stats") {
[10:29:54.507]                         base::loadNamespace(pkg)
[10:29:54.507]                         base::library(pkg, character.only = TRUE)
[10:29:54.507]                       }
[10:29:54.507]                     })
[10:29:54.507]                   }
[10:29:54.507]                   ...future.strategy.old <- future::plan("list")
[10:29:54.507]                   options(future.plan = NULL)
[10:29:54.507]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.507]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:54.507]                 }
[10:29:54.507]                 ...future.workdir <- getwd()
[10:29:54.507]             }
[10:29:54.507]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:54.507]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:54.507]         }
[10:29:54.507]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:54.507]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:54.507]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:54.507]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:54.507]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:54.507]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:54.507]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:54.507]             base::names(...future.oldOptions))
[10:29:54.507]     }
[10:29:54.507]     if (FALSE) {
[10:29:54.507]     }
[10:29:54.507]     else {
[10:29:54.507]         if (TRUE) {
[10:29:54.507]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:54.507]                 open = "w")
[10:29:54.507]         }
[10:29:54.507]         else {
[10:29:54.507]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:54.507]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:54.507]         }
[10:29:54.507]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:54.507]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:54.507]             base::sink(type = "output", split = FALSE)
[10:29:54.507]             base::close(...future.stdout)
[10:29:54.507]         }, add = TRUE)
[10:29:54.507]     }
[10:29:54.507]     ...future.frame <- base::sys.nframe()
[10:29:54.507]     ...future.conditions <- base::list()
[10:29:54.507]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:54.507]     if (FALSE) {
[10:29:54.507]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:54.507]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:54.507]     }
[10:29:54.507]     ...future.result <- base::tryCatch({
[10:29:54.507]         base::withCallingHandlers({
[10:29:54.507]             ...future.value <- base::withVisible(base::local({
[10:29:54.507]                 withCallingHandlers({
[10:29:54.507]                   {
[10:29:54.507]                     do.call(function(...) {
[10:29:54.507]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.507]                       if (!identical(...future.globals.maxSize.org, 
[10:29:54.507]                         ...future.globals.maxSize)) {
[10:29:54.507]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.507]                         on.exit(options(oopts), add = TRUE)
[10:29:54.507]                       }
[10:29:54.507]                       {
[10:29:54.507]                         lapply(seq_along(...future.elements_ii), 
[10:29:54.507]                           FUN = function(jj) {
[10:29:54.507]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.507]                             ...future.FUN(...future.X_jj, ...)
[10:29:54.507]                           })
[10:29:54.507]                       }
[10:29:54.507]                     }, args = future.call.arguments)
[10:29:54.507]                   }
[10:29:54.507]                 }, immediateCondition = function(cond) {
[10:29:54.507]                   save_rds <- function (object, pathname, ...) 
[10:29:54.507]                   {
[10:29:54.507]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:54.507]                     if (file_test("-f", pathname_tmp)) {
[10:29:54.507]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.507]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:54.507]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.507]                         fi_tmp[["mtime"]])
[10:29:54.507]                     }
[10:29:54.507]                     tryCatch({
[10:29:54.507]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:54.507]                     }, error = function(ex) {
[10:29:54.507]                       msg <- conditionMessage(ex)
[10:29:54.507]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.507]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:54.507]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.507]                         fi_tmp[["mtime"]], msg)
[10:29:54.507]                       ex$message <- msg
[10:29:54.507]                       stop(ex)
[10:29:54.507]                     })
[10:29:54.507]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:54.507]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:54.507]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:54.507]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.507]                       fi <- file.info(pathname)
[10:29:54.507]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:54.507]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.507]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:54.507]                         fi[["size"]], fi[["mtime"]])
[10:29:54.507]                       stop(msg)
[10:29:54.507]                     }
[10:29:54.507]                     invisible(pathname)
[10:29:54.507]                   }
[10:29:54.507]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:54.507]                     rootPath = tempdir()) 
[10:29:54.507]                   {
[10:29:54.507]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:54.507]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:54.507]                       tmpdir = path, fileext = ".rds")
[10:29:54.507]                     save_rds(obj, file)
[10:29:54.507]                   }
[10:29:54.507]                   saveImmediateCondition(cond, path = "/tmp/Rtmp11FQBX/.future/immediateConditions")
[10:29:54.507]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.507]                   {
[10:29:54.507]                     inherits <- base::inherits
[10:29:54.507]                     invokeRestart <- base::invokeRestart
[10:29:54.507]                     is.null <- base::is.null
[10:29:54.507]                     muffled <- FALSE
[10:29:54.507]                     if (inherits(cond, "message")) {
[10:29:54.507]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:54.507]                       if (muffled) 
[10:29:54.507]                         invokeRestart("muffleMessage")
[10:29:54.507]                     }
[10:29:54.507]                     else if (inherits(cond, "warning")) {
[10:29:54.507]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:54.507]                       if (muffled) 
[10:29:54.507]                         invokeRestart("muffleWarning")
[10:29:54.507]                     }
[10:29:54.507]                     else if (inherits(cond, "condition")) {
[10:29:54.507]                       if (!is.null(pattern)) {
[10:29:54.507]                         computeRestarts <- base::computeRestarts
[10:29:54.507]                         grepl <- base::grepl
[10:29:54.507]                         restarts <- computeRestarts(cond)
[10:29:54.507]                         for (restart in restarts) {
[10:29:54.507]                           name <- restart$name
[10:29:54.507]                           if (is.null(name)) 
[10:29:54.507]                             next
[10:29:54.507]                           if (!grepl(pattern, name)) 
[10:29:54.507]                             next
[10:29:54.507]                           invokeRestart(restart)
[10:29:54.507]                           muffled <- TRUE
[10:29:54.507]                           break
[10:29:54.507]                         }
[10:29:54.507]                       }
[10:29:54.507]                     }
[10:29:54.507]                     invisible(muffled)
[10:29:54.507]                   }
[10:29:54.507]                   muffleCondition(cond)
[10:29:54.507]                 })
[10:29:54.507]             }))
[10:29:54.507]             future::FutureResult(value = ...future.value$value, 
[10:29:54.507]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.507]                   ...future.rng), globalenv = if (FALSE) 
[10:29:54.507]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:54.507]                     ...future.globalenv.names))
[10:29:54.507]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:54.507]         }, condition = base::local({
[10:29:54.507]             c <- base::c
[10:29:54.507]             inherits <- base::inherits
[10:29:54.507]             invokeRestart <- base::invokeRestart
[10:29:54.507]             length <- base::length
[10:29:54.507]             list <- base::list
[10:29:54.507]             seq.int <- base::seq.int
[10:29:54.507]             signalCondition <- base::signalCondition
[10:29:54.507]             sys.calls <- base::sys.calls
[10:29:54.507]             `[[` <- base::`[[`
[10:29:54.507]             `+` <- base::`+`
[10:29:54.507]             `<<-` <- base::`<<-`
[10:29:54.507]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:54.507]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:54.507]                   3L)]
[10:29:54.507]             }
[10:29:54.507]             function(cond) {
[10:29:54.507]                 is_error <- inherits(cond, "error")
[10:29:54.507]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:54.507]                   NULL)
[10:29:54.507]                 if (is_error) {
[10:29:54.507]                   sessionInformation <- function() {
[10:29:54.507]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:54.507]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:54.507]                       search = base::search(), system = base::Sys.info())
[10:29:54.507]                   }
[10:29:54.507]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.507]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:54.507]                     cond$call), session = sessionInformation(), 
[10:29:54.507]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:54.507]                   signalCondition(cond)
[10:29:54.507]                 }
[10:29:54.507]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:54.507]                 "immediateCondition"))) {
[10:29:54.507]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:54.507]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.507]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:54.507]                   if (TRUE && !signal) {
[10:29:54.507]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.507]                     {
[10:29:54.507]                       inherits <- base::inherits
[10:29:54.507]                       invokeRestart <- base::invokeRestart
[10:29:54.507]                       is.null <- base::is.null
[10:29:54.507]                       muffled <- FALSE
[10:29:54.507]                       if (inherits(cond, "message")) {
[10:29:54.507]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.507]                         if (muffled) 
[10:29:54.507]                           invokeRestart("muffleMessage")
[10:29:54.507]                       }
[10:29:54.507]                       else if (inherits(cond, "warning")) {
[10:29:54.507]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.507]                         if (muffled) 
[10:29:54.507]                           invokeRestart("muffleWarning")
[10:29:54.507]                       }
[10:29:54.507]                       else if (inherits(cond, "condition")) {
[10:29:54.507]                         if (!is.null(pattern)) {
[10:29:54.507]                           computeRestarts <- base::computeRestarts
[10:29:54.507]                           grepl <- base::grepl
[10:29:54.507]                           restarts <- computeRestarts(cond)
[10:29:54.507]                           for (restart in restarts) {
[10:29:54.507]                             name <- restart$name
[10:29:54.507]                             if (is.null(name)) 
[10:29:54.507]                               next
[10:29:54.507]                             if (!grepl(pattern, name)) 
[10:29:54.507]                               next
[10:29:54.507]                             invokeRestart(restart)
[10:29:54.507]                             muffled <- TRUE
[10:29:54.507]                             break
[10:29:54.507]                           }
[10:29:54.507]                         }
[10:29:54.507]                       }
[10:29:54.507]                       invisible(muffled)
[10:29:54.507]                     }
[10:29:54.507]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.507]                   }
[10:29:54.507]                 }
[10:29:54.507]                 else {
[10:29:54.507]                   if (TRUE) {
[10:29:54.507]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.507]                     {
[10:29:54.507]                       inherits <- base::inherits
[10:29:54.507]                       invokeRestart <- base::invokeRestart
[10:29:54.507]                       is.null <- base::is.null
[10:29:54.507]                       muffled <- FALSE
[10:29:54.507]                       if (inherits(cond, "message")) {
[10:29:54.507]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.507]                         if (muffled) 
[10:29:54.507]                           invokeRestart("muffleMessage")
[10:29:54.507]                       }
[10:29:54.507]                       else if (inherits(cond, "warning")) {
[10:29:54.507]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.507]                         if (muffled) 
[10:29:54.507]                           invokeRestart("muffleWarning")
[10:29:54.507]                       }
[10:29:54.507]                       else if (inherits(cond, "condition")) {
[10:29:54.507]                         if (!is.null(pattern)) {
[10:29:54.507]                           computeRestarts <- base::computeRestarts
[10:29:54.507]                           grepl <- base::grepl
[10:29:54.507]                           restarts <- computeRestarts(cond)
[10:29:54.507]                           for (restart in restarts) {
[10:29:54.507]                             name <- restart$name
[10:29:54.507]                             if (is.null(name)) 
[10:29:54.507]                               next
[10:29:54.507]                             if (!grepl(pattern, name)) 
[10:29:54.507]                               next
[10:29:54.507]                             invokeRestart(restart)
[10:29:54.507]                             muffled <- TRUE
[10:29:54.507]                             break
[10:29:54.507]                           }
[10:29:54.507]                         }
[10:29:54.507]                       }
[10:29:54.507]                       invisible(muffled)
[10:29:54.507]                     }
[10:29:54.507]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.507]                   }
[10:29:54.507]                 }
[10:29:54.507]             }
[10:29:54.507]         }))
[10:29:54.507]     }, error = function(ex) {
[10:29:54.507]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:54.507]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.507]                 ...future.rng), started = ...future.startTime, 
[10:29:54.507]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:54.507]             version = "1.8"), class = "FutureResult")
[10:29:54.507]     }, finally = {
[10:29:54.507]         if (!identical(...future.workdir, getwd())) 
[10:29:54.507]             setwd(...future.workdir)
[10:29:54.507]         {
[10:29:54.507]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:54.507]                 ...future.oldOptions$nwarnings <- NULL
[10:29:54.507]             }
[10:29:54.507]             base::options(...future.oldOptions)
[10:29:54.507]             if (.Platform$OS.type == "windows") {
[10:29:54.507]                 old_names <- names(...future.oldEnvVars)
[10:29:54.507]                 envs <- base::Sys.getenv()
[10:29:54.507]                 names <- names(envs)
[10:29:54.507]                 common <- intersect(names, old_names)
[10:29:54.507]                 added <- setdiff(names, old_names)
[10:29:54.507]                 removed <- setdiff(old_names, names)
[10:29:54.507]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:54.507]                   envs[common]]
[10:29:54.507]                 NAMES <- toupper(changed)
[10:29:54.507]                 args <- list()
[10:29:54.507]                 for (kk in seq_along(NAMES)) {
[10:29:54.507]                   name <- changed[[kk]]
[10:29:54.507]                   NAME <- NAMES[[kk]]
[10:29:54.507]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.507]                     next
[10:29:54.507]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.507]                 }
[10:29:54.507]                 NAMES <- toupper(added)
[10:29:54.507]                 for (kk in seq_along(NAMES)) {
[10:29:54.507]                   name <- added[[kk]]
[10:29:54.507]                   NAME <- NAMES[[kk]]
[10:29:54.507]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.507]                     next
[10:29:54.507]                   args[[name]] <- ""
[10:29:54.507]                 }
[10:29:54.507]                 NAMES <- toupper(removed)
[10:29:54.507]                 for (kk in seq_along(NAMES)) {
[10:29:54.507]                   name <- removed[[kk]]
[10:29:54.507]                   NAME <- NAMES[[kk]]
[10:29:54.507]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.507]                     next
[10:29:54.507]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.507]                 }
[10:29:54.507]                 if (length(args) > 0) 
[10:29:54.507]                   base::do.call(base::Sys.setenv, args = args)
[10:29:54.507]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:54.507]             }
[10:29:54.507]             else {
[10:29:54.507]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:54.507]             }
[10:29:54.507]             {
[10:29:54.507]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:54.507]                   0L) {
[10:29:54.507]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:54.507]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:54.507]                   base::options(opts)
[10:29:54.507]                 }
[10:29:54.507]                 {
[10:29:54.507]                   {
[10:29:54.507]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:54.507]                     NULL
[10:29:54.507]                   }
[10:29:54.507]                   options(future.plan = NULL)
[10:29:54.507]                   if (is.na(NA_character_)) 
[10:29:54.507]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.507]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:54.507]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:54.507]                     .init = FALSE)
[10:29:54.507]                 }
[10:29:54.507]             }
[10:29:54.507]         }
[10:29:54.507]     })
[10:29:54.507]     if (TRUE) {
[10:29:54.507]         base::sink(type = "output", split = FALSE)
[10:29:54.507]         if (TRUE) {
[10:29:54.507]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:54.507]         }
[10:29:54.507]         else {
[10:29:54.507]             ...future.result["stdout"] <- base::list(NULL)
[10:29:54.507]         }
[10:29:54.507]         base::close(...future.stdout)
[10:29:54.507]         ...future.stdout <- NULL
[10:29:54.507]     }
[10:29:54.507]     ...future.result$conditions <- ...future.conditions
[10:29:54.507]     ...future.result$finished <- base::Sys.time()
[10:29:54.507]     ...future.result
[10:29:54.507] }
[10:29:54.510] assign_globals() ...
[10:29:54.510] List of 5
[10:29:54.510]  $ ...future.FUN            :function (x, ...)  
[10:29:54.510]  $ future.call.arguments    :List of 1
[10:29:54.510]   ..$ singular.ok: logi FALSE
[10:29:54.510]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.510]  $ ...future.elements_ii    :List of 1
[10:29:54.510]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:54.510]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:29:54.510]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:54.510]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:54.510]  $ ...future.seeds_ii       : NULL
[10:29:54.510]  $ ...future.globals.maxSize: NULL
[10:29:54.510]  - attr(*, "where")=List of 5
[10:29:54.510]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:54.510]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:54.510]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:54.510]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:54.510]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:54.510]  - attr(*, "resolved")= logi FALSE
[10:29:54.510]  - attr(*, "total_size")= num 5384
[10:29:54.510]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.510]  - attr(*, "already-done")= logi TRUE
[10:29:54.517] - reassign environment for ‘...future.FUN’
[10:29:54.517] - copied ‘...future.FUN’ to environment
[10:29:54.517] - copied ‘future.call.arguments’ to environment
[10:29:54.517] - copied ‘...future.elements_ii’ to environment
[10:29:54.517] - copied ‘...future.seeds_ii’ to environment
[10:29:54.517] - copied ‘...future.globals.maxSize’ to environment
[10:29:54.517] assign_globals() ... done
[10:29:54.517] requestCore(): workers = 2
[10:29:54.520] MulticoreFuture started
[10:29:54.520] - Launch lazy future ... done
[10:29:54.520] run() for ‘MulticoreFuture’ ... done
[10:29:54.521] Created future:
[10:29:54.522] plan(): Setting new future strategy stack:
[10:29:54.522] List of future strategies:
[10:29:54.522] 1. sequential:
[10:29:54.522]    - args: function (..., envir = parent.frame())
[10:29:54.522]    - tweaked: FALSE
[10:29:54.522]    - call: NULL
[10:29:54.523] plan(): nbrOfWorkers() = 1
[10:29:54.527] plan(): Setting new future strategy stack:
[10:29:54.527] List of future strategies:
[10:29:54.527] 1. multicore:
[10:29:54.527]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:54.527]    - tweaked: FALSE
[10:29:54.527]    - call: plan(strategy)
[10:29:54.533] plan(): nbrOfWorkers() = 2
[10:29:54.521] MulticoreFuture:
[10:29:54.521] Label: ‘future_by-1’
[10:29:54.521] Expression:
[10:29:54.521] {
[10:29:54.521]     do.call(function(...) {
[10:29:54.521]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.521]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.521]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.521]             on.exit(options(oopts), add = TRUE)
[10:29:54.521]         }
[10:29:54.521]         {
[10:29:54.521]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.521]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.521]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.521]             })
[10:29:54.521]         }
[10:29:54.521]     }, args = future.call.arguments)
[10:29:54.521] }
[10:29:54.521] Lazy evaluation: FALSE
[10:29:54.521] Asynchronous evaluation: TRUE
[10:29:54.521] Local evaluation: TRUE
[10:29:54.521] Environment: R_GlobalEnv
[10:29:54.521] Capture standard output: TRUE
[10:29:54.521] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:54.521] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:54.521] Packages: 1 packages (‘stats’)
[10:29:54.521] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:54.521] Resolved: FALSE
[10:29:54.521] Value: <not collected>
[10:29:54.521] Conditions captured: <none>
[10:29:54.521] Early signaling: FALSE
[10:29:54.521] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:54.521] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:54.534] Chunk #1 of 2 ... DONE
[10:29:54.534] Chunk #2 of 2 ...
[10:29:54.535]  - Finding globals in 'X' for chunk #2 ...
[10:29:54.535] getGlobalsAndPackages() ...
[10:29:54.535] Searching for globals...
[10:29:54.536] 
[10:29:54.536] Searching for globals ... DONE
[10:29:54.536] - globals: [0] <none>
[10:29:54.536] getGlobalsAndPackages() ... DONE
[10:29:54.536]    + additional globals found: [n=0] 
[10:29:54.537]    + additional namespaces needed: [n=0] 
[10:29:54.537]  - Finding globals in 'X' for chunk #2 ... DONE
[10:29:54.537]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:54.537]  - seeds: <none>
[10:29:54.537]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.537] getGlobalsAndPackages() ...
[10:29:54.537] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.538] Resolving globals: FALSE
[10:29:54.538] Tweak future expression to call with '...' arguments ...
[10:29:54.538] {
[10:29:54.538]     do.call(function(...) {
[10:29:54.538]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.538]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.538]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.538]             on.exit(options(oopts), add = TRUE)
[10:29:54.538]         }
[10:29:54.538]         {
[10:29:54.538]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.538]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.538]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.538]             })
[10:29:54.538]         }
[10:29:54.538]     }, args = future.call.arguments)
[10:29:54.538] }
[10:29:54.538] Tweak future expression to call with '...' arguments ... DONE
[10:29:54.539] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.539] 
[10:29:54.539] getGlobalsAndPackages() ... DONE
[10:29:54.540] run() for ‘Future’ ...
[10:29:54.540] - state: ‘created’
[10:29:54.540] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:54.545] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:54.545] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:54.546]   - Field: ‘label’
[10:29:54.546]   - Field: ‘local’
[10:29:54.546]   - Field: ‘owner’
[10:29:54.546]   - Field: ‘envir’
[10:29:54.546]   - Field: ‘workers’
[10:29:54.550]   - Field: ‘packages’
[10:29:54.550]   - Field: ‘gc’
[10:29:54.550]   - Field: ‘job’
[10:29:54.551]   - Field: ‘conditions’
[10:29:54.551]   - Field: ‘expr’
[10:29:54.551]   - Field: ‘uuid’
[10:29:54.552]   - Field: ‘seed’
[10:29:54.552]   - Field: ‘version’
[10:29:54.552]   - Field: ‘result’
[10:29:54.552]   - Field: ‘asynchronous’
[10:29:54.553]   - Field: ‘calls’
[10:29:54.553]   - Field: ‘globals’
[10:29:54.553]   - Field: ‘stdout’
[10:29:54.553]   - Field: ‘earlySignal’
[10:29:54.553]   - Field: ‘lazy’
[10:29:54.554]   - Field: ‘state’
[10:29:54.554] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:54.554] - Launch lazy future ...
[10:29:54.555] Packages needed by the future expression (n = 1): ‘stats’
[10:29:54.555] Packages needed by future strategies (n = 0): <none>
[10:29:54.556] {
[10:29:54.556]     {
[10:29:54.556]         {
[10:29:54.556]             ...future.startTime <- base::Sys.time()
[10:29:54.556]             {
[10:29:54.556]                 {
[10:29:54.556]                   {
[10:29:54.556]                     {
[10:29:54.556]                       {
[10:29:54.556]                         base::local({
[10:29:54.556]                           has_future <- base::requireNamespace("future", 
[10:29:54.556]                             quietly = TRUE)
[10:29:54.556]                           if (has_future) {
[10:29:54.556]                             ns <- base::getNamespace("future")
[10:29:54.556]                             version <- ns[[".package"]][["version"]]
[10:29:54.556]                             if (is.null(version)) 
[10:29:54.556]                               version <- utils::packageVersion("future")
[10:29:54.556]                           }
[10:29:54.556]                           else {
[10:29:54.556]                             version <- NULL
[10:29:54.556]                           }
[10:29:54.556]                           if (!has_future || version < "1.8.0") {
[10:29:54.556]                             info <- base::c(r_version = base::gsub("R version ", 
[10:29:54.556]                               "", base::R.version$version.string), 
[10:29:54.556]                               platform = base::sprintf("%s (%s-bit)", 
[10:29:54.556]                                 base::R.version$platform, 8 * 
[10:29:54.556]                                   base::.Machine$sizeof.pointer), 
[10:29:54.556]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:54.556]                                 "release", "version")], collapse = " "), 
[10:29:54.556]                               hostname = base::Sys.info()[["nodename"]])
[10:29:54.556]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:29:54.556]                               info)
[10:29:54.556]                             info <- base::paste(info, collapse = "; ")
[10:29:54.556]                             if (!has_future) {
[10:29:54.556]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:54.556]                                 info)
[10:29:54.556]                             }
[10:29:54.556]                             else {
[10:29:54.556]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:54.556]                                 info, version)
[10:29:54.556]                             }
[10:29:54.556]                             base::stop(msg)
[10:29:54.556]                           }
[10:29:54.556]                         })
[10:29:54.556]                       }
[10:29:54.556]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:54.556]                       base::options(mc.cores = 1L)
[10:29:54.556]                     }
[10:29:54.556]                     base::local({
[10:29:54.556]                       for (pkg in "stats") {
[10:29:54.556]                         base::loadNamespace(pkg)
[10:29:54.556]                         base::library(pkg, character.only = TRUE)
[10:29:54.556]                       }
[10:29:54.556]                     })
[10:29:54.556]                   }
[10:29:54.556]                   ...future.strategy.old <- future::plan("list")
[10:29:54.556]                   options(future.plan = NULL)
[10:29:54.556]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.556]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:54.556]                 }
[10:29:54.556]                 ...future.workdir <- getwd()
[10:29:54.556]             }
[10:29:54.556]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:54.556]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:54.556]         }
[10:29:54.556]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:54.556]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:54.556]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:54.556]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:54.556]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:54.556]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:54.556]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:54.556]             base::names(...future.oldOptions))
[10:29:54.556]     }
[10:29:54.556]     if (FALSE) {
[10:29:54.556]     }
[10:29:54.556]     else {
[10:29:54.556]         if (TRUE) {
[10:29:54.556]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:54.556]                 open = "w")
[10:29:54.556]         }
[10:29:54.556]         else {
[10:29:54.556]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:54.556]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:54.556]         }
[10:29:54.556]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:54.556]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:54.556]             base::sink(type = "output", split = FALSE)
[10:29:54.556]             base::close(...future.stdout)
[10:29:54.556]         }, add = TRUE)
[10:29:54.556]     }
[10:29:54.556]     ...future.frame <- base::sys.nframe()
[10:29:54.556]     ...future.conditions <- base::list()
[10:29:54.556]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:54.556]     if (FALSE) {
[10:29:54.556]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:54.556]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:54.556]     }
[10:29:54.556]     ...future.result <- base::tryCatch({
[10:29:54.556]         base::withCallingHandlers({
[10:29:54.556]             ...future.value <- base::withVisible(base::local({
[10:29:54.556]                 withCallingHandlers({
[10:29:54.556]                   {
[10:29:54.556]                     do.call(function(...) {
[10:29:54.556]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.556]                       if (!identical(...future.globals.maxSize.org, 
[10:29:54.556]                         ...future.globals.maxSize)) {
[10:29:54.556]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.556]                         on.exit(options(oopts), add = TRUE)
[10:29:54.556]                       }
[10:29:54.556]                       {
[10:29:54.556]                         lapply(seq_along(...future.elements_ii), 
[10:29:54.556]                           FUN = function(jj) {
[10:29:54.556]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.556]                             ...future.FUN(...future.X_jj, ...)
[10:29:54.556]                           })
[10:29:54.556]                       }
[10:29:54.556]                     }, args = future.call.arguments)
[10:29:54.556]                   }
[10:29:54.556]                 }, immediateCondition = function(cond) {
[10:29:54.556]                   save_rds <- function (object, pathname, ...) 
[10:29:54.556]                   {
[10:29:54.556]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:54.556]                     if (file_test("-f", pathname_tmp)) {
[10:29:54.556]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.556]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:54.556]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.556]                         fi_tmp[["mtime"]])
[10:29:54.556]                     }
[10:29:54.556]                     tryCatch({
[10:29:54.556]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:54.556]                     }, error = function(ex) {
[10:29:54.556]                       msg <- conditionMessage(ex)
[10:29:54.556]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.556]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:54.556]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.556]                         fi_tmp[["mtime"]], msg)
[10:29:54.556]                       ex$message <- msg
[10:29:54.556]                       stop(ex)
[10:29:54.556]                     })
[10:29:54.556]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:54.556]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:54.556]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:54.556]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.556]                       fi <- file.info(pathname)
[10:29:54.556]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:54.556]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.556]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:54.556]                         fi[["size"]], fi[["mtime"]])
[10:29:54.556]                       stop(msg)
[10:29:54.556]                     }
[10:29:54.556]                     invisible(pathname)
[10:29:54.556]                   }
[10:29:54.556]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:54.556]                     rootPath = tempdir()) 
[10:29:54.556]                   {
[10:29:54.556]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:54.556]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:54.556]                       tmpdir = path, fileext = ".rds")
[10:29:54.556]                     save_rds(obj, file)
[10:29:54.556]                   }
[10:29:54.556]                   saveImmediateCondition(cond, path = "/tmp/Rtmp11FQBX/.future/immediateConditions")
[10:29:54.556]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.556]                   {
[10:29:54.556]                     inherits <- base::inherits
[10:29:54.556]                     invokeRestart <- base::invokeRestart
[10:29:54.556]                     is.null <- base::is.null
[10:29:54.556]                     muffled <- FALSE
[10:29:54.556]                     if (inherits(cond, "message")) {
[10:29:54.556]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:54.556]                       if (muffled) 
[10:29:54.556]                         invokeRestart("muffleMessage")
[10:29:54.556]                     }
[10:29:54.556]                     else if (inherits(cond, "warning")) {
[10:29:54.556]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:54.556]                       if (muffled) 
[10:29:54.556]                         invokeRestart("muffleWarning")
[10:29:54.556]                     }
[10:29:54.556]                     else if (inherits(cond, "condition")) {
[10:29:54.556]                       if (!is.null(pattern)) {
[10:29:54.556]                         computeRestarts <- base::computeRestarts
[10:29:54.556]                         grepl <- base::grepl
[10:29:54.556]                         restarts <- computeRestarts(cond)
[10:29:54.556]                         for (restart in restarts) {
[10:29:54.556]                           name <- restart$name
[10:29:54.556]                           if (is.null(name)) 
[10:29:54.556]                             next
[10:29:54.556]                           if (!grepl(pattern, name)) 
[10:29:54.556]                             next
[10:29:54.556]                           invokeRestart(restart)
[10:29:54.556]                           muffled <- TRUE
[10:29:54.556]                           break
[10:29:54.556]                         }
[10:29:54.556]                       }
[10:29:54.556]                     }
[10:29:54.556]                     invisible(muffled)
[10:29:54.556]                   }
[10:29:54.556]                   muffleCondition(cond)
[10:29:54.556]                 })
[10:29:54.556]             }))
[10:29:54.556]             future::FutureResult(value = ...future.value$value, 
[10:29:54.556]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.556]                   ...future.rng), globalenv = if (FALSE) 
[10:29:54.556]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:54.556]                     ...future.globalenv.names))
[10:29:54.556]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:54.556]         }, condition = base::local({
[10:29:54.556]             c <- base::c
[10:29:54.556]             inherits <- base::inherits
[10:29:54.556]             invokeRestart <- base::invokeRestart
[10:29:54.556]             length <- base::length
[10:29:54.556]             list <- base::list
[10:29:54.556]             seq.int <- base::seq.int
[10:29:54.556]             signalCondition <- base::signalCondition
[10:29:54.556]             sys.calls <- base::sys.calls
[10:29:54.556]             `[[` <- base::`[[`
[10:29:54.556]             `+` <- base::`+`
[10:29:54.556]             `<<-` <- base::`<<-`
[10:29:54.556]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:54.556]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:54.556]                   3L)]
[10:29:54.556]             }
[10:29:54.556]             function(cond) {
[10:29:54.556]                 is_error <- inherits(cond, "error")
[10:29:54.556]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:54.556]                   NULL)
[10:29:54.556]                 if (is_error) {
[10:29:54.556]                   sessionInformation <- function() {
[10:29:54.556]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:54.556]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:54.556]                       search = base::search(), system = base::Sys.info())
[10:29:54.556]                   }
[10:29:54.556]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.556]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:54.556]                     cond$call), session = sessionInformation(), 
[10:29:54.556]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:54.556]                   signalCondition(cond)
[10:29:54.556]                 }
[10:29:54.556]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:54.556]                 "immediateCondition"))) {
[10:29:54.556]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:54.556]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.556]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:54.556]                   if (TRUE && !signal) {
[10:29:54.556]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.556]                     {
[10:29:54.556]                       inherits <- base::inherits
[10:29:54.556]                       invokeRestart <- base::invokeRestart
[10:29:54.556]                       is.null <- base::is.null
[10:29:54.556]                       muffled <- FALSE
[10:29:54.556]                       if (inherits(cond, "message")) {
[10:29:54.556]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.556]                         if (muffled) 
[10:29:54.556]                           invokeRestart("muffleMessage")
[10:29:54.556]                       }
[10:29:54.556]                       else if (inherits(cond, "warning")) {
[10:29:54.556]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.556]                         if (muffled) 
[10:29:54.556]                           invokeRestart("muffleWarning")
[10:29:54.556]                       }
[10:29:54.556]                       else if (inherits(cond, "condition")) {
[10:29:54.556]                         if (!is.null(pattern)) {
[10:29:54.556]                           computeRestarts <- base::computeRestarts
[10:29:54.556]                           grepl <- base::grepl
[10:29:54.556]                           restarts <- computeRestarts(cond)
[10:29:54.556]                           for (restart in restarts) {
[10:29:54.556]                             name <- restart$name
[10:29:54.556]                             if (is.null(name)) 
[10:29:54.556]                               next
[10:29:54.556]                             if (!grepl(pattern, name)) 
[10:29:54.556]                               next
[10:29:54.556]                             invokeRestart(restart)
[10:29:54.556]                             muffled <- TRUE
[10:29:54.556]                             break
[10:29:54.556]                           }
[10:29:54.556]                         }
[10:29:54.556]                       }
[10:29:54.556]                       invisible(muffled)
[10:29:54.556]                     }
[10:29:54.556]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.556]                   }
[10:29:54.556]                 }
[10:29:54.556]                 else {
[10:29:54.556]                   if (TRUE) {
[10:29:54.556]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.556]                     {
[10:29:54.556]                       inherits <- base::inherits
[10:29:54.556]                       invokeRestart <- base::invokeRestart
[10:29:54.556]                       is.null <- base::is.null
[10:29:54.556]                       muffled <- FALSE
[10:29:54.556]                       if (inherits(cond, "message")) {
[10:29:54.556]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.556]                         if (muffled) 
[10:29:54.556]                           invokeRestart("muffleMessage")
[10:29:54.556]                       }
[10:29:54.556]                       else if (inherits(cond, "warning")) {
[10:29:54.556]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.556]                         if (muffled) 
[10:29:54.556]                           invokeRestart("muffleWarning")
[10:29:54.556]                       }
[10:29:54.556]                       else if (inherits(cond, "condition")) {
[10:29:54.556]                         if (!is.null(pattern)) {
[10:29:54.556]                           computeRestarts <- base::computeRestarts
[10:29:54.556]                           grepl <- base::grepl
[10:29:54.556]                           restarts <- computeRestarts(cond)
[10:29:54.556]                           for (restart in restarts) {
[10:29:54.556]                             name <- restart$name
[10:29:54.556]                             if (is.null(name)) 
[10:29:54.556]                               next
[10:29:54.556]                             if (!grepl(pattern, name)) 
[10:29:54.556]                               next
[10:29:54.556]                             invokeRestart(restart)
[10:29:54.556]                             muffled <- TRUE
[10:29:54.556]                             break
[10:29:54.556]                           }
[10:29:54.556]                         }
[10:29:54.556]                       }
[10:29:54.556]                       invisible(muffled)
[10:29:54.556]                     }
[10:29:54.556]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.556]                   }
[10:29:54.556]                 }
[10:29:54.556]             }
[10:29:54.556]         }))
[10:29:54.556]     }, error = function(ex) {
[10:29:54.556]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:54.556]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.556]                 ...future.rng), started = ...future.startTime, 
[10:29:54.556]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:54.556]             version = "1.8"), class = "FutureResult")
[10:29:54.556]     }, finally = {
[10:29:54.556]         if (!identical(...future.workdir, getwd())) 
[10:29:54.556]             setwd(...future.workdir)
[10:29:54.556]         {
[10:29:54.556]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:54.556]                 ...future.oldOptions$nwarnings <- NULL
[10:29:54.556]             }
[10:29:54.556]             base::options(...future.oldOptions)
[10:29:54.556]             if (.Platform$OS.type == "windows") {
[10:29:54.556]                 old_names <- names(...future.oldEnvVars)
[10:29:54.556]                 envs <- base::Sys.getenv()
[10:29:54.556]                 names <- names(envs)
[10:29:54.556]                 common <- intersect(names, old_names)
[10:29:54.556]                 added <- setdiff(names, old_names)
[10:29:54.556]                 removed <- setdiff(old_names, names)
[10:29:54.556]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:54.556]                   envs[common]]
[10:29:54.556]                 NAMES <- toupper(changed)
[10:29:54.556]                 args <- list()
[10:29:54.556]                 for (kk in seq_along(NAMES)) {
[10:29:54.556]                   name <- changed[[kk]]
[10:29:54.556]                   NAME <- NAMES[[kk]]
[10:29:54.556]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.556]                     next
[10:29:54.556]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.556]                 }
[10:29:54.556]                 NAMES <- toupper(added)
[10:29:54.556]                 for (kk in seq_along(NAMES)) {
[10:29:54.556]                   name <- added[[kk]]
[10:29:54.556]                   NAME <- NAMES[[kk]]
[10:29:54.556]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.556]                     next
[10:29:54.556]                   args[[name]] <- ""
[10:29:54.556]                 }
[10:29:54.556]                 NAMES <- toupper(removed)
[10:29:54.556]                 for (kk in seq_along(NAMES)) {
[10:29:54.556]                   name <- removed[[kk]]
[10:29:54.556]                   NAME <- NAMES[[kk]]
[10:29:54.556]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.556]                     next
[10:29:54.556]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.556]                 }
[10:29:54.556]                 if (length(args) > 0) 
[10:29:54.556]                   base::do.call(base::Sys.setenv, args = args)
[10:29:54.556]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:54.556]             }
[10:29:54.556]             else {
[10:29:54.556]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:54.556]             }
[10:29:54.556]             {
[10:29:54.556]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:54.556]                   0L) {
[10:29:54.556]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:54.556]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:54.556]                   base::options(opts)
[10:29:54.556]                 }
[10:29:54.556]                 {
[10:29:54.556]                   {
[10:29:54.556]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:54.556]                     NULL
[10:29:54.556]                   }
[10:29:54.556]                   options(future.plan = NULL)
[10:29:54.556]                   if (is.na(NA_character_)) 
[10:29:54.556]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.556]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:54.556]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:54.556]                     .init = FALSE)
[10:29:54.556]                 }
[10:29:54.556]             }
[10:29:54.556]         }
[10:29:54.556]     })
[10:29:54.556]     if (TRUE) {
[10:29:54.556]         base::sink(type = "output", split = FALSE)
[10:29:54.556]         if (TRUE) {
[10:29:54.556]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:54.556]         }
[10:29:54.556]         else {
[10:29:54.556]             ...future.result["stdout"] <- base::list(NULL)
[10:29:54.556]         }
[10:29:54.556]         base::close(...future.stdout)
[10:29:54.556]         ...future.stdout <- NULL
[10:29:54.556]     }
[10:29:54.556]     ...future.result$conditions <- ...future.conditions
[10:29:54.556]     ...future.result$finished <- base::Sys.time()
[10:29:54.556]     ...future.result
[10:29:54.556] }
[10:29:54.560] assign_globals() ...
[10:29:54.560] List of 5
[10:29:54.560]  $ ...future.FUN            :function (x, ...)  
[10:29:54.560]  $ future.call.arguments    :List of 1
[10:29:54.560]   ..$ singular.ok: logi FALSE
[10:29:54.560]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.560]  $ ...future.elements_ii    :List of 2
[10:29:54.560]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:54.560]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:29:54.560]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:54.560]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:29:54.560]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:54.560]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:29:54.560]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:54.560]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:29:54.560]  $ ...future.seeds_ii       : NULL
[10:29:54.560]  $ ...future.globals.maxSize: NULL
[10:29:54.560]  - attr(*, "where")=List of 5
[10:29:54.560]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:54.560]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:54.560]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:54.560]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:54.560]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:54.560]  - attr(*, "resolved")= logi FALSE
[10:29:54.560]  - attr(*, "total_size")= num 5384
[10:29:54.560]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.560]  - attr(*, "already-done")= logi TRUE
[10:29:54.572] - reassign environment for ‘...future.FUN’
[10:29:54.573] - copied ‘...future.FUN’ to environment
[10:29:54.573] - copied ‘future.call.arguments’ to environment
[10:29:54.573] - copied ‘...future.elements_ii’ to environment
[10:29:54.573] - copied ‘...future.seeds_ii’ to environment
[10:29:54.573] - copied ‘...future.globals.maxSize’ to environment
[10:29:54.573] assign_globals() ... done
[10:29:54.573] requestCore(): workers = 2
[10:29:54.576] MulticoreFuture started
[10:29:54.576] - Launch lazy future ... done
[10:29:54.576] run() for ‘MulticoreFuture’ ... done
[10:29:54.577] Created future:
[10:29:54.577] plan(): Setting new future strategy stack:
[10:29:54.578] List of future strategies:
[10:29:54.578] 1. sequential:
[10:29:54.578]    - args: function (..., envir = parent.frame())
[10:29:54.578]    - tweaked: FALSE
[10:29:54.578]    - call: NULL
[10:29:54.579] plan(): nbrOfWorkers() = 1
[10:29:54.584] plan(): Setting new future strategy stack:
[10:29:54.584] List of future strategies:
[10:29:54.584] 1. multicore:
[10:29:54.584]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:54.584]    - tweaked: FALSE
[10:29:54.584]    - call: plan(strategy)
[10:29:54.589] plan(): nbrOfWorkers() = 2
[10:29:54.577] MulticoreFuture:
[10:29:54.577] Label: ‘future_by-2’
[10:29:54.577] Expression:
[10:29:54.577] {
[10:29:54.577]     do.call(function(...) {
[10:29:54.577]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.577]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.577]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.577]             on.exit(options(oopts), add = TRUE)
[10:29:54.577]         }
[10:29:54.577]         {
[10:29:54.577]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.577]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.577]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.577]             })
[10:29:54.577]         }
[10:29:54.577]     }, args = future.call.arguments)
[10:29:54.577] }
[10:29:54.577] Lazy evaluation: FALSE
[10:29:54.577] Asynchronous evaluation: TRUE
[10:29:54.577] Local evaluation: TRUE
[10:29:54.577] Environment: R_GlobalEnv
[10:29:54.577] Capture standard output: TRUE
[10:29:54.577] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:54.577] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:54.577] Packages: 1 packages (‘stats’)
[10:29:54.577] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:54.577] Resolved: FALSE
[10:29:54.577] Value: <not collected>
[10:29:54.577] Conditions captured: <none>
[10:29:54.577] Early signaling: FALSE
[10:29:54.577] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:54.577] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:54.590] Chunk #2 of 2 ... DONE
[10:29:54.590] Launching 2 futures (chunks) ... DONE
[10:29:54.590] Resolving 2 futures (chunks) ...
[10:29:54.591] resolve() on list ...
[10:29:54.591]  recursive: 0
[10:29:54.591]  length: 2
[10:29:54.591] 
[10:29:54.591] Future #1
[10:29:54.592] result() for MulticoreFuture ...
[10:29:54.593] result() for MulticoreFuture ...
[10:29:54.593] result() for MulticoreFuture ... done
[10:29:54.594] result() for MulticoreFuture ... done
[10:29:54.594] result() for MulticoreFuture ...
[10:29:54.594] result() for MulticoreFuture ... done
[10:29:54.594] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:29:54.594] - nx: 2
[10:29:54.594] - relay: TRUE
[10:29:54.595] - stdout: TRUE
[10:29:54.595] - signal: TRUE
[10:29:54.595] - resignal: FALSE
[10:29:54.595] - force: TRUE
[10:29:54.595] - relayed: [n=2] FALSE, FALSE
[10:29:54.595] - queued futures: [n=2] FALSE, FALSE
[10:29:54.596]  - until=1
[10:29:54.596]  - relaying element #1
[10:29:54.596] result() for MulticoreFuture ...
[10:29:54.596] result() for MulticoreFuture ... done
[10:29:54.596] result() for MulticoreFuture ...
[10:29:54.596] result() for MulticoreFuture ... done
[10:29:54.597] result() for MulticoreFuture ...
[10:29:54.597] result() for MulticoreFuture ... done
[10:29:54.597] result() for MulticoreFuture ...
[10:29:54.597] result() for MulticoreFuture ... done
[10:29:54.598] - relayed: [n=2] TRUE, FALSE
[10:29:54.601] - queued futures: [n=2] TRUE, FALSE
[10:29:54.601] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:29:54.602]  length: 1 (resolved future 1)
[10:29:54.602] Future #2
[10:29:54.602] result() for MulticoreFuture ...
[10:29:54.605] result() for MulticoreFuture ...
[10:29:54.605] result() for MulticoreFuture ... done
[10:29:54.605] result() for MulticoreFuture ... done
[10:29:54.605] result() for MulticoreFuture ...
[10:29:54.606] result() for MulticoreFuture ... done
[10:29:54.606] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:29:54.606] - nx: 2
[10:29:54.606] - relay: TRUE
[10:29:54.606] - stdout: TRUE
[10:29:54.607] - signal: TRUE
[10:29:54.607] - resignal: FALSE
[10:29:54.607] - force: TRUE
[10:29:54.607] - relayed: [n=2] TRUE, FALSE
[10:29:54.607] - queued futures: [n=2] TRUE, FALSE
[10:29:54.607]  - until=2
[10:29:54.607]  - relaying element #2
[10:29:54.608] result() for MulticoreFuture ...
[10:29:54.608] result() for MulticoreFuture ... done
[10:29:54.608] result() for MulticoreFuture ...
[10:29:54.608] result() for MulticoreFuture ... done
[10:29:54.608] result() for MulticoreFuture ...
[10:29:54.609] result() for MulticoreFuture ... done
[10:29:54.609] result() for MulticoreFuture ...
[10:29:54.609] result() for MulticoreFuture ... done
[10:29:54.609] - relayed: [n=2] TRUE, TRUE
[10:29:54.609] - queued futures: [n=2] TRUE, TRUE
[10:29:54.609] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:29:54.609]  length: 0 (resolved future 2)
[10:29:54.610] Relaying remaining futures
[10:29:54.610] signalConditionsASAP(NULL, pos=0) ...
[10:29:54.610] - nx: 2
[10:29:54.610] - relay: TRUE
[10:29:54.610] - stdout: TRUE
[10:29:54.610] - signal: TRUE
[10:29:54.610] - resignal: FALSE
[10:29:54.611] - force: TRUE
[10:29:54.611] - relayed: [n=2] TRUE, TRUE
[10:29:54.611] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:54.611] - relayed: [n=2] TRUE, TRUE
[10:29:54.611] - queued futures: [n=2] TRUE, TRUE
[10:29:54.611] signalConditionsASAP(NULL, pos=0) ... done
[10:29:54.611] resolve() on list ... DONE
[10:29:54.612] result() for MulticoreFuture ...
[10:29:54.612] result() for MulticoreFuture ... done
[10:29:54.612] result() for MulticoreFuture ...
[10:29:54.612] result() for MulticoreFuture ... done
[10:29:54.612] result() for MulticoreFuture ...
[10:29:54.612] result() for MulticoreFuture ... done
[10:29:54.613] result() for MulticoreFuture ...
[10:29:54.613] result() for MulticoreFuture ... done
[10:29:54.613]  - Number of value chunks collected: 2
[10:29:54.613] Resolving 2 futures (chunks) ... DONE
[10:29:54.613] Reducing values from 2 chunks ...
[10:29:54.613]  - Number of values collected after concatenation: 3
[10:29:54.613]  - Number of values expected: 3
[10:29:54.613] Reducing values from 2 chunks ... DONE
[10:29:54.613] future_lapply() ... DONE
[10:29:54.614] future_by_internal() ... DONE
[10:29:54.618] future_by_internal() ...
[10:29:54.619] future_lapply() ...
[10:29:54.624] Number of chunks: 2
[10:29:54.624] getGlobalsAndPackagesXApply() ...
[10:29:54.624]  - future.globals: TRUE
[10:29:54.624] getGlobalsAndPackages() ...
[10:29:54.624] Searching for globals...
[10:29:54.628] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:29:54.629] Searching for globals ... DONE
[10:29:54.629] Resolving globals: FALSE
[10:29:54.629] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[10:29:54.630] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[10:29:54.630] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[10:29:54.630] - packages: [1] ‘stats’
[10:29:54.630] getGlobalsAndPackages() ... DONE
[10:29:54.630]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[10:29:54.630]  - needed namespaces: [n=1] ‘stats’
[10:29:54.631] Finding globals ... DONE
[10:29:54.631]  - use_args: TRUE
[10:29:54.631]  - Getting '...' globals ...
[10:29:54.631] resolve() on list ...
[10:29:54.631]  recursive: 0
[10:29:54.631]  length: 1
[10:29:54.632]  elements: ‘...’
[10:29:54.632]  length: 0 (resolved future 1)
[10:29:54.632] resolve() on list ... DONE
[10:29:54.632]    - '...' content: [n=0] 
[10:29:54.632] List of 1
[10:29:54.632]  $ ...: list()
[10:29:54.632]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.632]  - attr(*, "where")=List of 1
[10:29:54.632]   ..$ ...:<environment: 0x556dd4d3b0d8> 
[10:29:54.632]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.632]  - attr(*, "resolved")= logi TRUE
[10:29:54.632]  - attr(*, "total_size")= num NA
[10:29:54.635]  - Getting '...' globals ... DONE
[10:29:54.636] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[10:29:54.636] List of 4
[10:29:54.636]  $ ...future.FUN:function (x)  
[10:29:54.636]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:29:54.636]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:54.636]  $ ...          : list()
[10:29:54.636]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.636]  - attr(*, "where")=List of 4
[10:29:54.636]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:54.636]   ..$ breaks       :<environment: R_EmptyEnv> 
[10:29:54.636]   ..$ wool         :<environment: R_EmptyEnv> 
[10:29:54.636]   ..$ ...          :<environment: 0x556dd4d3b0d8> 
[10:29:54.636]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.636]  - attr(*, "resolved")= logi FALSE
[10:29:54.636]  - attr(*, "total_size")= num 2320
[10:29:54.640] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:54.640] getGlobalsAndPackagesXApply() ... DONE
[10:29:54.640] Number of futures (= number of chunks): 2
[10:29:54.640] Launching 2 futures (chunks) ...
[10:29:54.640] Chunk #1 of 2 ...
[10:29:54.640]  - Finding globals in 'X' for chunk #1 ...
[10:29:54.640] getGlobalsAndPackages() ...
[10:29:54.641] Searching for globals...
[10:29:54.641] 
[10:29:54.641] Searching for globals ... DONE
[10:29:54.641] - globals: [0] <none>
[10:29:54.641] getGlobalsAndPackages() ... DONE
[10:29:54.641]    + additional globals found: [n=0] 
[10:29:54.641]    + additional namespaces needed: [n=0] 
[10:29:54.642]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:54.642]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:54.642]  - seeds: <none>
[10:29:54.642]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.642] getGlobalsAndPackages() ...
[10:29:54.642] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.642] Resolving globals: FALSE
[10:29:54.642] Tweak future expression to call with '...' arguments ...
[10:29:54.642] {
[10:29:54.642]     do.call(function(...) {
[10:29:54.642]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.642]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.642]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.642]             on.exit(options(oopts), add = TRUE)
[10:29:54.642]         }
[10:29:54.642]         {
[10:29:54.642]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.642]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.642]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.642]             })
[10:29:54.642]         }
[10:29:54.642]     }, args = future.call.arguments)
[10:29:54.642] }
[10:29:54.643] Tweak future expression to call with '...' arguments ... DONE
[10:29:54.643] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.643] 
[10:29:54.643] getGlobalsAndPackages() ... DONE
[10:29:54.644] run() for ‘Future’ ...
[10:29:54.644] - state: ‘created’
[10:29:54.644] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:54.649] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:54.649] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:54.649]   - Field: ‘label’
[10:29:54.649]   - Field: ‘local’
[10:29:54.649]   - Field: ‘owner’
[10:29:54.649]   - Field: ‘envir’
[10:29:54.649]   - Field: ‘workers’
[10:29:54.649]   - Field: ‘packages’
[10:29:54.650]   - Field: ‘gc’
[10:29:54.650]   - Field: ‘job’
[10:29:54.650]   - Field: ‘conditions’
[10:29:54.650]   - Field: ‘expr’
[10:29:54.650]   - Field: ‘uuid’
[10:29:54.650]   - Field: ‘seed’
[10:29:54.650]   - Field: ‘version’
[10:29:54.652]   - Field: ‘result’
[10:29:54.653]   - Field: ‘asynchronous’
[10:29:54.653]   - Field: ‘calls’
[10:29:54.653]   - Field: ‘globals’
[10:29:54.653]   - Field: ‘stdout’
[10:29:54.653]   - Field: ‘earlySignal’
[10:29:54.653]   - Field: ‘lazy’
[10:29:54.653]   - Field: ‘state’
[10:29:54.653] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:54.654] - Launch lazy future ...
[10:29:54.654] Packages needed by the future expression (n = 1): ‘stats’
[10:29:54.654] Packages needed by future strategies (n = 0): <none>
[10:29:54.655] {
[10:29:54.655]     {
[10:29:54.655]         {
[10:29:54.655]             ...future.startTime <- base::Sys.time()
[10:29:54.655]             {
[10:29:54.655]                 {
[10:29:54.655]                   {
[10:29:54.655]                     {
[10:29:54.655]                       {
[10:29:54.655]                         base::local({
[10:29:54.655]                           has_future <- base::requireNamespace("future", 
[10:29:54.655]                             quietly = TRUE)
[10:29:54.655]                           if (has_future) {
[10:29:54.655]                             ns <- base::getNamespace("future")
[10:29:54.655]                             version <- ns[[".package"]][["version"]]
[10:29:54.655]                             if (is.null(version)) 
[10:29:54.655]                               version <- utils::packageVersion("future")
[10:29:54.655]                           }
[10:29:54.655]                           else {
[10:29:54.655]                             version <- NULL
[10:29:54.655]                           }
[10:29:54.655]                           if (!has_future || version < "1.8.0") {
[10:29:54.655]                             info <- base::c(r_version = base::gsub("R version ", 
[10:29:54.655]                               "", base::R.version$version.string), 
[10:29:54.655]                               platform = base::sprintf("%s (%s-bit)", 
[10:29:54.655]                                 base::R.version$platform, 8 * 
[10:29:54.655]                                   base::.Machine$sizeof.pointer), 
[10:29:54.655]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:54.655]                                 "release", "version")], collapse = " "), 
[10:29:54.655]                               hostname = base::Sys.info()[["nodename"]])
[10:29:54.655]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:29:54.655]                               info)
[10:29:54.655]                             info <- base::paste(info, collapse = "; ")
[10:29:54.655]                             if (!has_future) {
[10:29:54.655]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:54.655]                                 info)
[10:29:54.655]                             }
[10:29:54.655]                             else {
[10:29:54.655]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:54.655]                                 info, version)
[10:29:54.655]                             }
[10:29:54.655]                             base::stop(msg)
[10:29:54.655]                           }
[10:29:54.655]                         })
[10:29:54.655]                       }
[10:29:54.655]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:54.655]                       base::options(mc.cores = 1L)
[10:29:54.655]                     }
[10:29:54.655]                     base::local({
[10:29:54.655]                       for (pkg in "stats") {
[10:29:54.655]                         base::loadNamespace(pkg)
[10:29:54.655]                         base::library(pkg, character.only = TRUE)
[10:29:54.655]                       }
[10:29:54.655]                     })
[10:29:54.655]                   }
[10:29:54.655]                   ...future.strategy.old <- future::plan("list")
[10:29:54.655]                   options(future.plan = NULL)
[10:29:54.655]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.655]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:54.655]                 }
[10:29:54.655]                 ...future.workdir <- getwd()
[10:29:54.655]             }
[10:29:54.655]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:54.655]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:54.655]         }
[10:29:54.655]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:54.655]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:54.655]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:54.655]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:54.655]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:54.655]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:54.655]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:54.655]             base::names(...future.oldOptions))
[10:29:54.655]     }
[10:29:54.655]     if (FALSE) {
[10:29:54.655]     }
[10:29:54.655]     else {
[10:29:54.655]         if (TRUE) {
[10:29:54.655]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:54.655]                 open = "w")
[10:29:54.655]         }
[10:29:54.655]         else {
[10:29:54.655]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:54.655]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:54.655]         }
[10:29:54.655]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:54.655]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:54.655]             base::sink(type = "output", split = FALSE)
[10:29:54.655]             base::close(...future.stdout)
[10:29:54.655]         }, add = TRUE)
[10:29:54.655]     }
[10:29:54.655]     ...future.frame <- base::sys.nframe()
[10:29:54.655]     ...future.conditions <- base::list()
[10:29:54.655]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:54.655]     if (FALSE) {
[10:29:54.655]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:54.655]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:54.655]     }
[10:29:54.655]     ...future.result <- base::tryCatch({
[10:29:54.655]         base::withCallingHandlers({
[10:29:54.655]             ...future.value <- base::withVisible(base::local({
[10:29:54.655]                 withCallingHandlers({
[10:29:54.655]                   {
[10:29:54.655]                     do.call(function(...) {
[10:29:54.655]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.655]                       if (!identical(...future.globals.maxSize.org, 
[10:29:54.655]                         ...future.globals.maxSize)) {
[10:29:54.655]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.655]                         on.exit(options(oopts), add = TRUE)
[10:29:54.655]                       }
[10:29:54.655]                       {
[10:29:54.655]                         lapply(seq_along(...future.elements_ii), 
[10:29:54.655]                           FUN = function(jj) {
[10:29:54.655]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.655]                             ...future.FUN(...future.X_jj, ...)
[10:29:54.655]                           })
[10:29:54.655]                       }
[10:29:54.655]                     }, args = future.call.arguments)
[10:29:54.655]                   }
[10:29:54.655]                 }, immediateCondition = function(cond) {
[10:29:54.655]                   save_rds <- function (object, pathname, ...) 
[10:29:54.655]                   {
[10:29:54.655]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:54.655]                     if (file_test("-f", pathname_tmp)) {
[10:29:54.655]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.655]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:54.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.655]                         fi_tmp[["mtime"]])
[10:29:54.655]                     }
[10:29:54.655]                     tryCatch({
[10:29:54.655]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:54.655]                     }, error = function(ex) {
[10:29:54.655]                       msg <- conditionMessage(ex)
[10:29:54.655]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.655]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:54.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.655]                         fi_tmp[["mtime"]], msg)
[10:29:54.655]                       ex$message <- msg
[10:29:54.655]                       stop(ex)
[10:29:54.655]                     })
[10:29:54.655]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:54.655]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:54.655]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:54.655]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.655]                       fi <- file.info(pathname)
[10:29:54.655]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:54.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.655]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:54.655]                         fi[["size"]], fi[["mtime"]])
[10:29:54.655]                       stop(msg)
[10:29:54.655]                     }
[10:29:54.655]                     invisible(pathname)
[10:29:54.655]                   }
[10:29:54.655]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:54.655]                     rootPath = tempdir()) 
[10:29:54.655]                   {
[10:29:54.655]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:54.655]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:54.655]                       tmpdir = path, fileext = ".rds")
[10:29:54.655]                     save_rds(obj, file)
[10:29:54.655]                   }
[10:29:54.655]                   saveImmediateCondition(cond, path = "/tmp/Rtmp11FQBX/.future/immediateConditions")
[10:29:54.655]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.655]                   {
[10:29:54.655]                     inherits <- base::inherits
[10:29:54.655]                     invokeRestart <- base::invokeRestart
[10:29:54.655]                     is.null <- base::is.null
[10:29:54.655]                     muffled <- FALSE
[10:29:54.655]                     if (inherits(cond, "message")) {
[10:29:54.655]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:54.655]                       if (muffled) 
[10:29:54.655]                         invokeRestart("muffleMessage")
[10:29:54.655]                     }
[10:29:54.655]                     else if (inherits(cond, "warning")) {
[10:29:54.655]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:54.655]                       if (muffled) 
[10:29:54.655]                         invokeRestart("muffleWarning")
[10:29:54.655]                     }
[10:29:54.655]                     else if (inherits(cond, "condition")) {
[10:29:54.655]                       if (!is.null(pattern)) {
[10:29:54.655]                         computeRestarts <- base::computeRestarts
[10:29:54.655]                         grepl <- base::grepl
[10:29:54.655]                         restarts <- computeRestarts(cond)
[10:29:54.655]                         for (restart in restarts) {
[10:29:54.655]                           name <- restart$name
[10:29:54.655]                           if (is.null(name)) 
[10:29:54.655]                             next
[10:29:54.655]                           if (!grepl(pattern, name)) 
[10:29:54.655]                             next
[10:29:54.655]                           invokeRestart(restart)
[10:29:54.655]                           muffled <- TRUE
[10:29:54.655]                           break
[10:29:54.655]                         }
[10:29:54.655]                       }
[10:29:54.655]                     }
[10:29:54.655]                     invisible(muffled)
[10:29:54.655]                   }
[10:29:54.655]                   muffleCondition(cond)
[10:29:54.655]                 })
[10:29:54.655]             }))
[10:29:54.655]             future::FutureResult(value = ...future.value$value, 
[10:29:54.655]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.655]                   ...future.rng), globalenv = if (FALSE) 
[10:29:54.655]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:54.655]                     ...future.globalenv.names))
[10:29:54.655]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:54.655]         }, condition = base::local({
[10:29:54.655]             c <- base::c
[10:29:54.655]             inherits <- base::inherits
[10:29:54.655]             invokeRestart <- base::invokeRestart
[10:29:54.655]             length <- base::length
[10:29:54.655]             list <- base::list
[10:29:54.655]             seq.int <- base::seq.int
[10:29:54.655]             signalCondition <- base::signalCondition
[10:29:54.655]             sys.calls <- base::sys.calls
[10:29:54.655]             `[[` <- base::`[[`
[10:29:54.655]             `+` <- base::`+`
[10:29:54.655]             `<<-` <- base::`<<-`
[10:29:54.655]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:54.655]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:54.655]                   3L)]
[10:29:54.655]             }
[10:29:54.655]             function(cond) {
[10:29:54.655]                 is_error <- inherits(cond, "error")
[10:29:54.655]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:54.655]                   NULL)
[10:29:54.655]                 if (is_error) {
[10:29:54.655]                   sessionInformation <- function() {
[10:29:54.655]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:54.655]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:54.655]                       search = base::search(), system = base::Sys.info())
[10:29:54.655]                   }
[10:29:54.655]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.655]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:54.655]                     cond$call), session = sessionInformation(), 
[10:29:54.655]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:54.655]                   signalCondition(cond)
[10:29:54.655]                 }
[10:29:54.655]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:54.655]                 "immediateCondition"))) {
[10:29:54.655]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:54.655]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.655]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:54.655]                   if (TRUE && !signal) {
[10:29:54.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.655]                     {
[10:29:54.655]                       inherits <- base::inherits
[10:29:54.655]                       invokeRestart <- base::invokeRestart
[10:29:54.655]                       is.null <- base::is.null
[10:29:54.655]                       muffled <- FALSE
[10:29:54.655]                       if (inherits(cond, "message")) {
[10:29:54.655]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.655]                         if (muffled) 
[10:29:54.655]                           invokeRestart("muffleMessage")
[10:29:54.655]                       }
[10:29:54.655]                       else if (inherits(cond, "warning")) {
[10:29:54.655]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.655]                         if (muffled) 
[10:29:54.655]                           invokeRestart("muffleWarning")
[10:29:54.655]                       }
[10:29:54.655]                       else if (inherits(cond, "condition")) {
[10:29:54.655]                         if (!is.null(pattern)) {
[10:29:54.655]                           computeRestarts <- base::computeRestarts
[10:29:54.655]                           grepl <- base::grepl
[10:29:54.655]                           restarts <- computeRestarts(cond)
[10:29:54.655]                           for (restart in restarts) {
[10:29:54.655]                             name <- restart$name
[10:29:54.655]                             if (is.null(name)) 
[10:29:54.655]                               next
[10:29:54.655]                             if (!grepl(pattern, name)) 
[10:29:54.655]                               next
[10:29:54.655]                             invokeRestart(restart)
[10:29:54.655]                             muffled <- TRUE
[10:29:54.655]                             break
[10:29:54.655]                           }
[10:29:54.655]                         }
[10:29:54.655]                       }
[10:29:54.655]                       invisible(muffled)
[10:29:54.655]                     }
[10:29:54.655]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.655]                   }
[10:29:54.655]                 }
[10:29:54.655]                 else {
[10:29:54.655]                   if (TRUE) {
[10:29:54.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.655]                     {
[10:29:54.655]                       inherits <- base::inherits
[10:29:54.655]                       invokeRestart <- base::invokeRestart
[10:29:54.655]                       is.null <- base::is.null
[10:29:54.655]                       muffled <- FALSE
[10:29:54.655]                       if (inherits(cond, "message")) {
[10:29:54.655]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.655]                         if (muffled) 
[10:29:54.655]                           invokeRestart("muffleMessage")
[10:29:54.655]                       }
[10:29:54.655]                       else if (inherits(cond, "warning")) {
[10:29:54.655]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.655]                         if (muffled) 
[10:29:54.655]                           invokeRestart("muffleWarning")
[10:29:54.655]                       }
[10:29:54.655]                       else if (inherits(cond, "condition")) {
[10:29:54.655]                         if (!is.null(pattern)) {
[10:29:54.655]                           computeRestarts <- base::computeRestarts
[10:29:54.655]                           grepl <- base::grepl
[10:29:54.655]                           restarts <- computeRestarts(cond)
[10:29:54.655]                           for (restart in restarts) {
[10:29:54.655]                             name <- restart$name
[10:29:54.655]                             if (is.null(name)) 
[10:29:54.655]                               next
[10:29:54.655]                             if (!grepl(pattern, name)) 
[10:29:54.655]                               next
[10:29:54.655]                             invokeRestart(restart)
[10:29:54.655]                             muffled <- TRUE
[10:29:54.655]                             break
[10:29:54.655]                           }
[10:29:54.655]                         }
[10:29:54.655]                       }
[10:29:54.655]                       invisible(muffled)
[10:29:54.655]                     }
[10:29:54.655]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.655]                   }
[10:29:54.655]                 }
[10:29:54.655]             }
[10:29:54.655]         }))
[10:29:54.655]     }, error = function(ex) {
[10:29:54.655]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:54.655]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.655]                 ...future.rng), started = ...future.startTime, 
[10:29:54.655]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:54.655]             version = "1.8"), class = "FutureResult")
[10:29:54.655]     }, finally = {
[10:29:54.655]         if (!identical(...future.workdir, getwd())) 
[10:29:54.655]             setwd(...future.workdir)
[10:29:54.655]         {
[10:29:54.655]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:54.655]                 ...future.oldOptions$nwarnings <- NULL
[10:29:54.655]             }
[10:29:54.655]             base::options(...future.oldOptions)
[10:29:54.655]             if (.Platform$OS.type == "windows") {
[10:29:54.655]                 old_names <- names(...future.oldEnvVars)
[10:29:54.655]                 envs <- base::Sys.getenv()
[10:29:54.655]                 names <- names(envs)
[10:29:54.655]                 common <- intersect(names, old_names)
[10:29:54.655]                 added <- setdiff(names, old_names)
[10:29:54.655]                 removed <- setdiff(old_names, names)
[10:29:54.655]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:54.655]                   envs[common]]
[10:29:54.655]                 NAMES <- toupper(changed)
[10:29:54.655]                 args <- list()
[10:29:54.655]                 for (kk in seq_along(NAMES)) {
[10:29:54.655]                   name <- changed[[kk]]
[10:29:54.655]                   NAME <- NAMES[[kk]]
[10:29:54.655]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.655]                     next
[10:29:54.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.655]                 }
[10:29:54.655]                 NAMES <- toupper(added)
[10:29:54.655]                 for (kk in seq_along(NAMES)) {
[10:29:54.655]                   name <- added[[kk]]
[10:29:54.655]                   NAME <- NAMES[[kk]]
[10:29:54.655]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.655]                     next
[10:29:54.655]                   args[[name]] <- ""
[10:29:54.655]                 }
[10:29:54.655]                 NAMES <- toupper(removed)
[10:29:54.655]                 for (kk in seq_along(NAMES)) {
[10:29:54.655]                   name <- removed[[kk]]
[10:29:54.655]                   NAME <- NAMES[[kk]]
[10:29:54.655]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.655]                     next
[10:29:54.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.655]                 }
[10:29:54.655]                 if (length(args) > 0) 
[10:29:54.655]                   base::do.call(base::Sys.setenv, args = args)
[10:29:54.655]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:54.655]             }
[10:29:54.655]             else {
[10:29:54.655]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:54.655]             }
[10:29:54.655]             {
[10:29:54.655]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:54.655]                   0L) {
[10:29:54.655]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:54.655]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:54.655]                   base::options(opts)
[10:29:54.655]                 }
[10:29:54.655]                 {
[10:29:54.655]                   {
[10:29:54.655]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:54.655]                     NULL
[10:29:54.655]                   }
[10:29:54.655]                   options(future.plan = NULL)
[10:29:54.655]                   if (is.na(NA_character_)) 
[10:29:54.655]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.655]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:54.655]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:54.655]                     .init = FALSE)
[10:29:54.655]                 }
[10:29:54.655]             }
[10:29:54.655]         }
[10:29:54.655]     })
[10:29:54.655]     if (TRUE) {
[10:29:54.655]         base::sink(type = "output", split = FALSE)
[10:29:54.655]         if (TRUE) {
[10:29:54.655]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:54.655]         }
[10:29:54.655]         else {
[10:29:54.655]             ...future.result["stdout"] <- base::list(NULL)
[10:29:54.655]         }
[10:29:54.655]         base::close(...future.stdout)
[10:29:54.655]         ...future.stdout <- NULL
[10:29:54.655]     }
[10:29:54.655]     ...future.result$conditions <- ...future.conditions
[10:29:54.655]     ...future.result$finished <- base::Sys.time()
[10:29:54.655]     ...future.result
[10:29:54.655] }
[10:29:54.657] assign_globals() ...
[10:29:54.658] List of 7
[10:29:54.658]  $ ...future.FUN            :function (x)  
[10:29:54.658]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:29:54.658]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:54.658]  $ future.call.arguments    : list()
[10:29:54.658]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.658]  $ ...future.elements_ii    :List of 1
[10:29:54.658]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:54.658]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:29:54.658]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:54.658]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:54.658]  $ ...future.seeds_ii       : NULL
[10:29:54.658]  $ ...future.globals.maxSize: NULL
[10:29:54.658]  - attr(*, "where")=List of 7
[10:29:54.658]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:54.658]   ..$ breaks                   :<environment: R_EmptyEnv> 
[10:29:54.658]   ..$ wool                     :<environment: R_EmptyEnv> 
[10:29:54.658]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:54.658]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:54.658]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:54.658]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:54.658]  - attr(*, "resolved")= logi FALSE
[10:29:54.658]  - attr(*, "total_size")= num 2320
[10:29:54.658]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.658]  - attr(*, "already-done")= logi TRUE
[10:29:54.666] - reassign environment for ‘...future.FUN’
[10:29:54.666] - copied ‘...future.FUN’ to environment
[10:29:54.666] - copied ‘breaks’ to environment
[10:29:54.666] - copied ‘wool’ to environment
[10:29:54.666] - copied ‘future.call.arguments’ to environment
[10:29:54.667] - copied ‘...future.elements_ii’ to environment
[10:29:54.667] - copied ‘...future.seeds_ii’ to environment
[10:29:54.667] - copied ‘...future.globals.maxSize’ to environment
[10:29:54.667] assign_globals() ... done
[10:29:54.667] requestCore(): workers = 2
[10:29:54.669] MulticoreFuture started
[10:29:54.670] - Launch lazy future ... done
[10:29:54.670] run() for ‘MulticoreFuture’ ... done
[10:29:54.670] Created future:
[10:29:54.671] plan(): Setting new future strategy stack:
[10:29:54.671] List of future strategies:
[10:29:54.671] 1. sequential:
[10:29:54.671]    - args: function (..., envir = parent.frame())
[10:29:54.671]    - tweaked: FALSE
[10:29:54.671]    - call: NULL
[10:29:54.672] plan(): nbrOfWorkers() = 1
[10:29:54.676] plan(): Setting new future strategy stack:
[10:29:54.676] List of future strategies:
[10:29:54.676] 1. multicore:
[10:29:54.676]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:54.676]    - tweaked: FALSE
[10:29:54.676]    - call: plan(strategy)
[10:29:54.682] plan(): nbrOfWorkers() = 2
[10:29:54.671] MulticoreFuture:
[10:29:54.671] Label: ‘future_by-1’
[10:29:54.671] Expression:
[10:29:54.671] {
[10:29:54.671]     do.call(function(...) {
[10:29:54.671]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.671]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.671]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.671]             on.exit(options(oopts), add = TRUE)
[10:29:54.671]         }
[10:29:54.671]         {
[10:29:54.671]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.671]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.671]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.671]             })
[10:29:54.671]         }
[10:29:54.671]     }, args = future.call.arguments)
[10:29:54.671] }
[10:29:54.671] Lazy evaluation: FALSE
[10:29:54.671] Asynchronous evaluation: TRUE
[10:29:54.671] Local evaluation: TRUE
[10:29:54.671] Environment: 0x556dd48e3ba0
[10:29:54.671] Capture standard output: TRUE
[10:29:54.671] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:54.671] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[10:29:54.671] Packages: 1 packages (‘stats’)
[10:29:54.671] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:54.671] Resolved: TRUE
[10:29:54.671] Value: <not collected>
[10:29:54.671] Conditions captured: <none>
[10:29:54.671] Early signaling: FALSE
[10:29:54.671] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:54.671] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:54.684] Chunk #1 of 2 ... DONE
[10:29:54.684] Chunk #2 of 2 ...
[10:29:54.684]  - Finding globals in 'X' for chunk #2 ...
[10:29:54.684] getGlobalsAndPackages() ...
[10:29:54.684] Searching for globals...
[10:29:54.685] 
[10:29:54.685] Searching for globals ... DONE
[10:29:54.685] - globals: [0] <none>
[10:29:54.685] getGlobalsAndPackages() ... DONE
[10:29:54.686]    + additional globals found: [n=0] 
[10:29:54.686]    + additional namespaces needed: [n=0] 
[10:29:54.686]  - Finding globals in 'X' for chunk #2 ... DONE
[10:29:54.686]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:54.686]  - seeds: <none>
[10:29:54.686]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.686] getGlobalsAndPackages() ...
[10:29:54.686] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.687] Resolving globals: FALSE
[10:29:54.687] Tweak future expression to call with '...' arguments ...
[10:29:54.687] {
[10:29:54.687]     do.call(function(...) {
[10:29:54.687]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.687]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.687]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.687]             on.exit(options(oopts), add = TRUE)
[10:29:54.687]         }
[10:29:54.687]         {
[10:29:54.687]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.687]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.687]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.687]             })
[10:29:54.687]         }
[10:29:54.687]     }, args = future.call.arguments)
[10:29:54.687] }
[10:29:54.687] Tweak future expression to call with '...' arguments ... DONE
[10:29:54.688] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.688] 
[10:29:54.688] getGlobalsAndPackages() ... DONE
[10:29:54.689] run() for ‘Future’ ...
[10:29:54.689] - state: ‘created’
[10:29:54.689] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:54.698] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:54.698] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:54.699]   - Field: ‘label’
[10:29:54.699]   - Field: ‘local’
[10:29:54.699]   - Field: ‘owner’
[10:29:54.699]   - Field: ‘envir’
[10:29:54.700]   - Field: ‘workers’
[10:29:54.700]   - Field: ‘packages’
[10:29:54.700]   - Field: ‘gc’
[10:29:54.700]   - Field: ‘job’
[10:29:54.701]   - Field: ‘conditions’
[10:29:54.701]   - Field: ‘expr’
[10:29:54.701]   - Field: ‘uuid’
[10:29:54.702]   - Field: ‘seed’
[10:29:54.702]   - Field: ‘version’
[10:29:54.702]   - Field: ‘result’
[10:29:54.702]   - Field: ‘asynchronous’
[10:29:54.702]   - Field: ‘calls’
[10:29:54.703]   - Field: ‘globals’
[10:29:54.703]   - Field: ‘stdout’
[10:29:54.703]   - Field: ‘earlySignal’
[10:29:54.703]   - Field: ‘lazy’
[10:29:54.703]   - Field: ‘state’
[10:29:54.704] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:54.704] - Launch lazy future ...
[10:29:54.705] Packages needed by the future expression (n = 1): ‘stats’
[10:29:54.705] Packages needed by future strategies (n = 0): <none>
[10:29:54.706] {
[10:29:54.706]     {
[10:29:54.706]         {
[10:29:54.706]             ...future.startTime <- base::Sys.time()
[10:29:54.706]             {
[10:29:54.706]                 {
[10:29:54.706]                   {
[10:29:54.706]                     {
[10:29:54.706]                       {
[10:29:54.706]                         base::local({
[10:29:54.706]                           has_future <- base::requireNamespace("future", 
[10:29:54.706]                             quietly = TRUE)
[10:29:54.706]                           if (has_future) {
[10:29:54.706]                             ns <- base::getNamespace("future")
[10:29:54.706]                             version <- ns[[".package"]][["version"]]
[10:29:54.706]                             if (is.null(version)) 
[10:29:54.706]                               version <- utils::packageVersion("future")
[10:29:54.706]                           }
[10:29:54.706]                           else {
[10:29:54.706]                             version <- NULL
[10:29:54.706]                           }
[10:29:54.706]                           if (!has_future || version < "1.8.0") {
[10:29:54.706]                             info <- base::c(r_version = base::gsub("R version ", 
[10:29:54.706]                               "", base::R.version$version.string), 
[10:29:54.706]                               platform = base::sprintf("%s (%s-bit)", 
[10:29:54.706]                                 base::R.version$platform, 8 * 
[10:29:54.706]                                   base::.Machine$sizeof.pointer), 
[10:29:54.706]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:54.706]                                 "release", "version")], collapse = " "), 
[10:29:54.706]                               hostname = base::Sys.info()[["nodename"]])
[10:29:54.706]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:29:54.706]                               info)
[10:29:54.706]                             info <- base::paste(info, collapse = "; ")
[10:29:54.706]                             if (!has_future) {
[10:29:54.706]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:54.706]                                 info)
[10:29:54.706]                             }
[10:29:54.706]                             else {
[10:29:54.706]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:54.706]                                 info, version)
[10:29:54.706]                             }
[10:29:54.706]                             base::stop(msg)
[10:29:54.706]                           }
[10:29:54.706]                         })
[10:29:54.706]                       }
[10:29:54.706]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:54.706]                       base::options(mc.cores = 1L)
[10:29:54.706]                     }
[10:29:54.706]                     base::local({
[10:29:54.706]                       for (pkg in "stats") {
[10:29:54.706]                         base::loadNamespace(pkg)
[10:29:54.706]                         base::library(pkg, character.only = TRUE)
[10:29:54.706]                       }
[10:29:54.706]                     })
[10:29:54.706]                   }
[10:29:54.706]                   ...future.strategy.old <- future::plan("list")
[10:29:54.706]                   options(future.plan = NULL)
[10:29:54.706]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.706]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:54.706]                 }
[10:29:54.706]                 ...future.workdir <- getwd()
[10:29:54.706]             }
[10:29:54.706]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:54.706]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:54.706]         }
[10:29:54.706]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:54.706]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:54.706]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:54.706]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:54.706]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:54.706]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:54.706]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:54.706]             base::names(...future.oldOptions))
[10:29:54.706]     }
[10:29:54.706]     if (FALSE) {
[10:29:54.706]     }
[10:29:54.706]     else {
[10:29:54.706]         if (TRUE) {
[10:29:54.706]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:54.706]                 open = "w")
[10:29:54.706]         }
[10:29:54.706]         else {
[10:29:54.706]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:54.706]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:54.706]         }
[10:29:54.706]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:54.706]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:54.706]             base::sink(type = "output", split = FALSE)
[10:29:54.706]             base::close(...future.stdout)
[10:29:54.706]         }, add = TRUE)
[10:29:54.706]     }
[10:29:54.706]     ...future.frame <- base::sys.nframe()
[10:29:54.706]     ...future.conditions <- base::list()
[10:29:54.706]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:54.706]     if (FALSE) {
[10:29:54.706]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:54.706]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:54.706]     }
[10:29:54.706]     ...future.result <- base::tryCatch({
[10:29:54.706]         base::withCallingHandlers({
[10:29:54.706]             ...future.value <- base::withVisible(base::local({
[10:29:54.706]                 withCallingHandlers({
[10:29:54.706]                   {
[10:29:54.706]                     do.call(function(...) {
[10:29:54.706]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.706]                       if (!identical(...future.globals.maxSize.org, 
[10:29:54.706]                         ...future.globals.maxSize)) {
[10:29:54.706]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.706]                         on.exit(options(oopts), add = TRUE)
[10:29:54.706]                       }
[10:29:54.706]                       {
[10:29:54.706]                         lapply(seq_along(...future.elements_ii), 
[10:29:54.706]                           FUN = function(jj) {
[10:29:54.706]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.706]                             ...future.FUN(...future.X_jj, ...)
[10:29:54.706]                           })
[10:29:54.706]                       }
[10:29:54.706]                     }, args = future.call.arguments)
[10:29:54.706]                   }
[10:29:54.706]                 }, immediateCondition = function(cond) {
[10:29:54.706]                   save_rds <- function (object, pathname, ...) 
[10:29:54.706]                   {
[10:29:54.706]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:54.706]                     if (file_test("-f", pathname_tmp)) {
[10:29:54.706]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.706]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:54.706]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.706]                         fi_tmp[["mtime"]])
[10:29:54.706]                     }
[10:29:54.706]                     tryCatch({
[10:29:54.706]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:54.706]                     }, error = function(ex) {
[10:29:54.706]                       msg <- conditionMessage(ex)
[10:29:54.706]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.706]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:54.706]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.706]                         fi_tmp[["mtime"]], msg)
[10:29:54.706]                       ex$message <- msg
[10:29:54.706]                       stop(ex)
[10:29:54.706]                     })
[10:29:54.706]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:54.706]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:54.706]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:54.706]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.706]                       fi <- file.info(pathname)
[10:29:54.706]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:54.706]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.706]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:54.706]                         fi[["size"]], fi[["mtime"]])
[10:29:54.706]                       stop(msg)
[10:29:54.706]                     }
[10:29:54.706]                     invisible(pathname)
[10:29:54.706]                   }
[10:29:54.706]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:54.706]                     rootPath = tempdir()) 
[10:29:54.706]                   {
[10:29:54.706]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:54.706]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:54.706]                       tmpdir = path, fileext = ".rds")
[10:29:54.706]                     save_rds(obj, file)
[10:29:54.706]                   }
[10:29:54.706]                   saveImmediateCondition(cond, path = "/tmp/Rtmp11FQBX/.future/immediateConditions")
[10:29:54.706]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.706]                   {
[10:29:54.706]                     inherits <- base::inherits
[10:29:54.706]                     invokeRestart <- base::invokeRestart
[10:29:54.706]                     is.null <- base::is.null
[10:29:54.706]                     muffled <- FALSE
[10:29:54.706]                     if (inherits(cond, "message")) {
[10:29:54.706]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:54.706]                       if (muffled) 
[10:29:54.706]                         invokeRestart("muffleMessage")
[10:29:54.706]                     }
[10:29:54.706]                     else if (inherits(cond, "warning")) {
[10:29:54.706]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:54.706]                       if (muffled) 
[10:29:54.706]                         invokeRestart("muffleWarning")
[10:29:54.706]                     }
[10:29:54.706]                     else if (inherits(cond, "condition")) {
[10:29:54.706]                       if (!is.null(pattern)) {
[10:29:54.706]                         computeRestarts <- base::computeRestarts
[10:29:54.706]                         grepl <- base::grepl
[10:29:54.706]                         restarts <- computeRestarts(cond)
[10:29:54.706]                         for (restart in restarts) {
[10:29:54.706]                           name <- restart$name
[10:29:54.706]                           if (is.null(name)) 
[10:29:54.706]                             next
[10:29:54.706]                           if (!grepl(pattern, name)) 
[10:29:54.706]                             next
[10:29:54.706]                           invokeRestart(restart)
[10:29:54.706]                           muffled <- TRUE
[10:29:54.706]                           break
[10:29:54.706]                         }
[10:29:54.706]                       }
[10:29:54.706]                     }
[10:29:54.706]                     invisible(muffled)
[10:29:54.706]                   }
[10:29:54.706]                   muffleCondition(cond)
[10:29:54.706]                 })
[10:29:54.706]             }))
[10:29:54.706]             future::FutureResult(value = ...future.value$value, 
[10:29:54.706]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.706]                   ...future.rng), globalenv = if (FALSE) 
[10:29:54.706]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:54.706]                     ...future.globalenv.names))
[10:29:54.706]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:54.706]         }, condition = base::local({
[10:29:54.706]             c <- base::c
[10:29:54.706]             inherits <- base::inherits
[10:29:54.706]             invokeRestart <- base::invokeRestart
[10:29:54.706]             length <- base::length
[10:29:54.706]             list <- base::list
[10:29:54.706]             seq.int <- base::seq.int
[10:29:54.706]             signalCondition <- base::signalCondition
[10:29:54.706]             sys.calls <- base::sys.calls
[10:29:54.706]             `[[` <- base::`[[`
[10:29:54.706]             `+` <- base::`+`
[10:29:54.706]             `<<-` <- base::`<<-`
[10:29:54.706]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:54.706]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:54.706]                   3L)]
[10:29:54.706]             }
[10:29:54.706]             function(cond) {
[10:29:54.706]                 is_error <- inherits(cond, "error")
[10:29:54.706]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:54.706]                   NULL)
[10:29:54.706]                 if (is_error) {
[10:29:54.706]                   sessionInformation <- function() {
[10:29:54.706]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:54.706]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:54.706]                       search = base::search(), system = base::Sys.info())
[10:29:54.706]                   }
[10:29:54.706]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.706]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:54.706]                     cond$call), session = sessionInformation(), 
[10:29:54.706]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:54.706]                   signalCondition(cond)
[10:29:54.706]                 }
[10:29:54.706]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:54.706]                 "immediateCondition"))) {
[10:29:54.706]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:54.706]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.706]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:54.706]                   if (TRUE && !signal) {
[10:29:54.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.706]                     {
[10:29:54.706]                       inherits <- base::inherits
[10:29:54.706]                       invokeRestart <- base::invokeRestart
[10:29:54.706]                       is.null <- base::is.null
[10:29:54.706]                       muffled <- FALSE
[10:29:54.706]                       if (inherits(cond, "message")) {
[10:29:54.706]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.706]                         if (muffled) 
[10:29:54.706]                           invokeRestart("muffleMessage")
[10:29:54.706]                       }
[10:29:54.706]                       else if (inherits(cond, "warning")) {
[10:29:54.706]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.706]                         if (muffled) 
[10:29:54.706]                           invokeRestart("muffleWarning")
[10:29:54.706]                       }
[10:29:54.706]                       else if (inherits(cond, "condition")) {
[10:29:54.706]                         if (!is.null(pattern)) {
[10:29:54.706]                           computeRestarts <- base::computeRestarts
[10:29:54.706]                           grepl <- base::grepl
[10:29:54.706]                           restarts <- computeRestarts(cond)
[10:29:54.706]                           for (restart in restarts) {
[10:29:54.706]                             name <- restart$name
[10:29:54.706]                             if (is.null(name)) 
[10:29:54.706]                               next
[10:29:54.706]                             if (!grepl(pattern, name)) 
[10:29:54.706]                               next
[10:29:54.706]                             invokeRestart(restart)
[10:29:54.706]                             muffled <- TRUE
[10:29:54.706]                             break
[10:29:54.706]                           }
[10:29:54.706]                         }
[10:29:54.706]                       }
[10:29:54.706]                       invisible(muffled)
[10:29:54.706]                     }
[10:29:54.706]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.706]                   }
[10:29:54.706]                 }
[10:29:54.706]                 else {
[10:29:54.706]                   if (TRUE) {
[10:29:54.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.706]                     {
[10:29:54.706]                       inherits <- base::inherits
[10:29:54.706]                       invokeRestart <- base::invokeRestart
[10:29:54.706]                       is.null <- base::is.null
[10:29:54.706]                       muffled <- FALSE
[10:29:54.706]                       if (inherits(cond, "message")) {
[10:29:54.706]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.706]                         if (muffled) 
[10:29:54.706]                           invokeRestart("muffleMessage")
[10:29:54.706]                       }
[10:29:54.706]                       else if (inherits(cond, "warning")) {
[10:29:54.706]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.706]                         if (muffled) 
[10:29:54.706]                           invokeRestart("muffleWarning")
[10:29:54.706]                       }
[10:29:54.706]                       else if (inherits(cond, "condition")) {
[10:29:54.706]                         if (!is.null(pattern)) {
[10:29:54.706]                           computeRestarts <- base::computeRestarts
[10:29:54.706]                           grepl <- base::grepl
[10:29:54.706]                           restarts <- computeRestarts(cond)
[10:29:54.706]                           for (restart in restarts) {
[10:29:54.706]                             name <- restart$name
[10:29:54.706]                             if (is.null(name)) 
[10:29:54.706]                               next
[10:29:54.706]                             if (!grepl(pattern, name)) 
[10:29:54.706]                               next
[10:29:54.706]                             invokeRestart(restart)
[10:29:54.706]                             muffled <- TRUE
[10:29:54.706]                             break
[10:29:54.706]                           }
[10:29:54.706]                         }
[10:29:54.706]                       }
[10:29:54.706]                       invisible(muffled)
[10:29:54.706]                     }
[10:29:54.706]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.706]                   }
[10:29:54.706]                 }
[10:29:54.706]             }
[10:29:54.706]         }))
[10:29:54.706]     }, error = function(ex) {
[10:29:54.706]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:54.706]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.706]                 ...future.rng), started = ...future.startTime, 
[10:29:54.706]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:54.706]             version = "1.8"), class = "FutureResult")
[10:29:54.706]     }, finally = {
[10:29:54.706]         if (!identical(...future.workdir, getwd())) 
[10:29:54.706]             setwd(...future.workdir)
[10:29:54.706]         {
[10:29:54.706]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:54.706]                 ...future.oldOptions$nwarnings <- NULL
[10:29:54.706]             }
[10:29:54.706]             base::options(...future.oldOptions)
[10:29:54.706]             if (.Platform$OS.type == "windows") {
[10:29:54.706]                 old_names <- names(...future.oldEnvVars)
[10:29:54.706]                 envs <- base::Sys.getenv()
[10:29:54.706]                 names <- names(envs)
[10:29:54.706]                 common <- intersect(names, old_names)
[10:29:54.706]                 added <- setdiff(names, old_names)
[10:29:54.706]                 removed <- setdiff(old_names, names)
[10:29:54.706]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:54.706]                   envs[common]]
[10:29:54.706]                 NAMES <- toupper(changed)
[10:29:54.706]                 args <- list()
[10:29:54.706]                 for (kk in seq_along(NAMES)) {
[10:29:54.706]                   name <- changed[[kk]]
[10:29:54.706]                   NAME <- NAMES[[kk]]
[10:29:54.706]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.706]                     next
[10:29:54.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.706]                 }
[10:29:54.706]                 NAMES <- toupper(added)
[10:29:54.706]                 for (kk in seq_along(NAMES)) {
[10:29:54.706]                   name <- added[[kk]]
[10:29:54.706]                   NAME <- NAMES[[kk]]
[10:29:54.706]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.706]                     next
[10:29:54.706]                   args[[name]] <- ""
[10:29:54.706]                 }
[10:29:54.706]                 NAMES <- toupper(removed)
[10:29:54.706]                 for (kk in seq_along(NAMES)) {
[10:29:54.706]                   name <- removed[[kk]]
[10:29:54.706]                   NAME <- NAMES[[kk]]
[10:29:54.706]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.706]                     next
[10:29:54.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.706]                 }
[10:29:54.706]                 if (length(args) > 0) 
[10:29:54.706]                   base::do.call(base::Sys.setenv, args = args)
[10:29:54.706]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:54.706]             }
[10:29:54.706]             else {
[10:29:54.706]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:54.706]             }
[10:29:54.706]             {
[10:29:54.706]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:54.706]                   0L) {
[10:29:54.706]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:54.706]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:54.706]                   base::options(opts)
[10:29:54.706]                 }
[10:29:54.706]                 {
[10:29:54.706]                   {
[10:29:54.706]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:54.706]                     NULL
[10:29:54.706]                   }
[10:29:54.706]                   options(future.plan = NULL)
[10:29:54.706]                   if (is.na(NA_character_)) 
[10:29:54.706]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.706]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:54.706]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:54.706]                     .init = FALSE)
[10:29:54.706]                 }
[10:29:54.706]             }
[10:29:54.706]         }
[10:29:54.706]     })
[10:29:54.706]     if (TRUE) {
[10:29:54.706]         base::sink(type = "output", split = FALSE)
[10:29:54.706]         if (TRUE) {
[10:29:54.706]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:54.706]         }
[10:29:54.706]         else {
[10:29:54.706]             ...future.result["stdout"] <- base::list(NULL)
[10:29:54.706]         }
[10:29:54.706]         base::close(...future.stdout)
[10:29:54.706]         ...future.stdout <- NULL
[10:29:54.706]     }
[10:29:54.706]     ...future.result$conditions <- ...future.conditions
[10:29:54.706]     ...future.result$finished <- base::Sys.time()
[10:29:54.706]     ...future.result
[10:29:54.706] }
[10:29:54.709] assign_globals() ...
[10:29:54.709] List of 7
[10:29:54.709]  $ ...future.FUN            :function (x)  
[10:29:54.709]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:29:54.709]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:54.709]  $ future.call.arguments    : list()
[10:29:54.709]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.709]  $ ...future.elements_ii    :List of 2
[10:29:54.709]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:54.709]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:29:54.709]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:54.709]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:29:54.709]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:54.709]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:29:54.709]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:54.709]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:29:54.709]  $ ...future.seeds_ii       : NULL
[10:29:54.709]  $ ...future.globals.maxSize: NULL
[10:29:54.709]  - attr(*, "where")=List of 7
[10:29:54.709]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:54.709]   ..$ breaks                   :<environment: R_EmptyEnv> 
[10:29:54.709]   ..$ wool                     :<environment: R_EmptyEnv> 
[10:29:54.709]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:54.709]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:54.709]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:54.709]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:54.709]  - attr(*, "resolved")= logi FALSE
[10:29:54.709]  - attr(*, "total_size")= num 2320
[10:29:54.709]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.709]  - attr(*, "already-done")= logi TRUE
[10:29:54.722] - reassign environment for ‘...future.FUN’
[10:29:54.722] - copied ‘...future.FUN’ to environment
[10:29:54.722] - copied ‘breaks’ to environment
[10:29:54.722] - copied ‘wool’ to environment
[10:29:54.722] - copied ‘future.call.arguments’ to environment
[10:29:54.722] - copied ‘...future.elements_ii’ to environment
[10:29:54.722] - copied ‘...future.seeds_ii’ to environment
[10:29:54.723] - copied ‘...future.globals.maxSize’ to environment
[10:29:54.723] assign_globals() ... done
[10:29:54.723] requestCore(): workers = 2
[10:29:54.725] MulticoreFuture started
[10:29:54.726] - Launch lazy future ... done
[10:29:54.726] run() for ‘MulticoreFuture’ ... done
[10:29:54.727] Created future:
[10:29:54.727] plan(): Setting new future strategy stack:
[10:29:54.728] List of future strategies:
[10:29:54.728] 1. sequential:
[10:29:54.728]    - args: function (..., envir = parent.frame())
[10:29:54.728]    - tweaked: FALSE
[10:29:54.728]    - call: NULL
[10:29:54.729] plan(): nbrOfWorkers() = 1
[10:29:54.727] MulticoreFuture:
[10:29:54.727] Label: ‘future_by-2’
[10:29:54.727] Expression:
[10:29:54.727] {
[10:29:54.727]     do.call(function(...) {
[10:29:54.727]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.727]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.727]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.727]             on.exit(options(oopts), add = TRUE)
[10:29:54.727]         }
[10:29:54.727]         {
[10:29:54.727]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.727]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.727]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.727]             })
[10:29:54.727]         }
[10:29:54.727]     }, args = future.call.arguments)
[10:29:54.727] }
[10:29:54.727] Lazy evaluation: FALSE
[10:29:54.727] Asynchronous evaluation: TRUE
[10:29:54.727] Local evaluation: TRUE
[10:29:54.727] Environment: 0x556dd48e3ba0
[10:29:54.727] Capture standard output: TRUE
[10:29:54.727] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:54.727] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[10:29:54.727] Packages: 1 packages (‘stats’)
[10:29:54.727] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:54.727] Resolved: FALSE
[10:29:54.727] Value: <not collected>
[10:29:54.727] Conditions captured: <none>
[10:29:54.727] Early signaling: FALSE
[10:29:54.727] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:54.727] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:54.742] Chunk #2 of 2 ... DONE
[10:29:54.742] Launching 2 futures (chunks) ... DONE
[10:29:54.742] Resolving 2 futures (chunks) ...
[10:29:54.742] resolve() on list ...
[10:29:54.743]  recursive: 0
[10:29:54.743] plan(): Setting new future strategy stack:
[10:29:54.743] List of future strategies:
[10:29:54.743] 1. multicore:
[10:29:54.743]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:54.743]    - tweaked: FALSE
[10:29:54.743]    - call: plan(strategy)
[10:29:54.749]  length: 2
[10:29:54.749] 
[10:29:54.749] Future #1
[10:29:54.749] result() for MulticoreFuture ...
[10:29:54.750] plan(): nbrOfWorkers() = 2
[10:29:54.751] result() for MulticoreFuture ...
[10:29:54.751] result() for MulticoreFuture ... done
[10:29:54.752] result() for MulticoreFuture ... done
[10:29:54.752] result() for MulticoreFuture ...
[10:29:54.752] result() for MulticoreFuture ... done
[10:29:54.752] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:29:54.752] - nx: 2
[10:29:54.752] - relay: TRUE
[10:29:54.753] - stdout: TRUE
[10:29:54.753] - signal: TRUE
[10:29:54.753] - resignal: FALSE
[10:29:54.753] - force: TRUE
[10:29:54.753] - relayed: [n=2] FALSE, FALSE
[10:29:54.754] - queued futures: [n=2] FALSE, FALSE
[10:29:54.754]  - until=1
[10:29:54.754]  - relaying element #1
[10:29:54.754] result() for MulticoreFuture ...
[10:29:54.754] result() for MulticoreFuture ... done
[10:29:54.755] result() for MulticoreFuture ...
[10:29:54.755] result() for MulticoreFuture ... done
[10:29:54.755] result() for MulticoreFuture ...
[10:29:54.755] result() for MulticoreFuture ... done
[10:29:54.756] result() for MulticoreFuture ...
[10:29:54.756] result() for MulticoreFuture ... done
[10:29:54.756] - relayed: [n=2] TRUE, FALSE
[10:29:54.756] - queued futures: [n=2] TRUE, FALSE
[10:29:54.756] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:29:54.757]  length: 1 (resolved future 1)
[10:29:54.757] Future #2
[10:29:54.757] result() for MulticoreFuture ...
[10:29:54.759] result() for MulticoreFuture ...
[10:29:54.759] result() for MulticoreFuture ... done
[10:29:54.759] result() for MulticoreFuture ... done
[10:29:54.760] result() for MulticoreFuture ...
[10:29:54.760] result() for MulticoreFuture ... done
[10:29:54.760] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:29:54.760] - nx: 2
[10:29:54.760] - relay: TRUE
[10:29:54.761] - stdout: TRUE
[10:29:54.761] - signal: TRUE
[10:29:54.761] - resignal: FALSE
[10:29:54.761] - force: TRUE
[10:29:54.761] - relayed: [n=2] TRUE, FALSE
[10:29:54.761] - queued futures: [n=2] TRUE, FALSE
[10:29:54.761]  - until=2
[10:29:54.762]  - relaying element #2
[10:29:54.762] result() for MulticoreFuture ...
[10:29:54.762] result() for MulticoreFuture ... done
[10:29:54.762] result() for MulticoreFuture ...
[10:29:54.762] result() for MulticoreFuture ... done
[10:29:54.762] result() for MulticoreFuture ...
[10:29:54.762] result() for MulticoreFuture ... done
[10:29:54.762] result() for MulticoreFuture ...
[10:29:54.762] result() for MulticoreFuture ... done
[10:29:54.763] - relayed: [n=2] TRUE, TRUE
[10:29:54.763] - queued futures: [n=2] TRUE, TRUE
[10:29:54.763] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:29:54.763]  length: 0 (resolved future 2)
[10:29:54.763] Relaying remaining futures
[10:29:54.763] signalConditionsASAP(NULL, pos=0) ...
[10:29:54.763] - nx: 2
[10:29:54.763] - relay: TRUE
[10:29:54.763] - stdout: TRUE
[10:29:54.763] - signal: TRUE
[10:29:54.764] - resignal: FALSE
[10:29:54.764] - force: TRUE
[10:29:54.764] - relayed: [n=2] TRUE, TRUE
[10:29:54.764] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:54.764] - relayed: [n=2] TRUE, TRUE
[10:29:54.764] - queued futures: [n=2] TRUE, TRUE
[10:29:54.764] signalConditionsASAP(NULL, pos=0) ... done
[10:29:54.764] resolve() on list ... DONE
[10:29:54.764] result() for MulticoreFuture ...
[10:29:54.765] result() for MulticoreFuture ... done
[10:29:54.765] result() for MulticoreFuture ...
[10:29:54.765] result() for MulticoreFuture ... done
[10:29:54.765] result() for MulticoreFuture ...
[10:29:54.765] result() for MulticoreFuture ... done
[10:29:54.765] result() for MulticoreFuture ...
[10:29:54.765] result() for MulticoreFuture ... done
[10:29:54.765]  - Number of value chunks collected: 2
[10:29:54.766] Resolving 2 futures (chunks) ... DONE
[10:29:54.766] Reducing values from 2 chunks ...
[10:29:54.766]  - Number of values collected after concatenation: 3
[10:29:54.766]  - Number of values expected: 3
[10:29:54.766] Reducing values from 2 chunks ... DONE
[10:29:54.766] future_lapply() ... DONE
[10:29:54.766] future_by_internal() ... DONE
[10:29:54.767] future_by_internal() ...
[10:29:54.767] future_lapply() ...
[10:29:54.772] Number of chunks: 2
[10:29:54.772] getGlobalsAndPackagesXApply() ...
[10:29:54.773]  - future.globals: TRUE
[10:29:54.773] getGlobalsAndPackages() ...
[10:29:54.773] Searching for globals...
[10:29:54.774] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:54.774] Searching for globals ... DONE
[10:29:54.774] Resolving globals: FALSE
[10:29:54.775] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:54.775] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:54.775] - globals: [1] ‘FUN’
[10:29:54.775] 
[10:29:54.775] getGlobalsAndPackages() ... DONE
[10:29:54.776]  - globals found/used: [n=1] ‘FUN’
[10:29:54.776]  - needed namespaces: [n=0] 
[10:29:54.776] Finding globals ... DONE
[10:29:54.776]  - use_args: TRUE
[10:29:54.776]  - Getting '...' globals ...
[10:29:54.776] resolve() on list ...
[10:29:54.776]  recursive: 0
[10:29:54.776]  length: 1
[10:29:54.777]  elements: ‘...’
[10:29:54.777]  length: 0 (resolved future 1)
[10:29:54.777] resolve() on list ... DONE
[10:29:54.777]    - '...' content: [n=0] 
[10:29:54.777] List of 1
[10:29:54.777]  $ ...: list()
[10:29:54.777]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.777]  - attr(*, "where")=List of 1
[10:29:54.777]   ..$ ...:<environment: 0x556dd4508590> 
[10:29:54.777]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.777]  - attr(*, "resolved")= logi TRUE
[10:29:54.777]  - attr(*, "total_size")= num NA
[10:29:54.783]  - Getting '...' globals ... DONE
[10:29:54.783] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:54.783] List of 2
[10:29:54.783]  $ ...future.FUN:function (object, ...)  
[10:29:54.783]  $ ...          : list()
[10:29:54.783]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.783]  - attr(*, "where")=List of 2
[10:29:54.783]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:54.783]   ..$ ...          :<environment: 0x556dd4508590> 
[10:29:54.783]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.783]  - attr(*, "resolved")= logi FALSE
[10:29:54.783]  - attr(*, "total_size")= num 1240
[10:29:54.786] Packages to be attached in all futures: [n=0] 
[10:29:54.786] getGlobalsAndPackagesXApply() ... DONE
[10:29:54.787] Number of futures (= number of chunks): 2
[10:29:54.787] Launching 2 futures (chunks) ...
[10:29:54.787] Chunk #1 of 2 ...
[10:29:54.787]  - Finding globals in 'X' for chunk #1 ...
[10:29:54.787] getGlobalsAndPackages() ...
[10:29:54.787] Searching for globals...
[10:29:54.788] 
[10:29:54.788] Searching for globals ... DONE
[10:29:54.788] - globals: [0] <none>
[10:29:54.788] getGlobalsAndPackages() ... DONE
[10:29:54.788]    + additional globals found: [n=0] 
[10:29:54.788]    + additional namespaces needed: [n=0] 
[10:29:54.788]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:54.788]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:54.788]  - seeds: <none>
[10:29:54.789]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.789] getGlobalsAndPackages() ...
[10:29:54.789] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.789] Resolving globals: FALSE
[10:29:54.789] Tweak future expression to call with '...' arguments ...
[10:29:54.789] {
[10:29:54.789]     do.call(function(...) {
[10:29:54.789]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.789]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.789]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.789]             on.exit(options(oopts), add = TRUE)
[10:29:54.789]         }
[10:29:54.789]         {
[10:29:54.789]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.789]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.789]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.789]             })
[10:29:54.789]         }
[10:29:54.789]     }, args = future.call.arguments)
[10:29:54.789] }
[10:29:54.789] Tweak future expression to call with '...' arguments ... DONE
[10:29:54.790] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.790] 
[10:29:54.790] getGlobalsAndPackages() ... DONE
[10:29:54.790] run() for ‘Future’ ...
[10:29:54.791] - state: ‘created’
[10:29:54.791] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:54.795] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:54.795] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:54.795]   - Field: ‘label’
[10:29:54.795]   - Field: ‘local’
[10:29:54.795]   - Field: ‘owner’
[10:29:54.795]   - Field: ‘envir’
[10:29:54.795]   - Field: ‘workers’
[10:29:54.795]   - Field: ‘packages’
[10:29:54.796]   - Field: ‘gc’
[10:29:54.796]   - Field: ‘job’
[10:29:54.796]   - Field: ‘conditions’
[10:29:54.796]   - Field: ‘expr’
[10:29:54.796]   - Field: ‘uuid’
[10:29:54.796]   - Field: ‘seed’
[10:29:54.796]   - Field: ‘version’
[10:29:54.796]   - Field: ‘result’
[10:29:54.796]   - Field: ‘asynchronous’
[10:29:54.796]   - Field: ‘calls’
[10:29:54.797]   - Field: ‘globals’
[10:29:54.797]   - Field: ‘stdout’
[10:29:54.797]   - Field: ‘earlySignal’
[10:29:54.797]   - Field: ‘lazy’
[10:29:54.797]   - Field: ‘state’
[10:29:54.797] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:54.797] - Launch lazy future ...
[10:29:54.798] Packages needed by the future expression (n = 0): <none>
[10:29:54.798] Packages needed by future strategies (n = 0): <none>
[10:29:54.798] {
[10:29:54.798]     {
[10:29:54.798]         {
[10:29:54.798]             ...future.startTime <- base::Sys.time()
[10:29:54.798]             {
[10:29:54.798]                 {
[10:29:54.798]                   {
[10:29:54.798]                     {
[10:29:54.798]                       base::local({
[10:29:54.798]                         has_future <- base::requireNamespace("future", 
[10:29:54.798]                           quietly = TRUE)
[10:29:54.798]                         if (has_future) {
[10:29:54.798]                           ns <- base::getNamespace("future")
[10:29:54.798]                           version <- ns[[".package"]][["version"]]
[10:29:54.798]                           if (is.null(version)) 
[10:29:54.798]                             version <- utils::packageVersion("future")
[10:29:54.798]                         }
[10:29:54.798]                         else {
[10:29:54.798]                           version <- NULL
[10:29:54.798]                         }
[10:29:54.798]                         if (!has_future || version < "1.8.0") {
[10:29:54.798]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:54.798]                             "", base::R.version$version.string), 
[10:29:54.798]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:54.798]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:54.798]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:54.798]                               "release", "version")], collapse = " "), 
[10:29:54.798]                             hostname = base::Sys.info()[["nodename"]])
[10:29:54.798]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:54.798]                             info)
[10:29:54.798]                           info <- base::paste(info, collapse = "; ")
[10:29:54.798]                           if (!has_future) {
[10:29:54.798]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:54.798]                               info)
[10:29:54.798]                           }
[10:29:54.798]                           else {
[10:29:54.798]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:54.798]                               info, version)
[10:29:54.798]                           }
[10:29:54.798]                           base::stop(msg)
[10:29:54.798]                         }
[10:29:54.798]                       })
[10:29:54.798]                     }
[10:29:54.798]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:54.798]                     base::options(mc.cores = 1L)
[10:29:54.798]                   }
[10:29:54.798]                   ...future.strategy.old <- future::plan("list")
[10:29:54.798]                   options(future.plan = NULL)
[10:29:54.798]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.798]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:54.798]                 }
[10:29:54.798]                 ...future.workdir <- getwd()
[10:29:54.798]             }
[10:29:54.798]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:54.798]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:54.798]         }
[10:29:54.798]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:54.798]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:54.798]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:54.798]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:54.798]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:54.798]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:54.798]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:54.798]             base::names(...future.oldOptions))
[10:29:54.798]     }
[10:29:54.798]     if (FALSE) {
[10:29:54.798]     }
[10:29:54.798]     else {
[10:29:54.798]         if (TRUE) {
[10:29:54.798]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:54.798]                 open = "w")
[10:29:54.798]         }
[10:29:54.798]         else {
[10:29:54.798]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:54.798]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:54.798]         }
[10:29:54.798]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:54.798]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:54.798]             base::sink(type = "output", split = FALSE)
[10:29:54.798]             base::close(...future.stdout)
[10:29:54.798]         }, add = TRUE)
[10:29:54.798]     }
[10:29:54.798]     ...future.frame <- base::sys.nframe()
[10:29:54.798]     ...future.conditions <- base::list()
[10:29:54.798]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:54.798]     if (FALSE) {
[10:29:54.798]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:54.798]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:54.798]     }
[10:29:54.798]     ...future.result <- base::tryCatch({
[10:29:54.798]         base::withCallingHandlers({
[10:29:54.798]             ...future.value <- base::withVisible(base::local({
[10:29:54.798]                 withCallingHandlers({
[10:29:54.798]                   {
[10:29:54.798]                     do.call(function(...) {
[10:29:54.798]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.798]                       if (!identical(...future.globals.maxSize.org, 
[10:29:54.798]                         ...future.globals.maxSize)) {
[10:29:54.798]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.798]                         on.exit(options(oopts), add = TRUE)
[10:29:54.798]                       }
[10:29:54.798]                       {
[10:29:54.798]                         lapply(seq_along(...future.elements_ii), 
[10:29:54.798]                           FUN = function(jj) {
[10:29:54.798]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.798]                             ...future.FUN(...future.X_jj, ...)
[10:29:54.798]                           })
[10:29:54.798]                       }
[10:29:54.798]                     }, args = future.call.arguments)
[10:29:54.798]                   }
[10:29:54.798]                 }, immediateCondition = function(cond) {
[10:29:54.798]                   save_rds <- function (object, pathname, ...) 
[10:29:54.798]                   {
[10:29:54.798]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:54.798]                     if (file_test("-f", pathname_tmp)) {
[10:29:54.798]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.798]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:54.798]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.798]                         fi_tmp[["mtime"]])
[10:29:54.798]                     }
[10:29:54.798]                     tryCatch({
[10:29:54.798]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:54.798]                     }, error = function(ex) {
[10:29:54.798]                       msg <- conditionMessage(ex)
[10:29:54.798]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.798]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:54.798]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.798]                         fi_tmp[["mtime"]], msg)
[10:29:54.798]                       ex$message <- msg
[10:29:54.798]                       stop(ex)
[10:29:54.798]                     })
[10:29:54.798]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:54.798]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:54.798]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:54.798]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.798]                       fi <- file.info(pathname)
[10:29:54.798]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:54.798]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.798]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:54.798]                         fi[["size"]], fi[["mtime"]])
[10:29:54.798]                       stop(msg)
[10:29:54.798]                     }
[10:29:54.798]                     invisible(pathname)
[10:29:54.798]                   }
[10:29:54.798]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:54.798]                     rootPath = tempdir()) 
[10:29:54.798]                   {
[10:29:54.798]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:54.798]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:54.798]                       tmpdir = path, fileext = ".rds")
[10:29:54.798]                     save_rds(obj, file)
[10:29:54.798]                   }
[10:29:54.798]                   saveImmediateCondition(cond, path = "/tmp/Rtmp11FQBX/.future/immediateConditions")
[10:29:54.798]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.798]                   {
[10:29:54.798]                     inherits <- base::inherits
[10:29:54.798]                     invokeRestart <- base::invokeRestart
[10:29:54.798]                     is.null <- base::is.null
[10:29:54.798]                     muffled <- FALSE
[10:29:54.798]                     if (inherits(cond, "message")) {
[10:29:54.798]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:54.798]                       if (muffled) 
[10:29:54.798]                         invokeRestart("muffleMessage")
[10:29:54.798]                     }
[10:29:54.798]                     else if (inherits(cond, "warning")) {
[10:29:54.798]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:54.798]                       if (muffled) 
[10:29:54.798]                         invokeRestart("muffleWarning")
[10:29:54.798]                     }
[10:29:54.798]                     else if (inherits(cond, "condition")) {
[10:29:54.798]                       if (!is.null(pattern)) {
[10:29:54.798]                         computeRestarts <- base::computeRestarts
[10:29:54.798]                         grepl <- base::grepl
[10:29:54.798]                         restarts <- computeRestarts(cond)
[10:29:54.798]                         for (restart in restarts) {
[10:29:54.798]                           name <- restart$name
[10:29:54.798]                           if (is.null(name)) 
[10:29:54.798]                             next
[10:29:54.798]                           if (!grepl(pattern, name)) 
[10:29:54.798]                             next
[10:29:54.798]                           invokeRestart(restart)
[10:29:54.798]                           muffled <- TRUE
[10:29:54.798]                           break
[10:29:54.798]                         }
[10:29:54.798]                       }
[10:29:54.798]                     }
[10:29:54.798]                     invisible(muffled)
[10:29:54.798]                   }
[10:29:54.798]                   muffleCondition(cond)
[10:29:54.798]                 })
[10:29:54.798]             }))
[10:29:54.798]             future::FutureResult(value = ...future.value$value, 
[10:29:54.798]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.798]                   ...future.rng), globalenv = if (FALSE) 
[10:29:54.798]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:54.798]                     ...future.globalenv.names))
[10:29:54.798]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:54.798]         }, condition = base::local({
[10:29:54.798]             c <- base::c
[10:29:54.798]             inherits <- base::inherits
[10:29:54.798]             invokeRestart <- base::invokeRestart
[10:29:54.798]             length <- base::length
[10:29:54.798]             list <- base::list
[10:29:54.798]             seq.int <- base::seq.int
[10:29:54.798]             signalCondition <- base::signalCondition
[10:29:54.798]             sys.calls <- base::sys.calls
[10:29:54.798]             `[[` <- base::`[[`
[10:29:54.798]             `+` <- base::`+`
[10:29:54.798]             `<<-` <- base::`<<-`
[10:29:54.798]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:54.798]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:54.798]                   3L)]
[10:29:54.798]             }
[10:29:54.798]             function(cond) {
[10:29:54.798]                 is_error <- inherits(cond, "error")
[10:29:54.798]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:54.798]                   NULL)
[10:29:54.798]                 if (is_error) {
[10:29:54.798]                   sessionInformation <- function() {
[10:29:54.798]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:54.798]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:54.798]                       search = base::search(), system = base::Sys.info())
[10:29:54.798]                   }
[10:29:54.798]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.798]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:54.798]                     cond$call), session = sessionInformation(), 
[10:29:54.798]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:54.798]                   signalCondition(cond)
[10:29:54.798]                 }
[10:29:54.798]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:54.798]                 "immediateCondition"))) {
[10:29:54.798]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:54.798]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.798]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:54.798]                   if (TRUE && !signal) {
[10:29:54.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.798]                     {
[10:29:54.798]                       inherits <- base::inherits
[10:29:54.798]                       invokeRestart <- base::invokeRestart
[10:29:54.798]                       is.null <- base::is.null
[10:29:54.798]                       muffled <- FALSE
[10:29:54.798]                       if (inherits(cond, "message")) {
[10:29:54.798]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.798]                         if (muffled) 
[10:29:54.798]                           invokeRestart("muffleMessage")
[10:29:54.798]                       }
[10:29:54.798]                       else if (inherits(cond, "warning")) {
[10:29:54.798]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.798]                         if (muffled) 
[10:29:54.798]                           invokeRestart("muffleWarning")
[10:29:54.798]                       }
[10:29:54.798]                       else if (inherits(cond, "condition")) {
[10:29:54.798]                         if (!is.null(pattern)) {
[10:29:54.798]                           computeRestarts <- base::computeRestarts
[10:29:54.798]                           grepl <- base::grepl
[10:29:54.798]                           restarts <- computeRestarts(cond)
[10:29:54.798]                           for (restart in restarts) {
[10:29:54.798]                             name <- restart$name
[10:29:54.798]                             if (is.null(name)) 
[10:29:54.798]                               next
[10:29:54.798]                             if (!grepl(pattern, name)) 
[10:29:54.798]                               next
[10:29:54.798]                             invokeRestart(restart)
[10:29:54.798]                             muffled <- TRUE
[10:29:54.798]                             break
[10:29:54.798]                           }
[10:29:54.798]                         }
[10:29:54.798]                       }
[10:29:54.798]                       invisible(muffled)
[10:29:54.798]                     }
[10:29:54.798]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.798]                   }
[10:29:54.798]                 }
[10:29:54.798]                 else {
[10:29:54.798]                   if (TRUE) {
[10:29:54.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.798]                     {
[10:29:54.798]                       inherits <- base::inherits
[10:29:54.798]                       invokeRestart <- base::invokeRestart
[10:29:54.798]                       is.null <- base::is.null
[10:29:54.798]                       muffled <- FALSE
[10:29:54.798]                       if (inherits(cond, "message")) {
[10:29:54.798]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.798]                         if (muffled) 
[10:29:54.798]                           invokeRestart("muffleMessage")
[10:29:54.798]                       }
[10:29:54.798]                       else if (inherits(cond, "warning")) {
[10:29:54.798]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.798]                         if (muffled) 
[10:29:54.798]                           invokeRestart("muffleWarning")
[10:29:54.798]                       }
[10:29:54.798]                       else if (inherits(cond, "condition")) {
[10:29:54.798]                         if (!is.null(pattern)) {
[10:29:54.798]                           computeRestarts <- base::computeRestarts
[10:29:54.798]                           grepl <- base::grepl
[10:29:54.798]                           restarts <- computeRestarts(cond)
[10:29:54.798]                           for (restart in restarts) {
[10:29:54.798]                             name <- restart$name
[10:29:54.798]                             if (is.null(name)) 
[10:29:54.798]                               next
[10:29:54.798]                             if (!grepl(pattern, name)) 
[10:29:54.798]                               next
[10:29:54.798]                             invokeRestart(restart)
[10:29:54.798]                             muffled <- TRUE
[10:29:54.798]                             break
[10:29:54.798]                           }
[10:29:54.798]                         }
[10:29:54.798]                       }
[10:29:54.798]                       invisible(muffled)
[10:29:54.798]                     }
[10:29:54.798]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.798]                   }
[10:29:54.798]                 }
[10:29:54.798]             }
[10:29:54.798]         }))
[10:29:54.798]     }, error = function(ex) {
[10:29:54.798]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:54.798]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.798]                 ...future.rng), started = ...future.startTime, 
[10:29:54.798]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:54.798]             version = "1.8"), class = "FutureResult")
[10:29:54.798]     }, finally = {
[10:29:54.798]         if (!identical(...future.workdir, getwd())) 
[10:29:54.798]             setwd(...future.workdir)
[10:29:54.798]         {
[10:29:54.798]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:54.798]                 ...future.oldOptions$nwarnings <- NULL
[10:29:54.798]             }
[10:29:54.798]             base::options(...future.oldOptions)
[10:29:54.798]             if (.Platform$OS.type == "windows") {
[10:29:54.798]                 old_names <- names(...future.oldEnvVars)
[10:29:54.798]                 envs <- base::Sys.getenv()
[10:29:54.798]                 names <- names(envs)
[10:29:54.798]                 common <- intersect(names, old_names)
[10:29:54.798]                 added <- setdiff(names, old_names)
[10:29:54.798]                 removed <- setdiff(old_names, names)
[10:29:54.798]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:54.798]                   envs[common]]
[10:29:54.798]                 NAMES <- toupper(changed)
[10:29:54.798]                 args <- list()
[10:29:54.798]                 for (kk in seq_along(NAMES)) {
[10:29:54.798]                   name <- changed[[kk]]
[10:29:54.798]                   NAME <- NAMES[[kk]]
[10:29:54.798]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.798]                     next
[10:29:54.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.798]                 }
[10:29:54.798]                 NAMES <- toupper(added)
[10:29:54.798]                 for (kk in seq_along(NAMES)) {
[10:29:54.798]                   name <- added[[kk]]
[10:29:54.798]                   NAME <- NAMES[[kk]]
[10:29:54.798]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.798]                     next
[10:29:54.798]                   args[[name]] <- ""
[10:29:54.798]                 }
[10:29:54.798]                 NAMES <- toupper(removed)
[10:29:54.798]                 for (kk in seq_along(NAMES)) {
[10:29:54.798]                   name <- removed[[kk]]
[10:29:54.798]                   NAME <- NAMES[[kk]]
[10:29:54.798]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.798]                     next
[10:29:54.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.798]                 }
[10:29:54.798]                 if (length(args) > 0) 
[10:29:54.798]                   base::do.call(base::Sys.setenv, args = args)
[10:29:54.798]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:54.798]             }
[10:29:54.798]             else {
[10:29:54.798]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:54.798]             }
[10:29:54.798]             {
[10:29:54.798]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:54.798]                   0L) {
[10:29:54.798]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:54.798]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:54.798]                   base::options(opts)
[10:29:54.798]                 }
[10:29:54.798]                 {
[10:29:54.798]                   {
[10:29:54.798]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:54.798]                     NULL
[10:29:54.798]                   }
[10:29:54.798]                   options(future.plan = NULL)
[10:29:54.798]                   if (is.na(NA_character_)) 
[10:29:54.798]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.798]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:54.798]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:54.798]                     .init = FALSE)
[10:29:54.798]                 }
[10:29:54.798]             }
[10:29:54.798]         }
[10:29:54.798]     })
[10:29:54.798]     if (TRUE) {
[10:29:54.798]         base::sink(type = "output", split = FALSE)
[10:29:54.798]         if (TRUE) {
[10:29:54.798]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:54.798]         }
[10:29:54.798]         else {
[10:29:54.798]             ...future.result["stdout"] <- base::list(NULL)
[10:29:54.798]         }
[10:29:54.798]         base::close(...future.stdout)
[10:29:54.798]         ...future.stdout <- NULL
[10:29:54.798]     }
[10:29:54.798]     ...future.result$conditions <- ...future.conditions
[10:29:54.798]     ...future.result$finished <- base::Sys.time()
[10:29:54.798]     ...future.result
[10:29:54.798] }
[10:29:54.801] assign_globals() ...
[10:29:54.801] List of 5
[10:29:54.801]  $ ...future.FUN            :function (object, ...)  
[10:29:54.801]  $ future.call.arguments    : list()
[10:29:54.801]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.801]  $ ...future.elements_ii    :List of 1
[10:29:54.801]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:54.801]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:29:54.801]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:54.801]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:54.801]  $ ...future.seeds_ii       : NULL
[10:29:54.801]  $ ...future.globals.maxSize: NULL
[10:29:54.801]  - attr(*, "where")=List of 5
[10:29:54.801]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:54.801]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:54.801]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:54.801]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:54.801]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:54.801]  - attr(*, "resolved")= logi FALSE
[10:29:54.801]  - attr(*, "total_size")= num 1240
[10:29:54.801]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.801]  - attr(*, "already-done")= logi TRUE
[10:29:54.848] - copied ‘...future.FUN’ to environment
[10:29:54.849] - copied ‘future.call.arguments’ to environment
[10:29:54.849] - copied ‘...future.elements_ii’ to environment
[10:29:54.849] - copied ‘...future.seeds_ii’ to environment
[10:29:54.849] - copied ‘...future.globals.maxSize’ to environment
[10:29:54.849] assign_globals() ... done
[10:29:54.849] requestCore(): workers = 2
[10:29:54.851] MulticoreFuture started
[10:29:54.852] - Launch lazy future ... done
[10:29:54.852] run() for ‘MulticoreFuture’ ... done
[10:29:54.852] Created future:
[10:29:54.853] plan(): Setting new future strategy stack:
[10:29:54.853] List of future strategies:
[10:29:54.853] 1. sequential:
[10:29:54.853]    - args: function (..., envir = parent.frame())
[10:29:54.853]    - tweaked: FALSE
[10:29:54.853]    - call: NULL
[10:29:54.854] plan(): nbrOfWorkers() = 1
[10:29:54.857] plan(): Setting new future strategy stack:
[10:29:54.858] List of future strategies:
[10:29:54.858] 1. multicore:
[10:29:54.858]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:54.858]    - tweaked: FALSE
[10:29:54.858]    - call: plan(strategy)
[10:29:54.863] plan(): nbrOfWorkers() = 2
[10:29:54.853] MulticoreFuture:
[10:29:54.853] Label: ‘future_by-1’
[10:29:54.853] Expression:
[10:29:54.853] {
[10:29:54.853]     do.call(function(...) {
[10:29:54.853]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.853]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.853]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.853]             on.exit(options(oopts), add = TRUE)
[10:29:54.853]         }
[10:29:54.853]         {
[10:29:54.853]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.853]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.853]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.853]             })
[10:29:54.853]         }
[10:29:54.853]     }, args = future.call.arguments)
[10:29:54.853] }
[10:29:54.853] Lazy evaluation: FALSE
[10:29:54.853] Asynchronous evaluation: TRUE
[10:29:54.853] Local evaluation: TRUE
[10:29:54.853] Environment: 0x556dd2da1680
[10:29:54.853] Capture standard output: TRUE
[10:29:54.853] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:54.853] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:54.853] Packages: <none>
[10:29:54.853] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:54.853] Resolved: TRUE
[10:29:54.853] Value: <not collected>
[10:29:54.853] Conditions captured: <none>
[10:29:54.853] Early signaling: FALSE
[10:29:54.853] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:54.853] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:54.864] Chunk #1 of 2 ... DONE
[10:29:54.864] Chunk #2 of 2 ...
[10:29:54.864]  - Finding globals in 'X' for chunk #2 ...
[10:29:54.864] getGlobalsAndPackages() ...
[10:29:54.864] Searching for globals...
[10:29:54.865] 
[10:29:54.865] Searching for globals ... DONE
[10:29:54.865] - globals: [0] <none>
[10:29:54.866] getGlobalsAndPackages() ... DONE
[10:29:54.866]    + additional globals found: [n=0] 
[10:29:54.866]    + additional namespaces needed: [n=0] 
[10:29:54.866]  - Finding globals in 'X' for chunk #2 ... DONE
[10:29:54.866]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:54.866]  - seeds: <none>
[10:29:54.866]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.867] getGlobalsAndPackages() ...
[10:29:54.867] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.867] Resolving globals: FALSE
[10:29:54.867] Tweak future expression to call with '...' arguments ...
[10:29:54.867] {
[10:29:54.867]     do.call(function(...) {
[10:29:54.867]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.867]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.867]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.867]             on.exit(options(oopts), add = TRUE)
[10:29:54.867]         }
[10:29:54.867]         {
[10:29:54.867]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.867]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.867]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.867]             })
[10:29:54.867]         }
[10:29:54.867]     }, args = future.call.arguments)
[10:29:54.867] }
[10:29:54.868] Tweak future expression to call with '...' arguments ... DONE
[10:29:54.868] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.868] 
[10:29:54.868] getGlobalsAndPackages() ... DONE
[10:29:54.869] run() for ‘Future’ ...
[10:29:54.869] - state: ‘created’
[10:29:54.869] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:54.875] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:54.875] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:54.875]   - Field: ‘label’
[10:29:54.876]   - Field: ‘local’
[10:29:54.876]   - Field: ‘owner’
[10:29:54.876]   - Field: ‘envir’
[10:29:54.876]   - Field: ‘workers’
[10:29:54.876]   - Field: ‘packages’
[10:29:54.876]   - Field: ‘gc’
[10:29:54.877]   - Field: ‘job’
[10:29:54.877]   - Field: ‘conditions’
[10:29:54.877]   - Field: ‘expr’
[10:29:54.877]   - Field: ‘uuid’
[10:29:54.877]   - Field: ‘seed’
[10:29:54.877]   - Field: ‘version’
[10:29:54.878]   - Field: ‘result’
[10:29:54.878]   - Field: ‘asynchronous’
[10:29:54.878]   - Field: ‘calls’
[10:29:54.878]   - Field: ‘globals’
[10:29:54.878]   - Field: ‘stdout’
[10:29:54.879]   - Field: ‘earlySignal’
[10:29:54.879]   - Field: ‘lazy’
[10:29:54.879]   - Field: ‘state’
[10:29:54.879] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:54.879] - Launch lazy future ...
[10:29:54.880] Packages needed by the future expression (n = 0): <none>
[10:29:54.880] Packages needed by future strategies (n = 0): <none>
[10:29:54.881] {
[10:29:54.881]     {
[10:29:54.881]         {
[10:29:54.881]             ...future.startTime <- base::Sys.time()
[10:29:54.881]             {
[10:29:54.881]                 {
[10:29:54.881]                   {
[10:29:54.881]                     {
[10:29:54.881]                       base::local({
[10:29:54.881]                         has_future <- base::requireNamespace("future", 
[10:29:54.881]                           quietly = TRUE)
[10:29:54.881]                         if (has_future) {
[10:29:54.881]                           ns <- base::getNamespace("future")
[10:29:54.881]                           version <- ns[[".package"]][["version"]]
[10:29:54.881]                           if (is.null(version)) 
[10:29:54.881]                             version <- utils::packageVersion("future")
[10:29:54.881]                         }
[10:29:54.881]                         else {
[10:29:54.881]                           version <- NULL
[10:29:54.881]                         }
[10:29:54.881]                         if (!has_future || version < "1.8.0") {
[10:29:54.881]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:54.881]                             "", base::R.version$version.string), 
[10:29:54.881]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:54.881]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:54.881]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:54.881]                               "release", "version")], collapse = " "), 
[10:29:54.881]                             hostname = base::Sys.info()[["nodename"]])
[10:29:54.881]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:54.881]                             info)
[10:29:54.881]                           info <- base::paste(info, collapse = "; ")
[10:29:54.881]                           if (!has_future) {
[10:29:54.881]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:54.881]                               info)
[10:29:54.881]                           }
[10:29:54.881]                           else {
[10:29:54.881]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:54.881]                               info, version)
[10:29:54.881]                           }
[10:29:54.881]                           base::stop(msg)
[10:29:54.881]                         }
[10:29:54.881]                       })
[10:29:54.881]                     }
[10:29:54.881]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:54.881]                     base::options(mc.cores = 1L)
[10:29:54.881]                   }
[10:29:54.881]                   ...future.strategy.old <- future::plan("list")
[10:29:54.881]                   options(future.plan = NULL)
[10:29:54.881]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.881]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:54.881]                 }
[10:29:54.881]                 ...future.workdir <- getwd()
[10:29:54.881]             }
[10:29:54.881]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:54.881]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:54.881]         }
[10:29:54.881]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:54.881]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:54.881]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:54.881]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:54.881]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:54.881]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:54.881]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:54.881]             base::names(...future.oldOptions))
[10:29:54.881]     }
[10:29:54.881]     if (FALSE) {
[10:29:54.881]     }
[10:29:54.881]     else {
[10:29:54.881]         if (TRUE) {
[10:29:54.881]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:54.881]                 open = "w")
[10:29:54.881]         }
[10:29:54.881]         else {
[10:29:54.881]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:54.881]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:54.881]         }
[10:29:54.881]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:54.881]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:54.881]             base::sink(type = "output", split = FALSE)
[10:29:54.881]             base::close(...future.stdout)
[10:29:54.881]         }, add = TRUE)
[10:29:54.881]     }
[10:29:54.881]     ...future.frame <- base::sys.nframe()
[10:29:54.881]     ...future.conditions <- base::list()
[10:29:54.881]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:54.881]     if (FALSE) {
[10:29:54.881]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:54.881]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:54.881]     }
[10:29:54.881]     ...future.result <- base::tryCatch({
[10:29:54.881]         base::withCallingHandlers({
[10:29:54.881]             ...future.value <- base::withVisible(base::local({
[10:29:54.881]                 withCallingHandlers({
[10:29:54.881]                   {
[10:29:54.881]                     do.call(function(...) {
[10:29:54.881]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.881]                       if (!identical(...future.globals.maxSize.org, 
[10:29:54.881]                         ...future.globals.maxSize)) {
[10:29:54.881]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.881]                         on.exit(options(oopts), add = TRUE)
[10:29:54.881]                       }
[10:29:54.881]                       {
[10:29:54.881]                         lapply(seq_along(...future.elements_ii), 
[10:29:54.881]                           FUN = function(jj) {
[10:29:54.881]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.881]                             ...future.FUN(...future.X_jj, ...)
[10:29:54.881]                           })
[10:29:54.881]                       }
[10:29:54.881]                     }, args = future.call.arguments)
[10:29:54.881]                   }
[10:29:54.881]                 }, immediateCondition = function(cond) {
[10:29:54.881]                   save_rds <- function (object, pathname, ...) 
[10:29:54.881]                   {
[10:29:54.881]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:54.881]                     if (file_test("-f", pathname_tmp)) {
[10:29:54.881]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.881]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:54.881]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.881]                         fi_tmp[["mtime"]])
[10:29:54.881]                     }
[10:29:54.881]                     tryCatch({
[10:29:54.881]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:54.881]                     }, error = function(ex) {
[10:29:54.881]                       msg <- conditionMessage(ex)
[10:29:54.881]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.881]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:54.881]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.881]                         fi_tmp[["mtime"]], msg)
[10:29:54.881]                       ex$message <- msg
[10:29:54.881]                       stop(ex)
[10:29:54.881]                     })
[10:29:54.881]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:54.881]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:54.881]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:54.881]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.881]                       fi <- file.info(pathname)
[10:29:54.881]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:54.881]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.881]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:54.881]                         fi[["size"]], fi[["mtime"]])
[10:29:54.881]                       stop(msg)
[10:29:54.881]                     }
[10:29:54.881]                     invisible(pathname)
[10:29:54.881]                   }
[10:29:54.881]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:54.881]                     rootPath = tempdir()) 
[10:29:54.881]                   {
[10:29:54.881]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:54.881]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:54.881]                       tmpdir = path, fileext = ".rds")
[10:29:54.881]                     save_rds(obj, file)
[10:29:54.881]                   }
[10:29:54.881]                   saveImmediateCondition(cond, path = "/tmp/Rtmp11FQBX/.future/immediateConditions")
[10:29:54.881]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.881]                   {
[10:29:54.881]                     inherits <- base::inherits
[10:29:54.881]                     invokeRestart <- base::invokeRestart
[10:29:54.881]                     is.null <- base::is.null
[10:29:54.881]                     muffled <- FALSE
[10:29:54.881]                     if (inherits(cond, "message")) {
[10:29:54.881]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:54.881]                       if (muffled) 
[10:29:54.881]                         invokeRestart("muffleMessage")
[10:29:54.881]                     }
[10:29:54.881]                     else if (inherits(cond, "warning")) {
[10:29:54.881]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:54.881]                       if (muffled) 
[10:29:54.881]                         invokeRestart("muffleWarning")
[10:29:54.881]                     }
[10:29:54.881]                     else if (inherits(cond, "condition")) {
[10:29:54.881]                       if (!is.null(pattern)) {
[10:29:54.881]                         computeRestarts <- base::computeRestarts
[10:29:54.881]                         grepl <- base::grepl
[10:29:54.881]                         restarts <- computeRestarts(cond)
[10:29:54.881]                         for (restart in restarts) {
[10:29:54.881]                           name <- restart$name
[10:29:54.881]                           if (is.null(name)) 
[10:29:54.881]                             next
[10:29:54.881]                           if (!grepl(pattern, name)) 
[10:29:54.881]                             next
[10:29:54.881]                           invokeRestart(restart)
[10:29:54.881]                           muffled <- TRUE
[10:29:54.881]                           break
[10:29:54.881]                         }
[10:29:54.881]                       }
[10:29:54.881]                     }
[10:29:54.881]                     invisible(muffled)
[10:29:54.881]                   }
[10:29:54.881]                   muffleCondition(cond)
[10:29:54.881]                 })
[10:29:54.881]             }))
[10:29:54.881]             future::FutureResult(value = ...future.value$value, 
[10:29:54.881]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.881]                   ...future.rng), globalenv = if (FALSE) 
[10:29:54.881]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:54.881]                     ...future.globalenv.names))
[10:29:54.881]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:54.881]         }, condition = base::local({
[10:29:54.881]             c <- base::c
[10:29:54.881]             inherits <- base::inherits
[10:29:54.881]             invokeRestart <- base::invokeRestart
[10:29:54.881]             length <- base::length
[10:29:54.881]             list <- base::list
[10:29:54.881]             seq.int <- base::seq.int
[10:29:54.881]             signalCondition <- base::signalCondition
[10:29:54.881]             sys.calls <- base::sys.calls
[10:29:54.881]             `[[` <- base::`[[`
[10:29:54.881]             `+` <- base::`+`
[10:29:54.881]             `<<-` <- base::`<<-`
[10:29:54.881]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:54.881]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:54.881]                   3L)]
[10:29:54.881]             }
[10:29:54.881]             function(cond) {
[10:29:54.881]                 is_error <- inherits(cond, "error")
[10:29:54.881]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:54.881]                   NULL)
[10:29:54.881]                 if (is_error) {
[10:29:54.881]                   sessionInformation <- function() {
[10:29:54.881]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:54.881]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:54.881]                       search = base::search(), system = base::Sys.info())
[10:29:54.881]                   }
[10:29:54.881]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.881]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:54.881]                     cond$call), session = sessionInformation(), 
[10:29:54.881]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:54.881]                   signalCondition(cond)
[10:29:54.881]                 }
[10:29:54.881]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:54.881]                 "immediateCondition"))) {
[10:29:54.881]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:54.881]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.881]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:54.881]                   if (TRUE && !signal) {
[10:29:54.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.881]                     {
[10:29:54.881]                       inherits <- base::inherits
[10:29:54.881]                       invokeRestart <- base::invokeRestart
[10:29:54.881]                       is.null <- base::is.null
[10:29:54.881]                       muffled <- FALSE
[10:29:54.881]                       if (inherits(cond, "message")) {
[10:29:54.881]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.881]                         if (muffled) 
[10:29:54.881]                           invokeRestart("muffleMessage")
[10:29:54.881]                       }
[10:29:54.881]                       else if (inherits(cond, "warning")) {
[10:29:54.881]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.881]                         if (muffled) 
[10:29:54.881]                           invokeRestart("muffleWarning")
[10:29:54.881]                       }
[10:29:54.881]                       else if (inherits(cond, "condition")) {
[10:29:54.881]                         if (!is.null(pattern)) {
[10:29:54.881]                           computeRestarts <- base::computeRestarts
[10:29:54.881]                           grepl <- base::grepl
[10:29:54.881]                           restarts <- computeRestarts(cond)
[10:29:54.881]                           for (restart in restarts) {
[10:29:54.881]                             name <- restart$name
[10:29:54.881]                             if (is.null(name)) 
[10:29:54.881]                               next
[10:29:54.881]                             if (!grepl(pattern, name)) 
[10:29:54.881]                               next
[10:29:54.881]                             invokeRestart(restart)
[10:29:54.881]                             muffled <- TRUE
[10:29:54.881]                             break
[10:29:54.881]                           }
[10:29:54.881]                         }
[10:29:54.881]                       }
[10:29:54.881]                       invisible(muffled)
[10:29:54.881]                     }
[10:29:54.881]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.881]                   }
[10:29:54.881]                 }
[10:29:54.881]                 else {
[10:29:54.881]                   if (TRUE) {
[10:29:54.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.881]                     {
[10:29:54.881]                       inherits <- base::inherits
[10:29:54.881]                       invokeRestart <- base::invokeRestart
[10:29:54.881]                       is.null <- base::is.null
[10:29:54.881]                       muffled <- FALSE
[10:29:54.881]                       if (inherits(cond, "message")) {
[10:29:54.881]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.881]                         if (muffled) 
[10:29:54.881]                           invokeRestart("muffleMessage")
[10:29:54.881]                       }
[10:29:54.881]                       else if (inherits(cond, "warning")) {
[10:29:54.881]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.881]                         if (muffled) 
[10:29:54.881]                           invokeRestart("muffleWarning")
[10:29:54.881]                       }
[10:29:54.881]                       else if (inherits(cond, "condition")) {
[10:29:54.881]                         if (!is.null(pattern)) {
[10:29:54.881]                           computeRestarts <- base::computeRestarts
[10:29:54.881]                           grepl <- base::grepl
[10:29:54.881]                           restarts <- computeRestarts(cond)
[10:29:54.881]                           for (restart in restarts) {
[10:29:54.881]                             name <- restart$name
[10:29:54.881]                             if (is.null(name)) 
[10:29:54.881]                               next
[10:29:54.881]                             if (!grepl(pattern, name)) 
[10:29:54.881]                               next
[10:29:54.881]                             invokeRestart(restart)
[10:29:54.881]                             muffled <- TRUE
[10:29:54.881]                             break
[10:29:54.881]                           }
[10:29:54.881]                         }
[10:29:54.881]                       }
[10:29:54.881]                       invisible(muffled)
[10:29:54.881]                     }
[10:29:54.881]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.881]                   }
[10:29:54.881]                 }
[10:29:54.881]             }
[10:29:54.881]         }))
[10:29:54.881]     }, error = function(ex) {
[10:29:54.881]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:54.881]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.881]                 ...future.rng), started = ...future.startTime, 
[10:29:54.881]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:54.881]             version = "1.8"), class = "FutureResult")
[10:29:54.881]     }, finally = {
[10:29:54.881]         if (!identical(...future.workdir, getwd())) 
[10:29:54.881]             setwd(...future.workdir)
[10:29:54.881]         {
[10:29:54.881]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:54.881]                 ...future.oldOptions$nwarnings <- NULL
[10:29:54.881]             }
[10:29:54.881]             base::options(...future.oldOptions)
[10:29:54.881]             if (.Platform$OS.type == "windows") {
[10:29:54.881]                 old_names <- names(...future.oldEnvVars)
[10:29:54.881]                 envs <- base::Sys.getenv()
[10:29:54.881]                 names <- names(envs)
[10:29:54.881]                 common <- intersect(names, old_names)
[10:29:54.881]                 added <- setdiff(names, old_names)
[10:29:54.881]                 removed <- setdiff(old_names, names)
[10:29:54.881]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:54.881]                   envs[common]]
[10:29:54.881]                 NAMES <- toupper(changed)
[10:29:54.881]                 args <- list()
[10:29:54.881]                 for (kk in seq_along(NAMES)) {
[10:29:54.881]                   name <- changed[[kk]]
[10:29:54.881]                   NAME <- NAMES[[kk]]
[10:29:54.881]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.881]                     next
[10:29:54.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.881]                 }
[10:29:54.881]                 NAMES <- toupper(added)
[10:29:54.881]                 for (kk in seq_along(NAMES)) {
[10:29:54.881]                   name <- added[[kk]]
[10:29:54.881]                   NAME <- NAMES[[kk]]
[10:29:54.881]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.881]                     next
[10:29:54.881]                   args[[name]] <- ""
[10:29:54.881]                 }
[10:29:54.881]                 NAMES <- toupper(removed)
[10:29:54.881]                 for (kk in seq_along(NAMES)) {
[10:29:54.881]                   name <- removed[[kk]]
[10:29:54.881]                   NAME <- NAMES[[kk]]
[10:29:54.881]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.881]                     next
[10:29:54.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.881]                 }
[10:29:54.881]                 if (length(args) > 0) 
[10:29:54.881]                   base::do.call(base::Sys.setenv, args = args)
[10:29:54.881]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:54.881]             }
[10:29:54.881]             else {
[10:29:54.881]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:54.881]             }
[10:29:54.881]             {
[10:29:54.881]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:54.881]                   0L) {
[10:29:54.881]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:54.881]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:54.881]                   base::options(opts)
[10:29:54.881]                 }
[10:29:54.881]                 {
[10:29:54.881]                   {
[10:29:54.881]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:54.881]                     NULL
[10:29:54.881]                   }
[10:29:54.881]                   options(future.plan = NULL)
[10:29:54.881]                   if (is.na(NA_character_)) 
[10:29:54.881]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.881]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:54.881]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:54.881]                     .init = FALSE)
[10:29:54.881]                 }
[10:29:54.881]             }
[10:29:54.881]         }
[10:29:54.881]     })
[10:29:54.881]     if (TRUE) {
[10:29:54.881]         base::sink(type = "output", split = FALSE)
[10:29:54.881]         if (TRUE) {
[10:29:54.881]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:54.881]         }
[10:29:54.881]         else {
[10:29:54.881]             ...future.result["stdout"] <- base::list(NULL)
[10:29:54.881]         }
[10:29:54.881]         base::close(...future.stdout)
[10:29:54.881]         ...future.stdout <- NULL
[10:29:54.881]     }
[10:29:54.881]     ...future.result$conditions <- ...future.conditions
[10:29:54.881]     ...future.result$finished <- base::Sys.time()
[10:29:54.881]     ...future.result
[10:29:54.881] }
[10:29:54.885] assign_globals() ...
[10:29:54.886] List of 5
[10:29:54.886]  $ ...future.FUN            :function (object, ...)  
[10:29:54.886]  $ future.call.arguments    : list()
[10:29:54.886]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.886]  $ ...future.elements_ii    :List of 2
[10:29:54.886]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:54.886]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:29:54.886]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:54.886]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:29:54.886]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:54.886]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:29:54.886]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:54.886]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:29:54.886]  $ ...future.seeds_ii       : NULL
[10:29:54.886]  $ ...future.globals.maxSize: NULL
[10:29:54.886]  - attr(*, "where")=List of 5
[10:29:54.886]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:54.886]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:54.886]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:54.886]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:54.886]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:54.886]  - attr(*, "resolved")= logi FALSE
[10:29:54.886]  - attr(*, "total_size")= num 1240
[10:29:54.886]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.886]  - attr(*, "already-done")= logi TRUE
[10:29:54.902] - copied ‘...future.FUN’ to environment
[10:29:54.903] - copied ‘future.call.arguments’ to environment
[10:29:54.903] - copied ‘...future.elements_ii’ to environment
[10:29:54.903] - copied ‘...future.seeds_ii’ to environment
[10:29:54.903] - copied ‘...future.globals.maxSize’ to environment
[10:29:54.903] assign_globals() ... done
[10:29:54.904] requestCore(): workers = 2
[10:29:54.906] MulticoreFuture started
[10:29:54.907] - Launch lazy future ... done
[10:29:54.907] run() for ‘MulticoreFuture’ ... done
[10:29:54.907] plan(): Setting new future strategy stack:
[10:29:54.908] Created future:
[10:29:54.908] List of future strategies:
[10:29:54.908] 1. sequential:
[10:29:54.908]    - args: function (..., envir = parent.frame())
[10:29:54.908]    - tweaked: FALSE
[10:29:54.908]    - call: NULL
[10:29:54.909] plan(): nbrOfWorkers() = 1
[10:29:54.913] plan(): Setting new future strategy stack:
[10:29:54.913] List of future strategies:
[10:29:54.913] 1. multicore:
[10:29:54.913]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:54.913]    - tweaked: FALSE
[10:29:54.913]    - call: plan(strategy)
[10:29:54.918] plan(): nbrOfWorkers() = 2
[10:29:54.908] MulticoreFuture:
[10:29:54.908] Label: ‘future_by-2’
[10:29:54.908] Expression:
[10:29:54.908] {
[10:29:54.908]     do.call(function(...) {
[10:29:54.908]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.908]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.908]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.908]             on.exit(options(oopts), add = TRUE)
[10:29:54.908]         }
[10:29:54.908]         {
[10:29:54.908]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.908]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.908]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.908]             })
[10:29:54.908]         }
[10:29:54.908]     }, args = future.call.arguments)
[10:29:54.908] }
[10:29:54.908] Lazy evaluation: FALSE
[10:29:54.908] Asynchronous evaluation: TRUE
[10:29:54.908] Local evaluation: TRUE
[10:29:54.908] Environment: 0x556dd2da1680
[10:29:54.908] Capture standard output: TRUE
[10:29:54.908] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:54.908] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:54.908] Packages: <none>
[10:29:54.908] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:54.908] Resolved: TRUE
[10:29:54.908] Value: <not collected>
[10:29:54.908] Conditions captured: <none>
[10:29:54.908] Early signaling: FALSE
[10:29:54.908] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:54.908] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:54.919] Chunk #2 of 2 ... DONE
[10:29:54.919] Launching 2 futures (chunks) ... DONE
[10:29:54.919] Resolving 2 futures (chunks) ...
[10:29:54.920] resolve() on list ...
[10:29:54.920]  recursive: 0
[10:29:54.920]  length: 2
[10:29:54.920] 
[10:29:54.920] Future #1
[10:29:54.921] result() for MulticoreFuture ...
[10:29:54.922] result() for MulticoreFuture ...
[10:29:54.922] result() for MulticoreFuture ... done
[10:29:54.922] result() for MulticoreFuture ... done
[10:29:54.922] result() for MulticoreFuture ...
[10:29:54.922] result() for MulticoreFuture ... done
[10:29:54.923] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:29:54.923] - nx: 2
[10:29:54.923] - relay: TRUE
[10:29:54.923] - stdout: TRUE
[10:29:54.923] - signal: TRUE
[10:29:54.923] - resignal: FALSE
[10:29:54.923] - force: TRUE
[10:29:54.923] - relayed: [n=2] FALSE, FALSE
[10:29:54.924] - queued futures: [n=2] FALSE, FALSE
[10:29:54.924]  - until=1
[10:29:54.924]  - relaying element #1
[10:29:54.924] result() for MulticoreFuture ...
[10:29:54.924] result() for MulticoreFuture ... done
[10:29:54.924] result() for MulticoreFuture ...
[10:29:54.924] result() for MulticoreFuture ... done
[10:29:54.925] result() for MulticoreFuture ...
[10:29:54.925] result() for MulticoreFuture ... done
[10:29:54.925] result() for MulticoreFuture ...
[10:29:54.925] result() for MulticoreFuture ... done
[10:29:54.925] - relayed: [n=2] TRUE, FALSE
[10:29:54.925] - queued futures: [n=2] TRUE, FALSE
[10:29:54.926] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:29:54.926]  length: 1 (resolved future 1)
[10:29:54.926] Future #2
[10:29:54.926] result() for MulticoreFuture ...
[10:29:54.927] result() for MulticoreFuture ...
[10:29:54.927] result() for MulticoreFuture ... done
[10:29:54.927] result() for MulticoreFuture ... done
[10:29:54.927] result() for MulticoreFuture ...
[10:29:54.927] result() for MulticoreFuture ... done
[10:29:54.928] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:29:54.928] - nx: 2
[10:29:54.928] - relay: TRUE
[10:29:54.928] - stdout: TRUE
[10:29:54.928] - signal: TRUE
[10:29:54.928] - resignal: FALSE
[10:29:54.928] - force: TRUE
[10:29:54.928] - relayed: [n=2] TRUE, FALSE
[10:29:54.928] - queued futures: [n=2] TRUE, FALSE
[10:29:54.929]  - until=2
[10:29:54.929]  - relaying element #2
[10:29:54.929] result() for MulticoreFuture ...
[10:29:54.929] result() for MulticoreFuture ... done
[10:29:54.929] result() for MulticoreFuture ...
[10:29:54.929] result() for MulticoreFuture ... done
[10:29:54.929] result() for MulticoreFuture ...
[10:29:54.930] result() for MulticoreFuture ... done
[10:29:54.930] result() for MulticoreFuture ...
[10:29:54.930] result() for MulticoreFuture ... done
[10:29:54.930] - relayed: [n=2] TRUE, TRUE
[10:29:54.930] - queued futures: [n=2] TRUE, TRUE
[10:29:54.930] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:29:54.930]  length: 0 (resolved future 2)
[10:29:54.930] Relaying remaining futures
[10:29:54.931] signalConditionsASAP(NULL, pos=0) ...
[10:29:54.931] - nx: 2
[10:29:54.931] - relay: TRUE
[10:29:54.931] - stdout: TRUE
[10:29:54.931] - signal: TRUE
[10:29:54.931] - resignal: FALSE
[10:29:54.931] - force: TRUE
[10:29:54.931] - relayed: [n=2] TRUE, TRUE
[10:29:54.931] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:54.932] - relayed: [n=2] TRUE, TRUE
[10:29:54.932] - queued futures: [n=2] TRUE, TRUE
[10:29:54.932] signalConditionsASAP(NULL, pos=0) ... done
[10:29:54.932] resolve() on list ... DONE
[10:29:54.932] result() for MulticoreFuture ...
[10:29:54.932] result() for MulticoreFuture ... done
[10:29:54.932] result() for MulticoreFuture ...
[10:29:54.933] result() for MulticoreFuture ... done
[10:29:54.933] result() for MulticoreFuture ...
[10:29:54.933] result() for MulticoreFuture ... done
[10:29:54.933] result() for MulticoreFuture ...
[10:29:54.933] result() for MulticoreFuture ... done
[10:29:54.933]  - Number of value chunks collected: 2
[10:29:54.933] Resolving 2 futures (chunks) ... DONE
[10:29:54.933] Reducing values from 2 chunks ...
[10:29:54.934]  - Number of values collected after concatenation: 3
[10:29:54.934]  - Number of values expected: 3
[10:29:54.934] Reducing values from 2 chunks ... DONE
[10:29:54.934] future_lapply() ... DONE
[10:29:54.934] future_by_internal() ... DONE
[10:29:54.935] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[10:29:54.936] future_lapply() ...
[10:29:54.942] Number of chunks: 2
[10:29:54.942] getGlobalsAndPackagesXApply() ...
[10:29:54.942]  - future.globals: TRUE
[10:29:54.942] getGlobalsAndPackages() ...
[10:29:54.942] Searching for globals...
[10:29:54.944] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:54.944] Searching for globals ... DONE
[10:29:54.944] Resolving globals: FALSE
[10:29:54.945] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:54.945] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:54.945] - globals: [1] ‘FUN’
[10:29:54.945] 
[10:29:54.945] getGlobalsAndPackages() ... DONE
[10:29:54.946]  - globals found/used: [n=1] ‘FUN’
[10:29:54.946]  - needed namespaces: [n=0] 
[10:29:54.946] Finding globals ... DONE
[10:29:54.946]  - use_args: TRUE
[10:29:54.946]  - Getting '...' globals ...
[10:29:54.946] resolve() on list ...
[10:29:54.947]  recursive: 0
[10:29:54.947]  length: 1
[10:29:54.947]  elements: ‘...’
[10:29:54.947]  length: 0 (resolved future 1)
[10:29:54.947] resolve() on list ... DONE
[10:29:54.947]    - '...' content: [n=0] 
[10:29:54.947] List of 1
[10:29:54.947]  $ ...: list()
[10:29:54.947]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.947]  - attr(*, "where")=List of 1
[10:29:54.947]   ..$ ...:<environment: 0x556dd62ac498> 
[10:29:54.947]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.947]  - attr(*, "resolved")= logi TRUE
[10:29:54.947]  - attr(*, "total_size")= num NA
[10:29:54.951]  - Getting '...' globals ... DONE
[10:29:54.951] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:54.951] List of 2
[10:29:54.951]  $ ...future.FUN:function (object, ...)  
[10:29:54.951]  $ ...          : list()
[10:29:54.951]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.951]  - attr(*, "where")=List of 2
[10:29:54.951]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:54.951]   ..$ ...          :<environment: 0x556dd62ac498> 
[10:29:54.951]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.951]  - attr(*, "resolved")= logi FALSE
[10:29:54.951]  - attr(*, "total_size")= num 1240
[10:29:54.955] Packages to be attached in all futures: [n=0] 
[10:29:54.955] getGlobalsAndPackagesXApply() ... DONE
[10:29:54.955] Number of futures (= number of chunks): 2
[10:29:54.955] Launching 2 futures (chunks) ...
[10:29:54.955] Chunk #1 of 2 ...
[10:29:54.956]  - Finding globals in 'X' for chunk #1 ...
[10:29:54.956] getGlobalsAndPackages() ...
[10:29:54.956] Searching for globals...
[10:29:54.956] 
[10:29:54.956] Searching for globals ... DONE
[10:29:54.957] - globals: [0] <none>
[10:29:54.957] getGlobalsAndPackages() ... DONE
[10:29:54.957]    + additional globals found: [n=0] 
[10:29:54.957]    + additional namespaces needed: [n=0] 
[10:29:54.957]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:54.957]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:54.957]  - seeds: <none>
[10:29:54.957]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.958] getGlobalsAndPackages() ...
[10:29:54.958] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.958] Resolving globals: FALSE
[10:29:54.958] Tweak future expression to call with '...' arguments ...
[10:29:54.958] {
[10:29:54.958]     do.call(function(...) {
[10:29:54.958]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.958]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.958]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.958]             on.exit(options(oopts), add = TRUE)
[10:29:54.958]         }
[10:29:54.958]         {
[10:29:54.958]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.958]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.958]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.958]             })
[10:29:54.958]         }
[10:29:54.958]     }, args = future.call.arguments)
[10:29:54.958] }
[10:29:54.958] Tweak future expression to call with '...' arguments ... DONE
[10:29:54.959] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.959] 
[10:29:54.959] getGlobalsAndPackages() ... DONE
[10:29:54.960] run() for ‘Future’ ...
[10:29:54.960] - state: ‘created’
[10:29:54.960] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:54.965] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:54.965] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:54.965]   - Field: ‘label’
[10:29:54.965]   - Field: ‘local’
[10:29:54.965]   - Field: ‘owner’
[10:29:54.966]   - Field: ‘envir’
[10:29:54.966]   - Field: ‘workers’
[10:29:54.966]   - Field: ‘packages’
[10:29:54.966]   - Field: ‘gc’
[10:29:54.966]   - Field: ‘job’
[10:29:54.966]   - Field: ‘conditions’
[10:29:54.966]   - Field: ‘expr’
[10:29:54.966]   - Field: ‘uuid’
[10:29:54.967]   - Field: ‘seed’
[10:29:54.967]   - Field: ‘version’
[10:29:54.967]   - Field: ‘result’
[10:29:54.967]   - Field: ‘asynchronous’
[10:29:54.967]   - Field: ‘calls’
[10:29:54.967]   - Field: ‘globals’
[10:29:54.967]   - Field: ‘stdout’
[10:29:54.967]   - Field: ‘earlySignal’
[10:29:54.968]   - Field: ‘lazy’
[10:29:54.968]   - Field: ‘state’
[10:29:54.968] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:54.968] - Launch lazy future ...
[10:29:54.968] Packages needed by the future expression (n = 0): <none>
[10:29:54.968] Packages needed by future strategies (n = 0): <none>
[10:29:54.969] {
[10:29:54.969]     {
[10:29:54.969]         {
[10:29:54.969]             ...future.startTime <- base::Sys.time()
[10:29:54.969]             {
[10:29:54.969]                 {
[10:29:54.969]                   {
[10:29:54.969]                     {
[10:29:54.969]                       base::local({
[10:29:54.969]                         has_future <- base::requireNamespace("future", 
[10:29:54.969]                           quietly = TRUE)
[10:29:54.969]                         if (has_future) {
[10:29:54.969]                           ns <- base::getNamespace("future")
[10:29:54.969]                           version <- ns[[".package"]][["version"]]
[10:29:54.969]                           if (is.null(version)) 
[10:29:54.969]                             version <- utils::packageVersion("future")
[10:29:54.969]                         }
[10:29:54.969]                         else {
[10:29:54.969]                           version <- NULL
[10:29:54.969]                         }
[10:29:54.969]                         if (!has_future || version < "1.8.0") {
[10:29:54.969]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:54.969]                             "", base::R.version$version.string), 
[10:29:54.969]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:54.969]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:54.969]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:54.969]                               "release", "version")], collapse = " "), 
[10:29:54.969]                             hostname = base::Sys.info()[["nodename"]])
[10:29:54.969]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:54.969]                             info)
[10:29:54.969]                           info <- base::paste(info, collapse = "; ")
[10:29:54.969]                           if (!has_future) {
[10:29:54.969]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:54.969]                               info)
[10:29:54.969]                           }
[10:29:54.969]                           else {
[10:29:54.969]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:54.969]                               info, version)
[10:29:54.969]                           }
[10:29:54.969]                           base::stop(msg)
[10:29:54.969]                         }
[10:29:54.969]                       })
[10:29:54.969]                     }
[10:29:54.969]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:54.969]                     base::options(mc.cores = 1L)
[10:29:54.969]                   }
[10:29:54.969]                   ...future.strategy.old <- future::plan("list")
[10:29:54.969]                   options(future.plan = NULL)
[10:29:54.969]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.969]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:54.969]                 }
[10:29:54.969]                 ...future.workdir <- getwd()
[10:29:54.969]             }
[10:29:54.969]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:54.969]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:54.969]         }
[10:29:54.969]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:54.969]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:54.969]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:54.969]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:54.969]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:54.969]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:54.969]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:54.969]             base::names(...future.oldOptions))
[10:29:54.969]     }
[10:29:54.969]     if (FALSE) {
[10:29:54.969]     }
[10:29:54.969]     else {
[10:29:54.969]         if (TRUE) {
[10:29:54.969]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:54.969]                 open = "w")
[10:29:54.969]         }
[10:29:54.969]         else {
[10:29:54.969]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:54.969]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:54.969]         }
[10:29:54.969]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:54.969]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:54.969]             base::sink(type = "output", split = FALSE)
[10:29:54.969]             base::close(...future.stdout)
[10:29:54.969]         }, add = TRUE)
[10:29:54.969]     }
[10:29:54.969]     ...future.frame <- base::sys.nframe()
[10:29:54.969]     ...future.conditions <- base::list()
[10:29:54.969]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:54.969]     if (FALSE) {
[10:29:54.969]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:54.969]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:54.969]     }
[10:29:54.969]     ...future.result <- base::tryCatch({
[10:29:54.969]         base::withCallingHandlers({
[10:29:54.969]             ...future.value <- base::withVisible(base::local({
[10:29:54.969]                 withCallingHandlers({
[10:29:54.969]                   {
[10:29:54.969]                     do.call(function(...) {
[10:29:54.969]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.969]                       if (!identical(...future.globals.maxSize.org, 
[10:29:54.969]                         ...future.globals.maxSize)) {
[10:29:54.969]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.969]                         on.exit(options(oopts), add = TRUE)
[10:29:54.969]                       }
[10:29:54.969]                       {
[10:29:54.969]                         lapply(seq_along(...future.elements_ii), 
[10:29:54.969]                           FUN = function(jj) {
[10:29:54.969]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.969]                             ...future.FUN(...future.X_jj, ...)
[10:29:54.969]                           })
[10:29:54.969]                       }
[10:29:54.969]                     }, args = future.call.arguments)
[10:29:54.969]                   }
[10:29:54.969]                 }, immediateCondition = function(cond) {
[10:29:54.969]                   save_rds <- function (object, pathname, ...) 
[10:29:54.969]                   {
[10:29:54.969]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:54.969]                     if (file_test("-f", pathname_tmp)) {
[10:29:54.969]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.969]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:54.969]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.969]                         fi_tmp[["mtime"]])
[10:29:54.969]                     }
[10:29:54.969]                     tryCatch({
[10:29:54.969]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:54.969]                     }, error = function(ex) {
[10:29:54.969]                       msg <- conditionMessage(ex)
[10:29:54.969]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.969]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:54.969]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.969]                         fi_tmp[["mtime"]], msg)
[10:29:54.969]                       ex$message <- msg
[10:29:54.969]                       stop(ex)
[10:29:54.969]                     })
[10:29:54.969]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:54.969]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:54.969]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:54.969]                       fi_tmp <- file.info(pathname_tmp)
[10:29:54.969]                       fi <- file.info(pathname)
[10:29:54.969]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:54.969]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:54.969]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:54.969]                         fi[["size"]], fi[["mtime"]])
[10:29:54.969]                       stop(msg)
[10:29:54.969]                     }
[10:29:54.969]                     invisible(pathname)
[10:29:54.969]                   }
[10:29:54.969]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:54.969]                     rootPath = tempdir()) 
[10:29:54.969]                   {
[10:29:54.969]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:54.969]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:54.969]                       tmpdir = path, fileext = ".rds")
[10:29:54.969]                     save_rds(obj, file)
[10:29:54.969]                   }
[10:29:54.969]                   saveImmediateCondition(cond, path = "/tmp/Rtmp11FQBX/.future/immediateConditions")
[10:29:54.969]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.969]                   {
[10:29:54.969]                     inherits <- base::inherits
[10:29:54.969]                     invokeRestart <- base::invokeRestart
[10:29:54.969]                     is.null <- base::is.null
[10:29:54.969]                     muffled <- FALSE
[10:29:54.969]                     if (inherits(cond, "message")) {
[10:29:54.969]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:54.969]                       if (muffled) 
[10:29:54.969]                         invokeRestart("muffleMessage")
[10:29:54.969]                     }
[10:29:54.969]                     else if (inherits(cond, "warning")) {
[10:29:54.969]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:54.969]                       if (muffled) 
[10:29:54.969]                         invokeRestart("muffleWarning")
[10:29:54.969]                     }
[10:29:54.969]                     else if (inherits(cond, "condition")) {
[10:29:54.969]                       if (!is.null(pattern)) {
[10:29:54.969]                         computeRestarts <- base::computeRestarts
[10:29:54.969]                         grepl <- base::grepl
[10:29:54.969]                         restarts <- computeRestarts(cond)
[10:29:54.969]                         for (restart in restarts) {
[10:29:54.969]                           name <- restart$name
[10:29:54.969]                           if (is.null(name)) 
[10:29:54.969]                             next
[10:29:54.969]                           if (!grepl(pattern, name)) 
[10:29:54.969]                             next
[10:29:54.969]                           invokeRestart(restart)
[10:29:54.969]                           muffled <- TRUE
[10:29:54.969]                           break
[10:29:54.969]                         }
[10:29:54.969]                       }
[10:29:54.969]                     }
[10:29:54.969]                     invisible(muffled)
[10:29:54.969]                   }
[10:29:54.969]                   muffleCondition(cond)
[10:29:54.969]                 })
[10:29:54.969]             }))
[10:29:54.969]             future::FutureResult(value = ...future.value$value, 
[10:29:54.969]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.969]                   ...future.rng), globalenv = if (FALSE) 
[10:29:54.969]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:54.969]                     ...future.globalenv.names))
[10:29:54.969]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:54.969]         }, condition = base::local({
[10:29:54.969]             c <- base::c
[10:29:54.969]             inherits <- base::inherits
[10:29:54.969]             invokeRestart <- base::invokeRestart
[10:29:54.969]             length <- base::length
[10:29:54.969]             list <- base::list
[10:29:54.969]             seq.int <- base::seq.int
[10:29:54.969]             signalCondition <- base::signalCondition
[10:29:54.969]             sys.calls <- base::sys.calls
[10:29:54.969]             `[[` <- base::`[[`
[10:29:54.969]             `+` <- base::`+`
[10:29:54.969]             `<<-` <- base::`<<-`
[10:29:54.969]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:54.969]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:54.969]                   3L)]
[10:29:54.969]             }
[10:29:54.969]             function(cond) {
[10:29:54.969]                 is_error <- inherits(cond, "error")
[10:29:54.969]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:54.969]                   NULL)
[10:29:54.969]                 if (is_error) {
[10:29:54.969]                   sessionInformation <- function() {
[10:29:54.969]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:54.969]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:54.969]                       search = base::search(), system = base::Sys.info())
[10:29:54.969]                   }
[10:29:54.969]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.969]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:54.969]                     cond$call), session = sessionInformation(), 
[10:29:54.969]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:54.969]                   signalCondition(cond)
[10:29:54.969]                 }
[10:29:54.969]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:54.969]                 "immediateCondition"))) {
[10:29:54.969]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:54.969]                   ...future.conditions[[length(...future.conditions) + 
[10:29:54.969]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:54.969]                   if (TRUE && !signal) {
[10:29:54.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.969]                     {
[10:29:54.969]                       inherits <- base::inherits
[10:29:54.969]                       invokeRestart <- base::invokeRestart
[10:29:54.969]                       is.null <- base::is.null
[10:29:54.969]                       muffled <- FALSE
[10:29:54.969]                       if (inherits(cond, "message")) {
[10:29:54.969]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.969]                         if (muffled) 
[10:29:54.969]                           invokeRestart("muffleMessage")
[10:29:54.969]                       }
[10:29:54.969]                       else if (inherits(cond, "warning")) {
[10:29:54.969]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.969]                         if (muffled) 
[10:29:54.969]                           invokeRestart("muffleWarning")
[10:29:54.969]                       }
[10:29:54.969]                       else if (inherits(cond, "condition")) {
[10:29:54.969]                         if (!is.null(pattern)) {
[10:29:54.969]                           computeRestarts <- base::computeRestarts
[10:29:54.969]                           grepl <- base::grepl
[10:29:54.969]                           restarts <- computeRestarts(cond)
[10:29:54.969]                           for (restart in restarts) {
[10:29:54.969]                             name <- restart$name
[10:29:54.969]                             if (is.null(name)) 
[10:29:54.969]                               next
[10:29:54.969]                             if (!grepl(pattern, name)) 
[10:29:54.969]                               next
[10:29:54.969]                             invokeRestart(restart)
[10:29:54.969]                             muffled <- TRUE
[10:29:54.969]                             break
[10:29:54.969]                           }
[10:29:54.969]                         }
[10:29:54.969]                       }
[10:29:54.969]                       invisible(muffled)
[10:29:54.969]                     }
[10:29:54.969]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.969]                   }
[10:29:54.969]                 }
[10:29:54.969]                 else {
[10:29:54.969]                   if (TRUE) {
[10:29:54.969]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:54.969]                     {
[10:29:54.969]                       inherits <- base::inherits
[10:29:54.969]                       invokeRestart <- base::invokeRestart
[10:29:54.969]                       is.null <- base::is.null
[10:29:54.969]                       muffled <- FALSE
[10:29:54.969]                       if (inherits(cond, "message")) {
[10:29:54.969]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:54.969]                         if (muffled) 
[10:29:54.969]                           invokeRestart("muffleMessage")
[10:29:54.969]                       }
[10:29:54.969]                       else if (inherits(cond, "warning")) {
[10:29:54.969]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:54.969]                         if (muffled) 
[10:29:54.969]                           invokeRestart("muffleWarning")
[10:29:54.969]                       }
[10:29:54.969]                       else if (inherits(cond, "condition")) {
[10:29:54.969]                         if (!is.null(pattern)) {
[10:29:54.969]                           computeRestarts <- base::computeRestarts
[10:29:54.969]                           grepl <- base::grepl
[10:29:54.969]                           restarts <- computeRestarts(cond)
[10:29:54.969]                           for (restart in restarts) {
[10:29:54.969]                             name <- restart$name
[10:29:54.969]                             if (is.null(name)) 
[10:29:54.969]                               next
[10:29:54.969]                             if (!grepl(pattern, name)) 
[10:29:54.969]                               next
[10:29:54.969]                             invokeRestart(restart)
[10:29:54.969]                             muffled <- TRUE
[10:29:54.969]                             break
[10:29:54.969]                           }
[10:29:54.969]                         }
[10:29:54.969]                       }
[10:29:54.969]                       invisible(muffled)
[10:29:54.969]                     }
[10:29:54.969]                     muffleCondition(cond, pattern = "^muffle")
[10:29:54.969]                   }
[10:29:54.969]                 }
[10:29:54.969]             }
[10:29:54.969]         }))
[10:29:54.969]     }, error = function(ex) {
[10:29:54.969]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:54.969]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:54.969]                 ...future.rng), started = ...future.startTime, 
[10:29:54.969]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:54.969]             version = "1.8"), class = "FutureResult")
[10:29:54.969]     }, finally = {
[10:29:54.969]         if (!identical(...future.workdir, getwd())) 
[10:29:54.969]             setwd(...future.workdir)
[10:29:54.969]         {
[10:29:54.969]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:54.969]                 ...future.oldOptions$nwarnings <- NULL
[10:29:54.969]             }
[10:29:54.969]             base::options(...future.oldOptions)
[10:29:54.969]             if (.Platform$OS.type == "windows") {
[10:29:54.969]                 old_names <- names(...future.oldEnvVars)
[10:29:54.969]                 envs <- base::Sys.getenv()
[10:29:54.969]                 names <- names(envs)
[10:29:54.969]                 common <- intersect(names, old_names)
[10:29:54.969]                 added <- setdiff(names, old_names)
[10:29:54.969]                 removed <- setdiff(old_names, names)
[10:29:54.969]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:54.969]                   envs[common]]
[10:29:54.969]                 NAMES <- toupper(changed)
[10:29:54.969]                 args <- list()
[10:29:54.969]                 for (kk in seq_along(NAMES)) {
[10:29:54.969]                   name <- changed[[kk]]
[10:29:54.969]                   NAME <- NAMES[[kk]]
[10:29:54.969]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.969]                     next
[10:29:54.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.969]                 }
[10:29:54.969]                 NAMES <- toupper(added)
[10:29:54.969]                 for (kk in seq_along(NAMES)) {
[10:29:54.969]                   name <- added[[kk]]
[10:29:54.969]                   NAME <- NAMES[[kk]]
[10:29:54.969]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.969]                     next
[10:29:54.969]                   args[[name]] <- ""
[10:29:54.969]                 }
[10:29:54.969]                 NAMES <- toupper(removed)
[10:29:54.969]                 for (kk in seq_along(NAMES)) {
[10:29:54.969]                   name <- removed[[kk]]
[10:29:54.969]                   NAME <- NAMES[[kk]]
[10:29:54.969]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:54.969]                     next
[10:29:54.969]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:54.969]                 }
[10:29:54.969]                 if (length(args) > 0) 
[10:29:54.969]                   base::do.call(base::Sys.setenv, args = args)
[10:29:54.969]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:54.969]             }
[10:29:54.969]             else {
[10:29:54.969]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:54.969]             }
[10:29:54.969]             {
[10:29:54.969]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:54.969]                   0L) {
[10:29:54.969]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:54.969]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:54.969]                   base::options(opts)
[10:29:54.969]                 }
[10:29:54.969]                 {
[10:29:54.969]                   {
[10:29:54.969]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:54.969]                     NULL
[10:29:54.969]                   }
[10:29:54.969]                   options(future.plan = NULL)
[10:29:54.969]                   if (is.na(NA_character_)) 
[10:29:54.969]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:54.969]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:54.969]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:54.969]                     .init = FALSE)
[10:29:54.969]                 }
[10:29:54.969]             }
[10:29:54.969]         }
[10:29:54.969]     })
[10:29:54.969]     if (TRUE) {
[10:29:54.969]         base::sink(type = "output", split = FALSE)
[10:29:54.969]         if (TRUE) {
[10:29:54.969]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:54.969]         }
[10:29:54.969]         else {
[10:29:54.969]             ...future.result["stdout"] <- base::list(NULL)
[10:29:54.969]         }
[10:29:54.969]         base::close(...future.stdout)
[10:29:54.969]         ...future.stdout <- NULL
[10:29:54.969]     }
[10:29:54.969]     ...future.result$conditions <- ...future.conditions
[10:29:54.969]     ...future.result$finished <- base::Sys.time()
[10:29:54.969]     ...future.result
[10:29:54.969] }
[10:29:54.972] assign_globals() ...
[10:29:54.972] List of 5
[10:29:54.972]  $ ...future.FUN            :function (object, ...)  
[10:29:54.972]  $ future.call.arguments    : list()
[10:29:54.972]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:54.972]  $ ...future.elements_ii    :List of 1
[10:29:54.972]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:54.972]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[10:29:54.972]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:54.972]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:54.972]  $ ...future.seeds_ii       : NULL
[10:29:54.972]  $ ...future.globals.maxSize: NULL
[10:29:54.972]  - attr(*, "where")=List of 5
[10:29:54.972]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:54.972]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:54.972]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:54.972]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:54.972]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:54.972]  - attr(*, "resolved")= logi FALSE
[10:29:54.972]  - attr(*, "total_size")= num 1240
[10:29:54.972]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:54.972]  - attr(*, "already-done")= logi TRUE
[10:29:54.979] - copied ‘...future.FUN’ to environment
[10:29:54.980] - copied ‘future.call.arguments’ to environment
[10:29:54.980] - copied ‘...future.elements_ii’ to environment
[10:29:54.980] - copied ‘...future.seeds_ii’ to environment
[10:29:54.980] - copied ‘...future.globals.maxSize’ to environment
[10:29:54.980] assign_globals() ... done
[10:29:54.980] requestCore(): workers = 2
[10:29:54.983] MulticoreFuture started
[10:29:54.983] - Launch lazy future ... done
[10:29:54.983] run() for ‘MulticoreFuture’ ... done
[10:29:54.984] Created future:
[10:29:54.984] plan(): Setting new future strategy stack:
[10:29:54.984] List of future strategies:
[10:29:54.984] 1. sequential:
[10:29:54.984]    - args: function (..., envir = parent.frame())
[10:29:54.984]    - tweaked: FALSE
[10:29:54.984]    - call: NULL
[10:29:54.985] plan(): nbrOfWorkers() = 1
[10:29:54.988] plan(): Setting new future strategy stack:
[10:29:54.988] List of future strategies:
[10:29:54.988] 1. multicore:
[10:29:54.988]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:54.988]    - tweaked: FALSE
[10:29:54.988]    - call: plan(strategy)
[10:29:54.993] plan(): nbrOfWorkers() = 2
[10:29:54.984] MulticoreFuture:
[10:29:54.984] Label: ‘future_by-1’
[10:29:54.984] Expression:
[10:29:54.984] {
[10:29:54.984]     do.call(function(...) {
[10:29:54.984]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.984]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.984]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.984]             on.exit(options(oopts), add = TRUE)
[10:29:54.984]         }
[10:29:54.984]         {
[10:29:54.984]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.984]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.984]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.984]             })
[10:29:54.984]         }
[10:29:54.984]     }, args = future.call.arguments)
[10:29:54.984] }
[10:29:54.984] Lazy evaluation: FALSE
[10:29:54.984] Asynchronous evaluation: TRUE
[10:29:54.984] Local evaluation: TRUE
[10:29:54.984] Environment: 0x556dd627b420
[10:29:54.984] Capture standard output: TRUE
[10:29:54.984] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:54.984] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:54.984] Packages: <none>
[10:29:54.984] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:54.984] Resolved: TRUE
[10:29:54.984] Value: <not collected>
[10:29:54.984] Conditions captured: <none>
[10:29:54.984] Early signaling: FALSE
[10:29:54.984] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:54.984] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:54.994] Chunk #1 of 2 ... DONE
[10:29:54.994] Chunk #2 of 2 ...
[10:29:54.995]  - Finding globals in 'X' for chunk #2 ...
[10:29:54.995] getGlobalsAndPackages() ...
[10:29:54.995] Searching for globals...
[10:29:54.996] 
[10:29:54.996] Searching for globals ... DONE
[10:29:54.996] - globals: [0] <none>
[10:29:54.996] getGlobalsAndPackages() ... DONE
[10:29:54.996]    + additional globals found: [n=0] 
[10:29:54.997]    + additional namespaces needed: [n=0] 
[10:29:54.997]  - Finding globals in 'X' for chunk #2 ... DONE
[10:29:54.997]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:54.997]  - seeds: <none>
[10:29:54.997]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.997] getGlobalsAndPackages() ...
[10:29:54.997] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.998] Resolving globals: FALSE
[10:29:54.998] Tweak future expression to call with '...' arguments ...
[10:29:54.998] {
[10:29:54.998]     do.call(function(...) {
[10:29:54.998]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:54.998]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:54.998]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:54.998]             on.exit(options(oopts), add = TRUE)
[10:29:54.998]         }
[10:29:54.998]         {
[10:29:54.998]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:54.998]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:54.998]                 ...future.FUN(...future.X_jj, ...)
[10:29:54.998]             })
[10:29:54.998]         }
[10:29:54.998]     }, args = future.call.arguments)
[10:29:54.998] }
[10:29:54.998] Tweak future expression to call with '...' arguments ... DONE
[10:29:54.999] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:54.999] 
[10:29:54.999] getGlobalsAndPackages() ... DONE
[10:29:55.000] run() for ‘Future’ ...
[10:29:55.000] - state: ‘created’
[10:29:55.000] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:55.005] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:55.005] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:55.005]   - Field: ‘label’
[10:29:55.005]   - Field: ‘local’
[10:29:55.006]   - Field: ‘owner’
[10:29:55.006]   - Field: ‘envir’
[10:29:55.006]   - Field: ‘workers’
[10:29:55.006]   - Field: ‘packages’
[10:29:55.006]   - Field: ‘gc’
[10:29:55.006]   - Field: ‘job’
[10:29:55.006]   - Field: ‘conditions’
[10:29:55.006]   - Field: ‘expr’
[10:29:55.007]   - Field: ‘uuid’
[10:29:55.007]   - Field: ‘seed’
[10:29:55.007]   - Field: ‘version’
[10:29:55.007]   - Field: ‘result’
[10:29:55.007]   - Field: ‘asynchronous’
[10:29:55.007]   - Field: ‘calls’
[10:29:55.007]   - Field: ‘globals’
[10:29:55.007]   - Field: ‘stdout’
[10:29:55.008]   - Field: ‘earlySignal’
[10:29:55.008]   - Field: ‘lazy’
[10:29:55.008]   - Field: ‘state’
[10:29:55.008] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:55.008] - Launch lazy future ...
[10:29:55.009] Packages needed by the future expression (n = 0): <none>
[10:29:55.009] Packages needed by future strategies (n = 0): <none>
[10:29:55.010] {
[10:29:55.010]     {
[10:29:55.010]         {
[10:29:55.010]             ...future.startTime <- base::Sys.time()
[10:29:55.010]             {
[10:29:55.010]                 {
[10:29:55.010]                   {
[10:29:55.010]                     {
[10:29:55.010]                       base::local({
[10:29:55.010]                         has_future <- base::requireNamespace("future", 
[10:29:55.010]                           quietly = TRUE)
[10:29:55.010]                         if (has_future) {
[10:29:55.010]                           ns <- base::getNamespace("future")
[10:29:55.010]                           version <- ns[[".package"]][["version"]]
[10:29:55.010]                           if (is.null(version)) 
[10:29:55.010]                             version <- utils::packageVersion("future")
[10:29:55.010]                         }
[10:29:55.010]                         else {
[10:29:55.010]                           version <- NULL
[10:29:55.010]                         }
[10:29:55.010]                         if (!has_future || version < "1.8.0") {
[10:29:55.010]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:55.010]                             "", base::R.version$version.string), 
[10:29:55.010]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:55.010]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:55.010]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:55.010]                               "release", "version")], collapse = " "), 
[10:29:55.010]                             hostname = base::Sys.info()[["nodename"]])
[10:29:55.010]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:55.010]                             info)
[10:29:55.010]                           info <- base::paste(info, collapse = "; ")
[10:29:55.010]                           if (!has_future) {
[10:29:55.010]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:55.010]                               info)
[10:29:55.010]                           }
[10:29:55.010]                           else {
[10:29:55.010]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:55.010]                               info, version)
[10:29:55.010]                           }
[10:29:55.010]                           base::stop(msg)
[10:29:55.010]                         }
[10:29:55.010]                       })
[10:29:55.010]                     }
[10:29:55.010]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:55.010]                     base::options(mc.cores = 1L)
[10:29:55.010]                   }
[10:29:55.010]                   ...future.strategy.old <- future::plan("list")
[10:29:55.010]                   options(future.plan = NULL)
[10:29:55.010]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:55.010]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:55.010]                 }
[10:29:55.010]                 ...future.workdir <- getwd()
[10:29:55.010]             }
[10:29:55.010]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:55.010]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:55.010]         }
[10:29:55.010]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:55.010]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:55.010]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:55.010]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:55.010]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:55.010]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:55.010]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:55.010]             base::names(...future.oldOptions))
[10:29:55.010]     }
[10:29:55.010]     if (FALSE) {
[10:29:55.010]     }
[10:29:55.010]     else {
[10:29:55.010]         if (TRUE) {
[10:29:55.010]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:55.010]                 open = "w")
[10:29:55.010]         }
[10:29:55.010]         else {
[10:29:55.010]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:55.010]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:55.010]         }
[10:29:55.010]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:55.010]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:55.010]             base::sink(type = "output", split = FALSE)
[10:29:55.010]             base::close(...future.stdout)
[10:29:55.010]         }, add = TRUE)
[10:29:55.010]     }
[10:29:55.010]     ...future.frame <- base::sys.nframe()
[10:29:55.010]     ...future.conditions <- base::list()
[10:29:55.010]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:55.010]     if (FALSE) {
[10:29:55.010]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:55.010]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:55.010]     }
[10:29:55.010]     ...future.result <- base::tryCatch({
[10:29:55.010]         base::withCallingHandlers({
[10:29:55.010]             ...future.value <- base::withVisible(base::local({
[10:29:55.010]                 withCallingHandlers({
[10:29:55.010]                   {
[10:29:55.010]                     do.call(function(...) {
[10:29:55.010]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:55.010]                       if (!identical(...future.globals.maxSize.org, 
[10:29:55.010]                         ...future.globals.maxSize)) {
[10:29:55.010]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:55.010]                         on.exit(options(oopts), add = TRUE)
[10:29:55.010]                       }
[10:29:55.010]                       {
[10:29:55.010]                         lapply(seq_along(...future.elements_ii), 
[10:29:55.010]                           FUN = function(jj) {
[10:29:55.010]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:55.010]                             ...future.FUN(...future.X_jj, ...)
[10:29:55.010]                           })
[10:29:55.010]                       }
[10:29:55.010]                     }, args = future.call.arguments)
[10:29:55.010]                   }
[10:29:55.010]                 }, immediateCondition = function(cond) {
[10:29:55.010]                   save_rds <- function (object, pathname, ...) 
[10:29:55.010]                   {
[10:29:55.010]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:55.010]                     if (file_test("-f", pathname_tmp)) {
[10:29:55.010]                       fi_tmp <- file.info(pathname_tmp)
[10:29:55.010]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:55.010]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:55.010]                         fi_tmp[["mtime"]])
[10:29:55.010]                     }
[10:29:55.010]                     tryCatch({
[10:29:55.010]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:55.010]                     }, error = function(ex) {
[10:29:55.010]                       msg <- conditionMessage(ex)
[10:29:55.010]                       fi_tmp <- file.info(pathname_tmp)
[10:29:55.010]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:55.010]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:55.010]                         fi_tmp[["mtime"]], msg)
[10:29:55.010]                       ex$message <- msg
[10:29:55.010]                       stop(ex)
[10:29:55.010]                     })
[10:29:55.010]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:55.010]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:55.010]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:55.010]                       fi_tmp <- file.info(pathname_tmp)
[10:29:55.010]                       fi <- file.info(pathname)
[10:29:55.010]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:55.010]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:55.010]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:55.010]                         fi[["size"]], fi[["mtime"]])
[10:29:55.010]                       stop(msg)
[10:29:55.010]                     }
[10:29:55.010]                     invisible(pathname)
[10:29:55.010]                   }
[10:29:55.010]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:55.010]                     rootPath = tempdir()) 
[10:29:55.010]                   {
[10:29:55.010]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:55.010]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:55.010]                       tmpdir = path, fileext = ".rds")
[10:29:55.010]                     save_rds(obj, file)
[10:29:55.010]                   }
[10:29:55.010]                   saveImmediateCondition(cond, path = "/tmp/Rtmp11FQBX/.future/immediateConditions")
[10:29:55.010]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:55.010]                   {
[10:29:55.010]                     inherits <- base::inherits
[10:29:55.010]                     invokeRestart <- base::invokeRestart
[10:29:55.010]                     is.null <- base::is.null
[10:29:55.010]                     muffled <- FALSE
[10:29:55.010]                     if (inherits(cond, "message")) {
[10:29:55.010]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:55.010]                       if (muffled) 
[10:29:55.010]                         invokeRestart("muffleMessage")
[10:29:55.010]                     }
[10:29:55.010]                     else if (inherits(cond, "warning")) {
[10:29:55.010]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:55.010]                       if (muffled) 
[10:29:55.010]                         invokeRestart("muffleWarning")
[10:29:55.010]                     }
[10:29:55.010]                     else if (inherits(cond, "condition")) {
[10:29:55.010]                       if (!is.null(pattern)) {
[10:29:55.010]                         computeRestarts <- base::computeRestarts
[10:29:55.010]                         grepl <- base::grepl
[10:29:55.010]                         restarts <- computeRestarts(cond)
[10:29:55.010]                         for (restart in restarts) {
[10:29:55.010]                           name <- restart$name
[10:29:55.010]                           if (is.null(name)) 
[10:29:55.010]                             next
[10:29:55.010]                           if (!grepl(pattern, name)) 
[10:29:55.010]                             next
[10:29:55.010]                           invokeRestart(restart)
[10:29:55.010]                           muffled <- TRUE
[10:29:55.010]                           break
[10:29:55.010]                         }
[10:29:55.010]                       }
[10:29:55.010]                     }
[10:29:55.010]                     invisible(muffled)
[10:29:55.010]                   }
[10:29:55.010]                   muffleCondition(cond)
[10:29:55.010]                 })
[10:29:55.010]             }))
[10:29:55.010]             future::FutureResult(value = ...future.value$value, 
[10:29:55.010]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:55.010]                   ...future.rng), globalenv = if (FALSE) 
[10:29:55.010]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:55.010]                     ...future.globalenv.names))
[10:29:55.010]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:55.010]         }, condition = base::local({
[10:29:55.010]             c <- base::c
[10:29:55.010]             inherits <- base::inherits
[10:29:55.010]             invokeRestart <- base::invokeRestart
[10:29:55.010]             length <- base::length
[10:29:55.010]             list <- base::list
[10:29:55.010]             seq.int <- base::seq.int
[10:29:55.010]             signalCondition <- base::signalCondition
[10:29:55.010]             sys.calls <- base::sys.calls
[10:29:55.010]             `[[` <- base::`[[`
[10:29:55.010]             `+` <- base::`+`
[10:29:55.010]             `<<-` <- base::`<<-`
[10:29:55.010]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:55.010]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:55.010]                   3L)]
[10:29:55.010]             }
[10:29:55.010]             function(cond) {
[10:29:55.010]                 is_error <- inherits(cond, "error")
[10:29:55.010]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:55.010]                   NULL)
[10:29:55.010]                 if (is_error) {
[10:29:55.010]                   sessionInformation <- function() {
[10:29:55.010]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:55.010]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:55.010]                       search = base::search(), system = base::Sys.info())
[10:29:55.010]                   }
[10:29:55.010]                   ...future.conditions[[length(...future.conditions) + 
[10:29:55.010]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:55.010]                     cond$call), session = sessionInformation(), 
[10:29:55.010]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:55.010]                   signalCondition(cond)
[10:29:55.010]                 }
[10:29:55.010]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:55.010]                 "immediateCondition"))) {
[10:29:55.010]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:55.010]                   ...future.conditions[[length(...future.conditions) + 
[10:29:55.010]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:55.010]                   if (TRUE && !signal) {
[10:29:55.010]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:55.010]                     {
[10:29:55.010]                       inherits <- base::inherits
[10:29:55.010]                       invokeRestart <- base::invokeRestart
[10:29:55.010]                       is.null <- base::is.null
[10:29:55.010]                       muffled <- FALSE
[10:29:55.010]                       if (inherits(cond, "message")) {
[10:29:55.010]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:55.010]                         if (muffled) 
[10:29:55.010]                           invokeRestart("muffleMessage")
[10:29:55.010]                       }
[10:29:55.010]                       else if (inherits(cond, "warning")) {
[10:29:55.010]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:55.010]                         if (muffled) 
[10:29:55.010]                           invokeRestart("muffleWarning")
[10:29:55.010]                       }
[10:29:55.010]                       else if (inherits(cond, "condition")) {
[10:29:55.010]                         if (!is.null(pattern)) {
[10:29:55.010]                           computeRestarts <- base::computeRestarts
[10:29:55.010]                           grepl <- base::grepl
[10:29:55.010]                           restarts <- computeRestarts(cond)
[10:29:55.010]                           for (restart in restarts) {
[10:29:55.010]                             name <- restart$name
[10:29:55.010]                             if (is.null(name)) 
[10:29:55.010]                               next
[10:29:55.010]                             if (!grepl(pattern, name)) 
[10:29:55.010]                               next
[10:29:55.010]                             invokeRestart(restart)
[10:29:55.010]                             muffled <- TRUE
[10:29:55.010]                             break
[10:29:55.010]                           }
[10:29:55.010]                         }
[10:29:55.010]                       }
[10:29:55.010]                       invisible(muffled)
[10:29:55.010]                     }
[10:29:55.010]                     muffleCondition(cond, pattern = "^muffle")
[10:29:55.010]                   }
[10:29:55.010]                 }
[10:29:55.010]                 else {
[10:29:55.010]                   if (TRUE) {
[10:29:55.010]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:55.010]                     {
[10:29:55.010]                       inherits <- base::inherits
[10:29:55.010]                       invokeRestart <- base::invokeRestart
[10:29:55.010]                       is.null <- base::is.null
[10:29:55.010]                       muffled <- FALSE
[10:29:55.010]                       if (inherits(cond, "message")) {
[10:29:55.010]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:55.010]                         if (muffled) 
[10:29:55.010]                           invokeRestart("muffleMessage")
[10:29:55.010]                       }
[10:29:55.010]                       else if (inherits(cond, "warning")) {
[10:29:55.010]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:55.010]                         if (muffled) 
[10:29:55.010]                           invokeRestart("muffleWarning")
[10:29:55.010]                       }
[10:29:55.010]                       else if (inherits(cond, "condition")) {
[10:29:55.010]                         if (!is.null(pattern)) {
[10:29:55.010]                           computeRestarts <- base::computeRestarts
[10:29:55.010]                           grepl <- base::grepl
[10:29:55.010]                           restarts <- computeRestarts(cond)
[10:29:55.010]                           for (restart in restarts) {
[10:29:55.010]                             name <- restart$name
[10:29:55.010]                             if (is.null(name)) 
[10:29:55.010]                               next
[10:29:55.010]                             if (!grepl(pattern, name)) 
[10:29:55.010]                               next
[10:29:55.010]                             invokeRestart(restart)
[10:29:55.010]                             muffled <- TRUE
[10:29:55.010]                             break
[10:29:55.010]                           }
[10:29:55.010]                         }
[10:29:55.010]                       }
[10:29:55.010]                       invisible(muffled)
[10:29:55.010]                     }
[10:29:55.010]                     muffleCondition(cond, pattern = "^muffle")
[10:29:55.010]                   }
[10:29:55.010]                 }
[10:29:55.010]             }
[10:29:55.010]         }))
[10:29:55.010]     }, error = function(ex) {
[10:29:55.010]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:55.010]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:55.010]                 ...future.rng), started = ...future.startTime, 
[10:29:55.010]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:55.010]             version = "1.8"), class = "FutureResult")
[10:29:55.010]     }, finally = {
[10:29:55.010]         if (!identical(...future.workdir, getwd())) 
[10:29:55.010]             setwd(...future.workdir)
[10:29:55.010]         {
[10:29:55.010]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:55.010]                 ...future.oldOptions$nwarnings <- NULL
[10:29:55.010]             }
[10:29:55.010]             base::options(...future.oldOptions)
[10:29:55.010]             if (.Platform$OS.type == "windows") {
[10:29:55.010]                 old_names <- names(...future.oldEnvVars)
[10:29:55.010]                 envs <- base::Sys.getenv()
[10:29:55.010]                 names <- names(envs)
[10:29:55.010]                 common <- intersect(names, old_names)
[10:29:55.010]                 added <- setdiff(names, old_names)
[10:29:55.010]                 removed <- setdiff(old_names, names)
[10:29:55.010]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:55.010]                   envs[common]]
[10:29:55.010]                 NAMES <- toupper(changed)
[10:29:55.010]                 args <- list()
[10:29:55.010]                 for (kk in seq_along(NAMES)) {
[10:29:55.010]                   name <- changed[[kk]]
[10:29:55.010]                   NAME <- NAMES[[kk]]
[10:29:55.010]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:55.010]                     next
[10:29:55.010]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:55.010]                 }
[10:29:55.010]                 NAMES <- toupper(added)
[10:29:55.010]                 for (kk in seq_along(NAMES)) {
[10:29:55.010]                   name <- added[[kk]]
[10:29:55.010]                   NAME <- NAMES[[kk]]
[10:29:55.010]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:55.010]                     next
[10:29:55.010]                   args[[name]] <- ""
[10:29:55.010]                 }
[10:29:55.010]                 NAMES <- toupper(removed)
[10:29:55.010]                 for (kk in seq_along(NAMES)) {
[10:29:55.010]                   name <- removed[[kk]]
[10:29:55.010]                   NAME <- NAMES[[kk]]
[10:29:55.010]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:55.010]                     next
[10:29:55.010]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:55.010]                 }
[10:29:55.010]                 if (length(args) > 0) 
[10:29:55.010]                   base::do.call(base::Sys.setenv, args = args)
[10:29:55.010]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:55.010]             }
[10:29:55.010]             else {
[10:29:55.010]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:55.010]             }
[10:29:55.010]             {
[10:29:55.010]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:55.010]                   0L) {
[10:29:55.010]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:55.010]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:55.010]                   base::options(opts)
[10:29:55.010]                 }
[10:29:55.010]                 {
[10:29:55.010]                   {
[10:29:55.010]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:55.010]                     NULL
[10:29:55.010]                   }
[10:29:55.010]                   options(future.plan = NULL)
[10:29:55.010]                   if (is.na(NA_character_)) 
[10:29:55.010]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:55.010]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:55.010]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:55.010]                     .init = FALSE)
[10:29:55.010]                 }
[10:29:55.010]             }
[10:29:55.010]         }
[10:29:55.010]     })
[10:29:55.010]     if (TRUE) {
[10:29:55.010]         base::sink(type = "output", split = FALSE)
[10:29:55.010]         if (TRUE) {
[10:29:55.010]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:55.010]         }
[10:29:55.010]         else {
[10:29:55.010]             ...future.result["stdout"] <- base::list(NULL)
[10:29:55.010]         }
[10:29:55.010]         base::close(...future.stdout)
[10:29:55.010]         ...future.stdout <- NULL
[10:29:55.010]     }
[10:29:55.010]     ...future.result$conditions <- ...future.conditions
[10:29:55.010]     ...future.result$finished <- base::Sys.time()
[10:29:55.010]     ...future.result
[10:29:55.010] }
[10:29:55.013] assign_globals() ...
[10:29:55.013] List of 5
[10:29:55.013]  $ ...future.FUN            :function (object, ...)  
[10:29:55.013]  $ future.call.arguments    : list()
[10:29:55.013]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:55.013]  $ ...future.elements_ii    :List of 2
[10:29:55.013]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:55.013]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[10:29:55.013]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:55.013]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[10:29:55.013]   ..$ :'data.frame':	18 obs. of  3 variables:
[10:29:55.013]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[10:29:55.013]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[10:29:55.013]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[10:29:55.013]  $ ...future.seeds_ii       : NULL
[10:29:55.013]  $ ...future.globals.maxSize: NULL
[10:29:55.013]  - attr(*, "where")=List of 5
[10:29:55.013]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:55.013]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:55.013]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:55.013]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:55.013]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:55.013]  - attr(*, "resolved")= logi FALSE
[10:29:55.013]  - attr(*, "total_size")= num 1240
[10:29:55.013]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:55.013]  - attr(*, "already-done")= logi TRUE
[10:29:55.029] - copied ‘...future.FUN’ to environment
[10:29:55.029] - copied ‘future.call.arguments’ to environment
[10:29:55.029] - copied ‘...future.elements_ii’ to environment
[10:29:55.029] - copied ‘...future.seeds_ii’ to environment
[10:29:55.029] - copied ‘...future.globals.maxSize’ to environment
[10:29:55.029] assign_globals() ... done
[10:29:55.030] requestCore(): workers = 2
[10:29:55.032] MulticoreFuture started
[10:29:55.033] - Launch lazy future ... done
[10:29:55.033] run() for ‘MulticoreFuture’ ... done
[10:29:55.033] Created future:
[10:29:55.034] plan(): Setting new future strategy stack:
[10:29:55.034] List of future strategies:
[10:29:55.034] 1. sequential:
[10:29:55.034]    - args: function (..., envir = parent.frame())
[10:29:55.034]    - tweaked: FALSE
[10:29:55.034]    - call: NULL
[10:29:55.035] plan(): nbrOfWorkers() = 1
[10:29:55.039] plan(): Setting new future strategy stack:
[10:29:55.039] List of future strategies:
[10:29:55.039] 1. multicore:
[10:29:55.039]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:55.039]    - tweaked: FALSE
[10:29:55.039]    - call: plan(strategy)
[10:29:55.044] plan(): nbrOfWorkers() = 2
[10:29:55.033] MulticoreFuture:
[10:29:55.033] Label: ‘future_by-2’
[10:29:55.033] Expression:
[10:29:55.033] {
[10:29:55.033]     do.call(function(...) {
[10:29:55.033]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:55.033]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:55.033]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:55.033]             on.exit(options(oopts), add = TRUE)
[10:29:55.033]         }
[10:29:55.033]         {
[10:29:55.033]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:55.033]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:55.033]                 ...future.FUN(...future.X_jj, ...)
[10:29:55.033]             })
[10:29:55.033]         }
[10:29:55.033]     }, args = future.call.arguments)
[10:29:55.033] }
[10:29:55.033] Lazy evaluation: FALSE
[10:29:55.033] Asynchronous evaluation: TRUE
[10:29:55.033] Local evaluation: TRUE
[10:29:55.033] Environment: 0x556dd627b420
[10:29:55.033] Capture standard output: TRUE
[10:29:55.033] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:55.033] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:55.033] Packages: <none>
[10:29:55.033] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:55.033] Resolved: TRUE
[10:29:55.033] Value: <not collected>
[10:29:55.033] Conditions captured: <none>
[10:29:55.033] Early signaling: FALSE
[10:29:55.033] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:55.033] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:55.045] Chunk #2 of 2 ... DONE
[10:29:55.045] Launching 2 futures (chunks) ... DONE
[10:29:55.046] Resolving 2 futures (chunks) ...
[10:29:55.046] resolve() on list ...
[10:29:55.046]  recursive: 0
[10:29:55.046]  length: 2
[10:29:55.046] 
[10:29:55.047] Future #1
[10:29:55.047] result() for MulticoreFuture ...
[10:29:55.048] result() for MulticoreFuture ...
[10:29:55.048] result() for MulticoreFuture ... done
[10:29:55.048] result() for MulticoreFuture ... done
[10:29:55.048] result() for MulticoreFuture ...
[10:29:55.048] result() for MulticoreFuture ... done
[10:29:55.048] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:29:55.049] - nx: 2
[10:29:55.049] - relay: TRUE
[10:29:55.049] - stdout: TRUE
[10:29:55.049] - signal: TRUE
[10:29:55.049] - resignal: FALSE
[10:29:55.049] - force: TRUE
[10:29:55.049] - relayed: [n=2] FALSE, FALSE
[10:29:55.050] - queued futures: [n=2] FALSE, FALSE
[10:29:55.050]  - until=1
[10:29:55.050]  - relaying element #1
[10:29:55.050] result() for MulticoreFuture ...
[10:29:55.050] result() for MulticoreFuture ... done
[10:29:55.050] result() for MulticoreFuture ...
[10:29:55.050] result() for MulticoreFuture ... done
[10:29:55.051] result() for MulticoreFuture ...
[10:29:55.051] result() for MulticoreFuture ... done
[10:29:55.051] result() for MulticoreFuture ...
[10:29:55.051] result() for MulticoreFuture ... done
[10:29:55.051] - relayed: [n=2] TRUE, FALSE
[10:29:55.051] - queued futures: [n=2] TRUE, FALSE
[10:29:55.051] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:29:55.052]  length: 1 (resolved future 1)
[10:29:55.052] Future #2
[10:29:55.052] result() for MulticoreFuture ...
[10:29:55.053] result() for MulticoreFuture ...
[10:29:55.053] result() for MulticoreFuture ... done
[10:29:55.053] result() for MulticoreFuture ... done
[10:29:55.054] result() for MulticoreFuture ...
[10:29:55.054] result() for MulticoreFuture ... done
[10:29:55.054] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:29:55.054] - nx: 2
[10:29:55.054] - relay: TRUE
[10:29:55.054] - stdout: TRUE
[10:29:55.054] - signal: TRUE
[10:29:55.054] - resignal: FALSE
[10:29:55.055] - force: TRUE
[10:29:55.055] - relayed: [n=2] TRUE, FALSE
[10:29:55.055] - queued futures: [n=2] TRUE, FALSE
[10:29:55.055]  - until=2
[10:29:55.055]  - relaying element #2
[10:29:55.055] result() for MulticoreFuture ...
[10:29:55.055] result() for MulticoreFuture ... done
[10:29:55.055] result() for MulticoreFuture ...
[10:29:55.055] result() for MulticoreFuture ... done
[10:29:55.056] result() for MulticoreFuture ...
[10:29:55.056] result() for MulticoreFuture ... done
[10:29:55.056] result() for MulticoreFuture ...
[10:29:55.056] result() for MulticoreFuture ... done
[10:29:55.056] - relayed: [n=2] TRUE, TRUE
[10:29:55.056] - queued futures: [n=2] TRUE, TRUE
[10:29:55.056] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:29:55.056]  length: 0 (resolved future 2)
[10:29:55.057] Relaying remaining futures
[10:29:55.057] signalConditionsASAP(NULL, pos=0) ...
[10:29:55.057] - nx: 2
[10:29:55.057] - relay: TRUE
[10:29:55.057] - stdout: TRUE
[10:29:55.057] - signal: TRUE
[10:29:55.057] - resignal: FALSE
[10:29:55.057] - force: TRUE
[10:29:55.057] - relayed: [n=2] TRUE, TRUE
[10:29:55.058] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:55.058] - relayed: [n=2] TRUE, TRUE
[10:29:55.058] - queued futures: [n=2] TRUE, TRUE
[10:29:55.058] signalConditionsASAP(NULL, pos=0) ... done
[10:29:55.058] resolve() on list ... DONE
[10:29:55.058] result() for MulticoreFuture ...
[10:29:55.058] result() for MulticoreFuture ... done
[10:29:55.058] result() for MulticoreFuture ...
[10:29:55.059] result() for MulticoreFuture ... done
[10:29:55.059] result() for MulticoreFuture ...
[10:29:55.059] result() for MulticoreFuture ... done
[10:29:55.059] result() for MulticoreFuture ...
[10:29:55.059] result() for MulticoreFuture ... done
[10:29:55.059]  - Number of value chunks collected: 2
[10:29:55.059] Resolving 2 futures (chunks) ... DONE
[10:29:55.060] Reducing values from 2 chunks ...
[10:29:55.060]  - Number of values collected after concatenation: 3
[10:29:55.060]  - Number of values expected: 3
[10:29:55.060] Reducing values from 2 chunks ... DONE
[10:29:55.060] future_lapply() ... DONE
[10:29:55.060] future_by_internal() ... DONE
[10:29:55.061] future_by_internal() ...
- plan('multisession') ...
[10:29:55.062] plan(): Setting new future strategy stack:
[10:29:55.062] List of future strategies:
[10:29:55.062] 1. multisession:
[10:29:55.062]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:29:55.062]    - tweaked: FALSE
[10:29:55.062]    - call: plan(strategy)
[10:29:55.063] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:29:55.063] multisession:
[10:29:55.063] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:29:55.063] - tweaked: FALSE
[10:29:55.063] - call: plan(strategy)
[10:29:55.071] getGlobalsAndPackages() ...
[10:29:55.071] Not searching for globals
[10:29:55.071] - globals: [0] <none>
[10:29:55.071] getGlobalsAndPackages() ... DONE
[10:29:55.072] [local output] makeClusterPSOCK() ...
[10:29:55.127] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:29:55.128] [local output] Base port: 11496
[10:29:55.128] [local output] Getting setup options for 2 cluster nodes ...
[10:29:55.129] [local output]  - Node 1 of 2 ...
[10:29:55.129] [local output] localMachine=TRUE => revtunnel=FALSE

[10:29:55.130] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp11FQBX/worker.rank=1.parallelly.parent=68412.10b3c4ebe2a29.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp11FQBX/worker.rank=1.parallelly.parent=68412.10b3c4ebe2a29.pid")'’
[10:29:55.325] - Possible to infer worker's PID: TRUE
[10:29:55.326] [local output] Rscript port: 11496

[10:29:55.326] [local output]  - Node 2 of 2 ...
[10:29:55.327] [local output] localMachine=TRUE => revtunnel=FALSE

[10:29:55.327] [local output] Rscript port: 11496

[10:29:55.328] [local output] Getting setup options for 2 cluster nodes ... done
[10:29:55.328] [local output]  - Parallel setup requested for some PSOCK nodes
[10:29:55.328] [local output] Setting up PSOCK nodes in parallel
[10:29:55.328] List of 36
[10:29:55.328]  $ worker          : chr "localhost"
[10:29:55.328]   ..- attr(*, "localhost")= logi TRUE
[10:29:55.328]  $ master          : chr "localhost"
[10:29:55.328]  $ port            : int 11496
[10:29:55.328]  $ connectTimeout  : num 120
[10:29:55.328]  $ timeout         : num 2592000
[10:29:55.328]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:29:55.328]  $ homogeneous     : logi TRUE
[10:29:55.328]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:29:55.328]  $ rscript_envs    : NULL
[10:29:55.328]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:29:55.328]  $ rscript_startup : NULL
[10:29:55.328]  $ rscript_sh      : chr "sh"
[10:29:55.328]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:29:55.328]  $ methods         : logi TRUE
[10:29:55.328]  $ socketOptions   : chr "no-delay"
[10:29:55.328]  $ useXDR          : logi FALSE
[10:29:55.328]  $ outfile         : chr "/dev/null"
[10:29:55.328]  $ renice          : int NA
[10:29:55.328]  $ rshcmd          : NULL
[10:29:55.328]  $ user            : chr(0) 
[10:29:55.328]  $ revtunnel       : logi FALSE
[10:29:55.328]  $ rshlogfile      : NULL
[10:29:55.328]  $ rshopts         : chr(0) 
[10:29:55.328]  $ rank            : int 1
[10:29:55.328]  $ manual          : logi FALSE
[10:29:55.328]  $ dryrun          : logi FALSE
[10:29:55.328]  $ quiet           : logi FALSE
[10:29:55.328]  $ setup_strategy  : chr "parallel"
[10:29:55.328]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:29:55.328]  $ pidfile         : chr "/tmp/Rtmp11FQBX/worker.rank=1.parallelly.parent=68412.10b3c4ebe2a29.pid"
[10:29:55.328]  $ rshcmd_label    : NULL
[10:29:55.328]  $ rsh_call        : NULL
[10:29:55.328]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:29:55.328]  $ localMachine    : logi TRUE
[10:29:55.328]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:29:55.328]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:29:55.328]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:29:55.328]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:29:55.328]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:29:55.328]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:29:55.328]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:29:55.328]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:29:55.328]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:29:55.328]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:29:55.328]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:29:55.328]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:29:55.328]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:29:55.328]  $ arguments       :List of 28
[10:29:55.328]   ..$ worker          : chr "localhost"
[10:29:55.328]   ..$ master          : NULL
[10:29:55.328]   ..$ port            : int 11496
[10:29:55.328]   ..$ connectTimeout  : num 120
[10:29:55.328]   ..$ timeout         : num 2592000
[10:29:55.328]   ..$ rscript         : NULL
[10:29:55.328]   ..$ homogeneous     : NULL
[10:29:55.328]   ..$ rscript_args    : NULL
[10:29:55.328]   ..$ rscript_envs    : NULL
[10:29:55.328]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:29:55.328]   ..$ rscript_startup : NULL
[10:29:55.328]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:29:55.328]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:29:55.328]   ..$ methods         : logi TRUE
[10:29:55.328]   ..$ socketOptions   : chr "no-delay"
[10:29:55.328]   ..$ useXDR          : logi FALSE
[10:29:55.328]   ..$ outfile         : chr "/dev/null"
[10:29:55.328]   ..$ renice          : int NA
[10:29:55.328]   ..$ rshcmd          : NULL
[10:29:55.328]   ..$ user            : NULL
[10:29:55.328]   ..$ revtunnel       : logi NA
[10:29:55.328]   ..$ rshlogfile      : NULL
[10:29:55.328]   ..$ rshopts         : NULL
[10:29:55.328]   ..$ rank            : int 1
[10:29:55.328]   ..$ manual          : logi FALSE
[10:29:55.328]   ..$ dryrun          : logi FALSE
[10:29:55.328]   ..$ quiet           : logi FALSE
[10:29:55.328]   ..$ setup_strategy  : chr "parallel"
[10:29:55.328]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:29:55.345] [local output] System call to launch all workers:
[10:29:55.345] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp11FQBX/worker.rank=1.parallelly.parent=68412.10b3c4ebe2a29.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11496 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:29:55.346] [local output] Starting PSOCK main server
[10:29:55.351] [local output] Workers launched
[10:29:55.351] [local output] Waiting for workers to connect back
[10:29:55.352]  - [local output] 0 workers out of 2 ready
[10:29:55.596]  - [local output] 0 workers out of 2 ready
[10:29:55.597]  - [local output] 1 workers out of 2 ready
[10:29:55.604]  - [local output] 1 workers out of 2 ready
[10:29:55.604]  - [local output] 2 workers out of 2 ready
[10:29:55.604] [local output] Launching of workers completed
[10:29:55.605] [local output] Collecting session information from workers
[10:29:55.605] [local output]  - Worker #1 of 2
[10:29:55.606] [local output]  - Worker #2 of 2
[10:29:55.606] [local output] makeClusterPSOCK() ... done
[10:29:55.617] Packages needed by the future expression (n = 0): <none>
[10:29:55.617] Packages needed by future strategies (n = 0): <none>
[10:29:55.618] {
[10:29:55.618]     {
[10:29:55.618]         {
[10:29:55.618]             ...future.startTime <- base::Sys.time()
[10:29:55.618]             {
[10:29:55.618]                 {
[10:29:55.618]                   {
[10:29:55.618]                     {
[10:29:55.618]                       base::local({
[10:29:55.618]                         has_future <- base::requireNamespace("future", 
[10:29:55.618]                           quietly = TRUE)
[10:29:55.618]                         if (has_future) {
[10:29:55.618]                           ns <- base::getNamespace("future")
[10:29:55.618]                           version <- ns[[".package"]][["version"]]
[10:29:55.618]                           if (is.null(version)) 
[10:29:55.618]                             version <- utils::packageVersion("future")
[10:29:55.618]                         }
[10:29:55.618]                         else {
[10:29:55.618]                           version <- NULL
[10:29:55.618]                         }
[10:29:55.618]                         if (!has_future || version < "1.8.0") {
[10:29:55.618]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:55.618]                             "", base::R.version$version.string), 
[10:29:55.618]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:55.618]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:55.618]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:55.618]                               "release", "version")], collapse = " "), 
[10:29:55.618]                             hostname = base::Sys.info()[["nodename"]])
[10:29:55.618]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:55.618]                             info)
[10:29:55.618]                           info <- base::paste(info, collapse = "; ")
[10:29:55.618]                           if (!has_future) {
[10:29:55.618]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:55.618]                               info)
[10:29:55.618]                           }
[10:29:55.618]                           else {
[10:29:55.618]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:55.618]                               info, version)
[10:29:55.618]                           }
[10:29:55.618]                           base::stop(msg)
[10:29:55.618]                         }
[10:29:55.618]                       })
[10:29:55.618]                     }
[10:29:55.618]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:55.618]                     base::options(mc.cores = 1L)
[10:29:55.618]                   }
[10:29:55.618]                   ...future.strategy.old <- future::plan("list")
[10:29:55.618]                   options(future.plan = NULL)
[10:29:55.618]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:55.618]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:55.618]                 }
[10:29:55.618]                 ...future.workdir <- getwd()
[10:29:55.618]             }
[10:29:55.618]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:55.618]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:55.618]         }
[10:29:55.618]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:55.618]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:55.618]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:55.618]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:55.618]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:55.618]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:55.618]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:55.618]             base::names(...future.oldOptions))
[10:29:55.618]     }
[10:29:55.618]     if (FALSE) {
[10:29:55.618]     }
[10:29:55.618]     else {
[10:29:55.618]         if (TRUE) {
[10:29:55.618]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:55.618]                 open = "w")
[10:29:55.618]         }
[10:29:55.618]         else {
[10:29:55.618]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:55.618]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:55.618]         }
[10:29:55.618]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:55.618]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:55.618]             base::sink(type = "output", split = FALSE)
[10:29:55.618]             base::close(...future.stdout)
[10:29:55.618]         }, add = TRUE)
[10:29:55.618]     }
[10:29:55.618]     ...future.frame <- base::sys.nframe()
[10:29:55.618]     ...future.conditions <- base::list()
[10:29:55.618]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:55.618]     if (FALSE) {
[10:29:55.618]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:55.618]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:55.618]     }
[10:29:55.618]     ...future.result <- base::tryCatch({
[10:29:55.618]         base::withCallingHandlers({
[10:29:55.618]             ...future.value <- base::withVisible(base::local({
[10:29:55.618]                 ...future.makeSendCondition <- base::local({
[10:29:55.618]                   sendCondition <- NULL
[10:29:55.618]                   function(frame = 1L) {
[10:29:55.618]                     if (is.function(sendCondition)) 
[10:29:55.618]                       return(sendCondition)
[10:29:55.618]                     ns <- getNamespace("parallel")
[10:29:55.618]                     if (exists("sendData", mode = "function", 
[10:29:55.618]                       envir = ns)) {
[10:29:55.618]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:55.618]                         envir = ns)
[10:29:55.618]                       envir <- sys.frame(frame)
[10:29:55.618]                       master <- NULL
[10:29:55.618]                       while (!identical(envir, .GlobalEnv) && 
[10:29:55.618]                         !identical(envir, emptyenv())) {
[10:29:55.618]                         if (exists("master", mode = "list", envir = envir, 
[10:29:55.618]                           inherits = FALSE)) {
[10:29:55.618]                           master <- get("master", mode = "list", 
[10:29:55.618]                             envir = envir, inherits = FALSE)
[10:29:55.618]                           if (inherits(master, c("SOCKnode", 
[10:29:55.618]                             "SOCK0node"))) {
[10:29:55.618]                             sendCondition <<- function(cond) {
[10:29:55.618]                               data <- list(type = "VALUE", value = cond, 
[10:29:55.618]                                 success = TRUE)
[10:29:55.618]                               parallel_sendData(master, data)
[10:29:55.618]                             }
[10:29:55.618]                             return(sendCondition)
[10:29:55.618]                           }
[10:29:55.618]                         }
[10:29:55.618]                         frame <- frame + 1L
[10:29:55.618]                         envir <- sys.frame(frame)
[10:29:55.618]                       }
[10:29:55.618]                     }
[10:29:55.618]                     sendCondition <<- function(cond) NULL
[10:29:55.618]                   }
[10:29:55.618]                 })
[10:29:55.618]                 withCallingHandlers({
[10:29:55.618]                   NA
[10:29:55.618]                 }, immediateCondition = function(cond) {
[10:29:55.618]                   sendCondition <- ...future.makeSendCondition()
[10:29:55.618]                   sendCondition(cond)
[10:29:55.618]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:55.618]                   {
[10:29:55.618]                     inherits <- base::inherits
[10:29:55.618]                     invokeRestart <- base::invokeRestart
[10:29:55.618]                     is.null <- base::is.null
[10:29:55.618]                     muffled <- FALSE
[10:29:55.618]                     if (inherits(cond, "message")) {
[10:29:55.618]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:55.618]                       if (muffled) 
[10:29:55.618]                         invokeRestart("muffleMessage")
[10:29:55.618]                     }
[10:29:55.618]                     else if (inherits(cond, "warning")) {
[10:29:55.618]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:55.618]                       if (muffled) 
[10:29:55.618]                         invokeRestart("muffleWarning")
[10:29:55.618]                     }
[10:29:55.618]                     else if (inherits(cond, "condition")) {
[10:29:55.618]                       if (!is.null(pattern)) {
[10:29:55.618]                         computeRestarts <- base::computeRestarts
[10:29:55.618]                         grepl <- base::grepl
[10:29:55.618]                         restarts <- computeRestarts(cond)
[10:29:55.618]                         for (restart in restarts) {
[10:29:55.618]                           name <- restart$name
[10:29:55.618]                           if (is.null(name)) 
[10:29:55.618]                             next
[10:29:55.618]                           if (!grepl(pattern, name)) 
[10:29:55.618]                             next
[10:29:55.618]                           invokeRestart(restart)
[10:29:55.618]                           muffled <- TRUE
[10:29:55.618]                           break
[10:29:55.618]                         }
[10:29:55.618]                       }
[10:29:55.618]                     }
[10:29:55.618]                     invisible(muffled)
[10:29:55.618]                   }
[10:29:55.618]                   muffleCondition(cond)
[10:29:55.618]                 })
[10:29:55.618]             }))
[10:29:55.618]             future::FutureResult(value = ...future.value$value, 
[10:29:55.618]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:55.618]                   ...future.rng), globalenv = if (FALSE) 
[10:29:55.618]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:55.618]                     ...future.globalenv.names))
[10:29:55.618]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:55.618]         }, condition = base::local({
[10:29:55.618]             c <- base::c
[10:29:55.618]             inherits <- base::inherits
[10:29:55.618]             invokeRestart <- base::invokeRestart
[10:29:55.618]             length <- base::length
[10:29:55.618]             list <- base::list
[10:29:55.618]             seq.int <- base::seq.int
[10:29:55.618]             signalCondition <- base::signalCondition
[10:29:55.618]             sys.calls <- base::sys.calls
[10:29:55.618]             `[[` <- base::`[[`
[10:29:55.618]             `+` <- base::`+`
[10:29:55.618]             `<<-` <- base::`<<-`
[10:29:55.618]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:55.618]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:55.618]                   3L)]
[10:29:55.618]             }
[10:29:55.618]             function(cond) {
[10:29:55.618]                 is_error <- inherits(cond, "error")
[10:29:55.618]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:55.618]                   NULL)
[10:29:55.618]                 if (is_error) {
[10:29:55.618]                   sessionInformation <- function() {
[10:29:55.618]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:55.618]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:55.618]                       search = base::search(), system = base::Sys.info())
[10:29:55.618]                   }
[10:29:55.618]                   ...future.conditions[[length(...future.conditions) + 
[10:29:55.618]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:55.618]                     cond$call), session = sessionInformation(), 
[10:29:55.618]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:55.618]                   signalCondition(cond)
[10:29:55.618]                 }
[10:29:55.618]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:55.618]                 "immediateCondition"))) {
[10:29:55.618]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:55.618]                   ...future.conditions[[length(...future.conditions) + 
[10:29:55.618]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:55.618]                   if (TRUE && !signal) {
[10:29:55.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:55.618]                     {
[10:29:55.618]                       inherits <- base::inherits
[10:29:55.618]                       invokeRestart <- base::invokeRestart
[10:29:55.618]                       is.null <- base::is.null
[10:29:55.618]                       muffled <- FALSE
[10:29:55.618]                       if (inherits(cond, "message")) {
[10:29:55.618]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:55.618]                         if (muffled) 
[10:29:55.618]                           invokeRestart("muffleMessage")
[10:29:55.618]                       }
[10:29:55.618]                       else if (inherits(cond, "warning")) {
[10:29:55.618]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:55.618]                         if (muffled) 
[10:29:55.618]                           invokeRestart("muffleWarning")
[10:29:55.618]                       }
[10:29:55.618]                       else if (inherits(cond, "condition")) {
[10:29:55.618]                         if (!is.null(pattern)) {
[10:29:55.618]                           computeRestarts <- base::computeRestarts
[10:29:55.618]                           grepl <- base::grepl
[10:29:55.618]                           restarts <- computeRestarts(cond)
[10:29:55.618]                           for (restart in restarts) {
[10:29:55.618]                             name <- restart$name
[10:29:55.618]                             if (is.null(name)) 
[10:29:55.618]                               next
[10:29:55.618]                             if (!grepl(pattern, name)) 
[10:29:55.618]                               next
[10:29:55.618]                             invokeRestart(restart)
[10:29:55.618]                             muffled <- TRUE
[10:29:55.618]                             break
[10:29:55.618]                           }
[10:29:55.618]                         }
[10:29:55.618]                       }
[10:29:55.618]                       invisible(muffled)
[10:29:55.618]                     }
[10:29:55.618]                     muffleCondition(cond, pattern = "^muffle")
[10:29:55.618]                   }
[10:29:55.618]                 }
[10:29:55.618]                 else {
[10:29:55.618]                   if (TRUE) {
[10:29:55.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:55.618]                     {
[10:29:55.618]                       inherits <- base::inherits
[10:29:55.618]                       invokeRestart <- base::invokeRestart
[10:29:55.618]                       is.null <- base::is.null
[10:29:55.618]                       muffled <- FALSE
[10:29:55.618]                       if (inherits(cond, "message")) {
[10:29:55.618]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:55.618]                         if (muffled) 
[10:29:55.618]                           invokeRestart("muffleMessage")
[10:29:55.618]                       }
[10:29:55.618]                       else if (inherits(cond, "warning")) {
[10:29:55.618]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:55.618]                         if (muffled) 
[10:29:55.618]                           invokeRestart("muffleWarning")
[10:29:55.618]                       }
[10:29:55.618]                       else if (inherits(cond, "condition")) {
[10:29:55.618]                         if (!is.null(pattern)) {
[10:29:55.618]                           computeRestarts <- base::computeRestarts
[10:29:55.618]                           grepl <- base::grepl
[10:29:55.618]                           restarts <- computeRestarts(cond)
[10:29:55.618]                           for (restart in restarts) {
[10:29:55.618]                             name <- restart$name
[10:29:55.618]                             if (is.null(name)) 
[10:29:55.618]                               next
[10:29:55.618]                             if (!grepl(pattern, name)) 
[10:29:55.618]                               next
[10:29:55.618]                             invokeRestart(restart)
[10:29:55.618]                             muffled <- TRUE
[10:29:55.618]                             break
[10:29:55.618]                           }
[10:29:55.618]                         }
[10:29:55.618]                       }
[10:29:55.618]                       invisible(muffled)
[10:29:55.618]                     }
[10:29:55.618]                     muffleCondition(cond, pattern = "^muffle")
[10:29:55.618]                   }
[10:29:55.618]                 }
[10:29:55.618]             }
[10:29:55.618]         }))
[10:29:55.618]     }, error = function(ex) {
[10:29:55.618]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:55.618]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:55.618]                 ...future.rng), started = ...future.startTime, 
[10:29:55.618]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:55.618]             version = "1.8"), class = "FutureResult")
[10:29:55.618]     }, finally = {
[10:29:55.618]         if (!identical(...future.workdir, getwd())) 
[10:29:55.618]             setwd(...future.workdir)
[10:29:55.618]         {
[10:29:55.618]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:55.618]                 ...future.oldOptions$nwarnings <- NULL
[10:29:55.618]             }
[10:29:55.618]             base::options(...future.oldOptions)
[10:29:55.618]             if (.Platform$OS.type == "windows") {
[10:29:55.618]                 old_names <- names(...future.oldEnvVars)
[10:29:55.618]                 envs <- base::Sys.getenv()
[10:29:55.618]                 names <- names(envs)
[10:29:55.618]                 common <- intersect(names, old_names)
[10:29:55.618]                 added <- setdiff(names, old_names)
[10:29:55.618]                 removed <- setdiff(old_names, names)
[10:29:55.618]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:55.618]                   envs[common]]
[10:29:55.618]                 NAMES <- toupper(changed)
[10:29:55.618]                 args <- list()
[10:29:55.618]                 for (kk in seq_along(NAMES)) {
[10:29:55.618]                   name <- changed[[kk]]
[10:29:55.618]                   NAME <- NAMES[[kk]]
[10:29:55.618]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:55.618]                     next
[10:29:55.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:55.618]                 }
[10:29:55.618]                 NAMES <- toupper(added)
[10:29:55.618]                 for (kk in seq_along(NAMES)) {
[10:29:55.618]                   name <- added[[kk]]
[10:29:55.618]                   NAME <- NAMES[[kk]]
[10:29:55.618]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:55.618]                     next
[10:29:55.618]                   args[[name]] <- ""
[10:29:55.618]                 }
[10:29:55.618]                 NAMES <- toupper(removed)
[10:29:55.618]                 for (kk in seq_along(NAMES)) {
[10:29:55.618]                   name <- removed[[kk]]
[10:29:55.618]                   NAME <- NAMES[[kk]]
[10:29:55.618]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:55.618]                     next
[10:29:55.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:55.618]                 }
[10:29:55.618]                 if (length(args) > 0) 
[10:29:55.618]                   base::do.call(base::Sys.setenv, args = args)
[10:29:55.618]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:55.618]             }
[10:29:55.618]             else {
[10:29:55.618]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:55.618]             }
[10:29:55.618]             {
[10:29:55.618]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:55.618]                   0L) {
[10:29:55.618]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:55.618]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:55.618]                   base::options(opts)
[10:29:55.618]                 }
[10:29:55.618]                 {
[10:29:55.618]                   {
[10:29:55.618]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:55.618]                     NULL
[10:29:55.618]                   }
[10:29:55.618]                   options(future.plan = NULL)
[10:29:55.618]                   if (is.na(NA_character_)) 
[10:29:55.618]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:55.618]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:55.618]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:55.618]                     .init = FALSE)
[10:29:55.618]                 }
[10:29:55.618]             }
[10:29:55.618]         }
[10:29:55.618]     })
[10:29:55.618]     if (TRUE) {
[10:29:55.618]         base::sink(type = "output", split = FALSE)
[10:29:55.618]         if (TRUE) {
[10:29:55.618]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:55.618]         }
[10:29:55.618]         else {
[10:29:55.618]             ...future.result["stdout"] <- base::list(NULL)
[10:29:55.618]         }
[10:29:55.618]         base::close(...future.stdout)
[10:29:55.618]         ...future.stdout <- NULL
[10:29:55.618]     }
[10:29:55.618]     ...future.result$conditions <- ...future.conditions
[10:29:55.618]     ...future.result$finished <- base::Sys.time()
[10:29:55.618]     ...future.result
[10:29:55.618] }
[10:29:55.675] MultisessionFuture started
[10:29:55.675] result() for ClusterFuture ...
[10:29:55.676] receiveMessageFromWorker() for ClusterFuture ...
[10:29:55.676] - Validating connection of MultisessionFuture
[10:29:55.710] - received message: FutureResult
[10:29:55.710] - Received FutureResult
[10:29:55.710] - Erased future from FutureRegistry
[10:29:55.711] result() for ClusterFuture ...
[10:29:55.711] - result already collected: FutureResult
[10:29:55.711] result() for ClusterFuture ... done
[10:29:55.711] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:55.711] result() for ClusterFuture ... done
[10:29:55.711] result() for ClusterFuture ...
[10:29:55.711] - result already collected: FutureResult
[10:29:55.711] result() for ClusterFuture ... done
[10:29:55.711] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:29:55.715] plan(): nbrOfWorkers() = 2
[10:29:55.715] future_by_internal() ...
[10:29:55.716] future_lapply() ...
[10:29:55.720] Number of chunks: 2
[10:29:55.720] getGlobalsAndPackagesXApply() ...
[10:29:55.720]  - future.globals: TRUE
[10:29:55.720] getGlobalsAndPackages() ...
[10:29:55.720] Searching for globals...
[10:29:55.721] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:55.722] Searching for globals ... DONE
[10:29:55.722] Resolving globals: FALSE
[10:29:55.722] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:55.722] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:55.722] - globals: [1] ‘FUN’
[10:29:55.723] 
[10:29:55.723] getGlobalsAndPackages() ... DONE
[10:29:55.723]  - globals found/used: [n=1] ‘FUN’
[10:29:55.723]  - needed namespaces: [n=0] 
[10:29:55.723] Finding globals ... DONE
[10:29:55.723]  - use_args: TRUE
[10:29:55.723]  - Getting '...' globals ...
[10:29:55.723] resolve() on list ...
[10:29:55.724]  recursive: 0
[10:29:55.724]  length: 1
[10:29:55.724]  elements: ‘...’
[10:29:55.724]  length: 0 (resolved future 1)
[10:29:55.724] resolve() on list ... DONE
[10:29:55.724]    - '...' content: [n=0] 
[10:29:55.724] List of 1
[10:29:55.724]  $ ...: list()
[10:29:55.724]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:55.724]  - attr(*, "where")=List of 1
[10:29:55.724]   ..$ ...:<environment: 0x556dd659bd90> 
[10:29:55.724]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:55.724]  - attr(*, "resolved")= logi TRUE
[10:29:55.724]  - attr(*, "total_size")= num NA
[10:29:55.727]  - Getting '...' globals ... DONE
[10:29:55.727] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:55.727] List of 2
[10:29:55.727]  $ ...future.FUN:function (object, ...)  
[10:29:55.727]  $ ...          : list()
[10:29:55.727]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:55.727]  - attr(*, "where")=List of 2
[10:29:55.727]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:55.727]   ..$ ...          :<environment: 0x556dd659bd90> 
[10:29:55.727]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:55.727]  - attr(*, "resolved")= logi FALSE
[10:29:55.727]  - attr(*, "total_size")= num 1240
[10:29:55.730] Packages to be attached in all futures: [n=0] 
[10:29:55.730] getGlobalsAndPackagesXApply() ... DONE
[10:29:55.730] Number of futures (= number of chunks): 2
[10:29:55.730] Launching 2 futures (chunks) ...
[10:29:55.730] Chunk #1 of 2 ...
[10:29:55.730]  - Finding globals in 'X' for chunk #1 ...
[10:29:55.730] getGlobalsAndPackages() ...
[10:29:55.731] Searching for globals...
[10:29:55.731] 
[10:29:55.731] Searching for globals ... DONE
[10:29:55.731] - globals: [0] <none>
[10:29:55.731] getGlobalsAndPackages() ... DONE
[10:29:55.731]    + additional globals found: [n=0] 
[10:29:55.731]    + additional namespaces needed: [n=0] 
[10:29:55.731]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:55.732]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:55.732]  - seeds: <none>
[10:29:55.732]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:55.732] getGlobalsAndPackages() ...
[10:29:55.732] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:55.732] Resolving globals: FALSE
[10:29:55.732] Tweak future expression to call with '...' arguments ...
[10:29:55.732] {
[10:29:55.732]     do.call(function(...) {
[10:29:55.732]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:55.732]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:55.732]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:55.732]             on.exit(options(oopts), add = TRUE)
[10:29:55.732]         }
[10:29:55.732]         {
[10:29:55.732]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:55.732]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:55.732]                 ...future.FUN(...future.X_jj, ...)
[10:29:55.732]             })
[10:29:55.732]         }
[10:29:55.732]     }, args = future.call.arguments)
[10:29:55.732] }
[10:29:55.733] Tweak future expression to call with '...' arguments ... DONE
[10:29:55.733] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:55.733] 
[10:29:55.733] getGlobalsAndPackages() ... DONE
[10:29:55.733] run() for ‘Future’ ...
[10:29:55.734] - state: ‘created’
[10:29:55.734] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:55.748] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:55.748] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:55.748]   - Field: ‘node’
[10:29:55.748]   - Field: ‘label’
[10:29:55.748]   - Field: ‘local’
[10:29:55.748]   - Field: ‘owner’
[10:29:55.748]   - Field: ‘envir’
[10:29:55.748]   - Field: ‘workers’
[10:29:55.749]   - Field: ‘packages’
[10:29:55.749]   - Field: ‘gc’
[10:29:55.749]   - Field: ‘conditions’
[10:29:55.749]   - Field: ‘persistent’
[10:29:55.749]   - Field: ‘expr’
[10:29:55.749]   - Field: ‘uuid’
[10:29:55.749]   - Field: ‘seed’
[10:29:55.749]   - Field: ‘version’
[10:29:55.749]   - Field: ‘result’
[10:29:55.749]   - Field: ‘asynchronous’
[10:29:55.750]   - Field: ‘calls’
[10:29:55.750]   - Field: ‘globals’
[10:29:55.750]   - Field: ‘stdout’
[10:29:55.750]   - Field: ‘earlySignal’
[10:29:55.750]   - Field: ‘lazy’
[10:29:55.750]   - Field: ‘state’
[10:29:55.750] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:55.750] - Launch lazy future ...
[10:29:55.750] Packages needed by the future expression (n = 0): <none>
[10:29:55.751] Packages needed by future strategies (n = 0): <none>
[10:29:55.751] {
[10:29:55.751]     {
[10:29:55.751]         {
[10:29:55.751]             ...future.startTime <- base::Sys.time()
[10:29:55.751]             {
[10:29:55.751]                 {
[10:29:55.751]                   {
[10:29:55.751]                     {
[10:29:55.751]                       base::local({
[10:29:55.751]                         has_future <- base::requireNamespace("future", 
[10:29:55.751]                           quietly = TRUE)
[10:29:55.751]                         if (has_future) {
[10:29:55.751]                           ns <- base::getNamespace("future")
[10:29:55.751]                           version <- ns[[".package"]][["version"]]
[10:29:55.751]                           if (is.null(version)) 
[10:29:55.751]                             version <- utils::packageVersion("future")
[10:29:55.751]                         }
[10:29:55.751]                         else {
[10:29:55.751]                           version <- NULL
[10:29:55.751]                         }
[10:29:55.751]                         if (!has_future || version < "1.8.0") {
[10:29:55.751]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:55.751]                             "", base::R.version$version.string), 
[10:29:55.751]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:55.751]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:55.751]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:55.751]                               "release", "version")], collapse = " "), 
[10:29:55.751]                             hostname = base::Sys.info()[["nodename"]])
[10:29:55.751]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:55.751]                             info)
[10:29:55.751]                           info <- base::paste(info, collapse = "; ")
[10:29:55.751]                           if (!has_future) {
[10:29:55.751]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:55.751]                               info)
[10:29:55.751]                           }
[10:29:55.751]                           else {
[10:29:55.751]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:55.751]                               info, version)
[10:29:55.751]                           }
[10:29:55.751]                           base::stop(msg)
[10:29:55.751]                         }
[10:29:55.751]                       })
[10:29:55.751]                     }
[10:29:55.751]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:55.751]                     base::options(mc.cores = 1L)
[10:29:55.751]                   }
[10:29:55.751]                   ...future.strategy.old <- future::plan("list")
[10:29:55.751]                   options(future.plan = NULL)
[10:29:55.751]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:55.751]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:55.751]                 }
[10:29:55.751]                 ...future.workdir <- getwd()
[10:29:55.751]             }
[10:29:55.751]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:55.751]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:55.751]         }
[10:29:55.751]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:55.751]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:55.751]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:55.751]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:55.751]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:55.751]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:55.751]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:55.751]             base::names(...future.oldOptions))
[10:29:55.751]     }
[10:29:55.751]     if (FALSE) {
[10:29:55.751]     }
[10:29:55.751]     else {
[10:29:55.751]         if (TRUE) {
[10:29:55.751]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:55.751]                 open = "w")
[10:29:55.751]         }
[10:29:55.751]         else {
[10:29:55.751]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:55.751]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:55.751]         }
[10:29:55.751]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:55.751]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:55.751]             base::sink(type = "output", split = FALSE)
[10:29:55.751]             base::close(...future.stdout)
[10:29:55.751]         }, add = TRUE)
[10:29:55.751]     }
[10:29:55.751]     ...future.frame <- base::sys.nframe()
[10:29:55.751]     ...future.conditions <- base::list()
[10:29:55.751]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:55.751]     if (FALSE) {
[10:29:55.751]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:55.751]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:55.751]     }
[10:29:55.751]     ...future.result <- base::tryCatch({
[10:29:55.751]         base::withCallingHandlers({
[10:29:55.751]             ...future.value <- base::withVisible(base::local({
[10:29:55.751]                 ...future.makeSendCondition <- base::local({
[10:29:55.751]                   sendCondition <- NULL
[10:29:55.751]                   function(frame = 1L) {
[10:29:55.751]                     if (is.function(sendCondition)) 
[10:29:55.751]                       return(sendCondition)
[10:29:55.751]                     ns <- getNamespace("parallel")
[10:29:55.751]                     if (exists("sendData", mode = "function", 
[10:29:55.751]                       envir = ns)) {
[10:29:55.751]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:55.751]                         envir = ns)
[10:29:55.751]                       envir <- sys.frame(frame)
[10:29:55.751]                       master <- NULL
[10:29:55.751]                       while (!identical(envir, .GlobalEnv) && 
[10:29:55.751]                         !identical(envir, emptyenv())) {
[10:29:55.751]                         if (exists("master", mode = "list", envir = envir, 
[10:29:55.751]                           inherits = FALSE)) {
[10:29:55.751]                           master <- get("master", mode = "list", 
[10:29:55.751]                             envir = envir, inherits = FALSE)
[10:29:55.751]                           if (inherits(master, c("SOCKnode", 
[10:29:55.751]                             "SOCK0node"))) {
[10:29:55.751]                             sendCondition <<- function(cond) {
[10:29:55.751]                               data <- list(type = "VALUE", value = cond, 
[10:29:55.751]                                 success = TRUE)
[10:29:55.751]                               parallel_sendData(master, data)
[10:29:55.751]                             }
[10:29:55.751]                             return(sendCondition)
[10:29:55.751]                           }
[10:29:55.751]                         }
[10:29:55.751]                         frame <- frame + 1L
[10:29:55.751]                         envir <- sys.frame(frame)
[10:29:55.751]                       }
[10:29:55.751]                     }
[10:29:55.751]                     sendCondition <<- function(cond) NULL
[10:29:55.751]                   }
[10:29:55.751]                 })
[10:29:55.751]                 withCallingHandlers({
[10:29:55.751]                   {
[10:29:55.751]                     do.call(function(...) {
[10:29:55.751]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:55.751]                       if (!identical(...future.globals.maxSize.org, 
[10:29:55.751]                         ...future.globals.maxSize)) {
[10:29:55.751]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:55.751]                         on.exit(options(oopts), add = TRUE)
[10:29:55.751]                       }
[10:29:55.751]                       {
[10:29:55.751]                         lapply(seq_along(...future.elements_ii), 
[10:29:55.751]                           FUN = function(jj) {
[10:29:55.751]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:55.751]                             ...future.FUN(...future.X_jj, ...)
[10:29:55.751]                           })
[10:29:55.751]                       }
[10:29:55.751]                     }, args = future.call.arguments)
[10:29:55.751]                   }
[10:29:55.751]                 }, immediateCondition = function(cond) {
[10:29:55.751]                   sendCondition <- ...future.makeSendCondition()
[10:29:55.751]                   sendCondition(cond)
[10:29:55.751]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:55.751]                   {
[10:29:55.751]                     inherits <- base::inherits
[10:29:55.751]                     invokeRestart <- base::invokeRestart
[10:29:55.751]                     is.null <- base::is.null
[10:29:55.751]                     muffled <- FALSE
[10:29:55.751]                     if (inherits(cond, "message")) {
[10:29:55.751]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:55.751]                       if (muffled) 
[10:29:55.751]                         invokeRestart("muffleMessage")
[10:29:55.751]                     }
[10:29:55.751]                     else if (inherits(cond, "warning")) {
[10:29:55.751]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:55.751]                       if (muffled) 
[10:29:55.751]                         invokeRestart("muffleWarning")
[10:29:55.751]                     }
[10:29:55.751]                     else if (inherits(cond, "condition")) {
[10:29:55.751]                       if (!is.null(pattern)) {
[10:29:55.751]                         computeRestarts <- base::computeRestarts
[10:29:55.751]                         grepl <- base::grepl
[10:29:55.751]                         restarts <- computeRestarts(cond)
[10:29:55.751]                         for (restart in restarts) {
[10:29:55.751]                           name <- restart$name
[10:29:55.751]                           if (is.null(name)) 
[10:29:55.751]                             next
[10:29:55.751]                           if (!grepl(pattern, name)) 
[10:29:55.751]                             next
[10:29:55.751]                           invokeRestart(restart)
[10:29:55.751]                           muffled <- TRUE
[10:29:55.751]                           break
[10:29:55.751]                         }
[10:29:55.751]                       }
[10:29:55.751]                     }
[10:29:55.751]                     invisible(muffled)
[10:29:55.751]                   }
[10:29:55.751]                   muffleCondition(cond)
[10:29:55.751]                 })
[10:29:55.751]             }))
[10:29:55.751]             future::FutureResult(value = ...future.value$value, 
[10:29:55.751]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:55.751]                   ...future.rng), globalenv = if (FALSE) 
[10:29:55.751]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:55.751]                     ...future.globalenv.names))
[10:29:55.751]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:55.751]         }, condition = base::local({
[10:29:55.751]             c <- base::c
[10:29:55.751]             inherits <- base::inherits
[10:29:55.751]             invokeRestart <- base::invokeRestart
[10:29:55.751]             length <- base::length
[10:29:55.751]             list <- base::list
[10:29:55.751]             seq.int <- base::seq.int
[10:29:55.751]             signalCondition <- base::signalCondition
[10:29:55.751]             sys.calls <- base::sys.calls
[10:29:55.751]             `[[` <- base::`[[`
[10:29:55.751]             `+` <- base::`+`
[10:29:55.751]             `<<-` <- base::`<<-`
[10:29:55.751]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:55.751]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:55.751]                   3L)]
[10:29:55.751]             }
[10:29:55.751]             function(cond) {
[10:29:55.751]                 is_error <- inherits(cond, "error")
[10:29:55.751]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:55.751]                   NULL)
[10:29:55.751]                 if (is_error) {
[10:29:55.751]                   sessionInformation <- function() {
[10:29:55.751]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:55.751]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:55.751]                       search = base::search(), system = base::Sys.info())
[10:29:55.751]                   }
[10:29:55.751]                   ...future.conditions[[length(...future.conditions) + 
[10:29:55.751]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:55.751]                     cond$call), session = sessionInformation(), 
[10:29:55.751]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:55.751]                   signalCondition(cond)
[10:29:55.751]                 }
[10:29:55.751]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:55.751]                 "immediateCondition"))) {
[10:29:55.751]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:55.751]                   ...future.conditions[[length(...future.conditions) + 
[10:29:55.751]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:55.751]                   if (TRUE && !signal) {
[10:29:55.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:55.751]                     {
[10:29:55.751]                       inherits <- base::inherits
[10:29:55.751]                       invokeRestart <- base::invokeRestart
[10:29:55.751]                       is.null <- base::is.null
[10:29:55.751]                       muffled <- FALSE
[10:29:55.751]                       if (inherits(cond, "message")) {
[10:29:55.751]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:55.751]                         if (muffled) 
[10:29:55.751]                           invokeRestart("muffleMessage")
[10:29:55.751]                       }
[10:29:55.751]                       else if (inherits(cond, "warning")) {
[10:29:55.751]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:55.751]                         if (muffled) 
[10:29:55.751]                           invokeRestart("muffleWarning")
[10:29:55.751]                       }
[10:29:55.751]                       else if (inherits(cond, "condition")) {
[10:29:55.751]                         if (!is.null(pattern)) {
[10:29:55.751]                           computeRestarts <- base::computeRestarts
[10:29:55.751]                           grepl <- base::grepl
[10:29:55.751]                           restarts <- computeRestarts(cond)
[10:29:55.751]                           for (restart in restarts) {
[10:29:55.751]                             name <- restart$name
[10:29:55.751]                             if (is.null(name)) 
[10:29:55.751]                               next
[10:29:55.751]                             if (!grepl(pattern, name)) 
[10:29:55.751]                               next
[10:29:55.751]                             invokeRestart(restart)
[10:29:55.751]                             muffled <- TRUE
[10:29:55.751]                             break
[10:29:55.751]                           }
[10:29:55.751]                         }
[10:29:55.751]                       }
[10:29:55.751]                       invisible(muffled)
[10:29:55.751]                     }
[10:29:55.751]                     muffleCondition(cond, pattern = "^muffle")
[10:29:55.751]                   }
[10:29:55.751]                 }
[10:29:55.751]                 else {
[10:29:55.751]                   if (TRUE) {
[10:29:55.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:55.751]                     {
[10:29:55.751]                       inherits <- base::inherits
[10:29:55.751]                       invokeRestart <- base::invokeRestart
[10:29:55.751]                       is.null <- base::is.null
[10:29:55.751]                       muffled <- FALSE
[10:29:55.751]                       if (inherits(cond, "message")) {
[10:29:55.751]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:55.751]                         if (muffled) 
[10:29:55.751]                           invokeRestart("muffleMessage")
[10:29:55.751]                       }
[10:29:55.751]                       else if (inherits(cond, "warning")) {
[10:29:55.751]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:55.751]                         if (muffled) 
[10:29:55.751]                           invokeRestart("muffleWarning")
[10:29:55.751]                       }
[10:29:55.751]                       else if (inherits(cond, "condition")) {
[10:29:55.751]                         if (!is.null(pattern)) {
[10:29:55.751]                           computeRestarts <- base::computeRestarts
[10:29:55.751]                           grepl <- base::grepl
[10:29:55.751]                           restarts <- computeRestarts(cond)
[10:29:55.751]                           for (restart in restarts) {
[10:29:55.751]                             name <- restart$name
[10:29:55.751]                             if (is.null(name)) 
[10:29:55.751]                               next
[10:29:55.751]                             if (!grepl(pattern, name)) 
[10:29:55.751]                               next
[10:29:55.751]                             invokeRestart(restart)
[10:29:55.751]                             muffled <- TRUE
[10:29:55.751]                             break
[10:29:55.751]                           }
[10:29:55.751]                         }
[10:29:55.751]                       }
[10:29:55.751]                       invisible(muffled)
[10:29:55.751]                     }
[10:29:55.751]                     muffleCondition(cond, pattern = "^muffle")
[10:29:55.751]                   }
[10:29:55.751]                 }
[10:29:55.751]             }
[10:29:55.751]         }))
[10:29:55.751]     }, error = function(ex) {
[10:29:55.751]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:55.751]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:55.751]                 ...future.rng), started = ...future.startTime, 
[10:29:55.751]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:55.751]             version = "1.8"), class = "FutureResult")
[10:29:55.751]     }, finally = {
[10:29:55.751]         if (!identical(...future.workdir, getwd())) 
[10:29:55.751]             setwd(...future.workdir)
[10:29:55.751]         {
[10:29:55.751]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:55.751]                 ...future.oldOptions$nwarnings <- NULL
[10:29:55.751]             }
[10:29:55.751]             base::options(...future.oldOptions)
[10:29:55.751]             if (.Platform$OS.type == "windows") {
[10:29:55.751]                 old_names <- names(...future.oldEnvVars)
[10:29:55.751]                 envs <- base::Sys.getenv()
[10:29:55.751]                 names <- names(envs)
[10:29:55.751]                 common <- intersect(names, old_names)
[10:29:55.751]                 added <- setdiff(names, old_names)
[10:29:55.751]                 removed <- setdiff(old_names, names)
[10:29:55.751]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:55.751]                   envs[common]]
[10:29:55.751]                 NAMES <- toupper(changed)
[10:29:55.751]                 args <- list()
[10:29:55.751]                 for (kk in seq_along(NAMES)) {
[10:29:55.751]                   name <- changed[[kk]]
[10:29:55.751]                   NAME <- NAMES[[kk]]
[10:29:55.751]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:55.751]                     next
[10:29:55.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:55.751]                 }
[10:29:55.751]                 NAMES <- toupper(added)
[10:29:55.751]                 for (kk in seq_along(NAMES)) {
[10:29:55.751]                   name <- added[[kk]]
[10:29:55.751]                   NAME <- NAMES[[kk]]
[10:29:55.751]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:55.751]                     next
[10:29:55.751]                   args[[name]] <- ""
[10:29:55.751]                 }
[10:29:55.751]                 NAMES <- toupper(removed)
[10:29:55.751]                 for (kk in seq_along(NAMES)) {
[10:29:55.751]                   name <- removed[[kk]]
[10:29:55.751]                   NAME <- NAMES[[kk]]
[10:29:55.751]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:55.751]                     next
[10:29:55.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:55.751]                 }
[10:29:55.751]                 if (length(args) > 0) 
[10:29:55.751]                   base::do.call(base::Sys.setenv, args = args)
[10:29:55.751]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:55.751]             }
[10:29:55.751]             else {
[10:29:55.751]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:55.751]             }
[10:29:55.751]             {
[10:29:55.751]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:55.751]                   0L) {
[10:29:55.751]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:55.751]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:55.751]                   base::options(opts)
[10:29:55.751]                 }
[10:29:55.751]                 {
[10:29:55.751]                   {
[10:29:55.751]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:55.751]                     NULL
[10:29:55.751]                   }
[10:29:55.751]                   options(future.plan = NULL)
[10:29:55.751]                   if (is.na(NA_character_)) 
[10:29:55.751]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:55.751]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:55.751]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:55.751]                     .init = FALSE)
[10:29:55.751]                 }
[10:29:55.751]             }
[10:29:55.751]         }
[10:29:55.751]     })
[10:29:55.751]     if (TRUE) {
[10:29:55.751]         base::sink(type = "output", split = FALSE)
[10:29:55.751]         if (TRUE) {
[10:29:55.751]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:55.751]         }
[10:29:55.751]         else {
[10:29:55.751]             ...future.result["stdout"] <- base::list(NULL)
[10:29:55.751]         }
[10:29:55.751]         base::close(...future.stdout)
[10:29:55.751]         ...future.stdout <- NULL
[10:29:55.751]     }
[10:29:55.751]     ...future.result$conditions <- ...future.conditions
[10:29:55.751]     ...future.result$finished <- base::Sys.time()
[10:29:55.751]     ...future.result
[10:29:55.751] }
[10:29:55.754] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[10:29:55.754] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[10:29:55.755] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[10:29:55.755] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:29:55.755] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:29:55.755] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ...
[10:29:55.756] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ... DONE
[10:29:55.756] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:29:55.756] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:29:55.756] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:29:55.757] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:29:55.757] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[10:29:55.757] MultisessionFuture started
[10:29:55.757] - Launch lazy future ... done
[10:29:55.757] run() for ‘MultisessionFuture’ ... done
[10:29:55.758] Created future:
[10:29:55.758] MultisessionFuture:
[10:29:55.758] Label: ‘future_by-1’
[10:29:55.758] Expression:
[10:29:55.758] {
[10:29:55.758]     do.call(function(...) {
[10:29:55.758]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:55.758]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:55.758]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:55.758]             on.exit(options(oopts), add = TRUE)
[10:29:55.758]         }
[10:29:55.758]         {
[10:29:55.758]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:55.758]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:55.758]                 ...future.FUN(...future.X_jj, ...)
[10:29:55.758]             })
[10:29:55.758]         }
[10:29:55.758]     }, args = future.call.arguments)
[10:29:55.758] }
[10:29:55.758] Lazy evaluation: FALSE
[10:29:55.758] Asynchronous evaluation: TRUE
[10:29:55.758] Local evaluation: TRUE
[10:29:55.758] Environment: R_GlobalEnv
[10:29:55.758] Capture standard output: TRUE
[10:29:55.758] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:55.758] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:55.758] Packages: <none>
[10:29:55.758] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:55.758] Resolved: FALSE
[10:29:55.758] Value: <not collected>
[10:29:55.758] Conditions captured: <none>
[10:29:55.758] Early signaling: FALSE
[10:29:55.758] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:55.758] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:55.770] Chunk #1 of 2 ... DONE
[10:29:55.770] Chunk #2 of 2 ...
[10:29:55.770]  - Finding globals in 'X' for chunk #2 ...
[10:29:55.770] getGlobalsAndPackages() ...
[10:29:55.770] Searching for globals...
[10:29:55.771] 
[10:29:55.771] Searching for globals ... DONE
[10:29:55.771] - globals: [0] <none>
[10:29:55.771] getGlobalsAndPackages() ... DONE
[10:29:55.771]    + additional globals found: [n=0] 
[10:29:55.771]    + additional namespaces needed: [n=0] 
[10:29:55.771]  - Finding globals in 'X' for chunk #2 ... DONE
[10:29:55.771]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:55.771]  - seeds: <none>
[10:29:55.772]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:55.772] getGlobalsAndPackages() ...
[10:29:55.772] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:55.772] Resolving globals: FALSE
[10:29:55.772] Tweak future expression to call with '...' arguments ...
[10:29:55.772] {
[10:29:55.772]     do.call(function(...) {
[10:29:55.772]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:55.772]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:55.772]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:55.772]             on.exit(options(oopts), add = TRUE)
[10:29:55.772]         }
[10:29:55.772]         {
[10:29:55.772]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:55.772]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:55.772]                 ...future.FUN(...future.X_jj, ...)
[10:29:55.772]             })
[10:29:55.772]         }
[10:29:55.772]     }, args = future.call.arguments)
[10:29:55.772] }
[10:29:55.772] Tweak future expression to call with '...' arguments ... DONE
[10:29:55.773] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:55.773] 
[10:29:55.773] getGlobalsAndPackages() ... DONE
[10:29:55.773] run() for ‘Future’ ...
[10:29:55.773] - state: ‘created’
[10:29:55.774] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:55.788] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:55.788] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:55.789]   - Field: ‘node’
[10:29:55.789]   - Field: ‘label’
[10:29:55.789]   - Field: ‘local’
[10:29:55.789]   - Field: ‘owner’
[10:29:55.789]   - Field: ‘envir’
[10:29:55.789]   - Field: ‘workers’
[10:29:55.789]   - Field: ‘packages’
[10:29:55.789]   - Field: ‘gc’
[10:29:55.789]   - Field: ‘conditions’
[10:29:55.790]   - Field: ‘persistent’
[10:29:55.790]   - Field: ‘expr’
[10:29:55.790]   - Field: ‘uuid’
[10:29:55.790]   - Field: ‘seed’
[10:29:55.790]   - Field: ‘version’
[10:29:55.790]   - Field: ‘result’
[10:29:55.790]   - Field: ‘asynchronous’
[10:29:55.790]   - Field: ‘calls’
[10:29:55.790]   - Field: ‘globals’
[10:29:55.790]   - Field: ‘stdout’
[10:29:55.791]   - Field: ‘earlySignal’
[10:29:55.791]   - Field: ‘lazy’
[10:29:55.791]   - Field: ‘state’
[10:29:55.791] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:55.791] - Launch lazy future ...
[10:29:55.791] Packages needed by the future expression (n = 0): <none>
[10:29:55.791] Packages needed by future strategies (n = 0): <none>
[10:29:55.792] {
[10:29:55.792]     {
[10:29:55.792]         {
[10:29:55.792]             ...future.startTime <- base::Sys.time()
[10:29:55.792]             {
[10:29:55.792]                 {
[10:29:55.792]                   {
[10:29:55.792]                     {
[10:29:55.792]                       base::local({
[10:29:55.792]                         has_future <- base::requireNamespace("future", 
[10:29:55.792]                           quietly = TRUE)
[10:29:55.792]                         if (has_future) {
[10:29:55.792]                           ns <- base::getNamespace("future")
[10:29:55.792]                           version <- ns[[".package"]][["version"]]
[10:29:55.792]                           if (is.null(version)) 
[10:29:55.792]                             version <- utils::packageVersion("future")
[10:29:55.792]                         }
[10:29:55.792]                         else {
[10:29:55.792]                           version <- NULL
[10:29:55.792]                         }
[10:29:55.792]                         if (!has_future || version < "1.8.0") {
[10:29:55.792]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:55.792]                             "", base::R.version$version.string), 
[10:29:55.792]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:55.792]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:55.792]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:55.792]                               "release", "version")], collapse = " "), 
[10:29:55.792]                             hostname = base::Sys.info()[["nodename"]])
[10:29:55.792]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:55.792]                             info)
[10:29:55.792]                           info <- base::paste(info, collapse = "; ")
[10:29:55.792]                           if (!has_future) {
[10:29:55.792]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:55.792]                               info)
[10:29:55.792]                           }
[10:29:55.792]                           else {
[10:29:55.792]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:55.792]                               info, version)
[10:29:55.792]                           }
[10:29:55.792]                           base::stop(msg)
[10:29:55.792]                         }
[10:29:55.792]                       })
[10:29:55.792]                     }
[10:29:55.792]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:55.792]                     base::options(mc.cores = 1L)
[10:29:55.792]                   }
[10:29:55.792]                   ...future.strategy.old <- future::plan("list")
[10:29:55.792]                   options(future.plan = NULL)
[10:29:55.792]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:55.792]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:55.792]                 }
[10:29:55.792]                 ...future.workdir <- getwd()
[10:29:55.792]             }
[10:29:55.792]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:55.792]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:55.792]         }
[10:29:55.792]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:55.792]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:55.792]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:55.792]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:55.792]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:55.792]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:55.792]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:55.792]             base::names(...future.oldOptions))
[10:29:55.792]     }
[10:29:55.792]     if (FALSE) {
[10:29:55.792]     }
[10:29:55.792]     else {
[10:29:55.792]         if (TRUE) {
[10:29:55.792]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:55.792]                 open = "w")
[10:29:55.792]         }
[10:29:55.792]         else {
[10:29:55.792]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:55.792]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:55.792]         }
[10:29:55.792]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:55.792]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:55.792]             base::sink(type = "output", split = FALSE)
[10:29:55.792]             base::close(...future.stdout)
[10:29:55.792]         }, add = TRUE)
[10:29:55.792]     }
[10:29:55.792]     ...future.frame <- base::sys.nframe()
[10:29:55.792]     ...future.conditions <- base::list()
[10:29:55.792]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:55.792]     if (FALSE) {
[10:29:55.792]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:55.792]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:55.792]     }
[10:29:55.792]     ...future.result <- base::tryCatch({
[10:29:55.792]         base::withCallingHandlers({
[10:29:55.792]             ...future.value <- base::withVisible(base::local({
[10:29:55.792]                 ...future.makeSendCondition <- base::local({
[10:29:55.792]                   sendCondition <- NULL
[10:29:55.792]                   function(frame = 1L) {
[10:29:55.792]                     if (is.function(sendCondition)) 
[10:29:55.792]                       return(sendCondition)
[10:29:55.792]                     ns <- getNamespace("parallel")
[10:29:55.792]                     if (exists("sendData", mode = "function", 
[10:29:55.792]                       envir = ns)) {
[10:29:55.792]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:55.792]                         envir = ns)
[10:29:55.792]                       envir <- sys.frame(frame)
[10:29:55.792]                       master <- NULL
[10:29:55.792]                       while (!identical(envir, .GlobalEnv) && 
[10:29:55.792]                         !identical(envir, emptyenv())) {
[10:29:55.792]                         if (exists("master", mode = "list", envir = envir, 
[10:29:55.792]                           inherits = FALSE)) {
[10:29:55.792]                           master <- get("master", mode = "list", 
[10:29:55.792]                             envir = envir, inherits = FALSE)
[10:29:55.792]                           if (inherits(master, c("SOCKnode", 
[10:29:55.792]                             "SOCK0node"))) {
[10:29:55.792]                             sendCondition <<- function(cond) {
[10:29:55.792]                               data <- list(type = "VALUE", value = cond, 
[10:29:55.792]                                 success = TRUE)
[10:29:55.792]                               parallel_sendData(master, data)
[10:29:55.792]                             }
[10:29:55.792]                             return(sendCondition)
[10:29:55.792]                           }
[10:29:55.792]                         }
[10:29:55.792]                         frame <- frame + 1L
[10:29:55.792]                         envir <- sys.frame(frame)
[10:29:55.792]                       }
[10:29:55.792]                     }
[10:29:55.792]                     sendCondition <<- function(cond) NULL
[10:29:55.792]                   }
[10:29:55.792]                 })
[10:29:55.792]                 withCallingHandlers({
[10:29:55.792]                   {
[10:29:55.792]                     do.call(function(...) {
[10:29:55.792]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:55.792]                       if (!identical(...future.globals.maxSize.org, 
[10:29:55.792]                         ...future.globals.maxSize)) {
[10:29:55.792]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:55.792]                         on.exit(options(oopts), add = TRUE)
[10:29:55.792]                       }
[10:29:55.792]                       {
[10:29:55.792]                         lapply(seq_along(...future.elements_ii), 
[10:29:55.792]                           FUN = function(jj) {
[10:29:55.792]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:55.792]                             ...future.FUN(...future.X_jj, ...)
[10:29:55.792]                           })
[10:29:55.792]                       }
[10:29:55.792]                     }, args = future.call.arguments)
[10:29:55.792]                   }
[10:29:55.792]                 }, immediateCondition = function(cond) {
[10:29:55.792]                   sendCondition <- ...future.makeSendCondition()
[10:29:55.792]                   sendCondition(cond)
[10:29:55.792]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:55.792]                   {
[10:29:55.792]                     inherits <- base::inherits
[10:29:55.792]                     invokeRestart <- base::invokeRestart
[10:29:55.792]                     is.null <- base::is.null
[10:29:55.792]                     muffled <- FALSE
[10:29:55.792]                     if (inherits(cond, "message")) {
[10:29:55.792]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:55.792]                       if (muffled) 
[10:29:55.792]                         invokeRestart("muffleMessage")
[10:29:55.792]                     }
[10:29:55.792]                     else if (inherits(cond, "warning")) {
[10:29:55.792]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:55.792]                       if (muffled) 
[10:29:55.792]                         invokeRestart("muffleWarning")
[10:29:55.792]                     }
[10:29:55.792]                     else if (inherits(cond, "condition")) {
[10:29:55.792]                       if (!is.null(pattern)) {
[10:29:55.792]                         computeRestarts <- base::computeRestarts
[10:29:55.792]                         grepl <- base::grepl
[10:29:55.792]                         restarts <- computeRestarts(cond)
[10:29:55.792]                         for (restart in restarts) {
[10:29:55.792]                           name <- restart$name
[10:29:55.792]                           if (is.null(name)) 
[10:29:55.792]                             next
[10:29:55.792]                           if (!grepl(pattern, name)) 
[10:29:55.792]                             next
[10:29:55.792]                           invokeRestart(restart)
[10:29:55.792]                           muffled <- TRUE
[10:29:55.792]                           break
[10:29:55.792]                         }
[10:29:55.792]                       }
[10:29:55.792]                     }
[10:29:55.792]                     invisible(muffled)
[10:29:55.792]                   }
[10:29:55.792]                   muffleCondition(cond)
[10:29:55.792]                 })
[10:29:55.792]             }))
[10:29:55.792]             future::FutureResult(value = ...future.value$value, 
[10:29:55.792]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:55.792]                   ...future.rng), globalenv = if (FALSE) 
[10:29:55.792]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:55.792]                     ...future.globalenv.names))
[10:29:55.792]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:55.792]         }, condition = base::local({
[10:29:55.792]             c <- base::c
[10:29:55.792]             inherits <- base::inherits
[10:29:55.792]             invokeRestart <- base::invokeRestart
[10:29:55.792]             length <- base::length
[10:29:55.792]             list <- base::list
[10:29:55.792]             seq.int <- base::seq.int
[10:29:55.792]             signalCondition <- base::signalCondition
[10:29:55.792]             sys.calls <- base::sys.calls
[10:29:55.792]             `[[` <- base::`[[`
[10:29:55.792]             `+` <- base::`+`
[10:29:55.792]             `<<-` <- base::`<<-`
[10:29:55.792]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:55.792]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:55.792]                   3L)]
[10:29:55.792]             }
[10:29:55.792]             function(cond) {
[10:29:55.792]                 is_error <- inherits(cond, "error")
[10:29:55.792]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:55.792]                   NULL)
[10:29:55.792]                 if (is_error) {
[10:29:55.792]                   sessionInformation <- function() {
[10:29:55.792]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:55.792]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:55.792]                       search = base::search(), system = base::Sys.info())
[10:29:55.792]                   }
[10:29:55.792]                   ...future.conditions[[length(...future.conditions) + 
[10:29:55.792]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:55.792]                     cond$call), session = sessionInformation(), 
[10:29:55.792]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:55.792]                   signalCondition(cond)
[10:29:55.792]                 }
[10:29:55.792]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:55.792]                 "immediateCondition"))) {
[10:29:55.792]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:55.792]                   ...future.conditions[[length(...future.conditions) + 
[10:29:55.792]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:55.792]                   if (TRUE && !signal) {
[10:29:55.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:55.792]                     {
[10:29:55.792]                       inherits <- base::inherits
[10:29:55.792]                       invokeRestart <- base::invokeRestart
[10:29:55.792]                       is.null <- base::is.null
[10:29:55.792]                       muffled <- FALSE
[10:29:55.792]                       if (inherits(cond, "message")) {
[10:29:55.792]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:55.792]                         if (muffled) 
[10:29:55.792]                           invokeRestart("muffleMessage")
[10:29:55.792]                       }
[10:29:55.792]                       else if (inherits(cond, "warning")) {
[10:29:55.792]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:55.792]                         if (muffled) 
[10:29:55.792]                           invokeRestart("muffleWarning")
[10:29:55.792]                       }
[10:29:55.792]                       else if (inherits(cond, "condition")) {
[10:29:55.792]                         if (!is.null(pattern)) {
[10:29:55.792]                           computeRestarts <- base::computeRestarts
[10:29:55.792]                           grepl <- base::grepl
[10:29:55.792]                           restarts <- computeRestarts(cond)
[10:29:55.792]                           for (restart in restarts) {
[10:29:55.792]                             name <- restart$name
[10:29:55.792]                             if (is.null(name)) 
[10:29:55.792]                               next
[10:29:55.792]                             if (!grepl(pattern, name)) 
[10:29:55.792]                               next
[10:29:55.792]                             invokeRestart(restart)
[10:29:55.792]                             muffled <- TRUE
[10:29:55.792]                             break
[10:29:55.792]                           }
[10:29:55.792]                         }
[10:29:55.792]                       }
[10:29:55.792]                       invisible(muffled)
[10:29:55.792]                     }
[10:29:55.792]                     muffleCondition(cond, pattern = "^muffle")
[10:29:55.792]                   }
[10:29:55.792]                 }
[10:29:55.792]                 else {
[10:29:55.792]                   if (TRUE) {
[10:29:55.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:55.792]                     {
[10:29:55.792]                       inherits <- base::inherits
[10:29:55.792]                       invokeRestart <- base::invokeRestart
[10:29:55.792]                       is.null <- base::is.null
[10:29:55.792]                       muffled <- FALSE
[10:29:55.792]                       if (inherits(cond, "message")) {
[10:29:55.792]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:55.792]                         if (muffled) 
[10:29:55.792]                           invokeRestart("muffleMessage")
[10:29:55.792]                       }
[10:29:55.792]                       else if (inherits(cond, "warning")) {
[10:29:55.792]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:55.792]                         if (muffled) 
[10:29:55.792]                           invokeRestart("muffleWarning")
[10:29:55.792]                       }
[10:29:55.792]                       else if (inherits(cond, "condition")) {
[10:29:55.792]                         if (!is.null(pattern)) {
[10:29:55.792]                           computeRestarts <- base::computeRestarts
[10:29:55.792]                           grepl <- base::grepl
[10:29:55.792]                           restarts <- computeRestarts(cond)
[10:29:55.792]                           for (restart in restarts) {
[10:29:55.792]                             name <- restart$name
[10:29:55.792]                             if (is.null(name)) 
[10:29:55.792]                               next
[10:29:55.792]                             if (!grepl(pattern, name)) 
[10:29:55.792]                               next
[10:29:55.792]                             invokeRestart(restart)
[10:29:55.792]                             muffled <- TRUE
[10:29:55.792]                             break
[10:29:55.792]                           }
[10:29:55.792]                         }
[10:29:55.792]                       }
[10:29:55.792]                       invisible(muffled)
[10:29:55.792]                     }
[10:29:55.792]                     muffleCondition(cond, pattern = "^muffle")
[10:29:55.792]                   }
[10:29:55.792]                 }
[10:29:55.792]             }
[10:29:55.792]         }))
[10:29:55.792]     }, error = function(ex) {
[10:29:55.792]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:55.792]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:55.792]                 ...future.rng), started = ...future.startTime, 
[10:29:55.792]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:55.792]             version = "1.8"), class = "FutureResult")
[10:29:55.792]     }, finally = {
[10:29:55.792]         if (!identical(...future.workdir, getwd())) 
[10:29:55.792]             setwd(...future.workdir)
[10:29:55.792]         {
[10:29:55.792]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:55.792]                 ...future.oldOptions$nwarnings <- NULL
[10:29:55.792]             }
[10:29:55.792]             base::options(...future.oldOptions)
[10:29:55.792]             if (.Platform$OS.type == "windows") {
[10:29:55.792]                 old_names <- names(...future.oldEnvVars)
[10:29:55.792]                 envs <- base::Sys.getenv()
[10:29:55.792]                 names <- names(envs)
[10:29:55.792]                 common <- intersect(names, old_names)
[10:29:55.792]                 added <- setdiff(names, old_names)
[10:29:55.792]                 removed <- setdiff(old_names, names)
[10:29:55.792]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:55.792]                   envs[common]]
[10:29:55.792]                 NAMES <- toupper(changed)
[10:29:55.792]                 args <- list()
[10:29:55.792]                 for (kk in seq_along(NAMES)) {
[10:29:55.792]                   name <- changed[[kk]]
[10:29:55.792]                   NAME <- NAMES[[kk]]
[10:29:55.792]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:55.792]                     next
[10:29:55.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:55.792]                 }
[10:29:55.792]                 NAMES <- toupper(added)
[10:29:55.792]                 for (kk in seq_along(NAMES)) {
[10:29:55.792]                   name <- added[[kk]]
[10:29:55.792]                   NAME <- NAMES[[kk]]
[10:29:55.792]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:55.792]                     next
[10:29:55.792]                   args[[name]] <- ""
[10:29:55.792]                 }
[10:29:55.792]                 NAMES <- toupper(removed)
[10:29:55.792]                 for (kk in seq_along(NAMES)) {
[10:29:55.792]                   name <- removed[[kk]]
[10:29:55.792]                   NAME <- NAMES[[kk]]
[10:29:55.792]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:55.792]                     next
[10:29:55.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:55.792]                 }
[10:29:55.792]                 if (length(args) > 0) 
[10:29:55.792]                   base::do.call(base::Sys.setenv, args = args)
[10:29:55.792]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:55.792]             }
[10:29:55.792]             else {
[10:29:55.792]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:55.792]             }
[10:29:55.792]             {
[10:29:55.792]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:55.792]                   0L) {
[10:29:55.792]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:55.792]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:55.792]                   base::options(opts)
[10:29:55.792]                 }
[10:29:55.792]                 {
[10:29:55.792]                   {
[10:29:55.792]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:55.792]                     NULL
[10:29:55.792]                   }
[10:29:55.792]                   options(future.plan = NULL)
[10:29:55.792]                   if (is.na(NA_character_)) 
[10:29:55.792]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:55.792]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:55.792]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:55.792]                     .init = FALSE)
[10:29:55.792]                 }
[10:29:55.792]             }
[10:29:55.792]         }
[10:29:55.792]     })
[10:29:55.792]     if (TRUE) {
[10:29:55.792]         base::sink(type = "output", split = FALSE)
[10:29:55.792]         if (TRUE) {
[10:29:55.792]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:55.792]         }
[10:29:55.792]         else {
[10:29:55.792]             ...future.result["stdout"] <- base::list(NULL)
[10:29:55.792]         }
[10:29:55.792]         base::close(...future.stdout)
[10:29:55.792]         ...future.stdout <- NULL
[10:29:55.792]     }
[10:29:55.792]     ...future.result$conditions <- ...future.conditions
[10:29:55.792]     ...future.result$finished <- base::Sys.time()
[10:29:55.792]     ...future.result
[10:29:55.792] }
[10:29:55.847] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[10:29:55.847] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[10:29:55.848] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[10:29:55.848] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:29:55.849] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:29:55.849] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ...
[10:29:55.849] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ... DONE
[10:29:55.849] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:29:55.850] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:29:55.850] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:29:55.850] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:29:55.850] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[10:29:55.851] MultisessionFuture started
[10:29:55.851] - Launch lazy future ... done
[10:29:55.851] run() for ‘MultisessionFuture’ ... done
[10:29:55.852] Created future:
[10:29:55.852] MultisessionFuture:
[10:29:55.852] Label: ‘future_by-2’
[10:29:55.852] Expression:
[10:29:55.852] {
[10:29:55.852]     do.call(function(...) {
[10:29:55.852]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:55.852]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:55.852]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:55.852]             on.exit(options(oopts), add = TRUE)
[10:29:55.852]         }
[10:29:55.852]         {
[10:29:55.852]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:55.852]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:55.852]                 ...future.FUN(...future.X_jj, ...)
[10:29:55.852]             })
[10:29:55.852]         }
[10:29:55.852]     }, args = future.call.arguments)
[10:29:55.852] }
[10:29:55.852] Lazy evaluation: FALSE
[10:29:55.852] Asynchronous evaluation: TRUE
[10:29:55.852] Local evaluation: TRUE
[10:29:55.852] Environment: R_GlobalEnv
[10:29:55.852] Capture standard output: TRUE
[10:29:55.852] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:55.852] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:55.852] Packages: <none>
[10:29:55.852] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:55.852] Resolved: FALSE
[10:29:55.852] Value: <not collected>
[10:29:55.852] Conditions captured: <none>
[10:29:55.852] Early signaling: FALSE
[10:29:55.852] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:55.852] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:55.864] Chunk #2 of 2 ... DONE
[10:29:55.864] Launching 2 futures (chunks) ... DONE
[10:29:55.864] Resolving 2 futures (chunks) ...
[10:29:55.864] resolve() on list ...
[10:29:55.864]  recursive: 0
[10:29:55.864]  length: 2
[10:29:55.864] 
[10:29:55.865] receiveMessageFromWorker() for ClusterFuture ...
[10:29:55.865] - Validating connection of MultisessionFuture
[10:29:55.865] - received message: FutureResult
[10:29:55.865] - Received FutureResult
[10:29:55.865] - Erased future from FutureRegistry
[10:29:55.865] result() for ClusterFuture ...
[10:29:55.866] - result already collected: FutureResult
[10:29:55.866] result() for ClusterFuture ... done
[10:29:55.866] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:55.866] Future #1
[10:29:55.866] result() for ClusterFuture ...
[10:29:55.866] - result already collected: FutureResult
[10:29:55.866] result() for ClusterFuture ... done
[10:29:55.866] result() for ClusterFuture ...
[10:29:55.866] - result already collected: FutureResult
[10:29:55.866] result() for ClusterFuture ... done
[10:29:55.867] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:29:55.867] - nx: 2
[10:29:55.867] - relay: TRUE
[10:29:55.867] - stdout: TRUE
[10:29:55.867] - signal: TRUE
[10:29:55.867] - resignal: FALSE
[10:29:55.867] - force: TRUE
[10:29:55.867] - relayed: [n=2] FALSE, FALSE
[10:29:55.867] - queued futures: [n=2] FALSE, FALSE
[10:29:55.867]  - until=1
[10:29:55.867]  - relaying element #1
[10:29:55.868] result() for ClusterFuture ...
[10:29:55.868] - result already collected: FutureResult
[10:29:55.868] result() for ClusterFuture ... done
[10:29:55.871] result() for ClusterFuture ...
[10:29:55.871] - result already collected: FutureResult
[10:29:55.871] result() for ClusterFuture ... done
[10:29:55.871] result() for ClusterFuture ...
[10:29:55.871] - result already collected: FutureResult
[10:29:55.871] result() for ClusterFuture ... done
[10:29:55.871] result() for ClusterFuture ...
[10:29:55.871] - result already collected: FutureResult
[10:29:55.871] result() for ClusterFuture ... done
[10:29:55.871] - relayed: [n=2] TRUE, FALSE
[10:29:55.872] - queued futures: [n=2] TRUE, FALSE
[10:29:55.872] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:29:55.872]  length: 1 (resolved future 1)
[10:29:55.937] receiveMessageFromWorker() for ClusterFuture ...
[10:29:55.938] - Validating connection of MultisessionFuture
[10:29:55.938] - received message: FutureResult
[10:29:55.938] - Received FutureResult
[10:29:55.938] - Erased future from FutureRegistry
[10:29:55.938] result() for ClusterFuture ...
[10:29:55.938] - result already collected: FutureResult
[10:29:55.938] result() for ClusterFuture ... done
[10:29:55.939] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:55.939] Future #2
[10:29:55.939] result() for ClusterFuture ...
[10:29:55.939] - result already collected: FutureResult
[10:29:55.939] result() for ClusterFuture ... done
[10:29:55.939] result() for ClusterFuture ...
[10:29:55.939] - result already collected: FutureResult
[10:29:55.939] result() for ClusterFuture ... done
[10:29:55.939] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:29:55.939] - nx: 2
[10:29:55.939] - relay: TRUE
[10:29:55.940] - stdout: TRUE
[10:29:55.940] - signal: TRUE
[10:29:55.940] - resignal: FALSE
[10:29:55.940] - force: TRUE
[10:29:55.940] - relayed: [n=2] TRUE, FALSE
[10:29:55.940] - queued futures: [n=2] TRUE, FALSE
[10:29:55.940]  - until=2
[10:29:55.940]  - relaying element #2
[10:29:55.940] result() for ClusterFuture ...
[10:29:55.940] - result already collected: FutureResult
[10:29:55.940] result() for ClusterFuture ... done
[10:29:55.941] result() for ClusterFuture ...
[10:29:55.941] - result already collected: FutureResult
[10:29:55.941] result() for ClusterFuture ... done
[10:29:55.941] result() for ClusterFuture ...
[10:29:55.941] - result already collected: FutureResult
[10:29:55.941] result() for ClusterFuture ... done
[10:29:55.941] result() for ClusterFuture ...
[10:29:55.941] - result already collected: FutureResult
[10:29:55.941] result() for ClusterFuture ... done
[10:29:55.941] - relayed: [n=2] TRUE, TRUE
[10:29:55.941] - queued futures: [n=2] TRUE, TRUE
[10:29:55.942] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:29:55.942]  length: 0 (resolved future 2)
[10:29:55.942] Relaying remaining futures
[10:29:55.942] signalConditionsASAP(NULL, pos=0) ...
[10:29:55.942] - nx: 2
[10:29:55.942] - relay: TRUE
[10:29:55.942] - stdout: TRUE
[10:29:55.942] - signal: TRUE
[10:29:55.942] - resignal: FALSE
[10:29:55.942] - force: TRUE
[10:29:55.942] - relayed: [n=2] TRUE, TRUE
[10:29:55.942] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:55.943] - relayed: [n=2] TRUE, TRUE
[10:29:55.943] - queued futures: [n=2] TRUE, TRUE
[10:29:55.943] signalConditionsASAP(NULL, pos=0) ... done
[10:29:55.943] resolve() on list ... DONE
[10:29:55.943] result() for ClusterFuture ...
[10:29:55.943] - result already collected: FutureResult
[10:29:55.943] result() for ClusterFuture ... done
[10:29:55.943] result() for ClusterFuture ...
[10:29:55.943] - result already collected: FutureResult
[10:29:55.943] result() for ClusterFuture ... done
[10:29:55.944] result() for ClusterFuture ...
[10:29:55.944] - result already collected: FutureResult
[10:29:55.944] result() for ClusterFuture ... done
[10:29:55.944] result() for ClusterFuture ...
[10:29:55.944] - result already collected: FutureResult
[10:29:55.944] result() for ClusterFuture ... done
[10:29:55.944]  - Number of value chunks collected: 2
[10:29:55.944] Resolving 2 futures (chunks) ... DONE
[10:29:55.944] Reducing values from 2 chunks ...
[10:29:55.944]  - Number of values collected after concatenation: 3
[10:29:55.945]  - Number of values expected: 3
[10:29:55.945] Reducing values from 2 chunks ... DONE
[10:29:55.945] future_lapply() ... DONE
[10:29:55.945] future_by_internal() ... DONE
[10:29:55.945] future_by_internal() ...
[10:29:55.945] future_lapply() ...
[10:29:55.950] Number of chunks: 2
[10:29:55.950] getGlobalsAndPackagesXApply() ...
[10:29:55.950]  - future.globals: TRUE
[10:29:55.950] getGlobalsAndPackages() ...
[10:29:55.950] Searching for globals...
[10:29:55.951] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:55.951] Searching for globals ... DONE
[10:29:55.951] Resolving globals: FALSE
[10:29:55.952] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:55.952] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:55.952] - globals: [1] ‘FUN’
[10:29:55.952] 
[10:29:55.952] getGlobalsAndPackages() ... DONE
[10:29:55.952]  - globals found/used: [n=1] ‘FUN’
[10:29:55.953]  - needed namespaces: [n=0] 
[10:29:55.953] Finding globals ... DONE
[10:29:55.953]  - use_args: TRUE
[10:29:55.953]  - Getting '...' globals ...
[10:29:55.953] resolve() on list ...
[10:29:55.953]  recursive: 0
[10:29:55.953]  length: 1
[10:29:55.953]  elements: ‘...’
[10:29:55.954]  length: 0 (resolved future 1)
[10:29:55.954] resolve() on list ... DONE
[10:29:55.954]    - '...' content: [n=1] ‘digits’
[10:29:55.954] List of 1
[10:29:55.954]  $ ...:List of 1
[10:29:55.954]   ..$ digits: int 2
[10:29:55.954]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:55.954]  - attr(*, "where")=List of 1
[10:29:55.954]   ..$ ...:<environment: 0x556dd70250b8> 
[10:29:55.954]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:55.954]  - attr(*, "resolved")= logi TRUE
[10:29:55.954]  - attr(*, "total_size")= num NA
[10:29:55.957]  - Getting '...' globals ... DONE
[10:29:55.957] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:55.957] List of 2
[10:29:55.957]  $ ...future.FUN:function (object, ...)  
[10:29:55.957]  $ ...          :List of 1
[10:29:55.957]   ..$ digits: int 2
[10:29:55.957]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:55.957]  - attr(*, "where")=List of 2
[10:29:55.957]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:55.957]   ..$ ...          :<environment: 0x556dd70250b8> 
[10:29:55.957]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:55.957]  - attr(*, "resolved")= logi FALSE
[10:29:55.957]  - attr(*, "total_size")= num 1296
[10:29:55.960] Packages to be attached in all futures: [n=0] 
[10:29:55.960] getGlobalsAndPackagesXApply() ... DONE
[10:29:55.960] Number of futures (= number of chunks): 2
[10:29:55.960] Launching 2 futures (chunks) ...
[10:29:55.960] Chunk #1 of 2 ...
[10:29:55.961]  - Finding globals in 'X' for chunk #1 ...
[10:29:55.961] getGlobalsAndPackages() ...
[10:29:55.961] Searching for globals...
[10:29:55.961] 
[10:29:55.961] Searching for globals ... DONE
[10:29:55.961] - globals: [0] <none>
[10:29:55.961] getGlobalsAndPackages() ... DONE
[10:29:55.961]    + additional globals found: [n=0] 
[10:29:55.961]    + additional namespaces needed: [n=0] 
[10:29:55.962]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:55.962]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:55.962]  - seeds: <none>
[10:29:55.962]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:55.962] getGlobalsAndPackages() ...
[10:29:55.962] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:55.962] Resolving globals: FALSE
[10:29:55.962] Tweak future expression to call with '...' arguments ...
[10:29:55.962] {
[10:29:55.962]     do.call(function(...) {
[10:29:55.962]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:55.962]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:55.962]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:55.962]             on.exit(options(oopts), add = TRUE)
[10:29:55.962]         }
[10:29:55.962]         {
[10:29:55.962]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:55.962]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:55.962]                 ...future.FUN(...future.X_jj, ...)
[10:29:55.962]             })
[10:29:55.962]         }
[10:29:55.962]     }, args = future.call.arguments)
[10:29:55.962] }
[10:29:55.963] Tweak future expression to call with '...' arguments ... DONE
[10:29:55.963] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:55.963] 
[10:29:55.963] getGlobalsAndPackages() ... DONE
[10:29:55.963] run() for ‘Future’ ...
[10:29:55.964] - state: ‘created’
[10:29:55.964] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:55.977] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:55.978] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:55.978]   - Field: ‘node’
[10:29:55.978]   - Field: ‘label’
[10:29:55.978]   - Field: ‘local’
[10:29:55.978]   - Field: ‘owner’
[10:29:55.978]   - Field: ‘envir’
[10:29:55.978]   - Field: ‘workers’
[10:29:55.978]   - Field: ‘packages’
[10:29:55.978]   - Field: ‘gc’
[10:29:55.978]   - Field: ‘conditions’
[10:29:55.979]   - Field: ‘persistent’
[10:29:55.979]   - Field: ‘expr’
[10:29:55.979]   - Field: ‘uuid’
[10:29:55.979]   - Field: ‘seed’
[10:29:55.979]   - Field: ‘version’
[10:29:55.979]   - Field: ‘result’
[10:29:55.979]   - Field: ‘asynchronous’
[10:29:55.979]   - Field: ‘calls’
[10:29:55.979]   - Field: ‘globals’
[10:29:55.979]   - Field: ‘stdout’
[10:29:55.979]   - Field: ‘earlySignal’
[10:29:55.980]   - Field: ‘lazy’
[10:29:55.980]   - Field: ‘state’
[10:29:55.980] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:55.980] - Launch lazy future ...
[10:29:55.980] Packages needed by the future expression (n = 0): <none>
[10:29:55.980] Packages needed by future strategies (n = 0): <none>
[10:29:55.981] {
[10:29:55.981]     {
[10:29:55.981]         {
[10:29:55.981]             ...future.startTime <- base::Sys.time()
[10:29:55.981]             {
[10:29:55.981]                 {
[10:29:55.981]                   {
[10:29:55.981]                     {
[10:29:55.981]                       base::local({
[10:29:55.981]                         has_future <- base::requireNamespace("future", 
[10:29:55.981]                           quietly = TRUE)
[10:29:55.981]                         if (has_future) {
[10:29:55.981]                           ns <- base::getNamespace("future")
[10:29:55.981]                           version <- ns[[".package"]][["version"]]
[10:29:55.981]                           if (is.null(version)) 
[10:29:55.981]                             version <- utils::packageVersion("future")
[10:29:55.981]                         }
[10:29:55.981]                         else {
[10:29:55.981]                           version <- NULL
[10:29:55.981]                         }
[10:29:55.981]                         if (!has_future || version < "1.8.0") {
[10:29:55.981]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:55.981]                             "", base::R.version$version.string), 
[10:29:55.981]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:55.981]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:55.981]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:55.981]                               "release", "version")], collapse = " "), 
[10:29:55.981]                             hostname = base::Sys.info()[["nodename"]])
[10:29:55.981]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:55.981]                             info)
[10:29:55.981]                           info <- base::paste(info, collapse = "; ")
[10:29:55.981]                           if (!has_future) {
[10:29:55.981]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:55.981]                               info)
[10:29:55.981]                           }
[10:29:55.981]                           else {
[10:29:55.981]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:55.981]                               info, version)
[10:29:55.981]                           }
[10:29:55.981]                           base::stop(msg)
[10:29:55.981]                         }
[10:29:55.981]                       })
[10:29:55.981]                     }
[10:29:55.981]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:55.981]                     base::options(mc.cores = 1L)
[10:29:55.981]                   }
[10:29:55.981]                   ...future.strategy.old <- future::plan("list")
[10:29:55.981]                   options(future.plan = NULL)
[10:29:55.981]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:55.981]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:55.981]                 }
[10:29:55.981]                 ...future.workdir <- getwd()
[10:29:55.981]             }
[10:29:55.981]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:55.981]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:55.981]         }
[10:29:55.981]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:55.981]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:55.981]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:55.981]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:55.981]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:55.981]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:55.981]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:55.981]             base::names(...future.oldOptions))
[10:29:55.981]     }
[10:29:55.981]     if (FALSE) {
[10:29:55.981]     }
[10:29:55.981]     else {
[10:29:55.981]         if (TRUE) {
[10:29:55.981]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:55.981]                 open = "w")
[10:29:55.981]         }
[10:29:55.981]         else {
[10:29:55.981]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:55.981]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:55.981]         }
[10:29:55.981]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:55.981]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:55.981]             base::sink(type = "output", split = FALSE)
[10:29:55.981]             base::close(...future.stdout)
[10:29:55.981]         }, add = TRUE)
[10:29:55.981]     }
[10:29:55.981]     ...future.frame <- base::sys.nframe()
[10:29:55.981]     ...future.conditions <- base::list()
[10:29:55.981]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:55.981]     if (FALSE) {
[10:29:55.981]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:55.981]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:55.981]     }
[10:29:55.981]     ...future.result <- base::tryCatch({
[10:29:55.981]         base::withCallingHandlers({
[10:29:55.981]             ...future.value <- base::withVisible(base::local({
[10:29:55.981]                 ...future.makeSendCondition <- base::local({
[10:29:55.981]                   sendCondition <- NULL
[10:29:55.981]                   function(frame = 1L) {
[10:29:55.981]                     if (is.function(sendCondition)) 
[10:29:55.981]                       return(sendCondition)
[10:29:55.981]                     ns <- getNamespace("parallel")
[10:29:55.981]                     if (exists("sendData", mode = "function", 
[10:29:55.981]                       envir = ns)) {
[10:29:55.981]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:55.981]                         envir = ns)
[10:29:55.981]                       envir <- sys.frame(frame)
[10:29:55.981]                       master <- NULL
[10:29:55.981]                       while (!identical(envir, .GlobalEnv) && 
[10:29:55.981]                         !identical(envir, emptyenv())) {
[10:29:55.981]                         if (exists("master", mode = "list", envir = envir, 
[10:29:55.981]                           inherits = FALSE)) {
[10:29:55.981]                           master <- get("master", mode = "list", 
[10:29:55.981]                             envir = envir, inherits = FALSE)
[10:29:55.981]                           if (inherits(master, c("SOCKnode", 
[10:29:55.981]                             "SOCK0node"))) {
[10:29:55.981]                             sendCondition <<- function(cond) {
[10:29:55.981]                               data <- list(type = "VALUE", value = cond, 
[10:29:55.981]                                 success = TRUE)
[10:29:55.981]                               parallel_sendData(master, data)
[10:29:55.981]                             }
[10:29:55.981]                             return(sendCondition)
[10:29:55.981]                           }
[10:29:55.981]                         }
[10:29:55.981]                         frame <- frame + 1L
[10:29:55.981]                         envir <- sys.frame(frame)
[10:29:55.981]                       }
[10:29:55.981]                     }
[10:29:55.981]                     sendCondition <<- function(cond) NULL
[10:29:55.981]                   }
[10:29:55.981]                 })
[10:29:55.981]                 withCallingHandlers({
[10:29:55.981]                   {
[10:29:55.981]                     do.call(function(...) {
[10:29:55.981]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:55.981]                       if (!identical(...future.globals.maxSize.org, 
[10:29:55.981]                         ...future.globals.maxSize)) {
[10:29:55.981]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:55.981]                         on.exit(options(oopts), add = TRUE)
[10:29:55.981]                       }
[10:29:55.981]                       {
[10:29:55.981]                         lapply(seq_along(...future.elements_ii), 
[10:29:55.981]                           FUN = function(jj) {
[10:29:55.981]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:55.981]                             ...future.FUN(...future.X_jj, ...)
[10:29:55.981]                           })
[10:29:55.981]                       }
[10:29:55.981]                     }, args = future.call.arguments)
[10:29:55.981]                   }
[10:29:55.981]                 }, immediateCondition = function(cond) {
[10:29:55.981]                   sendCondition <- ...future.makeSendCondition()
[10:29:55.981]                   sendCondition(cond)
[10:29:55.981]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:55.981]                   {
[10:29:55.981]                     inherits <- base::inherits
[10:29:55.981]                     invokeRestart <- base::invokeRestart
[10:29:55.981]                     is.null <- base::is.null
[10:29:55.981]                     muffled <- FALSE
[10:29:55.981]                     if (inherits(cond, "message")) {
[10:29:55.981]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:55.981]                       if (muffled) 
[10:29:55.981]                         invokeRestart("muffleMessage")
[10:29:55.981]                     }
[10:29:55.981]                     else if (inherits(cond, "warning")) {
[10:29:55.981]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:55.981]                       if (muffled) 
[10:29:55.981]                         invokeRestart("muffleWarning")
[10:29:55.981]                     }
[10:29:55.981]                     else if (inherits(cond, "condition")) {
[10:29:55.981]                       if (!is.null(pattern)) {
[10:29:55.981]                         computeRestarts <- base::computeRestarts
[10:29:55.981]                         grepl <- base::grepl
[10:29:55.981]                         restarts <- computeRestarts(cond)
[10:29:55.981]                         for (restart in restarts) {
[10:29:55.981]                           name <- restart$name
[10:29:55.981]                           if (is.null(name)) 
[10:29:55.981]                             next
[10:29:55.981]                           if (!grepl(pattern, name)) 
[10:29:55.981]                             next
[10:29:55.981]                           invokeRestart(restart)
[10:29:55.981]                           muffled <- TRUE
[10:29:55.981]                           break
[10:29:55.981]                         }
[10:29:55.981]                       }
[10:29:55.981]                     }
[10:29:55.981]                     invisible(muffled)
[10:29:55.981]                   }
[10:29:55.981]                   muffleCondition(cond)
[10:29:55.981]                 })
[10:29:55.981]             }))
[10:29:55.981]             future::FutureResult(value = ...future.value$value, 
[10:29:55.981]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:55.981]                   ...future.rng), globalenv = if (FALSE) 
[10:29:55.981]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:55.981]                     ...future.globalenv.names))
[10:29:55.981]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:55.981]         }, condition = base::local({
[10:29:55.981]             c <- base::c
[10:29:55.981]             inherits <- base::inherits
[10:29:55.981]             invokeRestart <- base::invokeRestart
[10:29:55.981]             length <- base::length
[10:29:55.981]             list <- base::list
[10:29:55.981]             seq.int <- base::seq.int
[10:29:55.981]             signalCondition <- base::signalCondition
[10:29:55.981]             sys.calls <- base::sys.calls
[10:29:55.981]             `[[` <- base::`[[`
[10:29:55.981]             `+` <- base::`+`
[10:29:55.981]             `<<-` <- base::`<<-`
[10:29:55.981]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:55.981]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:55.981]                   3L)]
[10:29:55.981]             }
[10:29:55.981]             function(cond) {
[10:29:55.981]                 is_error <- inherits(cond, "error")
[10:29:55.981]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:55.981]                   NULL)
[10:29:55.981]                 if (is_error) {
[10:29:55.981]                   sessionInformation <- function() {
[10:29:55.981]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:55.981]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:55.981]                       search = base::search(), system = base::Sys.info())
[10:29:55.981]                   }
[10:29:55.981]                   ...future.conditions[[length(...future.conditions) + 
[10:29:55.981]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:55.981]                     cond$call), session = sessionInformation(), 
[10:29:55.981]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:55.981]                   signalCondition(cond)
[10:29:55.981]                 }
[10:29:55.981]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:55.981]                 "immediateCondition"))) {
[10:29:55.981]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:55.981]                   ...future.conditions[[length(...future.conditions) + 
[10:29:55.981]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:55.981]                   if (TRUE && !signal) {
[10:29:55.981]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:55.981]                     {
[10:29:55.981]                       inherits <- base::inherits
[10:29:55.981]                       invokeRestart <- base::invokeRestart
[10:29:55.981]                       is.null <- base::is.null
[10:29:55.981]                       muffled <- FALSE
[10:29:55.981]                       if (inherits(cond, "message")) {
[10:29:55.981]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:55.981]                         if (muffled) 
[10:29:55.981]                           invokeRestart("muffleMessage")
[10:29:55.981]                       }
[10:29:55.981]                       else if (inherits(cond, "warning")) {
[10:29:55.981]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:55.981]                         if (muffled) 
[10:29:55.981]                           invokeRestart("muffleWarning")
[10:29:55.981]                       }
[10:29:55.981]                       else if (inherits(cond, "condition")) {
[10:29:55.981]                         if (!is.null(pattern)) {
[10:29:55.981]                           computeRestarts <- base::computeRestarts
[10:29:55.981]                           grepl <- base::grepl
[10:29:55.981]                           restarts <- computeRestarts(cond)
[10:29:55.981]                           for (restart in restarts) {
[10:29:55.981]                             name <- restart$name
[10:29:55.981]                             if (is.null(name)) 
[10:29:55.981]                               next
[10:29:55.981]                             if (!grepl(pattern, name)) 
[10:29:55.981]                               next
[10:29:55.981]                             invokeRestart(restart)
[10:29:55.981]                             muffled <- TRUE
[10:29:55.981]                             break
[10:29:55.981]                           }
[10:29:55.981]                         }
[10:29:55.981]                       }
[10:29:55.981]                       invisible(muffled)
[10:29:55.981]                     }
[10:29:55.981]                     muffleCondition(cond, pattern = "^muffle")
[10:29:55.981]                   }
[10:29:55.981]                 }
[10:29:55.981]                 else {
[10:29:55.981]                   if (TRUE) {
[10:29:55.981]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:55.981]                     {
[10:29:55.981]                       inherits <- base::inherits
[10:29:55.981]                       invokeRestart <- base::invokeRestart
[10:29:55.981]                       is.null <- base::is.null
[10:29:55.981]                       muffled <- FALSE
[10:29:55.981]                       if (inherits(cond, "message")) {
[10:29:55.981]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:55.981]                         if (muffled) 
[10:29:55.981]                           invokeRestart("muffleMessage")
[10:29:55.981]                       }
[10:29:55.981]                       else if (inherits(cond, "warning")) {
[10:29:55.981]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:55.981]                         if (muffled) 
[10:29:55.981]                           invokeRestart("muffleWarning")
[10:29:55.981]                       }
[10:29:55.981]                       else if (inherits(cond, "condition")) {
[10:29:55.981]                         if (!is.null(pattern)) {
[10:29:55.981]                           computeRestarts <- base::computeRestarts
[10:29:55.981]                           grepl <- base::grepl
[10:29:55.981]                           restarts <- computeRestarts(cond)
[10:29:55.981]                           for (restart in restarts) {
[10:29:55.981]                             name <- restart$name
[10:29:55.981]                             if (is.null(name)) 
[10:29:55.981]                               next
[10:29:55.981]                             if (!grepl(pattern, name)) 
[10:29:55.981]                               next
[10:29:55.981]                             invokeRestart(restart)
[10:29:55.981]                             muffled <- TRUE
[10:29:55.981]                             break
[10:29:55.981]                           }
[10:29:55.981]                         }
[10:29:55.981]                       }
[10:29:55.981]                       invisible(muffled)
[10:29:55.981]                     }
[10:29:55.981]                     muffleCondition(cond, pattern = "^muffle")
[10:29:55.981]                   }
[10:29:55.981]                 }
[10:29:55.981]             }
[10:29:55.981]         }))
[10:29:55.981]     }, error = function(ex) {
[10:29:55.981]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:55.981]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:55.981]                 ...future.rng), started = ...future.startTime, 
[10:29:55.981]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:55.981]             version = "1.8"), class = "FutureResult")
[10:29:55.981]     }, finally = {
[10:29:55.981]         if (!identical(...future.workdir, getwd())) 
[10:29:55.981]             setwd(...future.workdir)
[10:29:55.981]         {
[10:29:55.981]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:55.981]                 ...future.oldOptions$nwarnings <- NULL
[10:29:55.981]             }
[10:29:55.981]             base::options(...future.oldOptions)
[10:29:55.981]             if (.Platform$OS.type == "windows") {
[10:29:55.981]                 old_names <- names(...future.oldEnvVars)
[10:29:55.981]                 envs <- base::Sys.getenv()
[10:29:55.981]                 names <- names(envs)
[10:29:55.981]                 common <- intersect(names, old_names)
[10:29:55.981]                 added <- setdiff(names, old_names)
[10:29:55.981]                 removed <- setdiff(old_names, names)
[10:29:55.981]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:55.981]                   envs[common]]
[10:29:55.981]                 NAMES <- toupper(changed)
[10:29:55.981]                 args <- list()
[10:29:55.981]                 for (kk in seq_along(NAMES)) {
[10:29:55.981]                   name <- changed[[kk]]
[10:29:55.981]                   NAME <- NAMES[[kk]]
[10:29:55.981]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:55.981]                     next
[10:29:55.981]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:55.981]                 }
[10:29:55.981]                 NAMES <- toupper(added)
[10:29:55.981]                 for (kk in seq_along(NAMES)) {
[10:29:55.981]                   name <- added[[kk]]
[10:29:55.981]                   NAME <- NAMES[[kk]]
[10:29:55.981]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:55.981]                     next
[10:29:55.981]                   args[[name]] <- ""
[10:29:55.981]                 }
[10:29:55.981]                 NAMES <- toupper(removed)
[10:29:55.981]                 for (kk in seq_along(NAMES)) {
[10:29:55.981]                   name <- removed[[kk]]
[10:29:55.981]                   NAME <- NAMES[[kk]]
[10:29:55.981]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:55.981]                     next
[10:29:55.981]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:55.981]                 }
[10:29:55.981]                 if (length(args) > 0) 
[10:29:55.981]                   base::do.call(base::Sys.setenv, args = args)
[10:29:55.981]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:55.981]             }
[10:29:55.981]             else {
[10:29:55.981]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:55.981]             }
[10:29:55.981]             {
[10:29:55.981]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:55.981]                   0L) {
[10:29:55.981]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:55.981]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:55.981]                   base::options(opts)
[10:29:55.981]                 }
[10:29:55.981]                 {
[10:29:55.981]                   {
[10:29:55.981]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:55.981]                     NULL
[10:29:55.981]                   }
[10:29:55.981]                   options(future.plan = NULL)
[10:29:55.981]                   if (is.na(NA_character_)) 
[10:29:55.981]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:55.981]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:55.981]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:55.981]                     .init = FALSE)
[10:29:55.981]                 }
[10:29:55.981]             }
[10:29:55.981]         }
[10:29:55.981]     })
[10:29:55.981]     if (TRUE) {
[10:29:55.981]         base::sink(type = "output", split = FALSE)
[10:29:55.981]         if (TRUE) {
[10:29:55.981]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:55.981]         }
[10:29:55.981]         else {
[10:29:55.981]             ...future.result["stdout"] <- base::list(NULL)
[10:29:55.981]         }
[10:29:55.981]         base::close(...future.stdout)
[10:29:55.981]         ...future.stdout <- NULL
[10:29:55.981]     }
[10:29:55.981]     ...future.result$conditions <- ...future.conditions
[10:29:55.981]     ...future.result$finished <- base::Sys.time()
[10:29:55.981]     ...future.result
[10:29:55.981] }
[10:29:55.983] Exporting 5 global objects (1.27 KiB) to cluster node #1 ...
[10:29:55.984] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[10:29:55.984] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[10:29:55.984] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[10:29:55.984] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[10:29:55.985] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ...
[10:29:55.985] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ... DONE
[10:29:55.985] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:29:55.985] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:29:55.986] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:29:55.986] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:29:55.986] Exporting 5 global objects (1.27 KiB) to cluster node #1 ... DONE
[10:29:55.986] MultisessionFuture started
[10:29:55.986] - Launch lazy future ... done
[10:29:55.987] run() for ‘MultisessionFuture’ ... done
[10:29:55.987] Created future:
[10:29:55.987] MultisessionFuture:
[10:29:55.987] Label: ‘future_by-1’
[10:29:55.987] Expression:
[10:29:55.987] {
[10:29:55.987]     do.call(function(...) {
[10:29:55.987]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:55.987]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:55.987]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:55.987]             on.exit(options(oopts), add = TRUE)
[10:29:55.987]         }
[10:29:55.987]         {
[10:29:55.987]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:55.987]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:55.987]                 ...future.FUN(...future.X_jj, ...)
[10:29:55.987]             })
[10:29:55.987]         }
[10:29:55.987]     }, args = future.call.arguments)
[10:29:55.987] }
[10:29:55.987] Lazy evaluation: FALSE
[10:29:55.987] Asynchronous evaluation: TRUE
[10:29:55.987] Local evaluation: TRUE
[10:29:55.987] Environment: R_GlobalEnv
[10:29:55.987] Capture standard output: TRUE
[10:29:55.987] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:55.987] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:55.987] Packages: <none>
[10:29:55.987] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:55.987] Resolved: FALSE
[10:29:55.987] Value: <not collected>
[10:29:55.987] Conditions captured: <none>
[10:29:55.987] Early signaling: FALSE
[10:29:55.987] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:55.987] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:55.998] Chunk #1 of 2 ... DONE
[10:29:55.998] Chunk #2 of 2 ...
[10:29:55.998]  - Finding globals in 'X' for chunk #2 ...
[10:29:55.999] getGlobalsAndPackages() ...
[10:29:55.999] Searching for globals...
[10:29:55.999] 
[10:29:55.999] Searching for globals ... DONE
[10:29:55.999] - globals: [0] <none>
[10:29:55.999] getGlobalsAndPackages() ... DONE
[10:29:55.999]    + additional globals found: [n=0] 
[10:29:55.999]    + additional namespaces needed: [n=0] 
[10:29:55.999]  - Finding globals in 'X' for chunk #2 ... DONE
[10:29:56.000]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:56.000]  - seeds: <none>
[10:29:56.000]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.000] getGlobalsAndPackages() ...
[10:29:56.000] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.000] Resolving globals: FALSE
[10:29:56.000] Tweak future expression to call with '...' arguments ...
[10:29:56.000] {
[10:29:56.000]     do.call(function(...) {
[10:29:56.000]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.000]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:56.000]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.000]             on.exit(options(oopts), add = TRUE)
[10:29:56.000]         }
[10:29:56.000]         {
[10:29:56.000]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:56.000]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.000]                 ...future.FUN(...future.X_jj, ...)
[10:29:56.000]             })
[10:29:56.000]         }
[10:29:56.000]     }, args = future.call.arguments)
[10:29:56.000] }
[10:29:56.001] Tweak future expression to call with '...' arguments ... DONE
[10:29:56.001] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.001] 
[10:29:56.001] getGlobalsAndPackages() ... DONE
[10:29:56.002] run() for ‘Future’ ...
[10:29:56.002] - state: ‘created’
[10:29:56.002] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:56.015] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:56.015] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:56.016]   - Field: ‘node’
[10:29:56.016]   - Field: ‘label’
[10:29:56.016]   - Field: ‘local’
[10:29:56.016]   - Field: ‘owner’
[10:29:56.016]   - Field: ‘envir’
[10:29:56.016]   - Field: ‘workers’
[10:29:56.016]   - Field: ‘packages’
[10:29:56.016]   - Field: ‘gc’
[10:29:56.016]   - Field: ‘conditions’
[10:29:56.016]   - Field: ‘persistent’
[10:29:56.017]   - Field: ‘expr’
[10:29:56.017]   - Field: ‘uuid’
[10:29:56.017]   - Field: ‘seed’
[10:29:56.017]   - Field: ‘version’
[10:29:56.017]   - Field: ‘result’
[10:29:56.017]   - Field: ‘asynchronous’
[10:29:56.017]   - Field: ‘calls’
[10:29:56.017]   - Field: ‘globals’
[10:29:56.017]   - Field: ‘stdout’
[10:29:56.017]   - Field: ‘earlySignal’
[10:29:56.017]   - Field: ‘lazy’
[10:29:56.018]   - Field: ‘state’
[10:29:56.018] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:56.018] - Launch lazy future ...
[10:29:56.018] Packages needed by the future expression (n = 0): <none>
[10:29:56.018] Packages needed by future strategies (n = 0): <none>
[10:29:56.019] {
[10:29:56.019]     {
[10:29:56.019]         {
[10:29:56.019]             ...future.startTime <- base::Sys.time()
[10:29:56.019]             {
[10:29:56.019]                 {
[10:29:56.019]                   {
[10:29:56.019]                     {
[10:29:56.019]                       base::local({
[10:29:56.019]                         has_future <- base::requireNamespace("future", 
[10:29:56.019]                           quietly = TRUE)
[10:29:56.019]                         if (has_future) {
[10:29:56.019]                           ns <- base::getNamespace("future")
[10:29:56.019]                           version <- ns[[".package"]][["version"]]
[10:29:56.019]                           if (is.null(version)) 
[10:29:56.019]                             version <- utils::packageVersion("future")
[10:29:56.019]                         }
[10:29:56.019]                         else {
[10:29:56.019]                           version <- NULL
[10:29:56.019]                         }
[10:29:56.019]                         if (!has_future || version < "1.8.0") {
[10:29:56.019]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:56.019]                             "", base::R.version$version.string), 
[10:29:56.019]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:56.019]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:56.019]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:56.019]                               "release", "version")], collapse = " "), 
[10:29:56.019]                             hostname = base::Sys.info()[["nodename"]])
[10:29:56.019]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:56.019]                             info)
[10:29:56.019]                           info <- base::paste(info, collapse = "; ")
[10:29:56.019]                           if (!has_future) {
[10:29:56.019]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:56.019]                               info)
[10:29:56.019]                           }
[10:29:56.019]                           else {
[10:29:56.019]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:56.019]                               info, version)
[10:29:56.019]                           }
[10:29:56.019]                           base::stop(msg)
[10:29:56.019]                         }
[10:29:56.019]                       })
[10:29:56.019]                     }
[10:29:56.019]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:56.019]                     base::options(mc.cores = 1L)
[10:29:56.019]                   }
[10:29:56.019]                   ...future.strategy.old <- future::plan("list")
[10:29:56.019]                   options(future.plan = NULL)
[10:29:56.019]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:56.019]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:56.019]                 }
[10:29:56.019]                 ...future.workdir <- getwd()
[10:29:56.019]             }
[10:29:56.019]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:56.019]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:56.019]         }
[10:29:56.019]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:56.019]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:56.019]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:56.019]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:56.019]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:56.019]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:56.019]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:56.019]             base::names(...future.oldOptions))
[10:29:56.019]     }
[10:29:56.019]     if (FALSE) {
[10:29:56.019]     }
[10:29:56.019]     else {
[10:29:56.019]         if (TRUE) {
[10:29:56.019]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:56.019]                 open = "w")
[10:29:56.019]         }
[10:29:56.019]         else {
[10:29:56.019]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:56.019]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:56.019]         }
[10:29:56.019]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:56.019]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:56.019]             base::sink(type = "output", split = FALSE)
[10:29:56.019]             base::close(...future.stdout)
[10:29:56.019]         }, add = TRUE)
[10:29:56.019]     }
[10:29:56.019]     ...future.frame <- base::sys.nframe()
[10:29:56.019]     ...future.conditions <- base::list()
[10:29:56.019]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:56.019]     if (FALSE) {
[10:29:56.019]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:56.019]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:56.019]     }
[10:29:56.019]     ...future.result <- base::tryCatch({
[10:29:56.019]         base::withCallingHandlers({
[10:29:56.019]             ...future.value <- base::withVisible(base::local({
[10:29:56.019]                 ...future.makeSendCondition <- base::local({
[10:29:56.019]                   sendCondition <- NULL
[10:29:56.019]                   function(frame = 1L) {
[10:29:56.019]                     if (is.function(sendCondition)) 
[10:29:56.019]                       return(sendCondition)
[10:29:56.019]                     ns <- getNamespace("parallel")
[10:29:56.019]                     if (exists("sendData", mode = "function", 
[10:29:56.019]                       envir = ns)) {
[10:29:56.019]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:56.019]                         envir = ns)
[10:29:56.019]                       envir <- sys.frame(frame)
[10:29:56.019]                       master <- NULL
[10:29:56.019]                       while (!identical(envir, .GlobalEnv) && 
[10:29:56.019]                         !identical(envir, emptyenv())) {
[10:29:56.019]                         if (exists("master", mode = "list", envir = envir, 
[10:29:56.019]                           inherits = FALSE)) {
[10:29:56.019]                           master <- get("master", mode = "list", 
[10:29:56.019]                             envir = envir, inherits = FALSE)
[10:29:56.019]                           if (inherits(master, c("SOCKnode", 
[10:29:56.019]                             "SOCK0node"))) {
[10:29:56.019]                             sendCondition <<- function(cond) {
[10:29:56.019]                               data <- list(type = "VALUE", value = cond, 
[10:29:56.019]                                 success = TRUE)
[10:29:56.019]                               parallel_sendData(master, data)
[10:29:56.019]                             }
[10:29:56.019]                             return(sendCondition)
[10:29:56.019]                           }
[10:29:56.019]                         }
[10:29:56.019]                         frame <- frame + 1L
[10:29:56.019]                         envir <- sys.frame(frame)
[10:29:56.019]                       }
[10:29:56.019]                     }
[10:29:56.019]                     sendCondition <<- function(cond) NULL
[10:29:56.019]                   }
[10:29:56.019]                 })
[10:29:56.019]                 withCallingHandlers({
[10:29:56.019]                   {
[10:29:56.019]                     do.call(function(...) {
[10:29:56.019]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.019]                       if (!identical(...future.globals.maxSize.org, 
[10:29:56.019]                         ...future.globals.maxSize)) {
[10:29:56.019]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.019]                         on.exit(options(oopts), add = TRUE)
[10:29:56.019]                       }
[10:29:56.019]                       {
[10:29:56.019]                         lapply(seq_along(...future.elements_ii), 
[10:29:56.019]                           FUN = function(jj) {
[10:29:56.019]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.019]                             ...future.FUN(...future.X_jj, ...)
[10:29:56.019]                           })
[10:29:56.019]                       }
[10:29:56.019]                     }, args = future.call.arguments)
[10:29:56.019]                   }
[10:29:56.019]                 }, immediateCondition = function(cond) {
[10:29:56.019]                   sendCondition <- ...future.makeSendCondition()
[10:29:56.019]                   sendCondition(cond)
[10:29:56.019]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.019]                   {
[10:29:56.019]                     inherits <- base::inherits
[10:29:56.019]                     invokeRestart <- base::invokeRestart
[10:29:56.019]                     is.null <- base::is.null
[10:29:56.019]                     muffled <- FALSE
[10:29:56.019]                     if (inherits(cond, "message")) {
[10:29:56.019]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:56.019]                       if (muffled) 
[10:29:56.019]                         invokeRestart("muffleMessage")
[10:29:56.019]                     }
[10:29:56.019]                     else if (inherits(cond, "warning")) {
[10:29:56.019]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:56.019]                       if (muffled) 
[10:29:56.019]                         invokeRestart("muffleWarning")
[10:29:56.019]                     }
[10:29:56.019]                     else if (inherits(cond, "condition")) {
[10:29:56.019]                       if (!is.null(pattern)) {
[10:29:56.019]                         computeRestarts <- base::computeRestarts
[10:29:56.019]                         grepl <- base::grepl
[10:29:56.019]                         restarts <- computeRestarts(cond)
[10:29:56.019]                         for (restart in restarts) {
[10:29:56.019]                           name <- restart$name
[10:29:56.019]                           if (is.null(name)) 
[10:29:56.019]                             next
[10:29:56.019]                           if (!grepl(pattern, name)) 
[10:29:56.019]                             next
[10:29:56.019]                           invokeRestart(restart)
[10:29:56.019]                           muffled <- TRUE
[10:29:56.019]                           break
[10:29:56.019]                         }
[10:29:56.019]                       }
[10:29:56.019]                     }
[10:29:56.019]                     invisible(muffled)
[10:29:56.019]                   }
[10:29:56.019]                   muffleCondition(cond)
[10:29:56.019]                 })
[10:29:56.019]             }))
[10:29:56.019]             future::FutureResult(value = ...future.value$value, 
[10:29:56.019]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:56.019]                   ...future.rng), globalenv = if (FALSE) 
[10:29:56.019]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:56.019]                     ...future.globalenv.names))
[10:29:56.019]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:56.019]         }, condition = base::local({
[10:29:56.019]             c <- base::c
[10:29:56.019]             inherits <- base::inherits
[10:29:56.019]             invokeRestart <- base::invokeRestart
[10:29:56.019]             length <- base::length
[10:29:56.019]             list <- base::list
[10:29:56.019]             seq.int <- base::seq.int
[10:29:56.019]             signalCondition <- base::signalCondition
[10:29:56.019]             sys.calls <- base::sys.calls
[10:29:56.019]             `[[` <- base::`[[`
[10:29:56.019]             `+` <- base::`+`
[10:29:56.019]             `<<-` <- base::`<<-`
[10:29:56.019]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:56.019]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:56.019]                   3L)]
[10:29:56.019]             }
[10:29:56.019]             function(cond) {
[10:29:56.019]                 is_error <- inherits(cond, "error")
[10:29:56.019]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:56.019]                   NULL)
[10:29:56.019]                 if (is_error) {
[10:29:56.019]                   sessionInformation <- function() {
[10:29:56.019]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:56.019]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:56.019]                       search = base::search(), system = base::Sys.info())
[10:29:56.019]                   }
[10:29:56.019]                   ...future.conditions[[length(...future.conditions) + 
[10:29:56.019]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:56.019]                     cond$call), session = sessionInformation(), 
[10:29:56.019]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:56.019]                   signalCondition(cond)
[10:29:56.019]                 }
[10:29:56.019]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:56.019]                 "immediateCondition"))) {
[10:29:56.019]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:56.019]                   ...future.conditions[[length(...future.conditions) + 
[10:29:56.019]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:56.019]                   if (TRUE && !signal) {
[10:29:56.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.019]                     {
[10:29:56.019]                       inherits <- base::inherits
[10:29:56.019]                       invokeRestart <- base::invokeRestart
[10:29:56.019]                       is.null <- base::is.null
[10:29:56.019]                       muffled <- FALSE
[10:29:56.019]                       if (inherits(cond, "message")) {
[10:29:56.019]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:56.019]                         if (muffled) 
[10:29:56.019]                           invokeRestart("muffleMessage")
[10:29:56.019]                       }
[10:29:56.019]                       else if (inherits(cond, "warning")) {
[10:29:56.019]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:56.019]                         if (muffled) 
[10:29:56.019]                           invokeRestart("muffleWarning")
[10:29:56.019]                       }
[10:29:56.019]                       else if (inherits(cond, "condition")) {
[10:29:56.019]                         if (!is.null(pattern)) {
[10:29:56.019]                           computeRestarts <- base::computeRestarts
[10:29:56.019]                           grepl <- base::grepl
[10:29:56.019]                           restarts <- computeRestarts(cond)
[10:29:56.019]                           for (restart in restarts) {
[10:29:56.019]                             name <- restart$name
[10:29:56.019]                             if (is.null(name)) 
[10:29:56.019]                               next
[10:29:56.019]                             if (!grepl(pattern, name)) 
[10:29:56.019]                               next
[10:29:56.019]                             invokeRestart(restart)
[10:29:56.019]                             muffled <- TRUE
[10:29:56.019]                             break
[10:29:56.019]                           }
[10:29:56.019]                         }
[10:29:56.019]                       }
[10:29:56.019]                       invisible(muffled)
[10:29:56.019]                     }
[10:29:56.019]                     muffleCondition(cond, pattern = "^muffle")
[10:29:56.019]                   }
[10:29:56.019]                 }
[10:29:56.019]                 else {
[10:29:56.019]                   if (TRUE) {
[10:29:56.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.019]                     {
[10:29:56.019]                       inherits <- base::inherits
[10:29:56.019]                       invokeRestart <- base::invokeRestart
[10:29:56.019]                       is.null <- base::is.null
[10:29:56.019]                       muffled <- FALSE
[10:29:56.019]                       if (inherits(cond, "message")) {
[10:29:56.019]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:56.019]                         if (muffled) 
[10:29:56.019]                           invokeRestart("muffleMessage")
[10:29:56.019]                       }
[10:29:56.019]                       else if (inherits(cond, "warning")) {
[10:29:56.019]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:56.019]                         if (muffled) 
[10:29:56.019]                           invokeRestart("muffleWarning")
[10:29:56.019]                       }
[10:29:56.019]                       else if (inherits(cond, "condition")) {
[10:29:56.019]                         if (!is.null(pattern)) {
[10:29:56.019]                           computeRestarts <- base::computeRestarts
[10:29:56.019]                           grepl <- base::grepl
[10:29:56.019]                           restarts <- computeRestarts(cond)
[10:29:56.019]                           for (restart in restarts) {
[10:29:56.019]                             name <- restart$name
[10:29:56.019]                             if (is.null(name)) 
[10:29:56.019]                               next
[10:29:56.019]                             if (!grepl(pattern, name)) 
[10:29:56.019]                               next
[10:29:56.019]                             invokeRestart(restart)
[10:29:56.019]                             muffled <- TRUE
[10:29:56.019]                             break
[10:29:56.019]                           }
[10:29:56.019]                         }
[10:29:56.019]                       }
[10:29:56.019]                       invisible(muffled)
[10:29:56.019]                     }
[10:29:56.019]                     muffleCondition(cond, pattern = "^muffle")
[10:29:56.019]                   }
[10:29:56.019]                 }
[10:29:56.019]             }
[10:29:56.019]         }))
[10:29:56.019]     }, error = function(ex) {
[10:29:56.019]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:56.019]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:56.019]                 ...future.rng), started = ...future.startTime, 
[10:29:56.019]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:56.019]             version = "1.8"), class = "FutureResult")
[10:29:56.019]     }, finally = {
[10:29:56.019]         if (!identical(...future.workdir, getwd())) 
[10:29:56.019]             setwd(...future.workdir)
[10:29:56.019]         {
[10:29:56.019]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:56.019]                 ...future.oldOptions$nwarnings <- NULL
[10:29:56.019]             }
[10:29:56.019]             base::options(...future.oldOptions)
[10:29:56.019]             if (.Platform$OS.type == "windows") {
[10:29:56.019]                 old_names <- names(...future.oldEnvVars)
[10:29:56.019]                 envs <- base::Sys.getenv()
[10:29:56.019]                 names <- names(envs)
[10:29:56.019]                 common <- intersect(names, old_names)
[10:29:56.019]                 added <- setdiff(names, old_names)
[10:29:56.019]                 removed <- setdiff(old_names, names)
[10:29:56.019]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:56.019]                   envs[common]]
[10:29:56.019]                 NAMES <- toupper(changed)
[10:29:56.019]                 args <- list()
[10:29:56.019]                 for (kk in seq_along(NAMES)) {
[10:29:56.019]                   name <- changed[[kk]]
[10:29:56.019]                   NAME <- NAMES[[kk]]
[10:29:56.019]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.019]                     next
[10:29:56.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:56.019]                 }
[10:29:56.019]                 NAMES <- toupper(added)
[10:29:56.019]                 for (kk in seq_along(NAMES)) {
[10:29:56.019]                   name <- added[[kk]]
[10:29:56.019]                   NAME <- NAMES[[kk]]
[10:29:56.019]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.019]                     next
[10:29:56.019]                   args[[name]] <- ""
[10:29:56.019]                 }
[10:29:56.019]                 NAMES <- toupper(removed)
[10:29:56.019]                 for (kk in seq_along(NAMES)) {
[10:29:56.019]                   name <- removed[[kk]]
[10:29:56.019]                   NAME <- NAMES[[kk]]
[10:29:56.019]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.019]                     next
[10:29:56.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:56.019]                 }
[10:29:56.019]                 if (length(args) > 0) 
[10:29:56.019]                   base::do.call(base::Sys.setenv, args = args)
[10:29:56.019]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:56.019]             }
[10:29:56.019]             else {
[10:29:56.019]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:56.019]             }
[10:29:56.019]             {
[10:29:56.019]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:56.019]                   0L) {
[10:29:56.019]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:56.019]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:56.019]                   base::options(opts)
[10:29:56.019]                 }
[10:29:56.019]                 {
[10:29:56.019]                   {
[10:29:56.019]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:56.019]                     NULL
[10:29:56.019]                   }
[10:29:56.019]                   options(future.plan = NULL)
[10:29:56.019]                   if (is.na(NA_character_)) 
[10:29:56.019]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:56.019]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:56.019]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:56.019]                     .init = FALSE)
[10:29:56.019]                 }
[10:29:56.019]             }
[10:29:56.019]         }
[10:29:56.019]     })
[10:29:56.019]     if (TRUE) {
[10:29:56.019]         base::sink(type = "output", split = FALSE)
[10:29:56.019]         if (TRUE) {
[10:29:56.019]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:56.019]         }
[10:29:56.019]         else {
[10:29:56.019]             ...future.result["stdout"] <- base::list(NULL)
[10:29:56.019]         }
[10:29:56.019]         base::close(...future.stdout)
[10:29:56.019]         ...future.stdout <- NULL
[10:29:56.019]     }
[10:29:56.019]     ...future.result$conditions <- ...future.conditions
[10:29:56.019]     ...future.result$finished <- base::Sys.time()
[10:29:56.019]     ...future.result
[10:29:56.019] }
[10:29:56.021] Exporting 5 global objects (1.27 KiB) to cluster node #2 ...
[10:29:56.022] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[10:29:56.022] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[10:29:56.022] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[10:29:56.023] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[10:29:56.023] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ...
[10:29:56.023] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ... DONE
[10:29:56.023] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:29:56.024] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:29:56.024] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:29:56.024] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:29:56.025] Exporting 5 global objects (1.27 KiB) to cluster node #2 ... DONE
[10:29:56.025] MultisessionFuture started
[10:29:56.025] - Launch lazy future ... done
[10:29:56.025] run() for ‘MultisessionFuture’ ... done
[10:29:56.026] Created future:
[10:29:56.026] MultisessionFuture:
[10:29:56.026] Label: ‘future_by-2’
[10:29:56.026] Expression:
[10:29:56.026] {
[10:29:56.026]     do.call(function(...) {
[10:29:56.026]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.026]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:56.026]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.026]             on.exit(options(oopts), add = TRUE)
[10:29:56.026]         }
[10:29:56.026]         {
[10:29:56.026]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:56.026]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.026]                 ...future.FUN(...future.X_jj, ...)
[10:29:56.026]             })
[10:29:56.026]         }
[10:29:56.026]     }, args = future.call.arguments)
[10:29:56.026] }
[10:29:56.026] Lazy evaluation: FALSE
[10:29:56.026] Asynchronous evaluation: TRUE
[10:29:56.026] Local evaluation: TRUE
[10:29:56.026] Environment: R_GlobalEnv
[10:29:56.026] Capture standard output: TRUE
[10:29:56.026] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:56.026] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:56.026] Packages: <none>
[10:29:56.026] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:56.026] Resolved: FALSE
[10:29:56.026] Value: <not collected>
[10:29:56.026] Conditions captured: <none>
[10:29:56.026] Early signaling: FALSE
[10:29:56.026] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:56.026] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:56.037] Chunk #2 of 2 ... DONE
[10:29:56.038] Launching 2 futures (chunks) ... DONE
[10:29:56.038] Resolving 2 futures (chunks) ...
[10:29:56.038] resolve() on list ...
[10:29:56.038]  recursive: 0
[10:29:56.038]  length: 2
[10:29:56.038] 
[10:29:56.039] receiveMessageFromWorker() for ClusterFuture ...
[10:29:56.039] - Validating connection of MultisessionFuture
[10:29:56.039] - received message: FutureResult
[10:29:56.039] - Received FutureResult
[10:29:56.039] - Erased future from FutureRegistry
[10:29:56.039] result() for ClusterFuture ...
[10:29:56.040] - result already collected: FutureResult
[10:29:56.040] result() for ClusterFuture ... done
[10:29:56.040] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:56.040] Future #1
[10:29:56.040] result() for ClusterFuture ...
[10:29:56.040] - result already collected: FutureResult
[10:29:56.040] result() for ClusterFuture ... done
[10:29:56.040] result() for ClusterFuture ...
[10:29:56.040] - result already collected: FutureResult
[10:29:56.040] result() for ClusterFuture ... done
[10:29:56.040] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:29:56.041] - nx: 2
[10:29:56.041] - relay: TRUE
[10:29:56.041] - stdout: TRUE
[10:29:56.041] - signal: TRUE
[10:29:56.041] - resignal: FALSE
[10:29:56.041] - force: TRUE
[10:29:56.041] - relayed: [n=2] FALSE, FALSE
[10:29:56.041] - queued futures: [n=2] FALSE, FALSE
[10:29:56.041]  - until=1
[10:29:56.041]  - relaying element #1
[10:29:56.041] result() for ClusterFuture ...
[10:29:56.042] - result already collected: FutureResult
[10:29:56.042] result() for ClusterFuture ... done
[10:29:56.042] result() for ClusterFuture ...
[10:29:56.042] - result already collected: FutureResult
[10:29:56.042] result() for ClusterFuture ... done
[10:29:56.042] result() for ClusterFuture ...
[10:29:56.042] - result already collected: FutureResult
[10:29:56.042] result() for ClusterFuture ... done
[10:29:56.042] result() for ClusterFuture ...
[10:29:56.042] - result already collected: FutureResult
[10:29:56.042] result() for ClusterFuture ... done
[10:29:56.042] - relayed: [n=2] TRUE, FALSE
[10:29:56.043] - queued futures: [n=2] TRUE, FALSE
[10:29:56.043] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:29:56.043]  length: 1 (resolved future 1)
[10:29:56.071] receiveMessageFromWorker() for ClusterFuture ...
[10:29:56.071] - Validating connection of MultisessionFuture
[10:29:56.072] - received message: FutureResult
[10:29:56.072] - Received FutureResult
[10:29:56.072] - Erased future from FutureRegistry
[10:29:56.072] result() for ClusterFuture ...
[10:29:56.072] - result already collected: FutureResult
[10:29:56.072] result() for ClusterFuture ... done
[10:29:56.072] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:56.072] Future #2
[10:29:56.072] result() for ClusterFuture ...
[10:29:56.072] - result already collected: FutureResult
[10:29:56.073] result() for ClusterFuture ... done
[10:29:56.073] result() for ClusterFuture ...
[10:29:56.073] - result already collected: FutureResult
[10:29:56.073] result() for ClusterFuture ... done
[10:29:56.073] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:29:56.073] - nx: 2
[10:29:56.073] - relay: TRUE
[10:29:56.073] - stdout: TRUE
[10:29:56.073] - signal: TRUE
[10:29:56.073] - resignal: FALSE
[10:29:56.074] - force: TRUE
[10:29:56.074] - relayed: [n=2] TRUE, FALSE
[10:29:56.074] - queued futures: [n=2] TRUE, FALSE
[10:29:56.074]  - until=2
[10:29:56.074]  - relaying element #2
[10:29:56.074] result() for ClusterFuture ...
[10:29:56.074] - result already collected: FutureResult
[10:29:56.074] result() for ClusterFuture ... done
[10:29:56.074] result() for ClusterFuture ...
[10:29:56.074] - result already collected: FutureResult
[10:29:56.074] result() for ClusterFuture ... done
[10:29:56.075] result() for ClusterFuture ...
[10:29:56.075] - result already collected: FutureResult
[10:29:56.075] result() for ClusterFuture ... done
[10:29:56.075] result() for ClusterFuture ...
[10:29:56.075] - result already collected: FutureResult
[10:29:56.075] result() for ClusterFuture ... done
[10:29:56.075] - relayed: [n=2] TRUE, TRUE
[10:29:56.075] - queued futures: [n=2] TRUE, TRUE
[10:29:56.075] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:29:56.075]  length: 0 (resolved future 2)
[10:29:56.075] Relaying remaining futures
[10:29:56.076] signalConditionsASAP(NULL, pos=0) ...
[10:29:56.076] - nx: 2
[10:29:56.076] - relay: TRUE
[10:29:56.076] - stdout: TRUE
[10:29:56.076] - signal: TRUE
[10:29:56.076] - resignal: FALSE
[10:29:56.076] - force: TRUE
[10:29:56.076] - relayed: [n=2] TRUE, TRUE
[10:29:56.076] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:56.076] - relayed: [n=2] TRUE, TRUE
[10:29:56.076] - queued futures: [n=2] TRUE, TRUE
[10:29:56.077] signalConditionsASAP(NULL, pos=0) ... done
[10:29:56.077] resolve() on list ... DONE
[10:29:56.077] result() for ClusterFuture ...
[10:29:56.077] - result already collected: FutureResult
[10:29:56.077] result() for ClusterFuture ... done
[10:29:56.077] result() for ClusterFuture ...
[10:29:56.077] - result already collected: FutureResult
[10:29:56.077] result() for ClusterFuture ... done
[10:29:56.077] result() for ClusterFuture ...
[10:29:56.077] - result already collected: FutureResult
[10:29:56.077] result() for ClusterFuture ... done
[10:29:56.078] result() for ClusterFuture ...
[10:29:56.078] - result already collected: FutureResult
[10:29:56.078] result() for ClusterFuture ... done
[10:29:56.078]  - Number of value chunks collected: 2
[10:29:56.078] Resolving 2 futures (chunks) ... DONE
[10:29:56.078] Reducing values from 2 chunks ...
[10:29:56.078]  - Number of values collected after concatenation: 6
[10:29:56.078]  - Number of values expected: 6
[10:29:56.078] Reducing values from 2 chunks ... DONE
[10:29:56.078] future_lapply() ... DONE
[10:29:56.078] future_by_internal() ... DONE
[10:29:56.080] future_by_internal() ...
[10:29:56.080] future_lapply() ...
[10:29:56.085] Number of chunks: 2
[10:29:56.085] getGlobalsAndPackagesXApply() ...
[10:29:56.085]  - future.globals: TRUE
[10:29:56.085] getGlobalsAndPackages() ...
[10:29:56.085] Searching for globals...
[10:29:56.087] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:29:56.087] Searching for globals ... DONE
[10:29:56.087] Resolving globals: FALSE
[10:29:56.087] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[10:29:56.088] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[10:29:56.088] - globals: [1] ‘FUN’
[10:29:56.088] - packages: [1] ‘stats’
[10:29:56.088] getGlobalsAndPackages() ... DONE
[10:29:56.088]  - globals found/used: [n=1] ‘FUN’
[10:29:56.088]  - needed namespaces: [n=1] ‘stats’
[10:29:56.089] Finding globals ... DONE
[10:29:56.089]  - use_args: TRUE
[10:29:56.089]  - Getting '...' globals ...
[10:29:56.089] resolve() on list ...
[10:29:56.089]  recursive: 0
[10:29:56.089]  length: 1
[10:29:56.089]  elements: ‘...’
[10:29:56.089]  length: 0 (resolved future 1)
[10:29:56.090] resolve() on list ... DONE
[10:29:56.090]    - '...' content: [n=1] ‘singular.ok’
[10:29:56.090] List of 1
[10:29:56.090]  $ ...:List of 1
[10:29:56.090]   ..$ singular.ok: logi FALSE
[10:29:56.090]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:56.090]  - attr(*, "where")=List of 1
[10:29:56.090]   ..$ ...:<environment: 0x556dd5216440> 
[10:29:56.090]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:56.090]  - attr(*, "resolved")= logi TRUE
[10:29:56.090]  - attr(*, "total_size")= num NA
[10:29:56.093]  - Getting '...' globals ... DONE
[10:29:56.093] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:56.093] List of 2
[10:29:56.093]  $ ...future.FUN:function (x, ...)  
[10:29:56.093]  $ ...          :List of 1
[10:29:56.093]   ..$ singular.ok: logi FALSE
[10:29:56.093]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:56.093]  - attr(*, "where")=List of 2
[10:29:56.093]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:56.093]   ..$ ...          :<environment: 0x556dd5216440> 
[10:29:56.093]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:56.093]  - attr(*, "resolved")= logi FALSE
[10:29:56.093]  - attr(*, "total_size")= num 5384
[10:29:56.099] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:56.099] getGlobalsAndPackagesXApply() ... DONE
[10:29:56.099] Number of futures (= number of chunks): 2
[10:29:56.099] Launching 2 futures (chunks) ...
[10:29:56.099] Chunk #1 of 2 ...
[10:29:56.099]  - Finding globals in 'X' for chunk #1 ...
[10:29:56.100] getGlobalsAndPackages() ...
[10:29:56.100] Searching for globals...
[10:29:56.100] 
[10:29:56.100] Searching for globals ... DONE
[10:29:56.100] - globals: [0] <none>
[10:29:56.100] getGlobalsAndPackages() ... DONE
[10:29:56.100]    + additional globals found: [n=0] 
[10:29:56.100]    + additional namespaces needed: [n=0] 
[10:29:56.101]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:56.101]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:56.101]  - seeds: <none>
[10:29:56.101]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.101] getGlobalsAndPackages() ...
[10:29:56.101] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.101] Resolving globals: FALSE
[10:29:56.101] Tweak future expression to call with '...' arguments ...
[10:29:56.101] {
[10:29:56.101]     do.call(function(...) {
[10:29:56.101]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.101]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:56.101]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.101]             on.exit(options(oopts), add = TRUE)
[10:29:56.101]         }
[10:29:56.101]         {
[10:29:56.101]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:56.101]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.101]                 ...future.FUN(...future.X_jj, ...)
[10:29:56.101]             })
[10:29:56.101]         }
[10:29:56.101]     }, args = future.call.arguments)
[10:29:56.101] }
[10:29:56.102] Tweak future expression to call with '...' arguments ... DONE
[10:29:56.102] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.102] 
[10:29:56.102] getGlobalsAndPackages() ... DONE
[10:29:56.103] run() for ‘Future’ ...
[10:29:56.103] - state: ‘created’
[10:29:56.103] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:56.117] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:56.117] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:56.117]   - Field: ‘node’
[10:29:56.117]   - Field: ‘label’
[10:29:56.117]   - Field: ‘local’
[10:29:56.117]   - Field: ‘owner’
[10:29:56.117]   - Field: ‘envir’
[10:29:56.117]   - Field: ‘workers’
[10:29:56.117]   - Field: ‘packages’
[10:29:56.118]   - Field: ‘gc’
[10:29:56.118]   - Field: ‘conditions’
[10:29:56.118]   - Field: ‘persistent’
[10:29:56.118]   - Field: ‘expr’
[10:29:56.118]   - Field: ‘uuid’
[10:29:56.118]   - Field: ‘seed’
[10:29:56.118]   - Field: ‘version’
[10:29:56.118]   - Field: ‘result’
[10:29:56.118]   - Field: ‘asynchronous’
[10:29:56.118]   - Field: ‘calls’
[10:29:56.118]   - Field: ‘globals’
[10:29:56.118]   - Field: ‘stdout’
[10:29:56.119]   - Field: ‘earlySignal’
[10:29:56.119]   - Field: ‘lazy’
[10:29:56.119]   - Field: ‘state’
[10:29:56.119] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:56.119] - Launch lazy future ...
[10:29:56.119] Packages needed by the future expression (n = 1): ‘stats’
[10:29:56.119] Packages needed by future strategies (n = 0): <none>
[10:29:56.120] {
[10:29:56.120]     {
[10:29:56.120]         {
[10:29:56.120]             ...future.startTime <- base::Sys.time()
[10:29:56.120]             {
[10:29:56.120]                 {
[10:29:56.120]                   {
[10:29:56.120]                     {
[10:29:56.120]                       {
[10:29:56.120]                         base::local({
[10:29:56.120]                           has_future <- base::requireNamespace("future", 
[10:29:56.120]                             quietly = TRUE)
[10:29:56.120]                           if (has_future) {
[10:29:56.120]                             ns <- base::getNamespace("future")
[10:29:56.120]                             version <- ns[[".package"]][["version"]]
[10:29:56.120]                             if (is.null(version)) 
[10:29:56.120]                               version <- utils::packageVersion("future")
[10:29:56.120]                           }
[10:29:56.120]                           else {
[10:29:56.120]                             version <- NULL
[10:29:56.120]                           }
[10:29:56.120]                           if (!has_future || version < "1.8.0") {
[10:29:56.120]                             info <- base::c(r_version = base::gsub("R version ", 
[10:29:56.120]                               "", base::R.version$version.string), 
[10:29:56.120]                               platform = base::sprintf("%s (%s-bit)", 
[10:29:56.120]                                 base::R.version$platform, 8 * 
[10:29:56.120]                                   base::.Machine$sizeof.pointer), 
[10:29:56.120]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:56.120]                                 "release", "version")], collapse = " "), 
[10:29:56.120]                               hostname = base::Sys.info()[["nodename"]])
[10:29:56.120]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:29:56.120]                               info)
[10:29:56.120]                             info <- base::paste(info, collapse = "; ")
[10:29:56.120]                             if (!has_future) {
[10:29:56.120]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:56.120]                                 info)
[10:29:56.120]                             }
[10:29:56.120]                             else {
[10:29:56.120]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:56.120]                                 info, version)
[10:29:56.120]                             }
[10:29:56.120]                             base::stop(msg)
[10:29:56.120]                           }
[10:29:56.120]                         })
[10:29:56.120]                       }
[10:29:56.120]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:56.120]                       base::options(mc.cores = 1L)
[10:29:56.120]                     }
[10:29:56.120]                     base::local({
[10:29:56.120]                       for (pkg in "stats") {
[10:29:56.120]                         base::loadNamespace(pkg)
[10:29:56.120]                         base::library(pkg, character.only = TRUE)
[10:29:56.120]                       }
[10:29:56.120]                     })
[10:29:56.120]                   }
[10:29:56.120]                   ...future.strategy.old <- future::plan("list")
[10:29:56.120]                   options(future.plan = NULL)
[10:29:56.120]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:56.120]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:56.120]                 }
[10:29:56.120]                 ...future.workdir <- getwd()
[10:29:56.120]             }
[10:29:56.120]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:56.120]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:56.120]         }
[10:29:56.120]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:56.120]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:56.120]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:56.120]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:56.120]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:56.120]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:56.120]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:56.120]             base::names(...future.oldOptions))
[10:29:56.120]     }
[10:29:56.120]     if (FALSE) {
[10:29:56.120]     }
[10:29:56.120]     else {
[10:29:56.120]         if (TRUE) {
[10:29:56.120]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:56.120]                 open = "w")
[10:29:56.120]         }
[10:29:56.120]         else {
[10:29:56.120]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:56.120]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:56.120]         }
[10:29:56.120]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:56.120]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:56.120]             base::sink(type = "output", split = FALSE)
[10:29:56.120]             base::close(...future.stdout)
[10:29:56.120]         }, add = TRUE)
[10:29:56.120]     }
[10:29:56.120]     ...future.frame <- base::sys.nframe()
[10:29:56.120]     ...future.conditions <- base::list()
[10:29:56.120]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:56.120]     if (FALSE) {
[10:29:56.120]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:56.120]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:56.120]     }
[10:29:56.120]     ...future.result <- base::tryCatch({
[10:29:56.120]         base::withCallingHandlers({
[10:29:56.120]             ...future.value <- base::withVisible(base::local({
[10:29:56.120]                 ...future.makeSendCondition <- base::local({
[10:29:56.120]                   sendCondition <- NULL
[10:29:56.120]                   function(frame = 1L) {
[10:29:56.120]                     if (is.function(sendCondition)) 
[10:29:56.120]                       return(sendCondition)
[10:29:56.120]                     ns <- getNamespace("parallel")
[10:29:56.120]                     if (exists("sendData", mode = "function", 
[10:29:56.120]                       envir = ns)) {
[10:29:56.120]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:56.120]                         envir = ns)
[10:29:56.120]                       envir <- sys.frame(frame)
[10:29:56.120]                       master <- NULL
[10:29:56.120]                       while (!identical(envir, .GlobalEnv) && 
[10:29:56.120]                         !identical(envir, emptyenv())) {
[10:29:56.120]                         if (exists("master", mode = "list", envir = envir, 
[10:29:56.120]                           inherits = FALSE)) {
[10:29:56.120]                           master <- get("master", mode = "list", 
[10:29:56.120]                             envir = envir, inherits = FALSE)
[10:29:56.120]                           if (inherits(master, c("SOCKnode", 
[10:29:56.120]                             "SOCK0node"))) {
[10:29:56.120]                             sendCondition <<- function(cond) {
[10:29:56.120]                               data <- list(type = "VALUE", value = cond, 
[10:29:56.120]                                 success = TRUE)
[10:29:56.120]                               parallel_sendData(master, data)
[10:29:56.120]                             }
[10:29:56.120]                             return(sendCondition)
[10:29:56.120]                           }
[10:29:56.120]                         }
[10:29:56.120]                         frame <- frame + 1L
[10:29:56.120]                         envir <- sys.frame(frame)
[10:29:56.120]                       }
[10:29:56.120]                     }
[10:29:56.120]                     sendCondition <<- function(cond) NULL
[10:29:56.120]                   }
[10:29:56.120]                 })
[10:29:56.120]                 withCallingHandlers({
[10:29:56.120]                   {
[10:29:56.120]                     do.call(function(...) {
[10:29:56.120]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.120]                       if (!identical(...future.globals.maxSize.org, 
[10:29:56.120]                         ...future.globals.maxSize)) {
[10:29:56.120]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.120]                         on.exit(options(oopts), add = TRUE)
[10:29:56.120]                       }
[10:29:56.120]                       {
[10:29:56.120]                         lapply(seq_along(...future.elements_ii), 
[10:29:56.120]                           FUN = function(jj) {
[10:29:56.120]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.120]                             ...future.FUN(...future.X_jj, ...)
[10:29:56.120]                           })
[10:29:56.120]                       }
[10:29:56.120]                     }, args = future.call.arguments)
[10:29:56.120]                   }
[10:29:56.120]                 }, immediateCondition = function(cond) {
[10:29:56.120]                   sendCondition <- ...future.makeSendCondition()
[10:29:56.120]                   sendCondition(cond)
[10:29:56.120]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.120]                   {
[10:29:56.120]                     inherits <- base::inherits
[10:29:56.120]                     invokeRestart <- base::invokeRestart
[10:29:56.120]                     is.null <- base::is.null
[10:29:56.120]                     muffled <- FALSE
[10:29:56.120]                     if (inherits(cond, "message")) {
[10:29:56.120]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:56.120]                       if (muffled) 
[10:29:56.120]                         invokeRestart("muffleMessage")
[10:29:56.120]                     }
[10:29:56.120]                     else if (inherits(cond, "warning")) {
[10:29:56.120]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:56.120]                       if (muffled) 
[10:29:56.120]                         invokeRestart("muffleWarning")
[10:29:56.120]                     }
[10:29:56.120]                     else if (inherits(cond, "condition")) {
[10:29:56.120]                       if (!is.null(pattern)) {
[10:29:56.120]                         computeRestarts <- base::computeRestarts
[10:29:56.120]                         grepl <- base::grepl
[10:29:56.120]                         restarts <- computeRestarts(cond)
[10:29:56.120]                         for (restart in restarts) {
[10:29:56.120]                           name <- restart$name
[10:29:56.120]                           if (is.null(name)) 
[10:29:56.120]                             next
[10:29:56.120]                           if (!grepl(pattern, name)) 
[10:29:56.120]                             next
[10:29:56.120]                           invokeRestart(restart)
[10:29:56.120]                           muffled <- TRUE
[10:29:56.120]                           break
[10:29:56.120]                         }
[10:29:56.120]                       }
[10:29:56.120]                     }
[10:29:56.120]                     invisible(muffled)
[10:29:56.120]                   }
[10:29:56.120]                   muffleCondition(cond)
[10:29:56.120]                 })
[10:29:56.120]             }))
[10:29:56.120]             future::FutureResult(value = ...future.value$value, 
[10:29:56.120]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:56.120]                   ...future.rng), globalenv = if (FALSE) 
[10:29:56.120]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:56.120]                     ...future.globalenv.names))
[10:29:56.120]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:56.120]         }, condition = base::local({
[10:29:56.120]             c <- base::c
[10:29:56.120]             inherits <- base::inherits
[10:29:56.120]             invokeRestart <- base::invokeRestart
[10:29:56.120]             length <- base::length
[10:29:56.120]             list <- base::list
[10:29:56.120]             seq.int <- base::seq.int
[10:29:56.120]             signalCondition <- base::signalCondition
[10:29:56.120]             sys.calls <- base::sys.calls
[10:29:56.120]             `[[` <- base::`[[`
[10:29:56.120]             `+` <- base::`+`
[10:29:56.120]             `<<-` <- base::`<<-`
[10:29:56.120]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:56.120]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:56.120]                   3L)]
[10:29:56.120]             }
[10:29:56.120]             function(cond) {
[10:29:56.120]                 is_error <- inherits(cond, "error")
[10:29:56.120]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:56.120]                   NULL)
[10:29:56.120]                 if (is_error) {
[10:29:56.120]                   sessionInformation <- function() {
[10:29:56.120]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:56.120]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:56.120]                       search = base::search(), system = base::Sys.info())
[10:29:56.120]                   }
[10:29:56.120]                   ...future.conditions[[length(...future.conditions) + 
[10:29:56.120]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:56.120]                     cond$call), session = sessionInformation(), 
[10:29:56.120]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:56.120]                   signalCondition(cond)
[10:29:56.120]                 }
[10:29:56.120]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:56.120]                 "immediateCondition"))) {
[10:29:56.120]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:56.120]                   ...future.conditions[[length(...future.conditions) + 
[10:29:56.120]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:56.120]                   if (TRUE && !signal) {
[10:29:56.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.120]                     {
[10:29:56.120]                       inherits <- base::inherits
[10:29:56.120]                       invokeRestart <- base::invokeRestart
[10:29:56.120]                       is.null <- base::is.null
[10:29:56.120]                       muffled <- FALSE
[10:29:56.120]                       if (inherits(cond, "message")) {
[10:29:56.120]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:56.120]                         if (muffled) 
[10:29:56.120]                           invokeRestart("muffleMessage")
[10:29:56.120]                       }
[10:29:56.120]                       else if (inherits(cond, "warning")) {
[10:29:56.120]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:56.120]                         if (muffled) 
[10:29:56.120]                           invokeRestart("muffleWarning")
[10:29:56.120]                       }
[10:29:56.120]                       else if (inherits(cond, "condition")) {
[10:29:56.120]                         if (!is.null(pattern)) {
[10:29:56.120]                           computeRestarts <- base::computeRestarts
[10:29:56.120]                           grepl <- base::grepl
[10:29:56.120]                           restarts <- computeRestarts(cond)
[10:29:56.120]                           for (restart in restarts) {
[10:29:56.120]                             name <- restart$name
[10:29:56.120]                             if (is.null(name)) 
[10:29:56.120]                               next
[10:29:56.120]                             if (!grepl(pattern, name)) 
[10:29:56.120]                               next
[10:29:56.120]                             invokeRestart(restart)
[10:29:56.120]                             muffled <- TRUE
[10:29:56.120]                             break
[10:29:56.120]                           }
[10:29:56.120]                         }
[10:29:56.120]                       }
[10:29:56.120]                       invisible(muffled)
[10:29:56.120]                     }
[10:29:56.120]                     muffleCondition(cond, pattern = "^muffle")
[10:29:56.120]                   }
[10:29:56.120]                 }
[10:29:56.120]                 else {
[10:29:56.120]                   if (TRUE) {
[10:29:56.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.120]                     {
[10:29:56.120]                       inherits <- base::inherits
[10:29:56.120]                       invokeRestart <- base::invokeRestart
[10:29:56.120]                       is.null <- base::is.null
[10:29:56.120]                       muffled <- FALSE
[10:29:56.120]                       if (inherits(cond, "message")) {
[10:29:56.120]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:56.120]                         if (muffled) 
[10:29:56.120]                           invokeRestart("muffleMessage")
[10:29:56.120]                       }
[10:29:56.120]                       else if (inherits(cond, "warning")) {
[10:29:56.120]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:56.120]                         if (muffled) 
[10:29:56.120]                           invokeRestart("muffleWarning")
[10:29:56.120]                       }
[10:29:56.120]                       else if (inherits(cond, "condition")) {
[10:29:56.120]                         if (!is.null(pattern)) {
[10:29:56.120]                           computeRestarts <- base::computeRestarts
[10:29:56.120]                           grepl <- base::grepl
[10:29:56.120]                           restarts <- computeRestarts(cond)
[10:29:56.120]                           for (restart in restarts) {
[10:29:56.120]                             name <- restart$name
[10:29:56.120]                             if (is.null(name)) 
[10:29:56.120]                               next
[10:29:56.120]                             if (!grepl(pattern, name)) 
[10:29:56.120]                               next
[10:29:56.120]                             invokeRestart(restart)
[10:29:56.120]                             muffled <- TRUE
[10:29:56.120]                             break
[10:29:56.120]                           }
[10:29:56.120]                         }
[10:29:56.120]                       }
[10:29:56.120]                       invisible(muffled)
[10:29:56.120]                     }
[10:29:56.120]                     muffleCondition(cond, pattern = "^muffle")
[10:29:56.120]                   }
[10:29:56.120]                 }
[10:29:56.120]             }
[10:29:56.120]         }))
[10:29:56.120]     }, error = function(ex) {
[10:29:56.120]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:56.120]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:56.120]                 ...future.rng), started = ...future.startTime, 
[10:29:56.120]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:56.120]             version = "1.8"), class = "FutureResult")
[10:29:56.120]     }, finally = {
[10:29:56.120]         if (!identical(...future.workdir, getwd())) 
[10:29:56.120]             setwd(...future.workdir)
[10:29:56.120]         {
[10:29:56.120]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:56.120]                 ...future.oldOptions$nwarnings <- NULL
[10:29:56.120]             }
[10:29:56.120]             base::options(...future.oldOptions)
[10:29:56.120]             if (.Platform$OS.type == "windows") {
[10:29:56.120]                 old_names <- names(...future.oldEnvVars)
[10:29:56.120]                 envs <- base::Sys.getenv()
[10:29:56.120]                 names <- names(envs)
[10:29:56.120]                 common <- intersect(names, old_names)
[10:29:56.120]                 added <- setdiff(names, old_names)
[10:29:56.120]                 removed <- setdiff(old_names, names)
[10:29:56.120]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:56.120]                   envs[common]]
[10:29:56.120]                 NAMES <- toupper(changed)
[10:29:56.120]                 args <- list()
[10:29:56.120]                 for (kk in seq_along(NAMES)) {
[10:29:56.120]                   name <- changed[[kk]]
[10:29:56.120]                   NAME <- NAMES[[kk]]
[10:29:56.120]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.120]                     next
[10:29:56.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:56.120]                 }
[10:29:56.120]                 NAMES <- toupper(added)
[10:29:56.120]                 for (kk in seq_along(NAMES)) {
[10:29:56.120]                   name <- added[[kk]]
[10:29:56.120]                   NAME <- NAMES[[kk]]
[10:29:56.120]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.120]                     next
[10:29:56.120]                   args[[name]] <- ""
[10:29:56.120]                 }
[10:29:56.120]                 NAMES <- toupper(removed)
[10:29:56.120]                 for (kk in seq_along(NAMES)) {
[10:29:56.120]                   name <- removed[[kk]]
[10:29:56.120]                   NAME <- NAMES[[kk]]
[10:29:56.120]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.120]                     next
[10:29:56.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:56.120]                 }
[10:29:56.120]                 if (length(args) > 0) 
[10:29:56.120]                   base::do.call(base::Sys.setenv, args = args)
[10:29:56.120]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:56.120]             }
[10:29:56.120]             else {
[10:29:56.120]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:56.120]             }
[10:29:56.120]             {
[10:29:56.120]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:56.120]                   0L) {
[10:29:56.120]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:56.120]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:56.120]                   base::options(opts)
[10:29:56.120]                 }
[10:29:56.120]                 {
[10:29:56.120]                   {
[10:29:56.120]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:56.120]                     NULL
[10:29:56.120]                   }
[10:29:56.120]                   options(future.plan = NULL)
[10:29:56.120]                   if (is.na(NA_character_)) 
[10:29:56.120]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:56.120]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:56.120]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:56.120]                     .init = FALSE)
[10:29:56.120]                 }
[10:29:56.120]             }
[10:29:56.120]         }
[10:29:56.120]     })
[10:29:56.120]     if (TRUE) {
[10:29:56.120]         base::sink(type = "output", split = FALSE)
[10:29:56.120]         if (TRUE) {
[10:29:56.120]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:56.120]         }
[10:29:56.120]         else {
[10:29:56.120]             ...future.result["stdout"] <- base::list(NULL)
[10:29:56.120]         }
[10:29:56.120]         base::close(...future.stdout)
[10:29:56.120]         ...future.stdout <- NULL
[10:29:56.120]     }
[10:29:56.120]     ...future.result$conditions <- ...future.conditions
[10:29:56.120]     ...future.result$finished <- base::Sys.time()
[10:29:56.120]     ...future.result
[10:29:56.120] }
[10:29:56.123] Exporting 5 global objects (5.26 KiB) to cluster node #1 ...
[10:29:56.123] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ...
[10:29:56.123] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ... DONE
[10:29:56.123] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[10:29:56.124] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[10:29:56.124] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[10:29:56.124] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[10:29:56.124] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:29:56.125] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:29:56.125] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:29:56.125] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:29:56.125] Exporting 5 global objects (5.26 KiB) to cluster node #1 ... DONE
[10:29:56.126] MultisessionFuture started
[10:29:56.126] - Launch lazy future ... done
[10:29:56.126] run() for ‘MultisessionFuture’ ... done
[10:29:56.126] Created future:
[10:29:56.126] MultisessionFuture:
[10:29:56.126] Label: ‘future_by-1’
[10:29:56.126] Expression:
[10:29:56.126] {
[10:29:56.126]     do.call(function(...) {
[10:29:56.126]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.126]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:56.126]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.126]             on.exit(options(oopts), add = TRUE)
[10:29:56.126]         }
[10:29:56.126]         {
[10:29:56.126]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:56.126]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.126]                 ...future.FUN(...future.X_jj, ...)
[10:29:56.126]             })
[10:29:56.126]         }
[10:29:56.126]     }, args = future.call.arguments)
[10:29:56.126] }
[10:29:56.126] Lazy evaluation: FALSE
[10:29:56.126] Asynchronous evaluation: TRUE
[10:29:56.126] Local evaluation: TRUE
[10:29:56.126] Environment: R_GlobalEnv
[10:29:56.126] Capture standard output: TRUE
[10:29:56.126] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:56.126] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:56.126] Packages: 1 packages (‘stats’)
[10:29:56.126] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:56.126] Resolved: FALSE
[10:29:56.126] Value: <not collected>
[10:29:56.126] Conditions captured: <none>
[10:29:56.126] Early signaling: FALSE
[10:29:56.126] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:56.126] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:56.138] Chunk #1 of 2 ... DONE
[10:29:56.138] Chunk #2 of 2 ...
[10:29:56.138]  - Finding globals in 'X' for chunk #2 ...
[10:29:56.138] getGlobalsAndPackages() ...
[10:29:56.138] Searching for globals...
[10:29:56.139] 
[10:29:56.139] Searching for globals ... DONE
[10:29:56.139] - globals: [0] <none>
[10:29:56.139] getGlobalsAndPackages() ... DONE
[10:29:56.139]    + additional globals found: [n=0] 
[10:29:56.139]    + additional namespaces needed: [n=0] 
[10:29:56.139]  - Finding globals in 'X' for chunk #2 ... DONE
[10:29:56.139]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:56.140]  - seeds: <none>
[10:29:56.140]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.140] getGlobalsAndPackages() ...
[10:29:56.140] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.140] Resolving globals: FALSE
[10:29:56.140] Tweak future expression to call with '...' arguments ...
[10:29:56.140] {
[10:29:56.140]     do.call(function(...) {
[10:29:56.140]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.140]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:56.140]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.140]             on.exit(options(oopts), add = TRUE)
[10:29:56.140]         }
[10:29:56.140]         {
[10:29:56.140]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:56.140]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.140]                 ...future.FUN(...future.X_jj, ...)
[10:29:56.140]             })
[10:29:56.140]         }
[10:29:56.140]     }, args = future.call.arguments)
[10:29:56.140] }
[10:29:56.140] Tweak future expression to call with '...' arguments ... DONE
[10:29:56.141] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.141] 
[10:29:56.141] getGlobalsAndPackages() ... DONE
[10:29:56.141] run() for ‘Future’ ...
[10:29:56.142] - state: ‘created’
[10:29:56.142] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:56.156] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:56.156] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:56.156]   - Field: ‘node’
[10:29:56.156]   - Field: ‘label’
[10:29:56.156]   - Field: ‘local’
[10:29:56.156]   - Field: ‘owner’
[10:29:56.156]   - Field: ‘envir’
[10:29:56.156]   - Field: ‘workers’
[10:29:56.156]   - Field: ‘packages’
[10:29:56.156]   - Field: ‘gc’
[10:29:56.157]   - Field: ‘conditions’
[10:29:56.157]   - Field: ‘persistent’
[10:29:56.157]   - Field: ‘expr’
[10:29:56.157]   - Field: ‘uuid’
[10:29:56.157]   - Field: ‘seed’
[10:29:56.157]   - Field: ‘version’
[10:29:56.157]   - Field: ‘result’
[10:29:56.157]   - Field: ‘asynchronous’
[10:29:56.157]   - Field: ‘calls’
[10:29:56.157]   - Field: ‘globals’
[10:29:56.158]   - Field: ‘stdout’
[10:29:56.158]   - Field: ‘earlySignal’
[10:29:56.158]   - Field: ‘lazy’
[10:29:56.158]   - Field: ‘state’
[10:29:56.158] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:56.158] - Launch lazy future ...
[10:29:56.158] Packages needed by the future expression (n = 1): ‘stats’
[10:29:56.158] Packages needed by future strategies (n = 0): <none>
[10:29:56.159] {
[10:29:56.159]     {
[10:29:56.159]         {
[10:29:56.159]             ...future.startTime <- base::Sys.time()
[10:29:56.159]             {
[10:29:56.159]                 {
[10:29:56.159]                   {
[10:29:56.159]                     {
[10:29:56.159]                       {
[10:29:56.159]                         base::local({
[10:29:56.159]                           has_future <- base::requireNamespace("future", 
[10:29:56.159]                             quietly = TRUE)
[10:29:56.159]                           if (has_future) {
[10:29:56.159]                             ns <- base::getNamespace("future")
[10:29:56.159]                             version <- ns[[".package"]][["version"]]
[10:29:56.159]                             if (is.null(version)) 
[10:29:56.159]                               version <- utils::packageVersion("future")
[10:29:56.159]                           }
[10:29:56.159]                           else {
[10:29:56.159]                             version <- NULL
[10:29:56.159]                           }
[10:29:56.159]                           if (!has_future || version < "1.8.0") {
[10:29:56.159]                             info <- base::c(r_version = base::gsub("R version ", 
[10:29:56.159]                               "", base::R.version$version.string), 
[10:29:56.159]                               platform = base::sprintf("%s (%s-bit)", 
[10:29:56.159]                                 base::R.version$platform, 8 * 
[10:29:56.159]                                   base::.Machine$sizeof.pointer), 
[10:29:56.159]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:56.159]                                 "release", "version")], collapse = " "), 
[10:29:56.159]                               hostname = base::Sys.info()[["nodename"]])
[10:29:56.159]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:29:56.159]                               info)
[10:29:56.159]                             info <- base::paste(info, collapse = "; ")
[10:29:56.159]                             if (!has_future) {
[10:29:56.159]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:56.159]                                 info)
[10:29:56.159]                             }
[10:29:56.159]                             else {
[10:29:56.159]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:56.159]                                 info, version)
[10:29:56.159]                             }
[10:29:56.159]                             base::stop(msg)
[10:29:56.159]                           }
[10:29:56.159]                         })
[10:29:56.159]                       }
[10:29:56.159]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:56.159]                       base::options(mc.cores = 1L)
[10:29:56.159]                     }
[10:29:56.159]                     base::local({
[10:29:56.159]                       for (pkg in "stats") {
[10:29:56.159]                         base::loadNamespace(pkg)
[10:29:56.159]                         base::library(pkg, character.only = TRUE)
[10:29:56.159]                       }
[10:29:56.159]                     })
[10:29:56.159]                   }
[10:29:56.159]                   ...future.strategy.old <- future::plan("list")
[10:29:56.159]                   options(future.plan = NULL)
[10:29:56.159]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:56.159]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:56.159]                 }
[10:29:56.159]                 ...future.workdir <- getwd()
[10:29:56.159]             }
[10:29:56.159]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:56.159]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:56.159]         }
[10:29:56.159]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:56.159]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:56.159]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:56.159]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:56.159]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:56.159]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:56.159]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:56.159]             base::names(...future.oldOptions))
[10:29:56.159]     }
[10:29:56.159]     if (FALSE) {
[10:29:56.159]     }
[10:29:56.159]     else {
[10:29:56.159]         if (TRUE) {
[10:29:56.159]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:56.159]                 open = "w")
[10:29:56.159]         }
[10:29:56.159]         else {
[10:29:56.159]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:56.159]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:56.159]         }
[10:29:56.159]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:56.159]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:56.159]             base::sink(type = "output", split = FALSE)
[10:29:56.159]             base::close(...future.stdout)
[10:29:56.159]         }, add = TRUE)
[10:29:56.159]     }
[10:29:56.159]     ...future.frame <- base::sys.nframe()
[10:29:56.159]     ...future.conditions <- base::list()
[10:29:56.159]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:56.159]     if (FALSE) {
[10:29:56.159]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:56.159]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:56.159]     }
[10:29:56.159]     ...future.result <- base::tryCatch({
[10:29:56.159]         base::withCallingHandlers({
[10:29:56.159]             ...future.value <- base::withVisible(base::local({
[10:29:56.159]                 ...future.makeSendCondition <- base::local({
[10:29:56.159]                   sendCondition <- NULL
[10:29:56.159]                   function(frame = 1L) {
[10:29:56.159]                     if (is.function(sendCondition)) 
[10:29:56.159]                       return(sendCondition)
[10:29:56.159]                     ns <- getNamespace("parallel")
[10:29:56.159]                     if (exists("sendData", mode = "function", 
[10:29:56.159]                       envir = ns)) {
[10:29:56.159]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:56.159]                         envir = ns)
[10:29:56.159]                       envir <- sys.frame(frame)
[10:29:56.159]                       master <- NULL
[10:29:56.159]                       while (!identical(envir, .GlobalEnv) && 
[10:29:56.159]                         !identical(envir, emptyenv())) {
[10:29:56.159]                         if (exists("master", mode = "list", envir = envir, 
[10:29:56.159]                           inherits = FALSE)) {
[10:29:56.159]                           master <- get("master", mode = "list", 
[10:29:56.159]                             envir = envir, inherits = FALSE)
[10:29:56.159]                           if (inherits(master, c("SOCKnode", 
[10:29:56.159]                             "SOCK0node"))) {
[10:29:56.159]                             sendCondition <<- function(cond) {
[10:29:56.159]                               data <- list(type = "VALUE", value = cond, 
[10:29:56.159]                                 success = TRUE)
[10:29:56.159]                               parallel_sendData(master, data)
[10:29:56.159]                             }
[10:29:56.159]                             return(sendCondition)
[10:29:56.159]                           }
[10:29:56.159]                         }
[10:29:56.159]                         frame <- frame + 1L
[10:29:56.159]                         envir <- sys.frame(frame)
[10:29:56.159]                       }
[10:29:56.159]                     }
[10:29:56.159]                     sendCondition <<- function(cond) NULL
[10:29:56.159]                   }
[10:29:56.159]                 })
[10:29:56.159]                 withCallingHandlers({
[10:29:56.159]                   {
[10:29:56.159]                     do.call(function(...) {
[10:29:56.159]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.159]                       if (!identical(...future.globals.maxSize.org, 
[10:29:56.159]                         ...future.globals.maxSize)) {
[10:29:56.159]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.159]                         on.exit(options(oopts), add = TRUE)
[10:29:56.159]                       }
[10:29:56.159]                       {
[10:29:56.159]                         lapply(seq_along(...future.elements_ii), 
[10:29:56.159]                           FUN = function(jj) {
[10:29:56.159]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.159]                             ...future.FUN(...future.X_jj, ...)
[10:29:56.159]                           })
[10:29:56.159]                       }
[10:29:56.159]                     }, args = future.call.arguments)
[10:29:56.159]                   }
[10:29:56.159]                 }, immediateCondition = function(cond) {
[10:29:56.159]                   sendCondition <- ...future.makeSendCondition()
[10:29:56.159]                   sendCondition(cond)
[10:29:56.159]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.159]                   {
[10:29:56.159]                     inherits <- base::inherits
[10:29:56.159]                     invokeRestart <- base::invokeRestart
[10:29:56.159]                     is.null <- base::is.null
[10:29:56.159]                     muffled <- FALSE
[10:29:56.159]                     if (inherits(cond, "message")) {
[10:29:56.159]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:56.159]                       if (muffled) 
[10:29:56.159]                         invokeRestart("muffleMessage")
[10:29:56.159]                     }
[10:29:56.159]                     else if (inherits(cond, "warning")) {
[10:29:56.159]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:56.159]                       if (muffled) 
[10:29:56.159]                         invokeRestart("muffleWarning")
[10:29:56.159]                     }
[10:29:56.159]                     else if (inherits(cond, "condition")) {
[10:29:56.159]                       if (!is.null(pattern)) {
[10:29:56.159]                         computeRestarts <- base::computeRestarts
[10:29:56.159]                         grepl <- base::grepl
[10:29:56.159]                         restarts <- computeRestarts(cond)
[10:29:56.159]                         for (restart in restarts) {
[10:29:56.159]                           name <- restart$name
[10:29:56.159]                           if (is.null(name)) 
[10:29:56.159]                             next
[10:29:56.159]                           if (!grepl(pattern, name)) 
[10:29:56.159]                             next
[10:29:56.159]                           invokeRestart(restart)
[10:29:56.159]                           muffled <- TRUE
[10:29:56.159]                           break
[10:29:56.159]                         }
[10:29:56.159]                       }
[10:29:56.159]                     }
[10:29:56.159]                     invisible(muffled)
[10:29:56.159]                   }
[10:29:56.159]                   muffleCondition(cond)
[10:29:56.159]                 })
[10:29:56.159]             }))
[10:29:56.159]             future::FutureResult(value = ...future.value$value, 
[10:29:56.159]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:56.159]                   ...future.rng), globalenv = if (FALSE) 
[10:29:56.159]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:56.159]                     ...future.globalenv.names))
[10:29:56.159]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:56.159]         }, condition = base::local({
[10:29:56.159]             c <- base::c
[10:29:56.159]             inherits <- base::inherits
[10:29:56.159]             invokeRestart <- base::invokeRestart
[10:29:56.159]             length <- base::length
[10:29:56.159]             list <- base::list
[10:29:56.159]             seq.int <- base::seq.int
[10:29:56.159]             signalCondition <- base::signalCondition
[10:29:56.159]             sys.calls <- base::sys.calls
[10:29:56.159]             `[[` <- base::`[[`
[10:29:56.159]             `+` <- base::`+`
[10:29:56.159]             `<<-` <- base::`<<-`
[10:29:56.159]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:56.159]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:56.159]                   3L)]
[10:29:56.159]             }
[10:29:56.159]             function(cond) {
[10:29:56.159]                 is_error <- inherits(cond, "error")
[10:29:56.159]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:56.159]                   NULL)
[10:29:56.159]                 if (is_error) {
[10:29:56.159]                   sessionInformation <- function() {
[10:29:56.159]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:56.159]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:56.159]                       search = base::search(), system = base::Sys.info())
[10:29:56.159]                   }
[10:29:56.159]                   ...future.conditions[[length(...future.conditions) + 
[10:29:56.159]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:56.159]                     cond$call), session = sessionInformation(), 
[10:29:56.159]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:56.159]                   signalCondition(cond)
[10:29:56.159]                 }
[10:29:56.159]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:56.159]                 "immediateCondition"))) {
[10:29:56.159]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:56.159]                   ...future.conditions[[length(...future.conditions) + 
[10:29:56.159]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:56.159]                   if (TRUE && !signal) {
[10:29:56.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.159]                     {
[10:29:56.159]                       inherits <- base::inherits
[10:29:56.159]                       invokeRestart <- base::invokeRestart
[10:29:56.159]                       is.null <- base::is.null
[10:29:56.159]                       muffled <- FALSE
[10:29:56.159]                       if (inherits(cond, "message")) {
[10:29:56.159]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:56.159]                         if (muffled) 
[10:29:56.159]                           invokeRestart("muffleMessage")
[10:29:56.159]                       }
[10:29:56.159]                       else if (inherits(cond, "warning")) {
[10:29:56.159]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:56.159]                         if (muffled) 
[10:29:56.159]                           invokeRestart("muffleWarning")
[10:29:56.159]                       }
[10:29:56.159]                       else if (inherits(cond, "condition")) {
[10:29:56.159]                         if (!is.null(pattern)) {
[10:29:56.159]                           computeRestarts <- base::computeRestarts
[10:29:56.159]                           grepl <- base::grepl
[10:29:56.159]                           restarts <- computeRestarts(cond)
[10:29:56.159]                           for (restart in restarts) {
[10:29:56.159]                             name <- restart$name
[10:29:56.159]                             if (is.null(name)) 
[10:29:56.159]                               next
[10:29:56.159]                             if (!grepl(pattern, name)) 
[10:29:56.159]                               next
[10:29:56.159]                             invokeRestart(restart)
[10:29:56.159]                             muffled <- TRUE
[10:29:56.159]                             break
[10:29:56.159]                           }
[10:29:56.159]                         }
[10:29:56.159]                       }
[10:29:56.159]                       invisible(muffled)
[10:29:56.159]                     }
[10:29:56.159]                     muffleCondition(cond, pattern = "^muffle")
[10:29:56.159]                   }
[10:29:56.159]                 }
[10:29:56.159]                 else {
[10:29:56.159]                   if (TRUE) {
[10:29:56.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.159]                     {
[10:29:56.159]                       inherits <- base::inherits
[10:29:56.159]                       invokeRestart <- base::invokeRestart
[10:29:56.159]                       is.null <- base::is.null
[10:29:56.159]                       muffled <- FALSE
[10:29:56.159]                       if (inherits(cond, "message")) {
[10:29:56.159]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:56.159]                         if (muffled) 
[10:29:56.159]                           invokeRestart("muffleMessage")
[10:29:56.159]                       }
[10:29:56.159]                       else if (inherits(cond, "warning")) {
[10:29:56.159]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:56.159]                         if (muffled) 
[10:29:56.159]                           invokeRestart("muffleWarning")
[10:29:56.159]                       }
[10:29:56.159]                       else if (inherits(cond, "condition")) {
[10:29:56.159]                         if (!is.null(pattern)) {
[10:29:56.159]                           computeRestarts <- base::computeRestarts
[10:29:56.159]                           grepl <- base::grepl
[10:29:56.159]                           restarts <- computeRestarts(cond)
[10:29:56.159]                           for (restart in restarts) {
[10:29:56.159]                             name <- restart$name
[10:29:56.159]                             if (is.null(name)) 
[10:29:56.159]                               next
[10:29:56.159]                             if (!grepl(pattern, name)) 
[10:29:56.159]                               next
[10:29:56.159]                             invokeRestart(restart)
[10:29:56.159]                             muffled <- TRUE
[10:29:56.159]                             break
[10:29:56.159]                           }
[10:29:56.159]                         }
[10:29:56.159]                       }
[10:29:56.159]                       invisible(muffled)
[10:29:56.159]                     }
[10:29:56.159]                     muffleCondition(cond, pattern = "^muffle")
[10:29:56.159]                   }
[10:29:56.159]                 }
[10:29:56.159]             }
[10:29:56.159]         }))
[10:29:56.159]     }, error = function(ex) {
[10:29:56.159]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:56.159]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:56.159]                 ...future.rng), started = ...future.startTime, 
[10:29:56.159]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:56.159]             version = "1.8"), class = "FutureResult")
[10:29:56.159]     }, finally = {
[10:29:56.159]         if (!identical(...future.workdir, getwd())) 
[10:29:56.159]             setwd(...future.workdir)
[10:29:56.159]         {
[10:29:56.159]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:56.159]                 ...future.oldOptions$nwarnings <- NULL
[10:29:56.159]             }
[10:29:56.159]             base::options(...future.oldOptions)
[10:29:56.159]             if (.Platform$OS.type == "windows") {
[10:29:56.159]                 old_names <- names(...future.oldEnvVars)
[10:29:56.159]                 envs <- base::Sys.getenv()
[10:29:56.159]                 names <- names(envs)
[10:29:56.159]                 common <- intersect(names, old_names)
[10:29:56.159]                 added <- setdiff(names, old_names)
[10:29:56.159]                 removed <- setdiff(old_names, names)
[10:29:56.159]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:56.159]                   envs[common]]
[10:29:56.159]                 NAMES <- toupper(changed)
[10:29:56.159]                 args <- list()
[10:29:56.159]                 for (kk in seq_along(NAMES)) {
[10:29:56.159]                   name <- changed[[kk]]
[10:29:56.159]                   NAME <- NAMES[[kk]]
[10:29:56.159]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.159]                     next
[10:29:56.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:56.159]                 }
[10:29:56.159]                 NAMES <- toupper(added)
[10:29:56.159]                 for (kk in seq_along(NAMES)) {
[10:29:56.159]                   name <- added[[kk]]
[10:29:56.159]                   NAME <- NAMES[[kk]]
[10:29:56.159]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.159]                     next
[10:29:56.159]                   args[[name]] <- ""
[10:29:56.159]                 }
[10:29:56.159]                 NAMES <- toupper(removed)
[10:29:56.159]                 for (kk in seq_along(NAMES)) {
[10:29:56.159]                   name <- removed[[kk]]
[10:29:56.159]                   NAME <- NAMES[[kk]]
[10:29:56.159]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.159]                     next
[10:29:56.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:56.159]                 }
[10:29:56.159]                 if (length(args) > 0) 
[10:29:56.159]                   base::do.call(base::Sys.setenv, args = args)
[10:29:56.159]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:56.159]             }
[10:29:56.159]             else {
[10:29:56.159]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:56.159]             }
[10:29:56.159]             {
[10:29:56.159]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:56.159]                   0L) {
[10:29:56.159]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:56.159]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:56.159]                   base::options(opts)
[10:29:56.159]                 }
[10:29:56.159]                 {
[10:29:56.159]                   {
[10:29:56.159]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:56.159]                     NULL
[10:29:56.159]                   }
[10:29:56.159]                   options(future.plan = NULL)
[10:29:56.159]                   if (is.na(NA_character_)) 
[10:29:56.159]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:56.159]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:56.159]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:56.159]                     .init = FALSE)
[10:29:56.159]                 }
[10:29:56.159]             }
[10:29:56.159]         }
[10:29:56.159]     })
[10:29:56.159]     if (TRUE) {
[10:29:56.159]         base::sink(type = "output", split = FALSE)
[10:29:56.159]         if (TRUE) {
[10:29:56.159]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:56.159]         }
[10:29:56.159]         else {
[10:29:56.159]             ...future.result["stdout"] <- base::list(NULL)
[10:29:56.159]         }
[10:29:56.159]         base::close(...future.stdout)
[10:29:56.159]         ...future.stdout <- NULL
[10:29:56.159]     }
[10:29:56.159]     ...future.result$conditions <- ...future.conditions
[10:29:56.159]     ...future.result$finished <- base::Sys.time()
[10:29:56.159]     ...future.result
[10:29:56.159] }
[10:29:56.162] Exporting 5 global objects (5.26 KiB) to cluster node #2 ...
[10:29:56.162] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ...
[10:29:56.162] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ... DONE
[10:29:56.163] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[10:29:56.163] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[10:29:56.163] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[10:29:56.164] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[10:29:56.164] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:29:56.164] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:29:56.164] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:29:56.165] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:29:56.165] Exporting 5 global objects (5.26 KiB) to cluster node #2 ... DONE
[10:29:56.165] MultisessionFuture started
[10:29:56.165] - Launch lazy future ... done
[10:29:56.166] run() for ‘MultisessionFuture’ ... done
[10:29:56.166] Created future:
[10:29:56.166] MultisessionFuture:
[10:29:56.166] Label: ‘future_by-2’
[10:29:56.166] Expression:
[10:29:56.166] {
[10:29:56.166]     do.call(function(...) {
[10:29:56.166]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.166]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:56.166]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.166]             on.exit(options(oopts), add = TRUE)
[10:29:56.166]         }
[10:29:56.166]         {
[10:29:56.166]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:56.166]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.166]                 ...future.FUN(...future.X_jj, ...)
[10:29:56.166]             })
[10:29:56.166]         }
[10:29:56.166]     }, args = future.call.arguments)
[10:29:56.166] }
[10:29:56.166] Lazy evaluation: FALSE
[10:29:56.166] Asynchronous evaluation: TRUE
[10:29:56.166] Local evaluation: TRUE
[10:29:56.166] Environment: R_GlobalEnv
[10:29:56.166] Capture standard output: TRUE
[10:29:56.166] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:56.166] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:56.166] Packages: 1 packages (‘stats’)
[10:29:56.166] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:56.166] Resolved: FALSE
[10:29:56.166] Value: <not collected>
[10:29:56.166] Conditions captured: <none>
[10:29:56.166] Early signaling: FALSE
[10:29:56.166] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:56.166] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:56.178] Chunk #2 of 2 ... DONE
[10:29:56.178] Launching 2 futures (chunks) ... DONE
[10:29:56.178] Resolving 2 futures (chunks) ...
[10:29:56.178] resolve() on list ...
[10:29:56.178]  recursive: 0
[10:29:56.178]  length: 2
[10:29:56.178] 
[10:29:56.179] receiveMessageFromWorker() for ClusterFuture ...
[10:29:56.179] - Validating connection of MultisessionFuture
[10:29:56.179] - received message: FutureResult
[10:29:56.179] - Received FutureResult
[10:29:56.179] - Erased future from FutureRegistry
[10:29:56.179] result() for ClusterFuture ...
[10:29:56.180] - result already collected: FutureResult
[10:29:56.180] result() for ClusterFuture ... done
[10:29:56.180] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:56.180] Future #1
[10:29:56.180] result() for ClusterFuture ...
[10:29:56.180] - result already collected: FutureResult
[10:29:56.180] result() for ClusterFuture ... done
[10:29:56.180] result() for ClusterFuture ...
[10:29:56.180] - result already collected: FutureResult
[10:29:56.180] result() for ClusterFuture ... done
[10:29:56.180] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:29:56.181] - nx: 2
[10:29:56.181] - relay: TRUE
[10:29:56.181] - stdout: TRUE
[10:29:56.181] - signal: TRUE
[10:29:56.181] - resignal: FALSE
[10:29:56.181] - force: TRUE
[10:29:56.181] - relayed: [n=2] FALSE, FALSE
[10:29:56.181] - queued futures: [n=2] FALSE, FALSE
[10:29:56.181]  - until=1
[10:29:56.181]  - relaying element #1
[10:29:56.181] result() for ClusterFuture ...
[10:29:56.182] - result already collected: FutureResult
[10:29:56.182] result() for ClusterFuture ... done
[10:29:56.182] result() for ClusterFuture ...
[10:29:56.182] - result already collected: FutureResult
[10:29:56.182] result() for ClusterFuture ... done
[10:29:56.182] result() for ClusterFuture ...
[10:29:56.182] - result already collected: FutureResult
[10:29:56.182] result() for ClusterFuture ... done
[10:29:56.182] result() for ClusterFuture ...
[10:29:56.182] - result already collected: FutureResult
[10:29:56.183] result() for ClusterFuture ... done
[10:29:56.183] - relayed: [n=2] TRUE, FALSE
[10:29:56.183] - queued futures: [n=2] TRUE, FALSE
[10:29:56.183] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:29:56.183]  length: 1 (resolved future 1)
[10:29:56.225] receiveMessageFromWorker() for ClusterFuture ...
[10:29:56.225] - Validating connection of MultisessionFuture
[10:29:56.226] - received message: FutureResult
[10:29:56.226] - Received FutureResult
[10:29:56.226] - Erased future from FutureRegistry
[10:29:56.226] result() for ClusterFuture ...
[10:29:56.226] - result already collected: FutureResult
[10:29:56.226] result() for ClusterFuture ... done
[10:29:56.226] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:56.226] Future #2
[10:29:56.227] result() for ClusterFuture ...
[10:29:56.227] - result already collected: FutureResult
[10:29:56.227] result() for ClusterFuture ... done
[10:29:56.227] result() for ClusterFuture ...
[10:29:56.227] - result already collected: FutureResult
[10:29:56.227] result() for ClusterFuture ... done
[10:29:56.227] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:29:56.227] - nx: 2
[10:29:56.227] - relay: TRUE
[10:29:56.227] - stdout: TRUE
[10:29:56.227] - signal: TRUE
[10:29:56.228] - resignal: FALSE
[10:29:56.228] - force: TRUE
[10:29:56.228] - relayed: [n=2] TRUE, FALSE
[10:29:56.228] - queued futures: [n=2] TRUE, FALSE
[10:29:56.228]  - until=2
[10:29:56.228]  - relaying element #2
[10:29:56.228] result() for ClusterFuture ...
[10:29:56.228] - result already collected: FutureResult
[10:29:56.228] result() for ClusterFuture ... done
[10:29:56.228] result() for ClusterFuture ...
[10:29:56.228] - result already collected: FutureResult
[10:29:56.228] result() for ClusterFuture ... done
[10:29:56.229] result() for ClusterFuture ...
[10:29:56.229] - result already collected: FutureResult
[10:29:56.229] result() for ClusterFuture ... done
[10:29:56.229] result() for ClusterFuture ...
[10:29:56.229] - result already collected: FutureResult
[10:29:56.229] result() for ClusterFuture ... done
[10:29:56.229] - relayed: [n=2] TRUE, TRUE
[10:29:56.229] - queued futures: [n=2] TRUE, TRUE
[10:29:56.229] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:29:56.229]  length: 0 (resolved future 2)
[10:29:56.230] Relaying remaining futures
[10:29:56.230] signalConditionsASAP(NULL, pos=0) ...
[10:29:56.230] - nx: 2
[10:29:56.230] - relay: TRUE
[10:29:56.230] - stdout: TRUE
[10:29:56.230] - signal: TRUE
[10:29:56.230] - resignal: FALSE
[10:29:56.230] - force: TRUE
[10:29:56.230] - relayed: [n=2] TRUE, TRUE
[10:29:56.230] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:56.230] - relayed: [n=2] TRUE, TRUE
[10:29:56.231] - queued futures: [n=2] TRUE, TRUE
[10:29:56.231] signalConditionsASAP(NULL, pos=0) ... done
[10:29:56.231] resolve() on list ... DONE
[10:29:56.231] result() for ClusterFuture ...
[10:29:56.231] - result already collected: FutureResult
[10:29:56.231] result() for ClusterFuture ... done
[10:29:56.231] result() for ClusterFuture ...
[10:29:56.231] - result already collected: FutureResult
[10:29:56.231] result() for ClusterFuture ... done
[10:29:56.231] result() for ClusterFuture ...
[10:29:56.231] - result already collected: FutureResult
[10:29:56.231] result() for ClusterFuture ... done
[10:29:56.232] result() for ClusterFuture ...
[10:29:56.232] - result already collected: FutureResult
[10:29:56.232] result() for ClusterFuture ... done
[10:29:56.232]  - Number of value chunks collected: 2
[10:29:56.232] Resolving 2 futures (chunks) ... DONE
[10:29:56.232] Reducing values from 2 chunks ...
[10:29:56.232]  - Number of values collected after concatenation: 3
[10:29:56.232]  - Number of values expected: 3
[10:29:56.232] Reducing values from 2 chunks ... DONE
[10:29:56.232] future_lapply() ... DONE
[10:29:56.232] future_by_internal() ... DONE
[10:29:56.236] future_by_internal() ...
[10:29:56.237] future_lapply() ...
[10:29:56.241] Number of chunks: 2
[10:29:56.242] getGlobalsAndPackagesXApply() ...
[10:29:56.242]  - future.globals: TRUE
[10:29:56.242] getGlobalsAndPackages() ...
[10:29:56.242] Searching for globals...
[10:29:56.244] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[10:29:56.244] Searching for globals ... DONE
[10:29:56.244] Resolving globals: FALSE
[10:29:56.244] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[10:29:56.245] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[10:29:56.245] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[10:29:56.245] - packages: [1] ‘stats’
[10:29:56.245] getGlobalsAndPackages() ... DONE
[10:29:56.245]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[10:29:56.245]  - needed namespaces: [n=1] ‘stats’
[10:29:56.245] Finding globals ... DONE
[10:29:56.246]  - use_args: TRUE
[10:29:56.246]  - Getting '...' globals ...
[10:29:56.246] resolve() on list ...
[10:29:56.246]  recursive: 0
[10:29:56.246]  length: 1
[10:29:56.246]  elements: ‘...’
[10:29:56.246]  length: 0 (resolved future 1)
[10:29:56.246] resolve() on list ... DONE
[10:29:56.246]    - '...' content: [n=0] 
[10:29:56.247] List of 1
[10:29:56.247]  $ ...: list()
[10:29:56.247]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:56.247]  - attr(*, "where")=List of 1
[10:29:56.247]   ..$ ...:<environment: 0x556dd5efb660> 
[10:29:56.247]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:56.247]  - attr(*, "resolved")= logi TRUE
[10:29:56.247]  - attr(*, "total_size")= num NA
[10:29:56.249]  - Getting '...' globals ... DONE
[10:29:56.249] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[10:29:56.250] List of 4
[10:29:56.250]  $ ...future.FUN:function (x)  
[10:29:56.250]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[10:29:56.250]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[10:29:56.250]  $ ...          : list()
[10:29:56.250]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:56.250]  - attr(*, "where")=List of 4
[10:29:56.250]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:56.250]   ..$ breaks       :<environment: R_EmptyEnv> 
[10:29:56.250]   ..$ wool         :<environment: R_EmptyEnv> 
[10:29:56.250]   ..$ ...          :<environment: 0x556dd5efb660> 
[10:29:56.250]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:56.250]  - attr(*, "resolved")= logi FALSE
[10:29:56.250]  - attr(*, "total_size")= num 2320
[10:29:56.253] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:56.253] getGlobalsAndPackagesXApply() ... DONE
[10:29:56.254] Number of futures (= number of chunks): 2
[10:29:56.254] Launching 2 futures (chunks) ...
[10:29:56.254] Chunk #1 of 2 ...
[10:29:56.254]  - Finding globals in 'X' for chunk #1 ...
[10:29:56.254] getGlobalsAndPackages() ...
[10:29:56.254] Searching for globals...
[10:29:56.255] 
[10:29:56.255] Searching for globals ... DONE
[10:29:56.255] - globals: [0] <none>
[10:29:56.255] getGlobalsAndPackages() ... DONE
[10:29:56.255]    + additional globals found: [n=0] 
[10:29:56.255]    + additional namespaces needed: [n=0] 
[10:29:56.255]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:56.255]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:56.255]  - seeds: <none>
[10:29:56.255]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.256] getGlobalsAndPackages() ...
[10:29:56.256] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.256] Resolving globals: FALSE
[10:29:56.256] Tweak future expression to call with '...' arguments ...
[10:29:56.256] {
[10:29:56.256]     do.call(function(...) {
[10:29:56.256]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.256]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:56.256]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.256]             on.exit(options(oopts), add = TRUE)
[10:29:56.256]         }
[10:29:56.256]         {
[10:29:56.256]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:56.256]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.256]                 ...future.FUN(...future.X_jj, ...)
[10:29:56.256]             })
[10:29:56.256]         }
[10:29:56.256]     }, args = future.call.arguments)
[10:29:56.256] }
[10:29:56.256] Tweak future expression to call with '...' arguments ... DONE
[10:29:56.257] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.257] 
[10:29:56.257] getGlobalsAndPackages() ... DONE
[10:29:56.257] run() for ‘Future’ ...
[10:29:56.257] - state: ‘created’
[10:29:56.257] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:56.272] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:56.272] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:56.272]   - Field: ‘node’
[10:29:56.272]   - Field: ‘label’
[10:29:56.272]   - Field: ‘local’
[10:29:56.272]   - Field: ‘owner’
[10:29:56.272]   - Field: ‘envir’
[10:29:56.272]   - Field: ‘workers’
[10:29:56.273]   - Field: ‘packages’
[10:29:56.273]   - Field: ‘gc’
[10:29:56.273]   - Field: ‘conditions’
[10:29:56.273]   - Field: ‘persistent’
[10:29:56.273]   - Field: ‘expr’
[10:29:56.273]   - Field: ‘uuid’
[10:29:56.273]   - Field: ‘seed’
[10:29:56.273]   - Field: ‘version’
[10:29:56.273]   - Field: ‘result’
[10:29:56.273]   - Field: ‘asynchronous’
[10:29:56.274]   - Field: ‘calls’
[10:29:56.274]   - Field: ‘globals’
[10:29:56.274]   - Field: ‘stdout’
[10:29:56.274]   - Field: ‘earlySignal’
[10:29:56.274]   - Field: ‘lazy’
[10:29:56.274]   - Field: ‘state’
[10:29:56.274] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:56.274] - Launch lazy future ...
[10:29:56.274] Packages needed by the future expression (n = 1): ‘stats’
[10:29:56.275] Packages needed by future strategies (n = 0): <none>
[10:29:56.275] {
[10:29:56.275]     {
[10:29:56.275]         {
[10:29:56.275]             ...future.startTime <- base::Sys.time()
[10:29:56.275]             {
[10:29:56.275]                 {
[10:29:56.275]                   {
[10:29:56.275]                     {
[10:29:56.275]                       {
[10:29:56.275]                         base::local({
[10:29:56.275]                           has_future <- base::requireNamespace("future", 
[10:29:56.275]                             quietly = TRUE)
[10:29:56.275]                           if (has_future) {
[10:29:56.275]                             ns <- base::getNamespace("future")
[10:29:56.275]                             version <- ns[[".package"]][["version"]]
[10:29:56.275]                             if (is.null(version)) 
[10:29:56.275]                               version <- utils::packageVersion("future")
[10:29:56.275]                           }
[10:29:56.275]                           else {
[10:29:56.275]                             version <- NULL
[10:29:56.275]                           }
[10:29:56.275]                           if (!has_future || version < "1.8.0") {
[10:29:56.275]                             info <- base::c(r_version = base::gsub("R version ", 
[10:29:56.275]                               "", base::R.version$version.string), 
[10:29:56.275]                               platform = base::sprintf("%s (%s-bit)", 
[10:29:56.275]                                 base::R.version$platform, 8 * 
[10:29:56.275]                                   base::.Machine$sizeof.pointer), 
[10:29:56.275]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:56.275]                                 "release", "version")], collapse = " "), 
[10:29:56.275]                               hostname = base::Sys.info()[["nodename"]])
[10:29:56.275]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:29:56.275]                               info)
[10:29:56.275]                             info <- base::paste(info, collapse = "; ")
[10:29:56.275]                             if (!has_future) {
[10:29:56.275]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:56.275]                                 info)
[10:29:56.275]                             }
[10:29:56.275]                             else {
[10:29:56.275]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:56.275]                                 info, version)
[10:29:56.275]                             }
[10:29:56.275]                             base::stop(msg)
[10:29:56.275]                           }
[10:29:56.275]                         })
[10:29:56.275]                       }
[10:29:56.275]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:56.275]                       base::options(mc.cores = 1L)
[10:29:56.275]                     }
[10:29:56.275]                     base::local({
[10:29:56.275]                       for (pkg in "stats") {
[10:29:56.275]                         base::loadNamespace(pkg)
[10:29:56.275]                         base::library(pkg, character.only = TRUE)
[10:29:56.275]                       }
[10:29:56.275]                     })
[10:29:56.275]                   }
[10:29:56.275]                   ...future.strategy.old <- future::plan("list")
[10:29:56.275]                   options(future.plan = NULL)
[10:29:56.275]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:56.275]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:56.275]                 }
[10:29:56.275]                 ...future.workdir <- getwd()
[10:29:56.275]             }
[10:29:56.275]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:56.275]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:56.275]         }
[10:29:56.275]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:56.275]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:56.275]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:56.275]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:56.275]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:56.275]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:56.275]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:56.275]             base::names(...future.oldOptions))
[10:29:56.275]     }
[10:29:56.275]     if (FALSE) {
[10:29:56.275]     }
[10:29:56.275]     else {
[10:29:56.275]         if (TRUE) {
[10:29:56.275]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:56.275]                 open = "w")
[10:29:56.275]         }
[10:29:56.275]         else {
[10:29:56.275]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:56.275]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:56.275]         }
[10:29:56.275]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:56.275]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:56.275]             base::sink(type = "output", split = FALSE)
[10:29:56.275]             base::close(...future.stdout)
[10:29:56.275]         }, add = TRUE)
[10:29:56.275]     }
[10:29:56.275]     ...future.frame <- base::sys.nframe()
[10:29:56.275]     ...future.conditions <- base::list()
[10:29:56.275]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:56.275]     if (FALSE) {
[10:29:56.275]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:56.275]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:56.275]     }
[10:29:56.275]     ...future.result <- base::tryCatch({
[10:29:56.275]         base::withCallingHandlers({
[10:29:56.275]             ...future.value <- base::withVisible(base::local({
[10:29:56.275]                 ...future.makeSendCondition <- base::local({
[10:29:56.275]                   sendCondition <- NULL
[10:29:56.275]                   function(frame = 1L) {
[10:29:56.275]                     if (is.function(sendCondition)) 
[10:29:56.275]                       return(sendCondition)
[10:29:56.275]                     ns <- getNamespace("parallel")
[10:29:56.275]                     if (exists("sendData", mode = "function", 
[10:29:56.275]                       envir = ns)) {
[10:29:56.275]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:56.275]                         envir = ns)
[10:29:56.275]                       envir <- sys.frame(frame)
[10:29:56.275]                       master <- NULL
[10:29:56.275]                       while (!identical(envir, .GlobalEnv) && 
[10:29:56.275]                         !identical(envir, emptyenv())) {
[10:29:56.275]                         if (exists("master", mode = "list", envir = envir, 
[10:29:56.275]                           inherits = FALSE)) {
[10:29:56.275]                           master <- get("master", mode = "list", 
[10:29:56.275]                             envir = envir, inherits = FALSE)
[10:29:56.275]                           if (inherits(master, c("SOCKnode", 
[10:29:56.275]                             "SOCK0node"))) {
[10:29:56.275]                             sendCondition <<- function(cond) {
[10:29:56.275]                               data <- list(type = "VALUE", value = cond, 
[10:29:56.275]                                 success = TRUE)
[10:29:56.275]                               parallel_sendData(master, data)
[10:29:56.275]                             }
[10:29:56.275]                             return(sendCondition)
[10:29:56.275]                           }
[10:29:56.275]                         }
[10:29:56.275]                         frame <- frame + 1L
[10:29:56.275]                         envir <- sys.frame(frame)
[10:29:56.275]                       }
[10:29:56.275]                     }
[10:29:56.275]                     sendCondition <<- function(cond) NULL
[10:29:56.275]                   }
[10:29:56.275]                 })
[10:29:56.275]                 withCallingHandlers({
[10:29:56.275]                   {
[10:29:56.275]                     do.call(function(...) {
[10:29:56.275]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.275]                       if (!identical(...future.globals.maxSize.org, 
[10:29:56.275]                         ...future.globals.maxSize)) {
[10:29:56.275]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.275]                         on.exit(options(oopts), add = TRUE)
[10:29:56.275]                       }
[10:29:56.275]                       {
[10:29:56.275]                         lapply(seq_along(...future.elements_ii), 
[10:29:56.275]                           FUN = function(jj) {
[10:29:56.275]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.275]                             ...future.FUN(...future.X_jj, ...)
[10:29:56.275]                           })
[10:29:56.275]                       }
[10:29:56.275]                     }, args = future.call.arguments)
[10:29:56.275]                   }
[10:29:56.275]                 }, immediateCondition = function(cond) {
[10:29:56.275]                   sendCondition <- ...future.makeSendCondition()
[10:29:56.275]                   sendCondition(cond)
[10:29:56.275]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.275]                   {
[10:29:56.275]                     inherits <- base::inherits
[10:29:56.275]                     invokeRestart <- base::invokeRestart
[10:29:56.275]                     is.null <- base::is.null
[10:29:56.275]                     muffled <- FALSE
[10:29:56.275]                     if (inherits(cond, "message")) {
[10:29:56.275]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:56.275]                       if (muffled) 
[10:29:56.275]                         invokeRestart("muffleMessage")
[10:29:56.275]                     }
[10:29:56.275]                     else if (inherits(cond, "warning")) {
[10:29:56.275]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:56.275]                       if (muffled) 
[10:29:56.275]                         invokeRestart("muffleWarning")
[10:29:56.275]                     }
[10:29:56.275]                     else if (inherits(cond, "condition")) {
[10:29:56.275]                       if (!is.null(pattern)) {
[10:29:56.275]                         computeRestarts <- base::computeRestarts
[10:29:56.275]                         grepl <- base::grepl
[10:29:56.275]                         restarts <- computeRestarts(cond)
[10:29:56.275]                         for (restart in restarts) {
[10:29:56.275]                           name <- restart$name
[10:29:56.275]                           if (is.null(name)) 
[10:29:56.275]                             next
[10:29:56.275]                           if (!grepl(pattern, name)) 
[10:29:56.275]                             next
[10:29:56.275]                           invokeRestart(restart)
[10:29:56.275]                           muffled <- TRUE
[10:29:56.275]                           break
[10:29:56.275]                         }
[10:29:56.275]                       }
[10:29:56.275]                     }
[10:29:56.275]                     invisible(muffled)
[10:29:56.275]                   }
[10:29:56.275]                   muffleCondition(cond)
[10:29:56.275]                 })
[10:29:56.275]             }))
[10:29:56.275]             future::FutureResult(value = ...future.value$value, 
[10:29:56.275]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:56.275]                   ...future.rng), globalenv = if (FALSE) 
[10:29:56.275]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:56.275]                     ...future.globalenv.names))
[10:29:56.275]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:56.275]         }, condition = base::local({
[10:29:56.275]             c <- base::c
[10:29:56.275]             inherits <- base::inherits
[10:29:56.275]             invokeRestart <- base::invokeRestart
[10:29:56.275]             length <- base::length
[10:29:56.275]             list <- base::list
[10:29:56.275]             seq.int <- base::seq.int
[10:29:56.275]             signalCondition <- base::signalCondition
[10:29:56.275]             sys.calls <- base::sys.calls
[10:29:56.275]             `[[` <- base::`[[`
[10:29:56.275]             `+` <- base::`+`
[10:29:56.275]             `<<-` <- base::`<<-`
[10:29:56.275]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:56.275]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:56.275]                   3L)]
[10:29:56.275]             }
[10:29:56.275]             function(cond) {
[10:29:56.275]                 is_error <- inherits(cond, "error")
[10:29:56.275]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:56.275]                   NULL)
[10:29:56.275]                 if (is_error) {
[10:29:56.275]                   sessionInformation <- function() {
[10:29:56.275]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:56.275]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:56.275]                       search = base::search(), system = base::Sys.info())
[10:29:56.275]                   }
[10:29:56.275]                   ...future.conditions[[length(...future.conditions) + 
[10:29:56.275]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:56.275]                     cond$call), session = sessionInformation(), 
[10:29:56.275]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:56.275]                   signalCondition(cond)
[10:29:56.275]                 }
[10:29:56.275]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:56.275]                 "immediateCondition"))) {
[10:29:56.275]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:56.275]                   ...future.conditions[[length(...future.conditions) + 
[10:29:56.275]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:56.275]                   if (TRUE && !signal) {
[10:29:56.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.275]                     {
[10:29:56.275]                       inherits <- base::inherits
[10:29:56.275]                       invokeRestart <- base::invokeRestart
[10:29:56.275]                       is.null <- base::is.null
[10:29:56.275]                       muffled <- FALSE
[10:29:56.275]                       if (inherits(cond, "message")) {
[10:29:56.275]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:56.275]                         if (muffled) 
[10:29:56.275]                           invokeRestart("muffleMessage")
[10:29:56.275]                       }
[10:29:56.275]                       else if (inherits(cond, "warning")) {
[10:29:56.275]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:56.275]                         if (muffled) 
[10:29:56.275]                           invokeRestart("muffleWarning")
[10:29:56.275]                       }
[10:29:56.275]                       else if (inherits(cond, "condition")) {
[10:29:56.275]                         if (!is.null(pattern)) {
[10:29:56.275]                           computeRestarts <- base::computeRestarts
[10:29:56.275]                           grepl <- base::grepl
[10:29:56.275]                           restarts <- computeRestarts(cond)
[10:29:56.275]                           for (restart in restarts) {
[10:29:56.275]                             name <- restart$name
[10:29:56.275]                             if (is.null(name)) 
[10:29:56.275]                               next
[10:29:56.275]                             if (!grepl(pattern, name)) 
[10:29:56.275]                               next
[10:29:56.275]                             invokeRestart(restart)
[10:29:56.275]                             muffled <- TRUE
[10:29:56.275]                             break
[10:29:56.275]                           }
[10:29:56.275]                         }
[10:29:56.275]                       }
[10:29:56.275]                       invisible(muffled)
[10:29:56.275]                     }
[10:29:56.275]                     muffleCondition(cond, pattern = "^muffle")
[10:29:56.275]                   }
[10:29:56.275]                 }
[10:29:56.275]                 else {
[10:29:56.275]                   if (TRUE) {
[10:29:56.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.275]                     {
[10:29:56.275]                       inherits <- base::inherits
[10:29:56.275]                       invokeRestart <- base::invokeRestart
[10:29:56.275]                       is.null <- base::is.null
[10:29:56.275]                       muffled <- FALSE
[10:29:56.275]                       if (inherits(cond, "message")) {
[10:29:56.275]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:56.275]                         if (muffled) 
[10:29:56.275]                           invokeRestart("muffleMessage")
[10:29:56.275]                       }
[10:29:56.275]                       else if (inherits(cond, "warning")) {
[10:29:56.275]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:56.275]                         if (muffled) 
[10:29:56.275]                           invokeRestart("muffleWarning")
[10:29:56.275]                       }
[10:29:56.275]                       else if (inherits(cond, "condition")) {
[10:29:56.275]                         if (!is.null(pattern)) {
[10:29:56.275]                           computeRestarts <- base::computeRestarts
[10:29:56.275]                           grepl <- base::grepl
[10:29:56.275]                           restarts <- computeRestarts(cond)
[10:29:56.275]                           for (restart in restarts) {
[10:29:56.275]                             name <- restart$name
[10:29:56.275]                             if (is.null(name)) 
[10:29:56.275]                               next
[10:29:56.275]                             if (!grepl(pattern, name)) 
[10:29:56.275]                               next
[10:29:56.275]                             invokeRestart(restart)
[10:29:56.275]                             muffled <- TRUE
[10:29:56.275]                             break
[10:29:56.275]                           }
[10:29:56.275]                         }
[10:29:56.275]                       }
[10:29:56.275]                       invisible(muffled)
[10:29:56.275]                     }
[10:29:56.275]                     muffleCondition(cond, pattern = "^muffle")
[10:29:56.275]                   }
[10:29:56.275]                 }
[10:29:56.275]             }
[10:29:56.275]         }))
[10:29:56.275]     }, error = function(ex) {
[10:29:56.275]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:56.275]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:56.275]                 ...future.rng), started = ...future.startTime, 
[10:29:56.275]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:56.275]             version = "1.8"), class = "FutureResult")
[10:29:56.275]     }, finally = {
[10:29:56.275]         if (!identical(...future.workdir, getwd())) 
[10:29:56.275]             setwd(...future.workdir)
[10:29:56.275]         {
[10:29:56.275]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:56.275]                 ...future.oldOptions$nwarnings <- NULL
[10:29:56.275]             }
[10:29:56.275]             base::options(...future.oldOptions)
[10:29:56.275]             if (.Platform$OS.type == "windows") {
[10:29:56.275]                 old_names <- names(...future.oldEnvVars)
[10:29:56.275]                 envs <- base::Sys.getenv()
[10:29:56.275]                 names <- names(envs)
[10:29:56.275]                 common <- intersect(names, old_names)
[10:29:56.275]                 added <- setdiff(names, old_names)
[10:29:56.275]                 removed <- setdiff(old_names, names)
[10:29:56.275]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:56.275]                   envs[common]]
[10:29:56.275]                 NAMES <- toupper(changed)
[10:29:56.275]                 args <- list()
[10:29:56.275]                 for (kk in seq_along(NAMES)) {
[10:29:56.275]                   name <- changed[[kk]]
[10:29:56.275]                   NAME <- NAMES[[kk]]
[10:29:56.275]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.275]                     next
[10:29:56.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:56.275]                 }
[10:29:56.275]                 NAMES <- toupper(added)
[10:29:56.275]                 for (kk in seq_along(NAMES)) {
[10:29:56.275]                   name <- added[[kk]]
[10:29:56.275]                   NAME <- NAMES[[kk]]
[10:29:56.275]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.275]                     next
[10:29:56.275]                   args[[name]] <- ""
[10:29:56.275]                 }
[10:29:56.275]                 NAMES <- toupper(removed)
[10:29:56.275]                 for (kk in seq_along(NAMES)) {
[10:29:56.275]                   name <- removed[[kk]]
[10:29:56.275]                   NAME <- NAMES[[kk]]
[10:29:56.275]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.275]                     next
[10:29:56.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:56.275]                 }
[10:29:56.275]                 if (length(args) > 0) 
[10:29:56.275]                   base::do.call(base::Sys.setenv, args = args)
[10:29:56.275]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:56.275]             }
[10:29:56.275]             else {
[10:29:56.275]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:56.275]             }
[10:29:56.275]             {
[10:29:56.275]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:56.275]                   0L) {
[10:29:56.275]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:56.275]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:56.275]                   base::options(opts)
[10:29:56.275]                 }
[10:29:56.275]                 {
[10:29:56.275]                   {
[10:29:56.275]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:56.275]                     NULL
[10:29:56.275]                   }
[10:29:56.275]                   options(future.plan = NULL)
[10:29:56.275]                   if (is.na(NA_character_)) 
[10:29:56.275]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:56.275]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:56.275]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:56.275]                     .init = FALSE)
[10:29:56.275]                 }
[10:29:56.275]             }
[10:29:56.275]         }
[10:29:56.275]     })
[10:29:56.275]     if (TRUE) {
[10:29:56.275]         base::sink(type = "output", split = FALSE)
[10:29:56.275]         if (TRUE) {
[10:29:56.275]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:56.275]         }
[10:29:56.275]         else {
[10:29:56.275]             ...future.result["stdout"] <- base::list(NULL)
[10:29:56.275]         }
[10:29:56.275]         base::close(...future.stdout)
[10:29:56.275]         ...future.stdout <- NULL
[10:29:56.275]     }
[10:29:56.275]     ...future.result$conditions <- ...future.conditions
[10:29:56.275]     ...future.result$finished <- base::Sys.time()
[10:29:56.275]     ...future.result
[10:29:56.275] }
[10:29:56.278] Exporting 7 global objects (2.27 KiB) to cluster node #1 ...
[10:29:56.281] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ...
[10:29:56.281] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ... DONE
[10:29:56.281] Exporting ‘breaks’ (480 bytes) to cluster node #1 ...
[10:29:56.282] Exporting ‘breaks’ (480 bytes) to cluster node #1 ... DONE
[10:29:56.282] Exporting ‘wool’ (776 bytes) to cluster node #1 ...
[10:29:56.282] Exporting ‘wool’ (776 bytes) to cluster node #1 ... DONE
[10:29:56.282] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:29:56.283] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:29:56.283] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[10:29:56.283] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[10:29:56.283] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:29:56.283] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:29:56.284] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:29:56.284] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:29:56.284] Exporting 7 global objects (2.27 KiB) to cluster node #1 ... DONE
[10:29:56.285] MultisessionFuture started
[10:29:56.285] - Launch lazy future ... done
[10:29:56.285] run() for ‘MultisessionFuture’ ... done
[10:29:56.285] Created future:
[10:29:56.285] MultisessionFuture:
[10:29:56.285] Label: ‘future_by-1’
[10:29:56.285] Expression:
[10:29:56.285] {
[10:29:56.285]     do.call(function(...) {
[10:29:56.285]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.285]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:56.285]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.285]             on.exit(options(oopts), add = TRUE)
[10:29:56.285]         }
[10:29:56.285]         {
[10:29:56.285]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:56.285]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.285]                 ...future.FUN(...future.X_jj, ...)
[10:29:56.285]             })
[10:29:56.285]         }
[10:29:56.285]     }, args = future.call.arguments)
[10:29:56.285] }
[10:29:56.285] Lazy evaluation: FALSE
[10:29:56.285] Asynchronous evaluation: TRUE
[10:29:56.285] Local evaluation: TRUE
[10:29:56.285] Environment: 0x556dd5f21168
[10:29:56.285] Capture standard output: TRUE
[10:29:56.285] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:56.285] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[10:29:56.285] Packages: 1 packages (‘stats’)
[10:29:56.285] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:56.285] Resolved: FALSE
[10:29:56.285] Value: <not collected>
[10:29:56.285] Conditions captured: <none>
[10:29:56.285] Early signaling: FALSE
[10:29:56.285] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:56.285] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:56.297] Chunk #1 of 2 ... DONE
[10:29:56.297] Chunk #2 of 2 ...
[10:29:56.297]  - Finding globals in 'X' for chunk #2 ...
[10:29:56.297] getGlobalsAndPackages() ...
[10:29:56.297] Searching for globals...
[10:29:56.298] 
[10:29:56.298] Searching for globals ... DONE
[10:29:56.298] - globals: [0] <none>
[10:29:56.298] getGlobalsAndPackages() ... DONE
[10:29:56.298]    + additional globals found: [n=0] 
[10:29:56.298]    + additional namespaces needed: [n=0] 
[10:29:56.298]  - Finding globals in 'X' for chunk #2 ... DONE
[10:29:56.298]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:56.299]  - seeds: <none>
[10:29:56.299]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.299] getGlobalsAndPackages() ...
[10:29:56.299] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.299] Resolving globals: FALSE
[10:29:56.299] Tweak future expression to call with '...' arguments ...
[10:29:56.299] {
[10:29:56.299]     do.call(function(...) {
[10:29:56.299]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.299]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:56.299]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.299]             on.exit(options(oopts), add = TRUE)
[10:29:56.299]         }
[10:29:56.299]         {
[10:29:56.299]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:56.299]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.299]                 ...future.FUN(...future.X_jj, ...)
[10:29:56.299]             })
[10:29:56.299]         }
[10:29:56.299]     }, args = future.call.arguments)
[10:29:56.299] }
[10:29:56.299] Tweak future expression to call with '...' arguments ... DONE
[10:29:56.300] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.300] 
[10:29:56.300] getGlobalsAndPackages() ... DONE
[10:29:56.300] run() for ‘Future’ ...
[10:29:56.301] - state: ‘created’
[10:29:56.301] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:56.315] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:56.315] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:56.315]   - Field: ‘node’
[10:29:56.315]   - Field: ‘label’
[10:29:56.315]   - Field: ‘local’
[10:29:56.316]   - Field: ‘owner’
[10:29:56.316]   - Field: ‘envir’
[10:29:56.316]   - Field: ‘workers’
[10:29:56.316]   - Field: ‘packages’
[10:29:56.316]   - Field: ‘gc’
[10:29:56.316]   - Field: ‘conditions’
[10:29:56.316]   - Field: ‘persistent’
[10:29:56.316]   - Field: ‘expr’
[10:29:56.316]   - Field: ‘uuid’
[10:29:56.316]   - Field: ‘seed’
[10:29:56.316]   - Field: ‘version’
[10:29:56.317]   - Field: ‘result’
[10:29:56.317]   - Field: ‘asynchronous’
[10:29:56.317]   - Field: ‘calls’
[10:29:56.317]   - Field: ‘globals’
[10:29:56.317]   - Field: ‘stdout’
[10:29:56.317]   - Field: ‘earlySignal’
[10:29:56.317]   - Field: ‘lazy’
[10:29:56.317]   - Field: ‘state’
[10:29:56.317] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:56.317] - Launch lazy future ...
[10:29:56.318] Packages needed by the future expression (n = 1): ‘stats’
[10:29:56.318] Packages needed by future strategies (n = 0): <none>
[10:29:56.318] {
[10:29:56.318]     {
[10:29:56.318]         {
[10:29:56.318]             ...future.startTime <- base::Sys.time()
[10:29:56.318]             {
[10:29:56.318]                 {
[10:29:56.318]                   {
[10:29:56.318]                     {
[10:29:56.318]                       {
[10:29:56.318]                         base::local({
[10:29:56.318]                           has_future <- base::requireNamespace("future", 
[10:29:56.318]                             quietly = TRUE)
[10:29:56.318]                           if (has_future) {
[10:29:56.318]                             ns <- base::getNamespace("future")
[10:29:56.318]                             version <- ns[[".package"]][["version"]]
[10:29:56.318]                             if (is.null(version)) 
[10:29:56.318]                               version <- utils::packageVersion("future")
[10:29:56.318]                           }
[10:29:56.318]                           else {
[10:29:56.318]                             version <- NULL
[10:29:56.318]                           }
[10:29:56.318]                           if (!has_future || version < "1.8.0") {
[10:29:56.318]                             info <- base::c(r_version = base::gsub("R version ", 
[10:29:56.318]                               "", base::R.version$version.string), 
[10:29:56.318]                               platform = base::sprintf("%s (%s-bit)", 
[10:29:56.318]                                 base::R.version$platform, 8 * 
[10:29:56.318]                                   base::.Machine$sizeof.pointer), 
[10:29:56.318]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:56.318]                                 "release", "version")], collapse = " "), 
[10:29:56.318]                               hostname = base::Sys.info()[["nodename"]])
[10:29:56.318]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:29:56.318]                               info)
[10:29:56.318]                             info <- base::paste(info, collapse = "; ")
[10:29:56.318]                             if (!has_future) {
[10:29:56.318]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:56.318]                                 info)
[10:29:56.318]                             }
[10:29:56.318]                             else {
[10:29:56.318]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:56.318]                                 info, version)
[10:29:56.318]                             }
[10:29:56.318]                             base::stop(msg)
[10:29:56.318]                           }
[10:29:56.318]                         })
[10:29:56.318]                       }
[10:29:56.318]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:56.318]                       base::options(mc.cores = 1L)
[10:29:56.318]                     }
[10:29:56.318]                     base::local({
[10:29:56.318]                       for (pkg in "stats") {
[10:29:56.318]                         base::loadNamespace(pkg)
[10:29:56.318]                         base::library(pkg, character.only = TRUE)
[10:29:56.318]                       }
[10:29:56.318]                     })
[10:29:56.318]                   }
[10:29:56.318]                   ...future.strategy.old <- future::plan("list")
[10:29:56.318]                   options(future.plan = NULL)
[10:29:56.318]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:56.318]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:56.318]                 }
[10:29:56.318]                 ...future.workdir <- getwd()
[10:29:56.318]             }
[10:29:56.318]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:56.318]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:56.318]         }
[10:29:56.318]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:56.318]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:56.318]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:56.318]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:56.318]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:56.318]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:56.318]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:56.318]             base::names(...future.oldOptions))
[10:29:56.318]     }
[10:29:56.318]     if (FALSE) {
[10:29:56.318]     }
[10:29:56.318]     else {
[10:29:56.318]         if (TRUE) {
[10:29:56.318]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:56.318]                 open = "w")
[10:29:56.318]         }
[10:29:56.318]         else {
[10:29:56.318]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:56.318]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:56.318]         }
[10:29:56.318]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:56.318]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:56.318]             base::sink(type = "output", split = FALSE)
[10:29:56.318]             base::close(...future.stdout)
[10:29:56.318]         }, add = TRUE)
[10:29:56.318]     }
[10:29:56.318]     ...future.frame <- base::sys.nframe()
[10:29:56.318]     ...future.conditions <- base::list()
[10:29:56.318]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:56.318]     if (FALSE) {
[10:29:56.318]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:56.318]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:56.318]     }
[10:29:56.318]     ...future.result <- base::tryCatch({
[10:29:56.318]         base::withCallingHandlers({
[10:29:56.318]             ...future.value <- base::withVisible(base::local({
[10:29:56.318]                 ...future.makeSendCondition <- base::local({
[10:29:56.318]                   sendCondition <- NULL
[10:29:56.318]                   function(frame = 1L) {
[10:29:56.318]                     if (is.function(sendCondition)) 
[10:29:56.318]                       return(sendCondition)
[10:29:56.318]                     ns <- getNamespace("parallel")
[10:29:56.318]                     if (exists("sendData", mode = "function", 
[10:29:56.318]                       envir = ns)) {
[10:29:56.318]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:56.318]                         envir = ns)
[10:29:56.318]                       envir <- sys.frame(frame)
[10:29:56.318]                       master <- NULL
[10:29:56.318]                       while (!identical(envir, .GlobalEnv) && 
[10:29:56.318]                         !identical(envir, emptyenv())) {
[10:29:56.318]                         if (exists("master", mode = "list", envir = envir, 
[10:29:56.318]                           inherits = FALSE)) {
[10:29:56.318]                           master <- get("master", mode = "list", 
[10:29:56.318]                             envir = envir, inherits = FALSE)
[10:29:56.318]                           if (inherits(master, c("SOCKnode", 
[10:29:56.318]                             "SOCK0node"))) {
[10:29:56.318]                             sendCondition <<- function(cond) {
[10:29:56.318]                               data <- list(type = "VALUE", value = cond, 
[10:29:56.318]                                 success = TRUE)
[10:29:56.318]                               parallel_sendData(master, data)
[10:29:56.318]                             }
[10:29:56.318]                             return(sendCondition)
[10:29:56.318]                           }
[10:29:56.318]                         }
[10:29:56.318]                         frame <- frame + 1L
[10:29:56.318]                         envir <- sys.frame(frame)
[10:29:56.318]                       }
[10:29:56.318]                     }
[10:29:56.318]                     sendCondition <<- function(cond) NULL
[10:29:56.318]                   }
[10:29:56.318]                 })
[10:29:56.318]                 withCallingHandlers({
[10:29:56.318]                   {
[10:29:56.318]                     do.call(function(...) {
[10:29:56.318]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.318]                       if (!identical(...future.globals.maxSize.org, 
[10:29:56.318]                         ...future.globals.maxSize)) {
[10:29:56.318]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.318]                         on.exit(options(oopts), add = TRUE)
[10:29:56.318]                       }
[10:29:56.318]                       {
[10:29:56.318]                         lapply(seq_along(...future.elements_ii), 
[10:29:56.318]                           FUN = function(jj) {
[10:29:56.318]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.318]                             ...future.FUN(...future.X_jj, ...)
[10:29:56.318]                           })
[10:29:56.318]                       }
[10:29:56.318]                     }, args = future.call.arguments)
[10:29:56.318]                   }
[10:29:56.318]                 }, immediateCondition = function(cond) {
[10:29:56.318]                   sendCondition <- ...future.makeSendCondition()
[10:29:56.318]                   sendCondition(cond)
[10:29:56.318]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.318]                   {
[10:29:56.318]                     inherits <- base::inherits
[10:29:56.318]                     invokeRestart <- base::invokeRestart
[10:29:56.318]                     is.null <- base::is.null
[10:29:56.318]                     muffled <- FALSE
[10:29:56.318]                     if (inherits(cond, "message")) {
[10:29:56.318]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:56.318]                       if (muffled) 
[10:29:56.318]                         invokeRestart("muffleMessage")
[10:29:56.318]                     }
[10:29:56.318]                     else if (inherits(cond, "warning")) {
[10:29:56.318]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:56.318]                       if (muffled) 
[10:29:56.318]                         invokeRestart("muffleWarning")
[10:29:56.318]                     }
[10:29:56.318]                     else if (inherits(cond, "condition")) {
[10:29:56.318]                       if (!is.null(pattern)) {
[10:29:56.318]                         computeRestarts <- base::computeRestarts
[10:29:56.318]                         grepl <- base::grepl
[10:29:56.318]                         restarts <- computeRestarts(cond)
[10:29:56.318]                         for (restart in restarts) {
[10:29:56.318]                           name <- restart$name
[10:29:56.318]                           if (is.null(name)) 
[10:29:56.318]                             next
[10:29:56.318]                           if (!grepl(pattern, name)) 
[10:29:56.318]                             next
[10:29:56.318]                           invokeRestart(restart)
[10:29:56.318]                           muffled <- TRUE
[10:29:56.318]                           break
[10:29:56.318]                         }
[10:29:56.318]                       }
[10:29:56.318]                     }
[10:29:56.318]                     invisible(muffled)
[10:29:56.318]                   }
[10:29:56.318]                   muffleCondition(cond)
[10:29:56.318]                 })
[10:29:56.318]             }))
[10:29:56.318]             future::FutureResult(value = ...future.value$value, 
[10:29:56.318]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:56.318]                   ...future.rng), globalenv = if (FALSE) 
[10:29:56.318]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:56.318]                     ...future.globalenv.names))
[10:29:56.318]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:56.318]         }, condition = base::local({
[10:29:56.318]             c <- base::c
[10:29:56.318]             inherits <- base::inherits
[10:29:56.318]             invokeRestart <- base::invokeRestart
[10:29:56.318]             length <- base::length
[10:29:56.318]             list <- base::list
[10:29:56.318]             seq.int <- base::seq.int
[10:29:56.318]             signalCondition <- base::signalCondition
[10:29:56.318]             sys.calls <- base::sys.calls
[10:29:56.318]             `[[` <- base::`[[`
[10:29:56.318]             `+` <- base::`+`
[10:29:56.318]             `<<-` <- base::`<<-`
[10:29:56.318]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:56.318]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:56.318]                   3L)]
[10:29:56.318]             }
[10:29:56.318]             function(cond) {
[10:29:56.318]                 is_error <- inherits(cond, "error")
[10:29:56.318]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:56.318]                   NULL)
[10:29:56.318]                 if (is_error) {
[10:29:56.318]                   sessionInformation <- function() {
[10:29:56.318]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:56.318]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:56.318]                       search = base::search(), system = base::Sys.info())
[10:29:56.318]                   }
[10:29:56.318]                   ...future.conditions[[length(...future.conditions) + 
[10:29:56.318]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:56.318]                     cond$call), session = sessionInformation(), 
[10:29:56.318]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:56.318]                   signalCondition(cond)
[10:29:56.318]                 }
[10:29:56.318]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:56.318]                 "immediateCondition"))) {
[10:29:56.318]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:56.318]                   ...future.conditions[[length(...future.conditions) + 
[10:29:56.318]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:56.318]                   if (TRUE && !signal) {
[10:29:56.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.318]                     {
[10:29:56.318]                       inherits <- base::inherits
[10:29:56.318]                       invokeRestart <- base::invokeRestart
[10:29:56.318]                       is.null <- base::is.null
[10:29:56.318]                       muffled <- FALSE
[10:29:56.318]                       if (inherits(cond, "message")) {
[10:29:56.318]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:56.318]                         if (muffled) 
[10:29:56.318]                           invokeRestart("muffleMessage")
[10:29:56.318]                       }
[10:29:56.318]                       else if (inherits(cond, "warning")) {
[10:29:56.318]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:56.318]                         if (muffled) 
[10:29:56.318]                           invokeRestart("muffleWarning")
[10:29:56.318]                       }
[10:29:56.318]                       else if (inherits(cond, "condition")) {
[10:29:56.318]                         if (!is.null(pattern)) {
[10:29:56.318]                           computeRestarts <- base::computeRestarts
[10:29:56.318]                           grepl <- base::grepl
[10:29:56.318]                           restarts <- computeRestarts(cond)
[10:29:56.318]                           for (restart in restarts) {
[10:29:56.318]                             name <- restart$name
[10:29:56.318]                             if (is.null(name)) 
[10:29:56.318]                               next
[10:29:56.318]                             if (!grepl(pattern, name)) 
[10:29:56.318]                               next
[10:29:56.318]                             invokeRestart(restart)
[10:29:56.318]                             muffled <- TRUE
[10:29:56.318]                             break
[10:29:56.318]                           }
[10:29:56.318]                         }
[10:29:56.318]                       }
[10:29:56.318]                       invisible(muffled)
[10:29:56.318]                     }
[10:29:56.318]                     muffleCondition(cond, pattern = "^muffle")
[10:29:56.318]                   }
[10:29:56.318]                 }
[10:29:56.318]                 else {
[10:29:56.318]                   if (TRUE) {
[10:29:56.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.318]                     {
[10:29:56.318]                       inherits <- base::inherits
[10:29:56.318]                       invokeRestart <- base::invokeRestart
[10:29:56.318]                       is.null <- base::is.null
[10:29:56.318]                       muffled <- FALSE
[10:29:56.318]                       if (inherits(cond, "message")) {
[10:29:56.318]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:56.318]                         if (muffled) 
[10:29:56.318]                           invokeRestart("muffleMessage")
[10:29:56.318]                       }
[10:29:56.318]                       else if (inherits(cond, "warning")) {
[10:29:56.318]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:56.318]                         if (muffled) 
[10:29:56.318]                           invokeRestart("muffleWarning")
[10:29:56.318]                       }
[10:29:56.318]                       else if (inherits(cond, "condition")) {
[10:29:56.318]                         if (!is.null(pattern)) {
[10:29:56.318]                           computeRestarts <- base::computeRestarts
[10:29:56.318]                           grepl <- base::grepl
[10:29:56.318]                           restarts <- computeRestarts(cond)
[10:29:56.318]                           for (restart in restarts) {
[10:29:56.318]                             name <- restart$name
[10:29:56.318]                             if (is.null(name)) 
[10:29:56.318]                               next
[10:29:56.318]                             if (!grepl(pattern, name)) 
[10:29:56.318]                               next
[10:29:56.318]                             invokeRestart(restart)
[10:29:56.318]                             muffled <- TRUE
[10:29:56.318]                             break
[10:29:56.318]                           }
[10:29:56.318]                         }
[10:29:56.318]                       }
[10:29:56.318]                       invisible(muffled)
[10:29:56.318]                     }
[10:29:56.318]                     muffleCondition(cond, pattern = "^muffle")
[10:29:56.318]                   }
[10:29:56.318]                 }
[10:29:56.318]             }
[10:29:56.318]         }))
[10:29:56.318]     }, error = function(ex) {
[10:29:56.318]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:56.318]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:56.318]                 ...future.rng), started = ...future.startTime, 
[10:29:56.318]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:56.318]             version = "1.8"), class = "FutureResult")
[10:29:56.318]     }, finally = {
[10:29:56.318]         if (!identical(...future.workdir, getwd())) 
[10:29:56.318]             setwd(...future.workdir)
[10:29:56.318]         {
[10:29:56.318]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:56.318]                 ...future.oldOptions$nwarnings <- NULL
[10:29:56.318]             }
[10:29:56.318]             base::options(...future.oldOptions)
[10:29:56.318]             if (.Platform$OS.type == "windows") {
[10:29:56.318]                 old_names <- names(...future.oldEnvVars)
[10:29:56.318]                 envs <- base::Sys.getenv()
[10:29:56.318]                 names <- names(envs)
[10:29:56.318]                 common <- intersect(names, old_names)
[10:29:56.318]                 added <- setdiff(names, old_names)
[10:29:56.318]                 removed <- setdiff(old_names, names)
[10:29:56.318]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:56.318]                   envs[common]]
[10:29:56.318]                 NAMES <- toupper(changed)
[10:29:56.318]                 args <- list()
[10:29:56.318]                 for (kk in seq_along(NAMES)) {
[10:29:56.318]                   name <- changed[[kk]]
[10:29:56.318]                   NAME <- NAMES[[kk]]
[10:29:56.318]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.318]                     next
[10:29:56.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:56.318]                 }
[10:29:56.318]                 NAMES <- toupper(added)
[10:29:56.318]                 for (kk in seq_along(NAMES)) {
[10:29:56.318]                   name <- added[[kk]]
[10:29:56.318]                   NAME <- NAMES[[kk]]
[10:29:56.318]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.318]                     next
[10:29:56.318]                   args[[name]] <- ""
[10:29:56.318]                 }
[10:29:56.318]                 NAMES <- toupper(removed)
[10:29:56.318]                 for (kk in seq_along(NAMES)) {
[10:29:56.318]                   name <- removed[[kk]]
[10:29:56.318]                   NAME <- NAMES[[kk]]
[10:29:56.318]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.318]                     next
[10:29:56.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:56.318]                 }
[10:29:56.318]                 if (length(args) > 0) 
[10:29:56.318]                   base::do.call(base::Sys.setenv, args = args)
[10:29:56.318]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:56.318]             }
[10:29:56.318]             else {
[10:29:56.318]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:56.318]             }
[10:29:56.318]             {
[10:29:56.318]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:56.318]                   0L) {
[10:29:56.318]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:56.318]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:56.318]                   base::options(opts)
[10:29:56.318]                 }
[10:29:56.318]                 {
[10:29:56.318]                   {
[10:29:56.318]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:56.318]                     NULL
[10:29:56.318]                   }
[10:29:56.318]                   options(future.plan = NULL)
[10:29:56.318]                   if (is.na(NA_character_)) 
[10:29:56.318]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:56.318]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:56.318]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:56.318]                     .init = FALSE)
[10:29:56.318]                 }
[10:29:56.318]             }
[10:29:56.318]         }
[10:29:56.318]     })
[10:29:56.318]     if (TRUE) {
[10:29:56.318]         base::sink(type = "output", split = FALSE)
[10:29:56.318]         if (TRUE) {
[10:29:56.318]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:56.318]         }
[10:29:56.318]         else {
[10:29:56.318]             ...future.result["stdout"] <- base::list(NULL)
[10:29:56.318]         }
[10:29:56.318]         base::close(...future.stdout)
[10:29:56.318]         ...future.stdout <- NULL
[10:29:56.318]     }
[10:29:56.318]     ...future.result$conditions <- ...future.conditions
[10:29:56.318]     ...future.result$finished <- base::Sys.time()
[10:29:56.318]     ...future.result
[10:29:56.318] }
[10:29:56.321] Exporting 7 global objects (2.27 KiB) to cluster node #2 ...
[10:29:56.322] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ...
[10:29:56.322] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ... DONE
[10:29:56.322] Exporting ‘breaks’ (480 bytes) to cluster node #2 ...
[10:29:56.323] Exporting ‘breaks’ (480 bytes) to cluster node #2 ... DONE
[10:29:56.323] Exporting ‘wool’ (776 bytes) to cluster node #2 ...
[10:29:56.323] Exporting ‘wool’ (776 bytes) to cluster node #2 ... DONE
[10:29:56.323] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:29:56.324] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:29:56.324] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[10:29:56.324] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[10:29:56.324] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:29:56.325] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:29:56.325] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:29:56.325] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:29:56.325] Exporting 7 global objects (2.27 KiB) to cluster node #2 ... DONE
[10:29:56.326] MultisessionFuture started
[10:29:56.326] - Launch lazy future ... done
[10:29:56.326] run() for ‘MultisessionFuture’ ... done
[10:29:56.327] Created future:
[10:29:56.327] MultisessionFuture:
[10:29:56.327] Label: ‘future_by-2’
[10:29:56.327] Expression:
[10:29:56.327] {
[10:29:56.327]     do.call(function(...) {
[10:29:56.327]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.327]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:56.327]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.327]             on.exit(options(oopts), add = TRUE)
[10:29:56.327]         }
[10:29:56.327]         {
[10:29:56.327]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:56.327]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.327]                 ...future.FUN(...future.X_jj, ...)
[10:29:56.327]             })
[10:29:56.327]         }
[10:29:56.327]     }, args = future.call.arguments)
[10:29:56.327] }
[10:29:56.327] Lazy evaluation: FALSE
[10:29:56.327] Asynchronous evaluation: TRUE
[10:29:56.327] Local evaluation: TRUE
[10:29:56.327] Environment: 0x556dd5f21168
[10:29:56.327] Capture standard output: TRUE
[10:29:56.327] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:56.327] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[10:29:56.327] Packages: 1 packages (‘stats’)
[10:29:56.327] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:56.327] Resolved: FALSE
[10:29:56.327] Value: <not collected>
[10:29:56.327] Conditions captured: <none>
[10:29:56.327] Early signaling: FALSE
[10:29:56.327] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:56.327] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:56.338] Chunk #2 of 2 ... DONE
[10:29:56.339] Launching 2 futures (chunks) ... DONE
[10:29:56.339] Resolving 2 futures (chunks) ...
[10:29:56.339] resolve() on list ...
[10:29:56.339]  recursive: 0
[10:29:56.339]  length: 2
[10:29:56.339] 
[10:29:56.339] receiveMessageFromWorker() for ClusterFuture ...
[10:29:56.340] - Validating connection of MultisessionFuture
[10:29:56.340] - received message: FutureResult
[10:29:56.340] - Received FutureResult
[10:29:56.340] - Erased future from FutureRegistry
[10:29:56.340] result() for ClusterFuture ...
[10:29:56.340] - result already collected: FutureResult
[10:29:56.340] result() for ClusterFuture ... done
[10:29:56.340] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:56.340] Future #1
[10:29:56.341] result() for ClusterFuture ...
[10:29:56.341] - result already collected: FutureResult
[10:29:56.341] result() for ClusterFuture ... done
[10:29:56.341] result() for ClusterFuture ...
[10:29:56.341] - result already collected: FutureResult
[10:29:56.341] result() for ClusterFuture ... done
[10:29:56.341] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:29:56.341] - nx: 2
[10:29:56.341] - relay: TRUE
[10:29:56.341] - stdout: TRUE
[10:29:56.341] - signal: TRUE
[10:29:56.341] - resignal: FALSE
[10:29:56.342] - force: TRUE
[10:29:56.342] - relayed: [n=2] FALSE, FALSE
[10:29:56.342] - queued futures: [n=2] FALSE, FALSE
[10:29:56.342]  - until=1
[10:29:56.342]  - relaying element #1
[10:29:56.342] result() for ClusterFuture ...
[10:29:56.342] - result already collected: FutureResult
[10:29:56.342] result() for ClusterFuture ... done
[10:29:56.342] result() for ClusterFuture ...
[10:29:56.342] - result already collected: FutureResult
[10:29:56.342] result() for ClusterFuture ... done
[10:29:56.343] result() for ClusterFuture ...
[10:29:56.343] - result already collected: FutureResult
[10:29:56.343] result() for ClusterFuture ... done
[10:29:56.343] result() for ClusterFuture ...
[10:29:56.343] - result already collected: FutureResult
[10:29:56.343] result() for ClusterFuture ... done
[10:29:56.343] - relayed: [n=2] TRUE, FALSE
[10:29:56.343] - queued futures: [n=2] TRUE, FALSE
[10:29:56.343] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:29:56.343]  length: 1 (resolved future 1)
[10:29:56.372] receiveMessageFromWorker() for ClusterFuture ...
[10:29:56.373] - Validating connection of MultisessionFuture
[10:29:56.373] - received message: FutureResult
[10:29:56.373] - Received FutureResult
[10:29:56.373] - Erased future from FutureRegistry
[10:29:56.373] result() for ClusterFuture ...
[10:29:56.373] - result already collected: FutureResult
[10:29:56.373] result() for ClusterFuture ... done
[10:29:56.374] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:56.374] Future #2
[10:29:56.374] result() for ClusterFuture ...
[10:29:56.374] - result already collected: FutureResult
[10:29:56.374] result() for ClusterFuture ... done
[10:29:56.374] result() for ClusterFuture ...
[10:29:56.374] - result already collected: FutureResult
[10:29:56.374] result() for ClusterFuture ... done
[10:29:56.374] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:29:56.374] - nx: 2
[10:29:56.374] - relay: TRUE
[10:29:56.375] - stdout: TRUE
[10:29:56.375] - signal: TRUE
[10:29:56.375] - resignal: FALSE
[10:29:56.375] - force: TRUE
[10:29:56.375] - relayed: [n=2] TRUE, FALSE
[10:29:56.375] - queued futures: [n=2] TRUE, FALSE
[10:29:56.375]  - until=2
[10:29:56.375]  - relaying element #2
[10:29:56.375] result() for ClusterFuture ...
[10:29:56.375] - result already collected: FutureResult
[10:29:56.375] result() for ClusterFuture ... done
[10:29:56.376] result() for ClusterFuture ...
[10:29:56.376] - result already collected: FutureResult
[10:29:56.376] result() for ClusterFuture ... done
[10:29:56.376] result() for ClusterFuture ...
[10:29:56.376] - result already collected: FutureResult
[10:29:56.376] result() for ClusterFuture ... done
[10:29:56.376] result() for ClusterFuture ...
[10:29:56.376] - result already collected: FutureResult
[10:29:56.376] result() for ClusterFuture ... done
[10:29:56.376] - relayed: [n=2] TRUE, TRUE
[10:29:56.376] - queued futures: [n=2] TRUE, TRUE
[10:29:56.377] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:29:56.377]  length: 0 (resolved future 2)
[10:29:56.377] Relaying remaining futures
[10:29:56.377] signalConditionsASAP(NULL, pos=0) ...
[10:29:56.377] - nx: 2
[10:29:56.377] - relay: TRUE
[10:29:56.377] - stdout: TRUE
[10:29:56.377] - signal: TRUE
[10:29:56.377] - resignal: FALSE
[10:29:56.377] - force: TRUE
[10:29:56.377] - relayed: [n=2] TRUE, TRUE
[10:29:56.377] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:56.378] - relayed: [n=2] TRUE, TRUE
[10:29:56.378] - queued futures: [n=2] TRUE, TRUE
[10:29:56.378] signalConditionsASAP(NULL, pos=0) ... done
[10:29:56.378] resolve() on list ... DONE
[10:29:56.378] result() for ClusterFuture ...
[10:29:56.378] - result already collected: FutureResult
[10:29:56.378] result() for ClusterFuture ... done
[10:29:56.378] result() for ClusterFuture ...
[10:29:56.378] - result already collected: FutureResult
[10:29:56.378] result() for ClusterFuture ... done
[10:29:56.378] result() for ClusterFuture ...
[10:29:56.379] - result already collected: FutureResult
[10:29:56.379] result() for ClusterFuture ... done
[10:29:56.379] result() for ClusterFuture ...
[10:29:56.379] - result already collected: FutureResult
[10:29:56.379] result() for ClusterFuture ... done
[10:29:56.379]  - Number of value chunks collected: 2
[10:29:56.379] Resolving 2 futures (chunks) ... DONE
[10:29:56.379] Reducing values from 2 chunks ...
[10:29:56.379]  - Number of values collected after concatenation: 3
[10:29:56.379]  - Number of values expected: 3
[10:29:56.379] Reducing values from 2 chunks ... DONE
[10:29:56.380] future_lapply() ... DONE
[10:29:56.380] future_by_internal() ... DONE
[10:29:56.380] future_by_internal() ...
[10:29:56.380] future_lapply() ...
[10:29:56.385] Number of chunks: 2
[10:29:56.385] getGlobalsAndPackagesXApply() ...
[10:29:56.385]  - future.globals: TRUE
[10:29:56.385] getGlobalsAndPackages() ...
[10:29:56.385] Searching for globals...
[10:29:56.387] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:56.387] Searching for globals ... DONE
[10:29:56.387] Resolving globals: FALSE
[10:29:56.387] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:56.387] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:56.388] - globals: [1] ‘FUN’
[10:29:56.388] 
[10:29:56.388] getGlobalsAndPackages() ... DONE
[10:29:56.388]  - globals found/used: [n=1] ‘FUN’
[10:29:56.388]  - needed namespaces: [n=0] 
[10:29:56.388] Finding globals ... DONE
[10:29:56.388]  - use_args: TRUE
[10:29:56.388]  - Getting '...' globals ...
[10:29:56.389] resolve() on list ...
[10:29:56.389]  recursive: 0
[10:29:56.389]  length: 1
[10:29:56.389]  elements: ‘...’
[10:29:56.389]  length: 0 (resolved future 1)
[10:29:56.389] resolve() on list ... DONE
[10:29:56.389]    - '...' content: [n=0] 
[10:29:56.389] List of 1
[10:29:56.389]  $ ...: list()
[10:29:56.389]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:56.389]  - attr(*, "where")=List of 1
[10:29:56.389]   ..$ ...:<environment: 0x556dd661ff70> 
[10:29:56.389]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:56.389]  - attr(*, "resolved")= logi TRUE
[10:29:56.389]  - attr(*, "total_size")= num NA
[10:29:56.392]  - Getting '...' globals ... DONE
[10:29:56.392] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:56.392] List of 2
[10:29:56.392]  $ ...future.FUN:function (object, ...)  
[10:29:56.392]  $ ...          : list()
[10:29:56.392]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:56.392]  - attr(*, "where")=List of 2
[10:29:56.392]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:56.392]   ..$ ...          :<environment: 0x556dd661ff70> 
[10:29:56.392]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:56.392]  - attr(*, "resolved")= logi FALSE
[10:29:56.392]  - attr(*, "total_size")= num 1240
[10:29:56.395] Packages to be attached in all futures: [n=0] 
[10:29:56.395] getGlobalsAndPackagesXApply() ... DONE
[10:29:56.395] Number of futures (= number of chunks): 2
[10:29:56.395] Launching 2 futures (chunks) ...
[10:29:56.395] Chunk #1 of 2 ...
[10:29:56.395]  - Finding globals in 'X' for chunk #1 ...
[10:29:56.396] getGlobalsAndPackages() ...
[10:29:56.396] Searching for globals...
[10:29:56.396] 
[10:29:56.396] Searching for globals ... DONE
[10:29:56.396] - globals: [0] <none>
[10:29:56.396] getGlobalsAndPackages() ... DONE
[10:29:56.396]    + additional globals found: [n=0] 
[10:29:56.396]    + additional namespaces needed: [n=0] 
[10:29:56.397]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:56.397]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:56.397]  - seeds: <none>
[10:29:56.397]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.397] getGlobalsAndPackages() ...
[10:29:56.397] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.397] Resolving globals: FALSE
[10:29:56.397] Tweak future expression to call with '...' arguments ...
[10:29:56.397] {
[10:29:56.397]     do.call(function(...) {
[10:29:56.397]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.397]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:56.397]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.397]             on.exit(options(oopts), add = TRUE)
[10:29:56.397]         }
[10:29:56.397]         {
[10:29:56.397]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:56.397]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.397]                 ...future.FUN(...future.X_jj, ...)
[10:29:56.397]             })
[10:29:56.397]         }
[10:29:56.397]     }, args = future.call.arguments)
[10:29:56.397] }
[10:29:56.398] Tweak future expression to call with '...' arguments ... DONE
[10:29:56.398] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.398] 
[10:29:56.398] getGlobalsAndPackages() ... DONE
[10:29:56.399] run() for ‘Future’ ...
[10:29:56.399] - state: ‘created’
[10:29:56.399] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:56.413] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:56.413] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:56.413]   - Field: ‘node’
[10:29:56.413]   - Field: ‘label’
[10:29:56.413]   - Field: ‘local’
[10:29:56.413]   - Field: ‘owner’
[10:29:56.413]   - Field: ‘envir’
[10:29:56.413]   - Field: ‘workers’
[10:29:56.414]   - Field: ‘packages’
[10:29:56.414]   - Field: ‘gc’
[10:29:56.414]   - Field: ‘conditions’
[10:29:56.414]   - Field: ‘persistent’
[10:29:56.414]   - Field: ‘expr’
[10:29:56.414]   - Field: ‘uuid’
[10:29:56.414]   - Field: ‘seed’
[10:29:56.414]   - Field: ‘version’
[10:29:56.414]   - Field: ‘result’
[10:29:56.414]   - Field: ‘asynchronous’
[10:29:56.414]   - Field: ‘calls’
[10:29:56.415]   - Field: ‘globals’
[10:29:56.415]   - Field: ‘stdout’
[10:29:56.415]   - Field: ‘earlySignal’
[10:29:56.415]   - Field: ‘lazy’
[10:29:56.415]   - Field: ‘state’
[10:29:56.415] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:56.415] - Launch lazy future ...
[10:29:56.415] Packages needed by the future expression (n = 0): <none>
[10:29:56.415] Packages needed by future strategies (n = 0): <none>
[10:29:56.416] {
[10:29:56.416]     {
[10:29:56.416]         {
[10:29:56.416]             ...future.startTime <- base::Sys.time()
[10:29:56.416]             {
[10:29:56.416]                 {
[10:29:56.416]                   {
[10:29:56.416]                     {
[10:29:56.416]                       base::local({
[10:29:56.416]                         has_future <- base::requireNamespace("future", 
[10:29:56.416]                           quietly = TRUE)
[10:29:56.416]                         if (has_future) {
[10:29:56.416]                           ns <- base::getNamespace("future")
[10:29:56.416]                           version <- ns[[".package"]][["version"]]
[10:29:56.416]                           if (is.null(version)) 
[10:29:56.416]                             version <- utils::packageVersion("future")
[10:29:56.416]                         }
[10:29:56.416]                         else {
[10:29:56.416]                           version <- NULL
[10:29:56.416]                         }
[10:29:56.416]                         if (!has_future || version < "1.8.0") {
[10:29:56.416]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:56.416]                             "", base::R.version$version.string), 
[10:29:56.416]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:56.416]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:56.416]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:56.416]                               "release", "version")], collapse = " "), 
[10:29:56.416]                             hostname = base::Sys.info()[["nodename"]])
[10:29:56.416]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:56.416]                             info)
[10:29:56.416]                           info <- base::paste(info, collapse = "; ")
[10:29:56.416]                           if (!has_future) {
[10:29:56.416]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:56.416]                               info)
[10:29:56.416]                           }
[10:29:56.416]                           else {
[10:29:56.416]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:56.416]                               info, version)
[10:29:56.416]                           }
[10:29:56.416]                           base::stop(msg)
[10:29:56.416]                         }
[10:29:56.416]                       })
[10:29:56.416]                     }
[10:29:56.416]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:56.416]                     base::options(mc.cores = 1L)
[10:29:56.416]                   }
[10:29:56.416]                   ...future.strategy.old <- future::plan("list")
[10:29:56.416]                   options(future.plan = NULL)
[10:29:56.416]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:56.416]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:56.416]                 }
[10:29:56.416]                 ...future.workdir <- getwd()
[10:29:56.416]             }
[10:29:56.416]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:56.416]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:56.416]         }
[10:29:56.416]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:56.416]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:56.416]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:56.416]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:56.416]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:56.416]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:56.416]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:56.416]             base::names(...future.oldOptions))
[10:29:56.416]     }
[10:29:56.416]     if (FALSE) {
[10:29:56.416]     }
[10:29:56.416]     else {
[10:29:56.416]         if (TRUE) {
[10:29:56.416]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:56.416]                 open = "w")
[10:29:56.416]         }
[10:29:56.416]         else {
[10:29:56.416]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:56.416]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:56.416]         }
[10:29:56.416]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:56.416]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:56.416]             base::sink(type = "output", split = FALSE)
[10:29:56.416]             base::close(...future.stdout)
[10:29:56.416]         }, add = TRUE)
[10:29:56.416]     }
[10:29:56.416]     ...future.frame <- base::sys.nframe()
[10:29:56.416]     ...future.conditions <- base::list()
[10:29:56.416]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:56.416]     if (FALSE) {
[10:29:56.416]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:56.416]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:56.416]     }
[10:29:56.416]     ...future.result <- base::tryCatch({
[10:29:56.416]         base::withCallingHandlers({
[10:29:56.416]             ...future.value <- base::withVisible(base::local({
[10:29:56.416]                 ...future.makeSendCondition <- base::local({
[10:29:56.416]                   sendCondition <- NULL
[10:29:56.416]                   function(frame = 1L) {
[10:29:56.416]                     if (is.function(sendCondition)) 
[10:29:56.416]                       return(sendCondition)
[10:29:56.416]                     ns <- getNamespace("parallel")
[10:29:56.416]                     if (exists("sendData", mode = "function", 
[10:29:56.416]                       envir = ns)) {
[10:29:56.416]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:56.416]                         envir = ns)
[10:29:56.416]                       envir <- sys.frame(frame)
[10:29:56.416]                       master <- NULL
[10:29:56.416]                       while (!identical(envir, .GlobalEnv) && 
[10:29:56.416]                         !identical(envir, emptyenv())) {
[10:29:56.416]                         if (exists("master", mode = "list", envir = envir, 
[10:29:56.416]                           inherits = FALSE)) {
[10:29:56.416]                           master <- get("master", mode = "list", 
[10:29:56.416]                             envir = envir, inherits = FALSE)
[10:29:56.416]                           if (inherits(master, c("SOCKnode", 
[10:29:56.416]                             "SOCK0node"))) {
[10:29:56.416]                             sendCondition <<- function(cond) {
[10:29:56.416]                               data <- list(type = "VALUE", value = cond, 
[10:29:56.416]                                 success = TRUE)
[10:29:56.416]                               parallel_sendData(master, data)
[10:29:56.416]                             }
[10:29:56.416]                             return(sendCondition)
[10:29:56.416]                           }
[10:29:56.416]                         }
[10:29:56.416]                         frame <- frame + 1L
[10:29:56.416]                         envir <- sys.frame(frame)
[10:29:56.416]                       }
[10:29:56.416]                     }
[10:29:56.416]                     sendCondition <<- function(cond) NULL
[10:29:56.416]                   }
[10:29:56.416]                 })
[10:29:56.416]                 withCallingHandlers({
[10:29:56.416]                   {
[10:29:56.416]                     do.call(function(...) {
[10:29:56.416]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.416]                       if (!identical(...future.globals.maxSize.org, 
[10:29:56.416]                         ...future.globals.maxSize)) {
[10:29:56.416]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.416]                         on.exit(options(oopts), add = TRUE)
[10:29:56.416]                       }
[10:29:56.416]                       {
[10:29:56.416]                         lapply(seq_along(...future.elements_ii), 
[10:29:56.416]                           FUN = function(jj) {
[10:29:56.416]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.416]                             ...future.FUN(...future.X_jj, ...)
[10:29:56.416]                           })
[10:29:56.416]                       }
[10:29:56.416]                     }, args = future.call.arguments)
[10:29:56.416]                   }
[10:29:56.416]                 }, immediateCondition = function(cond) {
[10:29:56.416]                   sendCondition <- ...future.makeSendCondition()
[10:29:56.416]                   sendCondition(cond)
[10:29:56.416]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.416]                   {
[10:29:56.416]                     inherits <- base::inherits
[10:29:56.416]                     invokeRestart <- base::invokeRestart
[10:29:56.416]                     is.null <- base::is.null
[10:29:56.416]                     muffled <- FALSE
[10:29:56.416]                     if (inherits(cond, "message")) {
[10:29:56.416]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:56.416]                       if (muffled) 
[10:29:56.416]                         invokeRestart("muffleMessage")
[10:29:56.416]                     }
[10:29:56.416]                     else if (inherits(cond, "warning")) {
[10:29:56.416]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:56.416]                       if (muffled) 
[10:29:56.416]                         invokeRestart("muffleWarning")
[10:29:56.416]                     }
[10:29:56.416]                     else if (inherits(cond, "condition")) {
[10:29:56.416]                       if (!is.null(pattern)) {
[10:29:56.416]                         computeRestarts <- base::computeRestarts
[10:29:56.416]                         grepl <- base::grepl
[10:29:56.416]                         restarts <- computeRestarts(cond)
[10:29:56.416]                         for (restart in restarts) {
[10:29:56.416]                           name <- restart$name
[10:29:56.416]                           if (is.null(name)) 
[10:29:56.416]                             next
[10:29:56.416]                           if (!grepl(pattern, name)) 
[10:29:56.416]                             next
[10:29:56.416]                           invokeRestart(restart)
[10:29:56.416]                           muffled <- TRUE
[10:29:56.416]                           break
[10:29:56.416]                         }
[10:29:56.416]                       }
[10:29:56.416]                     }
[10:29:56.416]                     invisible(muffled)
[10:29:56.416]                   }
[10:29:56.416]                   muffleCondition(cond)
[10:29:56.416]                 })
[10:29:56.416]             }))
[10:29:56.416]             future::FutureResult(value = ...future.value$value, 
[10:29:56.416]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:56.416]                   ...future.rng), globalenv = if (FALSE) 
[10:29:56.416]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:56.416]                     ...future.globalenv.names))
[10:29:56.416]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:56.416]         }, condition = base::local({
[10:29:56.416]             c <- base::c
[10:29:56.416]             inherits <- base::inherits
[10:29:56.416]             invokeRestart <- base::invokeRestart
[10:29:56.416]             length <- base::length
[10:29:56.416]             list <- base::list
[10:29:56.416]             seq.int <- base::seq.int
[10:29:56.416]             signalCondition <- base::signalCondition
[10:29:56.416]             sys.calls <- base::sys.calls
[10:29:56.416]             `[[` <- base::`[[`
[10:29:56.416]             `+` <- base::`+`
[10:29:56.416]             `<<-` <- base::`<<-`
[10:29:56.416]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:56.416]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:56.416]                   3L)]
[10:29:56.416]             }
[10:29:56.416]             function(cond) {
[10:29:56.416]                 is_error <- inherits(cond, "error")
[10:29:56.416]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:56.416]                   NULL)
[10:29:56.416]                 if (is_error) {
[10:29:56.416]                   sessionInformation <- function() {
[10:29:56.416]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:56.416]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:56.416]                       search = base::search(), system = base::Sys.info())
[10:29:56.416]                   }
[10:29:56.416]                   ...future.conditions[[length(...future.conditions) + 
[10:29:56.416]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:56.416]                     cond$call), session = sessionInformation(), 
[10:29:56.416]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:56.416]                   signalCondition(cond)
[10:29:56.416]                 }
[10:29:56.416]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:56.416]                 "immediateCondition"))) {
[10:29:56.416]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:56.416]                   ...future.conditions[[length(...future.conditions) + 
[10:29:56.416]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:56.416]                   if (TRUE && !signal) {
[10:29:56.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.416]                     {
[10:29:56.416]                       inherits <- base::inherits
[10:29:56.416]                       invokeRestart <- base::invokeRestart
[10:29:56.416]                       is.null <- base::is.null
[10:29:56.416]                       muffled <- FALSE
[10:29:56.416]                       if (inherits(cond, "message")) {
[10:29:56.416]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:56.416]                         if (muffled) 
[10:29:56.416]                           invokeRestart("muffleMessage")
[10:29:56.416]                       }
[10:29:56.416]                       else if (inherits(cond, "warning")) {
[10:29:56.416]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:56.416]                         if (muffled) 
[10:29:56.416]                           invokeRestart("muffleWarning")
[10:29:56.416]                       }
[10:29:56.416]                       else if (inherits(cond, "condition")) {
[10:29:56.416]                         if (!is.null(pattern)) {
[10:29:56.416]                           computeRestarts <- base::computeRestarts
[10:29:56.416]                           grepl <- base::grepl
[10:29:56.416]                           restarts <- computeRestarts(cond)
[10:29:56.416]                           for (restart in restarts) {
[10:29:56.416]                             name <- restart$name
[10:29:56.416]                             if (is.null(name)) 
[10:29:56.416]                               next
[10:29:56.416]                             if (!grepl(pattern, name)) 
[10:29:56.416]                               next
[10:29:56.416]                             invokeRestart(restart)
[10:29:56.416]                             muffled <- TRUE
[10:29:56.416]                             break
[10:29:56.416]                           }
[10:29:56.416]                         }
[10:29:56.416]                       }
[10:29:56.416]                       invisible(muffled)
[10:29:56.416]                     }
[10:29:56.416]                     muffleCondition(cond, pattern = "^muffle")
[10:29:56.416]                   }
[10:29:56.416]                 }
[10:29:56.416]                 else {
[10:29:56.416]                   if (TRUE) {
[10:29:56.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.416]                     {
[10:29:56.416]                       inherits <- base::inherits
[10:29:56.416]                       invokeRestart <- base::invokeRestart
[10:29:56.416]                       is.null <- base::is.null
[10:29:56.416]                       muffled <- FALSE
[10:29:56.416]                       if (inherits(cond, "message")) {
[10:29:56.416]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:56.416]                         if (muffled) 
[10:29:56.416]                           invokeRestart("muffleMessage")
[10:29:56.416]                       }
[10:29:56.416]                       else if (inherits(cond, "warning")) {
[10:29:56.416]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:56.416]                         if (muffled) 
[10:29:56.416]                           invokeRestart("muffleWarning")
[10:29:56.416]                       }
[10:29:56.416]                       else if (inherits(cond, "condition")) {
[10:29:56.416]                         if (!is.null(pattern)) {
[10:29:56.416]                           computeRestarts <- base::computeRestarts
[10:29:56.416]                           grepl <- base::grepl
[10:29:56.416]                           restarts <- computeRestarts(cond)
[10:29:56.416]                           for (restart in restarts) {
[10:29:56.416]                             name <- restart$name
[10:29:56.416]                             if (is.null(name)) 
[10:29:56.416]                               next
[10:29:56.416]                             if (!grepl(pattern, name)) 
[10:29:56.416]                               next
[10:29:56.416]                             invokeRestart(restart)
[10:29:56.416]                             muffled <- TRUE
[10:29:56.416]                             break
[10:29:56.416]                           }
[10:29:56.416]                         }
[10:29:56.416]                       }
[10:29:56.416]                       invisible(muffled)
[10:29:56.416]                     }
[10:29:56.416]                     muffleCondition(cond, pattern = "^muffle")
[10:29:56.416]                   }
[10:29:56.416]                 }
[10:29:56.416]             }
[10:29:56.416]         }))
[10:29:56.416]     }, error = function(ex) {
[10:29:56.416]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:56.416]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:56.416]                 ...future.rng), started = ...future.startTime, 
[10:29:56.416]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:56.416]             version = "1.8"), class = "FutureResult")
[10:29:56.416]     }, finally = {
[10:29:56.416]         if (!identical(...future.workdir, getwd())) 
[10:29:56.416]             setwd(...future.workdir)
[10:29:56.416]         {
[10:29:56.416]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:56.416]                 ...future.oldOptions$nwarnings <- NULL
[10:29:56.416]             }
[10:29:56.416]             base::options(...future.oldOptions)
[10:29:56.416]             if (.Platform$OS.type == "windows") {
[10:29:56.416]                 old_names <- names(...future.oldEnvVars)
[10:29:56.416]                 envs <- base::Sys.getenv()
[10:29:56.416]                 names <- names(envs)
[10:29:56.416]                 common <- intersect(names, old_names)
[10:29:56.416]                 added <- setdiff(names, old_names)
[10:29:56.416]                 removed <- setdiff(old_names, names)
[10:29:56.416]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:56.416]                   envs[common]]
[10:29:56.416]                 NAMES <- toupper(changed)
[10:29:56.416]                 args <- list()
[10:29:56.416]                 for (kk in seq_along(NAMES)) {
[10:29:56.416]                   name <- changed[[kk]]
[10:29:56.416]                   NAME <- NAMES[[kk]]
[10:29:56.416]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.416]                     next
[10:29:56.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:56.416]                 }
[10:29:56.416]                 NAMES <- toupper(added)
[10:29:56.416]                 for (kk in seq_along(NAMES)) {
[10:29:56.416]                   name <- added[[kk]]
[10:29:56.416]                   NAME <- NAMES[[kk]]
[10:29:56.416]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.416]                     next
[10:29:56.416]                   args[[name]] <- ""
[10:29:56.416]                 }
[10:29:56.416]                 NAMES <- toupper(removed)
[10:29:56.416]                 for (kk in seq_along(NAMES)) {
[10:29:56.416]                   name <- removed[[kk]]
[10:29:56.416]                   NAME <- NAMES[[kk]]
[10:29:56.416]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.416]                     next
[10:29:56.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:56.416]                 }
[10:29:56.416]                 if (length(args) > 0) 
[10:29:56.416]                   base::do.call(base::Sys.setenv, args = args)
[10:29:56.416]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:56.416]             }
[10:29:56.416]             else {
[10:29:56.416]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:56.416]             }
[10:29:56.416]             {
[10:29:56.416]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:56.416]                   0L) {
[10:29:56.416]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:56.416]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:56.416]                   base::options(opts)
[10:29:56.416]                 }
[10:29:56.416]                 {
[10:29:56.416]                   {
[10:29:56.416]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:56.416]                     NULL
[10:29:56.416]                   }
[10:29:56.416]                   options(future.plan = NULL)
[10:29:56.416]                   if (is.na(NA_character_)) 
[10:29:56.416]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:56.416]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:56.416]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:56.416]                     .init = FALSE)
[10:29:56.416]                 }
[10:29:56.416]             }
[10:29:56.416]         }
[10:29:56.416]     })
[10:29:56.416]     if (TRUE) {
[10:29:56.416]         base::sink(type = "output", split = FALSE)
[10:29:56.416]         if (TRUE) {
[10:29:56.416]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:56.416]         }
[10:29:56.416]         else {
[10:29:56.416]             ...future.result["stdout"] <- base::list(NULL)
[10:29:56.416]         }
[10:29:56.416]         base::close(...future.stdout)
[10:29:56.416]         ...future.stdout <- NULL
[10:29:56.416]     }
[10:29:56.416]     ...future.result$conditions <- ...future.conditions
[10:29:56.416]     ...future.result$finished <- base::Sys.time()
[10:29:56.416]     ...future.result
[10:29:56.416] }
[10:29:56.419] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[10:29:56.419] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[10:29:56.419] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[10:29:56.420] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:29:56.420] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:29:56.420] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[10:29:56.420] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[10:29:56.420] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:29:56.421] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:29:56.421] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:29:56.421] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:29:56.421] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[10:29:56.422] MultisessionFuture started
[10:29:56.422] - Launch lazy future ... done
[10:29:56.422] run() for ‘MultisessionFuture’ ... done
[10:29:56.422] Created future:
[10:29:56.422] MultisessionFuture:
[10:29:56.422] Label: ‘future_by-1’
[10:29:56.422] Expression:
[10:29:56.422] {
[10:29:56.422]     do.call(function(...) {
[10:29:56.422]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.422]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:56.422]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.422]             on.exit(options(oopts), add = TRUE)
[10:29:56.422]         }
[10:29:56.422]         {
[10:29:56.422]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:56.422]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.422]                 ...future.FUN(...future.X_jj, ...)
[10:29:56.422]             })
[10:29:56.422]         }
[10:29:56.422]     }, args = future.call.arguments)
[10:29:56.422] }
[10:29:56.422] Lazy evaluation: FALSE
[10:29:56.422] Asynchronous evaluation: TRUE
[10:29:56.422] Local evaluation: TRUE
[10:29:56.422] Environment: 0x556dd664a798
[10:29:56.422] Capture standard output: TRUE
[10:29:56.422] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:56.422] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:56.422] Packages: <none>
[10:29:56.422] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:56.422] Resolved: FALSE
[10:29:56.422] Value: <not collected>
[10:29:56.422] Conditions captured: <none>
[10:29:56.422] Early signaling: FALSE
[10:29:56.422] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:56.422] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:56.434] Chunk #1 of 2 ... DONE
[10:29:56.434] Chunk #2 of 2 ...
[10:29:56.434]  - Finding globals in 'X' for chunk #2 ...
[10:29:56.434] getGlobalsAndPackages() ...
[10:29:56.434] Searching for globals...
[10:29:56.435] 
[10:29:56.435] Searching for globals ... DONE
[10:29:56.435] - globals: [0] <none>
[10:29:56.435] getGlobalsAndPackages() ... DONE
[10:29:56.435]    + additional globals found: [n=0] 
[10:29:56.435]    + additional namespaces needed: [n=0] 
[10:29:56.436]  - Finding globals in 'X' for chunk #2 ... DONE
[10:29:56.436]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:56.436]  - seeds: <none>
[10:29:56.436]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.436] getGlobalsAndPackages() ...
[10:29:56.436] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.436] Resolving globals: FALSE
[10:29:56.436] Tweak future expression to call with '...' arguments ...
[10:29:56.436] {
[10:29:56.436]     do.call(function(...) {
[10:29:56.436]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.436]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:56.436]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.436]             on.exit(options(oopts), add = TRUE)
[10:29:56.436]         }
[10:29:56.436]         {
[10:29:56.436]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:56.436]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.436]                 ...future.FUN(...future.X_jj, ...)
[10:29:56.436]             })
[10:29:56.436]         }
[10:29:56.436]     }, args = future.call.arguments)
[10:29:56.436] }
[10:29:56.437] Tweak future expression to call with '...' arguments ... DONE
[10:29:56.437] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.437] 
[10:29:56.437] getGlobalsAndPackages() ... DONE
[10:29:56.438] run() for ‘Future’ ...
[10:29:56.438] - state: ‘created’
[10:29:56.438] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:56.453] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:56.453] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:56.453]   - Field: ‘node’
[10:29:56.453]   - Field: ‘label’
[10:29:56.453]   - Field: ‘local’
[10:29:56.453]   - Field: ‘owner’
[10:29:56.454]   - Field: ‘envir’
[10:29:56.454]   - Field: ‘workers’
[10:29:56.454]   - Field: ‘packages’
[10:29:56.454]   - Field: ‘gc’
[10:29:56.454]   - Field: ‘conditions’
[10:29:56.454]   - Field: ‘persistent’
[10:29:56.454]   - Field: ‘expr’
[10:29:56.454]   - Field: ‘uuid’
[10:29:56.454]   - Field: ‘seed’
[10:29:56.454]   - Field: ‘version’
[10:29:56.455]   - Field: ‘result’
[10:29:56.455]   - Field: ‘asynchronous’
[10:29:56.455]   - Field: ‘calls’
[10:29:56.455]   - Field: ‘globals’
[10:29:56.455]   - Field: ‘stdout’
[10:29:56.455]   - Field: ‘earlySignal’
[10:29:56.455]   - Field: ‘lazy’
[10:29:56.455]   - Field: ‘state’
[10:29:56.455] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:56.455] - Launch lazy future ...
[10:29:56.456] Packages needed by the future expression (n = 0): <none>
[10:29:56.456] Packages needed by future strategies (n = 0): <none>
[10:29:56.456] {
[10:29:56.456]     {
[10:29:56.456]         {
[10:29:56.456]             ...future.startTime <- base::Sys.time()
[10:29:56.456]             {
[10:29:56.456]                 {
[10:29:56.456]                   {
[10:29:56.456]                     {
[10:29:56.456]                       base::local({
[10:29:56.456]                         has_future <- base::requireNamespace("future", 
[10:29:56.456]                           quietly = TRUE)
[10:29:56.456]                         if (has_future) {
[10:29:56.456]                           ns <- base::getNamespace("future")
[10:29:56.456]                           version <- ns[[".package"]][["version"]]
[10:29:56.456]                           if (is.null(version)) 
[10:29:56.456]                             version <- utils::packageVersion("future")
[10:29:56.456]                         }
[10:29:56.456]                         else {
[10:29:56.456]                           version <- NULL
[10:29:56.456]                         }
[10:29:56.456]                         if (!has_future || version < "1.8.0") {
[10:29:56.456]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:56.456]                             "", base::R.version$version.string), 
[10:29:56.456]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:56.456]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:56.456]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:56.456]                               "release", "version")], collapse = " "), 
[10:29:56.456]                             hostname = base::Sys.info()[["nodename"]])
[10:29:56.456]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:56.456]                             info)
[10:29:56.456]                           info <- base::paste(info, collapse = "; ")
[10:29:56.456]                           if (!has_future) {
[10:29:56.456]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:56.456]                               info)
[10:29:56.456]                           }
[10:29:56.456]                           else {
[10:29:56.456]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:56.456]                               info, version)
[10:29:56.456]                           }
[10:29:56.456]                           base::stop(msg)
[10:29:56.456]                         }
[10:29:56.456]                       })
[10:29:56.456]                     }
[10:29:56.456]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:56.456]                     base::options(mc.cores = 1L)
[10:29:56.456]                   }
[10:29:56.456]                   ...future.strategy.old <- future::plan("list")
[10:29:56.456]                   options(future.plan = NULL)
[10:29:56.456]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:56.456]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:56.456]                 }
[10:29:56.456]                 ...future.workdir <- getwd()
[10:29:56.456]             }
[10:29:56.456]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:56.456]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:56.456]         }
[10:29:56.456]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:56.456]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:56.456]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:56.456]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:56.456]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:56.456]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:56.456]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:56.456]             base::names(...future.oldOptions))
[10:29:56.456]     }
[10:29:56.456]     if (FALSE) {
[10:29:56.456]     }
[10:29:56.456]     else {
[10:29:56.456]         if (TRUE) {
[10:29:56.456]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:56.456]                 open = "w")
[10:29:56.456]         }
[10:29:56.456]         else {
[10:29:56.456]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:56.456]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:56.456]         }
[10:29:56.456]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:56.456]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:56.456]             base::sink(type = "output", split = FALSE)
[10:29:56.456]             base::close(...future.stdout)
[10:29:56.456]         }, add = TRUE)
[10:29:56.456]     }
[10:29:56.456]     ...future.frame <- base::sys.nframe()
[10:29:56.456]     ...future.conditions <- base::list()
[10:29:56.456]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:56.456]     if (FALSE) {
[10:29:56.456]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:56.456]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:56.456]     }
[10:29:56.456]     ...future.result <- base::tryCatch({
[10:29:56.456]         base::withCallingHandlers({
[10:29:56.456]             ...future.value <- base::withVisible(base::local({
[10:29:56.456]                 ...future.makeSendCondition <- base::local({
[10:29:56.456]                   sendCondition <- NULL
[10:29:56.456]                   function(frame = 1L) {
[10:29:56.456]                     if (is.function(sendCondition)) 
[10:29:56.456]                       return(sendCondition)
[10:29:56.456]                     ns <- getNamespace("parallel")
[10:29:56.456]                     if (exists("sendData", mode = "function", 
[10:29:56.456]                       envir = ns)) {
[10:29:56.456]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:56.456]                         envir = ns)
[10:29:56.456]                       envir <- sys.frame(frame)
[10:29:56.456]                       master <- NULL
[10:29:56.456]                       while (!identical(envir, .GlobalEnv) && 
[10:29:56.456]                         !identical(envir, emptyenv())) {
[10:29:56.456]                         if (exists("master", mode = "list", envir = envir, 
[10:29:56.456]                           inherits = FALSE)) {
[10:29:56.456]                           master <- get("master", mode = "list", 
[10:29:56.456]                             envir = envir, inherits = FALSE)
[10:29:56.456]                           if (inherits(master, c("SOCKnode", 
[10:29:56.456]                             "SOCK0node"))) {
[10:29:56.456]                             sendCondition <<- function(cond) {
[10:29:56.456]                               data <- list(type = "VALUE", value = cond, 
[10:29:56.456]                                 success = TRUE)
[10:29:56.456]                               parallel_sendData(master, data)
[10:29:56.456]                             }
[10:29:56.456]                             return(sendCondition)
[10:29:56.456]                           }
[10:29:56.456]                         }
[10:29:56.456]                         frame <- frame + 1L
[10:29:56.456]                         envir <- sys.frame(frame)
[10:29:56.456]                       }
[10:29:56.456]                     }
[10:29:56.456]                     sendCondition <<- function(cond) NULL
[10:29:56.456]                   }
[10:29:56.456]                 })
[10:29:56.456]                 withCallingHandlers({
[10:29:56.456]                   {
[10:29:56.456]                     do.call(function(...) {
[10:29:56.456]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.456]                       if (!identical(...future.globals.maxSize.org, 
[10:29:56.456]                         ...future.globals.maxSize)) {
[10:29:56.456]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.456]                         on.exit(options(oopts), add = TRUE)
[10:29:56.456]                       }
[10:29:56.456]                       {
[10:29:56.456]                         lapply(seq_along(...future.elements_ii), 
[10:29:56.456]                           FUN = function(jj) {
[10:29:56.456]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.456]                             ...future.FUN(...future.X_jj, ...)
[10:29:56.456]                           })
[10:29:56.456]                       }
[10:29:56.456]                     }, args = future.call.arguments)
[10:29:56.456]                   }
[10:29:56.456]                 }, immediateCondition = function(cond) {
[10:29:56.456]                   sendCondition <- ...future.makeSendCondition()
[10:29:56.456]                   sendCondition(cond)
[10:29:56.456]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.456]                   {
[10:29:56.456]                     inherits <- base::inherits
[10:29:56.456]                     invokeRestart <- base::invokeRestart
[10:29:56.456]                     is.null <- base::is.null
[10:29:56.456]                     muffled <- FALSE
[10:29:56.456]                     if (inherits(cond, "message")) {
[10:29:56.456]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:56.456]                       if (muffled) 
[10:29:56.456]                         invokeRestart("muffleMessage")
[10:29:56.456]                     }
[10:29:56.456]                     else if (inherits(cond, "warning")) {
[10:29:56.456]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:56.456]                       if (muffled) 
[10:29:56.456]                         invokeRestart("muffleWarning")
[10:29:56.456]                     }
[10:29:56.456]                     else if (inherits(cond, "condition")) {
[10:29:56.456]                       if (!is.null(pattern)) {
[10:29:56.456]                         computeRestarts <- base::computeRestarts
[10:29:56.456]                         grepl <- base::grepl
[10:29:56.456]                         restarts <- computeRestarts(cond)
[10:29:56.456]                         for (restart in restarts) {
[10:29:56.456]                           name <- restart$name
[10:29:56.456]                           if (is.null(name)) 
[10:29:56.456]                             next
[10:29:56.456]                           if (!grepl(pattern, name)) 
[10:29:56.456]                             next
[10:29:56.456]                           invokeRestart(restart)
[10:29:56.456]                           muffled <- TRUE
[10:29:56.456]                           break
[10:29:56.456]                         }
[10:29:56.456]                       }
[10:29:56.456]                     }
[10:29:56.456]                     invisible(muffled)
[10:29:56.456]                   }
[10:29:56.456]                   muffleCondition(cond)
[10:29:56.456]                 })
[10:29:56.456]             }))
[10:29:56.456]             future::FutureResult(value = ...future.value$value, 
[10:29:56.456]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:56.456]                   ...future.rng), globalenv = if (FALSE) 
[10:29:56.456]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:56.456]                     ...future.globalenv.names))
[10:29:56.456]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:56.456]         }, condition = base::local({
[10:29:56.456]             c <- base::c
[10:29:56.456]             inherits <- base::inherits
[10:29:56.456]             invokeRestart <- base::invokeRestart
[10:29:56.456]             length <- base::length
[10:29:56.456]             list <- base::list
[10:29:56.456]             seq.int <- base::seq.int
[10:29:56.456]             signalCondition <- base::signalCondition
[10:29:56.456]             sys.calls <- base::sys.calls
[10:29:56.456]             `[[` <- base::`[[`
[10:29:56.456]             `+` <- base::`+`
[10:29:56.456]             `<<-` <- base::`<<-`
[10:29:56.456]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:56.456]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:56.456]                   3L)]
[10:29:56.456]             }
[10:29:56.456]             function(cond) {
[10:29:56.456]                 is_error <- inherits(cond, "error")
[10:29:56.456]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:56.456]                   NULL)
[10:29:56.456]                 if (is_error) {
[10:29:56.456]                   sessionInformation <- function() {
[10:29:56.456]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:56.456]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:56.456]                       search = base::search(), system = base::Sys.info())
[10:29:56.456]                   }
[10:29:56.456]                   ...future.conditions[[length(...future.conditions) + 
[10:29:56.456]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:56.456]                     cond$call), session = sessionInformation(), 
[10:29:56.456]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:56.456]                   signalCondition(cond)
[10:29:56.456]                 }
[10:29:56.456]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:56.456]                 "immediateCondition"))) {
[10:29:56.456]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:56.456]                   ...future.conditions[[length(...future.conditions) + 
[10:29:56.456]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:56.456]                   if (TRUE && !signal) {
[10:29:56.456]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.456]                     {
[10:29:56.456]                       inherits <- base::inherits
[10:29:56.456]                       invokeRestart <- base::invokeRestart
[10:29:56.456]                       is.null <- base::is.null
[10:29:56.456]                       muffled <- FALSE
[10:29:56.456]                       if (inherits(cond, "message")) {
[10:29:56.456]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:56.456]                         if (muffled) 
[10:29:56.456]                           invokeRestart("muffleMessage")
[10:29:56.456]                       }
[10:29:56.456]                       else if (inherits(cond, "warning")) {
[10:29:56.456]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:56.456]                         if (muffled) 
[10:29:56.456]                           invokeRestart("muffleWarning")
[10:29:56.456]                       }
[10:29:56.456]                       else if (inherits(cond, "condition")) {
[10:29:56.456]                         if (!is.null(pattern)) {
[10:29:56.456]                           computeRestarts <- base::computeRestarts
[10:29:56.456]                           grepl <- base::grepl
[10:29:56.456]                           restarts <- computeRestarts(cond)
[10:29:56.456]                           for (restart in restarts) {
[10:29:56.456]                             name <- restart$name
[10:29:56.456]                             if (is.null(name)) 
[10:29:56.456]                               next
[10:29:56.456]                             if (!grepl(pattern, name)) 
[10:29:56.456]                               next
[10:29:56.456]                             invokeRestart(restart)
[10:29:56.456]                             muffled <- TRUE
[10:29:56.456]                             break
[10:29:56.456]                           }
[10:29:56.456]                         }
[10:29:56.456]                       }
[10:29:56.456]                       invisible(muffled)
[10:29:56.456]                     }
[10:29:56.456]                     muffleCondition(cond, pattern = "^muffle")
[10:29:56.456]                   }
[10:29:56.456]                 }
[10:29:56.456]                 else {
[10:29:56.456]                   if (TRUE) {
[10:29:56.456]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.456]                     {
[10:29:56.456]                       inherits <- base::inherits
[10:29:56.456]                       invokeRestart <- base::invokeRestart
[10:29:56.456]                       is.null <- base::is.null
[10:29:56.456]                       muffled <- FALSE
[10:29:56.456]                       if (inherits(cond, "message")) {
[10:29:56.456]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:56.456]                         if (muffled) 
[10:29:56.456]                           invokeRestart("muffleMessage")
[10:29:56.456]                       }
[10:29:56.456]                       else if (inherits(cond, "warning")) {
[10:29:56.456]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:56.456]                         if (muffled) 
[10:29:56.456]                           invokeRestart("muffleWarning")
[10:29:56.456]                       }
[10:29:56.456]                       else if (inherits(cond, "condition")) {
[10:29:56.456]                         if (!is.null(pattern)) {
[10:29:56.456]                           computeRestarts <- base::computeRestarts
[10:29:56.456]                           grepl <- base::grepl
[10:29:56.456]                           restarts <- computeRestarts(cond)
[10:29:56.456]                           for (restart in restarts) {
[10:29:56.456]                             name <- restart$name
[10:29:56.456]                             if (is.null(name)) 
[10:29:56.456]                               next
[10:29:56.456]                             if (!grepl(pattern, name)) 
[10:29:56.456]                               next
[10:29:56.456]                             invokeRestart(restart)
[10:29:56.456]                             muffled <- TRUE
[10:29:56.456]                             break
[10:29:56.456]                           }
[10:29:56.456]                         }
[10:29:56.456]                       }
[10:29:56.456]                       invisible(muffled)
[10:29:56.456]                     }
[10:29:56.456]                     muffleCondition(cond, pattern = "^muffle")
[10:29:56.456]                   }
[10:29:56.456]                 }
[10:29:56.456]             }
[10:29:56.456]         }))
[10:29:56.456]     }, error = function(ex) {
[10:29:56.456]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:56.456]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:56.456]                 ...future.rng), started = ...future.startTime, 
[10:29:56.456]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:56.456]             version = "1.8"), class = "FutureResult")
[10:29:56.456]     }, finally = {
[10:29:56.456]         if (!identical(...future.workdir, getwd())) 
[10:29:56.456]             setwd(...future.workdir)
[10:29:56.456]         {
[10:29:56.456]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:56.456]                 ...future.oldOptions$nwarnings <- NULL
[10:29:56.456]             }
[10:29:56.456]             base::options(...future.oldOptions)
[10:29:56.456]             if (.Platform$OS.type == "windows") {
[10:29:56.456]                 old_names <- names(...future.oldEnvVars)
[10:29:56.456]                 envs <- base::Sys.getenv()
[10:29:56.456]                 names <- names(envs)
[10:29:56.456]                 common <- intersect(names, old_names)
[10:29:56.456]                 added <- setdiff(names, old_names)
[10:29:56.456]                 removed <- setdiff(old_names, names)
[10:29:56.456]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:56.456]                   envs[common]]
[10:29:56.456]                 NAMES <- toupper(changed)
[10:29:56.456]                 args <- list()
[10:29:56.456]                 for (kk in seq_along(NAMES)) {
[10:29:56.456]                   name <- changed[[kk]]
[10:29:56.456]                   NAME <- NAMES[[kk]]
[10:29:56.456]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.456]                     next
[10:29:56.456]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:56.456]                 }
[10:29:56.456]                 NAMES <- toupper(added)
[10:29:56.456]                 for (kk in seq_along(NAMES)) {
[10:29:56.456]                   name <- added[[kk]]
[10:29:56.456]                   NAME <- NAMES[[kk]]
[10:29:56.456]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.456]                     next
[10:29:56.456]                   args[[name]] <- ""
[10:29:56.456]                 }
[10:29:56.456]                 NAMES <- toupper(removed)
[10:29:56.456]                 for (kk in seq_along(NAMES)) {
[10:29:56.456]                   name <- removed[[kk]]
[10:29:56.456]                   NAME <- NAMES[[kk]]
[10:29:56.456]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.456]                     next
[10:29:56.456]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:56.456]                 }
[10:29:56.456]                 if (length(args) > 0) 
[10:29:56.456]                   base::do.call(base::Sys.setenv, args = args)
[10:29:56.456]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:56.456]             }
[10:29:56.456]             else {
[10:29:56.456]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:56.456]             }
[10:29:56.456]             {
[10:29:56.456]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:56.456]                   0L) {
[10:29:56.456]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:56.456]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:56.456]                   base::options(opts)
[10:29:56.456]                 }
[10:29:56.456]                 {
[10:29:56.456]                   {
[10:29:56.456]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:56.456]                     NULL
[10:29:56.456]                   }
[10:29:56.456]                   options(future.plan = NULL)
[10:29:56.456]                   if (is.na(NA_character_)) 
[10:29:56.456]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:56.456]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:56.456]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:56.456]                     .init = FALSE)
[10:29:56.456]                 }
[10:29:56.456]             }
[10:29:56.456]         }
[10:29:56.456]     })
[10:29:56.456]     if (TRUE) {
[10:29:56.456]         base::sink(type = "output", split = FALSE)
[10:29:56.456]         if (TRUE) {
[10:29:56.456]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:56.456]         }
[10:29:56.456]         else {
[10:29:56.456]             ...future.result["stdout"] <- base::list(NULL)
[10:29:56.456]         }
[10:29:56.456]         base::close(...future.stdout)
[10:29:56.456]         ...future.stdout <- NULL
[10:29:56.456]     }
[10:29:56.456]     ...future.result$conditions <- ...future.conditions
[10:29:56.456]     ...future.result$finished <- base::Sys.time()
[10:29:56.456]     ...future.result
[10:29:56.456] }
[10:29:56.459] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[10:29:56.459] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[10:29:56.460] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[10:29:56.460] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:29:56.461] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:29:56.461] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[10:29:56.461] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[10:29:56.461] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:29:56.462] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:29:56.462] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:29:56.462] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:29:56.462] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[10:29:56.463] MultisessionFuture started
[10:29:56.463] - Launch lazy future ... done
[10:29:56.463] run() for ‘MultisessionFuture’ ... done
[10:29:56.464] Created future:
[10:29:56.464] MultisessionFuture:
[10:29:56.464] Label: ‘future_by-2’
[10:29:56.464] Expression:
[10:29:56.464] {
[10:29:56.464]     do.call(function(...) {
[10:29:56.464]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.464]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:56.464]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.464]             on.exit(options(oopts), add = TRUE)
[10:29:56.464]         }
[10:29:56.464]         {
[10:29:56.464]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:56.464]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.464]                 ...future.FUN(...future.X_jj, ...)
[10:29:56.464]             })
[10:29:56.464]         }
[10:29:56.464]     }, args = future.call.arguments)
[10:29:56.464] }
[10:29:56.464] Lazy evaluation: FALSE
[10:29:56.464] Asynchronous evaluation: TRUE
[10:29:56.464] Local evaluation: TRUE
[10:29:56.464] Environment: 0x556dd664a798
[10:29:56.464] Capture standard output: TRUE
[10:29:56.464] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:56.464] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:56.464] Packages: <none>
[10:29:56.464] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:56.464] Resolved: FALSE
[10:29:56.464] Value: <not collected>
[10:29:56.464] Conditions captured: <none>
[10:29:56.464] Early signaling: FALSE
[10:29:56.464] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:56.464] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:56.475] Chunk #2 of 2 ... DONE
[10:29:56.476] Launching 2 futures (chunks) ... DONE
[10:29:56.476] Resolving 2 futures (chunks) ...
[10:29:56.476] resolve() on list ...
[10:29:56.476]  recursive: 0
[10:29:56.476]  length: 2
[10:29:56.476] 
[10:29:56.477] receiveMessageFromWorker() for ClusterFuture ...
[10:29:56.477] - Validating connection of MultisessionFuture
[10:29:56.477] - received message: FutureResult
[10:29:56.477] - Received FutureResult
[10:29:56.477] - Erased future from FutureRegistry
[10:29:56.477] result() for ClusterFuture ...
[10:29:56.477] - result already collected: FutureResult
[10:29:56.478] result() for ClusterFuture ... done
[10:29:56.478] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:56.478] Future #1
[10:29:56.478] result() for ClusterFuture ...
[10:29:56.478] - result already collected: FutureResult
[10:29:56.478] result() for ClusterFuture ... done
[10:29:56.478] result() for ClusterFuture ...
[10:29:56.478] - result already collected: FutureResult
[10:29:56.478] result() for ClusterFuture ... done
[10:29:56.478] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:29:56.478] - nx: 2
[10:29:56.479] - relay: TRUE
[10:29:56.481] - stdout: TRUE
[10:29:56.481] - signal: TRUE
[10:29:56.481] - resignal: FALSE
[10:29:56.481] - force: TRUE
[10:29:56.481] - relayed: [n=2] FALSE, FALSE
[10:29:56.481] - queued futures: [n=2] FALSE, FALSE
[10:29:56.482]  - until=1
[10:29:56.482]  - relaying element #1
[10:29:56.482] result() for ClusterFuture ...
[10:29:56.482] - result already collected: FutureResult
[10:29:56.482] result() for ClusterFuture ... done
[10:29:56.482] result() for ClusterFuture ...
[10:29:56.482] - result already collected: FutureResult
[10:29:56.482] result() for ClusterFuture ... done
[10:29:56.482] result() for ClusterFuture ...
[10:29:56.482] - result already collected: FutureResult
[10:29:56.482] result() for ClusterFuture ... done
[10:29:56.483] result() for ClusterFuture ...
[10:29:56.483] - result already collected: FutureResult
[10:29:56.483] result() for ClusterFuture ... done
[10:29:56.483] - relayed: [n=2] TRUE, FALSE
[10:29:56.483] - queued futures: [n=2] TRUE, FALSE
[10:29:56.483] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:29:56.483]  length: 1 (resolved future 1)
[10:29:56.508] receiveMessageFromWorker() for ClusterFuture ...
[10:29:56.508] - Validating connection of MultisessionFuture
[10:29:56.508] - received message: FutureResult
[10:29:56.508] - Received FutureResult
[10:29:56.508] - Erased future from FutureRegistry
[10:29:56.508] result() for ClusterFuture ...
[10:29:56.509] - result already collected: FutureResult
[10:29:56.509] result() for ClusterFuture ... done
[10:29:56.509] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:56.509] Future #2
[10:29:56.509] result() for ClusterFuture ...
[10:29:56.509] - result already collected: FutureResult
[10:29:56.509] result() for ClusterFuture ... done
[10:29:56.509] result() for ClusterFuture ...
[10:29:56.509] - result already collected: FutureResult
[10:29:56.509] result() for ClusterFuture ... done
[10:29:56.510] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:29:56.510] - nx: 2
[10:29:56.510] - relay: TRUE
[10:29:56.510] - stdout: TRUE
[10:29:56.510] - signal: TRUE
[10:29:56.510] - resignal: FALSE
[10:29:56.510] - force: TRUE
[10:29:56.510] - relayed: [n=2] TRUE, FALSE
[10:29:56.510] - queued futures: [n=2] TRUE, FALSE
[10:29:56.510]  - until=2
[10:29:56.510]  - relaying element #2
[10:29:56.510] result() for ClusterFuture ...
[10:29:56.511] - result already collected: FutureResult
[10:29:56.511] result() for ClusterFuture ... done
[10:29:56.511] result() for ClusterFuture ...
[10:29:56.511] - result already collected: FutureResult
[10:29:56.511] result() for ClusterFuture ... done
[10:29:56.511] result() for ClusterFuture ...
[10:29:56.511] - result already collected: FutureResult
[10:29:56.511] result() for ClusterFuture ... done
[10:29:56.511] result() for ClusterFuture ...
[10:29:56.511] - result already collected: FutureResult
[10:29:56.511] result() for ClusterFuture ... done
[10:29:56.511] - relayed: [n=2] TRUE, TRUE
[10:29:56.512] - queued futures: [n=2] TRUE, TRUE
[10:29:56.512] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:29:56.512]  length: 0 (resolved future 2)
[10:29:56.512] Relaying remaining futures
[10:29:56.512] signalConditionsASAP(NULL, pos=0) ...
[10:29:56.512] - nx: 2
[10:29:56.512] - relay: TRUE
[10:29:56.512] - stdout: TRUE
[10:29:56.512] - signal: TRUE
[10:29:56.512] - resignal: FALSE
[10:29:56.512] - force: TRUE
[10:29:56.512] - relayed: [n=2] TRUE, TRUE
[10:29:56.513] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:56.513] - relayed: [n=2] TRUE, TRUE
[10:29:56.513] - queued futures: [n=2] TRUE, TRUE
[10:29:56.513] signalConditionsASAP(NULL, pos=0) ... done
[10:29:56.513] resolve() on list ... DONE
[10:29:56.513] result() for ClusterFuture ...
[10:29:56.513] - result already collected: FutureResult
[10:29:56.513] result() for ClusterFuture ... done
[10:29:56.513] result() for ClusterFuture ...
[10:29:56.513] - result already collected: FutureResult
[10:29:56.513] result() for ClusterFuture ... done
[10:29:56.514] result() for ClusterFuture ...
[10:29:56.514] - result already collected: FutureResult
[10:29:56.514] result() for ClusterFuture ... done
[10:29:56.514] result() for ClusterFuture ...
[10:29:56.514] - result already collected: FutureResult
[10:29:56.514] result() for ClusterFuture ... done
[10:29:56.514]  - Number of value chunks collected: 2
[10:29:56.514] Resolving 2 futures (chunks) ... DONE
[10:29:56.514] Reducing values from 2 chunks ...
[10:29:56.514]  - Number of values collected after concatenation: 3
[10:29:56.514]  - Number of values expected: 3
[10:29:56.515] Reducing values from 2 chunks ... DONE
[10:29:56.515] future_lapply() ... DONE
[10:29:56.515] future_by_internal() ... DONE
[10:29:56.516] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[10:29:56.516] future_lapply() ...
[10:29:56.520] Number of chunks: 2
[10:29:56.520] getGlobalsAndPackagesXApply() ...
[10:29:56.521]  - future.globals: TRUE
[10:29:56.521] getGlobalsAndPackages() ...
[10:29:56.521] Searching for globals...
[10:29:56.522] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:56.522] Searching for globals ... DONE
[10:29:56.522] Resolving globals: FALSE
[10:29:56.522] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:56.523] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:56.523] - globals: [1] ‘FUN’
[10:29:56.523] 
[10:29:56.523] getGlobalsAndPackages() ... DONE
[10:29:56.523]  - globals found/used: [n=1] ‘FUN’
[10:29:56.523]  - needed namespaces: [n=0] 
[10:29:56.523] Finding globals ... DONE
[10:29:56.523]  - use_args: TRUE
[10:29:56.524]  - Getting '...' globals ...
[10:29:56.524] resolve() on list ...
[10:29:56.524]  recursive: 0
[10:29:56.524]  length: 1
[10:29:56.524]  elements: ‘...’
[10:29:56.524]  length: 0 (resolved future 1)
[10:29:56.524] resolve() on list ... DONE
[10:29:56.524]    - '...' content: [n=0] 
[10:29:56.524] List of 1
[10:29:56.524]  $ ...: list()
[10:29:56.524]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:56.524]  - attr(*, "where")=List of 1
[10:29:56.524]   ..$ ...:<environment: 0x556dd6f7f388> 
[10:29:56.524]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:56.524]  - attr(*, "resolved")= logi TRUE
[10:29:56.524]  - attr(*, "total_size")= num NA
[10:29:56.527]  - Getting '...' globals ... DONE
[10:29:56.527] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:56.527] List of 2
[10:29:56.527]  $ ...future.FUN:function (object, ...)  
[10:29:56.527]  $ ...          : list()
[10:29:56.527]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:56.527]  - attr(*, "where")=List of 2
[10:29:56.527]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:56.527]   ..$ ...          :<environment: 0x556dd6f7f388> 
[10:29:56.527]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:56.527]  - attr(*, "resolved")= logi FALSE
[10:29:56.527]  - attr(*, "total_size")= num 1240
[10:29:56.530] Packages to be attached in all futures: [n=0] 
[10:29:56.530] getGlobalsAndPackagesXApply() ... DONE
[10:29:56.530] Number of futures (= number of chunks): 2
[10:29:56.530] Launching 2 futures (chunks) ...
[10:29:56.530] Chunk #1 of 2 ...
[10:29:56.531]  - Finding globals in 'X' for chunk #1 ...
[10:29:56.531] getGlobalsAndPackages() ...
[10:29:56.531] Searching for globals...
[10:29:56.531] 
[10:29:56.531] Searching for globals ... DONE
[10:29:56.531] - globals: [0] <none>
[10:29:56.531] getGlobalsAndPackages() ... DONE
[10:29:56.531]    + additional globals found: [n=0] 
[10:29:56.532]    + additional namespaces needed: [n=0] 
[10:29:56.532]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:56.532]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:56.532]  - seeds: <none>
[10:29:56.532]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.532] getGlobalsAndPackages() ...
[10:29:56.532] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.532] Resolving globals: FALSE
[10:29:56.532] Tweak future expression to call with '...' arguments ...
[10:29:56.532] {
[10:29:56.532]     do.call(function(...) {
[10:29:56.532]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.532]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:56.532]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.532]             on.exit(options(oopts), add = TRUE)
[10:29:56.532]         }
[10:29:56.532]         {
[10:29:56.532]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:56.532]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.532]                 ...future.FUN(...future.X_jj, ...)
[10:29:56.532]             })
[10:29:56.532]         }
[10:29:56.532]     }, args = future.call.arguments)
[10:29:56.532] }
[10:29:56.533] Tweak future expression to call with '...' arguments ... DONE
[10:29:56.533] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.533] 
[10:29:56.533] getGlobalsAndPackages() ... DONE
[10:29:56.534] run() for ‘Future’ ...
[10:29:56.534] - state: ‘created’
[10:29:56.534] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:56.548] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:56.548] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:56.548]   - Field: ‘node’
[10:29:56.548]   - Field: ‘label’
[10:29:56.548]   - Field: ‘local’
[10:29:56.548]   - Field: ‘owner’
[10:29:56.548]   - Field: ‘envir’
[10:29:56.548]   - Field: ‘workers’
[10:29:56.549]   - Field: ‘packages’
[10:29:56.549]   - Field: ‘gc’
[10:29:56.549]   - Field: ‘conditions’
[10:29:56.549]   - Field: ‘persistent’
[10:29:56.549]   - Field: ‘expr’
[10:29:56.549]   - Field: ‘uuid’
[10:29:56.549]   - Field: ‘seed’
[10:29:56.549]   - Field: ‘version’
[10:29:56.549]   - Field: ‘result’
[10:29:56.550]   - Field: ‘asynchronous’
[10:29:56.550]   - Field: ‘calls’
[10:29:56.550]   - Field: ‘globals’
[10:29:56.550]   - Field: ‘stdout’
[10:29:56.550]   - Field: ‘earlySignal’
[10:29:56.550]   - Field: ‘lazy’
[10:29:56.550]   - Field: ‘state’
[10:29:56.550] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:56.550] - Launch lazy future ...
[10:29:56.551] Packages needed by the future expression (n = 0): <none>
[10:29:56.551] Packages needed by future strategies (n = 0): <none>
[10:29:56.551] {
[10:29:56.551]     {
[10:29:56.551]         {
[10:29:56.551]             ...future.startTime <- base::Sys.time()
[10:29:56.551]             {
[10:29:56.551]                 {
[10:29:56.551]                   {
[10:29:56.551]                     {
[10:29:56.551]                       base::local({
[10:29:56.551]                         has_future <- base::requireNamespace("future", 
[10:29:56.551]                           quietly = TRUE)
[10:29:56.551]                         if (has_future) {
[10:29:56.551]                           ns <- base::getNamespace("future")
[10:29:56.551]                           version <- ns[[".package"]][["version"]]
[10:29:56.551]                           if (is.null(version)) 
[10:29:56.551]                             version <- utils::packageVersion("future")
[10:29:56.551]                         }
[10:29:56.551]                         else {
[10:29:56.551]                           version <- NULL
[10:29:56.551]                         }
[10:29:56.551]                         if (!has_future || version < "1.8.0") {
[10:29:56.551]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:56.551]                             "", base::R.version$version.string), 
[10:29:56.551]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:56.551]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:56.551]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:56.551]                               "release", "version")], collapse = " "), 
[10:29:56.551]                             hostname = base::Sys.info()[["nodename"]])
[10:29:56.551]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:56.551]                             info)
[10:29:56.551]                           info <- base::paste(info, collapse = "; ")
[10:29:56.551]                           if (!has_future) {
[10:29:56.551]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:56.551]                               info)
[10:29:56.551]                           }
[10:29:56.551]                           else {
[10:29:56.551]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:56.551]                               info, version)
[10:29:56.551]                           }
[10:29:56.551]                           base::stop(msg)
[10:29:56.551]                         }
[10:29:56.551]                       })
[10:29:56.551]                     }
[10:29:56.551]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:56.551]                     base::options(mc.cores = 1L)
[10:29:56.551]                   }
[10:29:56.551]                   ...future.strategy.old <- future::plan("list")
[10:29:56.551]                   options(future.plan = NULL)
[10:29:56.551]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:56.551]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:56.551]                 }
[10:29:56.551]                 ...future.workdir <- getwd()
[10:29:56.551]             }
[10:29:56.551]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:56.551]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:56.551]         }
[10:29:56.551]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:56.551]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:56.551]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:56.551]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:56.551]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:56.551]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:56.551]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:56.551]             base::names(...future.oldOptions))
[10:29:56.551]     }
[10:29:56.551]     if (FALSE) {
[10:29:56.551]     }
[10:29:56.551]     else {
[10:29:56.551]         if (TRUE) {
[10:29:56.551]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:56.551]                 open = "w")
[10:29:56.551]         }
[10:29:56.551]         else {
[10:29:56.551]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:56.551]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:56.551]         }
[10:29:56.551]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:56.551]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:56.551]             base::sink(type = "output", split = FALSE)
[10:29:56.551]             base::close(...future.stdout)
[10:29:56.551]         }, add = TRUE)
[10:29:56.551]     }
[10:29:56.551]     ...future.frame <- base::sys.nframe()
[10:29:56.551]     ...future.conditions <- base::list()
[10:29:56.551]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:56.551]     if (FALSE) {
[10:29:56.551]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:56.551]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:56.551]     }
[10:29:56.551]     ...future.result <- base::tryCatch({
[10:29:56.551]         base::withCallingHandlers({
[10:29:56.551]             ...future.value <- base::withVisible(base::local({
[10:29:56.551]                 ...future.makeSendCondition <- base::local({
[10:29:56.551]                   sendCondition <- NULL
[10:29:56.551]                   function(frame = 1L) {
[10:29:56.551]                     if (is.function(sendCondition)) 
[10:29:56.551]                       return(sendCondition)
[10:29:56.551]                     ns <- getNamespace("parallel")
[10:29:56.551]                     if (exists("sendData", mode = "function", 
[10:29:56.551]                       envir = ns)) {
[10:29:56.551]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:56.551]                         envir = ns)
[10:29:56.551]                       envir <- sys.frame(frame)
[10:29:56.551]                       master <- NULL
[10:29:56.551]                       while (!identical(envir, .GlobalEnv) && 
[10:29:56.551]                         !identical(envir, emptyenv())) {
[10:29:56.551]                         if (exists("master", mode = "list", envir = envir, 
[10:29:56.551]                           inherits = FALSE)) {
[10:29:56.551]                           master <- get("master", mode = "list", 
[10:29:56.551]                             envir = envir, inherits = FALSE)
[10:29:56.551]                           if (inherits(master, c("SOCKnode", 
[10:29:56.551]                             "SOCK0node"))) {
[10:29:56.551]                             sendCondition <<- function(cond) {
[10:29:56.551]                               data <- list(type = "VALUE", value = cond, 
[10:29:56.551]                                 success = TRUE)
[10:29:56.551]                               parallel_sendData(master, data)
[10:29:56.551]                             }
[10:29:56.551]                             return(sendCondition)
[10:29:56.551]                           }
[10:29:56.551]                         }
[10:29:56.551]                         frame <- frame + 1L
[10:29:56.551]                         envir <- sys.frame(frame)
[10:29:56.551]                       }
[10:29:56.551]                     }
[10:29:56.551]                     sendCondition <<- function(cond) NULL
[10:29:56.551]                   }
[10:29:56.551]                 })
[10:29:56.551]                 withCallingHandlers({
[10:29:56.551]                   {
[10:29:56.551]                     do.call(function(...) {
[10:29:56.551]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.551]                       if (!identical(...future.globals.maxSize.org, 
[10:29:56.551]                         ...future.globals.maxSize)) {
[10:29:56.551]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.551]                         on.exit(options(oopts), add = TRUE)
[10:29:56.551]                       }
[10:29:56.551]                       {
[10:29:56.551]                         lapply(seq_along(...future.elements_ii), 
[10:29:56.551]                           FUN = function(jj) {
[10:29:56.551]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.551]                             ...future.FUN(...future.X_jj, ...)
[10:29:56.551]                           })
[10:29:56.551]                       }
[10:29:56.551]                     }, args = future.call.arguments)
[10:29:56.551]                   }
[10:29:56.551]                 }, immediateCondition = function(cond) {
[10:29:56.551]                   sendCondition <- ...future.makeSendCondition()
[10:29:56.551]                   sendCondition(cond)
[10:29:56.551]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.551]                   {
[10:29:56.551]                     inherits <- base::inherits
[10:29:56.551]                     invokeRestart <- base::invokeRestart
[10:29:56.551]                     is.null <- base::is.null
[10:29:56.551]                     muffled <- FALSE
[10:29:56.551]                     if (inherits(cond, "message")) {
[10:29:56.551]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:56.551]                       if (muffled) 
[10:29:56.551]                         invokeRestart("muffleMessage")
[10:29:56.551]                     }
[10:29:56.551]                     else if (inherits(cond, "warning")) {
[10:29:56.551]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:56.551]                       if (muffled) 
[10:29:56.551]                         invokeRestart("muffleWarning")
[10:29:56.551]                     }
[10:29:56.551]                     else if (inherits(cond, "condition")) {
[10:29:56.551]                       if (!is.null(pattern)) {
[10:29:56.551]                         computeRestarts <- base::computeRestarts
[10:29:56.551]                         grepl <- base::grepl
[10:29:56.551]                         restarts <- computeRestarts(cond)
[10:29:56.551]                         for (restart in restarts) {
[10:29:56.551]                           name <- restart$name
[10:29:56.551]                           if (is.null(name)) 
[10:29:56.551]                             next
[10:29:56.551]                           if (!grepl(pattern, name)) 
[10:29:56.551]                             next
[10:29:56.551]                           invokeRestart(restart)
[10:29:56.551]                           muffled <- TRUE
[10:29:56.551]                           break
[10:29:56.551]                         }
[10:29:56.551]                       }
[10:29:56.551]                     }
[10:29:56.551]                     invisible(muffled)
[10:29:56.551]                   }
[10:29:56.551]                   muffleCondition(cond)
[10:29:56.551]                 })
[10:29:56.551]             }))
[10:29:56.551]             future::FutureResult(value = ...future.value$value, 
[10:29:56.551]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:56.551]                   ...future.rng), globalenv = if (FALSE) 
[10:29:56.551]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:56.551]                     ...future.globalenv.names))
[10:29:56.551]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:56.551]         }, condition = base::local({
[10:29:56.551]             c <- base::c
[10:29:56.551]             inherits <- base::inherits
[10:29:56.551]             invokeRestart <- base::invokeRestart
[10:29:56.551]             length <- base::length
[10:29:56.551]             list <- base::list
[10:29:56.551]             seq.int <- base::seq.int
[10:29:56.551]             signalCondition <- base::signalCondition
[10:29:56.551]             sys.calls <- base::sys.calls
[10:29:56.551]             `[[` <- base::`[[`
[10:29:56.551]             `+` <- base::`+`
[10:29:56.551]             `<<-` <- base::`<<-`
[10:29:56.551]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:56.551]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:56.551]                   3L)]
[10:29:56.551]             }
[10:29:56.551]             function(cond) {
[10:29:56.551]                 is_error <- inherits(cond, "error")
[10:29:56.551]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:56.551]                   NULL)
[10:29:56.551]                 if (is_error) {
[10:29:56.551]                   sessionInformation <- function() {
[10:29:56.551]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:56.551]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:56.551]                       search = base::search(), system = base::Sys.info())
[10:29:56.551]                   }
[10:29:56.551]                   ...future.conditions[[length(...future.conditions) + 
[10:29:56.551]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:56.551]                     cond$call), session = sessionInformation(), 
[10:29:56.551]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:56.551]                   signalCondition(cond)
[10:29:56.551]                 }
[10:29:56.551]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:56.551]                 "immediateCondition"))) {
[10:29:56.551]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:56.551]                   ...future.conditions[[length(...future.conditions) + 
[10:29:56.551]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:56.551]                   if (TRUE && !signal) {
[10:29:56.551]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.551]                     {
[10:29:56.551]                       inherits <- base::inherits
[10:29:56.551]                       invokeRestart <- base::invokeRestart
[10:29:56.551]                       is.null <- base::is.null
[10:29:56.551]                       muffled <- FALSE
[10:29:56.551]                       if (inherits(cond, "message")) {
[10:29:56.551]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:56.551]                         if (muffled) 
[10:29:56.551]                           invokeRestart("muffleMessage")
[10:29:56.551]                       }
[10:29:56.551]                       else if (inherits(cond, "warning")) {
[10:29:56.551]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:56.551]                         if (muffled) 
[10:29:56.551]                           invokeRestart("muffleWarning")
[10:29:56.551]                       }
[10:29:56.551]                       else if (inherits(cond, "condition")) {
[10:29:56.551]                         if (!is.null(pattern)) {
[10:29:56.551]                           computeRestarts <- base::computeRestarts
[10:29:56.551]                           grepl <- base::grepl
[10:29:56.551]                           restarts <- computeRestarts(cond)
[10:29:56.551]                           for (restart in restarts) {
[10:29:56.551]                             name <- restart$name
[10:29:56.551]                             if (is.null(name)) 
[10:29:56.551]                               next
[10:29:56.551]                             if (!grepl(pattern, name)) 
[10:29:56.551]                               next
[10:29:56.551]                             invokeRestart(restart)
[10:29:56.551]                             muffled <- TRUE
[10:29:56.551]                             break
[10:29:56.551]                           }
[10:29:56.551]                         }
[10:29:56.551]                       }
[10:29:56.551]                       invisible(muffled)
[10:29:56.551]                     }
[10:29:56.551]                     muffleCondition(cond, pattern = "^muffle")
[10:29:56.551]                   }
[10:29:56.551]                 }
[10:29:56.551]                 else {
[10:29:56.551]                   if (TRUE) {
[10:29:56.551]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.551]                     {
[10:29:56.551]                       inherits <- base::inherits
[10:29:56.551]                       invokeRestart <- base::invokeRestart
[10:29:56.551]                       is.null <- base::is.null
[10:29:56.551]                       muffled <- FALSE
[10:29:56.551]                       if (inherits(cond, "message")) {
[10:29:56.551]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:56.551]                         if (muffled) 
[10:29:56.551]                           invokeRestart("muffleMessage")
[10:29:56.551]                       }
[10:29:56.551]                       else if (inherits(cond, "warning")) {
[10:29:56.551]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:56.551]                         if (muffled) 
[10:29:56.551]                           invokeRestart("muffleWarning")
[10:29:56.551]                       }
[10:29:56.551]                       else if (inherits(cond, "condition")) {
[10:29:56.551]                         if (!is.null(pattern)) {
[10:29:56.551]                           computeRestarts <- base::computeRestarts
[10:29:56.551]                           grepl <- base::grepl
[10:29:56.551]                           restarts <- computeRestarts(cond)
[10:29:56.551]                           for (restart in restarts) {
[10:29:56.551]                             name <- restart$name
[10:29:56.551]                             if (is.null(name)) 
[10:29:56.551]                               next
[10:29:56.551]                             if (!grepl(pattern, name)) 
[10:29:56.551]                               next
[10:29:56.551]                             invokeRestart(restart)
[10:29:56.551]                             muffled <- TRUE
[10:29:56.551]                             break
[10:29:56.551]                           }
[10:29:56.551]                         }
[10:29:56.551]                       }
[10:29:56.551]                       invisible(muffled)
[10:29:56.551]                     }
[10:29:56.551]                     muffleCondition(cond, pattern = "^muffle")
[10:29:56.551]                   }
[10:29:56.551]                 }
[10:29:56.551]             }
[10:29:56.551]         }))
[10:29:56.551]     }, error = function(ex) {
[10:29:56.551]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:56.551]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:56.551]                 ...future.rng), started = ...future.startTime, 
[10:29:56.551]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:56.551]             version = "1.8"), class = "FutureResult")
[10:29:56.551]     }, finally = {
[10:29:56.551]         if (!identical(...future.workdir, getwd())) 
[10:29:56.551]             setwd(...future.workdir)
[10:29:56.551]         {
[10:29:56.551]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:56.551]                 ...future.oldOptions$nwarnings <- NULL
[10:29:56.551]             }
[10:29:56.551]             base::options(...future.oldOptions)
[10:29:56.551]             if (.Platform$OS.type == "windows") {
[10:29:56.551]                 old_names <- names(...future.oldEnvVars)
[10:29:56.551]                 envs <- base::Sys.getenv()
[10:29:56.551]                 names <- names(envs)
[10:29:56.551]                 common <- intersect(names, old_names)
[10:29:56.551]                 added <- setdiff(names, old_names)
[10:29:56.551]                 removed <- setdiff(old_names, names)
[10:29:56.551]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:56.551]                   envs[common]]
[10:29:56.551]                 NAMES <- toupper(changed)
[10:29:56.551]                 args <- list()
[10:29:56.551]                 for (kk in seq_along(NAMES)) {
[10:29:56.551]                   name <- changed[[kk]]
[10:29:56.551]                   NAME <- NAMES[[kk]]
[10:29:56.551]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.551]                     next
[10:29:56.551]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:56.551]                 }
[10:29:56.551]                 NAMES <- toupper(added)
[10:29:56.551]                 for (kk in seq_along(NAMES)) {
[10:29:56.551]                   name <- added[[kk]]
[10:29:56.551]                   NAME <- NAMES[[kk]]
[10:29:56.551]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.551]                     next
[10:29:56.551]                   args[[name]] <- ""
[10:29:56.551]                 }
[10:29:56.551]                 NAMES <- toupper(removed)
[10:29:56.551]                 for (kk in seq_along(NAMES)) {
[10:29:56.551]                   name <- removed[[kk]]
[10:29:56.551]                   NAME <- NAMES[[kk]]
[10:29:56.551]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.551]                     next
[10:29:56.551]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:56.551]                 }
[10:29:56.551]                 if (length(args) > 0) 
[10:29:56.551]                   base::do.call(base::Sys.setenv, args = args)
[10:29:56.551]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:56.551]             }
[10:29:56.551]             else {
[10:29:56.551]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:56.551]             }
[10:29:56.551]             {
[10:29:56.551]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:56.551]                   0L) {
[10:29:56.551]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:56.551]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:56.551]                   base::options(opts)
[10:29:56.551]                 }
[10:29:56.551]                 {
[10:29:56.551]                   {
[10:29:56.551]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:56.551]                     NULL
[10:29:56.551]                   }
[10:29:56.551]                   options(future.plan = NULL)
[10:29:56.551]                   if (is.na(NA_character_)) 
[10:29:56.551]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:56.551]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:56.551]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:56.551]                     .init = FALSE)
[10:29:56.551]                 }
[10:29:56.551]             }
[10:29:56.551]         }
[10:29:56.551]     })
[10:29:56.551]     if (TRUE) {
[10:29:56.551]         base::sink(type = "output", split = FALSE)
[10:29:56.551]         if (TRUE) {
[10:29:56.551]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:56.551]         }
[10:29:56.551]         else {
[10:29:56.551]             ...future.result["stdout"] <- base::list(NULL)
[10:29:56.551]         }
[10:29:56.551]         base::close(...future.stdout)
[10:29:56.551]         ...future.stdout <- NULL
[10:29:56.551]     }
[10:29:56.551]     ...future.result$conditions <- ...future.conditions
[10:29:56.551]     ...future.result$finished <- base::Sys.time()
[10:29:56.551]     ...future.result
[10:29:56.551] }
[10:29:56.554] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[10:29:56.554] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[10:29:56.554] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[10:29:56.555] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:29:56.555] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:29:56.555] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[10:29:56.556] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[10:29:56.556] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:29:56.556] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:29:56.556] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:29:56.556] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:29:56.556] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[10:29:56.557] MultisessionFuture started
[10:29:56.557] - Launch lazy future ... done
[10:29:56.557] run() for ‘MultisessionFuture’ ... done
[10:29:56.557] Created future:
[10:29:56.557] MultisessionFuture:
[10:29:56.557] Label: ‘future_by-1’
[10:29:56.557] Expression:
[10:29:56.557] {
[10:29:56.557]     do.call(function(...) {
[10:29:56.557]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.557]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:56.557]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.557]             on.exit(options(oopts), add = TRUE)
[10:29:56.557]         }
[10:29:56.557]         {
[10:29:56.557]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:56.557]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.557]                 ...future.FUN(...future.X_jj, ...)
[10:29:56.557]             })
[10:29:56.557]         }
[10:29:56.557]     }, args = future.call.arguments)
[10:29:56.557] }
[10:29:56.557] Lazy evaluation: FALSE
[10:29:56.557] Asynchronous evaluation: TRUE
[10:29:56.557] Local evaluation: TRUE
[10:29:56.557] Environment: 0x556dd6fb5108
[10:29:56.557] Capture standard output: TRUE
[10:29:56.557] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:56.557] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:56.557] Packages: <none>
[10:29:56.557] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:56.557] Resolved: FALSE
[10:29:56.557] Value: <not collected>
[10:29:56.557] Conditions captured: <none>
[10:29:56.557] Early signaling: FALSE
[10:29:56.557] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:56.557] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:56.569] Chunk #1 of 2 ... DONE
[10:29:56.569] Chunk #2 of 2 ...
[10:29:56.569]  - Finding globals in 'X' for chunk #2 ...
[10:29:56.570] getGlobalsAndPackages() ...
[10:29:56.570] Searching for globals...
[10:29:56.570] 
[10:29:56.570] Searching for globals ... DONE
[10:29:56.570] - globals: [0] <none>
[10:29:56.570] getGlobalsAndPackages() ... DONE
[10:29:56.570]    + additional globals found: [n=0] 
[10:29:56.571]    + additional namespaces needed: [n=0] 
[10:29:56.571]  - Finding globals in 'X' for chunk #2 ... DONE
[10:29:56.571]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:56.571]  - seeds: <none>
[10:29:56.571]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.571] getGlobalsAndPackages() ...
[10:29:56.571] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.571] Resolving globals: FALSE
[10:29:56.571] Tweak future expression to call with '...' arguments ...
[10:29:56.572] {
[10:29:56.572]     do.call(function(...) {
[10:29:56.572]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.572]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:56.572]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.572]             on.exit(options(oopts), add = TRUE)
[10:29:56.572]         }
[10:29:56.572]         {
[10:29:56.572]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:56.572]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.572]                 ...future.FUN(...future.X_jj, ...)
[10:29:56.572]             })
[10:29:56.572]         }
[10:29:56.572]     }, args = future.call.arguments)
[10:29:56.572] }
[10:29:56.572] Tweak future expression to call with '...' arguments ... DONE
[10:29:56.572] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:56.572] 
[10:29:56.572] getGlobalsAndPackages() ... DONE
[10:29:56.573] run() for ‘Future’ ...
[10:29:56.573] - state: ‘created’
[10:29:56.573] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:56.586] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:56.587] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:56.587]   - Field: ‘node’
[10:29:56.587]   - Field: ‘label’
[10:29:56.587]   - Field: ‘local’
[10:29:56.587]   - Field: ‘owner’
[10:29:56.587]   - Field: ‘envir’
[10:29:56.587]   - Field: ‘workers’
[10:29:56.587]   - Field: ‘packages’
[10:29:56.587]   - Field: ‘gc’
[10:29:56.587]   - Field: ‘conditions’
[10:29:56.588]   - Field: ‘persistent’
[10:29:56.588]   - Field: ‘expr’
[10:29:56.588]   - Field: ‘uuid’
[10:29:56.588]   - Field: ‘seed’
[10:29:56.588]   - Field: ‘version’
[10:29:56.588]   - Field: ‘result’
[10:29:56.588]   - Field: ‘asynchronous’
[10:29:56.588]   - Field: ‘calls’
[10:29:56.588]   - Field: ‘globals’
[10:29:56.588]   - Field: ‘stdout’
[10:29:56.588]   - Field: ‘earlySignal’
[10:29:56.589]   - Field: ‘lazy’
[10:29:56.589]   - Field: ‘state’
[10:29:56.589] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:56.589] - Launch lazy future ...
[10:29:56.589] Packages needed by the future expression (n = 0): <none>
[10:29:56.589] Packages needed by future strategies (n = 0): <none>
[10:29:56.590] {
[10:29:56.590]     {
[10:29:56.590]         {
[10:29:56.590]             ...future.startTime <- base::Sys.time()
[10:29:56.590]             {
[10:29:56.590]                 {
[10:29:56.590]                   {
[10:29:56.590]                     {
[10:29:56.590]                       base::local({
[10:29:56.590]                         has_future <- base::requireNamespace("future", 
[10:29:56.590]                           quietly = TRUE)
[10:29:56.590]                         if (has_future) {
[10:29:56.590]                           ns <- base::getNamespace("future")
[10:29:56.590]                           version <- ns[[".package"]][["version"]]
[10:29:56.590]                           if (is.null(version)) 
[10:29:56.590]                             version <- utils::packageVersion("future")
[10:29:56.590]                         }
[10:29:56.590]                         else {
[10:29:56.590]                           version <- NULL
[10:29:56.590]                         }
[10:29:56.590]                         if (!has_future || version < "1.8.0") {
[10:29:56.590]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:56.590]                             "", base::R.version$version.string), 
[10:29:56.590]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:56.590]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:56.590]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:56.590]                               "release", "version")], collapse = " "), 
[10:29:56.590]                             hostname = base::Sys.info()[["nodename"]])
[10:29:56.590]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:56.590]                             info)
[10:29:56.590]                           info <- base::paste(info, collapse = "; ")
[10:29:56.590]                           if (!has_future) {
[10:29:56.590]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:56.590]                               info)
[10:29:56.590]                           }
[10:29:56.590]                           else {
[10:29:56.590]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:56.590]                               info, version)
[10:29:56.590]                           }
[10:29:56.590]                           base::stop(msg)
[10:29:56.590]                         }
[10:29:56.590]                       })
[10:29:56.590]                     }
[10:29:56.590]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:56.590]                     base::options(mc.cores = 1L)
[10:29:56.590]                   }
[10:29:56.590]                   ...future.strategy.old <- future::plan("list")
[10:29:56.590]                   options(future.plan = NULL)
[10:29:56.590]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:56.590]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:56.590]                 }
[10:29:56.590]                 ...future.workdir <- getwd()
[10:29:56.590]             }
[10:29:56.590]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:56.590]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:56.590]         }
[10:29:56.590]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:56.590]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:56.590]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:56.590]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:56.590]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:56.590]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:56.590]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:56.590]             base::names(...future.oldOptions))
[10:29:56.590]     }
[10:29:56.590]     if (FALSE) {
[10:29:56.590]     }
[10:29:56.590]     else {
[10:29:56.590]         if (TRUE) {
[10:29:56.590]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:56.590]                 open = "w")
[10:29:56.590]         }
[10:29:56.590]         else {
[10:29:56.590]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:56.590]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:56.590]         }
[10:29:56.590]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:56.590]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:56.590]             base::sink(type = "output", split = FALSE)
[10:29:56.590]             base::close(...future.stdout)
[10:29:56.590]         }, add = TRUE)
[10:29:56.590]     }
[10:29:56.590]     ...future.frame <- base::sys.nframe()
[10:29:56.590]     ...future.conditions <- base::list()
[10:29:56.590]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:56.590]     if (FALSE) {
[10:29:56.590]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:56.590]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:56.590]     }
[10:29:56.590]     ...future.result <- base::tryCatch({
[10:29:56.590]         base::withCallingHandlers({
[10:29:56.590]             ...future.value <- base::withVisible(base::local({
[10:29:56.590]                 ...future.makeSendCondition <- base::local({
[10:29:56.590]                   sendCondition <- NULL
[10:29:56.590]                   function(frame = 1L) {
[10:29:56.590]                     if (is.function(sendCondition)) 
[10:29:56.590]                       return(sendCondition)
[10:29:56.590]                     ns <- getNamespace("parallel")
[10:29:56.590]                     if (exists("sendData", mode = "function", 
[10:29:56.590]                       envir = ns)) {
[10:29:56.590]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:56.590]                         envir = ns)
[10:29:56.590]                       envir <- sys.frame(frame)
[10:29:56.590]                       master <- NULL
[10:29:56.590]                       while (!identical(envir, .GlobalEnv) && 
[10:29:56.590]                         !identical(envir, emptyenv())) {
[10:29:56.590]                         if (exists("master", mode = "list", envir = envir, 
[10:29:56.590]                           inherits = FALSE)) {
[10:29:56.590]                           master <- get("master", mode = "list", 
[10:29:56.590]                             envir = envir, inherits = FALSE)
[10:29:56.590]                           if (inherits(master, c("SOCKnode", 
[10:29:56.590]                             "SOCK0node"))) {
[10:29:56.590]                             sendCondition <<- function(cond) {
[10:29:56.590]                               data <- list(type = "VALUE", value = cond, 
[10:29:56.590]                                 success = TRUE)
[10:29:56.590]                               parallel_sendData(master, data)
[10:29:56.590]                             }
[10:29:56.590]                             return(sendCondition)
[10:29:56.590]                           }
[10:29:56.590]                         }
[10:29:56.590]                         frame <- frame + 1L
[10:29:56.590]                         envir <- sys.frame(frame)
[10:29:56.590]                       }
[10:29:56.590]                     }
[10:29:56.590]                     sendCondition <<- function(cond) NULL
[10:29:56.590]                   }
[10:29:56.590]                 })
[10:29:56.590]                 withCallingHandlers({
[10:29:56.590]                   {
[10:29:56.590]                     do.call(function(...) {
[10:29:56.590]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.590]                       if (!identical(...future.globals.maxSize.org, 
[10:29:56.590]                         ...future.globals.maxSize)) {
[10:29:56.590]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.590]                         on.exit(options(oopts), add = TRUE)
[10:29:56.590]                       }
[10:29:56.590]                       {
[10:29:56.590]                         lapply(seq_along(...future.elements_ii), 
[10:29:56.590]                           FUN = function(jj) {
[10:29:56.590]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.590]                             ...future.FUN(...future.X_jj, ...)
[10:29:56.590]                           })
[10:29:56.590]                       }
[10:29:56.590]                     }, args = future.call.arguments)
[10:29:56.590]                   }
[10:29:56.590]                 }, immediateCondition = function(cond) {
[10:29:56.590]                   sendCondition <- ...future.makeSendCondition()
[10:29:56.590]                   sendCondition(cond)
[10:29:56.590]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.590]                   {
[10:29:56.590]                     inherits <- base::inherits
[10:29:56.590]                     invokeRestart <- base::invokeRestart
[10:29:56.590]                     is.null <- base::is.null
[10:29:56.590]                     muffled <- FALSE
[10:29:56.590]                     if (inherits(cond, "message")) {
[10:29:56.590]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:56.590]                       if (muffled) 
[10:29:56.590]                         invokeRestart("muffleMessage")
[10:29:56.590]                     }
[10:29:56.590]                     else if (inherits(cond, "warning")) {
[10:29:56.590]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:56.590]                       if (muffled) 
[10:29:56.590]                         invokeRestart("muffleWarning")
[10:29:56.590]                     }
[10:29:56.590]                     else if (inherits(cond, "condition")) {
[10:29:56.590]                       if (!is.null(pattern)) {
[10:29:56.590]                         computeRestarts <- base::computeRestarts
[10:29:56.590]                         grepl <- base::grepl
[10:29:56.590]                         restarts <- computeRestarts(cond)
[10:29:56.590]                         for (restart in restarts) {
[10:29:56.590]                           name <- restart$name
[10:29:56.590]                           if (is.null(name)) 
[10:29:56.590]                             next
[10:29:56.590]                           if (!grepl(pattern, name)) 
[10:29:56.590]                             next
[10:29:56.590]                           invokeRestart(restart)
[10:29:56.590]                           muffled <- TRUE
[10:29:56.590]                           break
[10:29:56.590]                         }
[10:29:56.590]                       }
[10:29:56.590]                     }
[10:29:56.590]                     invisible(muffled)
[10:29:56.590]                   }
[10:29:56.590]                   muffleCondition(cond)
[10:29:56.590]                 })
[10:29:56.590]             }))
[10:29:56.590]             future::FutureResult(value = ...future.value$value, 
[10:29:56.590]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:56.590]                   ...future.rng), globalenv = if (FALSE) 
[10:29:56.590]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:56.590]                     ...future.globalenv.names))
[10:29:56.590]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:56.590]         }, condition = base::local({
[10:29:56.590]             c <- base::c
[10:29:56.590]             inherits <- base::inherits
[10:29:56.590]             invokeRestart <- base::invokeRestart
[10:29:56.590]             length <- base::length
[10:29:56.590]             list <- base::list
[10:29:56.590]             seq.int <- base::seq.int
[10:29:56.590]             signalCondition <- base::signalCondition
[10:29:56.590]             sys.calls <- base::sys.calls
[10:29:56.590]             `[[` <- base::`[[`
[10:29:56.590]             `+` <- base::`+`
[10:29:56.590]             `<<-` <- base::`<<-`
[10:29:56.590]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:56.590]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:56.590]                   3L)]
[10:29:56.590]             }
[10:29:56.590]             function(cond) {
[10:29:56.590]                 is_error <- inherits(cond, "error")
[10:29:56.590]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:56.590]                   NULL)
[10:29:56.590]                 if (is_error) {
[10:29:56.590]                   sessionInformation <- function() {
[10:29:56.590]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:56.590]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:56.590]                       search = base::search(), system = base::Sys.info())
[10:29:56.590]                   }
[10:29:56.590]                   ...future.conditions[[length(...future.conditions) + 
[10:29:56.590]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:56.590]                     cond$call), session = sessionInformation(), 
[10:29:56.590]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:56.590]                   signalCondition(cond)
[10:29:56.590]                 }
[10:29:56.590]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:56.590]                 "immediateCondition"))) {
[10:29:56.590]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:56.590]                   ...future.conditions[[length(...future.conditions) + 
[10:29:56.590]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:56.590]                   if (TRUE && !signal) {
[10:29:56.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.590]                     {
[10:29:56.590]                       inherits <- base::inherits
[10:29:56.590]                       invokeRestart <- base::invokeRestart
[10:29:56.590]                       is.null <- base::is.null
[10:29:56.590]                       muffled <- FALSE
[10:29:56.590]                       if (inherits(cond, "message")) {
[10:29:56.590]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:56.590]                         if (muffled) 
[10:29:56.590]                           invokeRestart("muffleMessage")
[10:29:56.590]                       }
[10:29:56.590]                       else if (inherits(cond, "warning")) {
[10:29:56.590]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:56.590]                         if (muffled) 
[10:29:56.590]                           invokeRestart("muffleWarning")
[10:29:56.590]                       }
[10:29:56.590]                       else if (inherits(cond, "condition")) {
[10:29:56.590]                         if (!is.null(pattern)) {
[10:29:56.590]                           computeRestarts <- base::computeRestarts
[10:29:56.590]                           grepl <- base::grepl
[10:29:56.590]                           restarts <- computeRestarts(cond)
[10:29:56.590]                           for (restart in restarts) {
[10:29:56.590]                             name <- restart$name
[10:29:56.590]                             if (is.null(name)) 
[10:29:56.590]                               next
[10:29:56.590]                             if (!grepl(pattern, name)) 
[10:29:56.590]                               next
[10:29:56.590]                             invokeRestart(restart)
[10:29:56.590]                             muffled <- TRUE
[10:29:56.590]                             break
[10:29:56.590]                           }
[10:29:56.590]                         }
[10:29:56.590]                       }
[10:29:56.590]                       invisible(muffled)
[10:29:56.590]                     }
[10:29:56.590]                     muffleCondition(cond, pattern = "^muffle")
[10:29:56.590]                   }
[10:29:56.590]                 }
[10:29:56.590]                 else {
[10:29:56.590]                   if (TRUE) {
[10:29:56.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:56.590]                     {
[10:29:56.590]                       inherits <- base::inherits
[10:29:56.590]                       invokeRestart <- base::invokeRestart
[10:29:56.590]                       is.null <- base::is.null
[10:29:56.590]                       muffled <- FALSE
[10:29:56.590]                       if (inherits(cond, "message")) {
[10:29:56.590]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:56.590]                         if (muffled) 
[10:29:56.590]                           invokeRestart("muffleMessage")
[10:29:56.590]                       }
[10:29:56.590]                       else if (inherits(cond, "warning")) {
[10:29:56.590]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:56.590]                         if (muffled) 
[10:29:56.590]                           invokeRestart("muffleWarning")
[10:29:56.590]                       }
[10:29:56.590]                       else if (inherits(cond, "condition")) {
[10:29:56.590]                         if (!is.null(pattern)) {
[10:29:56.590]                           computeRestarts <- base::computeRestarts
[10:29:56.590]                           grepl <- base::grepl
[10:29:56.590]                           restarts <- computeRestarts(cond)
[10:29:56.590]                           for (restart in restarts) {
[10:29:56.590]                             name <- restart$name
[10:29:56.590]                             if (is.null(name)) 
[10:29:56.590]                               next
[10:29:56.590]                             if (!grepl(pattern, name)) 
[10:29:56.590]                               next
[10:29:56.590]                             invokeRestart(restart)
[10:29:56.590]                             muffled <- TRUE
[10:29:56.590]                             break
[10:29:56.590]                           }
[10:29:56.590]                         }
[10:29:56.590]                       }
[10:29:56.590]                       invisible(muffled)
[10:29:56.590]                     }
[10:29:56.590]                     muffleCondition(cond, pattern = "^muffle")
[10:29:56.590]                   }
[10:29:56.590]                 }
[10:29:56.590]             }
[10:29:56.590]         }))
[10:29:56.590]     }, error = function(ex) {
[10:29:56.590]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:56.590]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:56.590]                 ...future.rng), started = ...future.startTime, 
[10:29:56.590]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:56.590]             version = "1.8"), class = "FutureResult")
[10:29:56.590]     }, finally = {
[10:29:56.590]         if (!identical(...future.workdir, getwd())) 
[10:29:56.590]             setwd(...future.workdir)
[10:29:56.590]         {
[10:29:56.590]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:56.590]                 ...future.oldOptions$nwarnings <- NULL
[10:29:56.590]             }
[10:29:56.590]             base::options(...future.oldOptions)
[10:29:56.590]             if (.Platform$OS.type == "windows") {
[10:29:56.590]                 old_names <- names(...future.oldEnvVars)
[10:29:56.590]                 envs <- base::Sys.getenv()
[10:29:56.590]                 names <- names(envs)
[10:29:56.590]                 common <- intersect(names, old_names)
[10:29:56.590]                 added <- setdiff(names, old_names)
[10:29:56.590]                 removed <- setdiff(old_names, names)
[10:29:56.590]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:56.590]                   envs[common]]
[10:29:56.590]                 NAMES <- toupper(changed)
[10:29:56.590]                 args <- list()
[10:29:56.590]                 for (kk in seq_along(NAMES)) {
[10:29:56.590]                   name <- changed[[kk]]
[10:29:56.590]                   NAME <- NAMES[[kk]]
[10:29:56.590]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.590]                     next
[10:29:56.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:56.590]                 }
[10:29:56.590]                 NAMES <- toupper(added)
[10:29:56.590]                 for (kk in seq_along(NAMES)) {
[10:29:56.590]                   name <- added[[kk]]
[10:29:56.590]                   NAME <- NAMES[[kk]]
[10:29:56.590]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.590]                     next
[10:29:56.590]                   args[[name]] <- ""
[10:29:56.590]                 }
[10:29:56.590]                 NAMES <- toupper(removed)
[10:29:56.590]                 for (kk in seq_along(NAMES)) {
[10:29:56.590]                   name <- removed[[kk]]
[10:29:56.590]                   NAME <- NAMES[[kk]]
[10:29:56.590]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:56.590]                     next
[10:29:56.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:56.590]                 }
[10:29:56.590]                 if (length(args) > 0) 
[10:29:56.590]                   base::do.call(base::Sys.setenv, args = args)
[10:29:56.590]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:56.590]             }
[10:29:56.590]             else {
[10:29:56.590]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:56.590]             }
[10:29:56.590]             {
[10:29:56.590]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:56.590]                   0L) {
[10:29:56.590]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:56.590]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:56.590]                   base::options(opts)
[10:29:56.590]                 }
[10:29:56.590]                 {
[10:29:56.590]                   {
[10:29:56.590]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:56.590]                     NULL
[10:29:56.590]                   }
[10:29:56.590]                   options(future.plan = NULL)
[10:29:56.590]                   if (is.na(NA_character_)) 
[10:29:56.590]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:56.590]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:56.590]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:56.590]                     .init = FALSE)
[10:29:56.590]                 }
[10:29:56.590]             }
[10:29:56.590]         }
[10:29:56.590]     })
[10:29:56.590]     if (TRUE) {
[10:29:56.590]         base::sink(type = "output", split = FALSE)
[10:29:56.590]         if (TRUE) {
[10:29:56.590]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:56.590]         }
[10:29:56.590]         else {
[10:29:56.590]             ...future.result["stdout"] <- base::list(NULL)
[10:29:56.590]         }
[10:29:56.590]         base::close(...future.stdout)
[10:29:56.590]         ...future.stdout <- NULL
[10:29:56.590]     }
[10:29:56.590]     ...future.result$conditions <- ...future.conditions
[10:29:56.590]     ...future.result$finished <- base::Sys.time()
[10:29:56.590]     ...future.result
[10:29:56.590] }
[10:29:56.592] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[10:29:56.593] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[10:29:56.593] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[10:29:56.593] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:29:56.594] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:29:56.594] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[10:29:56.594] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[10:29:56.594] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:29:56.595] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:29:56.595] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:29:56.595] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:29:56.595] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[10:29:56.596] MultisessionFuture started
[10:29:56.596] - Launch lazy future ... done
[10:29:56.596] run() for ‘MultisessionFuture’ ... done
[10:29:56.596] Created future:
[10:29:56.596] MultisessionFuture:
[10:29:56.596] Label: ‘future_by-2’
[10:29:56.596] Expression:
[10:29:56.596] {
[10:29:56.596]     do.call(function(...) {
[10:29:56.596]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:56.596]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:56.596]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:56.596]             on.exit(options(oopts), add = TRUE)
[10:29:56.596]         }
[10:29:56.596]         {
[10:29:56.596]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:56.596]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:56.596]                 ...future.FUN(...future.X_jj, ...)
[10:29:56.596]             })
[10:29:56.596]         }
[10:29:56.596]     }, args = future.call.arguments)
[10:29:56.596] }
[10:29:56.596] Lazy evaluation: FALSE
[10:29:56.596] Asynchronous evaluation: TRUE
[10:29:56.596] Local evaluation: TRUE
[10:29:56.596] Environment: 0x556dd6fb5108
[10:29:56.596] Capture standard output: TRUE
[10:29:56.596] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:56.596] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:56.596] Packages: <none>
[10:29:56.596] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:56.596] Resolved: FALSE
[10:29:56.596] Value: <not collected>
[10:29:56.596] Conditions captured: <none>
[10:29:56.596] Early signaling: FALSE
[10:29:56.596] Owner process: a740280c-3654-d740-1306-c954d2bb48aa
[10:29:56.596] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:56.608] Chunk #2 of 2 ... DONE
[10:29:56.608] Launching 2 futures (chunks) ... DONE
[10:29:56.608] Resolving 2 futures (chunks) ...
[10:29:56.609] resolve() on list ...
[10:29:56.609]  recursive: 0
[10:29:56.609]  length: 2
[10:29:56.609] 
[10:29:56.609] receiveMessageFromWorker() for ClusterFuture ...
[10:29:56.610] - Validating connection of MultisessionFuture
[10:29:56.610] - received message: FutureResult
[10:29:56.610] - Received FutureResult
[10:29:56.610] - Erased future from FutureRegistry
[10:29:56.610] result() for ClusterFuture ...
[10:29:56.610] - result already collected: FutureResult
[10:29:56.610] result() for ClusterFuture ... done
[10:29:56.610] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:56.610] Future #1
[10:29:56.611] result() for ClusterFuture ...
[10:29:56.611] - result already collected: FutureResult
[10:29:56.611] result() for ClusterFuture ... done
[10:29:56.611] result() for ClusterFuture ...
[10:29:56.611] - result already collected: FutureResult
[10:29:56.611] result() for ClusterFuture ... done
[10:29:56.611] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:29:56.611] - nx: 2
[10:29:56.611] - relay: TRUE
[10:29:56.611] - stdout: TRUE
[10:29:56.611] - signal: TRUE
[10:29:56.612] - resignal: FALSE
[10:29:56.612] - force: TRUE
[10:29:56.612] - relayed: [n=2] FALSE, FALSE
[10:29:56.612] - queued futures: [n=2] FALSE, FALSE
[10:29:56.612]  - until=1
[10:29:56.612]  - relaying element #1
[10:29:56.612] result() for ClusterFuture ...
[10:29:56.612] - result already collected: FutureResult
[10:29:56.612] result() for ClusterFuture ... done
[10:29:56.612] result() for ClusterFuture ...
[10:29:56.612] - result already collected: FutureResult
[10:29:56.612] result() for ClusterFuture ... done
[10:29:56.613] result() for ClusterFuture ...
[10:29:56.613] - result already collected: FutureResult
[10:29:56.613] result() for ClusterFuture ... done
[10:29:56.613] result() for ClusterFuture ...
[10:29:56.613] - result already collected: FutureResult
[10:29:56.613] result() for ClusterFuture ... done
[10:29:56.613] - relayed: [n=2] TRUE, FALSE
[10:29:56.613] - queued futures: [n=2] TRUE, FALSE
[10:29:56.613] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:29:56.613]  length: 1 (resolved future 1)
[10:29:56.639] receiveMessageFromWorker() for ClusterFuture ...
[10:29:56.640] - Validating connection of MultisessionFuture
[10:29:56.640] - received message: FutureResult
[10:29:56.640] - Received FutureResult
[10:29:56.640] - Erased future from FutureRegistry
[10:29:56.640] result() for ClusterFuture ...
[10:29:56.640] - result already collected: FutureResult
[10:29:56.640] result() for ClusterFuture ... done
[10:29:56.640] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:56.641] Future #2
[10:29:56.641] result() for ClusterFuture ...
[10:29:56.641] - result already collected: FutureResult
[10:29:56.641] result() for ClusterFuture ... done
[10:29:56.641] result() for ClusterFuture ...
[10:29:56.641] - result already collected: FutureResult
[10:29:56.641] result() for ClusterFuture ... done
[10:29:56.641] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:29:56.641] - nx: 2
[10:29:56.641] - relay: TRUE
[10:29:56.642] - stdout: TRUE
[10:29:56.642] - signal: TRUE
[10:29:56.642] - resignal: FALSE
[10:29:56.642] - force: TRUE
[10:29:56.642] - relayed: [n=2] TRUE, FALSE
[10:29:56.642] - queued futures: [n=2] TRUE, FALSE
[10:29:56.642]  - until=2
[10:29:56.642]  - relaying element #2
[10:29:56.642] result() for ClusterFuture ...
[10:29:56.642] - result already collected: FutureResult
[10:29:56.642] result() for ClusterFuture ... done
[10:29:56.643] result() for ClusterFuture ...
[10:29:56.643] - result already collected: FutureResult
[10:29:56.643] result() for ClusterFuture ... done
[10:29:56.643] result() for ClusterFuture ...
[10:29:56.643] - result already collected: FutureResult
[10:29:56.643] result() for ClusterFuture ... done
[10:29:56.643] result() for ClusterFuture ...
[10:29:56.643] - result already collected: FutureResult
[10:29:56.643] result() for ClusterFuture ... done
[10:29:56.643] - relayed: [n=2] TRUE, TRUE
[10:29:56.643] - queued futures: [n=2] TRUE, TRUE
[10:29:56.643] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:29:56.644]  length: 0 (resolved future 2)
[10:29:56.644] Relaying remaining futures
[10:29:56.644] signalConditionsASAP(NULL, pos=0) ...
[10:29:56.644] - nx: 2
[10:29:56.644] - relay: TRUE
[10:29:56.644] - stdout: TRUE
[10:29:56.644] - signal: TRUE
[10:29:56.644] - resignal: FALSE
[10:29:56.644] - force: TRUE
[10:29:56.644] - relayed: [n=2] TRUE, TRUE
[10:29:56.644] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:56.645] - relayed: [n=2] TRUE, TRUE
[10:29:56.645] - queued futures: [n=2] TRUE, TRUE
[10:29:56.645] signalConditionsASAP(NULL, pos=0) ... done
[10:29:56.645] resolve() on list ... DONE
[10:29:56.645] result() for ClusterFuture ...
[10:29:56.645] - result already collected: FutureResult
[10:29:56.645] result() for ClusterFuture ... done
[10:29:56.645] result() for ClusterFuture ...
[10:29:56.645] - result already collected: FutureResult
[10:29:56.645] result() for ClusterFuture ... done
[10:29:56.646] result() for ClusterFuture ...
[10:29:56.646] - result already collected: FutureResult
[10:29:56.646] result() for ClusterFuture ... done
[10:29:56.646] result() for ClusterFuture ...
[10:29:56.646] - result already collected: FutureResult
[10:29:56.646] result() for ClusterFuture ... done
[10:29:56.646]  - Number of value chunks collected: 2
[10:29:56.646] Resolving 2 futures (chunks) ... DONE
[10:29:56.646] Reducing values from 2 chunks ...
[10:29:56.646]  - Number of values collected after concatenation: 3
[10:29:56.646]  - Number of values expected: 3
[10:29:56.647] Reducing values from 2 chunks ... DONE
[10:29:56.647] future_lapply() ... DONE
[10:29:56.647] future_by_internal() ... DONE
[10:29:56.648] future_by_internal() ...
Testing with 2 cores ... DONE
> 
> message("*** future_by() ... DONE")
*** future_by() ... DONE
> 
> source("incl/end.R")
[10:29:56.649] plan(): Setting new future strategy stack:
[10:29:56.649] List of future strategies:
[10:29:56.649] 1. FutureStrategy:
[10:29:56.649]    - args: function (..., envir = parent.frame())
[10:29:56.649]    - tweaked: FALSE
[10:29:56.649]    - call: future::plan(oplan)
[10:29:56.649] plan(): nbrOfWorkers() = 1
> 
