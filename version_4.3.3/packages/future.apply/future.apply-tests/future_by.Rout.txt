
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[16:17:46.010] plan(): Setting new future strategy stack:
[16:17:46.011] List of future strategies:
[16:17:46.011] 1. sequential:
[16:17:46.011]    - args: function (..., envir = parent.frame())
[16:17:46.011]    - tweaked: FALSE
[16:17:46.011]    - call: future::plan("sequential")
[16:17:46.024] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> all_equal_but_call <- function(target, current, ...) {
+   attr(target, "call") <- NULL
+   attr(current, "call") <- NULL
+   all.equal(target = target, current = current, ...)
+ }
> 
> message("*** future_by() ...")
*** future_by() ...
> 
> ## ---------------------------------------------------------
> ## by()
> ## ---------------------------------------------------------
> if (require("datasets") && require("stats")) { ## warpbreaks & lm()
+   ## Use a local variable to test that it is properly exported, because
+   ## 'warpbreaks' is available in all R sessions
+   data <- warpbreaks
+   
+   y0 <- by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+   y1 <- by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+   y2 <- by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+     lm(breaks ~ wool, data = x, ...)
+   }, singular.ok = FALSE)
+   
+   ## now suppose we want to extract the coefficients by group
+   tmp <- with(data, by(data, INDICES = tension, FUN = function(x) {
+     lm(breaks ~ wool, data = x)
+   }))
+   y3 <- sapply(tmp, coef)
+ 
+   ## Source: {r-source}/tests/reg-tests-1d.R
+   by2 <- function(data, INDICES, FUN) {
+     by(data, INDICES = INDICES, FUN = FUN)
+   }
+   future_by2 <- function(data, INDICES, FUN) {
+     future_by(data, INDICES = INDICES, FUN = FUN)
+   }
+   y4 <- by2(data, INDICES = data[,"tension"], FUN = summary)
+ 
+   for (cores in 1:availCores) {
+     message(sprintf("Testing with %d cores ...", cores))
+     options(mc.cores = cores)
+     strategies <- supportedStrategies(cores)
+   
+     for (strategy in supportedStrategies()) {
+       message(sprintf("- plan('%s') ...", strategy))
+       plan(strategy)
+     
+       y0f <- future_by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y0f, y0, check.attributes = FALSE))
+       
+       y1f <- future_by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+       stopifnot(all_equal_but_call(y1f, y1))
+       
+       y2f <- future_by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+         lm(breaks ~ wool, data = x, ...)
+       }, singular.ok = FALSE)
+       stopifnot(all_equal_but_call(y2f, y2))
+       
+       ## now suppose we want to extract the coefficients by group
+       tmp <- with(data, future_by(data, INDICES = tension, FUN = function(x) {
+         lm(breaks ~ wool, data = x)
+       }))
+       y3f <- sapply(tmp, coef)
+       stopifnot(all_equal_but_call(y3f, y3))
+       
+       y4f <- future_by2(data, INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y4f, y4))
+ 
+       ## Deprecated /HB 2022-10-24
+       y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       stopifnot(all_equal_but_call(y4f2, y4))
+ 
+       res <- tryCatch({
+         y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       }, warning = identity)
+       stopifnot(inherits(res, "warning"))
+       if (getRversion() >= "3.6.0") {
+         stopifnot(inherits(res, "deprecatedWarning"))
+       }
+     } ## for (strategy ...)
+     
+     message(sprintf("Testing with %d cores ... DONE", cores))
+   } ## for (cores ...)
+ } ## if (require("stats"))
Testing with 1 cores ...
- plan('sequential') ...
[16:17:46.078] plan(): Setting new future strategy stack:
[16:17:46.078] List of future strategies:
[16:17:46.078] 1. sequential:
[16:17:46.078]    - args: function (..., envir = parent.frame())
[16:17:46.078]    - tweaked: FALSE
[16:17:46.078]    - call: plan(strategy)
[16:17:46.089] plan(): nbrOfWorkers() = 1
[16:17:46.090] future_by_internal() ...
[16:17:46.090] future_lapply() ...
[16:17:46.094] Number of chunks: 1
[16:17:46.095] getGlobalsAndPackagesXApply() ...
[16:17:46.095]  - future.globals: TRUE
[16:17:46.095] getGlobalsAndPackages() ...
[16:17:46.096] Searching for globals...
[16:17:46.098] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:46.098] Searching for globals ... DONE
[16:17:46.098] Resolving globals: FALSE
[16:17:46.099] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:46.099] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:46.099] - globals: [1] ‘FUN’
[16:17:46.100] 
[16:17:46.100] getGlobalsAndPackages() ... DONE
[16:17:46.100]  - globals found/used: [n=1] ‘FUN’
[16:17:46.100]  - needed namespaces: [n=0] 
[16:17:46.100] Finding globals ... DONE
[16:17:46.100]  - use_args: TRUE
[16:17:46.100]  - Getting '...' globals ...
[16:17:46.101] resolve() on list ...
[16:17:46.101]  recursive: 0
[16:17:46.102]  length: 1
[16:17:46.102]  elements: ‘...’
[16:17:46.102]  length: 0 (resolved future 1)
[16:17:46.102] resolve() on list ... DONE
[16:17:46.102]    - '...' content: [n=0] 
[16:17:46.102] List of 1
[16:17:46.102]  $ ...: list()
[16:17:46.102]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.102]  - attr(*, "where")=List of 1
[16:17:46.102]   ..$ ...:<environment: 0x55b566729978> 
[16:17:46.102]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.102]  - attr(*, "resolved")= logi TRUE
[16:17:46.102]  - attr(*, "total_size")= num NA
[16:17:46.106]  - Getting '...' globals ... DONE
[16:17:46.107] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:46.107] List of 2
[16:17:46.107]  $ ...future.FUN:function (object, ...)  
[16:17:46.107]  $ ...          : list()
[16:17:46.107]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.107]  - attr(*, "where")=List of 2
[16:17:46.107]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:46.107]   ..$ ...          :<environment: 0x55b566729978> 
[16:17:46.107]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.107]  - attr(*, "resolved")= logi FALSE
[16:17:46.107]  - attr(*, "total_size")= num 1240
[16:17:46.109] Packages to be attached in all futures: [n=0] 
[16:17:46.109] getGlobalsAndPackagesXApply() ... DONE
[16:17:46.110] Number of futures (= number of chunks): 1
[16:17:46.110] Launching 1 futures (chunks) ...
[16:17:46.110] Chunk #1 of 1 ...
[16:17:46.110]  - Finding globals in 'X' for chunk #1 ...
[16:17:46.110] getGlobalsAndPackages() ...
[16:17:46.110] Searching for globals...
[16:17:46.111] 
[16:17:46.111] Searching for globals ... DONE
[16:17:46.111] - globals: [0] <none>
[16:17:46.111] getGlobalsAndPackages() ... DONE
[16:17:46.111]    + additional globals found: [n=0] 
[16:17:46.111]    + additional namespaces needed: [n=0] 
[16:17:46.111]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:46.111]  - seeds: <none>
[16:17:46.112]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.112] getGlobalsAndPackages() ...
[16:17:46.112] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.112] Resolving globals: FALSE
[16:17:46.112] Tweak future expression to call with '...' arguments ...
[16:17:46.112] {
[16:17:46.112]     do.call(function(...) {
[16:17:46.112]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.112]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.112]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.112]             on.exit(options(oopts), add = TRUE)
[16:17:46.112]         }
[16:17:46.112]         {
[16:17:46.112]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.112]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.112]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.112]             })
[16:17:46.112]         }
[16:17:46.112]     }, args = future.call.arguments)
[16:17:46.112] }
[16:17:46.112] Tweak future expression to call with '...' arguments ... DONE
[16:17:46.113] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.113] 
[16:17:46.113] getGlobalsAndPackages() ... DONE
[16:17:46.114] run() for ‘Future’ ...
[16:17:46.114] - state: ‘created’
[16:17:46.114] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:17:46.114] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.115] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:46.115]   - Field: ‘label’
[16:17:46.115]   - Field: ‘local’
[16:17:46.116]   - Field: ‘owner’
[16:17:46.117]   - Field: ‘envir’
[16:17:46.117]   - Field: ‘packages’
[16:17:46.117]   - Field: ‘gc’
[16:17:46.117]   - Field: ‘conditions’
[16:17:46.117]   - Field: ‘expr’
[16:17:46.117]   - Field: ‘uuid’
[16:17:46.117]   - Field: ‘seed’
[16:17:46.117]   - Field: ‘version’
[16:17:46.117]   - Field: ‘result’
[16:17:46.117]   - Field: ‘asynchronous’
[16:17:46.117]   - Field: ‘calls’
[16:17:46.118]   - Field: ‘globals’
[16:17:46.118]   - Field: ‘stdout’
[16:17:46.118]   - Field: ‘earlySignal’
[16:17:46.118]   - Field: ‘lazy’
[16:17:46.118]   - Field: ‘state’
[16:17:46.118] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:46.118] - Launch lazy future ...
[16:17:46.119] Packages needed by the future expression (n = 0): <none>
[16:17:46.119] Packages needed by future strategies (n = 0): <none>
[16:17:46.120] {
[16:17:46.120]     {
[16:17:46.120]         {
[16:17:46.120]             ...future.startTime <- base::Sys.time()
[16:17:46.120]             {
[16:17:46.120]                 {
[16:17:46.120]                   {
[16:17:46.120]                     base::local({
[16:17:46.120]                       has_future <- base::requireNamespace("future", 
[16:17:46.120]                         quietly = TRUE)
[16:17:46.120]                       if (has_future) {
[16:17:46.120]                         ns <- base::getNamespace("future")
[16:17:46.120]                         version <- ns[[".package"]][["version"]]
[16:17:46.120]                         if (is.null(version)) 
[16:17:46.120]                           version <- utils::packageVersion("future")
[16:17:46.120]                       }
[16:17:46.120]                       else {
[16:17:46.120]                         version <- NULL
[16:17:46.120]                       }
[16:17:46.120]                       if (!has_future || version < "1.8.0") {
[16:17:46.120]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:46.120]                           "", base::R.version$version.string), 
[16:17:46.120]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:46.120]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:46.120]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:46.120]                             "release", "version")], collapse = " "), 
[16:17:46.120]                           hostname = base::Sys.info()[["nodename"]])
[16:17:46.120]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:46.120]                           info)
[16:17:46.120]                         info <- base::paste(info, collapse = "; ")
[16:17:46.120]                         if (!has_future) {
[16:17:46.120]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:46.120]                             info)
[16:17:46.120]                         }
[16:17:46.120]                         else {
[16:17:46.120]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:46.120]                             info, version)
[16:17:46.120]                         }
[16:17:46.120]                         base::stop(msg)
[16:17:46.120]                       }
[16:17:46.120]                     })
[16:17:46.120]                   }
[16:17:46.120]                   ...future.strategy.old <- future::plan("list")
[16:17:46.120]                   options(future.plan = NULL)
[16:17:46.120]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.120]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:46.120]                 }
[16:17:46.120]                 ...future.workdir <- getwd()
[16:17:46.120]             }
[16:17:46.120]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:46.120]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:46.120]         }
[16:17:46.120]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:46.120]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:46.120]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:46.120]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:46.120]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:46.120]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:46.120]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:46.120]             base::names(...future.oldOptions))
[16:17:46.120]     }
[16:17:46.120]     if (FALSE) {
[16:17:46.120]     }
[16:17:46.120]     else {
[16:17:46.120]         if (TRUE) {
[16:17:46.120]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:46.120]                 open = "w")
[16:17:46.120]         }
[16:17:46.120]         else {
[16:17:46.120]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:46.120]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:46.120]         }
[16:17:46.120]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:46.120]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:46.120]             base::sink(type = "output", split = FALSE)
[16:17:46.120]             base::close(...future.stdout)
[16:17:46.120]         }, add = TRUE)
[16:17:46.120]     }
[16:17:46.120]     ...future.frame <- base::sys.nframe()
[16:17:46.120]     ...future.conditions <- base::list()
[16:17:46.120]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:46.120]     if (FALSE) {
[16:17:46.120]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:46.120]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:46.120]     }
[16:17:46.120]     ...future.result <- base::tryCatch({
[16:17:46.120]         base::withCallingHandlers({
[16:17:46.120]             ...future.value <- base::withVisible(base::local({
[16:17:46.120]                 do.call(function(...) {
[16:17:46.120]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.120]                   if (!identical(...future.globals.maxSize.org, 
[16:17:46.120]                     ...future.globals.maxSize)) {
[16:17:46.120]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.120]                     on.exit(options(oopts), add = TRUE)
[16:17:46.120]                   }
[16:17:46.120]                   {
[16:17:46.120]                     lapply(seq_along(...future.elements_ii), 
[16:17:46.120]                       FUN = function(jj) {
[16:17:46.120]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.120]                         ...future.FUN(...future.X_jj, ...)
[16:17:46.120]                       })
[16:17:46.120]                   }
[16:17:46.120]                 }, args = future.call.arguments)
[16:17:46.120]             }))
[16:17:46.120]             future::FutureResult(value = ...future.value$value, 
[16:17:46.120]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.120]                   ...future.rng), globalenv = if (FALSE) 
[16:17:46.120]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:46.120]                     ...future.globalenv.names))
[16:17:46.120]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:46.120]         }, condition = base::local({
[16:17:46.120]             c <- base::c
[16:17:46.120]             inherits <- base::inherits
[16:17:46.120]             invokeRestart <- base::invokeRestart
[16:17:46.120]             length <- base::length
[16:17:46.120]             list <- base::list
[16:17:46.120]             seq.int <- base::seq.int
[16:17:46.120]             signalCondition <- base::signalCondition
[16:17:46.120]             sys.calls <- base::sys.calls
[16:17:46.120]             `[[` <- base::`[[`
[16:17:46.120]             `+` <- base::`+`
[16:17:46.120]             `<<-` <- base::`<<-`
[16:17:46.120]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:46.120]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:46.120]                   3L)]
[16:17:46.120]             }
[16:17:46.120]             function(cond) {
[16:17:46.120]                 is_error <- inherits(cond, "error")
[16:17:46.120]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:46.120]                   NULL)
[16:17:46.120]                 if (is_error) {
[16:17:46.120]                   sessionInformation <- function() {
[16:17:46.120]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:46.120]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:46.120]                       search = base::search(), system = base::Sys.info())
[16:17:46.120]                   }
[16:17:46.120]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.120]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:46.120]                     cond$call), session = sessionInformation(), 
[16:17:46.120]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:46.120]                   signalCondition(cond)
[16:17:46.120]                 }
[16:17:46.120]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:46.120]                 "immediateCondition"))) {
[16:17:46.120]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:46.120]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.120]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:46.120]                   if (TRUE && !signal) {
[16:17:46.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.120]                     {
[16:17:46.120]                       inherits <- base::inherits
[16:17:46.120]                       invokeRestart <- base::invokeRestart
[16:17:46.120]                       is.null <- base::is.null
[16:17:46.120]                       muffled <- FALSE
[16:17:46.120]                       if (inherits(cond, "message")) {
[16:17:46.120]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.120]                         if (muffled) 
[16:17:46.120]                           invokeRestart("muffleMessage")
[16:17:46.120]                       }
[16:17:46.120]                       else if (inherits(cond, "warning")) {
[16:17:46.120]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.120]                         if (muffled) 
[16:17:46.120]                           invokeRestart("muffleWarning")
[16:17:46.120]                       }
[16:17:46.120]                       else if (inherits(cond, "condition")) {
[16:17:46.120]                         if (!is.null(pattern)) {
[16:17:46.120]                           computeRestarts <- base::computeRestarts
[16:17:46.120]                           grepl <- base::grepl
[16:17:46.120]                           restarts <- computeRestarts(cond)
[16:17:46.120]                           for (restart in restarts) {
[16:17:46.120]                             name <- restart$name
[16:17:46.120]                             if (is.null(name)) 
[16:17:46.120]                               next
[16:17:46.120]                             if (!grepl(pattern, name)) 
[16:17:46.120]                               next
[16:17:46.120]                             invokeRestart(restart)
[16:17:46.120]                             muffled <- TRUE
[16:17:46.120]                             break
[16:17:46.120]                           }
[16:17:46.120]                         }
[16:17:46.120]                       }
[16:17:46.120]                       invisible(muffled)
[16:17:46.120]                     }
[16:17:46.120]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.120]                   }
[16:17:46.120]                 }
[16:17:46.120]                 else {
[16:17:46.120]                   if (TRUE) {
[16:17:46.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.120]                     {
[16:17:46.120]                       inherits <- base::inherits
[16:17:46.120]                       invokeRestart <- base::invokeRestart
[16:17:46.120]                       is.null <- base::is.null
[16:17:46.120]                       muffled <- FALSE
[16:17:46.120]                       if (inherits(cond, "message")) {
[16:17:46.120]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.120]                         if (muffled) 
[16:17:46.120]                           invokeRestart("muffleMessage")
[16:17:46.120]                       }
[16:17:46.120]                       else if (inherits(cond, "warning")) {
[16:17:46.120]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.120]                         if (muffled) 
[16:17:46.120]                           invokeRestart("muffleWarning")
[16:17:46.120]                       }
[16:17:46.120]                       else if (inherits(cond, "condition")) {
[16:17:46.120]                         if (!is.null(pattern)) {
[16:17:46.120]                           computeRestarts <- base::computeRestarts
[16:17:46.120]                           grepl <- base::grepl
[16:17:46.120]                           restarts <- computeRestarts(cond)
[16:17:46.120]                           for (restart in restarts) {
[16:17:46.120]                             name <- restart$name
[16:17:46.120]                             if (is.null(name)) 
[16:17:46.120]                               next
[16:17:46.120]                             if (!grepl(pattern, name)) 
[16:17:46.120]                               next
[16:17:46.120]                             invokeRestart(restart)
[16:17:46.120]                             muffled <- TRUE
[16:17:46.120]                             break
[16:17:46.120]                           }
[16:17:46.120]                         }
[16:17:46.120]                       }
[16:17:46.120]                       invisible(muffled)
[16:17:46.120]                     }
[16:17:46.120]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.120]                   }
[16:17:46.120]                 }
[16:17:46.120]             }
[16:17:46.120]         }))
[16:17:46.120]     }, error = function(ex) {
[16:17:46.120]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:46.120]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.120]                 ...future.rng), started = ...future.startTime, 
[16:17:46.120]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:46.120]             version = "1.8"), class = "FutureResult")
[16:17:46.120]     }, finally = {
[16:17:46.120]         if (!identical(...future.workdir, getwd())) 
[16:17:46.120]             setwd(...future.workdir)
[16:17:46.120]         {
[16:17:46.120]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:46.120]                 ...future.oldOptions$nwarnings <- NULL
[16:17:46.120]             }
[16:17:46.120]             base::options(...future.oldOptions)
[16:17:46.120]             if (.Platform$OS.type == "windows") {
[16:17:46.120]                 old_names <- names(...future.oldEnvVars)
[16:17:46.120]                 envs <- base::Sys.getenv()
[16:17:46.120]                 names <- names(envs)
[16:17:46.120]                 common <- intersect(names, old_names)
[16:17:46.120]                 added <- setdiff(names, old_names)
[16:17:46.120]                 removed <- setdiff(old_names, names)
[16:17:46.120]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:46.120]                   envs[common]]
[16:17:46.120]                 NAMES <- toupper(changed)
[16:17:46.120]                 args <- list()
[16:17:46.120]                 for (kk in seq_along(NAMES)) {
[16:17:46.120]                   name <- changed[[kk]]
[16:17:46.120]                   NAME <- NAMES[[kk]]
[16:17:46.120]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.120]                     next
[16:17:46.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.120]                 }
[16:17:46.120]                 NAMES <- toupper(added)
[16:17:46.120]                 for (kk in seq_along(NAMES)) {
[16:17:46.120]                   name <- added[[kk]]
[16:17:46.120]                   NAME <- NAMES[[kk]]
[16:17:46.120]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.120]                     next
[16:17:46.120]                   args[[name]] <- ""
[16:17:46.120]                 }
[16:17:46.120]                 NAMES <- toupper(removed)
[16:17:46.120]                 for (kk in seq_along(NAMES)) {
[16:17:46.120]                   name <- removed[[kk]]
[16:17:46.120]                   NAME <- NAMES[[kk]]
[16:17:46.120]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.120]                     next
[16:17:46.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.120]                 }
[16:17:46.120]                 if (length(args) > 0) 
[16:17:46.120]                   base::do.call(base::Sys.setenv, args = args)
[16:17:46.120]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:46.120]             }
[16:17:46.120]             else {
[16:17:46.120]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:46.120]             }
[16:17:46.120]             {
[16:17:46.120]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:46.120]                   0L) {
[16:17:46.120]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:46.120]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:46.120]                   base::options(opts)
[16:17:46.120]                 }
[16:17:46.120]                 {
[16:17:46.120]                   {
[16:17:46.120]                     NULL
[16:17:46.120]                     RNGkind("Mersenne-Twister")
[16:17:46.120]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:46.120]                       inherits = FALSE)
[16:17:46.120]                   }
[16:17:46.120]                   options(future.plan = NULL)
[16:17:46.120]                   if (is.na(NA_character_)) 
[16:17:46.120]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.120]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:46.120]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:46.120]                     .init = FALSE)
[16:17:46.120]                 }
[16:17:46.120]             }
[16:17:46.120]         }
[16:17:46.120]     })
[16:17:46.120]     if (TRUE) {
[16:17:46.120]         base::sink(type = "output", split = FALSE)
[16:17:46.120]         if (TRUE) {
[16:17:46.120]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:46.120]         }
[16:17:46.120]         else {
[16:17:46.120]             ...future.result["stdout"] <- base::list(NULL)
[16:17:46.120]         }
[16:17:46.120]         base::close(...future.stdout)
[16:17:46.120]         ...future.stdout <- NULL
[16:17:46.120]     }
[16:17:46.120]     ...future.result$conditions <- ...future.conditions
[16:17:46.120]     ...future.result$finished <- base::Sys.time()
[16:17:46.120]     ...future.result
[16:17:46.120] }
[16:17:46.122] assign_globals() ...
[16:17:46.122] List of 5
[16:17:46.122]  $ ...future.FUN            :function (object, ...)  
[16:17:46.122]  $ future.call.arguments    : list()
[16:17:46.122]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.122]  $ ...future.elements_ii    :List of 3
[16:17:46.122]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:17:46.122]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:17:46.122]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.122]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:17:46.122]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:17:46.122]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.122]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:17:46.122]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:17:46.122]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.122]  $ ...future.seeds_ii       : NULL
[16:17:46.122]  $ ...future.globals.maxSize: NULL
[16:17:46.122]  - attr(*, "where")=List of 5
[16:17:46.122]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:46.122]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:46.122]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:46.122]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:46.122]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:46.122]  - attr(*, "resolved")= logi FALSE
[16:17:46.122]  - attr(*, "total_size")= num 1240
[16:17:46.122]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.122]  - attr(*, "already-done")= logi TRUE
[16:17:46.129] - copied ‘...future.FUN’ to environment
[16:17:46.129] - copied ‘future.call.arguments’ to environment
[16:17:46.129] - copied ‘...future.elements_ii’ to environment
[16:17:46.129] - copied ‘...future.seeds_ii’ to environment
[16:17:46.129] - copied ‘...future.globals.maxSize’ to environment
[16:17:46.129] assign_globals() ... done
[16:17:46.130] plan(): Setting new future strategy stack:
[16:17:46.130] List of future strategies:
[16:17:46.130] 1. sequential:
[16:17:46.130]    - args: function (..., envir = parent.frame())
[16:17:46.130]    - tweaked: FALSE
[16:17:46.130]    - call: NULL
[16:17:46.130] plan(): nbrOfWorkers() = 1
[16:17:46.132] plan(): Setting new future strategy stack:
[16:17:46.132] List of future strategies:
[16:17:46.132] 1. sequential:
[16:17:46.132]    - args: function (..., envir = parent.frame())
[16:17:46.132]    - tweaked: FALSE
[16:17:46.132]    - call: plan(strategy)
[16:17:46.133] plan(): nbrOfWorkers() = 1
[16:17:46.133] SequentialFuture started (and completed)
[16:17:46.133] - Launch lazy future ... done
[16:17:46.134] run() for ‘SequentialFuture’ ... done
[16:17:46.134] Created future:
[16:17:46.134] SequentialFuture:
[16:17:46.134] Label: ‘future_by-1’
[16:17:46.134] Expression:
[16:17:46.134] {
[16:17:46.134]     do.call(function(...) {
[16:17:46.134]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.134]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.134]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.134]             on.exit(options(oopts), add = TRUE)
[16:17:46.134]         }
[16:17:46.134]         {
[16:17:46.134]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.134]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.134]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.134]             })
[16:17:46.134]         }
[16:17:46.134]     }, args = future.call.arguments)
[16:17:46.134] }
[16:17:46.134] Lazy evaluation: FALSE
[16:17:46.134] Asynchronous evaluation: FALSE
[16:17:46.134] Local evaluation: TRUE
[16:17:46.134] Environment: R_GlobalEnv
[16:17:46.134] Capture standard output: TRUE
[16:17:46.134] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:46.134] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:46.134] Packages: <none>
[16:17:46.134] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:46.134] Resolved: TRUE
[16:17:46.134] Value: 4.62 KiB of class ‘list’
[16:17:46.134] Early signaling: FALSE
[16:17:46.134] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:46.134] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.135] Chunk #1 of 1 ... DONE
[16:17:46.135] Launching 1 futures (chunks) ... DONE
[16:17:46.135] Resolving 1 futures (chunks) ...
[16:17:46.136] resolve() on list ...
[16:17:46.136]  recursive: 0
[16:17:46.136]  length: 1
[16:17:46.136] 
[16:17:46.136] resolved() for ‘SequentialFuture’ ...
[16:17:46.136] - state: ‘finished’
[16:17:46.136] - run: TRUE
[16:17:46.136] - result: ‘FutureResult’
[16:17:46.136] resolved() for ‘SequentialFuture’ ... done
[16:17:46.137] Future #1
[16:17:46.137] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:46.137] - nx: 1
[16:17:46.137] - relay: TRUE
[16:17:46.137] - stdout: TRUE
[16:17:46.137] - signal: TRUE
[16:17:46.137] - resignal: FALSE
[16:17:46.137] - force: TRUE
[16:17:46.138] - relayed: [n=1] FALSE
[16:17:46.138] - queued futures: [n=1] FALSE
[16:17:46.138]  - until=1
[16:17:46.138]  - relaying element #1
[16:17:46.138] - relayed: [n=1] TRUE
[16:17:46.138] - queued futures: [n=1] TRUE
[16:17:46.138] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:46.138]  length: 0 (resolved future 1)
[16:17:46.138] Relaying remaining futures
[16:17:46.139] signalConditionsASAP(NULL, pos=0) ...
[16:17:46.139] - nx: 1
[16:17:46.139] - relay: TRUE
[16:17:46.139] - stdout: TRUE
[16:17:46.139] - signal: TRUE
[16:17:46.139] - resignal: FALSE
[16:17:46.139] - force: TRUE
[16:17:46.139] - relayed: [n=1] TRUE
[16:17:46.139] - queued futures: [n=1] TRUE
 - flush all
[16:17:46.139] - relayed: [n=1] TRUE
[16:17:46.139] - queued futures: [n=1] TRUE
[16:17:46.140] signalConditionsASAP(NULL, pos=0) ... done
[16:17:46.140] resolve() on list ... DONE
[16:17:46.140]  - Number of value chunks collected: 1
[16:17:46.140] Resolving 1 futures (chunks) ... DONE
[16:17:46.140] Reducing values from 1 chunks ...
[16:17:46.140]  - Number of values collected after concatenation: 3
[16:17:46.140]  - Number of values expected: 3
[16:17:46.140] Reducing values from 1 chunks ... DONE
[16:17:46.142] future_lapply() ... DONE
[16:17:46.142] future_by_internal() ... DONE
[16:17:46.142] future_by_internal() ...
[16:17:46.143] future_lapply() ...
[16:17:46.143] Number of chunks: 1
[16:17:46.143] getGlobalsAndPackagesXApply() ...
[16:17:46.143]  - future.globals: TRUE
[16:17:46.143] getGlobalsAndPackages() ...
[16:17:46.143] Searching for globals...
[16:17:46.144] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:46.145] Searching for globals ... DONE
[16:17:46.145] Resolving globals: FALSE
[16:17:46.145] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:46.145] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:46.145] - globals: [1] ‘FUN’
[16:17:46.146] 
[16:17:46.146] getGlobalsAndPackages() ... DONE
[16:17:46.146]  - globals found/used: [n=1] ‘FUN’
[16:17:46.146]  - needed namespaces: [n=0] 
[16:17:46.146] Finding globals ... DONE
[16:17:46.146]  - use_args: TRUE
[16:17:46.146]  - Getting '...' globals ...
[16:17:46.146] resolve() on list ...
[16:17:46.146]  recursive: 0
[16:17:46.147]  length: 1
[16:17:46.147]  elements: ‘...’
[16:17:46.147]  length: 0 (resolved future 1)
[16:17:46.147] resolve() on list ... DONE
[16:17:46.147]    - '...' content: [n=1] ‘digits’
[16:17:46.147] List of 1
[16:17:46.147]  $ ...:List of 1
[16:17:46.147]   ..$ digits: int 2
[16:17:46.147]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.147]  - attr(*, "where")=List of 1
[16:17:46.147]   ..$ ...:<environment: 0x55b5671d6f90> 
[16:17:46.147]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.147]  - attr(*, "resolved")= logi TRUE
[16:17:46.147]  - attr(*, "total_size")= num NA
[16:17:46.150]  - Getting '...' globals ... DONE
[16:17:46.150] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:46.150] List of 2
[16:17:46.150]  $ ...future.FUN:function (object, ...)  
[16:17:46.150]  $ ...          :List of 1
[16:17:46.150]   ..$ digits: int 2
[16:17:46.150]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.150]  - attr(*, "where")=List of 2
[16:17:46.150]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:46.150]   ..$ ...          :<environment: 0x55b5671d6f90> 
[16:17:46.150]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.150]  - attr(*, "resolved")= logi FALSE
[16:17:46.150]  - attr(*, "total_size")= num 1296
[16:17:46.153] Packages to be attached in all futures: [n=0] 
[16:17:46.153] getGlobalsAndPackagesXApply() ... DONE
[16:17:46.153] Number of futures (= number of chunks): 1
[16:17:46.153] Launching 1 futures (chunks) ...
[16:17:46.153] Chunk #1 of 1 ...
[16:17:46.153]  - Finding globals in 'X' for chunk #1 ...
[16:17:46.154] getGlobalsAndPackages() ...
[16:17:46.154] Searching for globals...
[16:17:46.154] 
[16:17:46.154] Searching for globals ... DONE
[16:17:46.154] - globals: [0] <none>
[16:17:46.154] getGlobalsAndPackages() ... DONE
[16:17:46.154]    + additional globals found: [n=0] 
[16:17:46.154]    + additional namespaces needed: [n=0] 
[16:17:46.154]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:46.154]  - seeds: <none>
[16:17:46.155]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.155] getGlobalsAndPackages() ...
[16:17:46.155] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.155] Resolving globals: FALSE
[16:17:46.155] Tweak future expression to call with '...' arguments ...
[16:17:46.155] {
[16:17:46.155]     do.call(function(...) {
[16:17:46.155]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.155]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.155]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.155]             on.exit(options(oopts), add = TRUE)
[16:17:46.155]         }
[16:17:46.155]         {
[16:17:46.155]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.155]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.155]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.155]             })
[16:17:46.155]         }
[16:17:46.155]     }, args = future.call.arguments)
[16:17:46.155] }
[16:17:46.155] Tweak future expression to call with '...' arguments ... DONE
[16:17:46.156] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.156] 
[16:17:46.156] getGlobalsAndPackages() ... DONE
[16:17:46.156] run() for ‘Future’ ...
[16:17:46.156] - state: ‘created’
[16:17:46.156] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:17:46.157] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.157] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:46.157]   - Field: ‘label’
[16:17:46.157]   - Field: ‘local’
[16:17:46.157]   - Field: ‘owner’
[16:17:46.157]   - Field: ‘envir’
[16:17:46.157]   - Field: ‘packages’
[16:17:46.157]   - Field: ‘gc’
[16:17:46.157]   - Field: ‘conditions’
[16:17:46.157]   - Field: ‘expr’
[16:17:46.158]   - Field: ‘uuid’
[16:17:46.158]   - Field: ‘seed’
[16:17:46.158]   - Field: ‘version’
[16:17:46.158]   - Field: ‘result’
[16:17:46.158]   - Field: ‘asynchronous’
[16:17:46.158]   - Field: ‘calls’
[16:17:46.158]   - Field: ‘globals’
[16:17:46.158]   - Field: ‘stdout’
[16:17:46.158]   - Field: ‘earlySignal’
[16:17:46.158]   - Field: ‘lazy’
[16:17:46.158]   - Field: ‘state’
[16:17:46.158] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:46.159] - Launch lazy future ...
[16:17:46.159] Packages needed by the future expression (n = 0): <none>
[16:17:46.159] Packages needed by future strategies (n = 0): <none>
[16:17:46.159] {
[16:17:46.159]     {
[16:17:46.159]         {
[16:17:46.159]             ...future.startTime <- base::Sys.time()
[16:17:46.159]             {
[16:17:46.159]                 {
[16:17:46.159]                   {
[16:17:46.159]                     base::local({
[16:17:46.159]                       has_future <- base::requireNamespace("future", 
[16:17:46.159]                         quietly = TRUE)
[16:17:46.159]                       if (has_future) {
[16:17:46.159]                         ns <- base::getNamespace("future")
[16:17:46.159]                         version <- ns[[".package"]][["version"]]
[16:17:46.159]                         if (is.null(version)) 
[16:17:46.159]                           version <- utils::packageVersion("future")
[16:17:46.159]                       }
[16:17:46.159]                       else {
[16:17:46.159]                         version <- NULL
[16:17:46.159]                       }
[16:17:46.159]                       if (!has_future || version < "1.8.0") {
[16:17:46.159]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:46.159]                           "", base::R.version$version.string), 
[16:17:46.159]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:46.159]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:46.159]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:46.159]                             "release", "version")], collapse = " "), 
[16:17:46.159]                           hostname = base::Sys.info()[["nodename"]])
[16:17:46.159]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:46.159]                           info)
[16:17:46.159]                         info <- base::paste(info, collapse = "; ")
[16:17:46.159]                         if (!has_future) {
[16:17:46.159]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:46.159]                             info)
[16:17:46.159]                         }
[16:17:46.159]                         else {
[16:17:46.159]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:46.159]                             info, version)
[16:17:46.159]                         }
[16:17:46.159]                         base::stop(msg)
[16:17:46.159]                       }
[16:17:46.159]                     })
[16:17:46.159]                   }
[16:17:46.159]                   ...future.strategy.old <- future::plan("list")
[16:17:46.159]                   options(future.plan = NULL)
[16:17:46.159]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.159]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:46.159]                 }
[16:17:46.159]                 ...future.workdir <- getwd()
[16:17:46.159]             }
[16:17:46.159]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:46.159]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:46.159]         }
[16:17:46.159]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:46.159]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:46.159]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:46.159]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:46.159]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:46.159]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:46.159]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:46.159]             base::names(...future.oldOptions))
[16:17:46.159]     }
[16:17:46.159]     if (FALSE) {
[16:17:46.159]     }
[16:17:46.159]     else {
[16:17:46.159]         if (TRUE) {
[16:17:46.159]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:46.159]                 open = "w")
[16:17:46.159]         }
[16:17:46.159]         else {
[16:17:46.159]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:46.159]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:46.159]         }
[16:17:46.159]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:46.159]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:46.159]             base::sink(type = "output", split = FALSE)
[16:17:46.159]             base::close(...future.stdout)
[16:17:46.159]         }, add = TRUE)
[16:17:46.159]     }
[16:17:46.159]     ...future.frame <- base::sys.nframe()
[16:17:46.159]     ...future.conditions <- base::list()
[16:17:46.159]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:46.159]     if (FALSE) {
[16:17:46.159]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:46.159]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:46.159]     }
[16:17:46.159]     ...future.result <- base::tryCatch({
[16:17:46.159]         base::withCallingHandlers({
[16:17:46.159]             ...future.value <- base::withVisible(base::local({
[16:17:46.159]                 do.call(function(...) {
[16:17:46.159]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.159]                   if (!identical(...future.globals.maxSize.org, 
[16:17:46.159]                     ...future.globals.maxSize)) {
[16:17:46.159]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.159]                     on.exit(options(oopts), add = TRUE)
[16:17:46.159]                   }
[16:17:46.159]                   {
[16:17:46.159]                     lapply(seq_along(...future.elements_ii), 
[16:17:46.159]                       FUN = function(jj) {
[16:17:46.159]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.159]                         ...future.FUN(...future.X_jj, ...)
[16:17:46.159]                       })
[16:17:46.159]                   }
[16:17:46.159]                 }, args = future.call.arguments)
[16:17:46.159]             }))
[16:17:46.159]             future::FutureResult(value = ...future.value$value, 
[16:17:46.159]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.159]                   ...future.rng), globalenv = if (FALSE) 
[16:17:46.159]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:46.159]                     ...future.globalenv.names))
[16:17:46.159]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:46.159]         }, condition = base::local({
[16:17:46.159]             c <- base::c
[16:17:46.159]             inherits <- base::inherits
[16:17:46.159]             invokeRestart <- base::invokeRestart
[16:17:46.159]             length <- base::length
[16:17:46.159]             list <- base::list
[16:17:46.159]             seq.int <- base::seq.int
[16:17:46.159]             signalCondition <- base::signalCondition
[16:17:46.159]             sys.calls <- base::sys.calls
[16:17:46.159]             `[[` <- base::`[[`
[16:17:46.159]             `+` <- base::`+`
[16:17:46.159]             `<<-` <- base::`<<-`
[16:17:46.159]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:46.159]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:46.159]                   3L)]
[16:17:46.159]             }
[16:17:46.159]             function(cond) {
[16:17:46.159]                 is_error <- inherits(cond, "error")
[16:17:46.159]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:46.159]                   NULL)
[16:17:46.159]                 if (is_error) {
[16:17:46.159]                   sessionInformation <- function() {
[16:17:46.159]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:46.159]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:46.159]                       search = base::search(), system = base::Sys.info())
[16:17:46.159]                   }
[16:17:46.159]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.159]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:46.159]                     cond$call), session = sessionInformation(), 
[16:17:46.159]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:46.159]                   signalCondition(cond)
[16:17:46.159]                 }
[16:17:46.159]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:46.159]                 "immediateCondition"))) {
[16:17:46.159]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:46.159]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.159]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:46.159]                   if (TRUE && !signal) {
[16:17:46.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.159]                     {
[16:17:46.159]                       inherits <- base::inherits
[16:17:46.159]                       invokeRestart <- base::invokeRestart
[16:17:46.159]                       is.null <- base::is.null
[16:17:46.159]                       muffled <- FALSE
[16:17:46.159]                       if (inherits(cond, "message")) {
[16:17:46.159]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.159]                         if (muffled) 
[16:17:46.159]                           invokeRestart("muffleMessage")
[16:17:46.159]                       }
[16:17:46.159]                       else if (inherits(cond, "warning")) {
[16:17:46.159]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.159]                         if (muffled) 
[16:17:46.159]                           invokeRestart("muffleWarning")
[16:17:46.159]                       }
[16:17:46.159]                       else if (inherits(cond, "condition")) {
[16:17:46.159]                         if (!is.null(pattern)) {
[16:17:46.159]                           computeRestarts <- base::computeRestarts
[16:17:46.159]                           grepl <- base::grepl
[16:17:46.159]                           restarts <- computeRestarts(cond)
[16:17:46.159]                           for (restart in restarts) {
[16:17:46.159]                             name <- restart$name
[16:17:46.159]                             if (is.null(name)) 
[16:17:46.159]                               next
[16:17:46.159]                             if (!grepl(pattern, name)) 
[16:17:46.159]                               next
[16:17:46.159]                             invokeRestart(restart)
[16:17:46.159]                             muffled <- TRUE
[16:17:46.159]                             break
[16:17:46.159]                           }
[16:17:46.159]                         }
[16:17:46.159]                       }
[16:17:46.159]                       invisible(muffled)
[16:17:46.159]                     }
[16:17:46.159]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.159]                   }
[16:17:46.159]                 }
[16:17:46.159]                 else {
[16:17:46.159]                   if (TRUE) {
[16:17:46.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.159]                     {
[16:17:46.159]                       inherits <- base::inherits
[16:17:46.159]                       invokeRestart <- base::invokeRestart
[16:17:46.159]                       is.null <- base::is.null
[16:17:46.159]                       muffled <- FALSE
[16:17:46.159]                       if (inherits(cond, "message")) {
[16:17:46.159]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.159]                         if (muffled) 
[16:17:46.159]                           invokeRestart("muffleMessage")
[16:17:46.159]                       }
[16:17:46.159]                       else if (inherits(cond, "warning")) {
[16:17:46.159]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.159]                         if (muffled) 
[16:17:46.159]                           invokeRestart("muffleWarning")
[16:17:46.159]                       }
[16:17:46.159]                       else if (inherits(cond, "condition")) {
[16:17:46.159]                         if (!is.null(pattern)) {
[16:17:46.159]                           computeRestarts <- base::computeRestarts
[16:17:46.159]                           grepl <- base::grepl
[16:17:46.159]                           restarts <- computeRestarts(cond)
[16:17:46.159]                           for (restart in restarts) {
[16:17:46.159]                             name <- restart$name
[16:17:46.159]                             if (is.null(name)) 
[16:17:46.159]                               next
[16:17:46.159]                             if (!grepl(pattern, name)) 
[16:17:46.159]                               next
[16:17:46.159]                             invokeRestart(restart)
[16:17:46.159]                             muffled <- TRUE
[16:17:46.159]                             break
[16:17:46.159]                           }
[16:17:46.159]                         }
[16:17:46.159]                       }
[16:17:46.159]                       invisible(muffled)
[16:17:46.159]                     }
[16:17:46.159]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.159]                   }
[16:17:46.159]                 }
[16:17:46.159]             }
[16:17:46.159]         }))
[16:17:46.159]     }, error = function(ex) {
[16:17:46.159]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:46.159]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.159]                 ...future.rng), started = ...future.startTime, 
[16:17:46.159]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:46.159]             version = "1.8"), class = "FutureResult")
[16:17:46.159]     }, finally = {
[16:17:46.159]         if (!identical(...future.workdir, getwd())) 
[16:17:46.159]             setwd(...future.workdir)
[16:17:46.159]         {
[16:17:46.159]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:46.159]                 ...future.oldOptions$nwarnings <- NULL
[16:17:46.159]             }
[16:17:46.159]             base::options(...future.oldOptions)
[16:17:46.159]             if (.Platform$OS.type == "windows") {
[16:17:46.159]                 old_names <- names(...future.oldEnvVars)
[16:17:46.159]                 envs <- base::Sys.getenv()
[16:17:46.159]                 names <- names(envs)
[16:17:46.159]                 common <- intersect(names, old_names)
[16:17:46.159]                 added <- setdiff(names, old_names)
[16:17:46.159]                 removed <- setdiff(old_names, names)
[16:17:46.159]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:46.159]                   envs[common]]
[16:17:46.159]                 NAMES <- toupper(changed)
[16:17:46.159]                 args <- list()
[16:17:46.159]                 for (kk in seq_along(NAMES)) {
[16:17:46.159]                   name <- changed[[kk]]
[16:17:46.159]                   NAME <- NAMES[[kk]]
[16:17:46.159]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.159]                     next
[16:17:46.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.159]                 }
[16:17:46.159]                 NAMES <- toupper(added)
[16:17:46.159]                 for (kk in seq_along(NAMES)) {
[16:17:46.159]                   name <- added[[kk]]
[16:17:46.159]                   NAME <- NAMES[[kk]]
[16:17:46.159]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.159]                     next
[16:17:46.159]                   args[[name]] <- ""
[16:17:46.159]                 }
[16:17:46.159]                 NAMES <- toupper(removed)
[16:17:46.159]                 for (kk in seq_along(NAMES)) {
[16:17:46.159]                   name <- removed[[kk]]
[16:17:46.159]                   NAME <- NAMES[[kk]]
[16:17:46.159]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.159]                     next
[16:17:46.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.159]                 }
[16:17:46.159]                 if (length(args) > 0) 
[16:17:46.159]                   base::do.call(base::Sys.setenv, args = args)
[16:17:46.159]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:46.159]             }
[16:17:46.159]             else {
[16:17:46.159]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:46.159]             }
[16:17:46.159]             {
[16:17:46.159]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:46.159]                   0L) {
[16:17:46.159]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:46.159]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:46.159]                   base::options(opts)
[16:17:46.159]                 }
[16:17:46.159]                 {
[16:17:46.159]                   {
[16:17:46.159]                     NULL
[16:17:46.159]                     RNGkind("Mersenne-Twister")
[16:17:46.159]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:46.159]                       inherits = FALSE)
[16:17:46.159]                   }
[16:17:46.159]                   options(future.plan = NULL)
[16:17:46.159]                   if (is.na(NA_character_)) 
[16:17:46.159]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.159]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:46.159]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:46.159]                     .init = FALSE)
[16:17:46.159]                 }
[16:17:46.159]             }
[16:17:46.159]         }
[16:17:46.159]     })
[16:17:46.159]     if (TRUE) {
[16:17:46.159]         base::sink(type = "output", split = FALSE)
[16:17:46.159]         if (TRUE) {
[16:17:46.159]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:46.159]         }
[16:17:46.159]         else {
[16:17:46.159]             ...future.result["stdout"] <- base::list(NULL)
[16:17:46.159]         }
[16:17:46.159]         base::close(...future.stdout)
[16:17:46.159]         ...future.stdout <- NULL
[16:17:46.159]     }
[16:17:46.159]     ...future.result$conditions <- ...future.conditions
[16:17:46.159]     ...future.result$finished <- base::Sys.time()
[16:17:46.159]     ...future.result
[16:17:46.159] }
[16:17:46.161] assign_globals() ...
[16:17:46.161] List of 5
[16:17:46.161]  $ ...future.FUN            :function (object, ...)  
[16:17:46.161]  $ future.call.arguments    :List of 1
[16:17:46.161]   ..$ digits: int 2
[16:17:46.161]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.161]  $ ...future.elements_ii    :List of 6
[16:17:46.161]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[16:17:46.161]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[16:17:46.161]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[16:17:46.161]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[16:17:46.161]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[16:17:46.161]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[16:17:46.161]  $ ...future.seeds_ii       : NULL
[16:17:46.161]  $ ...future.globals.maxSize: NULL
[16:17:46.161]  - attr(*, "where")=List of 5
[16:17:46.161]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:46.161]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:46.161]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:46.161]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:46.161]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:46.161]  - attr(*, "resolved")= logi FALSE
[16:17:46.161]  - attr(*, "total_size")= num 1296
[16:17:46.161]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.161]  - attr(*, "already-done")= logi TRUE
[16:17:46.168] - copied ‘...future.FUN’ to environment
[16:17:46.168] - copied ‘future.call.arguments’ to environment
[16:17:46.168] - copied ‘...future.elements_ii’ to environment
[16:17:46.168] - copied ‘...future.seeds_ii’ to environment
[16:17:46.168] - copied ‘...future.globals.maxSize’ to environment
[16:17:46.169] assign_globals() ... done
[16:17:46.169] plan(): Setting new future strategy stack:
[16:17:46.169] List of future strategies:
[16:17:46.169] 1. sequential:
[16:17:46.169]    - args: function (..., envir = parent.frame())
[16:17:46.169]    - tweaked: FALSE
[16:17:46.169]    - call: NULL
[16:17:46.169] plan(): nbrOfWorkers() = 1
[16:17:46.170] plan(): Setting new future strategy stack:
[16:17:46.171] List of future strategies:
[16:17:46.171] 1. sequential:
[16:17:46.171]    - args: function (..., envir = parent.frame())
[16:17:46.171]    - tweaked: FALSE
[16:17:46.171]    - call: plan(strategy)
[16:17:46.171] plan(): nbrOfWorkers() = 1
[16:17:46.171] SequentialFuture started (and completed)
[16:17:46.171] - Launch lazy future ... done
[16:17:46.171] run() for ‘SequentialFuture’ ... done
[16:17:46.171] Created future:
[16:17:46.171] SequentialFuture:
[16:17:46.171] Label: ‘future_by-1’
[16:17:46.171] Expression:
[16:17:46.171] {
[16:17:46.171]     do.call(function(...) {
[16:17:46.171]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.171]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.171]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.171]             on.exit(options(oopts), add = TRUE)
[16:17:46.171]         }
[16:17:46.171]         {
[16:17:46.171]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.171]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.171]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.171]             })
[16:17:46.171]         }
[16:17:46.171]     }, args = future.call.arguments)
[16:17:46.171] }
[16:17:46.171] Lazy evaluation: FALSE
[16:17:46.171] Asynchronous evaluation: FALSE
[16:17:46.171] Local evaluation: TRUE
[16:17:46.171] Environment: R_GlobalEnv
[16:17:46.171] Capture standard output: TRUE
[16:17:46.171] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:46.171] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:46.171] Packages: <none>
[16:17:46.171] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:46.171] Resolved: TRUE
[16:17:46.171] Value: 5.48 KiB of class ‘list’
[16:17:46.171] Early signaling: FALSE
[16:17:46.171] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:46.171] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.172] Chunk #1 of 1 ... DONE
[16:17:46.173] Launching 1 futures (chunks) ... DONE
[16:17:46.173] Resolving 1 futures (chunks) ...
[16:17:46.173] resolve() on list ...
[16:17:46.173]  recursive: 0
[16:17:46.173]  length: 1
[16:17:46.173] 
[16:17:46.173] resolved() for ‘SequentialFuture’ ...
[16:17:46.173] - state: ‘finished’
[16:17:46.173] - run: TRUE
[16:17:46.173] - result: ‘FutureResult’
[16:17:46.173] resolved() for ‘SequentialFuture’ ... done
[16:17:46.173] Future #1
[16:17:46.174] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:46.174] - nx: 1
[16:17:46.174] - relay: TRUE
[16:17:46.174] - stdout: TRUE
[16:17:46.174] - signal: TRUE
[16:17:46.174] - resignal: FALSE
[16:17:46.174] - force: TRUE
[16:17:46.174] - relayed: [n=1] FALSE
[16:17:46.174] - queued futures: [n=1] FALSE
[16:17:46.174]  - until=1
[16:17:46.174]  - relaying element #1
[16:17:46.175] - relayed: [n=1] TRUE
[16:17:46.175] - queued futures: [n=1] TRUE
[16:17:46.175] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:46.175]  length: 0 (resolved future 1)
[16:17:46.175] Relaying remaining futures
[16:17:46.175] signalConditionsASAP(NULL, pos=0) ...
[16:17:46.175] - nx: 1
[16:17:46.175] - relay: TRUE
[16:17:46.175] - stdout: TRUE
[16:17:46.175] - signal: TRUE
[16:17:46.175] - resignal: FALSE
[16:17:46.175] - force: TRUE
[16:17:46.176] - relayed: [n=1] TRUE
[16:17:46.176] - queued futures: [n=1] TRUE
 - flush all
[16:17:46.176] - relayed: [n=1] TRUE
[16:17:46.176] - queued futures: [n=1] TRUE
[16:17:46.176] signalConditionsASAP(NULL, pos=0) ... done
[16:17:46.176] resolve() on list ... DONE
[16:17:46.176]  - Number of value chunks collected: 1
[16:17:46.176] Resolving 1 futures (chunks) ... DONE
[16:17:46.176] Reducing values from 1 chunks ...
[16:17:46.176]  - Number of values collected after concatenation: 6
[16:17:46.177]  - Number of values expected: 6
[16:17:46.177] Reducing values from 1 chunks ... DONE
[16:17:46.177] future_lapply() ... DONE
[16:17:46.177] future_by_internal() ... DONE
[16:17:46.180] future_by_internal() ...
[16:17:46.180] future_lapply() ...
[16:17:46.181] Number of chunks: 1
[16:17:46.181] getGlobalsAndPackagesXApply() ...
[16:17:46.182]  - future.globals: TRUE
[16:17:46.182] getGlobalsAndPackages() ...
[16:17:46.182] Searching for globals...
[16:17:46.184] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:17:46.184] Searching for globals ... DONE
[16:17:46.184] Resolving globals: FALSE
[16:17:46.184] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[16:17:46.185] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[16:17:46.185] - globals: [1] ‘FUN’
[16:17:46.185] - packages: [1] ‘stats’
[16:17:46.185] getGlobalsAndPackages() ... DONE
[16:17:46.185]  - globals found/used: [n=1] ‘FUN’
[16:17:46.185]  - needed namespaces: [n=1] ‘stats’
[16:17:46.185] Finding globals ... DONE
[16:17:46.185]  - use_args: TRUE
[16:17:46.185]  - Getting '...' globals ...
[16:17:46.186] resolve() on list ...
[16:17:46.186]  recursive: 0
[16:17:46.186]  length: 1
[16:17:46.186]  elements: ‘...’
[16:17:46.186]  length: 0 (resolved future 1)
[16:17:46.186] resolve() on list ... DONE
[16:17:46.186]    - '...' content: [n=1] ‘singular.ok’
[16:17:46.186] List of 1
[16:17:46.186]  $ ...:List of 1
[16:17:46.186]   ..$ singular.ok: logi FALSE
[16:17:46.186]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.186]  - attr(*, "where")=List of 1
[16:17:46.186]   ..$ ...:<environment: 0x55b5682c1ae8> 
[16:17:46.186]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.186]  - attr(*, "resolved")= logi TRUE
[16:17:46.186]  - attr(*, "total_size")= num NA
[16:17:46.189]  - Getting '...' globals ... DONE
[16:17:46.189] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:46.189] List of 2
[16:17:46.189]  $ ...future.FUN:function (x, ...)  
[16:17:46.189]  $ ...          :List of 1
[16:17:46.189]   ..$ singular.ok: logi FALSE
[16:17:46.189]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.189]  - attr(*, "where")=List of 2
[16:17:46.189]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:46.189]   ..$ ...          :<environment: 0x55b5682c1ae8> 
[16:17:46.189]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.189]  - attr(*, "resolved")= logi FALSE
[16:17:46.189]  - attr(*, "total_size")= num 5384
[16:17:46.192] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:46.192] getGlobalsAndPackagesXApply() ... DONE
[16:17:46.193] Number of futures (= number of chunks): 1
[16:17:46.193] Launching 1 futures (chunks) ...
[16:17:46.193] Chunk #1 of 1 ...
[16:17:46.193]  - Finding globals in 'X' for chunk #1 ...
[16:17:46.193] getGlobalsAndPackages() ...
[16:17:46.193] Searching for globals...
[16:17:46.193] 
[16:17:46.194] Searching for globals ... DONE
[16:17:46.194] - globals: [0] <none>
[16:17:46.194] getGlobalsAndPackages() ... DONE
[16:17:46.194]    + additional globals found: [n=0] 
[16:17:46.194]    + additional namespaces needed: [n=0] 
[16:17:46.194]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:46.194]  - seeds: <none>
[16:17:46.194]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.194] getGlobalsAndPackages() ...
[16:17:46.194] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.194] Resolving globals: FALSE
[16:17:46.195] Tweak future expression to call with '...' arguments ...
[16:17:46.195] {
[16:17:46.195]     do.call(function(...) {
[16:17:46.195]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.195]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.195]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.195]             on.exit(options(oopts), add = TRUE)
[16:17:46.195]         }
[16:17:46.195]         {
[16:17:46.195]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.195]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.195]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.195]             })
[16:17:46.195]         }
[16:17:46.195]     }, args = future.call.arguments)
[16:17:46.195] }
[16:17:46.195] Tweak future expression to call with '...' arguments ... DONE
[16:17:46.195] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.195] 
[16:17:46.195] getGlobalsAndPackages() ... DONE
[16:17:46.196] run() for ‘Future’ ...
[16:17:46.196] - state: ‘created’
[16:17:46.196] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:17:46.196] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.196] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:46.196]   - Field: ‘label’
[16:17:46.196]   - Field: ‘local’
[16:17:46.197]   - Field: ‘owner’
[16:17:46.197]   - Field: ‘envir’
[16:17:46.197]   - Field: ‘packages’
[16:17:46.197]   - Field: ‘gc’
[16:17:46.197]   - Field: ‘conditions’
[16:17:46.197]   - Field: ‘expr’
[16:17:46.197]   - Field: ‘uuid’
[16:17:46.197]   - Field: ‘seed’
[16:17:46.197]   - Field: ‘version’
[16:17:46.197]   - Field: ‘result’
[16:17:46.197]   - Field: ‘asynchronous’
[16:17:46.198]   - Field: ‘calls’
[16:17:46.198]   - Field: ‘globals’
[16:17:46.198]   - Field: ‘stdout’
[16:17:46.198]   - Field: ‘earlySignal’
[16:17:46.198]   - Field: ‘lazy’
[16:17:46.198]   - Field: ‘state’
[16:17:46.198] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:46.198] - Launch lazy future ...
[16:17:46.198] Packages needed by the future expression (n = 1): ‘stats’
[16:17:46.199] Packages needed by future strategies (n = 0): <none>
[16:17:46.199] {
[16:17:46.199]     {
[16:17:46.199]         {
[16:17:46.199]             ...future.startTime <- base::Sys.time()
[16:17:46.199]             {
[16:17:46.199]                 {
[16:17:46.199]                   {
[16:17:46.199]                     {
[16:17:46.199]                       base::local({
[16:17:46.199]                         has_future <- base::requireNamespace("future", 
[16:17:46.199]                           quietly = TRUE)
[16:17:46.199]                         if (has_future) {
[16:17:46.199]                           ns <- base::getNamespace("future")
[16:17:46.199]                           version <- ns[[".package"]][["version"]]
[16:17:46.199]                           if (is.null(version)) 
[16:17:46.199]                             version <- utils::packageVersion("future")
[16:17:46.199]                         }
[16:17:46.199]                         else {
[16:17:46.199]                           version <- NULL
[16:17:46.199]                         }
[16:17:46.199]                         if (!has_future || version < "1.8.0") {
[16:17:46.199]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:46.199]                             "", base::R.version$version.string), 
[16:17:46.199]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:46.199]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:46.199]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:46.199]                               "release", "version")], collapse = " "), 
[16:17:46.199]                             hostname = base::Sys.info()[["nodename"]])
[16:17:46.199]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:46.199]                             info)
[16:17:46.199]                           info <- base::paste(info, collapse = "; ")
[16:17:46.199]                           if (!has_future) {
[16:17:46.199]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:46.199]                               info)
[16:17:46.199]                           }
[16:17:46.199]                           else {
[16:17:46.199]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:46.199]                               info, version)
[16:17:46.199]                           }
[16:17:46.199]                           base::stop(msg)
[16:17:46.199]                         }
[16:17:46.199]                       })
[16:17:46.199]                     }
[16:17:46.199]                     base::local({
[16:17:46.199]                       for (pkg in "stats") {
[16:17:46.199]                         base::loadNamespace(pkg)
[16:17:46.199]                         base::library(pkg, character.only = TRUE)
[16:17:46.199]                       }
[16:17:46.199]                     })
[16:17:46.199]                   }
[16:17:46.199]                   ...future.strategy.old <- future::plan("list")
[16:17:46.199]                   options(future.plan = NULL)
[16:17:46.199]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.199]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:46.199]                 }
[16:17:46.199]                 ...future.workdir <- getwd()
[16:17:46.199]             }
[16:17:46.199]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:46.199]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:46.199]         }
[16:17:46.199]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:46.199]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:46.199]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:46.199]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:46.199]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:46.199]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:46.199]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:46.199]             base::names(...future.oldOptions))
[16:17:46.199]     }
[16:17:46.199]     if (FALSE) {
[16:17:46.199]     }
[16:17:46.199]     else {
[16:17:46.199]         if (TRUE) {
[16:17:46.199]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:46.199]                 open = "w")
[16:17:46.199]         }
[16:17:46.199]         else {
[16:17:46.199]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:46.199]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:46.199]         }
[16:17:46.199]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:46.199]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:46.199]             base::sink(type = "output", split = FALSE)
[16:17:46.199]             base::close(...future.stdout)
[16:17:46.199]         }, add = TRUE)
[16:17:46.199]     }
[16:17:46.199]     ...future.frame <- base::sys.nframe()
[16:17:46.199]     ...future.conditions <- base::list()
[16:17:46.199]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:46.199]     if (FALSE) {
[16:17:46.199]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:46.199]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:46.199]     }
[16:17:46.199]     ...future.result <- base::tryCatch({
[16:17:46.199]         base::withCallingHandlers({
[16:17:46.199]             ...future.value <- base::withVisible(base::local({
[16:17:46.199]                 do.call(function(...) {
[16:17:46.199]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.199]                   if (!identical(...future.globals.maxSize.org, 
[16:17:46.199]                     ...future.globals.maxSize)) {
[16:17:46.199]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.199]                     on.exit(options(oopts), add = TRUE)
[16:17:46.199]                   }
[16:17:46.199]                   {
[16:17:46.199]                     lapply(seq_along(...future.elements_ii), 
[16:17:46.199]                       FUN = function(jj) {
[16:17:46.199]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.199]                         ...future.FUN(...future.X_jj, ...)
[16:17:46.199]                       })
[16:17:46.199]                   }
[16:17:46.199]                 }, args = future.call.arguments)
[16:17:46.199]             }))
[16:17:46.199]             future::FutureResult(value = ...future.value$value, 
[16:17:46.199]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.199]                   ...future.rng), globalenv = if (FALSE) 
[16:17:46.199]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:46.199]                     ...future.globalenv.names))
[16:17:46.199]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:46.199]         }, condition = base::local({
[16:17:46.199]             c <- base::c
[16:17:46.199]             inherits <- base::inherits
[16:17:46.199]             invokeRestart <- base::invokeRestart
[16:17:46.199]             length <- base::length
[16:17:46.199]             list <- base::list
[16:17:46.199]             seq.int <- base::seq.int
[16:17:46.199]             signalCondition <- base::signalCondition
[16:17:46.199]             sys.calls <- base::sys.calls
[16:17:46.199]             `[[` <- base::`[[`
[16:17:46.199]             `+` <- base::`+`
[16:17:46.199]             `<<-` <- base::`<<-`
[16:17:46.199]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:46.199]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:46.199]                   3L)]
[16:17:46.199]             }
[16:17:46.199]             function(cond) {
[16:17:46.199]                 is_error <- inherits(cond, "error")
[16:17:46.199]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:46.199]                   NULL)
[16:17:46.199]                 if (is_error) {
[16:17:46.199]                   sessionInformation <- function() {
[16:17:46.199]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:46.199]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:46.199]                       search = base::search(), system = base::Sys.info())
[16:17:46.199]                   }
[16:17:46.199]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.199]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:46.199]                     cond$call), session = sessionInformation(), 
[16:17:46.199]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:46.199]                   signalCondition(cond)
[16:17:46.199]                 }
[16:17:46.199]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:46.199]                 "immediateCondition"))) {
[16:17:46.199]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:46.199]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.199]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:46.199]                   if (TRUE && !signal) {
[16:17:46.199]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.199]                     {
[16:17:46.199]                       inherits <- base::inherits
[16:17:46.199]                       invokeRestart <- base::invokeRestart
[16:17:46.199]                       is.null <- base::is.null
[16:17:46.199]                       muffled <- FALSE
[16:17:46.199]                       if (inherits(cond, "message")) {
[16:17:46.199]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.199]                         if (muffled) 
[16:17:46.199]                           invokeRestart("muffleMessage")
[16:17:46.199]                       }
[16:17:46.199]                       else if (inherits(cond, "warning")) {
[16:17:46.199]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.199]                         if (muffled) 
[16:17:46.199]                           invokeRestart("muffleWarning")
[16:17:46.199]                       }
[16:17:46.199]                       else if (inherits(cond, "condition")) {
[16:17:46.199]                         if (!is.null(pattern)) {
[16:17:46.199]                           computeRestarts <- base::computeRestarts
[16:17:46.199]                           grepl <- base::grepl
[16:17:46.199]                           restarts <- computeRestarts(cond)
[16:17:46.199]                           for (restart in restarts) {
[16:17:46.199]                             name <- restart$name
[16:17:46.199]                             if (is.null(name)) 
[16:17:46.199]                               next
[16:17:46.199]                             if (!grepl(pattern, name)) 
[16:17:46.199]                               next
[16:17:46.199]                             invokeRestart(restart)
[16:17:46.199]                             muffled <- TRUE
[16:17:46.199]                             break
[16:17:46.199]                           }
[16:17:46.199]                         }
[16:17:46.199]                       }
[16:17:46.199]                       invisible(muffled)
[16:17:46.199]                     }
[16:17:46.199]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.199]                   }
[16:17:46.199]                 }
[16:17:46.199]                 else {
[16:17:46.199]                   if (TRUE) {
[16:17:46.199]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.199]                     {
[16:17:46.199]                       inherits <- base::inherits
[16:17:46.199]                       invokeRestart <- base::invokeRestart
[16:17:46.199]                       is.null <- base::is.null
[16:17:46.199]                       muffled <- FALSE
[16:17:46.199]                       if (inherits(cond, "message")) {
[16:17:46.199]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.199]                         if (muffled) 
[16:17:46.199]                           invokeRestart("muffleMessage")
[16:17:46.199]                       }
[16:17:46.199]                       else if (inherits(cond, "warning")) {
[16:17:46.199]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.199]                         if (muffled) 
[16:17:46.199]                           invokeRestart("muffleWarning")
[16:17:46.199]                       }
[16:17:46.199]                       else if (inherits(cond, "condition")) {
[16:17:46.199]                         if (!is.null(pattern)) {
[16:17:46.199]                           computeRestarts <- base::computeRestarts
[16:17:46.199]                           grepl <- base::grepl
[16:17:46.199]                           restarts <- computeRestarts(cond)
[16:17:46.199]                           for (restart in restarts) {
[16:17:46.199]                             name <- restart$name
[16:17:46.199]                             if (is.null(name)) 
[16:17:46.199]                               next
[16:17:46.199]                             if (!grepl(pattern, name)) 
[16:17:46.199]                               next
[16:17:46.199]                             invokeRestart(restart)
[16:17:46.199]                             muffled <- TRUE
[16:17:46.199]                             break
[16:17:46.199]                           }
[16:17:46.199]                         }
[16:17:46.199]                       }
[16:17:46.199]                       invisible(muffled)
[16:17:46.199]                     }
[16:17:46.199]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.199]                   }
[16:17:46.199]                 }
[16:17:46.199]             }
[16:17:46.199]         }))
[16:17:46.199]     }, error = function(ex) {
[16:17:46.199]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:46.199]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.199]                 ...future.rng), started = ...future.startTime, 
[16:17:46.199]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:46.199]             version = "1.8"), class = "FutureResult")
[16:17:46.199]     }, finally = {
[16:17:46.199]         if (!identical(...future.workdir, getwd())) 
[16:17:46.199]             setwd(...future.workdir)
[16:17:46.199]         {
[16:17:46.199]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:46.199]                 ...future.oldOptions$nwarnings <- NULL
[16:17:46.199]             }
[16:17:46.199]             base::options(...future.oldOptions)
[16:17:46.199]             if (.Platform$OS.type == "windows") {
[16:17:46.199]                 old_names <- names(...future.oldEnvVars)
[16:17:46.199]                 envs <- base::Sys.getenv()
[16:17:46.199]                 names <- names(envs)
[16:17:46.199]                 common <- intersect(names, old_names)
[16:17:46.199]                 added <- setdiff(names, old_names)
[16:17:46.199]                 removed <- setdiff(old_names, names)
[16:17:46.199]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:46.199]                   envs[common]]
[16:17:46.199]                 NAMES <- toupper(changed)
[16:17:46.199]                 args <- list()
[16:17:46.199]                 for (kk in seq_along(NAMES)) {
[16:17:46.199]                   name <- changed[[kk]]
[16:17:46.199]                   NAME <- NAMES[[kk]]
[16:17:46.199]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.199]                     next
[16:17:46.199]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.199]                 }
[16:17:46.199]                 NAMES <- toupper(added)
[16:17:46.199]                 for (kk in seq_along(NAMES)) {
[16:17:46.199]                   name <- added[[kk]]
[16:17:46.199]                   NAME <- NAMES[[kk]]
[16:17:46.199]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.199]                     next
[16:17:46.199]                   args[[name]] <- ""
[16:17:46.199]                 }
[16:17:46.199]                 NAMES <- toupper(removed)
[16:17:46.199]                 for (kk in seq_along(NAMES)) {
[16:17:46.199]                   name <- removed[[kk]]
[16:17:46.199]                   NAME <- NAMES[[kk]]
[16:17:46.199]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.199]                     next
[16:17:46.199]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.199]                 }
[16:17:46.199]                 if (length(args) > 0) 
[16:17:46.199]                   base::do.call(base::Sys.setenv, args = args)
[16:17:46.199]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:46.199]             }
[16:17:46.199]             else {
[16:17:46.199]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:46.199]             }
[16:17:46.199]             {
[16:17:46.199]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:46.199]                   0L) {
[16:17:46.199]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:46.199]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:46.199]                   base::options(opts)
[16:17:46.199]                 }
[16:17:46.199]                 {
[16:17:46.199]                   {
[16:17:46.199]                     NULL
[16:17:46.199]                     RNGkind("Mersenne-Twister")
[16:17:46.199]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:46.199]                       inherits = FALSE)
[16:17:46.199]                   }
[16:17:46.199]                   options(future.plan = NULL)
[16:17:46.199]                   if (is.na(NA_character_)) 
[16:17:46.199]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.199]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:46.199]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:46.199]                     .init = FALSE)
[16:17:46.199]                 }
[16:17:46.199]             }
[16:17:46.199]         }
[16:17:46.199]     })
[16:17:46.199]     if (TRUE) {
[16:17:46.199]         base::sink(type = "output", split = FALSE)
[16:17:46.199]         if (TRUE) {
[16:17:46.199]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:46.199]         }
[16:17:46.199]         else {
[16:17:46.199]             ...future.result["stdout"] <- base::list(NULL)
[16:17:46.199]         }
[16:17:46.199]         base::close(...future.stdout)
[16:17:46.199]         ...future.stdout <- NULL
[16:17:46.199]     }
[16:17:46.199]     ...future.result$conditions <- ...future.conditions
[16:17:46.199]     ...future.result$finished <- base::Sys.time()
[16:17:46.199]     ...future.result
[16:17:46.199] }
[16:17:46.201] assign_globals() ...
[16:17:46.201] List of 5
[16:17:46.201]  $ ...future.FUN            :function (x, ...)  
[16:17:46.201]  $ future.call.arguments    :List of 1
[16:17:46.201]   ..$ singular.ok: logi FALSE
[16:17:46.201]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.201]  $ ...future.elements_ii    :List of 3
[16:17:46.201]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.201]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:17:46.201]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.201]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:46.201]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.201]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:17:46.201]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.201]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:17:46.201]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.201]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:17:46.201]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.201]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:17:46.201]  $ ...future.seeds_ii       : NULL
[16:17:46.201]  $ ...future.globals.maxSize: NULL
[16:17:46.201]  - attr(*, "where")=List of 5
[16:17:46.201]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:46.201]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:46.201]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:46.201]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:46.201]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:46.201]  - attr(*, "resolved")= logi FALSE
[16:17:46.201]  - attr(*, "total_size")= num 5384
[16:17:46.201]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.201]  - attr(*, "already-done")= logi TRUE
[16:17:46.210] - reassign environment for ‘...future.FUN’
[16:17:46.210] - copied ‘...future.FUN’ to environment
[16:17:46.210] - copied ‘future.call.arguments’ to environment
[16:17:46.210] - copied ‘...future.elements_ii’ to environment
[16:17:46.210] - copied ‘...future.seeds_ii’ to environment
[16:17:46.211] - copied ‘...future.globals.maxSize’ to environment
[16:17:46.211] assign_globals() ... done
[16:17:46.211] plan(): Setting new future strategy stack:
[16:17:46.211] List of future strategies:
[16:17:46.211] 1. sequential:
[16:17:46.211]    - args: function (..., envir = parent.frame())
[16:17:46.211]    - tweaked: FALSE
[16:17:46.211]    - call: NULL
[16:17:46.211] plan(): nbrOfWorkers() = 1
[16:17:46.214] plan(): Setting new future strategy stack:
[16:17:46.214] List of future strategies:
[16:17:46.214] 1. sequential:
[16:17:46.214]    - args: function (..., envir = parent.frame())
[16:17:46.214]    - tweaked: FALSE
[16:17:46.214]    - call: plan(strategy)
[16:17:46.214] plan(): nbrOfWorkers() = 1
[16:17:46.215] SequentialFuture started (and completed)
[16:17:46.215] - Launch lazy future ... done
[16:17:46.215] run() for ‘SequentialFuture’ ... done
[16:17:46.215] Created future:
[16:17:46.215] SequentialFuture:
[16:17:46.215] Label: ‘future_by-1’
[16:17:46.215] Expression:
[16:17:46.215] {
[16:17:46.215]     do.call(function(...) {
[16:17:46.215]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.215]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.215]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.215]             on.exit(options(oopts), add = TRUE)
[16:17:46.215]         }
[16:17:46.215]         {
[16:17:46.215]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.215]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.215]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.215]             })
[16:17:46.215]         }
[16:17:46.215]     }, args = future.call.arguments)
[16:17:46.215] }
[16:17:46.215] Lazy evaluation: FALSE
[16:17:46.215] Asynchronous evaluation: FALSE
[16:17:46.215] Local evaluation: TRUE
[16:17:46.215] Environment: R_GlobalEnv
[16:17:46.215] Capture standard output: TRUE
[16:17:46.215] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:46.215] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:46.215] Packages: 1 packages (‘stats’)
[16:17:46.215] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:46.215] Resolved: TRUE
[16:17:46.215] Value: 26.06 KiB of class ‘list’
[16:17:46.215] Early signaling: FALSE
[16:17:46.215] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:46.215] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.216] Chunk #1 of 1 ... DONE
[16:17:46.216] Launching 1 futures (chunks) ... DONE
[16:17:46.217] Resolving 1 futures (chunks) ...
[16:17:46.217] resolve() on list ...
[16:17:46.217]  recursive: 0
[16:17:46.217]  length: 1
[16:17:46.217] 
[16:17:46.217] resolved() for ‘SequentialFuture’ ...
[16:17:46.217] - state: ‘finished’
[16:17:46.217] - run: TRUE
[16:17:46.217] - result: ‘FutureResult’
[16:17:46.217] resolved() for ‘SequentialFuture’ ... done
[16:17:46.217] Future #1
[16:17:46.218] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:46.218] - nx: 1
[16:17:46.218] - relay: TRUE
[16:17:46.218] - stdout: TRUE
[16:17:46.218] - signal: TRUE
[16:17:46.218] - resignal: FALSE
[16:17:46.218] - force: TRUE
[16:17:46.218] - relayed: [n=1] FALSE
[16:17:46.218] - queued futures: [n=1] FALSE
[16:17:46.218]  - until=1
[16:17:46.218]  - relaying element #1
[16:17:46.219] - relayed: [n=1] TRUE
[16:17:46.219] - queued futures: [n=1] TRUE
[16:17:46.219] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:46.219]  length: 0 (resolved future 1)
[16:17:46.219] Relaying remaining futures
[16:17:46.219] signalConditionsASAP(NULL, pos=0) ...
[16:17:46.219] - nx: 1
[16:17:46.219] - relay: TRUE
[16:17:46.219] - stdout: TRUE
[16:17:46.219] - signal: TRUE
[16:17:46.219] - resignal: FALSE
[16:17:46.220] - force: TRUE
[16:17:46.220] - relayed: [n=1] TRUE
[16:17:46.220] - queued futures: [n=1] TRUE
 - flush all
[16:17:46.220] - relayed: [n=1] TRUE
[16:17:46.220] - queued futures: [n=1] TRUE
[16:17:46.220] signalConditionsASAP(NULL, pos=0) ... done
[16:17:46.220] resolve() on list ... DONE
[16:17:46.220]  - Number of value chunks collected: 1
[16:17:46.220] Resolving 1 futures (chunks) ... DONE
[16:17:46.220] Reducing values from 1 chunks ...
[16:17:46.221]  - Number of values collected after concatenation: 3
[16:17:46.221]  - Number of values expected: 3
[16:17:46.221] Reducing values from 1 chunks ... DONE
[16:17:46.222] future_lapply() ... DONE
[16:17:46.222] future_by_internal() ... DONE
[16:17:46.226] future_by_internal() ...
[16:17:46.226] future_lapply() ...
[16:17:46.227] Number of chunks: 1
[16:17:46.227] getGlobalsAndPackagesXApply() ...
[16:17:46.227]  - future.globals: TRUE
[16:17:46.227] getGlobalsAndPackages() ...
[16:17:46.227] Searching for globals...
[16:17:46.229] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:17:46.229] Searching for globals ... DONE
[16:17:46.229] Resolving globals: FALSE
[16:17:46.229] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[16:17:46.230] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[16:17:46.230] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[16:17:46.230] - packages: [1] ‘stats’
[16:17:46.230] getGlobalsAndPackages() ... DONE
[16:17:46.230]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[16:17:46.230]  - needed namespaces: [n=1] ‘stats’
[16:17:46.230] Finding globals ... DONE
[16:17:46.230]  - use_args: TRUE
[16:17:46.230]  - Getting '...' globals ...
[16:17:46.231] resolve() on list ...
[16:17:46.231]  recursive: 0
[16:17:46.231]  length: 1
[16:17:46.231]  elements: ‘...’
[16:17:46.231]  length: 0 (resolved future 1)
[16:17:46.231] resolve() on list ... DONE
[16:17:46.231]    - '...' content: [n=0] 
[16:17:46.231] List of 1
[16:17:46.231]  $ ...: list()
[16:17:46.231]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.231]  - attr(*, "where")=List of 1
[16:17:46.231]   ..$ ...:<environment: 0x55b5667431d0> 
[16:17:46.231]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.231]  - attr(*, "resolved")= logi TRUE
[16:17:46.231]  - attr(*, "total_size")= num NA
[16:17:46.234]  - Getting '...' globals ... DONE
[16:17:46.234] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[16:17:46.234] List of 4
[16:17:46.234]  $ ...future.FUN:function (x)  
[16:17:46.234]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:17:46.234]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:46.234]  $ ...          : list()
[16:17:46.234]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.234]  - attr(*, "where")=List of 4
[16:17:46.234]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:46.234]   ..$ breaks       :<environment: R_EmptyEnv> 
[16:17:46.234]   ..$ wool         :<environment: R_EmptyEnv> 
[16:17:46.234]   ..$ ...          :<environment: 0x55b5667431d0> 
[16:17:46.234]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.234]  - attr(*, "resolved")= logi FALSE
[16:17:46.234]  - attr(*, "total_size")= num 2320
[16:17:46.238] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:46.239] getGlobalsAndPackagesXApply() ... DONE
[16:17:46.239] Number of futures (= number of chunks): 1
[16:17:46.239] Launching 1 futures (chunks) ...
[16:17:46.239] Chunk #1 of 1 ...
[16:17:46.239]  - Finding globals in 'X' for chunk #1 ...
[16:17:46.239] getGlobalsAndPackages() ...
[16:17:46.239] Searching for globals...
[16:17:46.240] 
[16:17:46.240] Searching for globals ... DONE
[16:17:46.240] - globals: [0] <none>
[16:17:46.240] getGlobalsAndPackages() ... DONE
[16:17:46.240]    + additional globals found: [n=0] 
[16:17:46.240]    + additional namespaces needed: [n=0] 
[16:17:46.240]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:46.240]  - seeds: <none>
[16:17:46.240]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.241] getGlobalsAndPackages() ...
[16:17:46.241] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.241] Resolving globals: FALSE
[16:17:46.241] Tweak future expression to call with '...' arguments ...
[16:17:46.241] {
[16:17:46.241]     do.call(function(...) {
[16:17:46.241]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.241]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.241]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.241]             on.exit(options(oopts), add = TRUE)
[16:17:46.241]         }
[16:17:46.241]         {
[16:17:46.241]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.241]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.241]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.241]             })
[16:17:46.241]         }
[16:17:46.241]     }, args = future.call.arguments)
[16:17:46.241] }
[16:17:46.241] Tweak future expression to call with '...' arguments ... DONE
[16:17:46.242] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.242] 
[16:17:46.242] getGlobalsAndPackages() ... DONE
[16:17:46.242] run() for ‘Future’ ...
[16:17:46.242] - state: ‘created’
[16:17:46.242] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:17:46.243] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.243] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:46.243]   - Field: ‘label’
[16:17:46.243]   - Field: ‘local’
[16:17:46.243]   - Field: ‘owner’
[16:17:46.243]   - Field: ‘envir’
[16:17:46.243]   - Field: ‘packages’
[16:17:46.243]   - Field: ‘gc’
[16:17:46.243]   - Field: ‘conditions’
[16:17:46.243]   - Field: ‘expr’
[16:17:46.243]   - Field: ‘uuid’
[16:17:46.244]   - Field: ‘seed’
[16:17:46.244]   - Field: ‘version’
[16:17:46.244]   - Field: ‘result’
[16:17:46.244]   - Field: ‘asynchronous’
[16:17:46.244]   - Field: ‘calls’
[16:17:46.244]   - Field: ‘globals’
[16:17:46.244]   - Field: ‘stdout’
[16:17:46.244]   - Field: ‘earlySignal’
[16:17:46.244]   - Field: ‘lazy’
[16:17:46.244]   - Field: ‘state’
[16:17:46.244] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:46.245] - Launch lazy future ...
[16:17:46.245] Packages needed by the future expression (n = 1): ‘stats’
[16:17:46.245] Packages needed by future strategies (n = 0): <none>
[16:17:46.245] {
[16:17:46.245]     {
[16:17:46.245]         {
[16:17:46.245]             ...future.startTime <- base::Sys.time()
[16:17:46.245]             {
[16:17:46.245]                 {
[16:17:46.245]                   {
[16:17:46.245]                     {
[16:17:46.245]                       base::local({
[16:17:46.245]                         has_future <- base::requireNamespace("future", 
[16:17:46.245]                           quietly = TRUE)
[16:17:46.245]                         if (has_future) {
[16:17:46.245]                           ns <- base::getNamespace("future")
[16:17:46.245]                           version <- ns[[".package"]][["version"]]
[16:17:46.245]                           if (is.null(version)) 
[16:17:46.245]                             version <- utils::packageVersion("future")
[16:17:46.245]                         }
[16:17:46.245]                         else {
[16:17:46.245]                           version <- NULL
[16:17:46.245]                         }
[16:17:46.245]                         if (!has_future || version < "1.8.0") {
[16:17:46.245]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:46.245]                             "", base::R.version$version.string), 
[16:17:46.245]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:46.245]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:46.245]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:46.245]                               "release", "version")], collapse = " "), 
[16:17:46.245]                             hostname = base::Sys.info()[["nodename"]])
[16:17:46.245]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:46.245]                             info)
[16:17:46.245]                           info <- base::paste(info, collapse = "; ")
[16:17:46.245]                           if (!has_future) {
[16:17:46.245]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:46.245]                               info)
[16:17:46.245]                           }
[16:17:46.245]                           else {
[16:17:46.245]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:46.245]                               info, version)
[16:17:46.245]                           }
[16:17:46.245]                           base::stop(msg)
[16:17:46.245]                         }
[16:17:46.245]                       })
[16:17:46.245]                     }
[16:17:46.245]                     base::local({
[16:17:46.245]                       for (pkg in "stats") {
[16:17:46.245]                         base::loadNamespace(pkg)
[16:17:46.245]                         base::library(pkg, character.only = TRUE)
[16:17:46.245]                       }
[16:17:46.245]                     })
[16:17:46.245]                   }
[16:17:46.245]                   ...future.strategy.old <- future::plan("list")
[16:17:46.245]                   options(future.plan = NULL)
[16:17:46.245]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.245]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:46.245]                 }
[16:17:46.245]                 ...future.workdir <- getwd()
[16:17:46.245]             }
[16:17:46.245]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:46.245]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:46.245]         }
[16:17:46.245]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:46.245]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:46.245]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:46.245]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:46.245]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:46.245]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:46.245]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:46.245]             base::names(...future.oldOptions))
[16:17:46.245]     }
[16:17:46.245]     if (FALSE) {
[16:17:46.245]     }
[16:17:46.245]     else {
[16:17:46.245]         if (TRUE) {
[16:17:46.245]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:46.245]                 open = "w")
[16:17:46.245]         }
[16:17:46.245]         else {
[16:17:46.245]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:46.245]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:46.245]         }
[16:17:46.245]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:46.245]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:46.245]             base::sink(type = "output", split = FALSE)
[16:17:46.245]             base::close(...future.stdout)
[16:17:46.245]         }, add = TRUE)
[16:17:46.245]     }
[16:17:46.245]     ...future.frame <- base::sys.nframe()
[16:17:46.245]     ...future.conditions <- base::list()
[16:17:46.245]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:46.245]     if (FALSE) {
[16:17:46.245]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:46.245]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:46.245]     }
[16:17:46.245]     ...future.result <- base::tryCatch({
[16:17:46.245]         base::withCallingHandlers({
[16:17:46.245]             ...future.value <- base::withVisible(base::local({
[16:17:46.245]                 do.call(function(...) {
[16:17:46.245]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.245]                   if (!identical(...future.globals.maxSize.org, 
[16:17:46.245]                     ...future.globals.maxSize)) {
[16:17:46.245]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.245]                     on.exit(options(oopts), add = TRUE)
[16:17:46.245]                   }
[16:17:46.245]                   {
[16:17:46.245]                     lapply(seq_along(...future.elements_ii), 
[16:17:46.245]                       FUN = function(jj) {
[16:17:46.245]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.245]                         ...future.FUN(...future.X_jj, ...)
[16:17:46.245]                       })
[16:17:46.245]                   }
[16:17:46.245]                 }, args = future.call.arguments)
[16:17:46.245]             }))
[16:17:46.245]             future::FutureResult(value = ...future.value$value, 
[16:17:46.245]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.245]                   ...future.rng), globalenv = if (FALSE) 
[16:17:46.245]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:46.245]                     ...future.globalenv.names))
[16:17:46.245]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:46.245]         }, condition = base::local({
[16:17:46.245]             c <- base::c
[16:17:46.245]             inherits <- base::inherits
[16:17:46.245]             invokeRestart <- base::invokeRestart
[16:17:46.245]             length <- base::length
[16:17:46.245]             list <- base::list
[16:17:46.245]             seq.int <- base::seq.int
[16:17:46.245]             signalCondition <- base::signalCondition
[16:17:46.245]             sys.calls <- base::sys.calls
[16:17:46.245]             `[[` <- base::`[[`
[16:17:46.245]             `+` <- base::`+`
[16:17:46.245]             `<<-` <- base::`<<-`
[16:17:46.245]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:46.245]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:46.245]                   3L)]
[16:17:46.245]             }
[16:17:46.245]             function(cond) {
[16:17:46.245]                 is_error <- inherits(cond, "error")
[16:17:46.245]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:46.245]                   NULL)
[16:17:46.245]                 if (is_error) {
[16:17:46.245]                   sessionInformation <- function() {
[16:17:46.245]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:46.245]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:46.245]                       search = base::search(), system = base::Sys.info())
[16:17:46.245]                   }
[16:17:46.245]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.245]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:46.245]                     cond$call), session = sessionInformation(), 
[16:17:46.245]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:46.245]                   signalCondition(cond)
[16:17:46.245]                 }
[16:17:46.245]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:46.245]                 "immediateCondition"))) {
[16:17:46.245]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:46.245]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.245]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:46.245]                   if (TRUE && !signal) {
[16:17:46.245]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.245]                     {
[16:17:46.245]                       inherits <- base::inherits
[16:17:46.245]                       invokeRestart <- base::invokeRestart
[16:17:46.245]                       is.null <- base::is.null
[16:17:46.245]                       muffled <- FALSE
[16:17:46.245]                       if (inherits(cond, "message")) {
[16:17:46.245]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.245]                         if (muffled) 
[16:17:46.245]                           invokeRestart("muffleMessage")
[16:17:46.245]                       }
[16:17:46.245]                       else if (inherits(cond, "warning")) {
[16:17:46.245]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.245]                         if (muffled) 
[16:17:46.245]                           invokeRestart("muffleWarning")
[16:17:46.245]                       }
[16:17:46.245]                       else if (inherits(cond, "condition")) {
[16:17:46.245]                         if (!is.null(pattern)) {
[16:17:46.245]                           computeRestarts <- base::computeRestarts
[16:17:46.245]                           grepl <- base::grepl
[16:17:46.245]                           restarts <- computeRestarts(cond)
[16:17:46.245]                           for (restart in restarts) {
[16:17:46.245]                             name <- restart$name
[16:17:46.245]                             if (is.null(name)) 
[16:17:46.245]                               next
[16:17:46.245]                             if (!grepl(pattern, name)) 
[16:17:46.245]                               next
[16:17:46.245]                             invokeRestart(restart)
[16:17:46.245]                             muffled <- TRUE
[16:17:46.245]                             break
[16:17:46.245]                           }
[16:17:46.245]                         }
[16:17:46.245]                       }
[16:17:46.245]                       invisible(muffled)
[16:17:46.245]                     }
[16:17:46.245]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.245]                   }
[16:17:46.245]                 }
[16:17:46.245]                 else {
[16:17:46.245]                   if (TRUE) {
[16:17:46.245]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.245]                     {
[16:17:46.245]                       inherits <- base::inherits
[16:17:46.245]                       invokeRestart <- base::invokeRestart
[16:17:46.245]                       is.null <- base::is.null
[16:17:46.245]                       muffled <- FALSE
[16:17:46.245]                       if (inherits(cond, "message")) {
[16:17:46.245]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.245]                         if (muffled) 
[16:17:46.245]                           invokeRestart("muffleMessage")
[16:17:46.245]                       }
[16:17:46.245]                       else if (inherits(cond, "warning")) {
[16:17:46.245]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.245]                         if (muffled) 
[16:17:46.245]                           invokeRestart("muffleWarning")
[16:17:46.245]                       }
[16:17:46.245]                       else if (inherits(cond, "condition")) {
[16:17:46.245]                         if (!is.null(pattern)) {
[16:17:46.245]                           computeRestarts <- base::computeRestarts
[16:17:46.245]                           grepl <- base::grepl
[16:17:46.245]                           restarts <- computeRestarts(cond)
[16:17:46.245]                           for (restart in restarts) {
[16:17:46.245]                             name <- restart$name
[16:17:46.245]                             if (is.null(name)) 
[16:17:46.245]                               next
[16:17:46.245]                             if (!grepl(pattern, name)) 
[16:17:46.245]                               next
[16:17:46.245]                             invokeRestart(restart)
[16:17:46.245]                             muffled <- TRUE
[16:17:46.245]                             break
[16:17:46.245]                           }
[16:17:46.245]                         }
[16:17:46.245]                       }
[16:17:46.245]                       invisible(muffled)
[16:17:46.245]                     }
[16:17:46.245]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.245]                   }
[16:17:46.245]                 }
[16:17:46.245]             }
[16:17:46.245]         }))
[16:17:46.245]     }, error = function(ex) {
[16:17:46.245]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:46.245]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.245]                 ...future.rng), started = ...future.startTime, 
[16:17:46.245]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:46.245]             version = "1.8"), class = "FutureResult")
[16:17:46.245]     }, finally = {
[16:17:46.245]         if (!identical(...future.workdir, getwd())) 
[16:17:46.245]             setwd(...future.workdir)
[16:17:46.245]         {
[16:17:46.245]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:46.245]                 ...future.oldOptions$nwarnings <- NULL
[16:17:46.245]             }
[16:17:46.245]             base::options(...future.oldOptions)
[16:17:46.245]             if (.Platform$OS.type == "windows") {
[16:17:46.245]                 old_names <- names(...future.oldEnvVars)
[16:17:46.245]                 envs <- base::Sys.getenv()
[16:17:46.245]                 names <- names(envs)
[16:17:46.245]                 common <- intersect(names, old_names)
[16:17:46.245]                 added <- setdiff(names, old_names)
[16:17:46.245]                 removed <- setdiff(old_names, names)
[16:17:46.245]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:46.245]                   envs[common]]
[16:17:46.245]                 NAMES <- toupper(changed)
[16:17:46.245]                 args <- list()
[16:17:46.245]                 for (kk in seq_along(NAMES)) {
[16:17:46.245]                   name <- changed[[kk]]
[16:17:46.245]                   NAME <- NAMES[[kk]]
[16:17:46.245]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.245]                     next
[16:17:46.245]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.245]                 }
[16:17:46.245]                 NAMES <- toupper(added)
[16:17:46.245]                 for (kk in seq_along(NAMES)) {
[16:17:46.245]                   name <- added[[kk]]
[16:17:46.245]                   NAME <- NAMES[[kk]]
[16:17:46.245]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.245]                     next
[16:17:46.245]                   args[[name]] <- ""
[16:17:46.245]                 }
[16:17:46.245]                 NAMES <- toupper(removed)
[16:17:46.245]                 for (kk in seq_along(NAMES)) {
[16:17:46.245]                   name <- removed[[kk]]
[16:17:46.245]                   NAME <- NAMES[[kk]]
[16:17:46.245]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.245]                     next
[16:17:46.245]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.245]                 }
[16:17:46.245]                 if (length(args) > 0) 
[16:17:46.245]                   base::do.call(base::Sys.setenv, args = args)
[16:17:46.245]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:46.245]             }
[16:17:46.245]             else {
[16:17:46.245]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:46.245]             }
[16:17:46.245]             {
[16:17:46.245]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:46.245]                   0L) {
[16:17:46.245]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:46.245]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:46.245]                   base::options(opts)
[16:17:46.245]                 }
[16:17:46.245]                 {
[16:17:46.245]                   {
[16:17:46.245]                     NULL
[16:17:46.245]                     RNGkind("Mersenne-Twister")
[16:17:46.245]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:46.245]                       inherits = FALSE)
[16:17:46.245]                   }
[16:17:46.245]                   options(future.plan = NULL)
[16:17:46.245]                   if (is.na(NA_character_)) 
[16:17:46.245]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.245]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:46.245]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:46.245]                     .init = FALSE)
[16:17:46.245]                 }
[16:17:46.245]             }
[16:17:46.245]         }
[16:17:46.245]     })
[16:17:46.245]     if (TRUE) {
[16:17:46.245]         base::sink(type = "output", split = FALSE)
[16:17:46.245]         if (TRUE) {
[16:17:46.245]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:46.245]         }
[16:17:46.245]         else {
[16:17:46.245]             ...future.result["stdout"] <- base::list(NULL)
[16:17:46.245]         }
[16:17:46.245]         base::close(...future.stdout)
[16:17:46.245]         ...future.stdout <- NULL
[16:17:46.245]     }
[16:17:46.245]     ...future.result$conditions <- ...future.conditions
[16:17:46.245]     ...future.result$finished <- base::Sys.time()
[16:17:46.245]     ...future.result
[16:17:46.245] }
[16:17:46.247] assign_globals() ...
[16:17:46.247] List of 7
[16:17:46.247]  $ ...future.FUN            :function (x)  
[16:17:46.247]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:17:46.247]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:46.247]  $ future.call.arguments    : list()
[16:17:46.247]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.247]  $ ...future.elements_ii    :List of 3
[16:17:46.247]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.247]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:17:46.247]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.247]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:46.247]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.247]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:17:46.247]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.247]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:17:46.247]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.247]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:17:46.247]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.247]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:17:46.247]  $ ...future.seeds_ii       : NULL
[16:17:46.247]  $ ...future.globals.maxSize: NULL
[16:17:46.247]  - attr(*, "where")=List of 7
[16:17:46.247]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:46.247]   ..$ breaks                   :<environment: R_EmptyEnv> 
[16:17:46.247]   ..$ wool                     :<environment: R_EmptyEnv> 
[16:17:46.247]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:46.247]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:46.247]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:46.247]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:46.247]  - attr(*, "resolved")= logi FALSE
[16:17:46.247]  - attr(*, "total_size")= num 2320
[16:17:46.247]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.247]  - attr(*, "already-done")= logi TRUE
[16:17:46.256] - reassign environment for ‘...future.FUN’
[16:17:46.256] - copied ‘...future.FUN’ to environment
[16:17:46.256] - copied ‘breaks’ to environment
[16:17:46.256] - copied ‘wool’ to environment
[16:17:46.257] - copied ‘future.call.arguments’ to environment
[16:17:46.257] - copied ‘...future.elements_ii’ to environment
[16:17:46.257] - copied ‘...future.seeds_ii’ to environment
[16:17:46.257] - copied ‘...future.globals.maxSize’ to environment
[16:17:46.257] assign_globals() ... done
[16:17:46.257] plan(): Setting new future strategy stack:
[16:17:46.257] List of future strategies:
[16:17:46.257] 1. sequential:
[16:17:46.257]    - args: function (..., envir = parent.frame())
[16:17:46.257]    - tweaked: FALSE
[16:17:46.257]    - call: NULL
[16:17:46.259] plan(): nbrOfWorkers() = 1
[16:17:46.262] plan(): Setting new future strategy stack:
[16:17:46.262] List of future strategies:
[16:17:46.262] 1. sequential:
[16:17:46.262]    - args: function (..., envir = parent.frame())
[16:17:46.262]    - tweaked: FALSE
[16:17:46.262]    - call: plan(strategy)
[16:17:46.262] plan(): nbrOfWorkers() = 1
[16:17:46.262] SequentialFuture started (and completed)
[16:17:46.262] - Launch lazy future ... done
[16:17:46.262] run() for ‘SequentialFuture’ ... done
[16:17:46.263] Created future:
[16:17:46.263] SequentialFuture:
[16:17:46.263] Label: ‘future_by-1’
[16:17:46.263] Expression:
[16:17:46.263] {
[16:17:46.263]     do.call(function(...) {
[16:17:46.263]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.263]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.263]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.263]             on.exit(options(oopts), add = TRUE)
[16:17:46.263]         }
[16:17:46.263]         {
[16:17:46.263]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.263]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.263]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.263]             })
[16:17:46.263]         }
[16:17:46.263]     }, args = future.call.arguments)
[16:17:46.263] }
[16:17:46.263] Lazy evaluation: FALSE
[16:17:46.263] Asynchronous evaluation: FALSE
[16:17:46.263] Local evaluation: TRUE
[16:17:46.263] Environment: 0x55b565b766f8
[16:17:46.263] Capture standard output: TRUE
[16:17:46.263] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:46.263] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[16:17:46.263] Packages: 1 packages (‘stats’)
[16:17:46.263] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:46.263] Resolved: TRUE
[16:17:46.263] Value: 25.57 KiB of class ‘list’
[16:17:46.263] Early signaling: FALSE
[16:17:46.263] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:46.263] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.264] Chunk #1 of 1 ... DONE
[16:17:46.264] Launching 1 futures (chunks) ... DONE
[16:17:46.264] Resolving 1 futures (chunks) ...
[16:17:46.264] resolve() on list ...
[16:17:46.265]  recursive: 0
[16:17:46.265]  length: 1
[16:17:46.265] 
[16:17:46.265] resolved() for ‘SequentialFuture’ ...
[16:17:46.265] - state: ‘finished’
[16:17:46.265] - run: TRUE
[16:17:46.265] - result: ‘FutureResult’
[16:17:46.265] resolved() for ‘SequentialFuture’ ... done
[16:17:46.265] Future #1
[16:17:46.265] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:46.266] - nx: 1
[16:17:46.266] - relay: TRUE
[16:17:46.266] - stdout: TRUE
[16:17:46.266] - signal: TRUE
[16:17:46.266] - resignal: FALSE
[16:17:46.266] - force: TRUE
[16:17:46.266] - relayed: [n=1] FALSE
[16:17:46.266] - queued futures: [n=1] FALSE
[16:17:46.266]  - until=1
[16:17:46.266]  - relaying element #1
[16:17:46.266] - relayed: [n=1] TRUE
[16:17:46.267] - queued futures: [n=1] TRUE
[16:17:46.267] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:46.267]  length: 0 (resolved future 1)
[16:17:46.267] Relaying remaining futures
[16:17:46.267] signalConditionsASAP(NULL, pos=0) ...
[16:17:46.267] - nx: 1
[16:17:46.267] - relay: TRUE
[16:17:46.267] - stdout: TRUE
[16:17:46.267] - signal: TRUE
[16:17:46.267] - resignal: FALSE
[16:17:46.267] - force: TRUE
[16:17:46.267] - relayed: [n=1] TRUE
[16:17:46.268] - queued futures: [n=1] TRUE
 - flush all
[16:17:46.268] - relayed: [n=1] TRUE
[16:17:46.268] - queued futures: [n=1] TRUE
[16:17:46.268] signalConditionsASAP(NULL, pos=0) ... done
[16:17:46.268] resolve() on list ... DONE
[16:17:46.268]  - Number of value chunks collected: 1
[16:17:46.268] Resolving 1 futures (chunks) ... DONE
[16:17:46.268] Reducing values from 1 chunks ...
[16:17:46.268]  - Number of values collected after concatenation: 3
[16:17:46.268]  - Number of values expected: 3
[16:17:46.269] Reducing values from 1 chunks ... DONE
[16:17:46.269] future_lapply() ... DONE
[16:17:46.269] future_by_internal() ... DONE
[16:17:46.269] future_by_internal() ...
[16:17:46.269] future_lapply() ...
[16:17:46.270] Number of chunks: 1
[16:17:46.270] getGlobalsAndPackagesXApply() ...
[16:17:46.270]  - future.globals: TRUE
[16:17:46.270] getGlobalsAndPackages() ...
[16:17:46.270] Searching for globals...
[16:17:46.271] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:46.271] Searching for globals ... DONE
[16:17:46.272] Resolving globals: FALSE
[16:17:46.272] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:46.272] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:46.272] - globals: [1] ‘FUN’
[16:17:46.272] 
[16:17:46.273] getGlobalsAndPackages() ... DONE
[16:17:46.273]  - globals found/used: [n=1] ‘FUN’
[16:17:46.273]  - needed namespaces: [n=0] 
[16:17:46.273] Finding globals ... DONE
[16:17:46.273]  - use_args: TRUE
[16:17:46.273]  - Getting '...' globals ...
[16:17:46.273] resolve() on list ...
[16:17:46.273]  recursive: 0
[16:17:46.273]  length: 1
[16:17:46.274]  elements: ‘...’
[16:17:46.274]  length: 0 (resolved future 1)
[16:17:46.274] resolve() on list ... DONE
[16:17:46.274]    - '...' content: [n=0] 
[16:17:46.274] List of 1
[16:17:46.274]  $ ...: list()
[16:17:46.274]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.274]  - attr(*, "where")=List of 1
[16:17:46.274]   ..$ ...:<environment: 0x55b567cb0bf8> 
[16:17:46.274]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.274]  - attr(*, "resolved")= logi TRUE
[16:17:46.274]  - attr(*, "total_size")= num NA
[16:17:46.276]  - Getting '...' globals ... DONE
[16:17:46.277] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:46.277] List of 2
[16:17:46.277]  $ ...future.FUN:function (object, ...)  
[16:17:46.277]  $ ...          : list()
[16:17:46.277]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.277]  - attr(*, "where")=List of 2
[16:17:46.277]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:46.277]   ..$ ...          :<environment: 0x55b567cb0bf8> 
[16:17:46.277]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.277]  - attr(*, "resolved")= logi FALSE
[16:17:46.277]  - attr(*, "total_size")= num 1240
[16:17:46.281] Packages to be attached in all futures: [n=0] 
[16:17:46.281] getGlobalsAndPackagesXApply() ... DONE
[16:17:46.281] Number of futures (= number of chunks): 1
[16:17:46.281] Launching 1 futures (chunks) ...
[16:17:46.281] Chunk #1 of 1 ...
[16:17:46.281]  - Finding globals in 'X' for chunk #1 ...
[16:17:46.281] getGlobalsAndPackages() ...
[16:17:46.281] Searching for globals...
[16:17:46.282] 
[16:17:46.282] Searching for globals ... DONE
[16:17:46.282] - globals: [0] <none>
[16:17:46.282] getGlobalsAndPackages() ... DONE
[16:17:46.282]    + additional globals found: [n=0] 
[16:17:46.282]    + additional namespaces needed: [n=0] 
[16:17:46.282]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:46.282]  - seeds: <none>
[16:17:46.282]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.283] getGlobalsAndPackages() ...
[16:17:46.283] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.283] Resolving globals: FALSE
[16:17:46.283] Tweak future expression to call with '...' arguments ...
[16:17:46.283] {
[16:17:46.283]     do.call(function(...) {
[16:17:46.283]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.283]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.283]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.283]             on.exit(options(oopts), add = TRUE)
[16:17:46.283]         }
[16:17:46.283]         {
[16:17:46.283]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.283]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.283]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.283]             })
[16:17:46.283]         }
[16:17:46.283]     }, args = future.call.arguments)
[16:17:46.283] }
[16:17:46.283] Tweak future expression to call with '...' arguments ... DONE
[16:17:46.284] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.284] 
[16:17:46.284] getGlobalsAndPackages() ... DONE
[16:17:46.284] run() for ‘Future’ ...
[16:17:46.284] - state: ‘created’
[16:17:46.284] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:17:46.285] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.285] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:46.285]   - Field: ‘label’
[16:17:46.285]   - Field: ‘local’
[16:17:46.285]   - Field: ‘owner’
[16:17:46.285]   - Field: ‘envir’
[16:17:46.285]   - Field: ‘packages’
[16:17:46.285]   - Field: ‘gc’
[16:17:46.285]   - Field: ‘conditions’
[16:17:46.286]   - Field: ‘expr’
[16:17:46.286]   - Field: ‘uuid’
[16:17:46.286]   - Field: ‘seed’
[16:17:46.286]   - Field: ‘version’
[16:17:46.286]   - Field: ‘result’
[16:17:46.286]   - Field: ‘asynchronous’
[16:17:46.286]   - Field: ‘calls’
[16:17:46.286]   - Field: ‘globals’
[16:17:46.286]   - Field: ‘stdout’
[16:17:46.286]   - Field: ‘earlySignal’
[16:17:46.286]   - Field: ‘lazy’
[16:17:46.287]   - Field: ‘state’
[16:17:46.287] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:46.287] - Launch lazy future ...
[16:17:46.287] Packages needed by the future expression (n = 0): <none>
[16:17:46.287] Packages needed by future strategies (n = 0): <none>
[16:17:46.287] {
[16:17:46.287]     {
[16:17:46.287]         {
[16:17:46.287]             ...future.startTime <- base::Sys.time()
[16:17:46.287]             {
[16:17:46.287]                 {
[16:17:46.287]                   {
[16:17:46.287]                     base::local({
[16:17:46.287]                       has_future <- base::requireNamespace("future", 
[16:17:46.287]                         quietly = TRUE)
[16:17:46.287]                       if (has_future) {
[16:17:46.287]                         ns <- base::getNamespace("future")
[16:17:46.287]                         version <- ns[[".package"]][["version"]]
[16:17:46.287]                         if (is.null(version)) 
[16:17:46.287]                           version <- utils::packageVersion("future")
[16:17:46.287]                       }
[16:17:46.287]                       else {
[16:17:46.287]                         version <- NULL
[16:17:46.287]                       }
[16:17:46.287]                       if (!has_future || version < "1.8.0") {
[16:17:46.287]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:46.287]                           "", base::R.version$version.string), 
[16:17:46.287]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:46.287]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:46.287]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:46.287]                             "release", "version")], collapse = " "), 
[16:17:46.287]                           hostname = base::Sys.info()[["nodename"]])
[16:17:46.287]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:46.287]                           info)
[16:17:46.287]                         info <- base::paste(info, collapse = "; ")
[16:17:46.287]                         if (!has_future) {
[16:17:46.287]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:46.287]                             info)
[16:17:46.287]                         }
[16:17:46.287]                         else {
[16:17:46.287]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:46.287]                             info, version)
[16:17:46.287]                         }
[16:17:46.287]                         base::stop(msg)
[16:17:46.287]                       }
[16:17:46.287]                     })
[16:17:46.287]                   }
[16:17:46.287]                   ...future.strategy.old <- future::plan("list")
[16:17:46.287]                   options(future.plan = NULL)
[16:17:46.287]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.287]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:46.287]                 }
[16:17:46.287]                 ...future.workdir <- getwd()
[16:17:46.287]             }
[16:17:46.287]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:46.287]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:46.287]         }
[16:17:46.287]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:46.287]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:46.287]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:46.287]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:46.287]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:46.287]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:46.287]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:46.287]             base::names(...future.oldOptions))
[16:17:46.287]     }
[16:17:46.287]     if (FALSE) {
[16:17:46.287]     }
[16:17:46.287]     else {
[16:17:46.287]         if (TRUE) {
[16:17:46.287]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:46.287]                 open = "w")
[16:17:46.287]         }
[16:17:46.287]         else {
[16:17:46.287]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:46.287]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:46.287]         }
[16:17:46.287]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:46.287]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:46.287]             base::sink(type = "output", split = FALSE)
[16:17:46.287]             base::close(...future.stdout)
[16:17:46.287]         }, add = TRUE)
[16:17:46.287]     }
[16:17:46.287]     ...future.frame <- base::sys.nframe()
[16:17:46.287]     ...future.conditions <- base::list()
[16:17:46.287]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:46.287]     if (FALSE) {
[16:17:46.287]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:46.287]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:46.287]     }
[16:17:46.287]     ...future.result <- base::tryCatch({
[16:17:46.287]         base::withCallingHandlers({
[16:17:46.287]             ...future.value <- base::withVisible(base::local({
[16:17:46.287]                 do.call(function(...) {
[16:17:46.287]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.287]                   if (!identical(...future.globals.maxSize.org, 
[16:17:46.287]                     ...future.globals.maxSize)) {
[16:17:46.287]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.287]                     on.exit(options(oopts), add = TRUE)
[16:17:46.287]                   }
[16:17:46.287]                   {
[16:17:46.287]                     lapply(seq_along(...future.elements_ii), 
[16:17:46.287]                       FUN = function(jj) {
[16:17:46.287]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.287]                         ...future.FUN(...future.X_jj, ...)
[16:17:46.287]                       })
[16:17:46.287]                   }
[16:17:46.287]                 }, args = future.call.arguments)
[16:17:46.287]             }))
[16:17:46.287]             future::FutureResult(value = ...future.value$value, 
[16:17:46.287]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.287]                   ...future.rng), globalenv = if (FALSE) 
[16:17:46.287]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:46.287]                     ...future.globalenv.names))
[16:17:46.287]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:46.287]         }, condition = base::local({
[16:17:46.287]             c <- base::c
[16:17:46.287]             inherits <- base::inherits
[16:17:46.287]             invokeRestart <- base::invokeRestart
[16:17:46.287]             length <- base::length
[16:17:46.287]             list <- base::list
[16:17:46.287]             seq.int <- base::seq.int
[16:17:46.287]             signalCondition <- base::signalCondition
[16:17:46.287]             sys.calls <- base::sys.calls
[16:17:46.287]             `[[` <- base::`[[`
[16:17:46.287]             `+` <- base::`+`
[16:17:46.287]             `<<-` <- base::`<<-`
[16:17:46.287]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:46.287]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:46.287]                   3L)]
[16:17:46.287]             }
[16:17:46.287]             function(cond) {
[16:17:46.287]                 is_error <- inherits(cond, "error")
[16:17:46.287]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:46.287]                   NULL)
[16:17:46.287]                 if (is_error) {
[16:17:46.287]                   sessionInformation <- function() {
[16:17:46.287]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:46.287]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:46.287]                       search = base::search(), system = base::Sys.info())
[16:17:46.287]                   }
[16:17:46.287]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.287]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:46.287]                     cond$call), session = sessionInformation(), 
[16:17:46.287]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:46.287]                   signalCondition(cond)
[16:17:46.287]                 }
[16:17:46.287]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:46.287]                 "immediateCondition"))) {
[16:17:46.287]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:46.287]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.287]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:46.287]                   if (TRUE && !signal) {
[16:17:46.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.287]                     {
[16:17:46.287]                       inherits <- base::inherits
[16:17:46.287]                       invokeRestart <- base::invokeRestart
[16:17:46.287]                       is.null <- base::is.null
[16:17:46.287]                       muffled <- FALSE
[16:17:46.287]                       if (inherits(cond, "message")) {
[16:17:46.287]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.287]                         if (muffled) 
[16:17:46.287]                           invokeRestart("muffleMessage")
[16:17:46.287]                       }
[16:17:46.287]                       else if (inherits(cond, "warning")) {
[16:17:46.287]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.287]                         if (muffled) 
[16:17:46.287]                           invokeRestart("muffleWarning")
[16:17:46.287]                       }
[16:17:46.287]                       else if (inherits(cond, "condition")) {
[16:17:46.287]                         if (!is.null(pattern)) {
[16:17:46.287]                           computeRestarts <- base::computeRestarts
[16:17:46.287]                           grepl <- base::grepl
[16:17:46.287]                           restarts <- computeRestarts(cond)
[16:17:46.287]                           for (restart in restarts) {
[16:17:46.287]                             name <- restart$name
[16:17:46.287]                             if (is.null(name)) 
[16:17:46.287]                               next
[16:17:46.287]                             if (!grepl(pattern, name)) 
[16:17:46.287]                               next
[16:17:46.287]                             invokeRestart(restart)
[16:17:46.287]                             muffled <- TRUE
[16:17:46.287]                             break
[16:17:46.287]                           }
[16:17:46.287]                         }
[16:17:46.287]                       }
[16:17:46.287]                       invisible(muffled)
[16:17:46.287]                     }
[16:17:46.287]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.287]                   }
[16:17:46.287]                 }
[16:17:46.287]                 else {
[16:17:46.287]                   if (TRUE) {
[16:17:46.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.287]                     {
[16:17:46.287]                       inherits <- base::inherits
[16:17:46.287]                       invokeRestart <- base::invokeRestart
[16:17:46.287]                       is.null <- base::is.null
[16:17:46.287]                       muffled <- FALSE
[16:17:46.287]                       if (inherits(cond, "message")) {
[16:17:46.287]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.287]                         if (muffled) 
[16:17:46.287]                           invokeRestart("muffleMessage")
[16:17:46.287]                       }
[16:17:46.287]                       else if (inherits(cond, "warning")) {
[16:17:46.287]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.287]                         if (muffled) 
[16:17:46.287]                           invokeRestart("muffleWarning")
[16:17:46.287]                       }
[16:17:46.287]                       else if (inherits(cond, "condition")) {
[16:17:46.287]                         if (!is.null(pattern)) {
[16:17:46.287]                           computeRestarts <- base::computeRestarts
[16:17:46.287]                           grepl <- base::grepl
[16:17:46.287]                           restarts <- computeRestarts(cond)
[16:17:46.287]                           for (restart in restarts) {
[16:17:46.287]                             name <- restart$name
[16:17:46.287]                             if (is.null(name)) 
[16:17:46.287]                               next
[16:17:46.287]                             if (!grepl(pattern, name)) 
[16:17:46.287]                               next
[16:17:46.287]                             invokeRestart(restart)
[16:17:46.287]                             muffled <- TRUE
[16:17:46.287]                             break
[16:17:46.287]                           }
[16:17:46.287]                         }
[16:17:46.287]                       }
[16:17:46.287]                       invisible(muffled)
[16:17:46.287]                     }
[16:17:46.287]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.287]                   }
[16:17:46.287]                 }
[16:17:46.287]             }
[16:17:46.287]         }))
[16:17:46.287]     }, error = function(ex) {
[16:17:46.287]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:46.287]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.287]                 ...future.rng), started = ...future.startTime, 
[16:17:46.287]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:46.287]             version = "1.8"), class = "FutureResult")
[16:17:46.287]     }, finally = {
[16:17:46.287]         if (!identical(...future.workdir, getwd())) 
[16:17:46.287]             setwd(...future.workdir)
[16:17:46.287]         {
[16:17:46.287]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:46.287]                 ...future.oldOptions$nwarnings <- NULL
[16:17:46.287]             }
[16:17:46.287]             base::options(...future.oldOptions)
[16:17:46.287]             if (.Platform$OS.type == "windows") {
[16:17:46.287]                 old_names <- names(...future.oldEnvVars)
[16:17:46.287]                 envs <- base::Sys.getenv()
[16:17:46.287]                 names <- names(envs)
[16:17:46.287]                 common <- intersect(names, old_names)
[16:17:46.287]                 added <- setdiff(names, old_names)
[16:17:46.287]                 removed <- setdiff(old_names, names)
[16:17:46.287]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:46.287]                   envs[common]]
[16:17:46.287]                 NAMES <- toupper(changed)
[16:17:46.287]                 args <- list()
[16:17:46.287]                 for (kk in seq_along(NAMES)) {
[16:17:46.287]                   name <- changed[[kk]]
[16:17:46.287]                   NAME <- NAMES[[kk]]
[16:17:46.287]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.287]                     next
[16:17:46.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.287]                 }
[16:17:46.287]                 NAMES <- toupper(added)
[16:17:46.287]                 for (kk in seq_along(NAMES)) {
[16:17:46.287]                   name <- added[[kk]]
[16:17:46.287]                   NAME <- NAMES[[kk]]
[16:17:46.287]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.287]                     next
[16:17:46.287]                   args[[name]] <- ""
[16:17:46.287]                 }
[16:17:46.287]                 NAMES <- toupper(removed)
[16:17:46.287]                 for (kk in seq_along(NAMES)) {
[16:17:46.287]                   name <- removed[[kk]]
[16:17:46.287]                   NAME <- NAMES[[kk]]
[16:17:46.287]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.287]                     next
[16:17:46.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.287]                 }
[16:17:46.287]                 if (length(args) > 0) 
[16:17:46.287]                   base::do.call(base::Sys.setenv, args = args)
[16:17:46.287]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:46.287]             }
[16:17:46.287]             else {
[16:17:46.287]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:46.287]             }
[16:17:46.287]             {
[16:17:46.287]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:46.287]                   0L) {
[16:17:46.287]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:46.287]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:46.287]                   base::options(opts)
[16:17:46.287]                 }
[16:17:46.287]                 {
[16:17:46.287]                   {
[16:17:46.287]                     NULL
[16:17:46.287]                     RNGkind("Mersenne-Twister")
[16:17:46.287]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:46.287]                       inherits = FALSE)
[16:17:46.287]                   }
[16:17:46.287]                   options(future.plan = NULL)
[16:17:46.287]                   if (is.na(NA_character_)) 
[16:17:46.287]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.287]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:46.287]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:46.287]                     .init = FALSE)
[16:17:46.287]                 }
[16:17:46.287]             }
[16:17:46.287]         }
[16:17:46.287]     })
[16:17:46.287]     if (TRUE) {
[16:17:46.287]         base::sink(type = "output", split = FALSE)
[16:17:46.287]         if (TRUE) {
[16:17:46.287]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:46.287]         }
[16:17:46.287]         else {
[16:17:46.287]             ...future.result["stdout"] <- base::list(NULL)
[16:17:46.287]         }
[16:17:46.287]         base::close(...future.stdout)
[16:17:46.287]         ...future.stdout <- NULL
[16:17:46.287]     }
[16:17:46.287]     ...future.result$conditions <- ...future.conditions
[16:17:46.287]     ...future.result$finished <- base::Sys.time()
[16:17:46.287]     ...future.result
[16:17:46.287] }
[16:17:46.289] assign_globals() ...
[16:17:46.289] List of 5
[16:17:46.289]  $ ...future.FUN            :function (object, ...)  
[16:17:46.289]  $ future.call.arguments    : list()
[16:17:46.289]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.289]  $ ...future.elements_ii    :List of 3
[16:17:46.289]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.289]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:17:46.289]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.289]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:46.289]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.289]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:17:46.289]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.289]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:17:46.289]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.289]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:17:46.289]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.289]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:17:46.289]  $ ...future.seeds_ii       : NULL
[16:17:46.289]  $ ...future.globals.maxSize: NULL
[16:17:46.289]  - attr(*, "where")=List of 5
[16:17:46.289]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:46.289]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:46.289]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:46.289]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:46.289]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:46.289]  - attr(*, "resolved")= logi FALSE
[16:17:46.289]  - attr(*, "total_size")= num 1240
[16:17:46.289]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.289]  - attr(*, "already-done")= logi TRUE
[16:17:46.298] - copied ‘...future.FUN’ to environment
[16:17:46.298] - copied ‘future.call.arguments’ to environment
[16:17:46.298] - copied ‘...future.elements_ii’ to environment
[16:17:46.298] - copied ‘...future.seeds_ii’ to environment
[16:17:46.298] - copied ‘...future.globals.maxSize’ to environment
[16:17:46.300] assign_globals() ... done
[16:17:46.300] plan(): Setting new future strategy stack:
[16:17:46.300] List of future strategies:
[16:17:46.300] 1. sequential:
[16:17:46.300]    - args: function (..., envir = parent.frame())
[16:17:46.300]    - tweaked: FALSE
[16:17:46.300]    - call: NULL
[16:17:46.301] plan(): nbrOfWorkers() = 1
[16:17:46.303] plan(): Setting new future strategy stack:
[16:17:46.303] List of future strategies:
[16:17:46.303] 1. sequential:
[16:17:46.303]    - args: function (..., envir = parent.frame())
[16:17:46.303]    - tweaked: FALSE
[16:17:46.303]    - call: plan(strategy)
[16:17:46.304] plan(): nbrOfWorkers() = 1
[16:17:46.304] SequentialFuture started (and completed)
[16:17:46.304] - Launch lazy future ... done
[16:17:46.304] run() for ‘SequentialFuture’ ... done
[16:17:46.304] Created future:
[16:17:46.304] SequentialFuture:
[16:17:46.304] Label: ‘future_by-1’
[16:17:46.304] Expression:
[16:17:46.304] {
[16:17:46.304]     do.call(function(...) {
[16:17:46.304]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.304]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.304]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.304]             on.exit(options(oopts), add = TRUE)
[16:17:46.304]         }
[16:17:46.304]         {
[16:17:46.304]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.304]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.304]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.304]             })
[16:17:46.304]         }
[16:17:46.304]     }, args = future.call.arguments)
[16:17:46.304] }
[16:17:46.304] Lazy evaluation: FALSE
[16:17:46.304] Asynchronous evaluation: FALSE
[16:17:46.304] Local evaluation: TRUE
[16:17:46.304] Environment: 0x55b567c81f88
[16:17:46.304] Capture standard output: TRUE
[16:17:46.304] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:46.304] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:46.304] Packages: <none>
[16:17:46.304] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:46.304] Resolved: TRUE
[16:17:46.304] Value: 5.37 KiB of class ‘list’
[16:17:46.304] Early signaling: FALSE
[16:17:46.304] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:46.304] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.305] Chunk #1 of 1 ... DONE
[16:17:46.306] Launching 1 futures (chunks) ... DONE
[16:17:46.306] Resolving 1 futures (chunks) ...
[16:17:46.306] resolve() on list ...
[16:17:46.306]  recursive: 0
[16:17:46.306]  length: 1
[16:17:46.306] 
[16:17:46.306] resolved() for ‘SequentialFuture’ ...
[16:17:46.306] - state: ‘finished’
[16:17:46.306] - run: TRUE
[16:17:46.306] - result: ‘FutureResult’
[16:17:46.307] resolved() for ‘SequentialFuture’ ... done
[16:17:46.307] Future #1
[16:17:46.307] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:46.307] - nx: 1
[16:17:46.307] - relay: TRUE
[16:17:46.307] - stdout: TRUE
[16:17:46.307] - signal: TRUE
[16:17:46.307] - resignal: FALSE
[16:17:46.307] - force: TRUE
[16:17:46.307] - relayed: [n=1] FALSE
[16:17:46.307] - queued futures: [n=1] FALSE
[16:17:46.308]  - until=1
[16:17:46.308]  - relaying element #1
[16:17:46.308] - relayed: [n=1] TRUE
[16:17:46.308] - queued futures: [n=1] TRUE
[16:17:46.308] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:46.308]  length: 0 (resolved future 1)
[16:17:46.308] Relaying remaining futures
[16:17:46.308] signalConditionsASAP(NULL, pos=0) ...
[16:17:46.308] - nx: 1
[16:17:46.309] - relay: TRUE
[16:17:46.309] - stdout: TRUE
[16:17:46.309] - signal: TRUE
[16:17:46.309] - resignal: FALSE
[16:17:46.309] - force: TRUE
[16:17:46.309] - relayed: [n=1] TRUE
[16:17:46.309] - queued futures: [n=1] TRUE
 - flush all
[16:17:46.309] - relayed: [n=1] TRUE
[16:17:46.309] - queued futures: [n=1] TRUE
[16:17:46.309] signalConditionsASAP(NULL, pos=0) ... done
[16:17:46.309] resolve() on list ... DONE
[16:17:46.310]  - Number of value chunks collected: 1
[16:17:46.310] Resolving 1 futures (chunks) ... DONE
[16:17:46.310] Reducing values from 1 chunks ...
[16:17:46.310]  - Number of values collected after concatenation: 3
[16:17:46.310]  - Number of values expected: 3
[16:17:46.310] Reducing values from 1 chunks ... DONE
[16:17:46.310] future_lapply() ... DONE
[16:17:46.310] future_by_internal() ... DONE
[16:17:46.312] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[16:17:46.313] future_lapply() ...
[16:17:46.313] Number of chunks: 1
[16:17:46.313] getGlobalsAndPackagesXApply() ...
[16:17:46.313]  - future.globals: TRUE
[16:17:46.314] getGlobalsAndPackages() ...
[16:17:46.314] Searching for globals...
[16:17:46.315] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:46.315] Searching for globals ... DONE
[16:17:46.315] Resolving globals: FALSE
[16:17:46.315] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:46.316] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:46.316] - globals: [1] ‘FUN’
[16:17:46.316] 
[16:17:46.316] getGlobalsAndPackages() ... DONE
[16:17:46.316]  - globals found/used: [n=1] ‘FUN’
[16:17:46.316]  - needed namespaces: [n=0] 
[16:17:46.316] Finding globals ... DONE
[16:17:46.316]  - use_args: TRUE
[16:17:46.316]  - Getting '...' globals ...
[16:17:46.317] resolve() on list ...
[16:17:46.317]  recursive: 0
[16:17:46.317]  length: 1
[16:17:46.317]  elements: ‘...’
[16:17:46.317]  length: 0 (resolved future 1)
[16:17:46.317] resolve() on list ... DONE
[16:17:46.317]    - '...' content: [n=0] 
[16:17:46.317] List of 1
[16:17:46.317]  $ ...: list()
[16:17:46.317]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.317]  - attr(*, "where")=List of 1
[16:17:46.317]   ..$ ...:<environment: 0x55b567e2a0f8> 
[16:17:46.317]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.317]  - attr(*, "resolved")= logi TRUE
[16:17:46.317]  - attr(*, "total_size")= num NA
[16:17:46.322]  - Getting '...' globals ... DONE
[16:17:46.322] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:46.322] List of 2
[16:17:46.322]  $ ...future.FUN:function (object, ...)  
[16:17:46.322]  $ ...          : list()
[16:17:46.322]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.322]  - attr(*, "where")=List of 2
[16:17:46.322]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:46.322]   ..$ ...          :<environment: 0x55b567e2a0f8> 
[16:17:46.322]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.322]  - attr(*, "resolved")= logi FALSE
[16:17:46.322]  - attr(*, "total_size")= num 1240
[16:17:46.325] Packages to be attached in all futures: [n=0] 
[16:17:46.325] getGlobalsAndPackagesXApply() ... DONE
[16:17:46.325] Number of futures (= number of chunks): 1
[16:17:46.325] Launching 1 futures (chunks) ...
[16:17:46.325] Chunk #1 of 1 ...
[16:17:46.325]  - Finding globals in 'X' for chunk #1 ...
[16:17:46.325] getGlobalsAndPackages() ...
[16:17:46.325] Searching for globals...
[16:17:46.326] 
[16:17:46.326] Searching for globals ... DONE
[16:17:46.326] - globals: [0] <none>
[16:17:46.326] getGlobalsAndPackages() ... DONE
[16:17:46.326]    + additional globals found: [n=0] 
[16:17:46.326]    + additional namespaces needed: [n=0] 
[16:17:46.326]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:46.327]  - seeds: <none>
[16:17:46.327]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.327] getGlobalsAndPackages() ...
[16:17:46.327] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.327] Resolving globals: FALSE
[16:17:46.327] Tweak future expression to call with '...' arguments ...
[16:17:46.327] {
[16:17:46.327]     do.call(function(...) {
[16:17:46.327]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.327]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.327]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.327]             on.exit(options(oopts), add = TRUE)
[16:17:46.327]         }
[16:17:46.327]         {
[16:17:46.327]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.327]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.327]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.327]             })
[16:17:46.327]         }
[16:17:46.327]     }, args = future.call.arguments)
[16:17:46.327] }
[16:17:46.327] Tweak future expression to call with '...' arguments ... DONE
[16:17:46.328] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.328] 
[16:17:46.328] getGlobalsAndPackages() ... DONE
[16:17:46.328] run() for ‘Future’ ...
[16:17:46.328] - state: ‘created’
[16:17:46.329] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:17:46.329] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.329] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:46.329]   - Field: ‘label’
[16:17:46.329]   - Field: ‘local’
[16:17:46.329]   - Field: ‘owner’
[16:17:46.329]   - Field: ‘envir’
[16:17:46.329]   - Field: ‘packages’
[16:17:46.330]   - Field: ‘gc’
[16:17:46.330]   - Field: ‘conditions’
[16:17:46.330]   - Field: ‘expr’
[16:17:46.330]   - Field: ‘uuid’
[16:17:46.330]   - Field: ‘seed’
[16:17:46.330]   - Field: ‘version’
[16:17:46.330]   - Field: ‘result’
[16:17:46.330]   - Field: ‘asynchronous’
[16:17:46.330]   - Field: ‘calls’
[16:17:46.330]   - Field: ‘globals’
[16:17:46.330]   - Field: ‘stdout’
[16:17:46.331]   - Field: ‘earlySignal’
[16:17:46.331]   - Field: ‘lazy’
[16:17:46.331]   - Field: ‘state’
[16:17:46.331] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:46.331] - Launch lazy future ...
[16:17:46.331] Packages needed by the future expression (n = 0): <none>
[16:17:46.331] Packages needed by future strategies (n = 0): <none>
[16:17:46.332] {
[16:17:46.332]     {
[16:17:46.332]         {
[16:17:46.332]             ...future.startTime <- base::Sys.time()
[16:17:46.332]             {
[16:17:46.332]                 {
[16:17:46.332]                   {
[16:17:46.332]                     base::local({
[16:17:46.332]                       has_future <- base::requireNamespace("future", 
[16:17:46.332]                         quietly = TRUE)
[16:17:46.332]                       if (has_future) {
[16:17:46.332]                         ns <- base::getNamespace("future")
[16:17:46.332]                         version <- ns[[".package"]][["version"]]
[16:17:46.332]                         if (is.null(version)) 
[16:17:46.332]                           version <- utils::packageVersion("future")
[16:17:46.332]                       }
[16:17:46.332]                       else {
[16:17:46.332]                         version <- NULL
[16:17:46.332]                       }
[16:17:46.332]                       if (!has_future || version < "1.8.0") {
[16:17:46.332]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:46.332]                           "", base::R.version$version.string), 
[16:17:46.332]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:46.332]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:46.332]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:46.332]                             "release", "version")], collapse = " "), 
[16:17:46.332]                           hostname = base::Sys.info()[["nodename"]])
[16:17:46.332]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:46.332]                           info)
[16:17:46.332]                         info <- base::paste(info, collapse = "; ")
[16:17:46.332]                         if (!has_future) {
[16:17:46.332]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:46.332]                             info)
[16:17:46.332]                         }
[16:17:46.332]                         else {
[16:17:46.332]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:46.332]                             info, version)
[16:17:46.332]                         }
[16:17:46.332]                         base::stop(msg)
[16:17:46.332]                       }
[16:17:46.332]                     })
[16:17:46.332]                   }
[16:17:46.332]                   ...future.strategy.old <- future::plan("list")
[16:17:46.332]                   options(future.plan = NULL)
[16:17:46.332]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.332]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:46.332]                 }
[16:17:46.332]                 ...future.workdir <- getwd()
[16:17:46.332]             }
[16:17:46.332]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:46.332]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:46.332]         }
[16:17:46.332]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:46.332]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:46.332]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:46.332]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:46.332]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:46.332]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:46.332]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:46.332]             base::names(...future.oldOptions))
[16:17:46.332]     }
[16:17:46.332]     if (FALSE) {
[16:17:46.332]     }
[16:17:46.332]     else {
[16:17:46.332]         if (TRUE) {
[16:17:46.332]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:46.332]                 open = "w")
[16:17:46.332]         }
[16:17:46.332]         else {
[16:17:46.332]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:46.332]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:46.332]         }
[16:17:46.332]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:46.332]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:46.332]             base::sink(type = "output", split = FALSE)
[16:17:46.332]             base::close(...future.stdout)
[16:17:46.332]         }, add = TRUE)
[16:17:46.332]     }
[16:17:46.332]     ...future.frame <- base::sys.nframe()
[16:17:46.332]     ...future.conditions <- base::list()
[16:17:46.332]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:46.332]     if (FALSE) {
[16:17:46.332]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:46.332]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:46.332]     }
[16:17:46.332]     ...future.result <- base::tryCatch({
[16:17:46.332]         base::withCallingHandlers({
[16:17:46.332]             ...future.value <- base::withVisible(base::local({
[16:17:46.332]                 do.call(function(...) {
[16:17:46.332]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.332]                   if (!identical(...future.globals.maxSize.org, 
[16:17:46.332]                     ...future.globals.maxSize)) {
[16:17:46.332]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.332]                     on.exit(options(oopts), add = TRUE)
[16:17:46.332]                   }
[16:17:46.332]                   {
[16:17:46.332]                     lapply(seq_along(...future.elements_ii), 
[16:17:46.332]                       FUN = function(jj) {
[16:17:46.332]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.332]                         ...future.FUN(...future.X_jj, ...)
[16:17:46.332]                       })
[16:17:46.332]                   }
[16:17:46.332]                 }, args = future.call.arguments)
[16:17:46.332]             }))
[16:17:46.332]             future::FutureResult(value = ...future.value$value, 
[16:17:46.332]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.332]                   ...future.rng), globalenv = if (FALSE) 
[16:17:46.332]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:46.332]                     ...future.globalenv.names))
[16:17:46.332]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:46.332]         }, condition = base::local({
[16:17:46.332]             c <- base::c
[16:17:46.332]             inherits <- base::inherits
[16:17:46.332]             invokeRestart <- base::invokeRestart
[16:17:46.332]             length <- base::length
[16:17:46.332]             list <- base::list
[16:17:46.332]             seq.int <- base::seq.int
[16:17:46.332]             signalCondition <- base::signalCondition
[16:17:46.332]             sys.calls <- base::sys.calls
[16:17:46.332]             `[[` <- base::`[[`
[16:17:46.332]             `+` <- base::`+`
[16:17:46.332]             `<<-` <- base::`<<-`
[16:17:46.332]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:46.332]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:46.332]                   3L)]
[16:17:46.332]             }
[16:17:46.332]             function(cond) {
[16:17:46.332]                 is_error <- inherits(cond, "error")
[16:17:46.332]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:46.332]                   NULL)
[16:17:46.332]                 if (is_error) {
[16:17:46.332]                   sessionInformation <- function() {
[16:17:46.332]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:46.332]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:46.332]                       search = base::search(), system = base::Sys.info())
[16:17:46.332]                   }
[16:17:46.332]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.332]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:46.332]                     cond$call), session = sessionInformation(), 
[16:17:46.332]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:46.332]                   signalCondition(cond)
[16:17:46.332]                 }
[16:17:46.332]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:46.332]                 "immediateCondition"))) {
[16:17:46.332]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:46.332]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.332]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:46.332]                   if (TRUE && !signal) {
[16:17:46.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.332]                     {
[16:17:46.332]                       inherits <- base::inherits
[16:17:46.332]                       invokeRestart <- base::invokeRestart
[16:17:46.332]                       is.null <- base::is.null
[16:17:46.332]                       muffled <- FALSE
[16:17:46.332]                       if (inherits(cond, "message")) {
[16:17:46.332]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.332]                         if (muffled) 
[16:17:46.332]                           invokeRestart("muffleMessage")
[16:17:46.332]                       }
[16:17:46.332]                       else if (inherits(cond, "warning")) {
[16:17:46.332]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.332]                         if (muffled) 
[16:17:46.332]                           invokeRestart("muffleWarning")
[16:17:46.332]                       }
[16:17:46.332]                       else if (inherits(cond, "condition")) {
[16:17:46.332]                         if (!is.null(pattern)) {
[16:17:46.332]                           computeRestarts <- base::computeRestarts
[16:17:46.332]                           grepl <- base::grepl
[16:17:46.332]                           restarts <- computeRestarts(cond)
[16:17:46.332]                           for (restart in restarts) {
[16:17:46.332]                             name <- restart$name
[16:17:46.332]                             if (is.null(name)) 
[16:17:46.332]                               next
[16:17:46.332]                             if (!grepl(pattern, name)) 
[16:17:46.332]                               next
[16:17:46.332]                             invokeRestart(restart)
[16:17:46.332]                             muffled <- TRUE
[16:17:46.332]                             break
[16:17:46.332]                           }
[16:17:46.332]                         }
[16:17:46.332]                       }
[16:17:46.332]                       invisible(muffled)
[16:17:46.332]                     }
[16:17:46.332]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.332]                   }
[16:17:46.332]                 }
[16:17:46.332]                 else {
[16:17:46.332]                   if (TRUE) {
[16:17:46.332]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.332]                     {
[16:17:46.332]                       inherits <- base::inherits
[16:17:46.332]                       invokeRestart <- base::invokeRestart
[16:17:46.332]                       is.null <- base::is.null
[16:17:46.332]                       muffled <- FALSE
[16:17:46.332]                       if (inherits(cond, "message")) {
[16:17:46.332]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.332]                         if (muffled) 
[16:17:46.332]                           invokeRestart("muffleMessage")
[16:17:46.332]                       }
[16:17:46.332]                       else if (inherits(cond, "warning")) {
[16:17:46.332]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.332]                         if (muffled) 
[16:17:46.332]                           invokeRestart("muffleWarning")
[16:17:46.332]                       }
[16:17:46.332]                       else if (inherits(cond, "condition")) {
[16:17:46.332]                         if (!is.null(pattern)) {
[16:17:46.332]                           computeRestarts <- base::computeRestarts
[16:17:46.332]                           grepl <- base::grepl
[16:17:46.332]                           restarts <- computeRestarts(cond)
[16:17:46.332]                           for (restart in restarts) {
[16:17:46.332]                             name <- restart$name
[16:17:46.332]                             if (is.null(name)) 
[16:17:46.332]                               next
[16:17:46.332]                             if (!grepl(pattern, name)) 
[16:17:46.332]                               next
[16:17:46.332]                             invokeRestart(restart)
[16:17:46.332]                             muffled <- TRUE
[16:17:46.332]                             break
[16:17:46.332]                           }
[16:17:46.332]                         }
[16:17:46.332]                       }
[16:17:46.332]                       invisible(muffled)
[16:17:46.332]                     }
[16:17:46.332]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.332]                   }
[16:17:46.332]                 }
[16:17:46.332]             }
[16:17:46.332]         }))
[16:17:46.332]     }, error = function(ex) {
[16:17:46.332]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:46.332]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.332]                 ...future.rng), started = ...future.startTime, 
[16:17:46.332]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:46.332]             version = "1.8"), class = "FutureResult")
[16:17:46.332]     }, finally = {
[16:17:46.332]         if (!identical(...future.workdir, getwd())) 
[16:17:46.332]             setwd(...future.workdir)
[16:17:46.332]         {
[16:17:46.332]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:46.332]                 ...future.oldOptions$nwarnings <- NULL
[16:17:46.332]             }
[16:17:46.332]             base::options(...future.oldOptions)
[16:17:46.332]             if (.Platform$OS.type == "windows") {
[16:17:46.332]                 old_names <- names(...future.oldEnvVars)
[16:17:46.332]                 envs <- base::Sys.getenv()
[16:17:46.332]                 names <- names(envs)
[16:17:46.332]                 common <- intersect(names, old_names)
[16:17:46.332]                 added <- setdiff(names, old_names)
[16:17:46.332]                 removed <- setdiff(old_names, names)
[16:17:46.332]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:46.332]                   envs[common]]
[16:17:46.332]                 NAMES <- toupper(changed)
[16:17:46.332]                 args <- list()
[16:17:46.332]                 for (kk in seq_along(NAMES)) {
[16:17:46.332]                   name <- changed[[kk]]
[16:17:46.332]                   NAME <- NAMES[[kk]]
[16:17:46.332]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.332]                     next
[16:17:46.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.332]                 }
[16:17:46.332]                 NAMES <- toupper(added)
[16:17:46.332]                 for (kk in seq_along(NAMES)) {
[16:17:46.332]                   name <- added[[kk]]
[16:17:46.332]                   NAME <- NAMES[[kk]]
[16:17:46.332]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.332]                     next
[16:17:46.332]                   args[[name]] <- ""
[16:17:46.332]                 }
[16:17:46.332]                 NAMES <- toupper(removed)
[16:17:46.332]                 for (kk in seq_along(NAMES)) {
[16:17:46.332]                   name <- removed[[kk]]
[16:17:46.332]                   NAME <- NAMES[[kk]]
[16:17:46.332]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.332]                     next
[16:17:46.332]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.332]                 }
[16:17:46.332]                 if (length(args) > 0) 
[16:17:46.332]                   base::do.call(base::Sys.setenv, args = args)
[16:17:46.332]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:46.332]             }
[16:17:46.332]             else {
[16:17:46.332]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:46.332]             }
[16:17:46.332]             {
[16:17:46.332]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:46.332]                   0L) {
[16:17:46.332]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:46.332]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:46.332]                   base::options(opts)
[16:17:46.332]                 }
[16:17:46.332]                 {
[16:17:46.332]                   {
[16:17:46.332]                     NULL
[16:17:46.332]                     RNGkind("Mersenne-Twister")
[16:17:46.332]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:46.332]                       inherits = FALSE)
[16:17:46.332]                   }
[16:17:46.332]                   options(future.plan = NULL)
[16:17:46.332]                   if (is.na(NA_character_)) 
[16:17:46.332]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.332]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:46.332]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:46.332]                     .init = FALSE)
[16:17:46.332]                 }
[16:17:46.332]             }
[16:17:46.332]         }
[16:17:46.332]     })
[16:17:46.332]     if (TRUE) {
[16:17:46.332]         base::sink(type = "output", split = FALSE)
[16:17:46.332]         if (TRUE) {
[16:17:46.332]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:46.332]         }
[16:17:46.332]         else {
[16:17:46.332]             ...future.result["stdout"] <- base::list(NULL)
[16:17:46.332]         }
[16:17:46.332]         base::close(...future.stdout)
[16:17:46.332]         ...future.stdout <- NULL
[16:17:46.332]     }
[16:17:46.332]     ...future.result$conditions <- ...future.conditions
[16:17:46.332]     ...future.result$finished <- base::Sys.time()
[16:17:46.332]     ...future.result
[16:17:46.332] }
[16:17:46.333] assign_globals() ...
[16:17:46.333] List of 5
[16:17:46.333]  $ ...future.FUN            :function (object, ...)  
[16:17:46.333]  $ future.call.arguments    : list()
[16:17:46.333]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.333]  $ ...future.elements_ii    :List of 3
[16:17:46.333]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.333]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:17:46.333]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.333]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:46.333]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.333]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:17:46.333]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.333]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:17:46.333]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.333]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:17:46.333]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.333]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:17:46.333]  $ ...future.seeds_ii       : NULL
[16:17:46.333]  $ ...future.globals.maxSize: NULL
[16:17:46.333]  - attr(*, "where")=List of 5
[16:17:46.333]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:46.333]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:46.333]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:46.333]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:46.333]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:46.333]  - attr(*, "resolved")= logi FALSE
[16:17:46.333]  - attr(*, "total_size")= num 1240
[16:17:46.333]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.333]  - attr(*, "already-done")= logi TRUE
[16:17:46.343] - copied ‘...future.FUN’ to environment
[16:17:46.344] - copied ‘future.call.arguments’ to environment
[16:17:46.344] - copied ‘...future.elements_ii’ to environment
[16:17:46.344] - copied ‘...future.seeds_ii’ to environment
[16:17:46.344] - copied ‘...future.globals.maxSize’ to environment
[16:17:46.344] assign_globals() ... done
[16:17:46.344] plan(): Setting new future strategy stack:
[16:17:46.344] List of future strategies:
[16:17:46.344] 1. sequential:
[16:17:46.344]    - args: function (..., envir = parent.frame())
[16:17:46.344]    - tweaked: FALSE
[16:17:46.344]    - call: NULL
[16:17:46.345] plan(): nbrOfWorkers() = 1
[16:17:46.347] plan(): Setting new future strategy stack:
[16:17:46.347] List of future strategies:
[16:17:46.347] 1. sequential:
[16:17:46.347]    - args: function (..., envir = parent.frame())
[16:17:46.347]    - tweaked: FALSE
[16:17:46.347]    - call: plan(strategy)
[16:17:46.348] plan(): nbrOfWorkers() = 1
[16:17:46.348] SequentialFuture started (and completed)
[16:17:46.348] - Launch lazy future ... done
[16:17:46.348] run() for ‘SequentialFuture’ ... done
[16:17:46.348] Created future:
[16:17:46.348] SequentialFuture:
[16:17:46.348] Label: ‘future_by-1’
[16:17:46.348] Expression:
[16:17:46.348] {
[16:17:46.348]     do.call(function(...) {
[16:17:46.348]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.348]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.348]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.348]             on.exit(options(oopts), add = TRUE)
[16:17:46.348]         }
[16:17:46.348]         {
[16:17:46.348]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.348]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.348]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.348]             })
[16:17:46.348]         }
[16:17:46.348]     }, args = future.call.arguments)
[16:17:46.348] }
[16:17:46.348] Lazy evaluation: FALSE
[16:17:46.348] Asynchronous evaluation: FALSE
[16:17:46.348] Local evaluation: TRUE
[16:17:46.348] Environment: 0x55b567c8fc78
[16:17:46.348] Capture standard output: TRUE
[16:17:46.348] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:46.348] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:46.348] Packages: <none>
[16:17:46.348] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:46.348] Resolved: TRUE
[16:17:46.348] Value: 5.37 KiB of class ‘list’
[16:17:46.348] Early signaling: FALSE
[16:17:46.348] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:46.348] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.350] Chunk #1 of 1 ... DONE
[16:17:46.350] Launching 1 futures (chunks) ... DONE
[16:17:46.350] Resolving 1 futures (chunks) ...
[16:17:46.350] resolve() on list ...
[16:17:46.350]  recursive: 0
[16:17:46.350]  length: 1
[16:17:46.350] 
[16:17:46.350] resolved() for ‘SequentialFuture’ ...
[16:17:46.350] - state: ‘finished’
[16:17:46.351] - run: TRUE
[16:17:46.351] - result: ‘FutureResult’
[16:17:46.351] resolved() for ‘SequentialFuture’ ... done
[16:17:46.351] Future #1
[16:17:46.351] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:46.351] - nx: 1
[16:17:46.351] - relay: TRUE
[16:17:46.351] - stdout: TRUE
[16:17:46.351] - signal: TRUE
[16:17:46.351] - resignal: FALSE
[16:17:46.352] - force: TRUE
[16:17:46.352] - relayed: [n=1] FALSE
[16:17:46.352] - queued futures: [n=1] FALSE
[16:17:46.352]  - until=1
[16:17:46.352]  - relaying element #1
[16:17:46.352] - relayed: [n=1] TRUE
[16:17:46.352] - queued futures: [n=1] TRUE
[16:17:46.352] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:46.352]  length: 0 (resolved future 1)
[16:17:46.353] Relaying remaining futures
[16:17:46.353] signalConditionsASAP(NULL, pos=0) ...
[16:17:46.353] - nx: 1
[16:17:46.353] - relay: TRUE
[16:17:46.353] - stdout: TRUE
[16:17:46.353] - signal: TRUE
[16:17:46.353] - resignal: FALSE
[16:17:46.353] - force: TRUE
[16:17:46.353] - relayed: [n=1] TRUE
[16:17:46.353] - queued futures: [n=1] TRUE
 - flush all
[16:17:46.353] - relayed: [n=1] TRUE
[16:17:46.354] - queued futures: [n=1] TRUE
[16:17:46.354] signalConditionsASAP(NULL, pos=0) ... done
[16:17:46.354] resolve() on list ... DONE
[16:17:46.354]  - Number of value chunks collected: 1
[16:17:46.354] Resolving 1 futures (chunks) ... DONE
[16:17:46.354] Reducing values from 1 chunks ...
[16:17:46.354]  - Number of values collected after concatenation: 3
[16:17:46.354]  - Number of values expected: 3
[16:17:46.354] Reducing values from 1 chunks ... DONE
[16:17:46.354] future_lapply() ... DONE
[16:17:46.354] future_by_internal() ... DONE
[16:17:46.355] future_by_internal() ...
- plan('multicore') ...
[16:17:46.356] plan(): Setting new future strategy stack:
[16:17:46.356] List of future strategies:
[16:17:46.356] 1. multicore:
[16:17:46.356]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:46.356]    - tweaked: FALSE
[16:17:46.356]    - call: plan(strategy)
[16:17:46.360] plan(): nbrOfWorkers() = 1
[16:17:46.360] future_by_internal() ...
[16:17:46.361] future_lapply() ...
[16:17:46.365] Number of chunks: 1
[16:17:46.365] getGlobalsAndPackagesXApply() ...
[16:17:46.365]  - future.globals: TRUE
[16:17:46.365] getGlobalsAndPackages() ...
[16:17:46.365] Searching for globals...
[16:17:46.366] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:46.366] Searching for globals ... DONE
[16:17:46.366] Resolving globals: FALSE
[16:17:46.367] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:46.369] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:46.369] - globals: [1] ‘FUN’
[16:17:46.369] 
[16:17:46.369] getGlobalsAndPackages() ... DONE
[16:17:46.369]  - globals found/used: [n=1] ‘FUN’
[16:17:46.369]  - needed namespaces: [n=0] 
[16:17:46.369] Finding globals ... DONE
[16:17:46.370]  - use_args: TRUE
[16:17:46.370]  - Getting '...' globals ...
[16:17:46.370] resolve() on list ...
[16:17:46.370]  recursive: 0
[16:17:46.370]  length: 1
[16:17:46.370]  elements: ‘...’
[16:17:46.370]  length: 0 (resolved future 1)
[16:17:46.370] resolve() on list ... DONE
[16:17:46.371]    - '...' content: [n=0] 
[16:17:46.371] List of 1
[16:17:46.371]  $ ...: list()
[16:17:46.371]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.371]  - attr(*, "where")=List of 1
[16:17:46.371]   ..$ ...:<environment: 0x55b567fcfed0> 
[16:17:46.371]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.371]  - attr(*, "resolved")= logi TRUE
[16:17:46.371]  - attr(*, "total_size")= num NA
[16:17:46.373]  - Getting '...' globals ... DONE
[16:17:46.373] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:46.373] List of 2
[16:17:46.373]  $ ...future.FUN:function (object, ...)  
[16:17:46.373]  $ ...          : list()
[16:17:46.373]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.373]  - attr(*, "where")=List of 2
[16:17:46.373]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:46.373]   ..$ ...          :<environment: 0x55b567fcfed0> 
[16:17:46.373]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.373]  - attr(*, "resolved")= logi FALSE
[16:17:46.373]  - attr(*, "total_size")= num 1240
[16:17:46.376] Packages to be attached in all futures: [n=0] 
[16:17:46.376] getGlobalsAndPackagesXApply() ... DONE
[16:17:46.376] Number of futures (= number of chunks): 1
[16:17:46.377] Launching 1 futures (chunks) ...
[16:17:46.377] Chunk #1 of 1 ...
[16:17:46.377]  - Finding globals in 'X' for chunk #1 ...
[16:17:46.377] getGlobalsAndPackages() ...
[16:17:46.377] Searching for globals...
[16:17:46.377] 
[16:17:46.378] Searching for globals ... DONE
[16:17:46.378] - globals: [0] <none>
[16:17:46.378] getGlobalsAndPackages() ... DONE
[16:17:46.378]    + additional globals found: [n=0] 
[16:17:46.378]    + additional namespaces needed: [n=0] 
[16:17:46.378]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:46.378]  - seeds: <none>
[16:17:46.378]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.378] getGlobalsAndPackages() ...
[16:17:46.378] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.378] Resolving globals: FALSE
[16:17:46.379] Tweak future expression to call with '...' arguments ...
[16:17:46.379] {
[16:17:46.379]     do.call(function(...) {
[16:17:46.379]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.379]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.379]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.379]             on.exit(options(oopts), add = TRUE)
[16:17:46.379]         }
[16:17:46.379]         {
[16:17:46.379]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.379]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.379]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.379]             })
[16:17:46.379]         }
[16:17:46.379]     }, args = future.call.arguments)
[16:17:46.379] }
[16:17:46.379] Tweak future expression to call with '...' arguments ... DONE
[16:17:46.379] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.379] 
[16:17:46.379] getGlobalsAndPackages() ... DONE
[16:17:46.380] run() for ‘Future’ ...
[16:17:46.380] - state: ‘created’
[16:17:46.380] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:46.383] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.384] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:46.384]   - Field: ‘label’
[16:17:46.384]   - Field: ‘local’
[16:17:46.384]   - Field: ‘owner’
[16:17:46.384]   - Field: ‘envir’
[16:17:46.384]   - Field: ‘packages’
[16:17:46.384]   - Field: ‘gc’
[16:17:46.384]   - Field: ‘conditions’
[16:17:46.384]   - Field: ‘expr’
[16:17:46.385]   - Field: ‘uuid’
[16:17:46.385]   - Field: ‘seed’
[16:17:46.385]   - Field: ‘version’
[16:17:46.385]   - Field: ‘result’
[16:17:46.385]   - Field: ‘asynchronous’
[16:17:46.385]   - Field: ‘calls’
[16:17:46.385]   - Field: ‘globals’
[16:17:46.385]   - Field: ‘stdout’
[16:17:46.385]   - Field: ‘earlySignal’
[16:17:46.385]   - Field: ‘lazy’
[16:17:46.385]   - Field: ‘state’
[16:17:46.386] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:46.386] - Launch lazy future ...
[16:17:46.386] Packages needed by the future expression (n = 0): <none>
[16:17:46.386] Packages needed by future strategies (n = 0): <none>
[16:17:46.386] {
[16:17:46.386]     {
[16:17:46.386]         {
[16:17:46.386]             ...future.startTime <- base::Sys.time()
[16:17:46.386]             {
[16:17:46.386]                 {
[16:17:46.386]                   {
[16:17:46.386]                     base::local({
[16:17:46.386]                       has_future <- base::requireNamespace("future", 
[16:17:46.386]                         quietly = TRUE)
[16:17:46.386]                       if (has_future) {
[16:17:46.386]                         ns <- base::getNamespace("future")
[16:17:46.386]                         version <- ns[[".package"]][["version"]]
[16:17:46.386]                         if (is.null(version)) 
[16:17:46.386]                           version <- utils::packageVersion("future")
[16:17:46.386]                       }
[16:17:46.386]                       else {
[16:17:46.386]                         version <- NULL
[16:17:46.386]                       }
[16:17:46.386]                       if (!has_future || version < "1.8.0") {
[16:17:46.386]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:46.386]                           "", base::R.version$version.string), 
[16:17:46.386]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:46.386]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:46.386]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:46.386]                             "release", "version")], collapse = " "), 
[16:17:46.386]                           hostname = base::Sys.info()[["nodename"]])
[16:17:46.386]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:46.386]                           info)
[16:17:46.386]                         info <- base::paste(info, collapse = "; ")
[16:17:46.386]                         if (!has_future) {
[16:17:46.386]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:46.386]                             info)
[16:17:46.386]                         }
[16:17:46.386]                         else {
[16:17:46.386]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:46.386]                             info, version)
[16:17:46.386]                         }
[16:17:46.386]                         base::stop(msg)
[16:17:46.386]                       }
[16:17:46.386]                     })
[16:17:46.386]                   }
[16:17:46.386]                   ...future.strategy.old <- future::plan("list")
[16:17:46.386]                   options(future.plan = NULL)
[16:17:46.386]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.386]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:46.386]                 }
[16:17:46.386]                 ...future.workdir <- getwd()
[16:17:46.386]             }
[16:17:46.386]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:46.386]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:46.386]         }
[16:17:46.386]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:46.386]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:46.386]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:46.386]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:46.386]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:46.386]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:46.386]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:46.386]             base::names(...future.oldOptions))
[16:17:46.386]     }
[16:17:46.386]     if (FALSE) {
[16:17:46.386]     }
[16:17:46.386]     else {
[16:17:46.386]         if (TRUE) {
[16:17:46.386]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:46.386]                 open = "w")
[16:17:46.386]         }
[16:17:46.386]         else {
[16:17:46.386]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:46.386]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:46.386]         }
[16:17:46.386]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:46.386]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:46.386]             base::sink(type = "output", split = FALSE)
[16:17:46.386]             base::close(...future.stdout)
[16:17:46.386]         }, add = TRUE)
[16:17:46.386]     }
[16:17:46.386]     ...future.frame <- base::sys.nframe()
[16:17:46.386]     ...future.conditions <- base::list()
[16:17:46.386]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:46.386]     if (FALSE) {
[16:17:46.386]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:46.386]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:46.386]     }
[16:17:46.386]     ...future.result <- base::tryCatch({
[16:17:46.386]         base::withCallingHandlers({
[16:17:46.386]             ...future.value <- base::withVisible(base::local({
[16:17:46.386]                 do.call(function(...) {
[16:17:46.386]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.386]                   if (!identical(...future.globals.maxSize.org, 
[16:17:46.386]                     ...future.globals.maxSize)) {
[16:17:46.386]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.386]                     on.exit(options(oopts), add = TRUE)
[16:17:46.386]                   }
[16:17:46.386]                   {
[16:17:46.386]                     lapply(seq_along(...future.elements_ii), 
[16:17:46.386]                       FUN = function(jj) {
[16:17:46.386]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.386]                         ...future.FUN(...future.X_jj, ...)
[16:17:46.386]                       })
[16:17:46.386]                   }
[16:17:46.386]                 }, args = future.call.arguments)
[16:17:46.386]             }))
[16:17:46.386]             future::FutureResult(value = ...future.value$value, 
[16:17:46.386]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.386]                   ...future.rng), globalenv = if (FALSE) 
[16:17:46.386]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:46.386]                     ...future.globalenv.names))
[16:17:46.386]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:46.386]         }, condition = base::local({
[16:17:46.386]             c <- base::c
[16:17:46.386]             inherits <- base::inherits
[16:17:46.386]             invokeRestart <- base::invokeRestart
[16:17:46.386]             length <- base::length
[16:17:46.386]             list <- base::list
[16:17:46.386]             seq.int <- base::seq.int
[16:17:46.386]             signalCondition <- base::signalCondition
[16:17:46.386]             sys.calls <- base::sys.calls
[16:17:46.386]             `[[` <- base::`[[`
[16:17:46.386]             `+` <- base::`+`
[16:17:46.386]             `<<-` <- base::`<<-`
[16:17:46.386]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:46.386]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:46.386]                   3L)]
[16:17:46.386]             }
[16:17:46.386]             function(cond) {
[16:17:46.386]                 is_error <- inherits(cond, "error")
[16:17:46.386]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:46.386]                   NULL)
[16:17:46.386]                 if (is_error) {
[16:17:46.386]                   sessionInformation <- function() {
[16:17:46.386]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:46.386]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:46.386]                       search = base::search(), system = base::Sys.info())
[16:17:46.386]                   }
[16:17:46.386]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.386]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:46.386]                     cond$call), session = sessionInformation(), 
[16:17:46.386]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:46.386]                   signalCondition(cond)
[16:17:46.386]                 }
[16:17:46.386]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:46.386]                 "immediateCondition"))) {
[16:17:46.386]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:46.386]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.386]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:46.386]                   if (TRUE && !signal) {
[16:17:46.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.386]                     {
[16:17:46.386]                       inherits <- base::inherits
[16:17:46.386]                       invokeRestart <- base::invokeRestart
[16:17:46.386]                       is.null <- base::is.null
[16:17:46.386]                       muffled <- FALSE
[16:17:46.386]                       if (inherits(cond, "message")) {
[16:17:46.386]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.386]                         if (muffled) 
[16:17:46.386]                           invokeRestart("muffleMessage")
[16:17:46.386]                       }
[16:17:46.386]                       else if (inherits(cond, "warning")) {
[16:17:46.386]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.386]                         if (muffled) 
[16:17:46.386]                           invokeRestart("muffleWarning")
[16:17:46.386]                       }
[16:17:46.386]                       else if (inherits(cond, "condition")) {
[16:17:46.386]                         if (!is.null(pattern)) {
[16:17:46.386]                           computeRestarts <- base::computeRestarts
[16:17:46.386]                           grepl <- base::grepl
[16:17:46.386]                           restarts <- computeRestarts(cond)
[16:17:46.386]                           for (restart in restarts) {
[16:17:46.386]                             name <- restart$name
[16:17:46.386]                             if (is.null(name)) 
[16:17:46.386]                               next
[16:17:46.386]                             if (!grepl(pattern, name)) 
[16:17:46.386]                               next
[16:17:46.386]                             invokeRestart(restart)
[16:17:46.386]                             muffled <- TRUE
[16:17:46.386]                             break
[16:17:46.386]                           }
[16:17:46.386]                         }
[16:17:46.386]                       }
[16:17:46.386]                       invisible(muffled)
[16:17:46.386]                     }
[16:17:46.386]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.386]                   }
[16:17:46.386]                 }
[16:17:46.386]                 else {
[16:17:46.386]                   if (TRUE) {
[16:17:46.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.386]                     {
[16:17:46.386]                       inherits <- base::inherits
[16:17:46.386]                       invokeRestart <- base::invokeRestart
[16:17:46.386]                       is.null <- base::is.null
[16:17:46.386]                       muffled <- FALSE
[16:17:46.386]                       if (inherits(cond, "message")) {
[16:17:46.386]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.386]                         if (muffled) 
[16:17:46.386]                           invokeRestart("muffleMessage")
[16:17:46.386]                       }
[16:17:46.386]                       else if (inherits(cond, "warning")) {
[16:17:46.386]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.386]                         if (muffled) 
[16:17:46.386]                           invokeRestart("muffleWarning")
[16:17:46.386]                       }
[16:17:46.386]                       else if (inherits(cond, "condition")) {
[16:17:46.386]                         if (!is.null(pattern)) {
[16:17:46.386]                           computeRestarts <- base::computeRestarts
[16:17:46.386]                           grepl <- base::grepl
[16:17:46.386]                           restarts <- computeRestarts(cond)
[16:17:46.386]                           for (restart in restarts) {
[16:17:46.386]                             name <- restart$name
[16:17:46.386]                             if (is.null(name)) 
[16:17:46.386]                               next
[16:17:46.386]                             if (!grepl(pattern, name)) 
[16:17:46.386]                               next
[16:17:46.386]                             invokeRestart(restart)
[16:17:46.386]                             muffled <- TRUE
[16:17:46.386]                             break
[16:17:46.386]                           }
[16:17:46.386]                         }
[16:17:46.386]                       }
[16:17:46.386]                       invisible(muffled)
[16:17:46.386]                     }
[16:17:46.386]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.386]                   }
[16:17:46.386]                 }
[16:17:46.386]             }
[16:17:46.386]         }))
[16:17:46.386]     }, error = function(ex) {
[16:17:46.386]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:46.386]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.386]                 ...future.rng), started = ...future.startTime, 
[16:17:46.386]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:46.386]             version = "1.8"), class = "FutureResult")
[16:17:46.386]     }, finally = {
[16:17:46.386]         if (!identical(...future.workdir, getwd())) 
[16:17:46.386]             setwd(...future.workdir)
[16:17:46.386]         {
[16:17:46.386]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:46.386]                 ...future.oldOptions$nwarnings <- NULL
[16:17:46.386]             }
[16:17:46.386]             base::options(...future.oldOptions)
[16:17:46.386]             if (.Platform$OS.type == "windows") {
[16:17:46.386]                 old_names <- names(...future.oldEnvVars)
[16:17:46.386]                 envs <- base::Sys.getenv()
[16:17:46.386]                 names <- names(envs)
[16:17:46.386]                 common <- intersect(names, old_names)
[16:17:46.386]                 added <- setdiff(names, old_names)
[16:17:46.386]                 removed <- setdiff(old_names, names)
[16:17:46.386]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:46.386]                   envs[common]]
[16:17:46.386]                 NAMES <- toupper(changed)
[16:17:46.386]                 args <- list()
[16:17:46.386]                 for (kk in seq_along(NAMES)) {
[16:17:46.386]                   name <- changed[[kk]]
[16:17:46.386]                   NAME <- NAMES[[kk]]
[16:17:46.386]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.386]                     next
[16:17:46.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.386]                 }
[16:17:46.386]                 NAMES <- toupper(added)
[16:17:46.386]                 for (kk in seq_along(NAMES)) {
[16:17:46.386]                   name <- added[[kk]]
[16:17:46.386]                   NAME <- NAMES[[kk]]
[16:17:46.386]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.386]                     next
[16:17:46.386]                   args[[name]] <- ""
[16:17:46.386]                 }
[16:17:46.386]                 NAMES <- toupper(removed)
[16:17:46.386]                 for (kk in seq_along(NAMES)) {
[16:17:46.386]                   name <- removed[[kk]]
[16:17:46.386]                   NAME <- NAMES[[kk]]
[16:17:46.386]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.386]                     next
[16:17:46.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.386]                 }
[16:17:46.386]                 if (length(args) > 0) 
[16:17:46.386]                   base::do.call(base::Sys.setenv, args = args)
[16:17:46.386]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:46.386]             }
[16:17:46.386]             else {
[16:17:46.386]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:46.386]             }
[16:17:46.386]             {
[16:17:46.386]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:46.386]                   0L) {
[16:17:46.386]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:46.386]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:46.386]                   base::options(opts)
[16:17:46.386]                 }
[16:17:46.386]                 {
[16:17:46.386]                   {
[16:17:46.386]                     NULL
[16:17:46.386]                     RNGkind("Mersenne-Twister")
[16:17:46.386]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:46.386]                       inherits = FALSE)
[16:17:46.386]                   }
[16:17:46.386]                   options(future.plan = NULL)
[16:17:46.386]                   if (is.na(NA_character_)) 
[16:17:46.386]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.386]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:46.386]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:46.386]                     .init = FALSE)
[16:17:46.386]                 }
[16:17:46.386]             }
[16:17:46.386]         }
[16:17:46.386]     })
[16:17:46.386]     if (TRUE) {
[16:17:46.386]         base::sink(type = "output", split = FALSE)
[16:17:46.386]         if (TRUE) {
[16:17:46.386]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:46.386]         }
[16:17:46.386]         else {
[16:17:46.386]             ...future.result["stdout"] <- base::list(NULL)
[16:17:46.386]         }
[16:17:46.386]         base::close(...future.stdout)
[16:17:46.386]         ...future.stdout <- NULL
[16:17:46.386]     }
[16:17:46.386]     ...future.result$conditions <- ...future.conditions
[16:17:46.386]     ...future.result$finished <- base::Sys.time()
[16:17:46.386]     ...future.result
[16:17:46.386] }
[16:17:46.388] assign_globals() ...
[16:17:46.388] List of 5
[16:17:46.388]  $ ...future.FUN            :function (object, ...)  
[16:17:46.388]  $ future.call.arguments    : list()
[16:17:46.388]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.388]  $ ...future.elements_ii    :List of 3
[16:17:46.388]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:17:46.388]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:17:46.388]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.388]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:17:46.388]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:17:46.388]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.388]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:17:46.388]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:17:46.388]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.388]  $ ...future.seeds_ii       : NULL
[16:17:46.388]  $ ...future.globals.maxSize: NULL
[16:17:46.388]  - attr(*, "where")=List of 5
[16:17:46.388]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:46.388]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:46.388]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:46.388]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:46.388]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:46.388]  - attr(*, "resolved")= logi FALSE
[16:17:46.388]  - attr(*, "total_size")= num 1240
[16:17:46.388]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.388]  - attr(*, "already-done")= logi TRUE
[16:17:46.397] - copied ‘...future.FUN’ to environment
[16:17:46.397] - copied ‘future.call.arguments’ to environment
[16:17:46.397] - copied ‘...future.elements_ii’ to environment
[16:17:46.397] - copied ‘...future.seeds_ii’ to environment
[16:17:46.397] - copied ‘...future.globals.maxSize’ to environment
[16:17:46.397] assign_globals() ... done
[16:17:46.398] plan(): Setting new future strategy stack:
[16:17:46.398] List of future strategies:
[16:17:46.398] 1. sequential:
[16:17:46.398]    - args: function (..., envir = parent.frame())
[16:17:46.398]    - tweaked: FALSE
[16:17:46.398]    - call: NULL
[16:17:46.398] plan(): nbrOfWorkers() = 1
[16:17:46.400] plan(): Setting new future strategy stack:
[16:17:46.400] List of future strategies:
[16:17:46.400] 1. multicore:
[16:17:46.400]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:46.400]    - tweaked: FALSE
[16:17:46.400]    - call: plan(strategy)
[16:17:46.403] plan(): nbrOfWorkers() = 1
[16:17:46.404] SequentialFuture started (and completed)
[16:17:46.404] - Launch lazy future ... done
[16:17:46.404] run() for ‘SequentialFuture’ ... done
[16:17:46.404] Created future:
[16:17:46.404] SequentialFuture:
[16:17:46.404] Label: ‘future_by-1’
[16:17:46.404] Expression:
[16:17:46.404] {
[16:17:46.404]     do.call(function(...) {
[16:17:46.404]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.404]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.404]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.404]             on.exit(options(oopts), add = TRUE)
[16:17:46.404]         }
[16:17:46.404]         {
[16:17:46.404]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.404]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.404]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.404]             })
[16:17:46.404]         }
[16:17:46.404]     }, args = future.call.arguments)
[16:17:46.404] }
[16:17:46.404] Lazy evaluation: FALSE
[16:17:46.404] Asynchronous evaluation: FALSE
[16:17:46.404] Local evaluation: TRUE
[16:17:46.404] Environment: R_GlobalEnv
[16:17:46.404] Capture standard output: TRUE
[16:17:46.404] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:46.404] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:46.404] Packages: <none>
[16:17:46.404] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:46.404] Resolved: TRUE
[16:17:46.404] Value: 4.62 KiB of class ‘list’
[16:17:46.404] Early signaling: FALSE
[16:17:46.404] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:46.404] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.405] Chunk #1 of 1 ... DONE
[16:17:46.405] Launching 1 futures (chunks) ... DONE
[16:17:46.405] Resolving 1 futures (chunks) ...
[16:17:46.405] resolve() on list ...
[16:17:46.406]  recursive: 0
[16:17:46.406]  length: 1
[16:17:46.406] 
[16:17:46.406] resolved() for ‘SequentialFuture’ ...
[16:17:46.406] - state: ‘finished’
[16:17:46.406] - run: TRUE
[16:17:46.406] - result: ‘FutureResult’
[16:17:46.406] resolved() for ‘SequentialFuture’ ... done
[16:17:46.406] Future #1
[16:17:46.406] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:46.406] - nx: 1
[16:17:46.407] - relay: TRUE
[16:17:46.407] - stdout: TRUE
[16:17:46.407] - signal: TRUE
[16:17:46.407] - resignal: FALSE
[16:17:46.407] - force: TRUE
[16:17:46.407] - relayed: [n=1] FALSE
[16:17:46.407] - queued futures: [n=1] FALSE
[16:17:46.407]  - until=1
[16:17:46.407]  - relaying element #1
[16:17:46.407] - relayed: [n=1] TRUE
[16:17:46.407] - queued futures: [n=1] TRUE
[16:17:46.408] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:46.408]  length: 0 (resolved future 1)
[16:17:46.408] Relaying remaining futures
[16:17:46.408] signalConditionsASAP(NULL, pos=0) ...
[16:17:46.408] - nx: 1
[16:17:46.408] - relay: TRUE
[16:17:46.408] - stdout: TRUE
[16:17:46.408] - signal: TRUE
[16:17:46.408] - resignal: FALSE
[16:17:46.408] - force: TRUE
[16:17:46.408] - relayed: [n=1] TRUE
[16:17:46.408] - queued futures: [n=1] TRUE
 - flush all
[16:17:46.409] - relayed: [n=1] TRUE
[16:17:46.409] - queued futures: [n=1] TRUE
[16:17:46.409] signalConditionsASAP(NULL, pos=0) ... done
[16:17:46.409] resolve() on list ... DONE
[16:17:46.409]  - Number of value chunks collected: 1
[16:17:46.409] Resolving 1 futures (chunks) ... DONE
[16:17:46.409] Reducing values from 1 chunks ...
[16:17:46.409]  - Number of values collected after concatenation: 3
[16:17:46.409]  - Number of values expected: 3
[16:17:46.409] Reducing values from 1 chunks ... DONE
[16:17:46.410] future_lapply() ... DONE
[16:17:46.410] future_by_internal() ... DONE
[16:17:46.410] future_by_internal() ...
[16:17:46.410] future_lapply() ...
[16:17:46.414] Number of chunks: 1
[16:17:46.414] getGlobalsAndPackagesXApply() ...
[16:17:46.415]  - future.globals: TRUE
[16:17:46.415] getGlobalsAndPackages() ...
[16:17:46.415] Searching for globals...
[16:17:46.416] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:46.416] Searching for globals ... DONE
[16:17:46.416] Resolving globals: FALSE
[16:17:46.417] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:46.417] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:46.417] - globals: [1] ‘FUN’
[16:17:46.417] 
[16:17:46.417] getGlobalsAndPackages() ... DONE
[16:17:46.417]  - globals found/used: [n=1] ‘FUN’
[16:17:46.418]  - needed namespaces: [n=0] 
[16:17:46.418] Finding globals ... DONE
[16:17:46.418]  - use_args: TRUE
[16:17:46.418]  - Getting '...' globals ...
[16:17:46.418] resolve() on list ...
[16:17:46.418]  recursive: 0
[16:17:46.418]  length: 1
[16:17:46.418]  elements: ‘...’
[16:17:46.418]  length: 0 (resolved future 1)
[16:17:46.419] resolve() on list ... DONE
[16:17:46.419]    - '...' content: [n=1] ‘digits’
[16:17:46.419] List of 1
[16:17:46.419]  $ ...:List of 1
[16:17:46.419]   ..$ digits: int 2
[16:17:46.419]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.419]  - attr(*, "where")=List of 1
[16:17:46.419]   ..$ ...:<environment: 0x55b5681599e8> 
[16:17:46.419]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.419]  - attr(*, "resolved")= logi TRUE
[16:17:46.419]  - attr(*, "total_size")= num NA
[16:17:46.422]  - Getting '...' globals ... DONE
[16:17:46.422] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:46.422] List of 2
[16:17:46.422]  $ ...future.FUN:function (object, ...)  
[16:17:46.422]  $ ...          :List of 1
[16:17:46.422]   ..$ digits: int 2
[16:17:46.422]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.422]  - attr(*, "where")=List of 2
[16:17:46.422]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:46.422]   ..$ ...          :<environment: 0x55b5681599e8> 
[16:17:46.422]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.422]  - attr(*, "resolved")= logi FALSE
[16:17:46.422]  - attr(*, "total_size")= num 1296
[16:17:46.425] Packages to be attached in all futures: [n=0] 
[16:17:46.425] getGlobalsAndPackagesXApply() ... DONE
[16:17:46.425] Number of futures (= number of chunks): 1
[16:17:46.425] Launching 1 futures (chunks) ...
[16:17:46.425] Chunk #1 of 1 ...
[16:17:46.425]  - Finding globals in 'X' for chunk #1 ...
[16:17:46.425] getGlobalsAndPackages() ...
[16:17:46.426] Searching for globals...
[16:17:46.426] 
[16:17:46.426] Searching for globals ... DONE
[16:17:46.426] - globals: [0] <none>
[16:17:46.426] getGlobalsAndPackages() ... DONE
[16:17:46.426]    + additional globals found: [n=0] 
[16:17:46.426]    + additional namespaces needed: [n=0] 
[16:17:46.426]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:46.426]  - seeds: <none>
[16:17:46.426]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.427] getGlobalsAndPackages() ...
[16:17:46.427] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.427] Resolving globals: FALSE
[16:17:46.427] Tweak future expression to call with '...' arguments ...
[16:17:46.427] {
[16:17:46.427]     do.call(function(...) {
[16:17:46.427]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.427]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.427]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.427]             on.exit(options(oopts), add = TRUE)
[16:17:46.427]         }
[16:17:46.427]         {
[16:17:46.427]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.427]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.427]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.427]             })
[16:17:46.427]         }
[16:17:46.427]     }, args = future.call.arguments)
[16:17:46.427] }
[16:17:46.427] Tweak future expression to call with '...' arguments ... DONE
[16:17:46.428] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.428] 
[16:17:46.428] getGlobalsAndPackages() ... DONE
[16:17:46.428] run() for ‘Future’ ...
[16:17:46.428] - state: ‘created’
[16:17:46.428] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:46.432] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.432] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:46.432]   - Field: ‘label’
[16:17:46.432]   - Field: ‘local’
[16:17:46.432]   - Field: ‘owner’
[16:17:46.432]   - Field: ‘envir’
[16:17:46.432]   - Field: ‘packages’
[16:17:46.432]   - Field: ‘gc’
[16:17:46.432]   - Field: ‘conditions’
[16:17:46.433]   - Field: ‘expr’
[16:17:46.433]   - Field: ‘uuid’
[16:17:46.433]   - Field: ‘seed’
[16:17:46.433]   - Field: ‘version’
[16:17:46.433]   - Field: ‘result’
[16:17:46.433]   - Field: ‘asynchronous’
[16:17:46.433]   - Field: ‘calls’
[16:17:46.433]   - Field: ‘globals’
[16:17:46.433]   - Field: ‘stdout’
[16:17:46.433]   - Field: ‘earlySignal’
[16:17:46.433]   - Field: ‘lazy’
[16:17:46.434]   - Field: ‘state’
[16:17:46.434] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:46.434] - Launch lazy future ...
[16:17:46.434] Packages needed by the future expression (n = 0): <none>
[16:17:46.434] Packages needed by future strategies (n = 0): <none>
[16:17:46.435] {
[16:17:46.435]     {
[16:17:46.435]         {
[16:17:46.435]             ...future.startTime <- base::Sys.time()
[16:17:46.435]             {
[16:17:46.435]                 {
[16:17:46.435]                   {
[16:17:46.435]                     base::local({
[16:17:46.435]                       has_future <- base::requireNamespace("future", 
[16:17:46.435]                         quietly = TRUE)
[16:17:46.435]                       if (has_future) {
[16:17:46.435]                         ns <- base::getNamespace("future")
[16:17:46.435]                         version <- ns[[".package"]][["version"]]
[16:17:46.435]                         if (is.null(version)) 
[16:17:46.435]                           version <- utils::packageVersion("future")
[16:17:46.435]                       }
[16:17:46.435]                       else {
[16:17:46.435]                         version <- NULL
[16:17:46.435]                       }
[16:17:46.435]                       if (!has_future || version < "1.8.0") {
[16:17:46.435]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:46.435]                           "", base::R.version$version.string), 
[16:17:46.435]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:46.435]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:46.435]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:46.435]                             "release", "version")], collapse = " "), 
[16:17:46.435]                           hostname = base::Sys.info()[["nodename"]])
[16:17:46.435]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:46.435]                           info)
[16:17:46.435]                         info <- base::paste(info, collapse = "; ")
[16:17:46.435]                         if (!has_future) {
[16:17:46.435]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:46.435]                             info)
[16:17:46.435]                         }
[16:17:46.435]                         else {
[16:17:46.435]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:46.435]                             info, version)
[16:17:46.435]                         }
[16:17:46.435]                         base::stop(msg)
[16:17:46.435]                       }
[16:17:46.435]                     })
[16:17:46.435]                   }
[16:17:46.435]                   ...future.strategy.old <- future::plan("list")
[16:17:46.435]                   options(future.plan = NULL)
[16:17:46.435]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.435]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:46.435]                 }
[16:17:46.435]                 ...future.workdir <- getwd()
[16:17:46.435]             }
[16:17:46.435]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:46.435]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:46.435]         }
[16:17:46.435]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:46.435]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:46.435]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:46.435]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:46.435]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:46.435]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:46.435]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:46.435]             base::names(...future.oldOptions))
[16:17:46.435]     }
[16:17:46.435]     if (FALSE) {
[16:17:46.435]     }
[16:17:46.435]     else {
[16:17:46.435]         if (TRUE) {
[16:17:46.435]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:46.435]                 open = "w")
[16:17:46.435]         }
[16:17:46.435]         else {
[16:17:46.435]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:46.435]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:46.435]         }
[16:17:46.435]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:46.435]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:46.435]             base::sink(type = "output", split = FALSE)
[16:17:46.435]             base::close(...future.stdout)
[16:17:46.435]         }, add = TRUE)
[16:17:46.435]     }
[16:17:46.435]     ...future.frame <- base::sys.nframe()
[16:17:46.435]     ...future.conditions <- base::list()
[16:17:46.435]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:46.435]     if (FALSE) {
[16:17:46.435]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:46.435]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:46.435]     }
[16:17:46.435]     ...future.result <- base::tryCatch({
[16:17:46.435]         base::withCallingHandlers({
[16:17:46.435]             ...future.value <- base::withVisible(base::local({
[16:17:46.435]                 do.call(function(...) {
[16:17:46.435]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.435]                   if (!identical(...future.globals.maxSize.org, 
[16:17:46.435]                     ...future.globals.maxSize)) {
[16:17:46.435]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.435]                     on.exit(options(oopts), add = TRUE)
[16:17:46.435]                   }
[16:17:46.435]                   {
[16:17:46.435]                     lapply(seq_along(...future.elements_ii), 
[16:17:46.435]                       FUN = function(jj) {
[16:17:46.435]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.435]                         ...future.FUN(...future.X_jj, ...)
[16:17:46.435]                       })
[16:17:46.435]                   }
[16:17:46.435]                 }, args = future.call.arguments)
[16:17:46.435]             }))
[16:17:46.435]             future::FutureResult(value = ...future.value$value, 
[16:17:46.435]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.435]                   ...future.rng), globalenv = if (FALSE) 
[16:17:46.435]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:46.435]                     ...future.globalenv.names))
[16:17:46.435]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:46.435]         }, condition = base::local({
[16:17:46.435]             c <- base::c
[16:17:46.435]             inherits <- base::inherits
[16:17:46.435]             invokeRestart <- base::invokeRestart
[16:17:46.435]             length <- base::length
[16:17:46.435]             list <- base::list
[16:17:46.435]             seq.int <- base::seq.int
[16:17:46.435]             signalCondition <- base::signalCondition
[16:17:46.435]             sys.calls <- base::sys.calls
[16:17:46.435]             `[[` <- base::`[[`
[16:17:46.435]             `+` <- base::`+`
[16:17:46.435]             `<<-` <- base::`<<-`
[16:17:46.435]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:46.435]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:46.435]                   3L)]
[16:17:46.435]             }
[16:17:46.435]             function(cond) {
[16:17:46.435]                 is_error <- inherits(cond, "error")
[16:17:46.435]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:46.435]                   NULL)
[16:17:46.435]                 if (is_error) {
[16:17:46.435]                   sessionInformation <- function() {
[16:17:46.435]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:46.435]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:46.435]                       search = base::search(), system = base::Sys.info())
[16:17:46.435]                   }
[16:17:46.435]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.435]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:46.435]                     cond$call), session = sessionInformation(), 
[16:17:46.435]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:46.435]                   signalCondition(cond)
[16:17:46.435]                 }
[16:17:46.435]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:46.435]                 "immediateCondition"))) {
[16:17:46.435]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:46.435]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.435]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:46.435]                   if (TRUE && !signal) {
[16:17:46.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.435]                     {
[16:17:46.435]                       inherits <- base::inherits
[16:17:46.435]                       invokeRestart <- base::invokeRestart
[16:17:46.435]                       is.null <- base::is.null
[16:17:46.435]                       muffled <- FALSE
[16:17:46.435]                       if (inherits(cond, "message")) {
[16:17:46.435]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.435]                         if (muffled) 
[16:17:46.435]                           invokeRestart("muffleMessage")
[16:17:46.435]                       }
[16:17:46.435]                       else if (inherits(cond, "warning")) {
[16:17:46.435]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.435]                         if (muffled) 
[16:17:46.435]                           invokeRestart("muffleWarning")
[16:17:46.435]                       }
[16:17:46.435]                       else if (inherits(cond, "condition")) {
[16:17:46.435]                         if (!is.null(pattern)) {
[16:17:46.435]                           computeRestarts <- base::computeRestarts
[16:17:46.435]                           grepl <- base::grepl
[16:17:46.435]                           restarts <- computeRestarts(cond)
[16:17:46.435]                           for (restart in restarts) {
[16:17:46.435]                             name <- restart$name
[16:17:46.435]                             if (is.null(name)) 
[16:17:46.435]                               next
[16:17:46.435]                             if (!grepl(pattern, name)) 
[16:17:46.435]                               next
[16:17:46.435]                             invokeRestart(restart)
[16:17:46.435]                             muffled <- TRUE
[16:17:46.435]                             break
[16:17:46.435]                           }
[16:17:46.435]                         }
[16:17:46.435]                       }
[16:17:46.435]                       invisible(muffled)
[16:17:46.435]                     }
[16:17:46.435]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.435]                   }
[16:17:46.435]                 }
[16:17:46.435]                 else {
[16:17:46.435]                   if (TRUE) {
[16:17:46.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.435]                     {
[16:17:46.435]                       inherits <- base::inherits
[16:17:46.435]                       invokeRestart <- base::invokeRestart
[16:17:46.435]                       is.null <- base::is.null
[16:17:46.435]                       muffled <- FALSE
[16:17:46.435]                       if (inherits(cond, "message")) {
[16:17:46.435]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.435]                         if (muffled) 
[16:17:46.435]                           invokeRestart("muffleMessage")
[16:17:46.435]                       }
[16:17:46.435]                       else if (inherits(cond, "warning")) {
[16:17:46.435]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.435]                         if (muffled) 
[16:17:46.435]                           invokeRestart("muffleWarning")
[16:17:46.435]                       }
[16:17:46.435]                       else if (inherits(cond, "condition")) {
[16:17:46.435]                         if (!is.null(pattern)) {
[16:17:46.435]                           computeRestarts <- base::computeRestarts
[16:17:46.435]                           grepl <- base::grepl
[16:17:46.435]                           restarts <- computeRestarts(cond)
[16:17:46.435]                           for (restart in restarts) {
[16:17:46.435]                             name <- restart$name
[16:17:46.435]                             if (is.null(name)) 
[16:17:46.435]                               next
[16:17:46.435]                             if (!grepl(pattern, name)) 
[16:17:46.435]                               next
[16:17:46.435]                             invokeRestart(restart)
[16:17:46.435]                             muffled <- TRUE
[16:17:46.435]                             break
[16:17:46.435]                           }
[16:17:46.435]                         }
[16:17:46.435]                       }
[16:17:46.435]                       invisible(muffled)
[16:17:46.435]                     }
[16:17:46.435]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.435]                   }
[16:17:46.435]                 }
[16:17:46.435]             }
[16:17:46.435]         }))
[16:17:46.435]     }, error = function(ex) {
[16:17:46.435]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:46.435]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.435]                 ...future.rng), started = ...future.startTime, 
[16:17:46.435]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:46.435]             version = "1.8"), class = "FutureResult")
[16:17:46.435]     }, finally = {
[16:17:46.435]         if (!identical(...future.workdir, getwd())) 
[16:17:46.435]             setwd(...future.workdir)
[16:17:46.435]         {
[16:17:46.435]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:46.435]                 ...future.oldOptions$nwarnings <- NULL
[16:17:46.435]             }
[16:17:46.435]             base::options(...future.oldOptions)
[16:17:46.435]             if (.Platform$OS.type == "windows") {
[16:17:46.435]                 old_names <- names(...future.oldEnvVars)
[16:17:46.435]                 envs <- base::Sys.getenv()
[16:17:46.435]                 names <- names(envs)
[16:17:46.435]                 common <- intersect(names, old_names)
[16:17:46.435]                 added <- setdiff(names, old_names)
[16:17:46.435]                 removed <- setdiff(old_names, names)
[16:17:46.435]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:46.435]                   envs[common]]
[16:17:46.435]                 NAMES <- toupper(changed)
[16:17:46.435]                 args <- list()
[16:17:46.435]                 for (kk in seq_along(NAMES)) {
[16:17:46.435]                   name <- changed[[kk]]
[16:17:46.435]                   NAME <- NAMES[[kk]]
[16:17:46.435]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.435]                     next
[16:17:46.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.435]                 }
[16:17:46.435]                 NAMES <- toupper(added)
[16:17:46.435]                 for (kk in seq_along(NAMES)) {
[16:17:46.435]                   name <- added[[kk]]
[16:17:46.435]                   NAME <- NAMES[[kk]]
[16:17:46.435]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.435]                     next
[16:17:46.435]                   args[[name]] <- ""
[16:17:46.435]                 }
[16:17:46.435]                 NAMES <- toupper(removed)
[16:17:46.435]                 for (kk in seq_along(NAMES)) {
[16:17:46.435]                   name <- removed[[kk]]
[16:17:46.435]                   NAME <- NAMES[[kk]]
[16:17:46.435]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.435]                     next
[16:17:46.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.435]                 }
[16:17:46.435]                 if (length(args) > 0) 
[16:17:46.435]                   base::do.call(base::Sys.setenv, args = args)
[16:17:46.435]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:46.435]             }
[16:17:46.435]             else {
[16:17:46.435]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:46.435]             }
[16:17:46.435]             {
[16:17:46.435]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:46.435]                   0L) {
[16:17:46.435]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:46.435]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:46.435]                   base::options(opts)
[16:17:46.435]                 }
[16:17:46.435]                 {
[16:17:46.435]                   {
[16:17:46.435]                     NULL
[16:17:46.435]                     RNGkind("Mersenne-Twister")
[16:17:46.435]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:46.435]                       inherits = FALSE)
[16:17:46.435]                   }
[16:17:46.435]                   options(future.plan = NULL)
[16:17:46.435]                   if (is.na(NA_character_)) 
[16:17:46.435]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.435]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:46.435]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:46.435]                     .init = FALSE)
[16:17:46.435]                 }
[16:17:46.435]             }
[16:17:46.435]         }
[16:17:46.435]     })
[16:17:46.435]     if (TRUE) {
[16:17:46.435]         base::sink(type = "output", split = FALSE)
[16:17:46.435]         if (TRUE) {
[16:17:46.435]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:46.435]         }
[16:17:46.435]         else {
[16:17:46.435]             ...future.result["stdout"] <- base::list(NULL)
[16:17:46.435]         }
[16:17:46.435]         base::close(...future.stdout)
[16:17:46.435]         ...future.stdout <- NULL
[16:17:46.435]     }
[16:17:46.435]     ...future.result$conditions <- ...future.conditions
[16:17:46.435]     ...future.result$finished <- base::Sys.time()
[16:17:46.435]     ...future.result
[16:17:46.435] }
[16:17:46.437] assign_globals() ...
[16:17:46.437] List of 5
[16:17:46.437]  $ ...future.FUN            :function (object, ...)  
[16:17:46.437]  $ future.call.arguments    :List of 1
[16:17:46.437]   ..$ digits: int 2
[16:17:46.437]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.437]  $ ...future.elements_ii    :List of 6
[16:17:46.437]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[16:17:46.437]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[16:17:46.437]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[16:17:46.437]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[16:17:46.437]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[16:17:46.437]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[16:17:46.437]  $ ...future.seeds_ii       : NULL
[16:17:46.437]  $ ...future.globals.maxSize: NULL
[16:17:46.437]  - attr(*, "where")=List of 5
[16:17:46.437]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:46.437]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:46.437]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:46.437]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:46.437]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:46.437]  - attr(*, "resolved")= logi FALSE
[16:17:46.437]  - attr(*, "total_size")= num 1296
[16:17:46.437]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.437]  - attr(*, "already-done")= logi TRUE
[16:17:46.443] - copied ‘...future.FUN’ to environment
[16:17:46.444] - copied ‘future.call.arguments’ to environment
[16:17:46.444] - copied ‘...future.elements_ii’ to environment
[16:17:46.444] - copied ‘...future.seeds_ii’ to environment
[16:17:46.444] - copied ‘...future.globals.maxSize’ to environment
[16:17:46.444] assign_globals() ... done
[16:17:46.444] plan(): Setting new future strategy stack:
[16:17:46.444] List of future strategies:
[16:17:46.444] 1. sequential:
[16:17:46.444]    - args: function (..., envir = parent.frame())
[16:17:46.444]    - tweaked: FALSE
[16:17:46.444]    - call: NULL
[16:17:46.445] plan(): nbrOfWorkers() = 1
[16:17:46.446] plan(): Setting new future strategy stack:
[16:17:46.446] List of future strategies:
[16:17:46.446] 1. multicore:
[16:17:46.446]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:46.446]    - tweaked: FALSE
[16:17:46.446]    - call: plan(strategy)
[16:17:46.449] plan(): nbrOfWorkers() = 1
[16:17:46.450] SequentialFuture started (and completed)
[16:17:46.450] - Launch lazy future ... done
[16:17:46.450] run() for ‘SequentialFuture’ ... done
[16:17:46.450] Created future:
[16:17:46.450] SequentialFuture:
[16:17:46.450] Label: ‘future_by-1’
[16:17:46.450] Expression:
[16:17:46.450] {
[16:17:46.450]     do.call(function(...) {
[16:17:46.450]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.450]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.450]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.450]             on.exit(options(oopts), add = TRUE)
[16:17:46.450]         }
[16:17:46.450]         {
[16:17:46.450]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.450]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.450]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.450]             })
[16:17:46.450]         }
[16:17:46.450]     }, args = future.call.arguments)
[16:17:46.450] }
[16:17:46.450] Lazy evaluation: FALSE
[16:17:46.450] Asynchronous evaluation: FALSE
[16:17:46.450] Local evaluation: TRUE
[16:17:46.450] Environment: R_GlobalEnv
[16:17:46.450] Capture standard output: TRUE
[16:17:46.450] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:46.450] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:46.450] Packages: <none>
[16:17:46.450] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:46.450] Resolved: TRUE
[16:17:46.450] Value: 5.48 KiB of class ‘list’
[16:17:46.450] Early signaling: FALSE
[16:17:46.450] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:46.450] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.451] Chunk #1 of 1 ... DONE
[16:17:46.451] Launching 1 futures (chunks) ... DONE
[16:17:46.451] Resolving 1 futures (chunks) ...
[16:17:46.451] resolve() on list ...
[16:17:46.451]  recursive: 0
[16:17:46.451]  length: 1
[16:17:46.452] 
[16:17:46.452] resolved() for ‘SequentialFuture’ ...
[16:17:46.452] - state: ‘finished’
[16:17:46.452] - run: TRUE
[16:17:46.452] - result: ‘FutureResult’
[16:17:46.452] resolved() for ‘SequentialFuture’ ... done
[16:17:46.452] Future #1
[16:17:46.452] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:46.452] - nx: 1
[16:17:46.452] - relay: TRUE
[16:17:46.453] - stdout: TRUE
[16:17:46.453] - signal: TRUE
[16:17:46.453] - resignal: FALSE
[16:17:46.453] - force: TRUE
[16:17:46.453] - relayed: [n=1] FALSE
[16:17:46.453] - queued futures: [n=1] FALSE
[16:17:46.453]  - until=1
[16:17:46.453]  - relaying element #1
[16:17:46.453] - relayed: [n=1] TRUE
[16:17:46.453] - queued futures: [n=1] TRUE
[16:17:46.454] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:46.454]  length: 0 (resolved future 1)
[16:17:46.454] Relaying remaining futures
[16:17:46.454] signalConditionsASAP(NULL, pos=0) ...
[16:17:46.454] - nx: 1
[16:17:46.454] - relay: TRUE
[16:17:46.454] - stdout: TRUE
[16:17:46.454] - signal: TRUE
[16:17:46.454] - resignal: FALSE
[16:17:46.454] - force: TRUE
[16:17:46.454] - relayed: [n=1] TRUE
[16:17:46.454] - queued futures: [n=1] TRUE
 - flush all
[16:17:46.455] - relayed: [n=1] TRUE
[16:17:46.455] - queued futures: [n=1] TRUE
[16:17:46.455] signalConditionsASAP(NULL, pos=0) ... done
[16:17:46.455] resolve() on list ... DONE
[16:17:46.455]  - Number of value chunks collected: 1
[16:17:46.455] Resolving 1 futures (chunks) ... DONE
[16:17:46.455] Reducing values from 1 chunks ...
[16:17:46.455]  - Number of values collected after concatenation: 6
[16:17:46.455]  - Number of values expected: 6
[16:17:46.455] Reducing values from 1 chunks ... DONE
[16:17:46.455] future_lapply() ... DONE
[16:17:46.456] future_by_internal() ... DONE
[16:17:46.481] future_by_internal() ...
[16:17:46.481] future_lapply() ...
[16:17:46.486] Number of chunks: 1
[16:17:46.486] getGlobalsAndPackagesXApply() ...
[16:17:46.486]  - future.globals: TRUE
[16:17:46.486] getGlobalsAndPackages() ...
[16:17:46.486] Searching for globals...
[16:17:46.488] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:17:46.488] Searching for globals ... DONE
[16:17:46.488] Resolving globals: FALSE
[16:17:46.489] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[16:17:46.489] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[16:17:46.489] - globals: [1] ‘FUN’
[16:17:46.489] - packages: [1] ‘stats’
[16:17:46.489] getGlobalsAndPackages() ... DONE
[16:17:46.489]  - globals found/used: [n=1] ‘FUN’
[16:17:46.490]  - needed namespaces: [n=1] ‘stats’
[16:17:46.490] Finding globals ... DONE
[16:17:46.490]  - use_args: TRUE
[16:17:46.490]  - Getting '...' globals ...
[16:17:46.490] resolve() on list ...
[16:17:46.490]  recursive: 0
[16:17:46.490]  length: 1
[16:17:46.490]  elements: ‘...’
[16:17:46.491]  length: 0 (resolved future 1)
[16:17:46.491] resolve() on list ... DONE
[16:17:46.491]    - '...' content: [n=1] ‘singular.ok’
[16:17:46.491] List of 1
[16:17:46.491]  $ ...:List of 1
[16:17:46.491]   ..$ singular.ok: logi FALSE
[16:17:46.491]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.491]  - attr(*, "where")=List of 1
[16:17:46.491]   ..$ ...:<environment: 0x55b56724d6e0> 
[16:17:46.491]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.491]  - attr(*, "resolved")= logi TRUE
[16:17:46.491]  - attr(*, "total_size")= num NA
[16:17:46.494]  - Getting '...' globals ... DONE
[16:17:46.494] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:46.494] List of 2
[16:17:46.494]  $ ...future.FUN:function (x, ...)  
[16:17:46.494]  $ ...          :List of 1
[16:17:46.494]   ..$ singular.ok: logi FALSE
[16:17:46.494]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.494]  - attr(*, "where")=List of 2
[16:17:46.494]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:46.494]   ..$ ...          :<environment: 0x55b56724d6e0> 
[16:17:46.494]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.494]  - attr(*, "resolved")= logi FALSE
[16:17:46.494]  - attr(*, "total_size")= num 5384
[16:17:46.497] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:46.497] getGlobalsAndPackagesXApply() ... DONE
[16:17:46.497] Number of futures (= number of chunks): 1
[16:17:46.498] Launching 1 futures (chunks) ...
[16:17:46.498] Chunk #1 of 1 ...
[16:17:46.498]  - Finding globals in 'X' for chunk #1 ...
[16:17:46.498] getGlobalsAndPackages() ...
[16:17:46.498] Searching for globals...
[16:17:46.498] 
[16:17:46.499] Searching for globals ... DONE
[16:17:46.499] - globals: [0] <none>
[16:17:46.499] getGlobalsAndPackages() ... DONE
[16:17:46.499]    + additional globals found: [n=0] 
[16:17:46.499]    + additional namespaces needed: [n=0] 
[16:17:46.499]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:46.499]  - seeds: <none>
[16:17:46.499]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.499] getGlobalsAndPackages() ...
[16:17:46.499] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.500] Resolving globals: FALSE
[16:17:46.500] Tweak future expression to call with '...' arguments ...
[16:17:46.500] {
[16:17:46.500]     do.call(function(...) {
[16:17:46.500]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.500]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.500]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.500]             on.exit(options(oopts), add = TRUE)
[16:17:46.500]         }
[16:17:46.500]         {
[16:17:46.500]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.500]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.500]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.500]             })
[16:17:46.500]         }
[16:17:46.500]     }, args = future.call.arguments)
[16:17:46.500] }
[16:17:46.500] Tweak future expression to call with '...' arguments ... DONE
[16:17:46.500] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.501] 
[16:17:46.501] getGlobalsAndPackages() ... DONE
[16:17:46.501] run() for ‘Future’ ...
[16:17:46.501] - state: ‘created’
[16:17:46.501] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:46.505] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.505] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:46.505]   - Field: ‘label’
[16:17:46.505]   - Field: ‘local’
[16:17:46.505]   - Field: ‘owner’
[16:17:46.505]   - Field: ‘envir’
[16:17:46.505]   - Field: ‘packages’
[16:17:46.505]   - Field: ‘gc’
[16:17:46.505]   - Field: ‘conditions’
[16:17:46.506]   - Field: ‘expr’
[16:17:46.506]   - Field: ‘uuid’
[16:17:46.506]   - Field: ‘seed’
[16:17:46.507]   - Field: ‘version’
[16:17:46.507]   - Field: ‘result’
[16:17:46.507]   - Field: ‘asynchronous’
[16:17:46.507]   - Field: ‘calls’
[16:17:46.508]   - Field: ‘globals’
[16:17:46.508]   - Field: ‘stdout’
[16:17:46.508]   - Field: ‘earlySignal’
[16:17:46.508]   - Field: ‘lazy’
[16:17:46.508]   - Field: ‘state’
[16:17:46.508] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:46.508] - Launch lazy future ...
[16:17:46.508] Packages needed by the future expression (n = 1): ‘stats’
[16:17:46.509] Packages needed by future strategies (n = 0): <none>
[16:17:46.509] {
[16:17:46.509]     {
[16:17:46.509]         {
[16:17:46.509]             ...future.startTime <- base::Sys.time()
[16:17:46.509]             {
[16:17:46.509]                 {
[16:17:46.509]                   {
[16:17:46.509]                     {
[16:17:46.509]                       base::local({
[16:17:46.509]                         has_future <- base::requireNamespace("future", 
[16:17:46.509]                           quietly = TRUE)
[16:17:46.509]                         if (has_future) {
[16:17:46.509]                           ns <- base::getNamespace("future")
[16:17:46.509]                           version <- ns[[".package"]][["version"]]
[16:17:46.509]                           if (is.null(version)) 
[16:17:46.509]                             version <- utils::packageVersion("future")
[16:17:46.509]                         }
[16:17:46.509]                         else {
[16:17:46.509]                           version <- NULL
[16:17:46.509]                         }
[16:17:46.509]                         if (!has_future || version < "1.8.0") {
[16:17:46.509]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:46.509]                             "", base::R.version$version.string), 
[16:17:46.509]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:46.509]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:46.509]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:46.509]                               "release", "version")], collapse = " "), 
[16:17:46.509]                             hostname = base::Sys.info()[["nodename"]])
[16:17:46.509]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:46.509]                             info)
[16:17:46.509]                           info <- base::paste(info, collapse = "; ")
[16:17:46.509]                           if (!has_future) {
[16:17:46.509]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:46.509]                               info)
[16:17:46.509]                           }
[16:17:46.509]                           else {
[16:17:46.509]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:46.509]                               info, version)
[16:17:46.509]                           }
[16:17:46.509]                           base::stop(msg)
[16:17:46.509]                         }
[16:17:46.509]                       })
[16:17:46.509]                     }
[16:17:46.509]                     base::local({
[16:17:46.509]                       for (pkg in "stats") {
[16:17:46.509]                         base::loadNamespace(pkg)
[16:17:46.509]                         base::library(pkg, character.only = TRUE)
[16:17:46.509]                       }
[16:17:46.509]                     })
[16:17:46.509]                   }
[16:17:46.509]                   ...future.strategy.old <- future::plan("list")
[16:17:46.509]                   options(future.plan = NULL)
[16:17:46.509]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.509]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:46.509]                 }
[16:17:46.509]                 ...future.workdir <- getwd()
[16:17:46.509]             }
[16:17:46.509]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:46.509]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:46.509]         }
[16:17:46.509]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:46.509]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:46.509]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:46.509]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:46.509]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:46.509]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:46.509]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:46.509]             base::names(...future.oldOptions))
[16:17:46.509]     }
[16:17:46.509]     if (FALSE) {
[16:17:46.509]     }
[16:17:46.509]     else {
[16:17:46.509]         if (TRUE) {
[16:17:46.509]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:46.509]                 open = "w")
[16:17:46.509]         }
[16:17:46.509]         else {
[16:17:46.509]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:46.509]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:46.509]         }
[16:17:46.509]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:46.509]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:46.509]             base::sink(type = "output", split = FALSE)
[16:17:46.509]             base::close(...future.stdout)
[16:17:46.509]         }, add = TRUE)
[16:17:46.509]     }
[16:17:46.509]     ...future.frame <- base::sys.nframe()
[16:17:46.509]     ...future.conditions <- base::list()
[16:17:46.509]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:46.509]     if (FALSE) {
[16:17:46.509]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:46.509]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:46.509]     }
[16:17:46.509]     ...future.result <- base::tryCatch({
[16:17:46.509]         base::withCallingHandlers({
[16:17:46.509]             ...future.value <- base::withVisible(base::local({
[16:17:46.509]                 do.call(function(...) {
[16:17:46.509]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.509]                   if (!identical(...future.globals.maxSize.org, 
[16:17:46.509]                     ...future.globals.maxSize)) {
[16:17:46.509]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.509]                     on.exit(options(oopts), add = TRUE)
[16:17:46.509]                   }
[16:17:46.509]                   {
[16:17:46.509]                     lapply(seq_along(...future.elements_ii), 
[16:17:46.509]                       FUN = function(jj) {
[16:17:46.509]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.509]                         ...future.FUN(...future.X_jj, ...)
[16:17:46.509]                       })
[16:17:46.509]                   }
[16:17:46.509]                 }, args = future.call.arguments)
[16:17:46.509]             }))
[16:17:46.509]             future::FutureResult(value = ...future.value$value, 
[16:17:46.509]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.509]                   ...future.rng), globalenv = if (FALSE) 
[16:17:46.509]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:46.509]                     ...future.globalenv.names))
[16:17:46.509]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:46.509]         }, condition = base::local({
[16:17:46.509]             c <- base::c
[16:17:46.509]             inherits <- base::inherits
[16:17:46.509]             invokeRestart <- base::invokeRestart
[16:17:46.509]             length <- base::length
[16:17:46.509]             list <- base::list
[16:17:46.509]             seq.int <- base::seq.int
[16:17:46.509]             signalCondition <- base::signalCondition
[16:17:46.509]             sys.calls <- base::sys.calls
[16:17:46.509]             `[[` <- base::`[[`
[16:17:46.509]             `+` <- base::`+`
[16:17:46.509]             `<<-` <- base::`<<-`
[16:17:46.509]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:46.509]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:46.509]                   3L)]
[16:17:46.509]             }
[16:17:46.509]             function(cond) {
[16:17:46.509]                 is_error <- inherits(cond, "error")
[16:17:46.509]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:46.509]                   NULL)
[16:17:46.509]                 if (is_error) {
[16:17:46.509]                   sessionInformation <- function() {
[16:17:46.509]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:46.509]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:46.509]                       search = base::search(), system = base::Sys.info())
[16:17:46.509]                   }
[16:17:46.509]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.509]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:46.509]                     cond$call), session = sessionInformation(), 
[16:17:46.509]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:46.509]                   signalCondition(cond)
[16:17:46.509]                 }
[16:17:46.509]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:46.509]                 "immediateCondition"))) {
[16:17:46.509]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:46.509]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.509]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:46.509]                   if (TRUE && !signal) {
[16:17:46.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.509]                     {
[16:17:46.509]                       inherits <- base::inherits
[16:17:46.509]                       invokeRestart <- base::invokeRestart
[16:17:46.509]                       is.null <- base::is.null
[16:17:46.509]                       muffled <- FALSE
[16:17:46.509]                       if (inherits(cond, "message")) {
[16:17:46.509]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.509]                         if (muffled) 
[16:17:46.509]                           invokeRestart("muffleMessage")
[16:17:46.509]                       }
[16:17:46.509]                       else if (inherits(cond, "warning")) {
[16:17:46.509]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.509]                         if (muffled) 
[16:17:46.509]                           invokeRestart("muffleWarning")
[16:17:46.509]                       }
[16:17:46.509]                       else if (inherits(cond, "condition")) {
[16:17:46.509]                         if (!is.null(pattern)) {
[16:17:46.509]                           computeRestarts <- base::computeRestarts
[16:17:46.509]                           grepl <- base::grepl
[16:17:46.509]                           restarts <- computeRestarts(cond)
[16:17:46.509]                           for (restart in restarts) {
[16:17:46.509]                             name <- restart$name
[16:17:46.509]                             if (is.null(name)) 
[16:17:46.509]                               next
[16:17:46.509]                             if (!grepl(pattern, name)) 
[16:17:46.509]                               next
[16:17:46.509]                             invokeRestart(restart)
[16:17:46.509]                             muffled <- TRUE
[16:17:46.509]                             break
[16:17:46.509]                           }
[16:17:46.509]                         }
[16:17:46.509]                       }
[16:17:46.509]                       invisible(muffled)
[16:17:46.509]                     }
[16:17:46.509]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.509]                   }
[16:17:46.509]                 }
[16:17:46.509]                 else {
[16:17:46.509]                   if (TRUE) {
[16:17:46.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.509]                     {
[16:17:46.509]                       inherits <- base::inherits
[16:17:46.509]                       invokeRestart <- base::invokeRestart
[16:17:46.509]                       is.null <- base::is.null
[16:17:46.509]                       muffled <- FALSE
[16:17:46.509]                       if (inherits(cond, "message")) {
[16:17:46.509]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.509]                         if (muffled) 
[16:17:46.509]                           invokeRestart("muffleMessage")
[16:17:46.509]                       }
[16:17:46.509]                       else if (inherits(cond, "warning")) {
[16:17:46.509]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.509]                         if (muffled) 
[16:17:46.509]                           invokeRestart("muffleWarning")
[16:17:46.509]                       }
[16:17:46.509]                       else if (inherits(cond, "condition")) {
[16:17:46.509]                         if (!is.null(pattern)) {
[16:17:46.509]                           computeRestarts <- base::computeRestarts
[16:17:46.509]                           grepl <- base::grepl
[16:17:46.509]                           restarts <- computeRestarts(cond)
[16:17:46.509]                           for (restart in restarts) {
[16:17:46.509]                             name <- restart$name
[16:17:46.509]                             if (is.null(name)) 
[16:17:46.509]                               next
[16:17:46.509]                             if (!grepl(pattern, name)) 
[16:17:46.509]                               next
[16:17:46.509]                             invokeRestart(restart)
[16:17:46.509]                             muffled <- TRUE
[16:17:46.509]                             break
[16:17:46.509]                           }
[16:17:46.509]                         }
[16:17:46.509]                       }
[16:17:46.509]                       invisible(muffled)
[16:17:46.509]                     }
[16:17:46.509]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.509]                   }
[16:17:46.509]                 }
[16:17:46.509]             }
[16:17:46.509]         }))
[16:17:46.509]     }, error = function(ex) {
[16:17:46.509]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:46.509]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.509]                 ...future.rng), started = ...future.startTime, 
[16:17:46.509]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:46.509]             version = "1.8"), class = "FutureResult")
[16:17:46.509]     }, finally = {
[16:17:46.509]         if (!identical(...future.workdir, getwd())) 
[16:17:46.509]             setwd(...future.workdir)
[16:17:46.509]         {
[16:17:46.509]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:46.509]                 ...future.oldOptions$nwarnings <- NULL
[16:17:46.509]             }
[16:17:46.509]             base::options(...future.oldOptions)
[16:17:46.509]             if (.Platform$OS.type == "windows") {
[16:17:46.509]                 old_names <- names(...future.oldEnvVars)
[16:17:46.509]                 envs <- base::Sys.getenv()
[16:17:46.509]                 names <- names(envs)
[16:17:46.509]                 common <- intersect(names, old_names)
[16:17:46.509]                 added <- setdiff(names, old_names)
[16:17:46.509]                 removed <- setdiff(old_names, names)
[16:17:46.509]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:46.509]                   envs[common]]
[16:17:46.509]                 NAMES <- toupper(changed)
[16:17:46.509]                 args <- list()
[16:17:46.509]                 for (kk in seq_along(NAMES)) {
[16:17:46.509]                   name <- changed[[kk]]
[16:17:46.509]                   NAME <- NAMES[[kk]]
[16:17:46.509]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.509]                     next
[16:17:46.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.509]                 }
[16:17:46.509]                 NAMES <- toupper(added)
[16:17:46.509]                 for (kk in seq_along(NAMES)) {
[16:17:46.509]                   name <- added[[kk]]
[16:17:46.509]                   NAME <- NAMES[[kk]]
[16:17:46.509]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.509]                     next
[16:17:46.509]                   args[[name]] <- ""
[16:17:46.509]                 }
[16:17:46.509]                 NAMES <- toupper(removed)
[16:17:46.509]                 for (kk in seq_along(NAMES)) {
[16:17:46.509]                   name <- removed[[kk]]
[16:17:46.509]                   NAME <- NAMES[[kk]]
[16:17:46.509]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.509]                     next
[16:17:46.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.509]                 }
[16:17:46.509]                 if (length(args) > 0) 
[16:17:46.509]                   base::do.call(base::Sys.setenv, args = args)
[16:17:46.509]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:46.509]             }
[16:17:46.509]             else {
[16:17:46.509]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:46.509]             }
[16:17:46.509]             {
[16:17:46.509]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:46.509]                   0L) {
[16:17:46.509]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:46.509]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:46.509]                   base::options(opts)
[16:17:46.509]                 }
[16:17:46.509]                 {
[16:17:46.509]                   {
[16:17:46.509]                     NULL
[16:17:46.509]                     RNGkind("Mersenne-Twister")
[16:17:46.509]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:46.509]                       inherits = FALSE)
[16:17:46.509]                   }
[16:17:46.509]                   options(future.plan = NULL)
[16:17:46.509]                   if (is.na(NA_character_)) 
[16:17:46.509]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.509]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:46.509]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:46.509]                     .init = FALSE)
[16:17:46.509]                 }
[16:17:46.509]             }
[16:17:46.509]         }
[16:17:46.509]     })
[16:17:46.509]     if (TRUE) {
[16:17:46.509]         base::sink(type = "output", split = FALSE)
[16:17:46.509]         if (TRUE) {
[16:17:46.509]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:46.509]         }
[16:17:46.509]         else {
[16:17:46.509]             ...future.result["stdout"] <- base::list(NULL)
[16:17:46.509]         }
[16:17:46.509]         base::close(...future.stdout)
[16:17:46.509]         ...future.stdout <- NULL
[16:17:46.509]     }
[16:17:46.509]     ...future.result$conditions <- ...future.conditions
[16:17:46.509]     ...future.result$finished <- base::Sys.time()
[16:17:46.509]     ...future.result
[16:17:46.509] }
[16:17:46.511] assign_globals() ...
[16:17:46.511] List of 5
[16:17:46.511]  $ ...future.FUN            :function (x, ...)  
[16:17:46.511]  $ future.call.arguments    :List of 1
[16:17:46.511]   ..$ singular.ok: logi FALSE
[16:17:46.511]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.511]  $ ...future.elements_ii    :List of 3
[16:17:46.511]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.511]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:17:46.511]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.511]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:46.511]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.511]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:17:46.511]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.511]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:17:46.511]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.511]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:17:46.511]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.511]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:17:46.511]  $ ...future.seeds_ii       : NULL
[16:17:46.511]  $ ...future.globals.maxSize: NULL
[16:17:46.511]  - attr(*, "where")=List of 5
[16:17:46.511]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:46.511]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:46.511]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:46.511]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:46.511]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:46.511]  - attr(*, "resolved")= logi FALSE
[16:17:46.511]  - attr(*, "total_size")= num 5384
[16:17:46.511]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.511]  - attr(*, "already-done")= logi TRUE
[16:17:46.520] - reassign environment for ‘...future.FUN’
[16:17:46.520] - copied ‘...future.FUN’ to environment
[16:17:46.520] - copied ‘future.call.arguments’ to environment
[16:17:46.520] - copied ‘...future.elements_ii’ to environment
[16:17:46.520] - copied ‘...future.seeds_ii’ to environment
[16:17:46.520] - copied ‘...future.globals.maxSize’ to environment
[16:17:46.520] assign_globals() ... done
[16:17:46.521] plan(): Setting new future strategy stack:
[16:17:46.521] List of future strategies:
[16:17:46.521] 1. sequential:
[16:17:46.521]    - args: function (..., envir = parent.frame())
[16:17:46.521]    - tweaked: FALSE
[16:17:46.521]    - call: NULL
[16:17:46.521] plan(): nbrOfWorkers() = 1
[16:17:46.524] plan(): Setting new future strategy stack:
[16:17:46.524] List of future strategies:
[16:17:46.524] 1. multicore:
[16:17:46.524]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:46.524]    - tweaked: FALSE
[16:17:46.524]    - call: plan(strategy)
[16:17:46.527] plan(): nbrOfWorkers() = 1
[16:17:46.528] SequentialFuture started (and completed)
[16:17:46.528] - Launch lazy future ... done
[16:17:46.528] run() for ‘SequentialFuture’ ... done
[16:17:46.528] Created future:
[16:17:46.528] SequentialFuture:
[16:17:46.528] Label: ‘future_by-1’
[16:17:46.528] Expression:
[16:17:46.528] {
[16:17:46.528]     do.call(function(...) {
[16:17:46.528]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.528]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.528]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.528]             on.exit(options(oopts), add = TRUE)
[16:17:46.528]         }
[16:17:46.528]         {
[16:17:46.528]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.528]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.528]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.528]             })
[16:17:46.528]         }
[16:17:46.528]     }, args = future.call.arguments)
[16:17:46.528] }
[16:17:46.528] Lazy evaluation: FALSE
[16:17:46.528] Asynchronous evaluation: FALSE
[16:17:46.528] Local evaluation: TRUE
[16:17:46.528] Environment: R_GlobalEnv
[16:17:46.528] Capture standard output: TRUE
[16:17:46.528] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:46.528] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:46.528] Packages: 1 packages (‘stats’)
[16:17:46.528] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:46.528] Resolved: TRUE
[16:17:46.528] Value: 26.06 KiB of class ‘list’
[16:17:46.528] Early signaling: FALSE
[16:17:46.528] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:46.528] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.529] Chunk #1 of 1 ... DONE
[16:17:46.530] Launching 1 futures (chunks) ... DONE
[16:17:46.530] Resolving 1 futures (chunks) ...
[16:17:46.530] resolve() on list ...
[16:17:46.530]  recursive: 0
[16:17:46.530]  length: 1
[16:17:46.530] 
[16:17:46.530] resolved() for ‘SequentialFuture’ ...
[16:17:46.530] - state: ‘finished’
[16:17:46.530] - run: TRUE
[16:17:46.530] - result: ‘FutureResult’
[16:17:46.530] resolved() for ‘SequentialFuture’ ... done
[16:17:46.531] Future #1
[16:17:46.531] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:46.531] - nx: 1
[16:17:46.531] - relay: TRUE
[16:17:46.531] - stdout: TRUE
[16:17:46.532] - signal: TRUE
[16:17:46.532] - resignal: FALSE
[16:17:46.532] - force: TRUE
[16:17:46.532] - relayed: [n=1] FALSE
[16:17:46.533] - queued futures: [n=1] FALSE
[16:17:46.533]  - until=1
[16:17:46.533]  - relaying element #1
[16:17:46.533] - relayed: [n=1] TRUE
[16:17:46.533] - queued futures: [n=1] TRUE
[16:17:46.533] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:46.533]  length: 0 (resolved future 1)
[16:17:46.533] Relaying remaining futures
[16:17:46.533] signalConditionsASAP(NULL, pos=0) ...
[16:17:46.534] - nx: 1
[16:17:46.534] - relay: TRUE
[16:17:46.534] - stdout: TRUE
[16:17:46.534] - signal: TRUE
[16:17:46.534] - resignal: FALSE
[16:17:46.534] - force: TRUE
[16:17:46.534] - relayed: [n=1] TRUE
[16:17:46.534] - queued futures: [n=1] TRUE
 - flush all
[16:17:46.534] - relayed: [n=1] TRUE
[16:17:46.534] - queued futures: [n=1] TRUE
[16:17:46.534] signalConditionsASAP(NULL, pos=0) ... done
[16:17:46.535] resolve() on list ... DONE
[16:17:46.535]  - Number of value chunks collected: 1
[16:17:46.535] Resolving 1 futures (chunks) ... DONE
[16:17:46.535] Reducing values from 1 chunks ...
[16:17:46.535]  - Number of values collected after concatenation: 3
[16:17:46.535]  - Number of values expected: 3
[16:17:46.535] Reducing values from 1 chunks ... DONE
[16:17:46.535] future_lapply() ... DONE
[16:17:46.535] future_by_internal() ... DONE
[16:17:46.539] future_by_internal() ...
[16:17:46.539] future_lapply() ...
[16:17:46.543] Number of chunks: 1
[16:17:46.543] getGlobalsAndPackagesXApply() ...
[16:17:46.543]  - future.globals: TRUE
[16:17:46.543] getGlobalsAndPackages() ...
[16:17:46.544] Searching for globals...
[16:17:46.545] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:17:46.545] Searching for globals ... DONE
[16:17:46.545] Resolving globals: FALSE
[16:17:46.546] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[16:17:46.546] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[16:17:46.546] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[16:17:46.546] - packages: [1] ‘stats’
[16:17:46.547] getGlobalsAndPackages() ... DONE
[16:17:46.547]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[16:17:46.547]  - needed namespaces: [n=1] ‘stats’
[16:17:46.547] Finding globals ... DONE
[16:17:46.547]  - use_args: TRUE
[16:17:46.547]  - Getting '...' globals ...
[16:17:46.547] resolve() on list ...
[16:17:46.547]  recursive: 0
[16:17:46.547]  length: 1
[16:17:46.548]  elements: ‘...’
[16:17:46.548]  length: 0 (resolved future 1)
[16:17:46.548] resolve() on list ... DONE
[16:17:46.548]    - '...' content: [n=0] 
[16:17:46.548] List of 1
[16:17:46.548]  $ ...: list()
[16:17:46.548]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.548]  - attr(*, "where")=List of 1
[16:17:46.548]   ..$ ...:<environment: 0x55b5676007d8> 
[16:17:46.548]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.548]  - attr(*, "resolved")= logi TRUE
[16:17:46.548]  - attr(*, "total_size")= num NA
[16:17:46.550]  - Getting '...' globals ... DONE
[16:17:46.551] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[16:17:46.551] List of 4
[16:17:46.551]  $ ...future.FUN:function (x)  
[16:17:46.551]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:17:46.551]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:46.551]  $ ...          : list()
[16:17:46.551]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.551]  - attr(*, "where")=List of 4
[16:17:46.551]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:46.551]   ..$ breaks       :<environment: R_EmptyEnv> 
[16:17:46.551]   ..$ wool         :<environment: R_EmptyEnv> 
[16:17:46.551]   ..$ ...          :<environment: 0x55b5676007d8> 
[16:17:46.551]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.551]  - attr(*, "resolved")= logi FALSE
[16:17:46.551]  - attr(*, "total_size")= num 2320
[16:17:46.555] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:46.556] getGlobalsAndPackagesXApply() ... DONE
[16:17:46.556] Number of futures (= number of chunks): 1
[16:17:46.556] Launching 1 futures (chunks) ...
[16:17:46.556] Chunk #1 of 1 ...
[16:17:46.556]  - Finding globals in 'X' for chunk #1 ...
[16:17:46.556] getGlobalsAndPackages() ...
[16:17:46.556] Searching for globals...
[16:17:46.557] 
[16:17:46.557] Searching for globals ... DONE
[16:17:46.557] - globals: [0] <none>
[16:17:46.557] getGlobalsAndPackages() ... DONE
[16:17:46.557]    + additional globals found: [n=0] 
[16:17:46.557]    + additional namespaces needed: [n=0] 
[16:17:46.557]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:46.557]  - seeds: <none>
[16:17:46.558]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.558] getGlobalsAndPackages() ...
[16:17:46.558] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.558] Resolving globals: FALSE
[16:17:46.558] Tweak future expression to call with '...' arguments ...
[16:17:46.558] {
[16:17:46.558]     do.call(function(...) {
[16:17:46.558]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.558]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.558]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.558]             on.exit(options(oopts), add = TRUE)
[16:17:46.558]         }
[16:17:46.558]         {
[16:17:46.558]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.558]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.558]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.558]             })
[16:17:46.558]         }
[16:17:46.558]     }, args = future.call.arguments)
[16:17:46.558] }
[16:17:46.558] Tweak future expression to call with '...' arguments ... DONE
[16:17:46.559] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.559] 
[16:17:46.559] getGlobalsAndPackages() ... DONE
[16:17:46.559] run() for ‘Future’ ...
[16:17:46.559] - state: ‘created’
[16:17:46.559] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:46.563] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.563] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:46.563]   - Field: ‘label’
[16:17:46.563]   - Field: ‘local’
[16:17:46.563]   - Field: ‘owner’
[16:17:46.563]   - Field: ‘envir’
[16:17:46.563]   - Field: ‘packages’
[16:17:46.563]   - Field: ‘gc’
[16:17:46.564]   - Field: ‘conditions’
[16:17:46.564]   - Field: ‘expr’
[16:17:46.564]   - Field: ‘uuid’
[16:17:46.564]   - Field: ‘seed’
[16:17:46.564]   - Field: ‘version’
[16:17:46.564]   - Field: ‘result’
[16:17:46.564]   - Field: ‘asynchronous’
[16:17:46.564]   - Field: ‘calls’
[16:17:46.564]   - Field: ‘globals’
[16:17:46.564]   - Field: ‘stdout’
[16:17:46.565]   - Field: ‘earlySignal’
[16:17:46.565]   - Field: ‘lazy’
[16:17:46.565]   - Field: ‘state’
[16:17:46.565] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:46.565] - Launch lazy future ...
[16:17:46.565] Packages needed by the future expression (n = 1): ‘stats’
[16:17:46.565] Packages needed by future strategies (n = 0): <none>
[16:17:46.566] {
[16:17:46.566]     {
[16:17:46.566]         {
[16:17:46.566]             ...future.startTime <- base::Sys.time()
[16:17:46.566]             {
[16:17:46.566]                 {
[16:17:46.566]                   {
[16:17:46.566]                     {
[16:17:46.566]                       base::local({
[16:17:46.566]                         has_future <- base::requireNamespace("future", 
[16:17:46.566]                           quietly = TRUE)
[16:17:46.566]                         if (has_future) {
[16:17:46.566]                           ns <- base::getNamespace("future")
[16:17:46.566]                           version <- ns[[".package"]][["version"]]
[16:17:46.566]                           if (is.null(version)) 
[16:17:46.566]                             version <- utils::packageVersion("future")
[16:17:46.566]                         }
[16:17:46.566]                         else {
[16:17:46.566]                           version <- NULL
[16:17:46.566]                         }
[16:17:46.566]                         if (!has_future || version < "1.8.0") {
[16:17:46.566]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:46.566]                             "", base::R.version$version.string), 
[16:17:46.566]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:46.566]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:46.566]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:46.566]                               "release", "version")], collapse = " "), 
[16:17:46.566]                             hostname = base::Sys.info()[["nodename"]])
[16:17:46.566]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:46.566]                             info)
[16:17:46.566]                           info <- base::paste(info, collapse = "; ")
[16:17:46.566]                           if (!has_future) {
[16:17:46.566]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:46.566]                               info)
[16:17:46.566]                           }
[16:17:46.566]                           else {
[16:17:46.566]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:46.566]                               info, version)
[16:17:46.566]                           }
[16:17:46.566]                           base::stop(msg)
[16:17:46.566]                         }
[16:17:46.566]                       })
[16:17:46.566]                     }
[16:17:46.566]                     base::local({
[16:17:46.566]                       for (pkg in "stats") {
[16:17:46.566]                         base::loadNamespace(pkg)
[16:17:46.566]                         base::library(pkg, character.only = TRUE)
[16:17:46.566]                       }
[16:17:46.566]                     })
[16:17:46.566]                   }
[16:17:46.566]                   ...future.strategy.old <- future::plan("list")
[16:17:46.566]                   options(future.plan = NULL)
[16:17:46.566]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.566]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:46.566]                 }
[16:17:46.566]                 ...future.workdir <- getwd()
[16:17:46.566]             }
[16:17:46.566]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:46.566]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:46.566]         }
[16:17:46.566]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:46.566]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:46.566]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:46.566]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:46.566]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:46.566]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:46.566]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:46.566]             base::names(...future.oldOptions))
[16:17:46.566]     }
[16:17:46.566]     if (FALSE) {
[16:17:46.566]     }
[16:17:46.566]     else {
[16:17:46.566]         if (TRUE) {
[16:17:46.566]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:46.566]                 open = "w")
[16:17:46.566]         }
[16:17:46.566]         else {
[16:17:46.566]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:46.566]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:46.566]         }
[16:17:46.566]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:46.566]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:46.566]             base::sink(type = "output", split = FALSE)
[16:17:46.566]             base::close(...future.stdout)
[16:17:46.566]         }, add = TRUE)
[16:17:46.566]     }
[16:17:46.566]     ...future.frame <- base::sys.nframe()
[16:17:46.566]     ...future.conditions <- base::list()
[16:17:46.566]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:46.566]     if (FALSE) {
[16:17:46.566]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:46.566]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:46.566]     }
[16:17:46.566]     ...future.result <- base::tryCatch({
[16:17:46.566]         base::withCallingHandlers({
[16:17:46.566]             ...future.value <- base::withVisible(base::local({
[16:17:46.566]                 do.call(function(...) {
[16:17:46.566]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.566]                   if (!identical(...future.globals.maxSize.org, 
[16:17:46.566]                     ...future.globals.maxSize)) {
[16:17:46.566]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.566]                     on.exit(options(oopts), add = TRUE)
[16:17:46.566]                   }
[16:17:46.566]                   {
[16:17:46.566]                     lapply(seq_along(...future.elements_ii), 
[16:17:46.566]                       FUN = function(jj) {
[16:17:46.566]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.566]                         ...future.FUN(...future.X_jj, ...)
[16:17:46.566]                       })
[16:17:46.566]                   }
[16:17:46.566]                 }, args = future.call.arguments)
[16:17:46.566]             }))
[16:17:46.566]             future::FutureResult(value = ...future.value$value, 
[16:17:46.566]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.566]                   ...future.rng), globalenv = if (FALSE) 
[16:17:46.566]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:46.566]                     ...future.globalenv.names))
[16:17:46.566]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:46.566]         }, condition = base::local({
[16:17:46.566]             c <- base::c
[16:17:46.566]             inherits <- base::inherits
[16:17:46.566]             invokeRestart <- base::invokeRestart
[16:17:46.566]             length <- base::length
[16:17:46.566]             list <- base::list
[16:17:46.566]             seq.int <- base::seq.int
[16:17:46.566]             signalCondition <- base::signalCondition
[16:17:46.566]             sys.calls <- base::sys.calls
[16:17:46.566]             `[[` <- base::`[[`
[16:17:46.566]             `+` <- base::`+`
[16:17:46.566]             `<<-` <- base::`<<-`
[16:17:46.566]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:46.566]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:46.566]                   3L)]
[16:17:46.566]             }
[16:17:46.566]             function(cond) {
[16:17:46.566]                 is_error <- inherits(cond, "error")
[16:17:46.566]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:46.566]                   NULL)
[16:17:46.566]                 if (is_error) {
[16:17:46.566]                   sessionInformation <- function() {
[16:17:46.566]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:46.566]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:46.566]                       search = base::search(), system = base::Sys.info())
[16:17:46.566]                   }
[16:17:46.566]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.566]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:46.566]                     cond$call), session = sessionInformation(), 
[16:17:46.566]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:46.566]                   signalCondition(cond)
[16:17:46.566]                 }
[16:17:46.566]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:46.566]                 "immediateCondition"))) {
[16:17:46.566]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:46.566]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.566]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:46.566]                   if (TRUE && !signal) {
[16:17:46.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.566]                     {
[16:17:46.566]                       inherits <- base::inherits
[16:17:46.566]                       invokeRestart <- base::invokeRestart
[16:17:46.566]                       is.null <- base::is.null
[16:17:46.566]                       muffled <- FALSE
[16:17:46.566]                       if (inherits(cond, "message")) {
[16:17:46.566]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.566]                         if (muffled) 
[16:17:46.566]                           invokeRestart("muffleMessage")
[16:17:46.566]                       }
[16:17:46.566]                       else if (inherits(cond, "warning")) {
[16:17:46.566]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.566]                         if (muffled) 
[16:17:46.566]                           invokeRestart("muffleWarning")
[16:17:46.566]                       }
[16:17:46.566]                       else if (inherits(cond, "condition")) {
[16:17:46.566]                         if (!is.null(pattern)) {
[16:17:46.566]                           computeRestarts <- base::computeRestarts
[16:17:46.566]                           grepl <- base::grepl
[16:17:46.566]                           restarts <- computeRestarts(cond)
[16:17:46.566]                           for (restart in restarts) {
[16:17:46.566]                             name <- restart$name
[16:17:46.566]                             if (is.null(name)) 
[16:17:46.566]                               next
[16:17:46.566]                             if (!grepl(pattern, name)) 
[16:17:46.566]                               next
[16:17:46.566]                             invokeRestart(restart)
[16:17:46.566]                             muffled <- TRUE
[16:17:46.566]                             break
[16:17:46.566]                           }
[16:17:46.566]                         }
[16:17:46.566]                       }
[16:17:46.566]                       invisible(muffled)
[16:17:46.566]                     }
[16:17:46.566]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.566]                   }
[16:17:46.566]                 }
[16:17:46.566]                 else {
[16:17:46.566]                   if (TRUE) {
[16:17:46.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.566]                     {
[16:17:46.566]                       inherits <- base::inherits
[16:17:46.566]                       invokeRestart <- base::invokeRestart
[16:17:46.566]                       is.null <- base::is.null
[16:17:46.566]                       muffled <- FALSE
[16:17:46.566]                       if (inherits(cond, "message")) {
[16:17:46.566]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.566]                         if (muffled) 
[16:17:46.566]                           invokeRestart("muffleMessage")
[16:17:46.566]                       }
[16:17:46.566]                       else if (inherits(cond, "warning")) {
[16:17:46.566]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.566]                         if (muffled) 
[16:17:46.566]                           invokeRestart("muffleWarning")
[16:17:46.566]                       }
[16:17:46.566]                       else if (inherits(cond, "condition")) {
[16:17:46.566]                         if (!is.null(pattern)) {
[16:17:46.566]                           computeRestarts <- base::computeRestarts
[16:17:46.566]                           grepl <- base::grepl
[16:17:46.566]                           restarts <- computeRestarts(cond)
[16:17:46.566]                           for (restart in restarts) {
[16:17:46.566]                             name <- restart$name
[16:17:46.566]                             if (is.null(name)) 
[16:17:46.566]                               next
[16:17:46.566]                             if (!grepl(pattern, name)) 
[16:17:46.566]                               next
[16:17:46.566]                             invokeRestart(restart)
[16:17:46.566]                             muffled <- TRUE
[16:17:46.566]                             break
[16:17:46.566]                           }
[16:17:46.566]                         }
[16:17:46.566]                       }
[16:17:46.566]                       invisible(muffled)
[16:17:46.566]                     }
[16:17:46.566]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.566]                   }
[16:17:46.566]                 }
[16:17:46.566]             }
[16:17:46.566]         }))
[16:17:46.566]     }, error = function(ex) {
[16:17:46.566]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:46.566]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.566]                 ...future.rng), started = ...future.startTime, 
[16:17:46.566]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:46.566]             version = "1.8"), class = "FutureResult")
[16:17:46.566]     }, finally = {
[16:17:46.566]         if (!identical(...future.workdir, getwd())) 
[16:17:46.566]             setwd(...future.workdir)
[16:17:46.566]         {
[16:17:46.566]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:46.566]                 ...future.oldOptions$nwarnings <- NULL
[16:17:46.566]             }
[16:17:46.566]             base::options(...future.oldOptions)
[16:17:46.566]             if (.Platform$OS.type == "windows") {
[16:17:46.566]                 old_names <- names(...future.oldEnvVars)
[16:17:46.566]                 envs <- base::Sys.getenv()
[16:17:46.566]                 names <- names(envs)
[16:17:46.566]                 common <- intersect(names, old_names)
[16:17:46.566]                 added <- setdiff(names, old_names)
[16:17:46.566]                 removed <- setdiff(old_names, names)
[16:17:46.566]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:46.566]                   envs[common]]
[16:17:46.566]                 NAMES <- toupper(changed)
[16:17:46.566]                 args <- list()
[16:17:46.566]                 for (kk in seq_along(NAMES)) {
[16:17:46.566]                   name <- changed[[kk]]
[16:17:46.566]                   NAME <- NAMES[[kk]]
[16:17:46.566]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.566]                     next
[16:17:46.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.566]                 }
[16:17:46.566]                 NAMES <- toupper(added)
[16:17:46.566]                 for (kk in seq_along(NAMES)) {
[16:17:46.566]                   name <- added[[kk]]
[16:17:46.566]                   NAME <- NAMES[[kk]]
[16:17:46.566]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.566]                     next
[16:17:46.566]                   args[[name]] <- ""
[16:17:46.566]                 }
[16:17:46.566]                 NAMES <- toupper(removed)
[16:17:46.566]                 for (kk in seq_along(NAMES)) {
[16:17:46.566]                   name <- removed[[kk]]
[16:17:46.566]                   NAME <- NAMES[[kk]]
[16:17:46.566]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.566]                     next
[16:17:46.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.566]                 }
[16:17:46.566]                 if (length(args) > 0) 
[16:17:46.566]                   base::do.call(base::Sys.setenv, args = args)
[16:17:46.566]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:46.566]             }
[16:17:46.566]             else {
[16:17:46.566]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:46.566]             }
[16:17:46.566]             {
[16:17:46.566]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:46.566]                   0L) {
[16:17:46.566]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:46.566]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:46.566]                   base::options(opts)
[16:17:46.566]                 }
[16:17:46.566]                 {
[16:17:46.566]                   {
[16:17:46.566]                     NULL
[16:17:46.566]                     RNGkind("Mersenne-Twister")
[16:17:46.566]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:46.566]                       inherits = FALSE)
[16:17:46.566]                   }
[16:17:46.566]                   options(future.plan = NULL)
[16:17:46.566]                   if (is.na(NA_character_)) 
[16:17:46.566]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.566]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:46.566]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:46.566]                     .init = FALSE)
[16:17:46.566]                 }
[16:17:46.566]             }
[16:17:46.566]         }
[16:17:46.566]     })
[16:17:46.566]     if (TRUE) {
[16:17:46.566]         base::sink(type = "output", split = FALSE)
[16:17:46.566]         if (TRUE) {
[16:17:46.566]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:46.566]         }
[16:17:46.566]         else {
[16:17:46.566]             ...future.result["stdout"] <- base::list(NULL)
[16:17:46.566]         }
[16:17:46.566]         base::close(...future.stdout)
[16:17:46.566]         ...future.stdout <- NULL
[16:17:46.566]     }
[16:17:46.566]     ...future.result$conditions <- ...future.conditions
[16:17:46.566]     ...future.result$finished <- base::Sys.time()
[16:17:46.566]     ...future.result
[16:17:46.566] }
[16:17:46.567] assign_globals() ...
[16:17:46.568] List of 7
[16:17:46.568]  $ ...future.FUN            :function (x)  
[16:17:46.568]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:17:46.568]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:46.568]  $ future.call.arguments    : list()
[16:17:46.568]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.568]  $ ...future.elements_ii    :List of 3
[16:17:46.568]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.568]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:17:46.568]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.568]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:46.568]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.568]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:17:46.568]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.568]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:17:46.568]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.568]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:17:46.568]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.568]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:17:46.568]  $ ...future.seeds_ii       : NULL
[16:17:46.568]  $ ...future.globals.maxSize: NULL
[16:17:46.568]  - attr(*, "where")=List of 7
[16:17:46.568]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:46.568]   ..$ breaks                   :<environment: R_EmptyEnv> 
[16:17:46.568]   ..$ wool                     :<environment: R_EmptyEnv> 
[16:17:46.568]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:46.568]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:46.568]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:46.568]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:46.568]  - attr(*, "resolved")= logi FALSE
[16:17:46.568]  - attr(*, "total_size")= num 2320
[16:17:46.568]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.568]  - attr(*, "already-done")= logi TRUE
[16:17:46.578] - reassign environment for ‘...future.FUN’
[16:17:46.578] - copied ‘...future.FUN’ to environment
[16:17:46.578] - copied ‘breaks’ to environment
[16:17:46.578] - copied ‘wool’ to environment
[16:17:46.578] - copied ‘future.call.arguments’ to environment
[16:17:46.578] - copied ‘...future.elements_ii’ to environment
[16:17:46.579] - copied ‘...future.seeds_ii’ to environment
[16:17:46.579] - copied ‘...future.globals.maxSize’ to environment
[16:17:46.579] assign_globals() ... done
[16:17:46.579] plan(): Setting new future strategy stack:
[16:17:46.579] List of future strategies:
[16:17:46.579] 1. sequential:
[16:17:46.579]    - args: function (..., envir = parent.frame())
[16:17:46.579]    - tweaked: FALSE
[16:17:46.579]    - call: NULL
[16:17:46.580] plan(): nbrOfWorkers() = 1
[16:17:46.582] plan(): Setting new future strategy stack:
[16:17:46.582] List of future strategies:
[16:17:46.582] 1. multicore:
[16:17:46.582]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:46.582]    - tweaked: FALSE
[16:17:46.582]    - call: plan(strategy)
[16:17:46.586] plan(): nbrOfWorkers() = 1
[16:17:46.586] SequentialFuture started (and completed)
[16:17:46.586] - Launch lazy future ... done
[16:17:46.586] run() for ‘SequentialFuture’ ... done
[16:17:46.586] Created future:
[16:17:46.586] SequentialFuture:
[16:17:46.586] Label: ‘future_by-1’
[16:17:46.586] Expression:
[16:17:46.586] {
[16:17:46.586]     do.call(function(...) {
[16:17:46.586]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.586]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.586]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.586]             on.exit(options(oopts), add = TRUE)
[16:17:46.586]         }
[16:17:46.586]         {
[16:17:46.586]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.586]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.586]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.586]             })
[16:17:46.586]         }
[16:17:46.586]     }, args = future.call.arguments)
[16:17:46.586] }
[16:17:46.586] Lazy evaluation: FALSE
[16:17:46.586] Asynchronous evaluation: FALSE
[16:17:46.586] Local evaluation: TRUE
[16:17:46.586] Environment: 0x55b56756a8f8
[16:17:46.586] Capture standard output: TRUE
[16:17:46.586] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:46.586] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[16:17:46.586] Packages: 1 packages (‘stats’)
[16:17:46.586] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:46.586] Resolved: TRUE
[16:17:46.586] Value: 25.57 KiB of class ‘list’
[16:17:46.586] Early signaling: FALSE
[16:17:46.586] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:46.586] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.588] Chunk #1 of 1 ... DONE
[16:17:46.588] Launching 1 futures (chunks) ... DONE
[16:17:46.588] Resolving 1 futures (chunks) ...
[16:17:46.588] resolve() on list ...
[16:17:46.588]  recursive: 0
[16:17:46.588]  length: 1
[16:17:46.589] 
[16:17:46.589] resolved() for ‘SequentialFuture’ ...
[16:17:46.589] - state: ‘finished’
[16:17:46.589] - run: TRUE
[16:17:46.589] - result: ‘FutureResult’
[16:17:46.589] resolved() for ‘SequentialFuture’ ... done
[16:17:46.589] Future #1
[16:17:46.589] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:46.589] - nx: 1
[16:17:46.589] - relay: TRUE
[16:17:46.589] - stdout: TRUE
[16:17:46.590] - signal: TRUE
[16:17:46.590] - resignal: FALSE
[16:17:46.590] - force: TRUE
[16:17:46.590] - relayed: [n=1] FALSE
[16:17:46.590] - queued futures: [n=1] FALSE
[16:17:46.590]  - until=1
[16:17:46.590]  - relaying element #1
[16:17:46.590] - relayed: [n=1] TRUE
[16:17:46.590] - queued futures: [n=1] TRUE
[16:17:46.590] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:46.591]  length: 0 (resolved future 1)
[16:17:46.591] Relaying remaining futures
[16:17:46.591] signalConditionsASAP(NULL, pos=0) ...
[16:17:46.591] - nx: 1
[16:17:46.591] - relay: TRUE
[16:17:46.591] - stdout: TRUE
[16:17:46.591] - signal: TRUE
[16:17:46.591] - resignal: FALSE
[16:17:46.591] - force: TRUE
[16:17:46.591] - relayed: [n=1] TRUE
[16:17:46.591] - queued futures: [n=1] TRUE
 - flush all
[16:17:46.591] - relayed: [n=1] TRUE
[16:17:46.592] - queued futures: [n=1] TRUE
[16:17:46.592] signalConditionsASAP(NULL, pos=0) ... done
[16:17:46.592] resolve() on list ... DONE
[16:17:46.592]  - Number of value chunks collected: 1
[16:17:46.592] Resolving 1 futures (chunks) ... DONE
[16:17:46.592] Reducing values from 1 chunks ...
[16:17:46.592]  - Number of values collected after concatenation: 3
[16:17:46.592]  - Number of values expected: 3
[16:17:46.592] Reducing values from 1 chunks ... DONE
[16:17:46.592] future_lapply() ... DONE
[16:17:46.593] future_by_internal() ... DONE
[16:17:46.593] future_by_internal() ...
[16:17:46.593] future_lapply() ...
[16:17:46.597] Number of chunks: 1
[16:17:46.597] getGlobalsAndPackagesXApply() ...
[16:17:46.597]  - future.globals: TRUE
[16:17:46.597] getGlobalsAndPackages() ...
[16:17:46.597] Searching for globals...
[16:17:46.598] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:46.598] Searching for globals ... DONE
[16:17:46.598] Resolving globals: FALSE
[16:17:46.599] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:46.599] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:46.599] - globals: [1] ‘FUN’
[16:17:46.599] 
[16:17:46.599] getGlobalsAndPackages() ... DONE
[16:17:46.599]  - globals found/used: [n=1] ‘FUN’
[16:17:46.599]  - needed namespaces: [n=0] 
[16:17:46.600] Finding globals ... DONE
[16:17:46.600]  - use_args: TRUE
[16:17:46.600]  - Getting '...' globals ...
[16:17:46.600] resolve() on list ...
[16:17:46.600]  recursive: 0
[16:17:46.600]  length: 1
[16:17:46.600]  elements: ‘...’
[16:17:46.600]  length: 0 (resolved future 1)
[16:17:46.601] resolve() on list ... DONE
[16:17:46.601]    - '...' content: [n=0] 
[16:17:46.601] List of 1
[16:17:46.601]  $ ...: list()
[16:17:46.601]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.601]  - attr(*, "where")=List of 1
[16:17:46.601]   ..$ ...:<environment: 0x55b567e59fa8> 
[16:17:46.601]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.601]  - attr(*, "resolved")= logi TRUE
[16:17:46.601]  - attr(*, "total_size")= num NA
[16:17:46.604]  - Getting '...' globals ... DONE
[16:17:46.604] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:46.605] List of 2
[16:17:46.605]  $ ...future.FUN:function (object, ...)  
[16:17:46.605]  $ ...          : list()
[16:17:46.605]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.605]  - attr(*, "where")=List of 2
[16:17:46.605]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:46.605]   ..$ ...          :<environment: 0x55b567e59fa8> 
[16:17:46.605]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.605]  - attr(*, "resolved")= logi FALSE
[16:17:46.605]  - attr(*, "total_size")= num 1240
[16:17:46.607] Packages to be attached in all futures: [n=0] 
[16:17:46.607] getGlobalsAndPackagesXApply() ... DONE
[16:17:46.607] Number of futures (= number of chunks): 1
[16:17:46.607] Launching 1 futures (chunks) ...
[16:17:46.608] Chunk #1 of 1 ...
[16:17:46.608]  - Finding globals in 'X' for chunk #1 ...
[16:17:46.608] getGlobalsAndPackages() ...
[16:17:46.608] Searching for globals...
[16:17:46.608] 
[16:17:46.608] Searching for globals ... DONE
[16:17:46.609] - globals: [0] <none>
[16:17:46.609] getGlobalsAndPackages() ... DONE
[16:17:46.609]    + additional globals found: [n=0] 
[16:17:46.609]    + additional namespaces needed: [n=0] 
[16:17:46.609]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:46.609]  - seeds: <none>
[16:17:46.609]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.609] getGlobalsAndPackages() ...
[16:17:46.609] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.609] Resolving globals: FALSE
[16:17:46.609] Tweak future expression to call with '...' arguments ...
[16:17:46.610] {
[16:17:46.610]     do.call(function(...) {
[16:17:46.610]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.610]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.610]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.610]             on.exit(options(oopts), add = TRUE)
[16:17:46.610]         }
[16:17:46.610]         {
[16:17:46.610]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.610]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.610]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.610]             })
[16:17:46.610]         }
[16:17:46.610]     }, args = future.call.arguments)
[16:17:46.610] }
[16:17:46.610] Tweak future expression to call with '...' arguments ... DONE
[16:17:46.610] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.610] 
[16:17:46.610] getGlobalsAndPackages() ... DONE
[16:17:46.611] run() for ‘Future’ ...
[16:17:46.611] - state: ‘created’
[16:17:46.611] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:46.614] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.614] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:46.614]   - Field: ‘label’
[16:17:46.615]   - Field: ‘local’
[16:17:46.615]   - Field: ‘owner’
[16:17:46.615]   - Field: ‘envir’
[16:17:46.615]   - Field: ‘packages’
[16:17:46.615]   - Field: ‘gc’
[16:17:46.615]   - Field: ‘conditions’
[16:17:46.615]   - Field: ‘expr’
[16:17:46.615]   - Field: ‘uuid’
[16:17:46.615]   - Field: ‘seed’
[16:17:46.615]   - Field: ‘version’
[16:17:46.615]   - Field: ‘result’
[16:17:46.616]   - Field: ‘asynchronous’
[16:17:46.616]   - Field: ‘calls’
[16:17:46.616]   - Field: ‘globals’
[16:17:46.616]   - Field: ‘stdout’
[16:17:46.616]   - Field: ‘earlySignal’
[16:17:46.616]   - Field: ‘lazy’
[16:17:46.616]   - Field: ‘state’
[16:17:46.616] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:46.616] - Launch lazy future ...
[16:17:46.616] Packages needed by the future expression (n = 0): <none>
[16:17:46.617] Packages needed by future strategies (n = 0): <none>
[16:17:46.617] {
[16:17:46.617]     {
[16:17:46.617]         {
[16:17:46.617]             ...future.startTime <- base::Sys.time()
[16:17:46.617]             {
[16:17:46.617]                 {
[16:17:46.617]                   {
[16:17:46.617]                     base::local({
[16:17:46.617]                       has_future <- base::requireNamespace("future", 
[16:17:46.617]                         quietly = TRUE)
[16:17:46.617]                       if (has_future) {
[16:17:46.617]                         ns <- base::getNamespace("future")
[16:17:46.617]                         version <- ns[[".package"]][["version"]]
[16:17:46.617]                         if (is.null(version)) 
[16:17:46.617]                           version <- utils::packageVersion("future")
[16:17:46.617]                       }
[16:17:46.617]                       else {
[16:17:46.617]                         version <- NULL
[16:17:46.617]                       }
[16:17:46.617]                       if (!has_future || version < "1.8.0") {
[16:17:46.617]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:46.617]                           "", base::R.version$version.string), 
[16:17:46.617]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:46.617]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:46.617]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:46.617]                             "release", "version")], collapse = " "), 
[16:17:46.617]                           hostname = base::Sys.info()[["nodename"]])
[16:17:46.617]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:46.617]                           info)
[16:17:46.617]                         info <- base::paste(info, collapse = "; ")
[16:17:46.617]                         if (!has_future) {
[16:17:46.617]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:46.617]                             info)
[16:17:46.617]                         }
[16:17:46.617]                         else {
[16:17:46.617]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:46.617]                             info, version)
[16:17:46.617]                         }
[16:17:46.617]                         base::stop(msg)
[16:17:46.617]                       }
[16:17:46.617]                     })
[16:17:46.617]                   }
[16:17:46.617]                   ...future.strategy.old <- future::plan("list")
[16:17:46.617]                   options(future.plan = NULL)
[16:17:46.617]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.617]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:46.617]                 }
[16:17:46.617]                 ...future.workdir <- getwd()
[16:17:46.617]             }
[16:17:46.617]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:46.617]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:46.617]         }
[16:17:46.617]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:46.617]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:46.617]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:46.617]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:46.617]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:46.617]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:46.617]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:46.617]             base::names(...future.oldOptions))
[16:17:46.617]     }
[16:17:46.617]     if (FALSE) {
[16:17:46.617]     }
[16:17:46.617]     else {
[16:17:46.617]         if (TRUE) {
[16:17:46.617]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:46.617]                 open = "w")
[16:17:46.617]         }
[16:17:46.617]         else {
[16:17:46.617]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:46.617]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:46.617]         }
[16:17:46.617]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:46.617]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:46.617]             base::sink(type = "output", split = FALSE)
[16:17:46.617]             base::close(...future.stdout)
[16:17:46.617]         }, add = TRUE)
[16:17:46.617]     }
[16:17:46.617]     ...future.frame <- base::sys.nframe()
[16:17:46.617]     ...future.conditions <- base::list()
[16:17:46.617]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:46.617]     if (FALSE) {
[16:17:46.617]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:46.617]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:46.617]     }
[16:17:46.617]     ...future.result <- base::tryCatch({
[16:17:46.617]         base::withCallingHandlers({
[16:17:46.617]             ...future.value <- base::withVisible(base::local({
[16:17:46.617]                 do.call(function(...) {
[16:17:46.617]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.617]                   if (!identical(...future.globals.maxSize.org, 
[16:17:46.617]                     ...future.globals.maxSize)) {
[16:17:46.617]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.617]                     on.exit(options(oopts), add = TRUE)
[16:17:46.617]                   }
[16:17:46.617]                   {
[16:17:46.617]                     lapply(seq_along(...future.elements_ii), 
[16:17:46.617]                       FUN = function(jj) {
[16:17:46.617]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.617]                         ...future.FUN(...future.X_jj, ...)
[16:17:46.617]                       })
[16:17:46.617]                   }
[16:17:46.617]                 }, args = future.call.arguments)
[16:17:46.617]             }))
[16:17:46.617]             future::FutureResult(value = ...future.value$value, 
[16:17:46.617]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.617]                   ...future.rng), globalenv = if (FALSE) 
[16:17:46.617]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:46.617]                     ...future.globalenv.names))
[16:17:46.617]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:46.617]         }, condition = base::local({
[16:17:46.617]             c <- base::c
[16:17:46.617]             inherits <- base::inherits
[16:17:46.617]             invokeRestart <- base::invokeRestart
[16:17:46.617]             length <- base::length
[16:17:46.617]             list <- base::list
[16:17:46.617]             seq.int <- base::seq.int
[16:17:46.617]             signalCondition <- base::signalCondition
[16:17:46.617]             sys.calls <- base::sys.calls
[16:17:46.617]             `[[` <- base::`[[`
[16:17:46.617]             `+` <- base::`+`
[16:17:46.617]             `<<-` <- base::`<<-`
[16:17:46.617]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:46.617]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:46.617]                   3L)]
[16:17:46.617]             }
[16:17:46.617]             function(cond) {
[16:17:46.617]                 is_error <- inherits(cond, "error")
[16:17:46.617]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:46.617]                   NULL)
[16:17:46.617]                 if (is_error) {
[16:17:46.617]                   sessionInformation <- function() {
[16:17:46.617]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:46.617]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:46.617]                       search = base::search(), system = base::Sys.info())
[16:17:46.617]                   }
[16:17:46.617]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.617]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:46.617]                     cond$call), session = sessionInformation(), 
[16:17:46.617]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:46.617]                   signalCondition(cond)
[16:17:46.617]                 }
[16:17:46.617]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:46.617]                 "immediateCondition"))) {
[16:17:46.617]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:46.617]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.617]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:46.617]                   if (TRUE && !signal) {
[16:17:46.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.617]                     {
[16:17:46.617]                       inherits <- base::inherits
[16:17:46.617]                       invokeRestart <- base::invokeRestart
[16:17:46.617]                       is.null <- base::is.null
[16:17:46.617]                       muffled <- FALSE
[16:17:46.617]                       if (inherits(cond, "message")) {
[16:17:46.617]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.617]                         if (muffled) 
[16:17:46.617]                           invokeRestart("muffleMessage")
[16:17:46.617]                       }
[16:17:46.617]                       else if (inherits(cond, "warning")) {
[16:17:46.617]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.617]                         if (muffled) 
[16:17:46.617]                           invokeRestart("muffleWarning")
[16:17:46.617]                       }
[16:17:46.617]                       else if (inherits(cond, "condition")) {
[16:17:46.617]                         if (!is.null(pattern)) {
[16:17:46.617]                           computeRestarts <- base::computeRestarts
[16:17:46.617]                           grepl <- base::grepl
[16:17:46.617]                           restarts <- computeRestarts(cond)
[16:17:46.617]                           for (restart in restarts) {
[16:17:46.617]                             name <- restart$name
[16:17:46.617]                             if (is.null(name)) 
[16:17:46.617]                               next
[16:17:46.617]                             if (!grepl(pattern, name)) 
[16:17:46.617]                               next
[16:17:46.617]                             invokeRestart(restart)
[16:17:46.617]                             muffled <- TRUE
[16:17:46.617]                             break
[16:17:46.617]                           }
[16:17:46.617]                         }
[16:17:46.617]                       }
[16:17:46.617]                       invisible(muffled)
[16:17:46.617]                     }
[16:17:46.617]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.617]                   }
[16:17:46.617]                 }
[16:17:46.617]                 else {
[16:17:46.617]                   if (TRUE) {
[16:17:46.617]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.617]                     {
[16:17:46.617]                       inherits <- base::inherits
[16:17:46.617]                       invokeRestart <- base::invokeRestart
[16:17:46.617]                       is.null <- base::is.null
[16:17:46.617]                       muffled <- FALSE
[16:17:46.617]                       if (inherits(cond, "message")) {
[16:17:46.617]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.617]                         if (muffled) 
[16:17:46.617]                           invokeRestart("muffleMessage")
[16:17:46.617]                       }
[16:17:46.617]                       else if (inherits(cond, "warning")) {
[16:17:46.617]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.617]                         if (muffled) 
[16:17:46.617]                           invokeRestart("muffleWarning")
[16:17:46.617]                       }
[16:17:46.617]                       else if (inherits(cond, "condition")) {
[16:17:46.617]                         if (!is.null(pattern)) {
[16:17:46.617]                           computeRestarts <- base::computeRestarts
[16:17:46.617]                           grepl <- base::grepl
[16:17:46.617]                           restarts <- computeRestarts(cond)
[16:17:46.617]                           for (restart in restarts) {
[16:17:46.617]                             name <- restart$name
[16:17:46.617]                             if (is.null(name)) 
[16:17:46.617]                               next
[16:17:46.617]                             if (!grepl(pattern, name)) 
[16:17:46.617]                               next
[16:17:46.617]                             invokeRestart(restart)
[16:17:46.617]                             muffled <- TRUE
[16:17:46.617]                             break
[16:17:46.617]                           }
[16:17:46.617]                         }
[16:17:46.617]                       }
[16:17:46.617]                       invisible(muffled)
[16:17:46.617]                     }
[16:17:46.617]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.617]                   }
[16:17:46.617]                 }
[16:17:46.617]             }
[16:17:46.617]         }))
[16:17:46.617]     }, error = function(ex) {
[16:17:46.617]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:46.617]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.617]                 ...future.rng), started = ...future.startTime, 
[16:17:46.617]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:46.617]             version = "1.8"), class = "FutureResult")
[16:17:46.617]     }, finally = {
[16:17:46.617]         if (!identical(...future.workdir, getwd())) 
[16:17:46.617]             setwd(...future.workdir)
[16:17:46.617]         {
[16:17:46.617]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:46.617]                 ...future.oldOptions$nwarnings <- NULL
[16:17:46.617]             }
[16:17:46.617]             base::options(...future.oldOptions)
[16:17:46.617]             if (.Platform$OS.type == "windows") {
[16:17:46.617]                 old_names <- names(...future.oldEnvVars)
[16:17:46.617]                 envs <- base::Sys.getenv()
[16:17:46.617]                 names <- names(envs)
[16:17:46.617]                 common <- intersect(names, old_names)
[16:17:46.617]                 added <- setdiff(names, old_names)
[16:17:46.617]                 removed <- setdiff(old_names, names)
[16:17:46.617]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:46.617]                   envs[common]]
[16:17:46.617]                 NAMES <- toupper(changed)
[16:17:46.617]                 args <- list()
[16:17:46.617]                 for (kk in seq_along(NAMES)) {
[16:17:46.617]                   name <- changed[[kk]]
[16:17:46.617]                   NAME <- NAMES[[kk]]
[16:17:46.617]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.617]                     next
[16:17:46.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.617]                 }
[16:17:46.617]                 NAMES <- toupper(added)
[16:17:46.617]                 for (kk in seq_along(NAMES)) {
[16:17:46.617]                   name <- added[[kk]]
[16:17:46.617]                   NAME <- NAMES[[kk]]
[16:17:46.617]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.617]                     next
[16:17:46.617]                   args[[name]] <- ""
[16:17:46.617]                 }
[16:17:46.617]                 NAMES <- toupper(removed)
[16:17:46.617]                 for (kk in seq_along(NAMES)) {
[16:17:46.617]                   name <- removed[[kk]]
[16:17:46.617]                   NAME <- NAMES[[kk]]
[16:17:46.617]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.617]                     next
[16:17:46.617]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.617]                 }
[16:17:46.617]                 if (length(args) > 0) 
[16:17:46.617]                   base::do.call(base::Sys.setenv, args = args)
[16:17:46.617]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:46.617]             }
[16:17:46.617]             else {
[16:17:46.617]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:46.617]             }
[16:17:46.617]             {
[16:17:46.617]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:46.617]                   0L) {
[16:17:46.617]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:46.617]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:46.617]                   base::options(opts)
[16:17:46.617]                 }
[16:17:46.617]                 {
[16:17:46.617]                   {
[16:17:46.617]                     NULL
[16:17:46.617]                     RNGkind("Mersenne-Twister")
[16:17:46.617]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:46.617]                       inherits = FALSE)
[16:17:46.617]                   }
[16:17:46.617]                   options(future.plan = NULL)
[16:17:46.617]                   if (is.na(NA_character_)) 
[16:17:46.617]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.617]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:46.617]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:46.617]                     .init = FALSE)
[16:17:46.617]                 }
[16:17:46.617]             }
[16:17:46.617]         }
[16:17:46.617]     })
[16:17:46.617]     if (TRUE) {
[16:17:46.617]         base::sink(type = "output", split = FALSE)
[16:17:46.617]         if (TRUE) {
[16:17:46.617]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:46.617]         }
[16:17:46.617]         else {
[16:17:46.617]             ...future.result["stdout"] <- base::list(NULL)
[16:17:46.617]         }
[16:17:46.617]         base::close(...future.stdout)
[16:17:46.617]         ...future.stdout <- NULL
[16:17:46.617]     }
[16:17:46.617]     ...future.result$conditions <- ...future.conditions
[16:17:46.617]     ...future.result$finished <- base::Sys.time()
[16:17:46.617]     ...future.result
[16:17:46.617] }
[16:17:46.619] assign_globals() ...
[16:17:46.619] List of 5
[16:17:46.619]  $ ...future.FUN            :function (object, ...)  
[16:17:46.619]  $ future.call.arguments    : list()
[16:17:46.619]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.619]  $ ...future.elements_ii    :List of 3
[16:17:46.619]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.619]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:17:46.619]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.619]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:46.619]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.619]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:17:46.619]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.619]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:17:46.619]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.619]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:17:46.619]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.619]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:17:46.619]  $ ...future.seeds_ii       : NULL
[16:17:46.619]  $ ...future.globals.maxSize: NULL
[16:17:46.619]  - attr(*, "where")=List of 5
[16:17:46.619]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:46.619]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:46.619]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:46.619]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:46.619]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:46.619]  - attr(*, "resolved")= logi FALSE
[16:17:46.619]  - attr(*, "total_size")= num 1240
[16:17:46.619]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.619]  - attr(*, "already-done")= logi TRUE
[16:17:46.628] - copied ‘...future.FUN’ to environment
[16:17:46.628] - copied ‘future.call.arguments’ to environment
[16:17:46.628] - copied ‘...future.elements_ii’ to environment
[16:17:46.628] - copied ‘...future.seeds_ii’ to environment
[16:17:46.628] - copied ‘...future.globals.maxSize’ to environment
[16:17:46.628] assign_globals() ... done
[16:17:46.629] plan(): Setting new future strategy stack:
[16:17:46.629] List of future strategies:
[16:17:46.629] 1. sequential:
[16:17:46.629]    - args: function (..., envir = parent.frame())
[16:17:46.629]    - tweaked: FALSE
[16:17:46.629]    - call: NULL
[16:17:46.629] plan(): nbrOfWorkers() = 1
[16:17:46.631] plan(): Setting new future strategy stack:
[16:17:46.631] List of future strategies:
[16:17:46.631] 1. multicore:
[16:17:46.631]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:46.631]    - tweaked: FALSE
[16:17:46.631]    - call: plan(strategy)
[16:17:46.635] plan(): nbrOfWorkers() = 1
[16:17:46.635] SequentialFuture started (and completed)
[16:17:46.635] - Launch lazy future ... done
[16:17:46.635] run() for ‘SequentialFuture’ ... done
[16:17:46.635] Created future:
[16:17:46.635] SequentialFuture:
[16:17:46.635] Label: ‘future_by-1’
[16:17:46.635] Expression:
[16:17:46.635] {
[16:17:46.635]     do.call(function(...) {
[16:17:46.635]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.635]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.635]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.635]             on.exit(options(oopts), add = TRUE)
[16:17:46.635]         }
[16:17:46.635]         {
[16:17:46.635]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.635]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.635]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.635]             })
[16:17:46.635]         }
[16:17:46.635]     }, args = future.call.arguments)
[16:17:46.635] }
[16:17:46.635] Lazy evaluation: FALSE
[16:17:46.635] Asynchronous evaluation: FALSE
[16:17:46.635] Local evaluation: TRUE
[16:17:46.635] Environment: 0x55b567e26a98
[16:17:46.635] Capture standard output: TRUE
[16:17:46.635] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:46.635] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:46.635] Packages: <none>
[16:17:46.635] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:46.635] Resolved: TRUE
[16:17:46.635] Value: 5.37 KiB of class ‘list’
[16:17:46.635] Early signaling: FALSE
[16:17:46.635] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:46.635] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.636] Chunk #1 of 1 ... DONE
[16:17:46.637] Launching 1 futures (chunks) ... DONE
[16:17:46.637] Resolving 1 futures (chunks) ...
[16:17:46.637] resolve() on list ...
[16:17:46.637]  recursive: 0
[16:17:46.637]  length: 1
[16:17:46.637] 
[16:17:46.637] resolved() for ‘SequentialFuture’ ...
[16:17:46.637] - state: ‘finished’
[16:17:46.637] - run: TRUE
[16:17:46.637] - result: ‘FutureResult’
[16:17:46.638] resolved() for ‘SequentialFuture’ ... done
[16:17:46.638] Future #1
[16:17:46.638] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:46.638] - nx: 1
[16:17:46.638] - relay: TRUE
[16:17:46.638] - stdout: TRUE
[16:17:46.638] - signal: TRUE
[16:17:46.638] - resignal: FALSE
[16:17:46.638] - force: TRUE
[16:17:46.638] - relayed: [n=1] FALSE
[16:17:46.638] - queued futures: [n=1] FALSE
[16:17:46.638]  - until=1
[16:17:46.639]  - relaying element #1
[16:17:46.639] - relayed: [n=1] TRUE
[16:17:46.639] - queued futures: [n=1] TRUE
[16:17:46.639] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:46.639]  length: 0 (resolved future 1)
[16:17:46.639] Relaying remaining futures
[16:17:46.639] signalConditionsASAP(NULL, pos=0) ...
[16:17:46.639] - nx: 1
[16:17:46.639] - relay: TRUE
[16:17:46.639] - stdout: TRUE
[16:17:46.640] - signal: TRUE
[16:17:46.640] - resignal: FALSE
[16:17:46.640] - force: TRUE
[16:17:46.640] - relayed: [n=1] TRUE
[16:17:46.640] - queued futures: [n=1] TRUE
 - flush all
[16:17:46.640] - relayed: [n=1] TRUE
[16:17:46.640] - queued futures: [n=1] TRUE
[16:17:46.640] signalConditionsASAP(NULL, pos=0) ... done
[16:17:46.640] resolve() on list ... DONE
[16:17:46.640]  - Number of value chunks collected: 1
[16:17:46.640] Resolving 1 futures (chunks) ... DONE
[16:17:46.641] Reducing values from 1 chunks ...
[16:17:46.641]  - Number of values collected after concatenation: 3
[16:17:46.641]  - Number of values expected: 3
[16:17:46.641] Reducing values from 1 chunks ... DONE
[16:17:46.641] future_lapply() ... DONE
[16:17:46.641] future_by_internal() ... DONE
[16:17:46.642] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[16:17:46.642] future_lapply() ...
[16:17:46.646] Number of chunks: 1
[16:17:46.646] getGlobalsAndPackagesXApply() ...
[16:17:46.646]  - future.globals: TRUE
[16:17:46.646] getGlobalsAndPackages() ...
[16:17:46.646] Searching for globals...
[16:17:46.647] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:46.647] Searching for globals ... DONE
[16:17:46.647] Resolving globals: FALSE
[16:17:46.648] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:46.648] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:46.648] - globals: [1] ‘FUN’
[16:17:46.648] 
[16:17:46.648] getGlobalsAndPackages() ... DONE
[16:17:46.648]  - globals found/used: [n=1] ‘FUN’
[16:17:46.649]  - needed namespaces: [n=0] 
[16:17:46.649] Finding globals ... DONE
[16:17:46.649]  - use_args: TRUE
[16:17:46.649]  - Getting '...' globals ...
[16:17:46.649] resolve() on list ...
[16:17:46.649]  recursive: 0
[16:17:46.649]  length: 1
[16:17:46.651]  elements: ‘...’
[16:17:46.651]  length: 0 (resolved future 1)
[16:17:46.651] resolve() on list ... DONE
[16:17:46.651]    - '...' content: [n=0] 
[16:17:46.651] List of 1
[16:17:46.651]  $ ...: list()
[16:17:46.651]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.651]  - attr(*, "where")=List of 1
[16:17:46.651]   ..$ ...:<environment: 0x55b567eb9b00> 
[16:17:46.651]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.651]  - attr(*, "resolved")= logi TRUE
[16:17:46.651]  - attr(*, "total_size")= num NA
[16:17:46.654]  - Getting '...' globals ... DONE
[16:17:46.654] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:46.654] List of 2
[16:17:46.654]  $ ...future.FUN:function (object, ...)  
[16:17:46.654]  $ ...          : list()
[16:17:46.654]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.654]  - attr(*, "where")=List of 2
[16:17:46.654]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:46.654]   ..$ ...          :<environment: 0x55b567eb9b00> 
[16:17:46.654]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.654]  - attr(*, "resolved")= logi FALSE
[16:17:46.654]  - attr(*, "total_size")= num 1240
[16:17:46.657] Packages to be attached in all futures: [n=0] 
[16:17:46.657] getGlobalsAndPackagesXApply() ... DONE
[16:17:46.657] Number of futures (= number of chunks): 1
[16:17:46.657] Launching 1 futures (chunks) ...
[16:17:46.658] Chunk #1 of 1 ...
[16:17:46.658]  - Finding globals in 'X' for chunk #1 ...
[16:17:46.658] getGlobalsAndPackages() ...
[16:17:46.658] Searching for globals...
[16:17:46.658] 
[16:17:46.658] Searching for globals ... DONE
[16:17:46.659] - globals: [0] <none>
[16:17:46.659] getGlobalsAndPackages() ... DONE
[16:17:46.659]    + additional globals found: [n=0] 
[16:17:46.659]    + additional namespaces needed: [n=0] 
[16:17:46.659]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:46.659]  - seeds: <none>
[16:17:46.659]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.659] getGlobalsAndPackages() ...
[16:17:46.659] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.659] Resolving globals: FALSE
[16:17:46.659] Tweak future expression to call with '...' arguments ...
[16:17:46.660] {
[16:17:46.660]     do.call(function(...) {
[16:17:46.660]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.660]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.660]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.660]             on.exit(options(oopts), add = TRUE)
[16:17:46.660]         }
[16:17:46.660]         {
[16:17:46.660]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.660]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.660]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.660]             })
[16:17:46.660]         }
[16:17:46.660]     }, args = future.call.arguments)
[16:17:46.660] }
[16:17:46.660] Tweak future expression to call with '...' arguments ... DONE
[16:17:46.660] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.660] 
[16:17:46.660] getGlobalsAndPackages() ... DONE
[16:17:46.661] run() for ‘Future’ ...
[16:17:46.661] - state: ‘created’
[16:17:46.661] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:46.665] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.665] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:46.665]   - Field: ‘label’
[16:17:46.665]   - Field: ‘local’
[16:17:46.665]   - Field: ‘owner’
[16:17:46.665]   - Field: ‘envir’
[16:17:46.665]   - Field: ‘packages’
[16:17:46.665]   - Field: ‘gc’
[16:17:46.665]   - Field: ‘conditions’
[16:17:46.666]   - Field: ‘expr’
[16:17:46.666]   - Field: ‘uuid’
[16:17:46.666]   - Field: ‘seed’
[16:17:46.666]   - Field: ‘version’
[16:17:46.666]   - Field: ‘result’
[16:17:46.666]   - Field: ‘asynchronous’
[16:17:46.666]   - Field: ‘calls’
[16:17:46.666]   - Field: ‘globals’
[16:17:46.666]   - Field: ‘stdout’
[16:17:46.666]   - Field: ‘earlySignal’
[16:17:46.666]   - Field: ‘lazy’
[16:17:46.667]   - Field: ‘state’
[16:17:46.667] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:46.667] - Launch lazy future ...
[16:17:46.667] Packages needed by the future expression (n = 0): <none>
[16:17:46.667] Packages needed by future strategies (n = 0): <none>
[16:17:46.667] {
[16:17:46.667]     {
[16:17:46.667]         {
[16:17:46.667]             ...future.startTime <- base::Sys.time()
[16:17:46.667]             {
[16:17:46.667]                 {
[16:17:46.667]                   {
[16:17:46.667]                     base::local({
[16:17:46.667]                       has_future <- base::requireNamespace("future", 
[16:17:46.667]                         quietly = TRUE)
[16:17:46.667]                       if (has_future) {
[16:17:46.667]                         ns <- base::getNamespace("future")
[16:17:46.667]                         version <- ns[[".package"]][["version"]]
[16:17:46.667]                         if (is.null(version)) 
[16:17:46.667]                           version <- utils::packageVersion("future")
[16:17:46.667]                       }
[16:17:46.667]                       else {
[16:17:46.667]                         version <- NULL
[16:17:46.667]                       }
[16:17:46.667]                       if (!has_future || version < "1.8.0") {
[16:17:46.667]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:46.667]                           "", base::R.version$version.string), 
[16:17:46.667]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:46.667]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:46.667]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:46.667]                             "release", "version")], collapse = " "), 
[16:17:46.667]                           hostname = base::Sys.info()[["nodename"]])
[16:17:46.667]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:46.667]                           info)
[16:17:46.667]                         info <- base::paste(info, collapse = "; ")
[16:17:46.667]                         if (!has_future) {
[16:17:46.667]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:46.667]                             info)
[16:17:46.667]                         }
[16:17:46.667]                         else {
[16:17:46.667]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:46.667]                             info, version)
[16:17:46.667]                         }
[16:17:46.667]                         base::stop(msg)
[16:17:46.667]                       }
[16:17:46.667]                     })
[16:17:46.667]                   }
[16:17:46.667]                   ...future.strategy.old <- future::plan("list")
[16:17:46.667]                   options(future.plan = NULL)
[16:17:46.667]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.667]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:46.667]                 }
[16:17:46.667]                 ...future.workdir <- getwd()
[16:17:46.667]             }
[16:17:46.667]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:46.667]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:46.667]         }
[16:17:46.667]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:46.667]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:46.667]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:46.667]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:46.667]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:46.667]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:46.667]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:46.667]             base::names(...future.oldOptions))
[16:17:46.667]     }
[16:17:46.667]     if (FALSE) {
[16:17:46.667]     }
[16:17:46.667]     else {
[16:17:46.667]         if (TRUE) {
[16:17:46.667]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:46.667]                 open = "w")
[16:17:46.667]         }
[16:17:46.667]         else {
[16:17:46.667]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:46.667]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:46.667]         }
[16:17:46.667]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:46.667]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:46.667]             base::sink(type = "output", split = FALSE)
[16:17:46.667]             base::close(...future.stdout)
[16:17:46.667]         }, add = TRUE)
[16:17:46.667]     }
[16:17:46.667]     ...future.frame <- base::sys.nframe()
[16:17:46.667]     ...future.conditions <- base::list()
[16:17:46.667]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:46.667]     if (FALSE) {
[16:17:46.667]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:46.667]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:46.667]     }
[16:17:46.667]     ...future.result <- base::tryCatch({
[16:17:46.667]         base::withCallingHandlers({
[16:17:46.667]             ...future.value <- base::withVisible(base::local({
[16:17:46.667]                 do.call(function(...) {
[16:17:46.667]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.667]                   if (!identical(...future.globals.maxSize.org, 
[16:17:46.667]                     ...future.globals.maxSize)) {
[16:17:46.667]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.667]                     on.exit(options(oopts), add = TRUE)
[16:17:46.667]                   }
[16:17:46.667]                   {
[16:17:46.667]                     lapply(seq_along(...future.elements_ii), 
[16:17:46.667]                       FUN = function(jj) {
[16:17:46.667]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.667]                         ...future.FUN(...future.X_jj, ...)
[16:17:46.667]                       })
[16:17:46.667]                   }
[16:17:46.667]                 }, args = future.call.arguments)
[16:17:46.667]             }))
[16:17:46.667]             future::FutureResult(value = ...future.value$value, 
[16:17:46.667]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.667]                   ...future.rng), globalenv = if (FALSE) 
[16:17:46.667]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:46.667]                     ...future.globalenv.names))
[16:17:46.667]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:46.667]         }, condition = base::local({
[16:17:46.667]             c <- base::c
[16:17:46.667]             inherits <- base::inherits
[16:17:46.667]             invokeRestart <- base::invokeRestart
[16:17:46.667]             length <- base::length
[16:17:46.667]             list <- base::list
[16:17:46.667]             seq.int <- base::seq.int
[16:17:46.667]             signalCondition <- base::signalCondition
[16:17:46.667]             sys.calls <- base::sys.calls
[16:17:46.667]             `[[` <- base::`[[`
[16:17:46.667]             `+` <- base::`+`
[16:17:46.667]             `<<-` <- base::`<<-`
[16:17:46.667]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:46.667]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:46.667]                   3L)]
[16:17:46.667]             }
[16:17:46.667]             function(cond) {
[16:17:46.667]                 is_error <- inherits(cond, "error")
[16:17:46.667]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:46.667]                   NULL)
[16:17:46.667]                 if (is_error) {
[16:17:46.667]                   sessionInformation <- function() {
[16:17:46.667]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:46.667]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:46.667]                       search = base::search(), system = base::Sys.info())
[16:17:46.667]                   }
[16:17:46.667]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.667]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:46.667]                     cond$call), session = sessionInformation(), 
[16:17:46.667]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:46.667]                   signalCondition(cond)
[16:17:46.667]                 }
[16:17:46.667]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:46.667]                 "immediateCondition"))) {
[16:17:46.667]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:46.667]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.667]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:46.667]                   if (TRUE && !signal) {
[16:17:46.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.667]                     {
[16:17:46.667]                       inherits <- base::inherits
[16:17:46.667]                       invokeRestart <- base::invokeRestart
[16:17:46.667]                       is.null <- base::is.null
[16:17:46.667]                       muffled <- FALSE
[16:17:46.667]                       if (inherits(cond, "message")) {
[16:17:46.667]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.667]                         if (muffled) 
[16:17:46.667]                           invokeRestart("muffleMessage")
[16:17:46.667]                       }
[16:17:46.667]                       else if (inherits(cond, "warning")) {
[16:17:46.667]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.667]                         if (muffled) 
[16:17:46.667]                           invokeRestart("muffleWarning")
[16:17:46.667]                       }
[16:17:46.667]                       else if (inherits(cond, "condition")) {
[16:17:46.667]                         if (!is.null(pattern)) {
[16:17:46.667]                           computeRestarts <- base::computeRestarts
[16:17:46.667]                           grepl <- base::grepl
[16:17:46.667]                           restarts <- computeRestarts(cond)
[16:17:46.667]                           for (restart in restarts) {
[16:17:46.667]                             name <- restart$name
[16:17:46.667]                             if (is.null(name)) 
[16:17:46.667]                               next
[16:17:46.667]                             if (!grepl(pattern, name)) 
[16:17:46.667]                               next
[16:17:46.667]                             invokeRestart(restart)
[16:17:46.667]                             muffled <- TRUE
[16:17:46.667]                             break
[16:17:46.667]                           }
[16:17:46.667]                         }
[16:17:46.667]                       }
[16:17:46.667]                       invisible(muffled)
[16:17:46.667]                     }
[16:17:46.667]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.667]                   }
[16:17:46.667]                 }
[16:17:46.667]                 else {
[16:17:46.667]                   if (TRUE) {
[16:17:46.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.667]                     {
[16:17:46.667]                       inherits <- base::inherits
[16:17:46.667]                       invokeRestart <- base::invokeRestart
[16:17:46.667]                       is.null <- base::is.null
[16:17:46.667]                       muffled <- FALSE
[16:17:46.667]                       if (inherits(cond, "message")) {
[16:17:46.667]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.667]                         if (muffled) 
[16:17:46.667]                           invokeRestart("muffleMessage")
[16:17:46.667]                       }
[16:17:46.667]                       else if (inherits(cond, "warning")) {
[16:17:46.667]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.667]                         if (muffled) 
[16:17:46.667]                           invokeRestart("muffleWarning")
[16:17:46.667]                       }
[16:17:46.667]                       else if (inherits(cond, "condition")) {
[16:17:46.667]                         if (!is.null(pattern)) {
[16:17:46.667]                           computeRestarts <- base::computeRestarts
[16:17:46.667]                           grepl <- base::grepl
[16:17:46.667]                           restarts <- computeRestarts(cond)
[16:17:46.667]                           for (restart in restarts) {
[16:17:46.667]                             name <- restart$name
[16:17:46.667]                             if (is.null(name)) 
[16:17:46.667]                               next
[16:17:46.667]                             if (!grepl(pattern, name)) 
[16:17:46.667]                               next
[16:17:46.667]                             invokeRestart(restart)
[16:17:46.667]                             muffled <- TRUE
[16:17:46.667]                             break
[16:17:46.667]                           }
[16:17:46.667]                         }
[16:17:46.667]                       }
[16:17:46.667]                       invisible(muffled)
[16:17:46.667]                     }
[16:17:46.667]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.667]                   }
[16:17:46.667]                 }
[16:17:46.667]             }
[16:17:46.667]         }))
[16:17:46.667]     }, error = function(ex) {
[16:17:46.667]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:46.667]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.667]                 ...future.rng), started = ...future.startTime, 
[16:17:46.667]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:46.667]             version = "1.8"), class = "FutureResult")
[16:17:46.667]     }, finally = {
[16:17:46.667]         if (!identical(...future.workdir, getwd())) 
[16:17:46.667]             setwd(...future.workdir)
[16:17:46.667]         {
[16:17:46.667]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:46.667]                 ...future.oldOptions$nwarnings <- NULL
[16:17:46.667]             }
[16:17:46.667]             base::options(...future.oldOptions)
[16:17:46.667]             if (.Platform$OS.type == "windows") {
[16:17:46.667]                 old_names <- names(...future.oldEnvVars)
[16:17:46.667]                 envs <- base::Sys.getenv()
[16:17:46.667]                 names <- names(envs)
[16:17:46.667]                 common <- intersect(names, old_names)
[16:17:46.667]                 added <- setdiff(names, old_names)
[16:17:46.667]                 removed <- setdiff(old_names, names)
[16:17:46.667]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:46.667]                   envs[common]]
[16:17:46.667]                 NAMES <- toupper(changed)
[16:17:46.667]                 args <- list()
[16:17:46.667]                 for (kk in seq_along(NAMES)) {
[16:17:46.667]                   name <- changed[[kk]]
[16:17:46.667]                   NAME <- NAMES[[kk]]
[16:17:46.667]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.667]                     next
[16:17:46.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.667]                 }
[16:17:46.667]                 NAMES <- toupper(added)
[16:17:46.667]                 for (kk in seq_along(NAMES)) {
[16:17:46.667]                   name <- added[[kk]]
[16:17:46.667]                   NAME <- NAMES[[kk]]
[16:17:46.667]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.667]                     next
[16:17:46.667]                   args[[name]] <- ""
[16:17:46.667]                 }
[16:17:46.667]                 NAMES <- toupper(removed)
[16:17:46.667]                 for (kk in seq_along(NAMES)) {
[16:17:46.667]                   name <- removed[[kk]]
[16:17:46.667]                   NAME <- NAMES[[kk]]
[16:17:46.667]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.667]                     next
[16:17:46.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.667]                 }
[16:17:46.667]                 if (length(args) > 0) 
[16:17:46.667]                   base::do.call(base::Sys.setenv, args = args)
[16:17:46.667]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:46.667]             }
[16:17:46.667]             else {
[16:17:46.667]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:46.667]             }
[16:17:46.667]             {
[16:17:46.667]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:46.667]                   0L) {
[16:17:46.667]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:46.667]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:46.667]                   base::options(opts)
[16:17:46.667]                 }
[16:17:46.667]                 {
[16:17:46.667]                   {
[16:17:46.667]                     NULL
[16:17:46.667]                     RNGkind("Mersenne-Twister")
[16:17:46.667]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:46.667]                       inherits = FALSE)
[16:17:46.667]                   }
[16:17:46.667]                   options(future.plan = NULL)
[16:17:46.667]                   if (is.na(NA_character_)) 
[16:17:46.667]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.667]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:46.667]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:46.667]                     .init = FALSE)
[16:17:46.667]                 }
[16:17:46.667]             }
[16:17:46.667]         }
[16:17:46.667]     })
[16:17:46.667]     if (TRUE) {
[16:17:46.667]         base::sink(type = "output", split = FALSE)
[16:17:46.667]         if (TRUE) {
[16:17:46.667]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:46.667]         }
[16:17:46.667]         else {
[16:17:46.667]             ...future.result["stdout"] <- base::list(NULL)
[16:17:46.667]         }
[16:17:46.667]         base::close(...future.stdout)
[16:17:46.667]         ...future.stdout <- NULL
[16:17:46.667]     }
[16:17:46.667]     ...future.result$conditions <- ...future.conditions
[16:17:46.667]     ...future.result$finished <- base::Sys.time()
[16:17:46.667]     ...future.result
[16:17:46.667] }
[16:17:46.669] assign_globals() ...
[16:17:46.669] List of 5
[16:17:46.669]  $ ...future.FUN            :function (object, ...)  
[16:17:46.669]  $ future.call.arguments    : list()
[16:17:46.669]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.669]  $ ...future.elements_ii    :List of 3
[16:17:46.669]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.669]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:17:46.669]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.669]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:46.669]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.669]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:17:46.669]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.669]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:17:46.669]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.669]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:17:46.669]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.669]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:17:46.669]  $ ...future.seeds_ii       : NULL
[16:17:46.669]  $ ...future.globals.maxSize: NULL
[16:17:46.669]  - attr(*, "where")=List of 5
[16:17:46.669]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:46.669]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:46.669]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:46.669]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:46.669]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:46.669]  - attr(*, "resolved")= logi FALSE
[16:17:46.669]  - attr(*, "total_size")= num 1240
[16:17:46.669]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.669]  - attr(*, "already-done")= logi TRUE
[16:17:46.679] - copied ‘...future.FUN’ to environment
[16:17:46.679] - copied ‘future.call.arguments’ to environment
[16:17:46.679] - copied ‘...future.elements_ii’ to environment
[16:17:46.679] - copied ‘...future.seeds_ii’ to environment
[16:17:46.680] - copied ‘...future.globals.maxSize’ to environment
[16:17:46.680] assign_globals() ... done
[16:17:46.680] plan(): Setting new future strategy stack:
[16:17:46.680] List of future strategies:
[16:17:46.680] 1. sequential:
[16:17:46.680]    - args: function (..., envir = parent.frame())
[16:17:46.680]    - tweaked: FALSE
[16:17:46.680]    - call: NULL
[16:17:46.680] plan(): nbrOfWorkers() = 1
[16:17:46.682] plan(): Setting new future strategy stack:
[16:17:46.683] List of future strategies:
[16:17:46.683] 1. multicore:
[16:17:46.683]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:46.683]    - tweaked: FALSE
[16:17:46.683]    - call: plan(strategy)
[16:17:46.686] plan(): nbrOfWorkers() = 1
[16:17:46.686] SequentialFuture started (and completed)
[16:17:46.686] - Launch lazy future ... done
[16:17:46.686] run() for ‘SequentialFuture’ ... done
[16:17:46.687] Created future:
[16:17:46.687] SequentialFuture:
[16:17:46.687] Label: ‘future_by-1’
[16:17:46.687] Expression:
[16:17:46.687] {
[16:17:46.687]     do.call(function(...) {
[16:17:46.687]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.687]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.687]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.687]             on.exit(options(oopts), add = TRUE)
[16:17:46.687]         }
[16:17:46.687]         {
[16:17:46.687]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.687]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.687]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.687]             })
[16:17:46.687]         }
[16:17:46.687]     }, args = future.call.arguments)
[16:17:46.687] }
[16:17:46.687] Lazy evaluation: FALSE
[16:17:46.687] Asynchronous evaluation: FALSE
[16:17:46.687] Local evaluation: TRUE
[16:17:46.687] Environment: 0x55b567e7ca70
[16:17:46.687] Capture standard output: TRUE
[16:17:46.687] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:46.687] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:46.687] Packages: <none>
[16:17:46.687] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:46.687] Resolved: TRUE
[16:17:46.687] Value: 5.37 KiB of class ‘list’
[16:17:46.687] Early signaling: FALSE
[16:17:46.687] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:46.687] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.688] Chunk #1 of 1 ... DONE
[16:17:46.688] Launching 1 futures (chunks) ... DONE
[16:17:46.688] Resolving 1 futures (chunks) ...
[16:17:46.688] resolve() on list ...
[16:17:46.688]  recursive: 0
[16:17:46.688]  length: 1
[16:17:46.689] 
[16:17:46.689] resolved() for ‘SequentialFuture’ ...
[16:17:46.689] - state: ‘finished’
[16:17:46.689] - run: TRUE
[16:17:46.689] - result: ‘FutureResult’
[16:17:46.689] resolved() for ‘SequentialFuture’ ... done
[16:17:46.689] Future #1
[16:17:46.689] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:46.689] - nx: 1
[16:17:46.689] - relay: TRUE
[16:17:46.690] - stdout: TRUE
[16:17:46.690] - signal: TRUE
[16:17:46.690] - resignal: FALSE
[16:17:46.690] - force: TRUE
[16:17:46.690] - relayed: [n=1] FALSE
[16:17:46.690] - queued futures: [n=1] FALSE
[16:17:46.690]  - until=1
[16:17:46.690]  - relaying element #1
[16:17:46.690] - relayed: [n=1] TRUE
[16:17:46.690] - queued futures: [n=1] TRUE
[16:17:46.691] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:46.691]  length: 0 (resolved future 1)
[16:17:46.691] Relaying remaining futures
[16:17:46.691] signalConditionsASAP(NULL, pos=0) ...
[16:17:46.691] - nx: 1
[16:17:46.691] - relay: TRUE
[16:17:46.691] - stdout: TRUE
[16:17:46.691] - signal: TRUE
[16:17:46.691] - resignal: FALSE
[16:17:46.691] - force: TRUE
[16:17:46.691] - relayed: [n=1] TRUE
[16:17:46.691] - queued futures: [n=1] TRUE
 - flush all
[16:17:46.692] - relayed: [n=1] TRUE
[16:17:46.692] - queued futures: [n=1] TRUE
[16:17:46.692] signalConditionsASAP(NULL, pos=0) ... done
[16:17:46.692] resolve() on list ... DONE
[16:17:46.692]  - Number of value chunks collected: 1
[16:17:46.692] Resolving 1 futures (chunks) ... DONE
[16:17:46.692] Reducing values from 1 chunks ...
[16:17:46.692]  - Number of values collected after concatenation: 3
[16:17:46.692]  - Number of values expected: 3
[16:17:46.692] Reducing values from 1 chunks ... DONE
[16:17:46.693] future_lapply() ... DONE
[16:17:46.693] future_by_internal() ... DONE
[16:17:46.693] future_by_internal() ...
- plan('multisession') ...
[16:17:46.694] plan(): Setting new future strategy stack:
[16:17:46.694] List of future strategies:
[16:17:46.694] 1. multisession:
[16:17:46.694]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:17:46.694]    - tweaked: FALSE
[16:17:46.694]    - call: plan(strategy)
[16:17:46.694] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:17:46.695] multisession:
[16:17:46.695] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:17:46.695] - tweaked: FALSE
[16:17:46.695] - call: plan(strategy)
[16:17:46.698] getGlobalsAndPackages() ...
[16:17:46.698] Not searching for globals
[16:17:46.698] - globals: [0] <none>
[16:17:46.698] getGlobalsAndPackages() ... DONE
[16:17:46.699] Packages needed by the future expression (n = 0): <none>
[16:17:46.699] Packages needed by future strategies (n = 0): <none>
[16:17:46.699] {
[16:17:46.699]     {
[16:17:46.699]         {
[16:17:46.699]             ...future.startTime <- base::Sys.time()
[16:17:46.699]             {
[16:17:46.699]                 {
[16:17:46.699]                   {
[16:17:46.699]                     base::local({
[16:17:46.699]                       has_future <- base::requireNamespace("future", 
[16:17:46.699]                         quietly = TRUE)
[16:17:46.699]                       if (has_future) {
[16:17:46.699]                         ns <- base::getNamespace("future")
[16:17:46.699]                         version <- ns[[".package"]][["version"]]
[16:17:46.699]                         if (is.null(version)) 
[16:17:46.699]                           version <- utils::packageVersion("future")
[16:17:46.699]                       }
[16:17:46.699]                       else {
[16:17:46.699]                         version <- NULL
[16:17:46.699]                       }
[16:17:46.699]                       if (!has_future || version < "1.8.0") {
[16:17:46.699]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:46.699]                           "", base::R.version$version.string), 
[16:17:46.699]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:46.699]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:46.699]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:46.699]                             "release", "version")], collapse = " "), 
[16:17:46.699]                           hostname = base::Sys.info()[["nodename"]])
[16:17:46.699]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:46.699]                           info)
[16:17:46.699]                         info <- base::paste(info, collapse = "; ")
[16:17:46.699]                         if (!has_future) {
[16:17:46.699]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:46.699]                             info)
[16:17:46.699]                         }
[16:17:46.699]                         else {
[16:17:46.699]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:46.699]                             info, version)
[16:17:46.699]                         }
[16:17:46.699]                         base::stop(msg)
[16:17:46.699]                       }
[16:17:46.699]                     })
[16:17:46.699]                   }
[16:17:46.699]                   ...future.strategy.old <- future::plan("list")
[16:17:46.699]                   options(future.plan = NULL)
[16:17:46.699]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.699]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:46.699]                 }
[16:17:46.699]                 ...future.workdir <- getwd()
[16:17:46.699]             }
[16:17:46.699]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:46.699]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:46.699]         }
[16:17:46.699]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:46.699]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:46.699]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:46.699]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:46.699]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:46.699]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:46.699]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:46.699]             base::names(...future.oldOptions))
[16:17:46.699]     }
[16:17:46.699]     if (FALSE) {
[16:17:46.699]     }
[16:17:46.699]     else {
[16:17:46.699]         if (TRUE) {
[16:17:46.699]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:46.699]                 open = "w")
[16:17:46.699]         }
[16:17:46.699]         else {
[16:17:46.699]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:46.699]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:46.699]         }
[16:17:46.699]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:46.699]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:46.699]             base::sink(type = "output", split = FALSE)
[16:17:46.699]             base::close(...future.stdout)
[16:17:46.699]         }, add = TRUE)
[16:17:46.699]     }
[16:17:46.699]     ...future.frame <- base::sys.nframe()
[16:17:46.699]     ...future.conditions <- base::list()
[16:17:46.699]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:46.699]     if (FALSE) {
[16:17:46.699]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:46.699]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:46.699]     }
[16:17:46.699]     ...future.result <- base::tryCatch({
[16:17:46.699]         base::withCallingHandlers({
[16:17:46.699]             ...future.value <- base::withVisible(base::local(NA))
[16:17:46.699]             future::FutureResult(value = ...future.value$value, 
[16:17:46.699]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.699]                   ...future.rng), globalenv = if (FALSE) 
[16:17:46.699]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:46.699]                     ...future.globalenv.names))
[16:17:46.699]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:46.699]         }, condition = base::local({
[16:17:46.699]             c <- base::c
[16:17:46.699]             inherits <- base::inherits
[16:17:46.699]             invokeRestart <- base::invokeRestart
[16:17:46.699]             length <- base::length
[16:17:46.699]             list <- base::list
[16:17:46.699]             seq.int <- base::seq.int
[16:17:46.699]             signalCondition <- base::signalCondition
[16:17:46.699]             sys.calls <- base::sys.calls
[16:17:46.699]             `[[` <- base::`[[`
[16:17:46.699]             `+` <- base::`+`
[16:17:46.699]             `<<-` <- base::`<<-`
[16:17:46.699]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:46.699]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:46.699]                   3L)]
[16:17:46.699]             }
[16:17:46.699]             function(cond) {
[16:17:46.699]                 is_error <- inherits(cond, "error")
[16:17:46.699]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:46.699]                   NULL)
[16:17:46.699]                 if (is_error) {
[16:17:46.699]                   sessionInformation <- function() {
[16:17:46.699]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:46.699]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:46.699]                       search = base::search(), system = base::Sys.info())
[16:17:46.699]                   }
[16:17:46.699]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.699]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:46.699]                     cond$call), session = sessionInformation(), 
[16:17:46.699]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:46.699]                   signalCondition(cond)
[16:17:46.699]                 }
[16:17:46.699]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:46.699]                 "immediateCondition"))) {
[16:17:46.699]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:46.699]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.699]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:46.699]                   if (TRUE && !signal) {
[16:17:46.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.699]                     {
[16:17:46.699]                       inherits <- base::inherits
[16:17:46.699]                       invokeRestart <- base::invokeRestart
[16:17:46.699]                       is.null <- base::is.null
[16:17:46.699]                       muffled <- FALSE
[16:17:46.699]                       if (inherits(cond, "message")) {
[16:17:46.699]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.699]                         if (muffled) 
[16:17:46.699]                           invokeRestart("muffleMessage")
[16:17:46.699]                       }
[16:17:46.699]                       else if (inherits(cond, "warning")) {
[16:17:46.699]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.699]                         if (muffled) 
[16:17:46.699]                           invokeRestart("muffleWarning")
[16:17:46.699]                       }
[16:17:46.699]                       else if (inherits(cond, "condition")) {
[16:17:46.699]                         if (!is.null(pattern)) {
[16:17:46.699]                           computeRestarts <- base::computeRestarts
[16:17:46.699]                           grepl <- base::grepl
[16:17:46.699]                           restarts <- computeRestarts(cond)
[16:17:46.699]                           for (restart in restarts) {
[16:17:46.699]                             name <- restart$name
[16:17:46.699]                             if (is.null(name)) 
[16:17:46.699]                               next
[16:17:46.699]                             if (!grepl(pattern, name)) 
[16:17:46.699]                               next
[16:17:46.699]                             invokeRestart(restart)
[16:17:46.699]                             muffled <- TRUE
[16:17:46.699]                             break
[16:17:46.699]                           }
[16:17:46.699]                         }
[16:17:46.699]                       }
[16:17:46.699]                       invisible(muffled)
[16:17:46.699]                     }
[16:17:46.699]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.699]                   }
[16:17:46.699]                 }
[16:17:46.699]                 else {
[16:17:46.699]                   if (TRUE) {
[16:17:46.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.699]                     {
[16:17:46.699]                       inherits <- base::inherits
[16:17:46.699]                       invokeRestart <- base::invokeRestart
[16:17:46.699]                       is.null <- base::is.null
[16:17:46.699]                       muffled <- FALSE
[16:17:46.699]                       if (inherits(cond, "message")) {
[16:17:46.699]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.699]                         if (muffled) 
[16:17:46.699]                           invokeRestart("muffleMessage")
[16:17:46.699]                       }
[16:17:46.699]                       else if (inherits(cond, "warning")) {
[16:17:46.699]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.699]                         if (muffled) 
[16:17:46.699]                           invokeRestart("muffleWarning")
[16:17:46.699]                       }
[16:17:46.699]                       else if (inherits(cond, "condition")) {
[16:17:46.699]                         if (!is.null(pattern)) {
[16:17:46.699]                           computeRestarts <- base::computeRestarts
[16:17:46.699]                           grepl <- base::grepl
[16:17:46.699]                           restarts <- computeRestarts(cond)
[16:17:46.699]                           for (restart in restarts) {
[16:17:46.699]                             name <- restart$name
[16:17:46.699]                             if (is.null(name)) 
[16:17:46.699]                               next
[16:17:46.699]                             if (!grepl(pattern, name)) 
[16:17:46.699]                               next
[16:17:46.699]                             invokeRestart(restart)
[16:17:46.699]                             muffled <- TRUE
[16:17:46.699]                             break
[16:17:46.699]                           }
[16:17:46.699]                         }
[16:17:46.699]                       }
[16:17:46.699]                       invisible(muffled)
[16:17:46.699]                     }
[16:17:46.699]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.699]                   }
[16:17:46.699]                 }
[16:17:46.699]             }
[16:17:46.699]         }))
[16:17:46.699]     }, error = function(ex) {
[16:17:46.699]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:46.699]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.699]                 ...future.rng), started = ...future.startTime, 
[16:17:46.699]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:46.699]             version = "1.8"), class = "FutureResult")
[16:17:46.699]     }, finally = {
[16:17:46.699]         if (!identical(...future.workdir, getwd())) 
[16:17:46.699]             setwd(...future.workdir)
[16:17:46.699]         {
[16:17:46.699]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:46.699]                 ...future.oldOptions$nwarnings <- NULL
[16:17:46.699]             }
[16:17:46.699]             base::options(...future.oldOptions)
[16:17:46.699]             if (.Platform$OS.type == "windows") {
[16:17:46.699]                 old_names <- names(...future.oldEnvVars)
[16:17:46.699]                 envs <- base::Sys.getenv()
[16:17:46.699]                 names <- names(envs)
[16:17:46.699]                 common <- intersect(names, old_names)
[16:17:46.699]                 added <- setdiff(names, old_names)
[16:17:46.699]                 removed <- setdiff(old_names, names)
[16:17:46.699]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:46.699]                   envs[common]]
[16:17:46.699]                 NAMES <- toupper(changed)
[16:17:46.699]                 args <- list()
[16:17:46.699]                 for (kk in seq_along(NAMES)) {
[16:17:46.699]                   name <- changed[[kk]]
[16:17:46.699]                   NAME <- NAMES[[kk]]
[16:17:46.699]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.699]                     next
[16:17:46.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.699]                 }
[16:17:46.699]                 NAMES <- toupper(added)
[16:17:46.699]                 for (kk in seq_along(NAMES)) {
[16:17:46.699]                   name <- added[[kk]]
[16:17:46.699]                   NAME <- NAMES[[kk]]
[16:17:46.699]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.699]                     next
[16:17:46.699]                   args[[name]] <- ""
[16:17:46.699]                 }
[16:17:46.699]                 NAMES <- toupper(removed)
[16:17:46.699]                 for (kk in seq_along(NAMES)) {
[16:17:46.699]                   name <- removed[[kk]]
[16:17:46.699]                   NAME <- NAMES[[kk]]
[16:17:46.699]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.699]                     next
[16:17:46.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.699]                 }
[16:17:46.699]                 if (length(args) > 0) 
[16:17:46.699]                   base::do.call(base::Sys.setenv, args = args)
[16:17:46.699]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:46.699]             }
[16:17:46.699]             else {
[16:17:46.699]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:46.699]             }
[16:17:46.699]             {
[16:17:46.699]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:46.699]                   0L) {
[16:17:46.699]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:46.699]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:46.699]                   base::options(opts)
[16:17:46.699]                 }
[16:17:46.699]                 {
[16:17:46.699]                   {
[16:17:46.699]                     NULL
[16:17:46.699]                     RNGkind("Mersenne-Twister")
[16:17:46.699]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:46.699]                       inherits = FALSE)
[16:17:46.699]                   }
[16:17:46.699]                   options(future.plan = NULL)
[16:17:46.699]                   if (is.na(NA_character_)) 
[16:17:46.699]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.699]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:46.699]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:46.699]                     .init = FALSE)
[16:17:46.699]                 }
[16:17:46.699]             }
[16:17:46.699]         }
[16:17:46.699]     })
[16:17:46.699]     if (TRUE) {
[16:17:46.699]         base::sink(type = "output", split = FALSE)
[16:17:46.699]         if (TRUE) {
[16:17:46.699]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:46.699]         }
[16:17:46.699]         else {
[16:17:46.699]             ...future.result["stdout"] <- base::list(NULL)
[16:17:46.699]         }
[16:17:46.699]         base::close(...future.stdout)
[16:17:46.699]         ...future.stdout <- NULL
[16:17:46.699]     }
[16:17:46.699]     ...future.result$conditions <- ...future.conditions
[16:17:46.699]     ...future.result$finished <- base::Sys.time()
[16:17:46.699]     ...future.result
[16:17:46.699] }
[16:17:46.703] plan(): Setting new future strategy stack:
[16:17:46.703] List of future strategies:
[16:17:46.703] 1. sequential:
[16:17:46.703]    - args: function (..., envir = parent.frame())
[16:17:46.703]    - tweaked: FALSE
[16:17:46.703]    - call: NULL
[16:17:46.703] plan(): nbrOfWorkers() = 1
[16:17:46.704] plan(): Setting new future strategy stack:
[16:17:46.704] List of future strategies:
[16:17:46.704] 1. multisession:
[16:17:46.704]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:17:46.704]    - tweaked: FALSE
[16:17:46.704]    - call: plan(strategy)
[16:17:46.707] plan(): nbrOfWorkers() = 1
[16:17:46.708] SequentialFuture started (and completed)
[16:17:46.708] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:17:46.711] plan(): nbrOfWorkers() = 1
[16:17:46.711] future_by_internal() ...
[16:17:46.711] future_lapply() ...
[16:17:46.715] Number of chunks: 1
[16:17:46.715] getGlobalsAndPackagesXApply() ...
[16:17:46.715]  - future.globals: TRUE
[16:17:46.715] getGlobalsAndPackages() ...
[16:17:46.715] Searching for globals...
[16:17:46.717] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:46.717] Searching for globals ... DONE
[16:17:46.717] Resolving globals: FALSE
[16:17:46.717] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:46.718] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:46.718] - globals: [1] ‘FUN’
[16:17:46.718] 
[16:17:46.718] getGlobalsAndPackages() ... DONE
[16:17:46.718]  - globals found/used: [n=1] ‘FUN’
[16:17:46.718]  - needed namespaces: [n=0] 
[16:17:46.718] Finding globals ... DONE
[16:17:46.718]  - use_args: TRUE
[16:17:46.718]  - Getting '...' globals ...
[16:17:46.719] resolve() on list ...
[16:17:46.719]  recursive: 0
[16:17:46.719]  length: 1
[16:17:46.719]  elements: ‘...’
[16:17:46.719]  length: 0 (resolved future 1)
[16:17:46.719] resolve() on list ... DONE
[16:17:46.719]    - '...' content: [n=0] 
[16:17:46.719] List of 1
[16:17:46.719]  $ ...: list()
[16:17:46.719]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.719]  - attr(*, "where")=List of 1
[16:17:46.719]   ..$ ...:<environment: 0x55b5667bf098> 
[16:17:46.719]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.719]  - attr(*, "resolved")= logi TRUE
[16:17:46.719]  - attr(*, "total_size")= num NA
[16:17:46.722]  - Getting '...' globals ... DONE
[16:17:46.722] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:46.722] List of 2
[16:17:46.722]  $ ...future.FUN:function (object, ...)  
[16:17:46.722]  $ ...          : list()
[16:17:46.722]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.722]  - attr(*, "where")=List of 2
[16:17:46.722]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:46.722]   ..$ ...          :<environment: 0x55b5667bf098> 
[16:17:46.722]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.722]  - attr(*, "resolved")= logi FALSE
[16:17:46.722]  - attr(*, "total_size")= num 1240
[16:17:46.725] Packages to be attached in all futures: [n=0] 
[16:17:46.725] getGlobalsAndPackagesXApply() ... DONE
[16:17:46.725] Number of futures (= number of chunks): 1
[16:17:46.725] Launching 1 futures (chunks) ...
[16:17:46.725] Chunk #1 of 1 ...
[16:17:46.726]  - Finding globals in 'X' for chunk #1 ...
[16:17:46.726] getGlobalsAndPackages() ...
[16:17:46.726] Searching for globals...
[16:17:46.726] 
[16:17:46.726] Searching for globals ... DONE
[16:17:46.726] - globals: [0] <none>
[16:17:46.727] getGlobalsAndPackages() ... DONE
[16:17:46.727]    + additional globals found: [n=0] 
[16:17:46.727]    + additional namespaces needed: [n=0] 
[16:17:46.727]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:46.727]  - seeds: <none>
[16:17:46.727]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.727] getGlobalsAndPackages() ...
[16:17:46.727] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.727] Resolving globals: FALSE
[16:17:46.727] Tweak future expression to call with '...' arguments ...
[16:17:46.727] {
[16:17:46.727]     do.call(function(...) {
[16:17:46.727]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.727]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.727]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.727]             on.exit(options(oopts), add = TRUE)
[16:17:46.727]         }
[16:17:46.727]         {
[16:17:46.727]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.727]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.727]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.727]             })
[16:17:46.727]         }
[16:17:46.727]     }, args = future.call.arguments)
[16:17:46.727] }
[16:17:46.728] Tweak future expression to call with '...' arguments ... DONE
[16:17:46.728] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.728] 
[16:17:46.728] getGlobalsAndPackages() ... DONE
[16:17:46.729] run() for ‘Future’ ...
[16:17:46.729] - state: ‘created’
[16:17:46.729] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:46.734] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.734] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:46.734]   - Field: ‘label’
[16:17:46.734]   - Field: ‘local’
[16:17:46.734]   - Field: ‘owner’
[16:17:46.734]   - Field: ‘envir’
[16:17:46.735]   - Field: ‘packages’
[16:17:46.735]   - Field: ‘gc’
[16:17:46.735]   - Field: ‘conditions’
[16:17:46.735]   - Field: ‘expr’
[16:17:46.735]   - Field: ‘uuid’
[16:17:46.735]   - Field: ‘seed’
[16:17:46.735]   - Field: ‘version’
[16:17:46.735]   - Field: ‘result’
[16:17:46.735]   - Field: ‘asynchronous’
[16:17:46.735]   - Field: ‘calls’
[16:17:46.735]   - Field: ‘globals’
[16:17:46.736]   - Field: ‘stdout’
[16:17:46.736]   - Field: ‘earlySignal’
[16:17:46.736]   - Field: ‘lazy’
[16:17:46.736]   - Field: ‘state’
[16:17:46.736] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:46.736] - Launch lazy future ...
[16:17:46.736] Packages needed by the future expression (n = 0): <none>
[16:17:46.736] Packages needed by future strategies (n = 0): <none>
[16:17:46.737] {
[16:17:46.737]     {
[16:17:46.737]         {
[16:17:46.737]             ...future.startTime <- base::Sys.time()
[16:17:46.737]             {
[16:17:46.737]                 {
[16:17:46.737]                   {
[16:17:46.737]                     base::local({
[16:17:46.737]                       has_future <- base::requireNamespace("future", 
[16:17:46.737]                         quietly = TRUE)
[16:17:46.737]                       if (has_future) {
[16:17:46.737]                         ns <- base::getNamespace("future")
[16:17:46.737]                         version <- ns[[".package"]][["version"]]
[16:17:46.737]                         if (is.null(version)) 
[16:17:46.737]                           version <- utils::packageVersion("future")
[16:17:46.737]                       }
[16:17:46.737]                       else {
[16:17:46.737]                         version <- NULL
[16:17:46.737]                       }
[16:17:46.737]                       if (!has_future || version < "1.8.0") {
[16:17:46.737]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:46.737]                           "", base::R.version$version.string), 
[16:17:46.737]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:46.737]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:46.737]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:46.737]                             "release", "version")], collapse = " "), 
[16:17:46.737]                           hostname = base::Sys.info()[["nodename"]])
[16:17:46.737]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:46.737]                           info)
[16:17:46.737]                         info <- base::paste(info, collapse = "; ")
[16:17:46.737]                         if (!has_future) {
[16:17:46.737]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:46.737]                             info)
[16:17:46.737]                         }
[16:17:46.737]                         else {
[16:17:46.737]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:46.737]                             info, version)
[16:17:46.737]                         }
[16:17:46.737]                         base::stop(msg)
[16:17:46.737]                       }
[16:17:46.737]                     })
[16:17:46.737]                   }
[16:17:46.737]                   ...future.strategy.old <- future::plan("list")
[16:17:46.737]                   options(future.plan = NULL)
[16:17:46.737]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.737]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:46.737]                 }
[16:17:46.737]                 ...future.workdir <- getwd()
[16:17:46.737]             }
[16:17:46.737]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:46.737]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:46.737]         }
[16:17:46.737]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:46.737]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:46.737]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:46.737]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:46.737]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:46.737]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:46.737]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:46.737]             base::names(...future.oldOptions))
[16:17:46.737]     }
[16:17:46.737]     if (FALSE) {
[16:17:46.737]     }
[16:17:46.737]     else {
[16:17:46.737]         if (TRUE) {
[16:17:46.737]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:46.737]                 open = "w")
[16:17:46.737]         }
[16:17:46.737]         else {
[16:17:46.737]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:46.737]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:46.737]         }
[16:17:46.737]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:46.737]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:46.737]             base::sink(type = "output", split = FALSE)
[16:17:46.737]             base::close(...future.stdout)
[16:17:46.737]         }, add = TRUE)
[16:17:46.737]     }
[16:17:46.737]     ...future.frame <- base::sys.nframe()
[16:17:46.737]     ...future.conditions <- base::list()
[16:17:46.737]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:46.737]     if (FALSE) {
[16:17:46.737]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:46.737]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:46.737]     }
[16:17:46.737]     ...future.result <- base::tryCatch({
[16:17:46.737]         base::withCallingHandlers({
[16:17:46.737]             ...future.value <- base::withVisible(base::local({
[16:17:46.737]                 do.call(function(...) {
[16:17:46.737]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.737]                   if (!identical(...future.globals.maxSize.org, 
[16:17:46.737]                     ...future.globals.maxSize)) {
[16:17:46.737]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.737]                     on.exit(options(oopts), add = TRUE)
[16:17:46.737]                   }
[16:17:46.737]                   {
[16:17:46.737]                     lapply(seq_along(...future.elements_ii), 
[16:17:46.737]                       FUN = function(jj) {
[16:17:46.737]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.737]                         ...future.FUN(...future.X_jj, ...)
[16:17:46.737]                       })
[16:17:46.737]                   }
[16:17:46.737]                 }, args = future.call.arguments)
[16:17:46.737]             }))
[16:17:46.737]             future::FutureResult(value = ...future.value$value, 
[16:17:46.737]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.737]                   ...future.rng), globalenv = if (FALSE) 
[16:17:46.737]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:46.737]                     ...future.globalenv.names))
[16:17:46.737]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:46.737]         }, condition = base::local({
[16:17:46.737]             c <- base::c
[16:17:46.737]             inherits <- base::inherits
[16:17:46.737]             invokeRestart <- base::invokeRestart
[16:17:46.737]             length <- base::length
[16:17:46.737]             list <- base::list
[16:17:46.737]             seq.int <- base::seq.int
[16:17:46.737]             signalCondition <- base::signalCondition
[16:17:46.737]             sys.calls <- base::sys.calls
[16:17:46.737]             `[[` <- base::`[[`
[16:17:46.737]             `+` <- base::`+`
[16:17:46.737]             `<<-` <- base::`<<-`
[16:17:46.737]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:46.737]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:46.737]                   3L)]
[16:17:46.737]             }
[16:17:46.737]             function(cond) {
[16:17:46.737]                 is_error <- inherits(cond, "error")
[16:17:46.737]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:46.737]                   NULL)
[16:17:46.737]                 if (is_error) {
[16:17:46.737]                   sessionInformation <- function() {
[16:17:46.737]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:46.737]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:46.737]                       search = base::search(), system = base::Sys.info())
[16:17:46.737]                   }
[16:17:46.737]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.737]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:46.737]                     cond$call), session = sessionInformation(), 
[16:17:46.737]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:46.737]                   signalCondition(cond)
[16:17:46.737]                 }
[16:17:46.737]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:46.737]                 "immediateCondition"))) {
[16:17:46.737]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:46.737]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.737]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:46.737]                   if (TRUE && !signal) {
[16:17:46.737]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.737]                     {
[16:17:46.737]                       inherits <- base::inherits
[16:17:46.737]                       invokeRestart <- base::invokeRestart
[16:17:46.737]                       is.null <- base::is.null
[16:17:46.737]                       muffled <- FALSE
[16:17:46.737]                       if (inherits(cond, "message")) {
[16:17:46.737]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.737]                         if (muffled) 
[16:17:46.737]                           invokeRestart("muffleMessage")
[16:17:46.737]                       }
[16:17:46.737]                       else if (inherits(cond, "warning")) {
[16:17:46.737]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.737]                         if (muffled) 
[16:17:46.737]                           invokeRestart("muffleWarning")
[16:17:46.737]                       }
[16:17:46.737]                       else if (inherits(cond, "condition")) {
[16:17:46.737]                         if (!is.null(pattern)) {
[16:17:46.737]                           computeRestarts <- base::computeRestarts
[16:17:46.737]                           grepl <- base::grepl
[16:17:46.737]                           restarts <- computeRestarts(cond)
[16:17:46.737]                           for (restart in restarts) {
[16:17:46.737]                             name <- restart$name
[16:17:46.737]                             if (is.null(name)) 
[16:17:46.737]                               next
[16:17:46.737]                             if (!grepl(pattern, name)) 
[16:17:46.737]                               next
[16:17:46.737]                             invokeRestart(restart)
[16:17:46.737]                             muffled <- TRUE
[16:17:46.737]                             break
[16:17:46.737]                           }
[16:17:46.737]                         }
[16:17:46.737]                       }
[16:17:46.737]                       invisible(muffled)
[16:17:46.737]                     }
[16:17:46.737]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.737]                   }
[16:17:46.737]                 }
[16:17:46.737]                 else {
[16:17:46.737]                   if (TRUE) {
[16:17:46.737]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.737]                     {
[16:17:46.737]                       inherits <- base::inherits
[16:17:46.737]                       invokeRestart <- base::invokeRestart
[16:17:46.737]                       is.null <- base::is.null
[16:17:46.737]                       muffled <- FALSE
[16:17:46.737]                       if (inherits(cond, "message")) {
[16:17:46.737]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.737]                         if (muffled) 
[16:17:46.737]                           invokeRestart("muffleMessage")
[16:17:46.737]                       }
[16:17:46.737]                       else if (inherits(cond, "warning")) {
[16:17:46.737]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.737]                         if (muffled) 
[16:17:46.737]                           invokeRestart("muffleWarning")
[16:17:46.737]                       }
[16:17:46.737]                       else if (inherits(cond, "condition")) {
[16:17:46.737]                         if (!is.null(pattern)) {
[16:17:46.737]                           computeRestarts <- base::computeRestarts
[16:17:46.737]                           grepl <- base::grepl
[16:17:46.737]                           restarts <- computeRestarts(cond)
[16:17:46.737]                           for (restart in restarts) {
[16:17:46.737]                             name <- restart$name
[16:17:46.737]                             if (is.null(name)) 
[16:17:46.737]                               next
[16:17:46.737]                             if (!grepl(pattern, name)) 
[16:17:46.737]                               next
[16:17:46.737]                             invokeRestart(restart)
[16:17:46.737]                             muffled <- TRUE
[16:17:46.737]                             break
[16:17:46.737]                           }
[16:17:46.737]                         }
[16:17:46.737]                       }
[16:17:46.737]                       invisible(muffled)
[16:17:46.737]                     }
[16:17:46.737]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.737]                   }
[16:17:46.737]                 }
[16:17:46.737]             }
[16:17:46.737]         }))
[16:17:46.737]     }, error = function(ex) {
[16:17:46.737]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:46.737]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.737]                 ...future.rng), started = ...future.startTime, 
[16:17:46.737]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:46.737]             version = "1.8"), class = "FutureResult")
[16:17:46.737]     }, finally = {
[16:17:46.737]         if (!identical(...future.workdir, getwd())) 
[16:17:46.737]             setwd(...future.workdir)
[16:17:46.737]         {
[16:17:46.737]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:46.737]                 ...future.oldOptions$nwarnings <- NULL
[16:17:46.737]             }
[16:17:46.737]             base::options(...future.oldOptions)
[16:17:46.737]             if (.Platform$OS.type == "windows") {
[16:17:46.737]                 old_names <- names(...future.oldEnvVars)
[16:17:46.737]                 envs <- base::Sys.getenv()
[16:17:46.737]                 names <- names(envs)
[16:17:46.737]                 common <- intersect(names, old_names)
[16:17:46.737]                 added <- setdiff(names, old_names)
[16:17:46.737]                 removed <- setdiff(old_names, names)
[16:17:46.737]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:46.737]                   envs[common]]
[16:17:46.737]                 NAMES <- toupper(changed)
[16:17:46.737]                 args <- list()
[16:17:46.737]                 for (kk in seq_along(NAMES)) {
[16:17:46.737]                   name <- changed[[kk]]
[16:17:46.737]                   NAME <- NAMES[[kk]]
[16:17:46.737]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.737]                     next
[16:17:46.737]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.737]                 }
[16:17:46.737]                 NAMES <- toupper(added)
[16:17:46.737]                 for (kk in seq_along(NAMES)) {
[16:17:46.737]                   name <- added[[kk]]
[16:17:46.737]                   NAME <- NAMES[[kk]]
[16:17:46.737]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.737]                     next
[16:17:46.737]                   args[[name]] <- ""
[16:17:46.737]                 }
[16:17:46.737]                 NAMES <- toupper(removed)
[16:17:46.737]                 for (kk in seq_along(NAMES)) {
[16:17:46.737]                   name <- removed[[kk]]
[16:17:46.737]                   NAME <- NAMES[[kk]]
[16:17:46.737]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.737]                     next
[16:17:46.737]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.737]                 }
[16:17:46.737]                 if (length(args) > 0) 
[16:17:46.737]                   base::do.call(base::Sys.setenv, args = args)
[16:17:46.737]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:46.737]             }
[16:17:46.737]             else {
[16:17:46.737]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:46.737]             }
[16:17:46.737]             {
[16:17:46.737]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:46.737]                   0L) {
[16:17:46.737]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:46.737]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:46.737]                   base::options(opts)
[16:17:46.737]                 }
[16:17:46.737]                 {
[16:17:46.737]                   {
[16:17:46.737]                     NULL
[16:17:46.737]                     RNGkind("Mersenne-Twister")
[16:17:46.737]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:46.737]                       inherits = FALSE)
[16:17:46.737]                   }
[16:17:46.737]                   options(future.plan = NULL)
[16:17:46.737]                   if (is.na(NA_character_)) 
[16:17:46.737]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.737]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:46.737]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:46.737]                     .init = FALSE)
[16:17:46.737]                 }
[16:17:46.737]             }
[16:17:46.737]         }
[16:17:46.737]     })
[16:17:46.737]     if (TRUE) {
[16:17:46.737]         base::sink(type = "output", split = FALSE)
[16:17:46.737]         if (TRUE) {
[16:17:46.737]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:46.737]         }
[16:17:46.737]         else {
[16:17:46.737]             ...future.result["stdout"] <- base::list(NULL)
[16:17:46.737]         }
[16:17:46.737]         base::close(...future.stdout)
[16:17:46.737]         ...future.stdout <- NULL
[16:17:46.737]     }
[16:17:46.737]     ...future.result$conditions <- ...future.conditions
[16:17:46.737]     ...future.result$finished <- base::Sys.time()
[16:17:46.737]     ...future.result
[16:17:46.737] }
[16:17:46.739] assign_globals() ...
[16:17:46.739] List of 5
[16:17:46.739]  $ ...future.FUN            :function (object, ...)  
[16:17:46.739]  $ future.call.arguments    : list()
[16:17:46.739]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.739]  $ ...future.elements_ii    :List of 3
[16:17:46.739]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:17:46.739]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:17:46.739]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.739]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:17:46.739]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:17:46.739]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.739]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:17:46.739]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:17:46.739]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.739]  $ ...future.seeds_ii       : NULL
[16:17:46.739]  $ ...future.globals.maxSize: NULL
[16:17:46.739]  - attr(*, "where")=List of 5
[16:17:46.739]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:46.739]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:46.739]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:46.739]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:46.739]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:46.739]  - attr(*, "resolved")= logi FALSE
[16:17:46.739]  - attr(*, "total_size")= num 1240
[16:17:46.739]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.739]  - attr(*, "already-done")= logi TRUE
[16:17:46.746] - copied ‘...future.FUN’ to environment
[16:17:46.746] - copied ‘future.call.arguments’ to environment
[16:17:46.746] - copied ‘...future.elements_ii’ to environment
[16:17:46.746] - copied ‘...future.seeds_ii’ to environment
[16:17:46.746] - copied ‘...future.globals.maxSize’ to environment
[16:17:46.747] assign_globals() ... done
[16:17:46.747] plan(): Setting new future strategy stack:
[16:17:46.747] List of future strategies:
[16:17:46.747] 1. sequential:
[16:17:46.747]    - args: function (..., envir = parent.frame())
[16:17:46.747]    - tweaked: FALSE
[16:17:46.747]    - call: NULL
[16:17:46.747] plan(): nbrOfWorkers() = 1
[16:17:46.749] plan(): Setting new future strategy stack:
[16:17:46.749] List of future strategies:
[16:17:46.749] 1. multisession:
[16:17:46.749]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:17:46.749]    - tweaked: FALSE
[16:17:46.749]    - call: plan(strategy)
[16:17:46.753] plan(): nbrOfWorkers() = 1
[16:17:46.753] SequentialFuture started (and completed)
[16:17:46.753] - Launch lazy future ... done
[16:17:46.753] run() for ‘SequentialFuture’ ... done
[16:17:46.753] Created future:
[16:17:46.753] SequentialFuture:
[16:17:46.753] Label: ‘future_by-1’
[16:17:46.753] Expression:
[16:17:46.753] {
[16:17:46.753]     do.call(function(...) {
[16:17:46.753]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.753]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.753]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.753]             on.exit(options(oopts), add = TRUE)
[16:17:46.753]         }
[16:17:46.753]         {
[16:17:46.753]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.753]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.753]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.753]             })
[16:17:46.753]         }
[16:17:46.753]     }, args = future.call.arguments)
[16:17:46.753] }
[16:17:46.753] Lazy evaluation: FALSE
[16:17:46.753] Asynchronous evaluation: FALSE
[16:17:46.753] Local evaluation: TRUE
[16:17:46.753] Environment: R_GlobalEnv
[16:17:46.753] Capture standard output: TRUE
[16:17:46.753] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:46.753] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:46.753] Packages: <none>
[16:17:46.753] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:46.753] Resolved: TRUE
[16:17:46.753] Value: 4.62 KiB of class ‘list’
[16:17:46.753] Early signaling: FALSE
[16:17:46.753] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:46.753] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.754] Chunk #1 of 1 ... DONE
[16:17:46.755] Launching 1 futures (chunks) ... DONE
[16:17:46.755] Resolving 1 futures (chunks) ...
[16:17:46.755] resolve() on list ...
[16:17:46.755]  recursive: 0
[16:17:46.755]  length: 1
[16:17:46.755] 
[16:17:46.755] resolved() for ‘SequentialFuture’ ...
[16:17:46.755] - state: ‘finished’
[16:17:46.755] - run: TRUE
[16:17:46.755] - result: ‘FutureResult’
[16:17:46.756] resolved() for ‘SequentialFuture’ ... done
[16:17:46.756] Future #1
[16:17:46.756] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:46.757] - nx: 1
[16:17:46.757] - relay: TRUE
[16:17:46.758] - stdout: TRUE
[16:17:46.758] - signal: TRUE
[16:17:46.758] - resignal: FALSE
[16:17:46.758] - force: TRUE
[16:17:46.758] - relayed: [n=1] FALSE
[16:17:46.758] - queued futures: [n=1] FALSE
[16:17:46.758]  - until=1
[16:17:46.758]  - relaying element #1
[16:17:46.758] - relayed: [n=1] TRUE
[16:17:46.759] - queued futures: [n=1] TRUE
[16:17:46.759] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:46.759]  length: 0 (resolved future 1)
[16:17:46.759] Relaying remaining futures
[16:17:46.759] signalConditionsASAP(NULL, pos=0) ...
[16:17:46.759] - nx: 1
[16:17:46.759] - relay: TRUE
[16:17:46.759] - stdout: TRUE
[16:17:46.759] - signal: TRUE
[16:17:46.759] - resignal: FALSE
[16:17:46.759] - force: TRUE
[16:17:46.760] - relayed: [n=1] TRUE
[16:17:46.760] - queued futures: [n=1] TRUE
 - flush all
[16:17:46.760] - relayed: [n=1] TRUE
[16:17:46.760] - queued futures: [n=1] TRUE
[16:17:46.760] signalConditionsASAP(NULL, pos=0) ... done
[16:17:46.760] resolve() on list ... DONE
[16:17:46.760]  - Number of value chunks collected: 1
[16:17:46.760] Resolving 1 futures (chunks) ... DONE
[16:17:46.760] Reducing values from 1 chunks ...
[16:17:46.761]  - Number of values collected after concatenation: 3
[16:17:46.761]  - Number of values expected: 3
[16:17:46.761] Reducing values from 1 chunks ... DONE
[16:17:46.761] future_lapply() ... DONE
[16:17:46.761] future_by_internal() ... DONE
[16:17:46.761] future_by_internal() ...
[16:17:46.762] future_lapply() ...
[16:17:46.765] Number of chunks: 1
[16:17:46.765] getGlobalsAndPackagesXApply() ...
[16:17:46.765]  - future.globals: TRUE
[16:17:46.765] getGlobalsAndPackages() ...
[16:17:46.765] Searching for globals...
[16:17:46.766] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:46.767] Searching for globals ... DONE
[16:17:46.767] Resolving globals: FALSE
[16:17:46.767] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:46.767] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:46.767] - globals: [1] ‘FUN’
[16:17:46.768] 
[16:17:46.768] getGlobalsAndPackages() ... DONE
[16:17:46.768]  - globals found/used: [n=1] ‘FUN’
[16:17:46.768]  - needed namespaces: [n=0] 
[16:17:46.768] Finding globals ... DONE
[16:17:46.768]  - use_args: TRUE
[16:17:46.768]  - Getting '...' globals ...
[16:17:46.768] resolve() on list ...
[16:17:46.769]  recursive: 0
[16:17:46.769]  length: 1
[16:17:46.769]  elements: ‘...’
[16:17:46.769]  length: 0 (resolved future 1)
[16:17:46.769] resolve() on list ... DONE
[16:17:46.769]    - '...' content: [n=1] ‘digits’
[16:17:46.769] List of 1
[16:17:46.769]  $ ...:List of 1
[16:17:46.769]   ..$ digits: int 2
[16:17:46.769]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.769]  - attr(*, "where")=List of 1
[16:17:46.769]   ..$ ...:<environment: 0x55b5666c2b98> 
[16:17:46.769]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.769]  - attr(*, "resolved")= logi TRUE
[16:17:46.769]  - attr(*, "total_size")= num NA
[16:17:46.772]  - Getting '...' globals ... DONE
[16:17:46.772] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:46.772] List of 2
[16:17:46.772]  $ ...future.FUN:function (object, ...)  
[16:17:46.772]  $ ...          :List of 1
[16:17:46.772]   ..$ digits: int 2
[16:17:46.772]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.772]  - attr(*, "where")=List of 2
[16:17:46.772]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:46.772]   ..$ ...          :<environment: 0x55b5666c2b98> 
[16:17:46.772]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.772]  - attr(*, "resolved")= logi FALSE
[16:17:46.772]  - attr(*, "total_size")= num 1296
[16:17:46.775] Packages to be attached in all futures: [n=0] 
[16:17:46.775] getGlobalsAndPackagesXApply() ... DONE
[16:17:46.775] Number of futures (= number of chunks): 1
[16:17:46.776] Launching 1 futures (chunks) ...
[16:17:46.776] Chunk #1 of 1 ...
[16:17:46.776]  - Finding globals in 'X' for chunk #1 ...
[16:17:46.776] getGlobalsAndPackages() ...
[16:17:46.776] Searching for globals...
[16:17:46.776] 
[16:17:46.776] Searching for globals ... DONE
[16:17:46.777] - globals: [0] <none>
[16:17:46.777] getGlobalsAndPackages() ... DONE
[16:17:46.777]    + additional globals found: [n=0] 
[16:17:46.777]    + additional namespaces needed: [n=0] 
[16:17:46.777]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:46.777]  - seeds: <none>
[16:17:46.777]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.777] getGlobalsAndPackages() ...
[16:17:46.777] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.777] Resolving globals: FALSE
[16:17:46.777] Tweak future expression to call with '...' arguments ...
[16:17:46.778] {
[16:17:46.778]     do.call(function(...) {
[16:17:46.778]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.778]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.778]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.778]             on.exit(options(oopts), add = TRUE)
[16:17:46.778]         }
[16:17:46.778]         {
[16:17:46.778]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.778]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.778]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.778]             })
[16:17:46.778]         }
[16:17:46.778]     }, args = future.call.arguments)
[16:17:46.778] }
[16:17:46.778] Tweak future expression to call with '...' arguments ... DONE
[16:17:46.778] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.780] 
[16:17:46.780] getGlobalsAndPackages() ... DONE
[16:17:46.780] run() for ‘Future’ ...
[16:17:46.780] - state: ‘created’
[16:17:46.780] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:46.784] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.784] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:46.784]   - Field: ‘label’
[16:17:46.784]   - Field: ‘local’
[16:17:46.784]   - Field: ‘owner’
[16:17:46.784]   - Field: ‘envir’
[16:17:46.784]   - Field: ‘packages’
[16:17:46.784]   - Field: ‘gc’
[16:17:46.784]   - Field: ‘conditions’
[16:17:46.785]   - Field: ‘expr’
[16:17:46.785]   - Field: ‘uuid’
[16:17:46.785]   - Field: ‘seed’
[16:17:46.785]   - Field: ‘version’
[16:17:46.785]   - Field: ‘result’
[16:17:46.785]   - Field: ‘asynchronous’
[16:17:46.785]   - Field: ‘calls’
[16:17:46.785]   - Field: ‘globals’
[16:17:46.785]   - Field: ‘stdout’
[16:17:46.785]   - Field: ‘earlySignal’
[16:17:46.786]   - Field: ‘lazy’
[16:17:46.786]   - Field: ‘state’
[16:17:46.786] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:46.786] - Launch lazy future ...
[16:17:46.786] Packages needed by the future expression (n = 0): <none>
[16:17:46.786] Packages needed by future strategies (n = 0): <none>
[16:17:46.787] {
[16:17:46.787]     {
[16:17:46.787]         {
[16:17:46.787]             ...future.startTime <- base::Sys.time()
[16:17:46.787]             {
[16:17:46.787]                 {
[16:17:46.787]                   {
[16:17:46.787]                     base::local({
[16:17:46.787]                       has_future <- base::requireNamespace("future", 
[16:17:46.787]                         quietly = TRUE)
[16:17:46.787]                       if (has_future) {
[16:17:46.787]                         ns <- base::getNamespace("future")
[16:17:46.787]                         version <- ns[[".package"]][["version"]]
[16:17:46.787]                         if (is.null(version)) 
[16:17:46.787]                           version <- utils::packageVersion("future")
[16:17:46.787]                       }
[16:17:46.787]                       else {
[16:17:46.787]                         version <- NULL
[16:17:46.787]                       }
[16:17:46.787]                       if (!has_future || version < "1.8.0") {
[16:17:46.787]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:46.787]                           "", base::R.version$version.string), 
[16:17:46.787]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:46.787]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:46.787]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:46.787]                             "release", "version")], collapse = " "), 
[16:17:46.787]                           hostname = base::Sys.info()[["nodename"]])
[16:17:46.787]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:46.787]                           info)
[16:17:46.787]                         info <- base::paste(info, collapse = "; ")
[16:17:46.787]                         if (!has_future) {
[16:17:46.787]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:46.787]                             info)
[16:17:46.787]                         }
[16:17:46.787]                         else {
[16:17:46.787]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:46.787]                             info, version)
[16:17:46.787]                         }
[16:17:46.787]                         base::stop(msg)
[16:17:46.787]                       }
[16:17:46.787]                     })
[16:17:46.787]                   }
[16:17:46.787]                   ...future.strategy.old <- future::plan("list")
[16:17:46.787]                   options(future.plan = NULL)
[16:17:46.787]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.787]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:46.787]                 }
[16:17:46.787]                 ...future.workdir <- getwd()
[16:17:46.787]             }
[16:17:46.787]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:46.787]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:46.787]         }
[16:17:46.787]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:46.787]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:46.787]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:46.787]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:46.787]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:46.787]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:46.787]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:46.787]             base::names(...future.oldOptions))
[16:17:46.787]     }
[16:17:46.787]     if (FALSE) {
[16:17:46.787]     }
[16:17:46.787]     else {
[16:17:46.787]         if (TRUE) {
[16:17:46.787]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:46.787]                 open = "w")
[16:17:46.787]         }
[16:17:46.787]         else {
[16:17:46.787]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:46.787]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:46.787]         }
[16:17:46.787]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:46.787]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:46.787]             base::sink(type = "output", split = FALSE)
[16:17:46.787]             base::close(...future.stdout)
[16:17:46.787]         }, add = TRUE)
[16:17:46.787]     }
[16:17:46.787]     ...future.frame <- base::sys.nframe()
[16:17:46.787]     ...future.conditions <- base::list()
[16:17:46.787]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:46.787]     if (FALSE) {
[16:17:46.787]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:46.787]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:46.787]     }
[16:17:46.787]     ...future.result <- base::tryCatch({
[16:17:46.787]         base::withCallingHandlers({
[16:17:46.787]             ...future.value <- base::withVisible(base::local({
[16:17:46.787]                 do.call(function(...) {
[16:17:46.787]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.787]                   if (!identical(...future.globals.maxSize.org, 
[16:17:46.787]                     ...future.globals.maxSize)) {
[16:17:46.787]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.787]                     on.exit(options(oopts), add = TRUE)
[16:17:46.787]                   }
[16:17:46.787]                   {
[16:17:46.787]                     lapply(seq_along(...future.elements_ii), 
[16:17:46.787]                       FUN = function(jj) {
[16:17:46.787]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.787]                         ...future.FUN(...future.X_jj, ...)
[16:17:46.787]                       })
[16:17:46.787]                   }
[16:17:46.787]                 }, args = future.call.arguments)
[16:17:46.787]             }))
[16:17:46.787]             future::FutureResult(value = ...future.value$value, 
[16:17:46.787]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.787]                   ...future.rng), globalenv = if (FALSE) 
[16:17:46.787]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:46.787]                     ...future.globalenv.names))
[16:17:46.787]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:46.787]         }, condition = base::local({
[16:17:46.787]             c <- base::c
[16:17:46.787]             inherits <- base::inherits
[16:17:46.787]             invokeRestart <- base::invokeRestart
[16:17:46.787]             length <- base::length
[16:17:46.787]             list <- base::list
[16:17:46.787]             seq.int <- base::seq.int
[16:17:46.787]             signalCondition <- base::signalCondition
[16:17:46.787]             sys.calls <- base::sys.calls
[16:17:46.787]             `[[` <- base::`[[`
[16:17:46.787]             `+` <- base::`+`
[16:17:46.787]             `<<-` <- base::`<<-`
[16:17:46.787]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:46.787]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:46.787]                   3L)]
[16:17:46.787]             }
[16:17:46.787]             function(cond) {
[16:17:46.787]                 is_error <- inherits(cond, "error")
[16:17:46.787]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:46.787]                   NULL)
[16:17:46.787]                 if (is_error) {
[16:17:46.787]                   sessionInformation <- function() {
[16:17:46.787]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:46.787]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:46.787]                       search = base::search(), system = base::Sys.info())
[16:17:46.787]                   }
[16:17:46.787]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.787]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:46.787]                     cond$call), session = sessionInformation(), 
[16:17:46.787]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:46.787]                   signalCondition(cond)
[16:17:46.787]                 }
[16:17:46.787]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:46.787]                 "immediateCondition"))) {
[16:17:46.787]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:46.787]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.787]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:46.787]                   if (TRUE && !signal) {
[16:17:46.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.787]                     {
[16:17:46.787]                       inherits <- base::inherits
[16:17:46.787]                       invokeRestart <- base::invokeRestart
[16:17:46.787]                       is.null <- base::is.null
[16:17:46.787]                       muffled <- FALSE
[16:17:46.787]                       if (inherits(cond, "message")) {
[16:17:46.787]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.787]                         if (muffled) 
[16:17:46.787]                           invokeRestart("muffleMessage")
[16:17:46.787]                       }
[16:17:46.787]                       else if (inherits(cond, "warning")) {
[16:17:46.787]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.787]                         if (muffled) 
[16:17:46.787]                           invokeRestart("muffleWarning")
[16:17:46.787]                       }
[16:17:46.787]                       else if (inherits(cond, "condition")) {
[16:17:46.787]                         if (!is.null(pattern)) {
[16:17:46.787]                           computeRestarts <- base::computeRestarts
[16:17:46.787]                           grepl <- base::grepl
[16:17:46.787]                           restarts <- computeRestarts(cond)
[16:17:46.787]                           for (restart in restarts) {
[16:17:46.787]                             name <- restart$name
[16:17:46.787]                             if (is.null(name)) 
[16:17:46.787]                               next
[16:17:46.787]                             if (!grepl(pattern, name)) 
[16:17:46.787]                               next
[16:17:46.787]                             invokeRestart(restart)
[16:17:46.787]                             muffled <- TRUE
[16:17:46.787]                             break
[16:17:46.787]                           }
[16:17:46.787]                         }
[16:17:46.787]                       }
[16:17:46.787]                       invisible(muffled)
[16:17:46.787]                     }
[16:17:46.787]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.787]                   }
[16:17:46.787]                 }
[16:17:46.787]                 else {
[16:17:46.787]                   if (TRUE) {
[16:17:46.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.787]                     {
[16:17:46.787]                       inherits <- base::inherits
[16:17:46.787]                       invokeRestart <- base::invokeRestart
[16:17:46.787]                       is.null <- base::is.null
[16:17:46.787]                       muffled <- FALSE
[16:17:46.787]                       if (inherits(cond, "message")) {
[16:17:46.787]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.787]                         if (muffled) 
[16:17:46.787]                           invokeRestart("muffleMessage")
[16:17:46.787]                       }
[16:17:46.787]                       else if (inherits(cond, "warning")) {
[16:17:46.787]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.787]                         if (muffled) 
[16:17:46.787]                           invokeRestart("muffleWarning")
[16:17:46.787]                       }
[16:17:46.787]                       else if (inherits(cond, "condition")) {
[16:17:46.787]                         if (!is.null(pattern)) {
[16:17:46.787]                           computeRestarts <- base::computeRestarts
[16:17:46.787]                           grepl <- base::grepl
[16:17:46.787]                           restarts <- computeRestarts(cond)
[16:17:46.787]                           for (restart in restarts) {
[16:17:46.787]                             name <- restart$name
[16:17:46.787]                             if (is.null(name)) 
[16:17:46.787]                               next
[16:17:46.787]                             if (!grepl(pattern, name)) 
[16:17:46.787]                               next
[16:17:46.787]                             invokeRestart(restart)
[16:17:46.787]                             muffled <- TRUE
[16:17:46.787]                             break
[16:17:46.787]                           }
[16:17:46.787]                         }
[16:17:46.787]                       }
[16:17:46.787]                       invisible(muffled)
[16:17:46.787]                     }
[16:17:46.787]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.787]                   }
[16:17:46.787]                 }
[16:17:46.787]             }
[16:17:46.787]         }))
[16:17:46.787]     }, error = function(ex) {
[16:17:46.787]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:46.787]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.787]                 ...future.rng), started = ...future.startTime, 
[16:17:46.787]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:46.787]             version = "1.8"), class = "FutureResult")
[16:17:46.787]     }, finally = {
[16:17:46.787]         if (!identical(...future.workdir, getwd())) 
[16:17:46.787]             setwd(...future.workdir)
[16:17:46.787]         {
[16:17:46.787]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:46.787]                 ...future.oldOptions$nwarnings <- NULL
[16:17:46.787]             }
[16:17:46.787]             base::options(...future.oldOptions)
[16:17:46.787]             if (.Platform$OS.type == "windows") {
[16:17:46.787]                 old_names <- names(...future.oldEnvVars)
[16:17:46.787]                 envs <- base::Sys.getenv()
[16:17:46.787]                 names <- names(envs)
[16:17:46.787]                 common <- intersect(names, old_names)
[16:17:46.787]                 added <- setdiff(names, old_names)
[16:17:46.787]                 removed <- setdiff(old_names, names)
[16:17:46.787]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:46.787]                   envs[common]]
[16:17:46.787]                 NAMES <- toupper(changed)
[16:17:46.787]                 args <- list()
[16:17:46.787]                 for (kk in seq_along(NAMES)) {
[16:17:46.787]                   name <- changed[[kk]]
[16:17:46.787]                   NAME <- NAMES[[kk]]
[16:17:46.787]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.787]                     next
[16:17:46.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.787]                 }
[16:17:46.787]                 NAMES <- toupper(added)
[16:17:46.787]                 for (kk in seq_along(NAMES)) {
[16:17:46.787]                   name <- added[[kk]]
[16:17:46.787]                   NAME <- NAMES[[kk]]
[16:17:46.787]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.787]                     next
[16:17:46.787]                   args[[name]] <- ""
[16:17:46.787]                 }
[16:17:46.787]                 NAMES <- toupper(removed)
[16:17:46.787]                 for (kk in seq_along(NAMES)) {
[16:17:46.787]                   name <- removed[[kk]]
[16:17:46.787]                   NAME <- NAMES[[kk]]
[16:17:46.787]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.787]                     next
[16:17:46.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.787]                 }
[16:17:46.787]                 if (length(args) > 0) 
[16:17:46.787]                   base::do.call(base::Sys.setenv, args = args)
[16:17:46.787]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:46.787]             }
[16:17:46.787]             else {
[16:17:46.787]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:46.787]             }
[16:17:46.787]             {
[16:17:46.787]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:46.787]                   0L) {
[16:17:46.787]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:46.787]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:46.787]                   base::options(opts)
[16:17:46.787]                 }
[16:17:46.787]                 {
[16:17:46.787]                   {
[16:17:46.787]                     NULL
[16:17:46.787]                     RNGkind("Mersenne-Twister")
[16:17:46.787]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:46.787]                       inherits = FALSE)
[16:17:46.787]                   }
[16:17:46.787]                   options(future.plan = NULL)
[16:17:46.787]                   if (is.na(NA_character_)) 
[16:17:46.787]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.787]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:46.787]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:46.787]                     .init = FALSE)
[16:17:46.787]                 }
[16:17:46.787]             }
[16:17:46.787]         }
[16:17:46.787]     })
[16:17:46.787]     if (TRUE) {
[16:17:46.787]         base::sink(type = "output", split = FALSE)
[16:17:46.787]         if (TRUE) {
[16:17:46.787]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:46.787]         }
[16:17:46.787]         else {
[16:17:46.787]             ...future.result["stdout"] <- base::list(NULL)
[16:17:46.787]         }
[16:17:46.787]         base::close(...future.stdout)
[16:17:46.787]         ...future.stdout <- NULL
[16:17:46.787]     }
[16:17:46.787]     ...future.result$conditions <- ...future.conditions
[16:17:46.787]     ...future.result$finished <- base::Sys.time()
[16:17:46.787]     ...future.result
[16:17:46.787] }
[16:17:46.788] assign_globals() ...
[16:17:46.788] List of 5
[16:17:46.788]  $ ...future.FUN            :function (object, ...)  
[16:17:46.788]  $ future.call.arguments    :List of 1
[16:17:46.788]   ..$ digits: int 2
[16:17:46.788]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.788]  $ ...future.elements_ii    :List of 6
[16:17:46.788]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[16:17:46.788]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[16:17:46.788]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[16:17:46.788]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[16:17:46.788]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[16:17:46.788]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[16:17:46.788]  $ ...future.seeds_ii       : NULL
[16:17:46.788]  $ ...future.globals.maxSize: NULL
[16:17:46.788]  - attr(*, "where")=List of 5
[16:17:46.788]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:46.788]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:46.788]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:46.788]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:46.788]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:46.788]  - attr(*, "resolved")= logi FALSE
[16:17:46.788]  - attr(*, "total_size")= num 1296
[16:17:46.788]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.788]  - attr(*, "already-done")= logi TRUE
[16:17:46.795] - copied ‘...future.FUN’ to environment
[16:17:46.795] - copied ‘future.call.arguments’ to environment
[16:17:46.795] - copied ‘...future.elements_ii’ to environment
[16:17:46.795] - copied ‘...future.seeds_ii’ to environment
[16:17:46.795] - copied ‘...future.globals.maxSize’ to environment
[16:17:46.795] assign_globals() ... done
[16:17:46.795] plan(): Setting new future strategy stack:
[16:17:46.795] List of future strategies:
[16:17:46.795] 1. sequential:
[16:17:46.795]    - args: function (..., envir = parent.frame())
[16:17:46.795]    - tweaked: FALSE
[16:17:46.795]    - call: NULL
[16:17:46.796] plan(): nbrOfWorkers() = 1
[16:17:46.797] plan(): Setting new future strategy stack:
[16:17:46.797] List of future strategies:
[16:17:46.797] 1. multisession:
[16:17:46.797]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:17:46.797]    - tweaked: FALSE
[16:17:46.797]    - call: plan(strategy)
[16:17:46.801] plan(): nbrOfWorkers() = 1
[16:17:46.801] SequentialFuture started (and completed)
[16:17:46.801] - Launch lazy future ... done
[16:17:46.801] run() for ‘SequentialFuture’ ... done
[16:17:46.801] Created future:
[16:17:46.801] SequentialFuture:
[16:17:46.801] Label: ‘future_by-1’
[16:17:46.801] Expression:
[16:17:46.801] {
[16:17:46.801]     do.call(function(...) {
[16:17:46.801]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.801]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.801]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.801]             on.exit(options(oopts), add = TRUE)
[16:17:46.801]         }
[16:17:46.801]         {
[16:17:46.801]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.801]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.801]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.801]             })
[16:17:46.801]         }
[16:17:46.801]     }, args = future.call.arguments)
[16:17:46.801] }
[16:17:46.801] Lazy evaluation: FALSE
[16:17:46.801] Asynchronous evaluation: FALSE
[16:17:46.801] Local evaluation: TRUE
[16:17:46.801] Environment: R_GlobalEnv
[16:17:46.801] Capture standard output: TRUE
[16:17:46.801] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:46.801] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:46.801] Packages: <none>
[16:17:46.801] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:46.801] Resolved: TRUE
[16:17:46.801] Value: 5.48 KiB of class ‘list’
[16:17:46.801] Early signaling: FALSE
[16:17:46.801] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:46.801] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.802] Chunk #1 of 1 ... DONE
[16:17:46.802] Launching 1 futures (chunks) ... DONE
[16:17:46.802] Resolving 1 futures (chunks) ...
[16:17:46.802] resolve() on list ...
[16:17:46.803]  recursive: 0
[16:17:46.803]  length: 1
[16:17:46.803] 
[16:17:46.803] resolved() for ‘SequentialFuture’ ...
[16:17:46.803] - state: ‘finished’
[16:17:46.803] - run: TRUE
[16:17:46.803] - result: ‘FutureResult’
[16:17:46.803] resolved() for ‘SequentialFuture’ ... done
[16:17:46.803] Future #1
[16:17:46.803] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:46.804] - nx: 1
[16:17:46.804] - relay: TRUE
[16:17:46.804] - stdout: TRUE
[16:17:46.805] - signal: TRUE
[16:17:46.805] - resignal: FALSE
[16:17:46.805] - force: TRUE
[16:17:46.805] - relayed: [n=1] FALSE
[16:17:46.805] - queued futures: [n=1] FALSE
[16:17:46.805]  - until=1
[16:17:46.806]  - relaying element #1
[16:17:46.806] - relayed: [n=1] TRUE
[16:17:46.806] - queued futures: [n=1] TRUE
[16:17:46.806] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:46.806]  length: 0 (resolved future 1)
[16:17:46.806] Relaying remaining futures
[16:17:46.806] signalConditionsASAP(NULL, pos=0) ...
[16:17:46.806] - nx: 1
[16:17:46.806] - relay: TRUE
[16:17:46.806] - stdout: TRUE
[16:17:46.807] - signal: TRUE
[16:17:46.807] - resignal: FALSE
[16:17:46.807] - force: TRUE
[16:17:46.807] - relayed: [n=1] TRUE
[16:17:46.807] - queued futures: [n=1] TRUE
 - flush all
[16:17:46.807] - relayed: [n=1] TRUE
[16:17:46.807] - queued futures: [n=1] TRUE
[16:17:46.807] signalConditionsASAP(NULL, pos=0) ... done
[16:17:46.807] resolve() on list ... DONE
[16:17:46.807]  - Number of value chunks collected: 1
[16:17:46.808] Resolving 1 futures (chunks) ... DONE
[16:17:46.808] Reducing values from 1 chunks ...
[16:17:46.808]  - Number of values collected after concatenation: 6
[16:17:46.808]  - Number of values expected: 6
[16:17:46.808] Reducing values from 1 chunks ... DONE
[16:17:46.808] future_lapply() ... DONE
[16:17:46.808] future_by_internal() ... DONE
[16:17:46.809] future_by_internal() ...
[16:17:46.809] future_lapply() ...
[16:17:46.813] Number of chunks: 1
[16:17:46.813] getGlobalsAndPackagesXApply() ...
[16:17:46.813]  - future.globals: TRUE
[16:17:46.814] getGlobalsAndPackages() ...
[16:17:46.814] Searching for globals...
[16:17:46.815] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:17:46.815] Searching for globals ... DONE
[16:17:46.815] Resolving globals: FALSE
[16:17:46.816] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[16:17:46.816] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[16:17:46.816] - globals: [1] ‘FUN’
[16:17:46.816] - packages: [1] ‘stats’
[16:17:46.817] getGlobalsAndPackages() ... DONE
[16:17:46.817]  - globals found/used: [n=1] ‘FUN’
[16:17:46.817]  - needed namespaces: [n=1] ‘stats’
[16:17:46.817] Finding globals ... DONE
[16:17:46.817]  - use_args: TRUE
[16:17:46.817]  - Getting '...' globals ...
[16:17:46.817] resolve() on list ...
[16:17:46.817]  recursive: 0
[16:17:46.817]  length: 1
[16:17:46.818]  elements: ‘...’
[16:17:46.818]  length: 0 (resolved future 1)
[16:17:46.818] resolve() on list ... DONE
[16:17:46.818]    - '...' content: [n=1] ‘singular.ok’
[16:17:46.818] List of 1
[16:17:46.818]  $ ...:List of 1
[16:17:46.818]   ..$ singular.ok: logi FALSE
[16:17:46.818]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.818]  - attr(*, "where")=List of 1
[16:17:46.818]   ..$ ...:<environment: 0x55b566458940> 
[16:17:46.818]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.818]  - attr(*, "resolved")= logi TRUE
[16:17:46.818]  - attr(*, "total_size")= num NA
[16:17:46.821]  - Getting '...' globals ... DONE
[16:17:46.821] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:46.821] List of 2
[16:17:46.821]  $ ...future.FUN:function (x, ...)  
[16:17:46.821]  $ ...          :List of 1
[16:17:46.821]   ..$ singular.ok: logi FALSE
[16:17:46.821]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.821]  - attr(*, "where")=List of 2
[16:17:46.821]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:46.821]   ..$ ...          :<environment: 0x55b566458940> 
[16:17:46.821]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.821]  - attr(*, "resolved")= logi FALSE
[16:17:46.821]  - attr(*, "total_size")= num 5384
[16:17:46.824] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:46.824] getGlobalsAndPackagesXApply() ... DONE
[16:17:46.824] Number of futures (= number of chunks): 1
[16:17:46.825] Launching 1 futures (chunks) ...
[16:17:46.825] Chunk #1 of 1 ...
[16:17:46.826]  - Finding globals in 'X' for chunk #1 ...
[16:17:46.826] getGlobalsAndPackages() ...
[16:17:46.826] Searching for globals...
[16:17:46.826] 
[16:17:46.826] Searching for globals ... DONE
[16:17:46.826] - globals: [0] <none>
[16:17:46.827] getGlobalsAndPackages() ... DONE
[16:17:46.827]    + additional globals found: [n=0] 
[16:17:46.827]    + additional namespaces needed: [n=0] 
[16:17:46.827]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:46.827]  - seeds: <none>
[16:17:46.827]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.827] getGlobalsAndPackages() ...
[16:17:46.827] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.827] Resolving globals: FALSE
[16:17:46.827] Tweak future expression to call with '...' arguments ...
[16:17:46.827] {
[16:17:46.827]     do.call(function(...) {
[16:17:46.827]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.827]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.827]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.827]             on.exit(options(oopts), add = TRUE)
[16:17:46.827]         }
[16:17:46.827]         {
[16:17:46.827]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.827]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.827]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.827]             })
[16:17:46.827]         }
[16:17:46.827]     }, args = future.call.arguments)
[16:17:46.827] }
[16:17:46.828] Tweak future expression to call with '...' arguments ... DONE
[16:17:46.828] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.828] 
[16:17:46.828] getGlobalsAndPackages() ... DONE
[16:17:46.829] run() for ‘Future’ ...
[16:17:46.829] - state: ‘created’
[16:17:46.829] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:46.832] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.832] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:46.832]   - Field: ‘label’
[16:17:46.832]   - Field: ‘local’
[16:17:46.832]   - Field: ‘owner’
[16:17:46.833]   - Field: ‘envir’
[16:17:46.833]   - Field: ‘packages’
[16:17:46.833]   - Field: ‘gc’
[16:17:46.833]   - Field: ‘conditions’
[16:17:46.833]   - Field: ‘expr’
[16:17:46.833]   - Field: ‘uuid’
[16:17:46.833]   - Field: ‘seed’
[16:17:46.833]   - Field: ‘version’
[16:17:46.833]   - Field: ‘result’
[16:17:46.833]   - Field: ‘asynchronous’
[16:17:46.833]   - Field: ‘calls’
[16:17:46.834]   - Field: ‘globals’
[16:17:46.834]   - Field: ‘stdout’
[16:17:46.834]   - Field: ‘earlySignal’
[16:17:46.834]   - Field: ‘lazy’
[16:17:46.834]   - Field: ‘state’
[16:17:46.834] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:46.834] - Launch lazy future ...
[16:17:46.834] Packages needed by the future expression (n = 1): ‘stats’
[16:17:46.834] Packages needed by future strategies (n = 0): <none>
[16:17:46.835] {
[16:17:46.835]     {
[16:17:46.835]         {
[16:17:46.835]             ...future.startTime <- base::Sys.time()
[16:17:46.835]             {
[16:17:46.835]                 {
[16:17:46.835]                   {
[16:17:46.835]                     {
[16:17:46.835]                       base::local({
[16:17:46.835]                         has_future <- base::requireNamespace("future", 
[16:17:46.835]                           quietly = TRUE)
[16:17:46.835]                         if (has_future) {
[16:17:46.835]                           ns <- base::getNamespace("future")
[16:17:46.835]                           version <- ns[[".package"]][["version"]]
[16:17:46.835]                           if (is.null(version)) 
[16:17:46.835]                             version <- utils::packageVersion("future")
[16:17:46.835]                         }
[16:17:46.835]                         else {
[16:17:46.835]                           version <- NULL
[16:17:46.835]                         }
[16:17:46.835]                         if (!has_future || version < "1.8.0") {
[16:17:46.835]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:46.835]                             "", base::R.version$version.string), 
[16:17:46.835]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:46.835]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:46.835]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:46.835]                               "release", "version")], collapse = " "), 
[16:17:46.835]                             hostname = base::Sys.info()[["nodename"]])
[16:17:46.835]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:46.835]                             info)
[16:17:46.835]                           info <- base::paste(info, collapse = "; ")
[16:17:46.835]                           if (!has_future) {
[16:17:46.835]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:46.835]                               info)
[16:17:46.835]                           }
[16:17:46.835]                           else {
[16:17:46.835]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:46.835]                               info, version)
[16:17:46.835]                           }
[16:17:46.835]                           base::stop(msg)
[16:17:46.835]                         }
[16:17:46.835]                       })
[16:17:46.835]                     }
[16:17:46.835]                     base::local({
[16:17:46.835]                       for (pkg in "stats") {
[16:17:46.835]                         base::loadNamespace(pkg)
[16:17:46.835]                         base::library(pkg, character.only = TRUE)
[16:17:46.835]                       }
[16:17:46.835]                     })
[16:17:46.835]                   }
[16:17:46.835]                   ...future.strategy.old <- future::plan("list")
[16:17:46.835]                   options(future.plan = NULL)
[16:17:46.835]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.835]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:46.835]                 }
[16:17:46.835]                 ...future.workdir <- getwd()
[16:17:46.835]             }
[16:17:46.835]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:46.835]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:46.835]         }
[16:17:46.835]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:46.835]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:46.835]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:46.835]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:46.835]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:46.835]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:46.835]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:46.835]             base::names(...future.oldOptions))
[16:17:46.835]     }
[16:17:46.835]     if (FALSE) {
[16:17:46.835]     }
[16:17:46.835]     else {
[16:17:46.835]         if (TRUE) {
[16:17:46.835]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:46.835]                 open = "w")
[16:17:46.835]         }
[16:17:46.835]         else {
[16:17:46.835]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:46.835]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:46.835]         }
[16:17:46.835]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:46.835]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:46.835]             base::sink(type = "output", split = FALSE)
[16:17:46.835]             base::close(...future.stdout)
[16:17:46.835]         }, add = TRUE)
[16:17:46.835]     }
[16:17:46.835]     ...future.frame <- base::sys.nframe()
[16:17:46.835]     ...future.conditions <- base::list()
[16:17:46.835]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:46.835]     if (FALSE) {
[16:17:46.835]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:46.835]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:46.835]     }
[16:17:46.835]     ...future.result <- base::tryCatch({
[16:17:46.835]         base::withCallingHandlers({
[16:17:46.835]             ...future.value <- base::withVisible(base::local({
[16:17:46.835]                 do.call(function(...) {
[16:17:46.835]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.835]                   if (!identical(...future.globals.maxSize.org, 
[16:17:46.835]                     ...future.globals.maxSize)) {
[16:17:46.835]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.835]                     on.exit(options(oopts), add = TRUE)
[16:17:46.835]                   }
[16:17:46.835]                   {
[16:17:46.835]                     lapply(seq_along(...future.elements_ii), 
[16:17:46.835]                       FUN = function(jj) {
[16:17:46.835]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.835]                         ...future.FUN(...future.X_jj, ...)
[16:17:46.835]                       })
[16:17:46.835]                   }
[16:17:46.835]                 }, args = future.call.arguments)
[16:17:46.835]             }))
[16:17:46.835]             future::FutureResult(value = ...future.value$value, 
[16:17:46.835]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.835]                   ...future.rng), globalenv = if (FALSE) 
[16:17:46.835]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:46.835]                     ...future.globalenv.names))
[16:17:46.835]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:46.835]         }, condition = base::local({
[16:17:46.835]             c <- base::c
[16:17:46.835]             inherits <- base::inherits
[16:17:46.835]             invokeRestart <- base::invokeRestart
[16:17:46.835]             length <- base::length
[16:17:46.835]             list <- base::list
[16:17:46.835]             seq.int <- base::seq.int
[16:17:46.835]             signalCondition <- base::signalCondition
[16:17:46.835]             sys.calls <- base::sys.calls
[16:17:46.835]             `[[` <- base::`[[`
[16:17:46.835]             `+` <- base::`+`
[16:17:46.835]             `<<-` <- base::`<<-`
[16:17:46.835]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:46.835]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:46.835]                   3L)]
[16:17:46.835]             }
[16:17:46.835]             function(cond) {
[16:17:46.835]                 is_error <- inherits(cond, "error")
[16:17:46.835]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:46.835]                   NULL)
[16:17:46.835]                 if (is_error) {
[16:17:46.835]                   sessionInformation <- function() {
[16:17:46.835]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:46.835]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:46.835]                       search = base::search(), system = base::Sys.info())
[16:17:46.835]                   }
[16:17:46.835]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.835]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:46.835]                     cond$call), session = sessionInformation(), 
[16:17:46.835]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:46.835]                   signalCondition(cond)
[16:17:46.835]                 }
[16:17:46.835]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:46.835]                 "immediateCondition"))) {
[16:17:46.835]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:46.835]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.835]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:46.835]                   if (TRUE && !signal) {
[16:17:46.835]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.835]                     {
[16:17:46.835]                       inherits <- base::inherits
[16:17:46.835]                       invokeRestart <- base::invokeRestart
[16:17:46.835]                       is.null <- base::is.null
[16:17:46.835]                       muffled <- FALSE
[16:17:46.835]                       if (inherits(cond, "message")) {
[16:17:46.835]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.835]                         if (muffled) 
[16:17:46.835]                           invokeRestart("muffleMessage")
[16:17:46.835]                       }
[16:17:46.835]                       else if (inherits(cond, "warning")) {
[16:17:46.835]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.835]                         if (muffled) 
[16:17:46.835]                           invokeRestart("muffleWarning")
[16:17:46.835]                       }
[16:17:46.835]                       else if (inherits(cond, "condition")) {
[16:17:46.835]                         if (!is.null(pattern)) {
[16:17:46.835]                           computeRestarts <- base::computeRestarts
[16:17:46.835]                           grepl <- base::grepl
[16:17:46.835]                           restarts <- computeRestarts(cond)
[16:17:46.835]                           for (restart in restarts) {
[16:17:46.835]                             name <- restart$name
[16:17:46.835]                             if (is.null(name)) 
[16:17:46.835]                               next
[16:17:46.835]                             if (!grepl(pattern, name)) 
[16:17:46.835]                               next
[16:17:46.835]                             invokeRestart(restart)
[16:17:46.835]                             muffled <- TRUE
[16:17:46.835]                             break
[16:17:46.835]                           }
[16:17:46.835]                         }
[16:17:46.835]                       }
[16:17:46.835]                       invisible(muffled)
[16:17:46.835]                     }
[16:17:46.835]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.835]                   }
[16:17:46.835]                 }
[16:17:46.835]                 else {
[16:17:46.835]                   if (TRUE) {
[16:17:46.835]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.835]                     {
[16:17:46.835]                       inherits <- base::inherits
[16:17:46.835]                       invokeRestart <- base::invokeRestart
[16:17:46.835]                       is.null <- base::is.null
[16:17:46.835]                       muffled <- FALSE
[16:17:46.835]                       if (inherits(cond, "message")) {
[16:17:46.835]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.835]                         if (muffled) 
[16:17:46.835]                           invokeRestart("muffleMessage")
[16:17:46.835]                       }
[16:17:46.835]                       else if (inherits(cond, "warning")) {
[16:17:46.835]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.835]                         if (muffled) 
[16:17:46.835]                           invokeRestart("muffleWarning")
[16:17:46.835]                       }
[16:17:46.835]                       else if (inherits(cond, "condition")) {
[16:17:46.835]                         if (!is.null(pattern)) {
[16:17:46.835]                           computeRestarts <- base::computeRestarts
[16:17:46.835]                           grepl <- base::grepl
[16:17:46.835]                           restarts <- computeRestarts(cond)
[16:17:46.835]                           for (restart in restarts) {
[16:17:46.835]                             name <- restart$name
[16:17:46.835]                             if (is.null(name)) 
[16:17:46.835]                               next
[16:17:46.835]                             if (!grepl(pattern, name)) 
[16:17:46.835]                               next
[16:17:46.835]                             invokeRestart(restart)
[16:17:46.835]                             muffled <- TRUE
[16:17:46.835]                             break
[16:17:46.835]                           }
[16:17:46.835]                         }
[16:17:46.835]                       }
[16:17:46.835]                       invisible(muffled)
[16:17:46.835]                     }
[16:17:46.835]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.835]                   }
[16:17:46.835]                 }
[16:17:46.835]             }
[16:17:46.835]         }))
[16:17:46.835]     }, error = function(ex) {
[16:17:46.835]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:46.835]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.835]                 ...future.rng), started = ...future.startTime, 
[16:17:46.835]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:46.835]             version = "1.8"), class = "FutureResult")
[16:17:46.835]     }, finally = {
[16:17:46.835]         if (!identical(...future.workdir, getwd())) 
[16:17:46.835]             setwd(...future.workdir)
[16:17:46.835]         {
[16:17:46.835]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:46.835]                 ...future.oldOptions$nwarnings <- NULL
[16:17:46.835]             }
[16:17:46.835]             base::options(...future.oldOptions)
[16:17:46.835]             if (.Platform$OS.type == "windows") {
[16:17:46.835]                 old_names <- names(...future.oldEnvVars)
[16:17:46.835]                 envs <- base::Sys.getenv()
[16:17:46.835]                 names <- names(envs)
[16:17:46.835]                 common <- intersect(names, old_names)
[16:17:46.835]                 added <- setdiff(names, old_names)
[16:17:46.835]                 removed <- setdiff(old_names, names)
[16:17:46.835]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:46.835]                   envs[common]]
[16:17:46.835]                 NAMES <- toupper(changed)
[16:17:46.835]                 args <- list()
[16:17:46.835]                 for (kk in seq_along(NAMES)) {
[16:17:46.835]                   name <- changed[[kk]]
[16:17:46.835]                   NAME <- NAMES[[kk]]
[16:17:46.835]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.835]                     next
[16:17:46.835]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.835]                 }
[16:17:46.835]                 NAMES <- toupper(added)
[16:17:46.835]                 for (kk in seq_along(NAMES)) {
[16:17:46.835]                   name <- added[[kk]]
[16:17:46.835]                   NAME <- NAMES[[kk]]
[16:17:46.835]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.835]                     next
[16:17:46.835]                   args[[name]] <- ""
[16:17:46.835]                 }
[16:17:46.835]                 NAMES <- toupper(removed)
[16:17:46.835]                 for (kk in seq_along(NAMES)) {
[16:17:46.835]                   name <- removed[[kk]]
[16:17:46.835]                   NAME <- NAMES[[kk]]
[16:17:46.835]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.835]                     next
[16:17:46.835]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.835]                 }
[16:17:46.835]                 if (length(args) > 0) 
[16:17:46.835]                   base::do.call(base::Sys.setenv, args = args)
[16:17:46.835]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:46.835]             }
[16:17:46.835]             else {
[16:17:46.835]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:46.835]             }
[16:17:46.835]             {
[16:17:46.835]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:46.835]                   0L) {
[16:17:46.835]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:46.835]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:46.835]                   base::options(opts)
[16:17:46.835]                 }
[16:17:46.835]                 {
[16:17:46.835]                   {
[16:17:46.835]                     NULL
[16:17:46.835]                     RNGkind("Mersenne-Twister")
[16:17:46.835]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:46.835]                       inherits = FALSE)
[16:17:46.835]                   }
[16:17:46.835]                   options(future.plan = NULL)
[16:17:46.835]                   if (is.na(NA_character_)) 
[16:17:46.835]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.835]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:46.835]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:46.835]                     .init = FALSE)
[16:17:46.835]                 }
[16:17:46.835]             }
[16:17:46.835]         }
[16:17:46.835]     })
[16:17:46.835]     if (TRUE) {
[16:17:46.835]         base::sink(type = "output", split = FALSE)
[16:17:46.835]         if (TRUE) {
[16:17:46.835]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:46.835]         }
[16:17:46.835]         else {
[16:17:46.835]             ...future.result["stdout"] <- base::list(NULL)
[16:17:46.835]         }
[16:17:46.835]         base::close(...future.stdout)
[16:17:46.835]         ...future.stdout <- NULL
[16:17:46.835]     }
[16:17:46.835]     ...future.result$conditions <- ...future.conditions
[16:17:46.835]     ...future.result$finished <- base::Sys.time()
[16:17:46.835]     ...future.result
[16:17:46.835] }
[16:17:46.837] assign_globals() ...
[16:17:46.837] List of 5
[16:17:46.837]  $ ...future.FUN            :function (x, ...)  
[16:17:46.837]  $ future.call.arguments    :List of 1
[16:17:46.837]   ..$ singular.ok: logi FALSE
[16:17:46.837]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.837]  $ ...future.elements_ii    :List of 3
[16:17:46.837]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.837]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:17:46.837]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.837]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:46.837]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.837]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:17:46.837]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.837]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:17:46.837]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.837]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:17:46.837]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.837]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:17:46.837]  $ ...future.seeds_ii       : NULL
[16:17:46.837]  $ ...future.globals.maxSize: NULL
[16:17:46.837]  - attr(*, "where")=List of 5
[16:17:46.837]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:46.837]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:46.837]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:46.837]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:46.837]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:46.837]  - attr(*, "resolved")= logi FALSE
[16:17:46.837]  - attr(*, "total_size")= num 5384
[16:17:46.837]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.837]  - attr(*, "already-done")= logi TRUE
[16:17:46.845] - reassign environment for ‘...future.FUN’
[16:17:46.845] - copied ‘...future.FUN’ to environment
[16:17:46.845] - copied ‘future.call.arguments’ to environment
[16:17:46.845] - copied ‘...future.elements_ii’ to environment
[16:17:46.846] - copied ‘...future.seeds_ii’ to environment
[16:17:46.846] - copied ‘...future.globals.maxSize’ to environment
[16:17:46.846] assign_globals() ... done
[16:17:46.846] plan(): Setting new future strategy stack:
[16:17:46.846] List of future strategies:
[16:17:46.846] 1. sequential:
[16:17:46.846]    - args: function (..., envir = parent.frame())
[16:17:46.846]    - tweaked: FALSE
[16:17:46.846]    - call: NULL
[16:17:46.848] plan(): nbrOfWorkers() = 1
[16:17:46.850] plan(): Setting new future strategy stack:
[16:17:46.850] List of future strategies:
[16:17:46.850] 1. multisession:
[16:17:46.850]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:17:46.850]    - tweaked: FALSE
[16:17:46.850]    - call: plan(strategy)
[16:17:46.854] plan(): nbrOfWorkers() = 1
[16:17:46.854] SequentialFuture started (and completed)
[16:17:46.854] - Launch lazy future ... done
[16:17:46.854] run() for ‘SequentialFuture’ ... done
[16:17:46.854] Created future:
[16:17:46.854] SequentialFuture:
[16:17:46.854] Label: ‘future_by-1’
[16:17:46.854] Expression:
[16:17:46.854] {
[16:17:46.854]     do.call(function(...) {
[16:17:46.854]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.854]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.854]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.854]             on.exit(options(oopts), add = TRUE)
[16:17:46.854]         }
[16:17:46.854]         {
[16:17:46.854]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.854]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.854]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.854]             })
[16:17:46.854]         }
[16:17:46.854]     }, args = future.call.arguments)
[16:17:46.854] }
[16:17:46.854] Lazy evaluation: FALSE
[16:17:46.854] Asynchronous evaluation: FALSE
[16:17:46.854] Local evaluation: TRUE
[16:17:46.854] Environment: R_GlobalEnv
[16:17:46.854] Capture standard output: TRUE
[16:17:46.854] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:46.854] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:46.854] Packages: 1 packages (‘stats’)
[16:17:46.854] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:46.854] Resolved: TRUE
[16:17:46.854] Value: 26.06 KiB of class ‘list’
[16:17:46.854] Early signaling: FALSE
[16:17:46.854] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:46.854] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.856] Chunk #1 of 1 ... DONE
[16:17:46.856] Launching 1 futures (chunks) ... DONE
[16:17:46.856] Resolving 1 futures (chunks) ...
[16:17:46.856] resolve() on list ...
[16:17:46.856]  recursive: 0
[16:17:46.856]  length: 1
[16:17:46.856] 
[16:17:46.857] resolved() for ‘SequentialFuture’ ...
[16:17:46.857] - state: ‘finished’
[16:17:46.857] - run: TRUE
[16:17:46.857] - result: ‘FutureResult’
[16:17:46.857] resolved() for ‘SequentialFuture’ ... done
[16:17:46.857] Future #1
[16:17:46.857] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:46.857] - nx: 1
[16:17:46.857] - relay: TRUE
[16:17:46.857] - stdout: TRUE
[16:17:46.857] - signal: TRUE
[16:17:46.858] - resignal: FALSE
[16:17:46.858] - force: TRUE
[16:17:46.858] - relayed: [n=1] FALSE
[16:17:46.858] - queued futures: [n=1] FALSE
[16:17:46.858]  - until=1
[16:17:46.858]  - relaying element #1
[16:17:46.858] - relayed: [n=1] TRUE
[16:17:46.858] - queued futures: [n=1] TRUE
[16:17:46.858] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:46.858]  length: 0 (resolved future 1)
[16:17:46.859] Relaying remaining futures
[16:17:46.859] signalConditionsASAP(NULL, pos=0) ...
[16:17:46.859] - nx: 1
[16:17:46.859] - relay: TRUE
[16:17:46.859] - stdout: TRUE
[16:17:46.859] - signal: TRUE
[16:17:46.859] - resignal: FALSE
[16:17:46.859] - force: TRUE
[16:17:46.859] - relayed: [n=1] TRUE
[16:17:46.859] - queued futures: [n=1] TRUE
 - flush all
[16:17:46.859] - relayed: [n=1] TRUE
[16:17:46.859] - queued futures: [n=1] TRUE
[16:17:46.860] signalConditionsASAP(NULL, pos=0) ... done
[16:17:46.860] resolve() on list ... DONE
[16:17:46.860]  - Number of value chunks collected: 1
[16:17:46.860] Resolving 1 futures (chunks) ... DONE
[16:17:46.860] Reducing values from 1 chunks ...
[16:17:46.860]  - Number of values collected after concatenation: 3
[16:17:46.860]  - Number of values expected: 3
[16:17:46.860] Reducing values from 1 chunks ... DONE
[16:17:46.860] future_lapply() ... DONE
[16:17:46.860] future_by_internal() ... DONE
[16:17:46.864] future_by_internal() ...
[16:17:46.864] future_lapply() ...
[16:17:46.870] Number of chunks: 1
[16:17:46.870] getGlobalsAndPackagesXApply() ...
[16:17:46.870]  - future.globals: TRUE
[16:17:46.870] getGlobalsAndPackages() ...
[16:17:46.870] Searching for globals...
[16:17:46.872] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:17:46.872] Searching for globals ... DONE
[16:17:46.872] Resolving globals: FALSE
[16:17:46.873] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[16:17:46.873] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[16:17:46.873] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[16:17:46.873] - packages: [1] ‘stats’
[16:17:46.874] getGlobalsAndPackages() ... DONE
[16:17:46.874]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[16:17:46.874]  - needed namespaces: [n=1] ‘stats’
[16:17:46.874] Finding globals ... DONE
[16:17:46.874]  - use_args: TRUE
[16:17:46.874]  - Getting '...' globals ...
[16:17:46.874] resolve() on list ...
[16:17:46.874]  recursive: 0
[16:17:46.874]  length: 1
[16:17:46.875]  elements: ‘...’
[16:17:46.875]  length: 0 (resolved future 1)
[16:17:46.875] resolve() on list ... DONE
[16:17:46.875]    - '...' content: [n=0] 
[16:17:46.875] List of 1
[16:17:46.875]  $ ...: list()
[16:17:46.875]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.875]  - attr(*, "where")=List of 1
[16:17:46.875]   ..$ ...:<environment: 0x55b5680a9430> 
[16:17:46.875]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.875]  - attr(*, "resolved")= logi TRUE
[16:17:46.875]  - attr(*, "total_size")= num NA
[16:17:46.877]  - Getting '...' globals ... DONE
[16:17:46.878] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[16:17:46.878] List of 4
[16:17:46.878]  $ ...future.FUN:function (x)  
[16:17:46.878]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:17:46.878]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:46.878]  $ ...          : list()
[16:17:46.878]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.878]  - attr(*, "where")=List of 4
[16:17:46.878]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:46.878]   ..$ breaks       :<environment: R_EmptyEnv> 
[16:17:46.878]   ..$ wool         :<environment: R_EmptyEnv> 
[16:17:46.878]   ..$ ...          :<environment: 0x55b5680a9430> 
[16:17:46.878]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.878]  - attr(*, "resolved")= logi FALSE
[16:17:46.878]  - attr(*, "total_size")= num 2320
[16:17:46.881] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:46.881] getGlobalsAndPackagesXApply() ... DONE
[16:17:46.882] Number of futures (= number of chunks): 1
[16:17:46.882] Launching 1 futures (chunks) ...
[16:17:46.882] Chunk #1 of 1 ...
[16:17:46.882]  - Finding globals in 'X' for chunk #1 ...
[16:17:46.882] getGlobalsAndPackages() ...
[16:17:46.882] Searching for globals...
[16:17:46.883] 
[16:17:46.883] Searching for globals ... DONE
[16:17:46.883] - globals: [0] <none>
[16:17:46.883] getGlobalsAndPackages() ... DONE
[16:17:46.883]    + additional globals found: [n=0] 
[16:17:46.883]    + additional namespaces needed: [n=0] 
[16:17:46.883]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:46.883]  - seeds: <none>
[16:17:46.883]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.883] getGlobalsAndPackages() ...
[16:17:46.883] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.884] Resolving globals: FALSE
[16:17:46.884] Tweak future expression to call with '...' arguments ...
[16:17:46.884] {
[16:17:46.884]     do.call(function(...) {
[16:17:46.884]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.884]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.884]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.884]             on.exit(options(oopts), add = TRUE)
[16:17:46.884]         }
[16:17:46.884]         {
[16:17:46.884]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.884]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.884]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.884]             })
[16:17:46.884]         }
[16:17:46.884]     }, args = future.call.arguments)
[16:17:46.884] }
[16:17:46.884] Tweak future expression to call with '...' arguments ... DONE
[16:17:46.884] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.885] 
[16:17:46.885] getGlobalsAndPackages() ... DONE
[16:17:46.885] run() for ‘Future’ ...
[16:17:46.885] - state: ‘created’
[16:17:46.885] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:46.888] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.888] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:46.889]   - Field: ‘label’
[16:17:46.889]   - Field: ‘local’
[16:17:46.889]   - Field: ‘owner’
[16:17:46.889]   - Field: ‘envir’
[16:17:46.889]   - Field: ‘packages’
[16:17:46.889]   - Field: ‘gc’
[16:17:46.890]   - Field: ‘conditions’
[16:17:46.890]   - Field: ‘expr’
[16:17:46.890]   - Field: ‘uuid’
[16:17:46.890]   - Field: ‘seed’
[16:17:46.891]   - Field: ‘version’
[16:17:46.891]   - Field: ‘result’
[16:17:46.891]   - Field: ‘asynchronous’
[16:17:46.891]   - Field: ‘calls’
[16:17:46.891]   - Field: ‘globals’
[16:17:46.891]   - Field: ‘stdout’
[16:17:46.891]   - Field: ‘earlySignal’
[16:17:46.891]   - Field: ‘lazy’
[16:17:46.891]   - Field: ‘state’
[16:17:46.891] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:46.891] - Launch lazy future ...
[16:17:46.892] Packages needed by the future expression (n = 1): ‘stats’
[16:17:46.892] Packages needed by future strategies (n = 0): <none>
[16:17:46.892] {
[16:17:46.892]     {
[16:17:46.892]         {
[16:17:46.892]             ...future.startTime <- base::Sys.time()
[16:17:46.892]             {
[16:17:46.892]                 {
[16:17:46.892]                   {
[16:17:46.892]                     {
[16:17:46.892]                       base::local({
[16:17:46.892]                         has_future <- base::requireNamespace("future", 
[16:17:46.892]                           quietly = TRUE)
[16:17:46.892]                         if (has_future) {
[16:17:46.892]                           ns <- base::getNamespace("future")
[16:17:46.892]                           version <- ns[[".package"]][["version"]]
[16:17:46.892]                           if (is.null(version)) 
[16:17:46.892]                             version <- utils::packageVersion("future")
[16:17:46.892]                         }
[16:17:46.892]                         else {
[16:17:46.892]                           version <- NULL
[16:17:46.892]                         }
[16:17:46.892]                         if (!has_future || version < "1.8.0") {
[16:17:46.892]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:46.892]                             "", base::R.version$version.string), 
[16:17:46.892]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:46.892]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:46.892]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:46.892]                               "release", "version")], collapse = " "), 
[16:17:46.892]                             hostname = base::Sys.info()[["nodename"]])
[16:17:46.892]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:46.892]                             info)
[16:17:46.892]                           info <- base::paste(info, collapse = "; ")
[16:17:46.892]                           if (!has_future) {
[16:17:46.892]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:46.892]                               info)
[16:17:46.892]                           }
[16:17:46.892]                           else {
[16:17:46.892]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:46.892]                               info, version)
[16:17:46.892]                           }
[16:17:46.892]                           base::stop(msg)
[16:17:46.892]                         }
[16:17:46.892]                       })
[16:17:46.892]                     }
[16:17:46.892]                     base::local({
[16:17:46.892]                       for (pkg in "stats") {
[16:17:46.892]                         base::loadNamespace(pkg)
[16:17:46.892]                         base::library(pkg, character.only = TRUE)
[16:17:46.892]                       }
[16:17:46.892]                     })
[16:17:46.892]                   }
[16:17:46.892]                   ...future.strategy.old <- future::plan("list")
[16:17:46.892]                   options(future.plan = NULL)
[16:17:46.892]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.892]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:46.892]                 }
[16:17:46.892]                 ...future.workdir <- getwd()
[16:17:46.892]             }
[16:17:46.892]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:46.892]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:46.892]         }
[16:17:46.892]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:46.892]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:46.892]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:46.892]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:46.892]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:46.892]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:46.892]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:46.892]             base::names(...future.oldOptions))
[16:17:46.892]     }
[16:17:46.892]     if (FALSE) {
[16:17:46.892]     }
[16:17:46.892]     else {
[16:17:46.892]         if (TRUE) {
[16:17:46.892]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:46.892]                 open = "w")
[16:17:46.892]         }
[16:17:46.892]         else {
[16:17:46.892]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:46.892]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:46.892]         }
[16:17:46.892]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:46.892]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:46.892]             base::sink(type = "output", split = FALSE)
[16:17:46.892]             base::close(...future.stdout)
[16:17:46.892]         }, add = TRUE)
[16:17:46.892]     }
[16:17:46.892]     ...future.frame <- base::sys.nframe()
[16:17:46.892]     ...future.conditions <- base::list()
[16:17:46.892]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:46.892]     if (FALSE) {
[16:17:46.892]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:46.892]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:46.892]     }
[16:17:46.892]     ...future.result <- base::tryCatch({
[16:17:46.892]         base::withCallingHandlers({
[16:17:46.892]             ...future.value <- base::withVisible(base::local({
[16:17:46.892]                 do.call(function(...) {
[16:17:46.892]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.892]                   if (!identical(...future.globals.maxSize.org, 
[16:17:46.892]                     ...future.globals.maxSize)) {
[16:17:46.892]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.892]                     on.exit(options(oopts), add = TRUE)
[16:17:46.892]                   }
[16:17:46.892]                   {
[16:17:46.892]                     lapply(seq_along(...future.elements_ii), 
[16:17:46.892]                       FUN = function(jj) {
[16:17:46.892]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.892]                         ...future.FUN(...future.X_jj, ...)
[16:17:46.892]                       })
[16:17:46.892]                   }
[16:17:46.892]                 }, args = future.call.arguments)
[16:17:46.892]             }))
[16:17:46.892]             future::FutureResult(value = ...future.value$value, 
[16:17:46.892]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.892]                   ...future.rng), globalenv = if (FALSE) 
[16:17:46.892]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:46.892]                     ...future.globalenv.names))
[16:17:46.892]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:46.892]         }, condition = base::local({
[16:17:46.892]             c <- base::c
[16:17:46.892]             inherits <- base::inherits
[16:17:46.892]             invokeRestart <- base::invokeRestart
[16:17:46.892]             length <- base::length
[16:17:46.892]             list <- base::list
[16:17:46.892]             seq.int <- base::seq.int
[16:17:46.892]             signalCondition <- base::signalCondition
[16:17:46.892]             sys.calls <- base::sys.calls
[16:17:46.892]             `[[` <- base::`[[`
[16:17:46.892]             `+` <- base::`+`
[16:17:46.892]             `<<-` <- base::`<<-`
[16:17:46.892]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:46.892]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:46.892]                   3L)]
[16:17:46.892]             }
[16:17:46.892]             function(cond) {
[16:17:46.892]                 is_error <- inherits(cond, "error")
[16:17:46.892]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:46.892]                   NULL)
[16:17:46.892]                 if (is_error) {
[16:17:46.892]                   sessionInformation <- function() {
[16:17:46.892]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:46.892]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:46.892]                       search = base::search(), system = base::Sys.info())
[16:17:46.892]                   }
[16:17:46.892]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.892]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:46.892]                     cond$call), session = sessionInformation(), 
[16:17:46.892]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:46.892]                   signalCondition(cond)
[16:17:46.892]                 }
[16:17:46.892]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:46.892]                 "immediateCondition"))) {
[16:17:46.892]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:46.892]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.892]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:46.892]                   if (TRUE && !signal) {
[16:17:46.892]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.892]                     {
[16:17:46.892]                       inherits <- base::inherits
[16:17:46.892]                       invokeRestart <- base::invokeRestart
[16:17:46.892]                       is.null <- base::is.null
[16:17:46.892]                       muffled <- FALSE
[16:17:46.892]                       if (inherits(cond, "message")) {
[16:17:46.892]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.892]                         if (muffled) 
[16:17:46.892]                           invokeRestart("muffleMessage")
[16:17:46.892]                       }
[16:17:46.892]                       else if (inherits(cond, "warning")) {
[16:17:46.892]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.892]                         if (muffled) 
[16:17:46.892]                           invokeRestart("muffleWarning")
[16:17:46.892]                       }
[16:17:46.892]                       else if (inherits(cond, "condition")) {
[16:17:46.892]                         if (!is.null(pattern)) {
[16:17:46.892]                           computeRestarts <- base::computeRestarts
[16:17:46.892]                           grepl <- base::grepl
[16:17:46.892]                           restarts <- computeRestarts(cond)
[16:17:46.892]                           for (restart in restarts) {
[16:17:46.892]                             name <- restart$name
[16:17:46.892]                             if (is.null(name)) 
[16:17:46.892]                               next
[16:17:46.892]                             if (!grepl(pattern, name)) 
[16:17:46.892]                               next
[16:17:46.892]                             invokeRestart(restart)
[16:17:46.892]                             muffled <- TRUE
[16:17:46.892]                             break
[16:17:46.892]                           }
[16:17:46.892]                         }
[16:17:46.892]                       }
[16:17:46.892]                       invisible(muffled)
[16:17:46.892]                     }
[16:17:46.892]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.892]                   }
[16:17:46.892]                 }
[16:17:46.892]                 else {
[16:17:46.892]                   if (TRUE) {
[16:17:46.892]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.892]                     {
[16:17:46.892]                       inherits <- base::inherits
[16:17:46.892]                       invokeRestart <- base::invokeRestart
[16:17:46.892]                       is.null <- base::is.null
[16:17:46.892]                       muffled <- FALSE
[16:17:46.892]                       if (inherits(cond, "message")) {
[16:17:46.892]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.892]                         if (muffled) 
[16:17:46.892]                           invokeRestart("muffleMessage")
[16:17:46.892]                       }
[16:17:46.892]                       else if (inherits(cond, "warning")) {
[16:17:46.892]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.892]                         if (muffled) 
[16:17:46.892]                           invokeRestart("muffleWarning")
[16:17:46.892]                       }
[16:17:46.892]                       else if (inherits(cond, "condition")) {
[16:17:46.892]                         if (!is.null(pattern)) {
[16:17:46.892]                           computeRestarts <- base::computeRestarts
[16:17:46.892]                           grepl <- base::grepl
[16:17:46.892]                           restarts <- computeRestarts(cond)
[16:17:46.892]                           for (restart in restarts) {
[16:17:46.892]                             name <- restart$name
[16:17:46.892]                             if (is.null(name)) 
[16:17:46.892]                               next
[16:17:46.892]                             if (!grepl(pattern, name)) 
[16:17:46.892]                               next
[16:17:46.892]                             invokeRestart(restart)
[16:17:46.892]                             muffled <- TRUE
[16:17:46.892]                             break
[16:17:46.892]                           }
[16:17:46.892]                         }
[16:17:46.892]                       }
[16:17:46.892]                       invisible(muffled)
[16:17:46.892]                     }
[16:17:46.892]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.892]                   }
[16:17:46.892]                 }
[16:17:46.892]             }
[16:17:46.892]         }))
[16:17:46.892]     }, error = function(ex) {
[16:17:46.892]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:46.892]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.892]                 ...future.rng), started = ...future.startTime, 
[16:17:46.892]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:46.892]             version = "1.8"), class = "FutureResult")
[16:17:46.892]     }, finally = {
[16:17:46.892]         if (!identical(...future.workdir, getwd())) 
[16:17:46.892]             setwd(...future.workdir)
[16:17:46.892]         {
[16:17:46.892]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:46.892]                 ...future.oldOptions$nwarnings <- NULL
[16:17:46.892]             }
[16:17:46.892]             base::options(...future.oldOptions)
[16:17:46.892]             if (.Platform$OS.type == "windows") {
[16:17:46.892]                 old_names <- names(...future.oldEnvVars)
[16:17:46.892]                 envs <- base::Sys.getenv()
[16:17:46.892]                 names <- names(envs)
[16:17:46.892]                 common <- intersect(names, old_names)
[16:17:46.892]                 added <- setdiff(names, old_names)
[16:17:46.892]                 removed <- setdiff(old_names, names)
[16:17:46.892]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:46.892]                   envs[common]]
[16:17:46.892]                 NAMES <- toupper(changed)
[16:17:46.892]                 args <- list()
[16:17:46.892]                 for (kk in seq_along(NAMES)) {
[16:17:46.892]                   name <- changed[[kk]]
[16:17:46.892]                   NAME <- NAMES[[kk]]
[16:17:46.892]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.892]                     next
[16:17:46.892]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.892]                 }
[16:17:46.892]                 NAMES <- toupper(added)
[16:17:46.892]                 for (kk in seq_along(NAMES)) {
[16:17:46.892]                   name <- added[[kk]]
[16:17:46.892]                   NAME <- NAMES[[kk]]
[16:17:46.892]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.892]                     next
[16:17:46.892]                   args[[name]] <- ""
[16:17:46.892]                 }
[16:17:46.892]                 NAMES <- toupper(removed)
[16:17:46.892]                 for (kk in seq_along(NAMES)) {
[16:17:46.892]                   name <- removed[[kk]]
[16:17:46.892]                   NAME <- NAMES[[kk]]
[16:17:46.892]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.892]                     next
[16:17:46.892]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.892]                 }
[16:17:46.892]                 if (length(args) > 0) 
[16:17:46.892]                   base::do.call(base::Sys.setenv, args = args)
[16:17:46.892]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:46.892]             }
[16:17:46.892]             else {
[16:17:46.892]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:46.892]             }
[16:17:46.892]             {
[16:17:46.892]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:46.892]                   0L) {
[16:17:46.892]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:46.892]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:46.892]                   base::options(opts)
[16:17:46.892]                 }
[16:17:46.892]                 {
[16:17:46.892]                   {
[16:17:46.892]                     NULL
[16:17:46.892]                     RNGkind("Mersenne-Twister")
[16:17:46.892]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:46.892]                       inherits = FALSE)
[16:17:46.892]                   }
[16:17:46.892]                   options(future.plan = NULL)
[16:17:46.892]                   if (is.na(NA_character_)) 
[16:17:46.892]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.892]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:46.892]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:46.892]                     .init = FALSE)
[16:17:46.892]                 }
[16:17:46.892]             }
[16:17:46.892]         }
[16:17:46.892]     })
[16:17:46.892]     if (TRUE) {
[16:17:46.892]         base::sink(type = "output", split = FALSE)
[16:17:46.892]         if (TRUE) {
[16:17:46.892]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:46.892]         }
[16:17:46.892]         else {
[16:17:46.892]             ...future.result["stdout"] <- base::list(NULL)
[16:17:46.892]         }
[16:17:46.892]         base::close(...future.stdout)
[16:17:46.892]         ...future.stdout <- NULL
[16:17:46.892]     }
[16:17:46.892]     ...future.result$conditions <- ...future.conditions
[16:17:46.892]     ...future.result$finished <- base::Sys.time()
[16:17:46.892]     ...future.result
[16:17:46.892] }
[16:17:46.894] assign_globals() ...
[16:17:46.894] List of 7
[16:17:46.894]  $ ...future.FUN            :function (x)  
[16:17:46.894]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:17:46.894]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:46.894]  $ future.call.arguments    : list()
[16:17:46.894]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.894]  $ ...future.elements_ii    :List of 3
[16:17:46.894]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.894]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:17:46.894]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.894]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:46.894]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.894]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:17:46.894]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.894]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:17:46.894]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.894]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:17:46.894]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.894]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:17:46.894]  $ ...future.seeds_ii       : NULL
[16:17:46.894]  $ ...future.globals.maxSize: NULL
[16:17:46.894]  - attr(*, "where")=List of 7
[16:17:46.894]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:46.894]   ..$ breaks                   :<environment: R_EmptyEnv> 
[16:17:46.894]   ..$ wool                     :<environment: R_EmptyEnv> 
[16:17:46.894]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:46.894]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:46.894]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:46.894]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:46.894]  - attr(*, "resolved")= logi FALSE
[16:17:46.894]  - attr(*, "total_size")= num 2320
[16:17:46.894]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.894]  - attr(*, "already-done")= logi TRUE
[16:17:46.903] - reassign environment for ‘...future.FUN’
[16:17:46.903] - copied ‘...future.FUN’ to environment
[16:17:46.904] - copied ‘breaks’ to environment
[16:17:46.904] - copied ‘wool’ to environment
[16:17:46.904] - copied ‘future.call.arguments’ to environment
[16:17:46.904] - copied ‘...future.elements_ii’ to environment
[16:17:46.904] - copied ‘...future.seeds_ii’ to environment
[16:17:46.904] - copied ‘...future.globals.maxSize’ to environment
[16:17:46.904] assign_globals() ... done
[16:17:46.905] plan(): Setting new future strategy stack:
[16:17:46.905] List of future strategies:
[16:17:46.905] 1. sequential:
[16:17:46.905]    - args: function (..., envir = parent.frame())
[16:17:46.905]    - tweaked: FALSE
[16:17:46.905]    - call: NULL
[16:17:46.905] plan(): nbrOfWorkers() = 1
[16:17:46.908] plan(): Setting new future strategy stack:
[16:17:46.908] List of future strategies:
[16:17:46.908] 1. multisession:
[16:17:46.908]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:17:46.908]    - tweaked: FALSE
[16:17:46.908]    - call: plan(strategy)
[16:17:46.912] plan(): nbrOfWorkers() = 1
[16:17:46.912] SequentialFuture started (and completed)
[16:17:46.912] - Launch lazy future ... done
[16:17:46.913] run() for ‘SequentialFuture’ ... done
[16:17:46.913] Created future:
[16:17:46.913] SequentialFuture:
[16:17:46.913] Label: ‘future_by-1’
[16:17:46.913] Expression:
[16:17:46.913] {
[16:17:46.913]     do.call(function(...) {
[16:17:46.913]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.913]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.913]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.913]             on.exit(options(oopts), add = TRUE)
[16:17:46.913]         }
[16:17:46.913]         {
[16:17:46.913]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.913]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.913]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.913]             })
[16:17:46.913]         }
[16:17:46.913]     }, args = future.call.arguments)
[16:17:46.913] }
[16:17:46.913] Lazy evaluation: FALSE
[16:17:46.913] Asynchronous evaluation: FALSE
[16:17:46.913] Local evaluation: TRUE
[16:17:46.913] Environment: 0x55b568069dc0
[16:17:46.913] Capture standard output: TRUE
[16:17:46.913] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:46.913] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[16:17:46.913] Packages: 1 packages (‘stats’)
[16:17:46.913] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:46.913] Resolved: TRUE
[16:17:46.913] Value: 25.57 KiB of class ‘list’
[16:17:46.913] Early signaling: FALSE
[16:17:46.913] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:46.913] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.914] Chunk #1 of 1 ... DONE
[16:17:46.914] Launching 1 futures (chunks) ... DONE
[16:17:46.915] Resolving 1 futures (chunks) ...
[16:17:46.915] resolve() on list ...
[16:17:46.915]  recursive: 0
[16:17:46.915]  length: 1
[16:17:46.915] 
[16:17:46.915] resolved() for ‘SequentialFuture’ ...
[16:17:46.915] - state: ‘finished’
[16:17:46.915] - run: TRUE
[16:17:46.915] - result: ‘FutureResult’
[16:17:46.915] resolved() for ‘SequentialFuture’ ... done
[16:17:46.915] Future #1
[16:17:46.916] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:46.916] - nx: 1
[16:17:46.916] - relay: TRUE
[16:17:46.916] - stdout: TRUE
[16:17:46.916] - signal: TRUE
[16:17:46.916] - resignal: FALSE
[16:17:46.916] - force: TRUE
[16:17:46.916] - relayed: [n=1] FALSE
[16:17:46.916] - queued futures: [n=1] FALSE
[16:17:46.916]  - until=1
[16:17:46.916]  - relaying element #1
[16:17:46.917] - relayed: [n=1] TRUE
[16:17:46.917] - queued futures: [n=1] TRUE
[16:17:46.917] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:46.917]  length: 0 (resolved future 1)
[16:17:46.917] Relaying remaining futures
[16:17:46.917] signalConditionsASAP(NULL, pos=0) ...
[16:17:46.917] - nx: 1
[16:17:46.917] - relay: TRUE
[16:17:46.917] - stdout: TRUE
[16:17:46.917] - signal: TRUE
[16:17:46.918] - resignal: FALSE
[16:17:46.918] - force: TRUE
[16:17:46.918] - relayed: [n=1] TRUE
[16:17:46.918] - queued futures: [n=1] TRUE
 - flush all
[16:17:46.918] - relayed: [n=1] TRUE
[16:17:46.918] - queued futures: [n=1] TRUE
[16:17:46.918] signalConditionsASAP(NULL, pos=0) ... done
[16:17:46.918] resolve() on list ... DONE
[16:17:46.918]  - Number of value chunks collected: 1
[16:17:46.918] Resolving 1 futures (chunks) ... DONE
[16:17:46.918] Reducing values from 1 chunks ...
[16:17:46.919]  - Number of values collected after concatenation: 3
[16:17:46.919]  - Number of values expected: 3
[16:17:46.919] Reducing values from 1 chunks ... DONE
[16:17:46.919] future_lapply() ... DONE
[16:17:46.919] future_by_internal() ... DONE
[16:17:46.919] future_by_internal() ...
[16:17:46.920] future_lapply() ...
[16:17:46.923] Number of chunks: 1
[16:17:46.923] getGlobalsAndPackagesXApply() ...
[16:17:46.923]  - future.globals: TRUE
[16:17:46.923] getGlobalsAndPackages() ...
[16:17:46.923] Searching for globals...
[16:17:46.924] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:46.925] Searching for globals ... DONE
[16:17:46.925] Resolving globals: FALSE
[16:17:46.925] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:46.925] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:46.925] - globals: [1] ‘FUN’
[16:17:46.926] 
[16:17:46.926] getGlobalsAndPackages() ... DONE
[16:17:46.926]  - globals found/used: [n=1] ‘FUN’
[16:17:46.926]  - needed namespaces: [n=0] 
[16:17:46.926] Finding globals ... DONE
[16:17:46.926]  - use_args: TRUE
[16:17:46.926]  - Getting '...' globals ...
[16:17:46.926] resolve() on list ...
[16:17:46.926]  recursive: 0
[16:17:46.927]  length: 1
[16:17:46.927]  elements: ‘...’
[16:17:46.927]  length: 0 (resolved future 1)
[16:17:46.927] resolve() on list ... DONE
[16:17:46.927]    - '...' content: [n=0] 
[16:17:46.927] List of 1
[16:17:46.927]  $ ...: list()
[16:17:46.927]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.927]  - attr(*, "where")=List of 1
[16:17:46.927]   ..$ ...:<environment: 0x55b565ea9c50> 
[16:17:46.927]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.927]  - attr(*, "resolved")= logi TRUE
[16:17:46.927]  - attr(*, "total_size")= num NA
[16:17:46.929]  - Getting '...' globals ... DONE
[16:17:46.930] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:46.930] List of 2
[16:17:46.930]  $ ...future.FUN:function (object, ...)  
[16:17:46.930]  $ ...          : list()
[16:17:46.930]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.930]  - attr(*, "where")=List of 2
[16:17:46.930]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:46.930]   ..$ ...          :<environment: 0x55b565ea9c50> 
[16:17:46.930]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.930]  - attr(*, "resolved")= logi FALSE
[16:17:46.930]  - attr(*, "total_size")= num 1240
[16:17:46.933] Packages to be attached in all futures: [n=0] 
[16:17:46.933] getGlobalsAndPackagesXApply() ... DONE
[16:17:46.934] Number of futures (= number of chunks): 1
[16:17:46.934] Launching 1 futures (chunks) ...
[16:17:46.934] Chunk #1 of 1 ...
[16:17:46.934]  - Finding globals in 'X' for chunk #1 ...
[16:17:46.934] getGlobalsAndPackages() ...
[16:17:46.934] Searching for globals...
[16:17:46.935] 
[16:17:46.935] Searching for globals ... DONE
[16:17:46.935] - globals: [0] <none>
[16:17:46.935] getGlobalsAndPackages() ... DONE
[16:17:46.935]    + additional globals found: [n=0] 
[16:17:46.935]    + additional namespaces needed: [n=0] 
[16:17:46.935]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:46.935]  - seeds: <none>
[16:17:46.935]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.935] getGlobalsAndPackages() ...
[16:17:46.935] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.936] Resolving globals: FALSE
[16:17:46.936] Tweak future expression to call with '...' arguments ...
[16:17:46.936] {
[16:17:46.936]     do.call(function(...) {
[16:17:46.936]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.936]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.936]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.936]             on.exit(options(oopts), add = TRUE)
[16:17:46.936]         }
[16:17:46.936]         {
[16:17:46.936]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.936]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.936]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.936]             })
[16:17:46.936]         }
[16:17:46.936]     }, args = future.call.arguments)
[16:17:46.936] }
[16:17:46.936] Tweak future expression to call with '...' arguments ... DONE
[16:17:46.936] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.937] 
[16:17:46.937] getGlobalsAndPackages() ... DONE
[16:17:46.937] run() for ‘Future’ ...
[16:17:46.937] - state: ‘created’
[16:17:46.937] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:46.940] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.940] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:46.941]   - Field: ‘label’
[16:17:46.941]   - Field: ‘local’
[16:17:46.941]   - Field: ‘owner’
[16:17:46.941]   - Field: ‘envir’
[16:17:46.941]   - Field: ‘packages’
[16:17:46.941]   - Field: ‘gc’
[16:17:46.941]   - Field: ‘conditions’
[16:17:46.941]   - Field: ‘expr’
[16:17:46.941]   - Field: ‘uuid’
[16:17:46.941]   - Field: ‘seed’
[16:17:46.941]   - Field: ‘version’
[16:17:46.942]   - Field: ‘result’
[16:17:46.942]   - Field: ‘asynchronous’
[16:17:46.942]   - Field: ‘calls’
[16:17:46.942]   - Field: ‘globals’
[16:17:46.942]   - Field: ‘stdout’
[16:17:46.942]   - Field: ‘earlySignal’
[16:17:46.942]   - Field: ‘lazy’
[16:17:46.942]   - Field: ‘state’
[16:17:46.942] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:46.942] - Launch lazy future ...
[16:17:46.942] Packages needed by the future expression (n = 0): <none>
[16:17:46.943] Packages needed by future strategies (n = 0): <none>
[16:17:46.943] {
[16:17:46.943]     {
[16:17:46.943]         {
[16:17:46.943]             ...future.startTime <- base::Sys.time()
[16:17:46.943]             {
[16:17:46.943]                 {
[16:17:46.943]                   {
[16:17:46.943]                     base::local({
[16:17:46.943]                       has_future <- base::requireNamespace("future", 
[16:17:46.943]                         quietly = TRUE)
[16:17:46.943]                       if (has_future) {
[16:17:46.943]                         ns <- base::getNamespace("future")
[16:17:46.943]                         version <- ns[[".package"]][["version"]]
[16:17:46.943]                         if (is.null(version)) 
[16:17:46.943]                           version <- utils::packageVersion("future")
[16:17:46.943]                       }
[16:17:46.943]                       else {
[16:17:46.943]                         version <- NULL
[16:17:46.943]                       }
[16:17:46.943]                       if (!has_future || version < "1.8.0") {
[16:17:46.943]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:46.943]                           "", base::R.version$version.string), 
[16:17:46.943]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:46.943]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:46.943]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:46.943]                             "release", "version")], collapse = " "), 
[16:17:46.943]                           hostname = base::Sys.info()[["nodename"]])
[16:17:46.943]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:46.943]                           info)
[16:17:46.943]                         info <- base::paste(info, collapse = "; ")
[16:17:46.943]                         if (!has_future) {
[16:17:46.943]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:46.943]                             info)
[16:17:46.943]                         }
[16:17:46.943]                         else {
[16:17:46.943]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:46.943]                             info, version)
[16:17:46.943]                         }
[16:17:46.943]                         base::stop(msg)
[16:17:46.943]                       }
[16:17:46.943]                     })
[16:17:46.943]                   }
[16:17:46.943]                   ...future.strategy.old <- future::plan("list")
[16:17:46.943]                   options(future.plan = NULL)
[16:17:46.943]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.943]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:46.943]                 }
[16:17:46.943]                 ...future.workdir <- getwd()
[16:17:46.943]             }
[16:17:46.943]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:46.943]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:46.943]         }
[16:17:46.943]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:46.943]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:46.943]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:46.943]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:46.943]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:46.943]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:46.943]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:46.943]             base::names(...future.oldOptions))
[16:17:46.943]     }
[16:17:46.943]     if (FALSE) {
[16:17:46.943]     }
[16:17:46.943]     else {
[16:17:46.943]         if (TRUE) {
[16:17:46.943]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:46.943]                 open = "w")
[16:17:46.943]         }
[16:17:46.943]         else {
[16:17:46.943]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:46.943]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:46.943]         }
[16:17:46.943]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:46.943]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:46.943]             base::sink(type = "output", split = FALSE)
[16:17:46.943]             base::close(...future.stdout)
[16:17:46.943]         }, add = TRUE)
[16:17:46.943]     }
[16:17:46.943]     ...future.frame <- base::sys.nframe()
[16:17:46.943]     ...future.conditions <- base::list()
[16:17:46.943]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:46.943]     if (FALSE) {
[16:17:46.943]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:46.943]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:46.943]     }
[16:17:46.943]     ...future.result <- base::tryCatch({
[16:17:46.943]         base::withCallingHandlers({
[16:17:46.943]             ...future.value <- base::withVisible(base::local({
[16:17:46.943]                 do.call(function(...) {
[16:17:46.943]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.943]                   if (!identical(...future.globals.maxSize.org, 
[16:17:46.943]                     ...future.globals.maxSize)) {
[16:17:46.943]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.943]                     on.exit(options(oopts), add = TRUE)
[16:17:46.943]                   }
[16:17:46.943]                   {
[16:17:46.943]                     lapply(seq_along(...future.elements_ii), 
[16:17:46.943]                       FUN = function(jj) {
[16:17:46.943]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.943]                         ...future.FUN(...future.X_jj, ...)
[16:17:46.943]                       })
[16:17:46.943]                   }
[16:17:46.943]                 }, args = future.call.arguments)
[16:17:46.943]             }))
[16:17:46.943]             future::FutureResult(value = ...future.value$value, 
[16:17:46.943]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.943]                   ...future.rng), globalenv = if (FALSE) 
[16:17:46.943]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:46.943]                     ...future.globalenv.names))
[16:17:46.943]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:46.943]         }, condition = base::local({
[16:17:46.943]             c <- base::c
[16:17:46.943]             inherits <- base::inherits
[16:17:46.943]             invokeRestart <- base::invokeRestart
[16:17:46.943]             length <- base::length
[16:17:46.943]             list <- base::list
[16:17:46.943]             seq.int <- base::seq.int
[16:17:46.943]             signalCondition <- base::signalCondition
[16:17:46.943]             sys.calls <- base::sys.calls
[16:17:46.943]             `[[` <- base::`[[`
[16:17:46.943]             `+` <- base::`+`
[16:17:46.943]             `<<-` <- base::`<<-`
[16:17:46.943]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:46.943]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:46.943]                   3L)]
[16:17:46.943]             }
[16:17:46.943]             function(cond) {
[16:17:46.943]                 is_error <- inherits(cond, "error")
[16:17:46.943]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:46.943]                   NULL)
[16:17:46.943]                 if (is_error) {
[16:17:46.943]                   sessionInformation <- function() {
[16:17:46.943]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:46.943]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:46.943]                       search = base::search(), system = base::Sys.info())
[16:17:46.943]                   }
[16:17:46.943]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.943]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:46.943]                     cond$call), session = sessionInformation(), 
[16:17:46.943]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:46.943]                   signalCondition(cond)
[16:17:46.943]                 }
[16:17:46.943]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:46.943]                 "immediateCondition"))) {
[16:17:46.943]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:46.943]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.943]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:46.943]                   if (TRUE && !signal) {
[16:17:46.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.943]                     {
[16:17:46.943]                       inherits <- base::inherits
[16:17:46.943]                       invokeRestart <- base::invokeRestart
[16:17:46.943]                       is.null <- base::is.null
[16:17:46.943]                       muffled <- FALSE
[16:17:46.943]                       if (inherits(cond, "message")) {
[16:17:46.943]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.943]                         if (muffled) 
[16:17:46.943]                           invokeRestart("muffleMessage")
[16:17:46.943]                       }
[16:17:46.943]                       else if (inherits(cond, "warning")) {
[16:17:46.943]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.943]                         if (muffled) 
[16:17:46.943]                           invokeRestart("muffleWarning")
[16:17:46.943]                       }
[16:17:46.943]                       else if (inherits(cond, "condition")) {
[16:17:46.943]                         if (!is.null(pattern)) {
[16:17:46.943]                           computeRestarts <- base::computeRestarts
[16:17:46.943]                           grepl <- base::grepl
[16:17:46.943]                           restarts <- computeRestarts(cond)
[16:17:46.943]                           for (restart in restarts) {
[16:17:46.943]                             name <- restart$name
[16:17:46.943]                             if (is.null(name)) 
[16:17:46.943]                               next
[16:17:46.943]                             if (!grepl(pattern, name)) 
[16:17:46.943]                               next
[16:17:46.943]                             invokeRestart(restart)
[16:17:46.943]                             muffled <- TRUE
[16:17:46.943]                             break
[16:17:46.943]                           }
[16:17:46.943]                         }
[16:17:46.943]                       }
[16:17:46.943]                       invisible(muffled)
[16:17:46.943]                     }
[16:17:46.943]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.943]                   }
[16:17:46.943]                 }
[16:17:46.943]                 else {
[16:17:46.943]                   if (TRUE) {
[16:17:46.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.943]                     {
[16:17:46.943]                       inherits <- base::inherits
[16:17:46.943]                       invokeRestart <- base::invokeRestart
[16:17:46.943]                       is.null <- base::is.null
[16:17:46.943]                       muffled <- FALSE
[16:17:46.943]                       if (inherits(cond, "message")) {
[16:17:46.943]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.943]                         if (muffled) 
[16:17:46.943]                           invokeRestart("muffleMessage")
[16:17:46.943]                       }
[16:17:46.943]                       else if (inherits(cond, "warning")) {
[16:17:46.943]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.943]                         if (muffled) 
[16:17:46.943]                           invokeRestart("muffleWarning")
[16:17:46.943]                       }
[16:17:46.943]                       else if (inherits(cond, "condition")) {
[16:17:46.943]                         if (!is.null(pattern)) {
[16:17:46.943]                           computeRestarts <- base::computeRestarts
[16:17:46.943]                           grepl <- base::grepl
[16:17:46.943]                           restarts <- computeRestarts(cond)
[16:17:46.943]                           for (restart in restarts) {
[16:17:46.943]                             name <- restart$name
[16:17:46.943]                             if (is.null(name)) 
[16:17:46.943]                               next
[16:17:46.943]                             if (!grepl(pattern, name)) 
[16:17:46.943]                               next
[16:17:46.943]                             invokeRestart(restart)
[16:17:46.943]                             muffled <- TRUE
[16:17:46.943]                             break
[16:17:46.943]                           }
[16:17:46.943]                         }
[16:17:46.943]                       }
[16:17:46.943]                       invisible(muffled)
[16:17:46.943]                     }
[16:17:46.943]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.943]                   }
[16:17:46.943]                 }
[16:17:46.943]             }
[16:17:46.943]         }))
[16:17:46.943]     }, error = function(ex) {
[16:17:46.943]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:46.943]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.943]                 ...future.rng), started = ...future.startTime, 
[16:17:46.943]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:46.943]             version = "1.8"), class = "FutureResult")
[16:17:46.943]     }, finally = {
[16:17:46.943]         if (!identical(...future.workdir, getwd())) 
[16:17:46.943]             setwd(...future.workdir)
[16:17:46.943]         {
[16:17:46.943]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:46.943]                 ...future.oldOptions$nwarnings <- NULL
[16:17:46.943]             }
[16:17:46.943]             base::options(...future.oldOptions)
[16:17:46.943]             if (.Platform$OS.type == "windows") {
[16:17:46.943]                 old_names <- names(...future.oldEnvVars)
[16:17:46.943]                 envs <- base::Sys.getenv()
[16:17:46.943]                 names <- names(envs)
[16:17:46.943]                 common <- intersect(names, old_names)
[16:17:46.943]                 added <- setdiff(names, old_names)
[16:17:46.943]                 removed <- setdiff(old_names, names)
[16:17:46.943]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:46.943]                   envs[common]]
[16:17:46.943]                 NAMES <- toupper(changed)
[16:17:46.943]                 args <- list()
[16:17:46.943]                 for (kk in seq_along(NAMES)) {
[16:17:46.943]                   name <- changed[[kk]]
[16:17:46.943]                   NAME <- NAMES[[kk]]
[16:17:46.943]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.943]                     next
[16:17:46.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.943]                 }
[16:17:46.943]                 NAMES <- toupper(added)
[16:17:46.943]                 for (kk in seq_along(NAMES)) {
[16:17:46.943]                   name <- added[[kk]]
[16:17:46.943]                   NAME <- NAMES[[kk]]
[16:17:46.943]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.943]                     next
[16:17:46.943]                   args[[name]] <- ""
[16:17:46.943]                 }
[16:17:46.943]                 NAMES <- toupper(removed)
[16:17:46.943]                 for (kk in seq_along(NAMES)) {
[16:17:46.943]                   name <- removed[[kk]]
[16:17:46.943]                   NAME <- NAMES[[kk]]
[16:17:46.943]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.943]                     next
[16:17:46.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.943]                 }
[16:17:46.943]                 if (length(args) > 0) 
[16:17:46.943]                   base::do.call(base::Sys.setenv, args = args)
[16:17:46.943]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:46.943]             }
[16:17:46.943]             else {
[16:17:46.943]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:46.943]             }
[16:17:46.943]             {
[16:17:46.943]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:46.943]                   0L) {
[16:17:46.943]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:46.943]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:46.943]                   base::options(opts)
[16:17:46.943]                 }
[16:17:46.943]                 {
[16:17:46.943]                   {
[16:17:46.943]                     NULL
[16:17:46.943]                     RNGkind("Mersenne-Twister")
[16:17:46.943]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:46.943]                       inherits = FALSE)
[16:17:46.943]                   }
[16:17:46.943]                   options(future.plan = NULL)
[16:17:46.943]                   if (is.na(NA_character_)) 
[16:17:46.943]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.943]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:46.943]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:46.943]                     .init = FALSE)
[16:17:46.943]                 }
[16:17:46.943]             }
[16:17:46.943]         }
[16:17:46.943]     })
[16:17:46.943]     if (TRUE) {
[16:17:46.943]         base::sink(type = "output", split = FALSE)
[16:17:46.943]         if (TRUE) {
[16:17:46.943]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:46.943]         }
[16:17:46.943]         else {
[16:17:46.943]             ...future.result["stdout"] <- base::list(NULL)
[16:17:46.943]         }
[16:17:46.943]         base::close(...future.stdout)
[16:17:46.943]         ...future.stdout <- NULL
[16:17:46.943]     }
[16:17:46.943]     ...future.result$conditions <- ...future.conditions
[16:17:46.943]     ...future.result$finished <- base::Sys.time()
[16:17:46.943]     ...future.result
[16:17:46.943] }
[16:17:46.945] assign_globals() ...
[16:17:46.945] List of 5
[16:17:46.945]  $ ...future.FUN            :function (object, ...)  
[16:17:46.945]  $ future.call.arguments    : list()
[16:17:46.945]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.945]  $ ...future.elements_ii    :List of 3
[16:17:46.945]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.945]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:17:46.945]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.945]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:46.945]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.945]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:17:46.945]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.945]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:17:46.945]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.945]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:17:46.945]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.945]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:17:46.945]  $ ...future.seeds_ii       : NULL
[16:17:46.945]  $ ...future.globals.maxSize: NULL
[16:17:46.945]  - attr(*, "where")=List of 5
[16:17:46.945]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:46.945]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:46.945]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:46.945]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:46.945]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:46.945]  - attr(*, "resolved")= logi FALSE
[16:17:46.945]  - attr(*, "total_size")= num 1240
[16:17:46.945]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.945]  - attr(*, "already-done")= logi TRUE
[16:17:46.954] - copied ‘...future.FUN’ to environment
[16:17:46.954] - copied ‘future.call.arguments’ to environment
[16:17:46.954] - copied ‘...future.elements_ii’ to environment
[16:17:46.954] - copied ‘...future.seeds_ii’ to environment
[16:17:46.955] - copied ‘...future.globals.maxSize’ to environment
[16:17:46.955] assign_globals() ... done
[16:17:46.955] plan(): Setting new future strategy stack:
[16:17:46.955] List of future strategies:
[16:17:46.955] 1. sequential:
[16:17:46.955]    - args: function (..., envir = parent.frame())
[16:17:46.955]    - tweaked: FALSE
[16:17:46.955]    - call: NULL
[16:17:46.955] plan(): nbrOfWorkers() = 1
[16:17:46.958] plan(): Setting new future strategy stack:
[16:17:46.958] List of future strategies:
[16:17:46.958] 1. multisession:
[16:17:46.958]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:17:46.958]    - tweaked: FALSE
[16:17:46.958]    - call: plan(strategy)
[16:17:46.961] plan(): nbrOfWorkers() = 1
[16:17:46.961] SequentialFuture started (and completed)
[16:17:46.961] - Launch lazy future ... done
[16:17:46.961] run() for ‘SequentialFuture’ ... done
[16:17:46.961] Created future:
[16:17:46.962] SequentialFuture:
[16:17:46.962] Label: ‘future_by-1’
[16:17:46.962] Expression:
[16:17:46.962] {
[16:17:46.962]     do.call(function(...) {
[16:17:46.962]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.962]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.962]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.962]             on.exit(options(oopts), add = TRUE)
[16:17:46.962]         }
[16:17:46.962]         {
[16:17:46.962]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.962]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.962]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.962]             })
[16:17:46.962]         }
[16:17:46.962]     }, args = future.call.arguments)
[16:17:46.962] }
[16:17:46.962] Lazy evaluation: FALSE
[16:17:46.962] Asynchronous evaluation: FALSE
[16:17:46.962] Local evaluation: TRUE
[16:17:46.962] Environment: 0x55b566538b68
[16:17:46.962] Capture standard output: TRUE
[16:17:46.962] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:46.962] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:46.962] Packages: <none>
[16:17:46.962] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:46.962] Resolved: TRUE
[16:17:46.962] Value: 5.37 KiB of class ‘list’
[16:17:46.962] Early signaling: FALSE
[16:17:46.962] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:46.962] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.963] Chunk #1 of 1 ... DONE
[16:17:46.963] Launching 1 futures (chunks) ... DONE
[16:17:46.963] Resolving 1 futures (chunks) ...
[16:17:46.963] resolve() on list ...
[16:17:46.963]  recursive: 0
[16:17:46.963]  length: 1
[16:17:46.963] 
[16:17:46.963] resolved() for ‘SequentialFuture’ ...
[16:17:46.963] - state: ‘finished’
[16:17:46.964] - run: TRUE
[16:17:46.964] - result: ‘FutureResult’
[16:17:46.964] resolved() for ‘SequentialFuture’ ... done
[16:17:46.964] Future #1
[16:17:46.964] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:46.964] - nx: 1
[16:17:46.964] - relay: TRUE
[16:17:46.964] - stdout: TRUE
[16:17:46.964] - signal: TRUE
[16:17:46.964] - resignal: FALSE
[16:17:46.965] - force: TRUE
[16:17:46.965] - relayed: [n=1] FALSE
[16:17:46.965] - queued futures: [n=1] FALSE
[16:17:46.965]  - until=1
[16:17:46.965]  - relaying element #1
[16:17:46.965] - relayed: [n=1] TRUE
[16:17:46.965] - queued futures: [n=1] TRUE
[16:17:46.965] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:46.965]  length: 0 (resolved future 1)
[16:17:46.965] Relaying remaining futures
[16:17:46.966] signalConditionsASAP(NULL, pos=0) ...
[16:17:46.966] - nx: 1
[16:17:46.966] - relay: TRUE
[16:17:46.966] - stdout: TRUE
[16:17:46.966] - signal: TRUE
[16:17:46.966] - resignal: FALSE
[16:17:46.966] - force: TRUE
[16:17:46.966] - relayed: [n=1] TRUE
[16:17:46.966] - queued futures: [n=1] TRUE
 - flush all
[16:17:46.966] - relayed: [n=1] TRUE
[16:17:46.966] - queued futures: [n=1] TRUE
[16:17:46.966] signalConditionsASAP(NULL, pos=0) ... done
[16:17:46.967] resolve() on list ... DONE
[16:17:46.967]  - Number of value chunks collected: 1
[16:17:46.967] Resolving 1 futures (chunks) ... DONE
[16:17:46.967] Reducing values from 1 chunks ...
[16:17:46.967]  - Number of values collected after concatenation: 3
[16:17:46.967]  - Number of values expected: 3
[16:17:46.967] Reducing values from 1 chunks ... DONE
[16:17:46.967] future_lapply() ... DONE
[16:17:46.967] future_by_internal() ... DONE
[16:17:46.968] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[16:17:46.969] future_lapply() ...
[16:17:46.972] Number of chunks: 1
[16:17:46.972] getGlobalsAndPackagesXApply() ...
[16:17:46.972]  - future.globals: TRUE
[16:17:46.972] getGlobalsAndPackages() ...
[16:17:46.972] Searching for globals...
[16:17:46.973] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:46.973] Searching for globals ... DONE
[16:17:46.973] Resolving globals: FALSE
[16:17:46.974] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:46.974] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:46.974] - globals: [1] ‘FUN’
[16:17:46.974] 
[16:17:46.974] getGlobalsAndPackages() ... DONE
[16:17:46.974]  - globals found/used: [n=1] ‘FUN’
[16:17:46.975]  - needed namespaces: [n=0] 
[16:17:46.975] Finding globals ... DONE
[16:17:46.975]  - use_args: TRUE
[16:17:46.975]  - Getting '...' globals ...
[16:17:46.975] resolve() on list ...
[16:17:46.975]  recursive: 0
[16:17:46.975]  length: 1
[16:17:46.975]  elements: ‘...’
[16:17:46.976]  length: 0 (resolved future 1)
[16:17:46.978] resolve() on list ... DONE
[16:17:46.978]    - '...' content: [n=0] 
[16:17:46.978] List of 1
[16:17:46.978]  $ ...: list()
[16:17:46.978]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.978]  - attr(*, "where")=List of 1
[16:17:46.978]   ..$ ...:<environment: 0x55b567dcb8e0> 
[16:17:46.978]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.978]  - attr(*, "resolved")= logi TRUE
[16:17:46.978]  - attr(*, "total_size")= num NA
[16:17:46.980]  - Getting '...' globals ... DONE
[16:17:46.981] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:46.981] List of 2
[16:17:46.981]  $ ...future.FUN:function (object, ...)  
[16:17:46.981]  $ ...          : list()
[16:17:46.981]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.981]  - attr(*, "where")=List of 2
[16:17:46.981]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:46.981]   ..$ ...          :<environment: 0x55b567dcb8e0> 
[16:17:46.981]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.981]  - attr(*, "resolved")= logi FALSE
[16:17:46.981]  - attr(*, "total_size")= num 1240
[16:17:46.983] Packages to be attached in all futures: [n=0] 
[16:17:46.983] getGlobalsAndPackagesXApply() ... DONE
[16:17:46.984] Number of futures (= number of chunks): 1
[16:17:46.984] Launching 1 futures (chunks) ...
[16:17:46.984] Chunk #1 of 1 ...
[16:17:46.984]  - Finding globals in 'X' for chunk #1 ...
[16:17:46.984] getGlobalsAndPackages() ...
[16:17:46.984] Searching for globals...
[16:17:46.985] 
[16:17:46.985] Searching for globals ... DONE
[16:17:46.985] - globals: [0] <none>
[16:17:46.985] getGlobalsAndPackages() ... DONE
[16:17:46.985]    + additional globals found: [n=0] 
[16:17:46.985]    + additional namespaces needed: [n=0] 
[16:17:46.985]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:46.985]  - seeds: <none>
[16:17:46.985]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.986] getGlobalsAndPackages() ...
[16:17:46.986] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.986] Resolving globals: FALSE
[16:17:46.986] Tweak future expression to call with '...' arguments ...
[16:17:46.986] {
[16:17:46.986]     do.call(function(...) {
[16:17:46.986]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.986]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:46.986]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.986]             on.exit(options(oopts), add = TRUE)
[16:17:46.986]         }
[16:17:46.986]         {
[16:17:46.986]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:46.986]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.986]                 ...future.FUN(...future.X_jj, ...)
[16:17:46.986]             })
[16:17:46.986]         }
[16:17:46.986]     }, args = future.call.arguments)
[16:17:46.986] }
[16:17:46.986] Tweak future expression to call with '...' arguments ... DONE
[16:17:46.987] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:46.987] 
[16:17:46.987] getGlobalsAndPackages() ... DONE
[16:17:46.987] run() for ‘Future’ ...
[16:17:46.987] - state: ‘created’
[16:17:46.987] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:46.991] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:46.991] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:46.991]   - Field: ‘label’
[16:17:46.991]   - Field: ‘local’
[16:17:46.992]   - Field: ‘owner’
[16:17:46.992]   - Field: ‘envir’
[16:17:46.992]   - Field: ‘packages’
[16:17:46.992]   - Field: ‘gc’
[16:17:46.992]   - Field: ‘conditions’
[16:17:46.992]   - Field: ‘expr’
[16:17:46.992]   - Field: ‘uuid’
[16:17:46.992]   - Field: ‘seed’
[16:17:46.992]   - Field: ‘version’
[16:17:46.992]   - Field: ‘result’
[16:17:46.992]   - Field: ‘asynchronous’
[16:17:46.993]   - Field: ‘calls’
[16:17:46.993]   - Field: ‘globals’
[16:17:46.993]   - Field: ‘stdout’
[16:17:46.993]   - Field: ‘earlySignal’
[16:17:46.993]   - Field: ‘lazy’
[16:17:46.993]   - Field: ‘state’
[16:17:46.993] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:46.993] - Launch lazy future ...
[16:17:46.993] Packages needed by the future expression (n = 0): <none>
[16:17:46.993] Packages needed by future strategies (n = 0): <none>
[16:17:46.994] {
[16:17:46.994]     {
[16:17:46.994]         {
[16:17:46.994]             ...future.startTime <- base::Sys.time()
[16:17:46.994]             {
[16:17:46.994]                 {
[16:17:46.994]                   {
[16:17:46.994]                     base::local({
[16:17:46.994]                       has_future <- base::requireNamespace("future", 
[16:17:46.994]                         quietly = TRUE)
[16:17:46.994]                       if (has_future) {
[16:17:46.994]                         ns <- base::getNamespace("future")
[16:17:46.994]                         version <- ns[[".package"]][["version"]]
[16:17:46.994]                         if (is.null(version)) 
[16:17:46.994]                           version <- utils::packageVersion("future")
[16:17:46.994]                       }
[16:17:46.994]                       else {
[16:17:46.994]                         version <- NULL
[16:17:46.994]                       }
[16:17:46.994]                       if (!has_future || version < "1.8.0") {
[16:17:46.994]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:46.994]                           "", base::R.version$version.string), 
[16:17:46.994]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:46.994]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:46.994]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:46.994]                             "release", "version")], collapse = " "), 
[16:17:46.994]                           hostname = base::Sys.info()[["nodename"]])
[16:17:46.994]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:46.994]                           info)
[16:17:46.994]                         info <- base::paste(info, collapse = "; ")
[16:17:46.994]                         if (!has_future) {
[16:17:46.994]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:46.994]                             info)
[16:17:46.994]                         }
[16:17:46.994]                         else {
[16:17:46.994]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:46.994]                             info, version)
[16:17:46.994]                         }
[16:17:46.994]                         base::stop(msg)
[16:17:46.994]                       }
[16:17:46.994]                     })
[16:17:46.994]                   }
[16:17:46.994]                   ...future.strategy.old <- future::plan("list")
[16:17:46.994]                   options(future.plan = NULL)
[16:17:46.994]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.994]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:46.994]                 }
[16:17:46.994]                 ...future.workdir <- getwd()
[16:17:46.994]             }
[16:17:46.994]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:46.994]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:46.994]         }
[16:17:46.994]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:46.994]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:46.994]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:46.994]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:46.994]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:46.994]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:46.994]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:46.994]             base::names(...future.oldOptions))
[16:17:46.994]     }
[16:17:46.994]     if (FALSE) {
[16:17:46.994]     }
[16:17:46.994]     else {
[16:17:46.994]         if (TRUE) {
[16:17:46.994]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:46.994]                 open = "w")
[16:17:46.994]         }
[16:17:46.994]         else {
[16:17:46.994]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:46.994]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:46.994]         }
[16:17:46.994]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:46.994]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:46.994]             base::sink(type = "output", split = FALSE)
[16:17:46.994]             base::close(...future.stdout)
[16:17:46.994]         }, add = TRUE)
[16:17:46.994]     }
[16:17:46.994]     ...future.frame <- base::sys.nframe()
[16:17:46.994]     ...future.conditions <- base::list()
[16:17:46.994]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:46.994]     if (FALSE) {
[16:17:46.994]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:46.994]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:46.994]     }
[16:17:46.994]     ...future.result <- base::tryCatch({
[16:17:46.994]         base::withCallingHandlers({
[16:17:46.994]             ...future.value <- base::withVisible(base::local({
[16:17:46.994]                 do.call(function(...) {
[16:17:46.994]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:46.994]                   if (!identical(...future.globals.maxSize.org, 
[16:17:46.994]                     ...future.globals.maxSize)) {
[16:17:46.994]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:46.994]                     on.exit(options(oopts), add = TRUE)
[16:17:46.994]                   }
[16:17:46.994]                   {
[16:17:46.994]                     lapply(seq_along(...future.elements_ii), 
[16:17:46.994]                       FUN = function(jj) {
[16:17:46.994]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:46.994]                         ...future.FUN(...future.X_jj, ...)
[16:17:46.994]                       })
[16:17:46.994]                   }
[16:17:46.994]                 }, args = future.call.arguments)
[16:17:46.994]             }))
[16:17:46.994]             future::FutureResult(value = ...future.value$value, 
[16:17:46.994]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.994]                   ...future.rng), globalenv = if (FALSE) 
[16:17:46.994]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:46.994]                     ...future.globalenv.names))
[16:17:46.994]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:46.994]         }, condition = base::local({
[16:17:46.994]             c <- base::c
[16:17:46.994]             inherits <- base::inherits
[16:17:46.994]             invokeRestart <- base::invokeRestart
[16:17:46.994]             length <- base::length
[16:17:46.994]             list <- base::list
[16:17:46.994]             seq.int <- base::seq.int
[16:17:46.994]             signalCondition <- base::signalCondition
[16:17:46.994]             sys.calls <- base::sys.calls
[16:17:46.994]             `[[` <- base::`[[`
[16:17:46.994]             `+` <- base::`+`
[16:17:46.994]             `<<-` <- base::`<<-`
[16:17:46.994]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:46.994]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:46.994]                   3L)]
[16:17:46.994]             }
[16:17:46.994]             function(cond) {
[16:17:46.994]                 is_error <- inherits(cond, "error")
[16:17:46.994]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:46.994]                   NULL)
[16:17:46.994]                 if (is_error) {
[16:17:46.994]                   sessionInformation <- function() {
[16:17:46.994]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:46.994]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:46.994]                       search = base::search(), system = base::Sys.info())
[16:17:46.994]                   }
[16:17:46.994]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.994]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:46.994]                     cond$call), session = sessionInformation(), 
[16:17:46.994]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:46.994]                   signalCondition(cond)
[16:17:46.994]                 }
[16:17:46.994]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:46.994]                 "immediateCondition"))) {
[16:17:46.994]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:46.994]                   ...future.conditions[[length(...future.conditions) + 
[16:17:46.994]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:46.994]                   if (TRUE && !signal) {
[16:17:46.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.994]                     {
[16:17:46.994]                       inherits <- base::inherits
[16:17:46.994]                       invokeRestart <- base::invokeRestart
[16:17:46.994]                       is.null <- base::is.null
[16:17:46.994]                       muffled <- FALSE
[16:17:46.994]                       if (inherits(cond, "message")) {
[16:17:46.994]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.994]                         if (muffled) 
[16:17:46.994]                           invokeRestart("muffleMessage")
[16:17:46.994]                       }
[16:17:46.994]                       else if (inherits(cond, "warning")) {
[16:17:46.994]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.994]                         if (muffled) 
[16:17:46.994]                           invokeRestart("muffleWarning")
[16:17:46.994]                       }
[16:17:46.994]                       else if (inherits(cond, "condition")) {
[16:17:46.994]                         if (!is.null(pattern)) {
[16:17:46.994]                           computeRestarts <- base::computeRestarts
[16:17:46.994]                           grepl <- base::grepl
[16:17:46.994]                           restarts <- computeRestarts(cond)
[16:17:46.994]                           for (restart in restarts) {
[16:17:46.994]                             name <- restart$name
[16:17:46.994]                             if (is.null(name)) 
[16:17:46.994]                               next
[16:17:46.994]                             if (!grepl(pattern, name)) 
[16:17:46.994]                               next
[16:17:46.994]                             invokeRestart(restart)
[16:17:46.994]                             muffled <- TRUE
[16:17:46.994]                             break
[16:17:46.994]                           }
[16:17:46.994]                         }
[16:17:46.994]                       }
[16:17:46.994]                       invisible(muffled)
[16:17:46.994]                     }
[16:17:46.994]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.994]                   }
[16:17:46.994]                 }
[16:17:46.994]                 else {
[16:17:46.994]                   if (TRUE) {
[16:17:46.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:46.994]                     {
[16:17:46.994]                       inherits <- base::inherits
[16:17:46.994]                       invokeRestart <- base::invokeRestart
[16:17:46.994]                       is.null <- base::is.null
[16:17:46.994]                       muffled <- FALSE
[16:17:46.994]                       if (inherits(cond, "message")) {
[16:17:46.994]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:46.994]                         if (muffled) 
[16:17:46.994]                           invokeRestart("muffleMessage")
[16:17:46.994]                       }
[16:17:46.994]                       else if (inherits(cond, "warning")) {
[16:17:46.994]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:46.994]                         if (muffled) 
[16:17:46.994]                           invokeRestart("muffleWarning")
[16:17:46.994]                       }
[16:17:46.994]                       else if (inherits(cond, "condition")) {
[16:17:46.994]                         if (!is.null(pattern)) {
[16:17:46.994]                           computeRestarts <- base::computeRestarts
[16:17:46.994]                           grepl <- base::grepl
[16:17:46.994]                           restarts <- computeRestarts(cond)
[16:17:46.994]                           for (restart in restarts) {
[16:17:46.994]                             name <- restart$name
[16:17:46.994]                             if (is.null(name)) 
[16:17:46.994]                               next
[16:17:46.994]                             if (!grepl(pattern, name)) 
[16:17:46.994]                               next
[16:17:46.994]                             invokeRestart(restart)
[16:17:46.994]                             muffled <- TRUE
[16:17:46.994]                             break
[16:17:46.994]                           }
[16:17:46.994]                         }
[16:17:46.994]                       }
[16:17:46.994]                       invisible(muffled)
[16:17:46.994]                     }
[16:17:46.994]                     muffleCondition(cond, pattern = "^muffle")
[16:17:46.994]                   }
[16:17:46.994]                 }
[16:17:46.994]             }
[16:17:46.994]         }))
[16:17:46.994]     }, error = function(ex) {
[16:17:46.994]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:46.994]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:46.994]                 ...future.rng), started = ...future.startTime, 
[16:17:46.994]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:46.994]             version = "1.8"), class = "FutureResult")
[16:17:46.994]     }, finally = {
[16:17:46.994]         if (!identical(...future.workdir, getwd())) 
[16:17:46.994]             setwd(...future.workdir)
[16:17:46.994]         {
[16:17:46.994]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:46.994]                 ...future.oldOptions$nwarnings <- NULL
[16:17:46.994]             }
[16:17:46.994]             base::options(...future.oldOptions)
[16:17:46.994]             if (.Platform$OS.type == "windows") {
[16:17:46.994]                 old_names <- names(...future.oldEnvVars)
[16:17:46.994]                 envs <- base::Sys.getenv()
[16:17:46.994]                 names <- names(envs)
[16:17:46.994]                 common <- intersect(names, old_names)
[16:17:46.994]                 added <- setdiff(names, old_names)
[16:17:46.994]                 removed <- setdiff(old_names, names)
[16:17:46.994]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:46.994]                   envs[common]]
[16:17:46.994]                 NAMES <- toupper(changed)
[16:17:46.994]                 args <- list()
[16:17:46.994]                 for (kk in seq_along(NAMES)) {
[16:17:46.994]                   name <- changed[[kk]]
[16:17:46.994]                   NAME <- NAMES[[kk]]
[16:17:46.994]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.994]                     next
[16:17:46.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.994]                 }
[16:17:46.994]                 NAMES <- toupper(added)
[16:17:46.994]                 for (kk in seq_along(NAMES)) {
[16:17:46.994]                   name <- added[[kk]]
[16:17:46.994]                   NAME <- NAMES[[kk]]
[16:17:46.994]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.994]                     next
[16:17:46.994]                   args[[name]] <- ""
[16:17:46.994]                 }
[16:17:46.994]                 NAMES <- toupper(removed)
[16:17:46.994]                 for (kk in seq_along(NAMES)) {
[16:17:46.994]                   name <- removed[[kk]]
[16:17:46.994]                   NAME <- NAMES[[kk]]
[16:17:46.994]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:46.994]                     next
[16:17:46.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:46.994]                 }
[16:17:46.994]                 if (length(args) > 0) 
[16:17:46.994]                   base::do.call(base::Sys.setenv, args = args)
[16:17:46.994]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:46.994]             }
[16:17:46.994]             else {
[16:17:46.994]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:46.994]             }
[16:17:46.994]             {
[16:17:46.994]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:46.994]                   0L) {
[16:17:46.994]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:46.994]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:46.994]                   base::options(opts)
[16:17:46.994]                 }
[16:17:46.994]                 {
[16:17:46.994]                   {
[16:17:46.994]                     NULL
[16:17:46.994]                     RNGkind("Mersenne-Twister")
[16:17:46.994]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:46.994]                       inherits = FALSE)
[16:17:46.994]                   }
[16:17:46.994]                   options(future.plan = NULL)
[16:17:46.994]                   if (is.na(NA_character_)) 
[16:17:46.994]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:46.994]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:46.994]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:46.994]                     .init = FALSE)
[16:17:46.994]                 }
[16:17:46.994]             }
[16:17:46.994]         }
[16:17:46.994]     })
[16:17:46.994]     if (TRUE) {
[16:17:46.994]         base::sink(type = "output", split = FALSE)
[16:17:46.994]         if (TRUE) {
[16:17:46.994]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:46.994]         }
[16:17:46.994]         else {
[16:17:46.994]             ...future.result["stdout"] <- base::list(NULL)
[16:17:46.994]         }
[16:17:46.994]         base::close(...future.stdout)
[16:17:46.994]         ...future.stdout <- NULL
[16:17:46.994]     }
[16:17:46.994]     ...future.result$conditions <- ...future.conditions
[16:17:46.994]     ...future.result$finished <- base::Sys.time()
[16:17:46.994]     ...future.result
[16:17:46.994] }
[16:17:46.996] assign_globals() ...
[16:17:46.996] List of 5
[16:17:46.996]  $ ...future.FUN            :function (object, ...)  
[16:17:46.996]  $ future.call.arguments    : list()
[16:17:46.996]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:46.996]  $ ...future.elements_ii    :List of 3
[16:17:46.996]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.996]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:17:46.996]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.996]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:46.996]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.996]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:17:46.996]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.996]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:17:46.996]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:46.996]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:17:46.996]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:46.996]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:17:46.996]  $ ...future.seeds_ii       : NULL
[16:17:46.996]  $ ...future.globals.maxSize: NULL
[16:17:46.996]  - attr(*, "where")=List of 5
[16:17:46.996]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:46.996]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:46.996]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:46.996]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:46.996]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:46.996]  - attr(*, "resolved")= logi FALSE
[16:17:46.996]  - attr(*, "total_size")= num 1240
[16:17:46.996]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:46.996]  - attr(*, "already-done")= logi TRUE
[16:17:47.006] - copied ‘...future.FUN’ to environment
[16:17:47.006] - copied ‘future.call.arguments’ to environment
[16:17:47.006] - copied ‘...future.elements_ii’ to environment
[16:17:47.006] - copied ‘...future.seeds_ii’ to environment
[16:17:47.006] - copied ‘...future.globals.maxSize’ to environment
[16:17:47.006] assign_globals() ... done
[16:17:47.007] plan(): Setting new future strategy stack:
[16:17:47.007] List of future strategies:
[16:17:47.007] 1. sequential:
[16:17:47.007]    - args: function (..., envir = parent.frame())
[16:17:47.007]    - tweaked: FALSE
[16:17:47.007]    - call: NULL
[16:17:47.007] plan(): nbrOfWorkers() = 1
[16:17:47.009] plan(): Setting new future strategy stack:
[16:17:47.009] List of future strategies:
[16:17:47.009] 1. multisession:
[16:17:47.009]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:17:47.009]    - tweaked: FALSE
[16:17:47.009]    - call: plan(strategy)
[16:17:47.013] plan(): nbrOfWorkers() = 1
[16:17:47.013] SequentialFuture started (and completed)
[16:17:47.013] - Launch lazy future ... done
[16:17:47.013] run() for ‘SequentialFuture’ ... done
[16:17:47.013] Created future:
[16:17:47.013] SequentialFuture:
[16:17:47.013] Label: ‘future_by-1’
[16:17:47.013] Expression:
[16:17:47.013] {
[16:17:47.013]     do.call(function(...) {
[16:17:47.013]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.013]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.013]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.013]             on.exit(options(oopts), add = TRUE)
[16:17:47.013]         }
[16:17:47.013]         {
[16:17:47.013]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.013]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.013]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.013]             })
[16:17:47.013]         }
[16:17:47.013]     }, args = future.call.arguments)
[16:17:47.013] }
[16:17:47.013] Lazy evaluation: FALSE
[16:17:47.013] Asynchronous evaluation: FALSE
[16:17:47.013] Local evaluation: TRUE
[16:17:47.013] Environment: 0x55b567d6e118
[16:17:47.013] Capture standard output: TRUE
[16:17:47.013] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:47.013] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:47.013] Packages: <none>
[16:17:47.013] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:47.013] Resolved: TRUE
[16:17:47.013] Value: 5.37 KiB of class ‘list’
[16:17:47.013] Early signaling: FALSE
[16:17:47.013] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:47.013] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:47.015] Chunk #1 of 1 ... DONE
[16:17:47.015] Launching 1 futures (chunks) ... DONE
[16:17:47.015] Resolving 1 futures (chunks) ...
[16:17:47.015] resolve() on list ...
[16:17:47.015]  recursive: 0
[16:17:47.015]  length: 1
[16:17:47.015] 
[16:17:47.015] resolved() for ‘SequentialFuture’ ...
[16:17:47.015] - state: ‘finished’
[16:17:47.015] - run: TRUE
[16:17:47.015] - result: ‘FutureResult’
[16:17:47.016] resolved() for ‘SequentialFuture’ ... done
[16:17:47.016] Future #1
[16:17:47.016] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:47.016] - nx: 1
[16:17:47.016] - relay: TRUE
[16:17:47.016] - stdout: TRUE
[16:17:47.016] - signal: TRUE
[16:17:47.016] - resignal: FALSE
[16:17:47.016] - force: TRUE
[16:17:47.016] - relayed: [n=1] FALSE
[16:17:47.017] - queued futures: [n=1] FALSE
[16:17:47.017]  - until=1
[16:17:47.017]  - relaying element #1
[16:17:47.017] - relayed: [n=1] TRUE
[16:17:47.017] - queued futures: [n=1] TRUE
[16:17:47.017] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:47.017]  length: 0 (resolved future 1)
[16:17:47.017] Relaying remaining futures
[16:17:47.017] signalConditionsASAP(NULL, pos=0) ...
[16:17:47.017] - nx: 1
[16:17:47.018] - relay: TRUE
[16:17:47.018] - stdout: TRUE
[16:17:47.018] - signal: TRUE
[16:17:47.018] - resignal: FALSE
[16:17:47.018] - force: TRUE
[16:17:47.018] - relayed: [n=1] TRUE
[16:17:47.018] - queued futures: [n=1] TRUE
 - flush all
[16:17:47.018] - relayed: [n=1] TRUE
[16:17:47.018] - queued futures: [n=1] TRUE
[16:17:47.018] signalConditionsASAP(NULL, pos=0) ... done
[16:17:47.018] resolve() on list ... DONE
[16:17:47.019]  - Number of value chunks collected: 1
[16:17:47.019] Resolving 1 futures (chunks) ... DONE
[16:17:47.019] Reducing values from 1 chunks ...
[16:17:47.019]  - Number of values collected after concatenation: 3
[16:17:47.019]  - Number of values expected: 3
[16:17:47.019] Reducing values from 1 chunks ... DONE
[16:17:47.019] future_lapply() ... DONE
[16:17:47.019] future_by_internal() ... DONE
[16:17:47.020] future_by_internal() ...
Testing with 1 cores ... DONE
Testing with 2 cores ...
- plan('sequential') ...
[16:17:47.021] plan(): Setting new future strategy stack:
[16:17:47.021] List of future strategies:
[16:17:47.021] 1. sequential:
[16:17:47.021]    - args: function (..., envir = parent.frame())
[16:17:47.021]    - tweaked: FALSE
[16:17:47.021]    - call: plan(strategy)
[16:17:47.021] plan(): nbrOfWorkers() = 1
[16:17:47.021] future_by_internal() ...
[16:17:47.022] future_lapply() ...
[16:17:47.022] Number of chunks: 1
[16:17:47.022] getGlobalsAndPackagesXApply() ...
[16:17:47.022]  - future.globals: TRUE
[16:17:47.022] getGlobalsAndPackages() ...
[16:17:47.023] Searching for globals...
[16:17:47.023] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:47.024] Searching for globals ... DONE
[16:17:47.024] Resolving globals: FALSE
[16:17:47.024] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:47.026] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:47.026] - globals: [1] ‘FUN’
[16:17:47.026] 
[16:17:47.026] getGlobalsAndPackages() ... DONE
[16:17:47.026]  - globals found/used: [n=1] ‘FUN’
[16:17:47.026]  - needed namespaces: [n=0] 
[16:17:47.026] Finding globals ... DONE
[16:17:47.026]  - use_args: TRUE
[16:17:47.026]  - Getting '...' globals ...
[16:17:47.027] resolve() on list ...
[16:17:47.027]  recursive: 0
[16:17:47.027]  length: 1
[16:17:47.027]  elements: ‘...’
[16:17:47.027]  length: 0 (resolved future 1)
[16:17:47.027] resolve() on list ... DONE
[16:17:47.027]    - '...' content: [n=0] 
[16:17:47.027] List of 1
[16:17:47.027]  $ ...: list()
[16:17:47.027]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.027]  - attr(*, "where")=List of 1
[16:17:47.027]   ..$ ...:<environment: 0x55b567f816a8> 
[16:17:47.027]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.027]  - attr(*, "resolved")= logi TRUE
[16:17:47.027]  - attr(*, "total_size")= num NA
[16:17:47.030]  - Getting '...' globals ... DONE
[16:17:47.030] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:47.030] List of 2
[16:17:47.030]  $ ...future.FUN:function (object, ...)  
[16:17:47.030]  $ ...          : list()
[16:17:47.030]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.030]  - attr(*, "where")=List of 2
[16:17:47.030]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:47.030]   ..$ ...          :<environment: 0x55b567f816a8> 
[16:17:47.030]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.030]  - attr(*, "resolved")= logi FALSE
[16:17:47.030]  - attr(*, "total_size")= num 1240
[16:17:47.033] Packages to be attached in all futures: [n=0] 
[16:17:47.033] getGlobalsAndPackagesXApply() ... DONE
[16:17:47.033] Number of futures (= number of chunks): 1
[16:17:47.033] Launching 1 futures (chunks) ...
[16:17:47.033] Chunk #1 of 1 ...
[16:17:47.033]  - Finding globals in 'X' for chunk #1 ...
[16:17:47.033] getGlobalsAndPackages() ...
[16:17:47.034] Searching for globals...
[16:17:47.034] 
[16:17:47.034] Searching for globals ... DONE
[16:17:47.034] - globals: [0] <none>
[16:17:47.034] getGlobalsAndPackages() ... DONE
[16:17:47.034]    + additional globals found: [n=0] 
[16:17:47.034]    + additional namespaces needed: [n=0] 
[16:17:47.035]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:47.035]  - seeds: <none>
[16:17:47.035]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.035] getGlobalsAndPackages() ...
[16:17:47.035] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.035] Resolving globals: FALSE
[16:17:47.035] Tweak future expression to call with '...' arguments ...
[16:17:47.035] {
[16:17:47.035]     do.call(function(...) {
[16:17:47.035]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.035]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.035]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.035]             on.exit(options(oopts), add = TRUE)
[16:17:47.035]         }
[16:17:47.035]         {
[16:17:47.035]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.035]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.035]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.035]             })
[16:17:47.035]         }
[16:17:47.035]     }, args = future.call.arguments)
[16:17:47.035] }
[16:17:47.036] Tweak future expression to call with '...' arguments ... DONE
[16:17:47.036] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.036] 
[16:17:47.036] getGlobalsAndPackages() ... DONE
[16:17:47.036] run() for ‘Future’ ...
[16:17:47.036] - state: ‘created’
[16:17:47.037] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:17:47.037] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:47.037] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:47.037]   - Field: ‘label’
[16:17:47.037]   - Field: ‘local’
[16:17:47.037]   - Field: ‘owner’
[16:17:47.037]   - Field: ‘envir’
[16:17:47.037]   - Field: ‘packages’
[16:17:47.038]   - Field: ‘gc’
[16:17:47.038]   - Field: ‘conditions’
[16:17:47.038]   - Field: ‘expr’
[16:17:47.038]   - Field: ‘uuid’
[16:17:47.038]   - Field: ‘seed’
[16:17:47.038]   - Field: ‘version’
[16:17:47.038]   - Field: ‘result’
[16:17:47.038]   - Field: ‘asynchronous’
[16:17:47.038]   - Field: ‘calls’
[16:17:47.038]   - Field: ‘globals’
[16:17:47.038]   - Field: ‘stdout’
[16:17:47.038]   - Field: ‘earlySignal’
[16:17:47.039]   - Field: ‘lazy’
[16:17:47.039]   - Field: ‘state’
[16:17:47.039] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:47.039] - Launch lazy future ...
[16:17:47.039] Packages needed by the future expression (n = 0): <none>
[16:17:47.039] Packages needed by future strategies (n = 0): <none>
[16:17:47.040] {
[16:17:47.040]     {
[16:17:47.040]         {
[16:17:47.040]             ...future.startTime <- base::Sys.time()
[16:17:47.040]             {
[16:17:47.040]                 {
[16:17:47.040]                   {
[16:17:47.040]                     base::local({
[16:17:47.040]                       has_future <- base::requireNamespace("future", 
[16:17:47.040]                         quietly = TRUE)
[16:17:47.040]                       if (has_future) {
[16:17:47.040]                         ns <- base::getNamespace("future")
[16:17:47.040]                         version <- ns[[".package"]][["version"]]
[16:17:47.040]                         if (is.null(version)) 
[16:17:47.040]                           version <- utils::packageVersion("future")
[16:17:47.040]                       }
[16:17:47.040]                       else {
[16:17:47.040]                         version <- NULL
[16:17:47.040]                       }
[16:17:47.040]                       if (!has_future || version < "1.8.0") {
[16:17:47.040]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:47.040]                           "", base::R.version$version.string), 
[16:17:47.040]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:47.040]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:47.040]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:47.040]                             "release", "version")], collapse = " "), 
[16:17:47.040]                           hostname = base::Sys.info()[["nodename"]])
[16:17:47.040]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:47.040]                           info)
[16:17:47.040]                         info <- base::paste(info, collapse = "; ")
[16:17:47.040]                         if (!has_future) {
[16:17:47.040]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:47.040]                             info)
[16:17:47.040]                         }
[16:17:47.040]                         else {
[16:17:47.040]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:47.040]                             info, version)
[16:17:47.040]                         }
[16:17:47.040]                         base::stop(msg)
[16:17:47.040]                       }
[16:17:47.040]                     })
[16:17:47.040]                   }
[16:17:47.040]                   ...future.strategy.old <- future::plan("list")
[16:17:47.040]                   options(future.plan = NULL)
[16:17:47.040]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.040]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:47.040]                 }
[16:17:47.040]                 ...future.workdir <- getwd()
[16:17:47.040]             }
[16:17:47.040]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:47.040]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:47.040]         }
[16:17:47.040]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:47.040]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:47.040]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:47.040]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:47.040]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:47.040]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:47.040]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:47.040]             base::names(...future.oldOptions))
[16:17:47.040]     }
[16:17:47.040]     if (FALSE) {
[16:17:47.040]     }
[16:17:47.040]     else {
[16:17:47.040]         if (TRUE) {
[16:17:47.040]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:47.040]                 open = "w")
[16:17:47.040]         }
[16:17:47.040]         else {
[16:17:47.040]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:47.040]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:47.040]         }
[16:17:47.040]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:47.040]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:47.040]             base::sink(type = "output", split = FALSE)
[16:17:47.040]             base::close(...future.stdout)
[16:17:47.040]         }, add = TRUE)
[16:17:47.040]     }
[16:17:47.040]     ...future.frame <- base::sys.nframe()
[16:17:47.040]     ...future.conditions <- base::list()
[16:17:47.040]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:47.040]     if (FALSE) {
[16:17:47.040]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:47.040]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:47.040]     }
[16:17:47.040]     ...future.result <- base::tryCatch({
[16:17:47.040]         base::withCallingHandlers({
[16:17:47.040]             ...future.value <- base::withVisible(base::local({
[16:17:47.040]                 do.call(function(...) {
[16:17:47.040]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.040]                   if (!identical(...future.globals.maxSize.org, 
[16:17:47.040]                     ...future.globals.maxSize)) {
[16:17:47.040]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.040]                     on.exit(options(oopts), add = TRUE)
[16:17:47.040]                   }
[16:17:47.040]                   {
[16:17:47.040]                     lapply(seq_along(...future.elements_ii), 
[16:17:47.040]                       FUN = function(jj) {
[16:17:47.040]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.040]                         ...future.FUN(...future.X_jj, ...)
[16:17:47.040]                       })
[16:17:47.040]                   }
[16:17:47.040]                 }, args = future.call.arguments)
[16:17:47.040]             }))
[16:17:47.040]             future::FutureResult(value = ...future.value$value, 
[16:17:47.040]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.040]                   ...future.rng), globalenv = if (FALSE) 
[16:17:47.040]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:47.040]                     ...future.globalenv.names))
[16:17:47.040]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:47.040]         }, condition = base::local({
[16:17:47.040]             c <- base::c
[16:17:47.040]             inherits <- base::inherits
[16:17:47.040]             invokeRestart <- base::invokeRestart
[16:17:47.040]             length <- base::length
[16:17:47.040]             list <- base::list
[16:17:47.040]             seq.int <- base::seq.int
[16:17:47.040]             signalCondition <- base::signalCondition
[16:17:47.040]             sys.calls <- base::sys.calls
[16:17:47.040]             `[[` <- base::`[[`
[16:17:47.040]             `+` <- base::`+`
[16:17:47.040]             `<<-` <- base::`<<-`
[16:17:47.040]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:47.040]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:47.040]                   3L)]
[16:17:47.040]             }
[16:17:47.040]             function(cond) {
[16:17:47.040]                 is_error <- inherits(cond, "error")
[16:17:47.040]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:47.040]                   NULL)
[16:17:47.040]                 if (is_error) {
[16:17:47.040]                   sessionInformation <- function() {
[16:17:47.040]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:47.040]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:47.040]                       search = base::search(), system = base::Sys.info())
[16:17:47.040]                   }
[16:17:47.040]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.040]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:47.040]                     cond$call), session = sessionInformation(), 
[16:17:47.040]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:47.040]                   signalCondition(cond)
[16:17:47.040]                 }
[16:17:47.040]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:47.040]                 "immediateCondition"))) {
[16:17:47.040]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:47.040]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.040]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:47.040]                   if (TRUE && !signal) {
[16:17:47.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.040]                     {
[16:17:47.040]                       inherits <- base::inherits
[16:17:47.040]                       invokeRestart <- base::invokeRestart
[16:17:47.040]                       is.null <- base::is.null
[16:17:47.040]                       muffled <- FALSE
[16:17:47.040]                       if (inherits(cond, "message")) {
[16:17:47.040]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.040]                         if (muffled) 
[16:17:47.040]                           invokeRestart("muffleMessage")
[16:17:47.040]                       }
[16:17:47.040]                       else if (inherits(cond, "warning")) {
[16:17:47.040]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.040]                         if (muffled) 
[16:17:47.040]                           invokeRestart("muffleWarning")
[16:17:47.040]                       }
[16:17:47.040]                       else if (inherits(cond, "condition")) {
[16:17:47.040]                         if (!is.null(pattern)) {
[16:17:47.040]                           computeRestarts <- base::computeRestarts
[16:17:47.040]                           grepl <- base::grepl
[16:17:47.040]                           restarts <- computeRestarts(cond)
[16:17:47.040]                           for (restart in restarts) {
[16:17:47.040]                             name <- restart$name
[16:17:47.040]                             if (is.null(name)) 
[16:17:47.040]                               next
[16:17:47.040]                             if (!grepl(pattern, name)) 
[16:17:47.040]                               next
[16:17:47.040]                             invokeRestart(restart)
[16:17:47.040]                             muffled <- TRUE
[16:17:47.040]                             break
[16:17:47.040]                           }
[16:17:47.040]                         }
[16:17:47.040]                       }
[16:17:47.040]                       invisible(muffled)
[16:17:47.040]                     }
[16:17:47.040]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.040]                   }
[16:17:47.040]                 }
[16:17:47.040]                 else {
[16:17:47.040]                   if (TRUE) {
[16:17:47.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.040]                     {
[16:17:47.040]                       inherits <- base::inherits
[16:17:47.040]                       invokeRestart <- base::invokeRestart
[16:17:47.040]                       is.null <- base::is.null
[16:17:47.040]                       muffled <- FALSE
[16:17:47.040]                       if (inherits(cond, "message")) {
[16:17:47.040]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.040]                         if (muffled) 
[16:17:47.040]                           invokeRestart("muffleMessage")
[16:17:47.040]                       }
[16:17:47.040]                       else if (inherits(cond, "warning")) {
[16:17:47.040]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.040]                         if (muffled) 
[16:17:47.040]                           invokeRestart("muffleWarning")
[16:17:47.040]                       }
[16:17:47.040]                       else if (inherits(cond, "condition")) {
[16:17:47.040]                         if (!is.null(pattern)) {
[16:17:47.040]                           computeRestarts <- base::computeRestarts
[16:17:47.040]                           grepl <- base::grepl
[16:17:47.040]                           restarts <- computeRestarts(cond)
[16:17:47.040]                           for (restart in restarts) {
[16:17:47.040]                             name <- restart$name
[16:17:47.040]                             if (is.null(name)) 
[16:17:47.040]                               next
[16:17:47.040]                             if (!grepl(pattern, name)) 
[16:17:47.040]                               next
[16:17:47.040]                             invokeRestart(restart)
[16:17:47.040]                             muffled <- TRUE
[16:17:47.040]                             break
[16:17:47.040]                           }
[16:17:47.040]                         }
[16:17:47.040]                       }
[16:17:47.040]                       invisible(muffled)
[16:17:47.040]                     }
[16:17:47.040]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.040]                   }
[16:17:47.040]                 }
[16:17:47.040]             }
[16:17:47.040]         }))
[16:17:47.040]     }, error = function(ex) {
[16:17:47.040]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:47.040]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.040]                 ...future.rng), started = ...future.startTime, 
[16:17:47.040]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:47.040]             version = "1.8"), class = "FutureResult")
[16:17:47.040]     }, finally = {
[16:17:47.040]         if (!identical(...future.workdir, getwd())) 
[16:17:47.040]             setwd(...future.workdir)
[16:17:47.040]         {
[16:17:47.040]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:47.040]                 ...future.oldOptions$nwarnings <- NULL
[16:17:47.040]             }
[16:17:47.040]             base::options(...future.oldOptions)
[16:17:47.040]             if (.Platform$OS.type == "windows") {
[16:17:47.040]                 old_names <- names(...future.oldEnvVars)
[16:17:47.040]                 envs <- base::Sys.getenv()
[16:17:47.040]                 names <- names(envs)
[16:17:47.040]                 common <- intersect(names, old_names)
[16:17:47.040]                 added <- setdiff(names, old_names)
[16:17:47.040]                 removed <- setdiff(old_names, names)
[16:17:47.040]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:47.040]                   envs[common]]
[16:17:47.040]                 NAMES <- toupper(changed)
[16:17:47.040]                 args <- list()
[16:17:47.040]                 for (kk in seq_along(NAMES)) {
[16:17:47.040]                   name <- changed[[kk]]
[16:17:47.040]                   NAME <- NAMES[[kk]]
[16:17:47.040]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.040]                     next
[16:17:47.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.040]                 }
[16:17:47.040]                 NAMES <- toupper(added)
[16:17:47.040]                 for (kk in seq_along(NAMES)) {
[16:17:47.040]                   name <- added[[kk]]
[16:17:47.040]                   NAME <- NAMES[[kk]]
[16:17:47.040]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.040]                     next
[16:17:47.040]                   args[[name]] <- ""
[16:17:47.040]                 }
[16:17:47.040]                 NAMES <- toupper(removed)
[16:17:47.040]                 for (kk in seq_along(NAMES)) {
[16:17:47.040]                   name <- removed[[kk]]
[16:17:47.040]                   NAME <- NAMES[[kk]]
[16:17:47.040]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.040]                     next
[16:17:47.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.040]                 }
[16:17:47.040]                 if (length(args) > 0) 
[16:17:47.040]                   base::do.call(base::Sys.setenv, args = args)
[16:17:47.040]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:47.040]             }
[16:17:47.040]             else {
[16:17:47.040]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:47.040]             }
[16:17:47.040]             {
[16:17:47.040]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:47.040]                   0L) {
[16:17:47.040]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:47.040]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:47.040]                   base::options(opts)
[16:17:47.040]                 }
[16:17:47.040]                 {
[16:17:47.040]                   {
[16:17:47.040]                     NULL
[16:17:47.040]                     RNGkind("Mersenne-Twister")
[16:17:47.040]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:47.040]                       inherits = FALSE)
[16:17:47.040]                   }
[16:17:47.040]                   options(future.plan = NULL)
[16:17:47.040]                   if (is.na(NA_character_)) 
[16:17:47.040]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.040]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:47.040]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:47.040]                     .init = FALSE)
[16:17:47.040]                 }
[16:17:47.040]             }
[16:17:47.040]         }
[16:17:47.040]     })
[16:17:47.040]     if (TRUE) {
[16:17:47.040]         base::sink(type = "output", split = FALSE)
[16:17:47.040]         if (TRUE) {
[16:17:47.040]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:47.040]         }
[16:17:47.040]         else {
[16:17:47.040]             ...future.result["stdout"] <- base::list(NULL)
[16:17:47.040]         }
[16:17:47.040]         base::close(...future.stdout)
[16:17:47.040]         ...future.stdout <- NULL
[16:17:47.040]     }
[16:17:47.040]     ...future.result$conditions <- ...future.conditions
[16:17:47.040]     ...future.result$finished <- base::Sys.time()
[16:17:47.040]     ...future.result
[16:17:47.040] }
[16:17:47.041] assign_globals() ...
[16:17:47.041] List of 5
[16:17:47.041]  $ ...future.FUN            :function (object, ...)  
[16:17:47.041]  $ future.call.arguments    : list()
[16:17:47.041]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.041]  $ ...future.elements_ii    :List of 3
[16:17:47.041]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:17:47.041]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:17:47.041]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.041]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:17:47.041]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:17:47.041]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.041]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:17:47.041]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:17:47.041]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.041]  $ ...future.seeds_ii       : NULL
[16:17:47.041]  $ ...future.globals.maxSize: NULL
[16:17:47.041]  - attr(*, "where")=List of 5
[16:17:47.041]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:47.041]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:47.041]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:47.041]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:47.041]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:47.041]  - attr(*, "resolved")= logi FALSE
[16:17:47.041]  - attr(*, "total_size")= num 1240
[16:17:47.041]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.041]  - attr(*, "already-done")= logi TRUE
[16:17:47.050] - copied ‘...future.FUN’ to environment
[16:17:47.050] - copied ‘future.call.arguments’ to environment
[16:17:47.050] - copied ‘...future.elements_ii’ to environment
[16:17:47.050] - copied ‘...future.seeds_ii’ to environment
[16:17:47.050] - copied ‘...future.globals.maxSize’ to environment
[16:17:47.050] assign_globals() ... done
[16:17:47.050] plan(): Setting new future strategy stack:
[16:17:47.050] List of future strategies:
[16:17:47.050] 1. sequential:
[16:17:47.050]    - args: function (..., envir = parent.frame())
[16:17:47.050]    - tweaked: FALSE
[16:17:47.050]    - call: NULL
[16:17:47.051] plan(): nbrOfWorkers() = 1
[16:17:47.053] plan(): Setting new future strategy stack:
[16:17:47.053] List of future strategies:
[16:17:47.053] 1. sequential:
[16:17:47.053]    - args: function (..., envir = parent.frame())
[16:17:47.053]    - tweaked: FALSE
[16:17:47.053]    - call: plan(strategy)
[16:17:47.053] plan(): nbrOfWorkers() = 1
[16:17:47.053] SequentialFuture started (and completed)
[16:17:47.053] - Launch lazy future ... done
[16:17:47.053] run() for ‘SequentialFuture’ ... done
[16:17:47.054] Created future:
[16:17:47.054] SequentialFuture:
[16:17:47.054] Label: ‘future_by-1’
[16:17:47.054] Expression:
[16:17:47.054] {
[16:17:47.054]     do.call(function(...) {
[16:17:47.054]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.054]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.054]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.054]             on.exit(options(oopts), add = TRUE)
[16:17:47.054]         }
[16:17:47.054]         {
[16:17:47.054]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.054]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.054]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.054]             })
[16:17:47.054]         }
[16:17:47.054]     }, args = future.call.arguments)
[16:17:47.054] }
[16:17:47.054] Lazy evaluation: FALSE
[16:17:47.054] Asynchronous evaluation: FALSE
[16:17:47.054] Local evaluation: TRUE
[16:17:47.054] Environment: R_GlobalEnv
[16:17:47.054] Capture standard output: TRUE
[16:17:47.054] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:47.054] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:47.054] Packages: <none>
[16:17:47.054] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:47.054] Resolved: TRUE
[16:17:47.054] Value: 4.62 KiB of class ‘list’
[16:17:47.054] Early signaling: FALSE
[16:17:47.054] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:47.054] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:47.055] Chunk #1 of 1 ... DONE
[16:17:47.055] Launching 1 futures (chunks) ... DONE
[16:17:47.055] Resolving 1 futures (chunks) ...
[16:17:47.055] resolve() on list ...
[16:17:47.055]  recursive: 0
[16:17:47.055]  length: 1
[16:17:47.055] 
[16:17:47.055] resolved() for ‘SequentialFuture’ ...
[16:17:47.055] - state: ‘finished’
[16:17:47.056] - run: TRUE
[16:17:47.056] - result: ‘FutureResult’
[16:17:47.056] resolved() for ‘SequentialFuture’ ... done
[16:17:47.056] Future #1
[16:17:47.056] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:47.056] - nx: 1
[16:17:47.056] - relay: TRUE
[16:17:47.056] - stdout: TRUE
[16:17:47.056] - signal: TRUE
[16:17:47.056] - resignal: FALSE
[16:17:47.056] - force: TRUE
[16:17:47.057] - relayed: [n=1] FALSE
[16:17:47.057] - queued futures: [n=1] FALSE
[16:17:47.057]  - until=1
[16:17:47.057]  - relaying element #1
[16:17:47.057] - relayed: [n=1] TRUE
[16:17:47.057] - queued futures: [n=1] TRUE
[16:17:47.057] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:47.057]  length: 0 (resolved future 1)
[16:17:47.057] Relaying remaining futures
[16:17:47.057] signalConditionsASAP(NULL, pos=0) ...
[16:17:47.058] - nx: 1
[16:17:47.058] - relay: TRUE
[16:17:47.058] - stdout: TRUE
[16:17:47.058] - signal: TRUE
[16:17:47.058] - resignal: FALSE
[16:17:47.058] - force: TRUE
[16:17:47.058] - relayed: [n=1] TRUE
[16:17:47.058] - queued futures: [n=1] TRUE
 - flush all
[16:17:47.058] - relayed: [n=1] TRUE
[16:17:47.058] - queued futures: [n=1] TRUE
[16:17:47.058] signalConditionsASAP(NULL, pos=0) ... done
[16:17:47.058] resolve() on list ... DONE
[16:17:47.059]  - Number of value chunks collected: 1
[16:17:47.059] Resolving 1 futures (chunks) ... DONE
[16:17:47.059] Reducing values from 1 chunks ...
[16:17:47.059]  - Number of values collected after concatenation: 3
[16:17:47.059]  - Number of values expected: 3
[16:17:47.059] Reducing values from 1 chunks ... DONE
[16:17:47.059] future_lapply() ... DONE
[16:17:47.059] future_by_internal() ... DONE
[16:17:47.059] future_by_internal() ...
[16:17:47.060] future_lapply() ...
[16:17:47.060] Number of chunks: 1
[16:17:47.060] getGlobalsAndPackagesXApply() ...
[16:17:47.060]  - future.globals: TRUE
[16:17:47.060] getGlobalsAndPackages() ...
[16:17:47.061] Searching for globals...
[16:17:47.061] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:47.062] Searching for globals ... DONE
[16:17:47.062] Resolving globals: FALSE
[16:17:47.062] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:47.062] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:47.062] - globals: [1] ‘FUN’
[16:17:47.063] 
[16:17:47.063] getGlobalsAndPackages() ... DONE
[16:17:47.063]  - globals found/used: [n=1] ‘FUN’
[16:17:47.063]  - needed namespaces: [n=0] 
[16:17:47.063] Finding globals ... DONE
[16:17:47.063]  - use_args: TRUE
[16:17:47.063]  - Getting '...' globals ...
[16:17:47.063] resolve() on list ...
[16:17:47.063]  recursive: 0
[16:17:47.064]  length: 1
[16:17:47.064]  elements: ‘...’
[16:17:47.064]  length: 0 (resolved future 1)
[16:17:47.064] resolve() on list ... DONE
[16:17:47.064]    - '...' content: [n=1] ‘digits’
[16:17:47.064] List of 1
[16:17:47.064]  $ ...:List of 1
[16:17:47.064]   ..$ digits: int 2
[16:17:47.064]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.064]  - attr(*, "where")=List of 1
[16:17:47.064]   ..$ ...:<environment: 0x55b567d57f58> 
[16:17:47.064]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.064]  - attr(*, "resolved")= logi TRUE
[16:17:47.064]  - attr(*, "total_size")= num NA
[16:17:47.068]  - Getting '...' globals ... DONE
[16:17:47.068] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:47.068] List of 2
[16:17:47.068]  $ ...future.FUN:function (object, ...)  
[16:17:47.068]  $ ...          :List of 1
[16:17:47.068]   ..$ digits: int 2
[16:17:47.068]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.068]  - attr(*, "where")=List of 2
[16:17:47.068]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:47.068]   ..$ ...          :<environment: 0x55b567d57f58> 
[16:17:47.068]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.068]  - attr(*, "resolved")= logi FALSE
[16:17:47.068]  - attr(*, "total_size")= num 1296
[16:17:47.071] Packages to be attached in all futures: [n=0] 
[16:17:47.071] getGlobalsAndPackagesXApply() ... DONE
[16:17:47.072] Number of futures (= number of chunks): 1
[16:17:47.072] Launching 1 futures (chunks) ...
[16:17:47.072] Chunk #1 of 1 ...
[16:17:47.072]  - Finding globals in 'X' for chunk #1 ...
[16:17:47.072] getGlobalsAndPackages() ...
[16:17:47.072] Searching for globals...
[16:17:47.072] 
[16:17:47.072] Searching for globals ... DONE
[16:17:47.073] - globals: [0] <none>
[16:17:47.073] getGlobalsAndPackages() ... DONE
[16:17:47.073]    + additional globals found: [n=0] 
[16:17:47.073]    + additional namespaces needed: [n=0] 
[16:17:47.073]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:47.073]  - seeds: <none>
[16:17:47.073]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.073] getGlobalsAndPackages() ...
[16:17:47.073] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.073] Resolving globals: FALSE
[16:17:47.073] Tweak future expression to call with '...' arguments ...
[16:17:47.074] {
[16:17:47.074]     do.call(function(...) {
[16:17:47.074]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.074]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.074]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.074]             on.exit(options(oopts), add = TRUE)
[16:17:47.074]         }
[16:17:47.074]         {
[16:17:47.074]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.074]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.074]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.074]             })
[16:17:47.074]         }
[16:17:47.074]     }, args = future.call.arguments)
[16:17:47.074] }
[16:17:47.074] Tweak future expression to call with '...' arguments ... DONE
[16:17:47.074] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.074] 
[16:17:47.074] getGlobalsAndPackages() ... DONE
[16:17:47.075] run() for ‘Future’ ...
[16:17:47.075] - state: ‘created’
[16:17:47.075] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:17:47.075] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:47.075] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:47.075]   - Field: ‘label’
[16:17:47.075]   - Field: ‘local’
[16:17:47.075]   - Field: ‘owner’
[16:17:47.076]   - Field: ‘envir’
[16:17:47.076]   - Field: ‘packages’
[16:17:47.076]   - Field: ‘gc’
[16:17:47.076]   - Field: ‘conditions’
[16:17:47.076]   - Field: ‘expr’
[16:17:47.076]   - Field: ‘uuid’
[16:17:47.076]   - Field: ‘seed’
[16:17:47.076]   - Field: ‘version’
[16:17:47.076]   - Field: ‘result’
[16:17:47.076]   - Field: ‘asynchronous’
[16:17:47.076]   - Field: ‘calls’
[16:17:47.077]   - Field: ‘globals’
[16:17:47.077]   - Field: ‘stdout’
[16:17:47.077]   - Field: ‘earlySignal’
[16:17:47.077]   - Field: ‘lazy’
[16:17:47.077]   - Field: ‘state’
[16:17:47.077] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:47.077] - Launch lazy future ...
[16:17:47.077] Packages needed by the future expression (n = 0): <none>
[16:17:47.077] Packages needed by future strategies (n = 0): <none>
[16:17:47.078] {
[16:17:47.078]     {
[16:17:47.078]         {
[16:17:47.078]             ...future.startTime <- base::Sys.time()
[16:17:47.078]             {
[16:17:47.078]                 {
[16:17:47.078]                   {
[16:17:47.078]                     base::local({
[16:17:47.078]                       has_future <- base::requireNamespace("future", 
[16:17:47.078]                         quietly = TRUE)
[16:17:47.078]                       if (has_future) {
[16:17:47.078]                         ns <- base::getNamespace("future")
[16:17:47.078]                         version <- ns[[".package"]][["version"]]
[16:17:47.078]                         if (is.null(version)) 
[16:17:47.078]                           version <- utils::packageVersion("future")
[16:17:47.078]                       }
[16:17:47.078]                       else {
[16:17:47.078]                         version <- NULL
[16:17:47.078]                       }
[16:17:47.078]                       if (!has_future || version < "1.8.0") {
[16:17:47.078]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:47.078]                           "", base::R.version$version.string), 
[16:17:47.078]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:47.078]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:47.078]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:47.078]                             "release", "version")], collapse = " "), 
[16:17:47.078]                           hostname = base::Sys.info()[["nodename"]])
[16:17:47.078]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:47.078]                           info)
[16:17:47.078]                         info <- base::paste(info, collapse = "; ")
[16:17:47.078]                         if (!has_future) {
[16:17:47.078]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:47.078]                             info)
[16:17:47.078]                         }
[16:17:47.078]                         else {
[16:17:47.078]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:47.078]                             info, version)
[16:17:47.078]                         }
[16:17:47.078]                         base::stop(msg)
[16:17:47.078]                       }
[16:17:47.078]                     })
[16:17:47.078]                   }
[16:17:47.078]                   ...future.strategy.old <- future::plan("list")
[16:17:47.078]                   options(future.plan = NULL)
[16:17:47.078]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.078]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:47.078]                 }
[16:17:47.078]                 ...future.workdir <- getwd()
[16:17:47.078]             }
[16:17:47.078]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:47.078]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:47.078]         }
[16:17:47.078]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:47.078]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:47.078]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:47.078]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:47.078]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:47.078]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:47.078]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:47.078]             base::names(...future.oldOptions))
[16:17:47.078]     }
[16:17:47.078]     if (FALSE) {
[16:17:47.078]     }
[16:17:47.078]     else {
[16:17:47.078]         if (TRUE) {
[16:17:47.078]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:47.078]                 open = "w")
[16:17:47.078]         }
[16:17:47.078]         else {
[16:17:47.078]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:47.078]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:47.078]         }
[16:17:47.078]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:47.078]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:47.078]             base::sink(type = "output", split = FALSE)
[16:17:47.078]             base::close(...future.stdout)
[16:17:47.078]         }, add = TRUE)
[16:17:47.078]     }
[16:17:47.078]     ...future.frame <- base::sys.nframe()
[16:17:47.078]     ...future.conditions <- base::list()
[16:17:47.078]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:47.078]     if (FALSE) {
[16:17:47.078]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:47.078]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:47.078]     }
[16:17:47.078]     ...future.result <- base::tryCatch({
[16:17:47.078]         base::withCallingHandlers({
[16:17:47.078]             ...future.value <- base::withVisible(base::local({
[16:17:47.078]                 do.call(function(...) {
[16:17:47.078]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.078]                   if (!identical(...future.globals.maxSize.org, 
[16:17:47.078]                     ...future.globals.maxSize)) {
[16:17:47.078]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.078]                     on.exit(options(oopts), add = TRUE)
[16:17:47.078]                   }
[16:17:47.078]                   {
[16:17:47.078]                     lapply(seq_along(...future.elements_ii), 
[16:17:47.078]                       FUN = function(jj) {
[16:17:47.078]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.078]                         ...future.FUN(...future.X_jj, ...)
[16:17:47.078]                       })
[16:17:47.078]                   }
[16:17:47.078]                 }, args = future.call.arguments)
[16:17:47.078]             }))
[16:17:47.078]             future::FutureResult(value = ...future.value$value, 
[16:17:47.078]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.078]                   ...future.rng), globalenv = if (FALSE) 
[16:17:47.078]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:47.078]                     ...future.globalenv.names))
[16:17:47.078]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:47.078]         }, condition = base::local({
[16:17:47.078]             c <- base::c
[16:17:47.078]             inherits <- base::inherits
[16:17:47.078]             invokeRestart <- base::invokeRestart
[16:17:47.078]             length <- base::length
[16:17:47.078]             list <- base::list
[16:17:47.078]             seq.int <- base::seq.int
[16:17:47.078]             signalCondition <- base::signalCondition
[16:17:47.078]             sys.calls <- base::sys.calls
[16:17:47.078]             `[[` <- base::`[[`
[16:17:47.078]             `+` <- base::`+`
[16:17:47.078]             `<<-` <- base::`<<-`
[16:17:47.078]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:47.078]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:47.078]                   3L)]
[16:17:47.078]             }
[16:17:47.078]             function(cond) {
[16:17:47.078]                 is_error <- inherits(cond, "error")
[16:17:47.078]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:47.078]                   NULL)
[16:17:47.078]                 if (is_error) {
[16:17:47.078]                   sessionInformation <- function() {
[16:17:47.078]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:47.078]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:47.078]                       search = base::search(), system = base::Sys.info())
[16:17:47.078]                   }
[16:17:47.078]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.078]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:47.078]                     cond$call), session = sessionInformation(), 
[16:17:47.078]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:47.078]                   signalCondition(cond)
[16:17:47.078]                 }
[16:17:47.078]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:47.078]                 "immediateCondition"))) {
[16:17:47.078]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:47.078]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.078]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:47.078]                   if (TRUE && !signal) {
[16:17:47.078]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.078]                     {
[16:17:47.078]                       inherits <- base::inherits
[16:17:47.078]                       invokeRestart <- base::invokeRestart
[16:17:47.078]                       is.null <- base::is.null
[16:17:47.078]                       muffled <- FALSE
[16:17:47.078]                       if (inherits(cond, "message")) {
[16:17:47.078]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.078]                         if (muffled) 
[16:17:47.078]                           invokeRestart("muffleMessage")
[16:17:47.078]                       }
[16:17:47.078]                       else if (inherits(cond, "warning")) {
[16:17:47.078]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.078]                         if (muffled) 
[16:17:47.078]                           invokeRestart("muffleWarning")
[16:17:47.078]                       }
[16:17:47.078]                       else if (inherits(cond, "condition")) {
[16:17:47.078]                         if (!is.null(pattern)) {
[16:17:47.078]                           computeRestarts <- base::computeRestarts
[16:17:47.078]                           grepl <- base::grepl
[16:17:47.078]                           restarts <- computeRestarts(cond)
[16:17:47.078]                           for (restart in restarts) {
[16:17:47.078]                             name <- restart$name
[16:17:47.078]                             if (is.null(name)) 
[16:17:47.078]                               next
[16:17:47.078]                             if (!grepl(pattern, name)) 
[16:17:47.078]                               next
[16:17:47.078]                             invokeRestart(restart)
[16:17:47.078]                             muffled <- TRUE
[16:17:47.078]                             break
[16:17:47.078]                           }
[16:17:47.078]                         }
[16:17:47.078]                       }
[16:17:47.078]                       invisible(muffled)
[16:17:47.078]                     }
[16:17:47.078]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.078]                   }
[16:17:47.078]                 }
[16:17:47.078]                 else {
[16:17:47.078]                   if (TRUE) {
[16:17:47.078]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.078]                     {
[16:17:47.078]                       inherits <- base::inherits
[16:17:47.078]                       invokeRestart <- base::invokeRestart
[16:17:47.078]                       is.null <- base::is.null
[16:17:47.078]                       muffled <- FALSE
[16:17:47.078]                       if (inherits(cond, "message")) {
[16:17:47.078]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.078]                         if (muffled) 
[16:17:47.078]                           invokeRestart("muffleMessage")
[16:17:47.078]                       }
[16:17:47.078]                       else if (inherits(cond, "warning")) {
[16:17:47.078]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.078]                         if (muffled) 
[16:17:47.078]                           invokeRestart("muffleWarning")
[16:17:47.078]                       }
[16:17:47.078]                       else if (inherits(cond, "condition")) {
[16:17:47.078]                         if (!is.null(pattern)) {
[16:17:47.078]                           computeRestarts <- base::computeRestarts
[16:17:47.078]                           grepl <- base::grepl
[16:17:47.078]                           restarts <- computeRestarts(cond)
[16:17:47.078]                           for (restart in restarts) {
[16:17:47.078]                             name <- restart$name
[16:17:47.078]                             if (is.null(name)) 
[16:17:47.078]                               next
[16:17:47.078]                             if (!grepl(pattern, name)) 
[16:17:47.078]                               next
[16:17:47.078]                             invokeRestart(restart)
[16:17:47.078]                             muffled <- TRUE
[16:17:47.078]                             break
[16:17:47.078]                           }
[16:17:47.078]                         }
[16:17:47.078]                       }
[16:17:47.078]                       invisible(muffled)
[16:17:47.078]                     }
[16:17:47.078]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.078]                   }
[16:17:47.078]                 }
[16:17:47.078]             }
[16:17:47.078]         }))
[16:17:47.078]     }, error = function(ex) {
[16:17:47.078]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:47.078]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.078]                 ...future.rng), started = ...future.startTime, 
[16:17:47.078]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:47.078]             version = "1.8"), class = "FutureResult")
[16:17:47.078]     }, finally = {
[16:17:47.078]         if (!identical(...future.workdir, getwd())) 
[16:17:47.078]             setwd(...future.workdir)
[16:17:47.078]         {
[16:17:47.078]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:47.078]                 ...future.oldOptions$nwarnings <- NULL
[16:17:47.078]             }
[16:17:47.078]             base::options(...future.oldOptions)
[16:17:47.078]             if (.Platform$OS.type == "windows") {
[16:17:47.078]                 old_names <- names(...future.oldEnvVars)
[16:17:47.078]                 envs <- base::Sys.getenv()
[16:17:47.078]                 names <- names(envs)
[16:17:47.078]                 common <- intersect(names, old_names)
[16:17:47.078]                 added <- setdiff(names, old_names)
[16:17:47.078]                 removed <- setdiff(old_names, names)
[16:17:47.078]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:47.078]                   envs[common]]
[16:17:47.078]                 NAMES <- toupper(changed)
[16:17:47.078]                 args <- list()
[16:17:47.078]                 for (kk in seq_along(NAMES)) {
[16:17:47.078]                   name <- changed[[kk]]
[16:17:47.078]                   NAME <- NAMES[[kk]]
[16:17:47.078]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.078]                     next
[16:17:47.078]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.078]                 }
[16:17:47.078]                 NAMES <- toupper(added)
[16:17:47.078]                 for (kk in seq_along(NAMES)) {
[16:17:47.078]                   name <- added[[kk]]
[16:17:47.078]                   NAME <- NAMES[[kk]]
[16:17:47.078]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.078]                     next
[16:17:47.078]                   args[[name]] <- ""
[16:17:47.078]                 }
[16:17:47.078]                 NAMES <- toupper(removed)
[16:17:47.078]                 for (kk in seq_along(NAMES)) {
[16:17:47.078]                   name <- removed[[kk]]
[16:17:47.078]                   NAME <- NAMES[[kk]]
[16:17:47.078]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.078]                     next
[16:17:47.078]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.078]                 }
[16:17:47.078]                 if (length(args) > 0) 
[16:17:47.078]                   base::do.call(base::Sys.setenv, args = args)
[16:17:47.078]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:47.078]             }
[16:17:47.078]             else {
[16:17:47.078]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:47.078]             }
[16:17:47.078]             {
[16:17:47.078]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:47.078]                   0L) {
[16:17:47.078]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:47.078]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:47.078]                   base::options(opts)
[16:17:47.078]                 }
[16:17:47.078]                 {
[16:17:47.078]                   {
[16:17:47.078]                     NULL
[16:17:47.078]                     RNGkind("Mersenne-Twister")
[16:17:47.078]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:47.078]                       inherits = FALSE)
[16:17:47.078]                   }
[16:17:47.078]                   options(future.plan = NULL)
[16:17:47.078]                   if (is.na(NA_character_)) 
[16:17:47.078]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.078]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:47.078]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:47.078]                     .init = FALSE)
[16:17:47.078]                 }
[16:17:47.078]             }
[16:17:47.078]         }
[16:17:47.078]     })
[16:17:47.078]     if (TRUE) {
[16:17:47.078]         base::sink(type = "output", split = FALSE)
[16:17:47.078]         if (TRUE) {
[16:17:47.078]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:47.078]         }
[16:17:47.078]         else {
[16:17:47.078]             ...future.result["stdout"] <- base::list(NULL)
[16:17:47.078]         }
[16:17:47.078]         base::close(...future.stdout)
[16:17:47.078]         ...future.stdout <- NULL
[16:17:47.078]     }
[16:17:47.078]     ...future.result$conditions <- ...future.conditions
[16:17:47.078]     ...future.result$finished <- base::Sys.time()
[16:17:47.078]     ...future.result
[16:17:47.078] }
[16:17:47.079] assign_globals() ...
[16:17:47.079] List of 5
[16:17:47.079]  $ ...future.FUN            :function (object, ...)  
[16:17:47.079]  $ future.call.arguments    :List of 1
[16:17:47.079]   ..$ digits: int 2
[16:17:47.079]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.079]  $ ...future.elements_ii    :List of 6
[16:17:47.079]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[16:17:47.079]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[16:17:47.079]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[16:17:47.079]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[16:17:47.079]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[16:17:47.079]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[16:17:47.079]  $ ...future.seeds_ii       : NULL
[16:17:47.079]  $ ...future.globals.maxSize: NULL
[16:17:47.079]  - attr(*, "where")=List of 5
[16:17:47.079]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:47.079]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:47.079]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:47.079]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:47.079]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:47.079]  - attr(*, "resolved")= logi FALSE
[16:17:47.079]  - attr(*, "total_size")= num 1296
[16:17:47.079]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.079]  - attr(*, "already-done")= logi TRUE
[16:17:47.087] - copied ‘...future.FUN’ to environment
[16:17:47.087] - copied ‘future.call.arguments’ to environment
[16:17:47.087] - copied ‘...future.elements_ii’ to environment
[16:17:47.087] - copied ‘...future.seeds_ii’ to environment
[16:17:47.087] - copied ‘...future.globals.maxSize’ to environment
[16:17:47.087] assign_globals() ... done
[16:17:47.087] plan(): Setting new future strategy stack:
[16:17:47.088] List of future strategies:
[16:17:47.088] 1. sequential:
[16:17:47.088]    - args: function (..., envir = parent.frame())
[16:17:47.088]    - tweaked: FALSE
[16:17:47.088]    - call: NULL
[16:17:47.088] plan(): nbrOfWorkers() = 1
[16:17:47.089] plan(): Setting new future strategy stack:
[16:17:47.089] List of future strategies:
[16:17:47.089] 1. sequential:
[16:17:47.089]    - args: function (..., envir = parent.frame())
[16:17:47.089]    - tweaked: FALSE
[16:17:47.089]    - call: plan(strategy)
[16:17:47.090] plan(): nbrOfWorkers() = 1
[16:17:47.090] SequentialFuture started (and completed)
[16:17:47.090] - Launch lazy future ... done
[16:17:47.090] run() for ‘SequentialFuture’ ... done
[16:17:47.090] Created future:
[16:17:47.090] SequentialFuture:
[16:17:47.090] Label: ‘future_by-1’
[16:17:47.090] Expression:
[16:17:47.090] {
[16:17:47.090]     do.call(function(...) {
[16:17:47.090]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.090]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.090]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.090]             on.exit(options(oopts), add = TRUE)
[16:17:47.090]         }
[16:17:47.090]         {
[16:17:47.090]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.090]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.090]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.090]             })
[16:17:47.090]         }
[16:17:47.090]     }, args = future.call.arguments)
[16:17:47.090] }
[16:17:47.090] Lazy evaluation: FALSE
[16:17:47.090] Asynchronous evaluation: FALSE
[16:17:47.090] Local evaluation: TRUE
[16:17:47.090] Environment: R_GlobalEnv
[16:17:47.090] Capture standard output: TRUE
[16:17:47.090] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:47.090] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:47.090] Packages: <none>
[16:17:47.090] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:47.090] Resolved: TRUE
[16:17:47.090] Value: 5.48 KiB of class ‘list’
[16:17:47.090] Early signaling: FALSE
[16:17:47.090] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:47.090] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:47.091] Chunk #1 of 1 ... DONE
[16:17:47.091] Launching 1 futures (chunks) ... DONE
[16:17:47.091] Resolving 1 futures (chunks) ...
[16:17:47.091] resolve() on list ...
[16:17:47.091]  recursive: 0
[16:17:47.092]  length: 1
[16:17:47.092] 
[16:17:47.092] resolved() for ‘SequentialFuture’ ...
[16:17:47.092] - state: ‘finished’
[16:17:47.092] - run: TRUE
[16:17:47.092] - result: ‘FutureResult’
[16:17:47.092] resolved() for ‘SequentialFuture’ ... done
[16:17:47.092] Future #1
[16:17:47.092] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:47.092] - nx: 1
[16:17:47.093] - relay: TRUE
[16:17:47.093] - stdout: TRUE
[16:17:47.093] - signal: TRUE
[16:17:47.093] - resignal: FALSE
[16:17:47.093] - force: TRUE
[16:17:47.093] - relayed: [n=1] FALSE
[16:17:47.093] - queued futures: [n=1] FALSE
[16:17:47.093]  - until=1
[16:17:47.093]  - relaying element #1
[16:17:47.093] - relayed: [n=1] TRUE
[16:17:47.093] - queued futures: [n=1] TRUE
[16:17:47.094] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:47.094]  length: 0 (resolved future 1)
[16:17:47.094] Relaying remaining futures
[16:17:47.094] signalConditionsASAP(NULL, pos=0) ...
[16:17:47.094] - nx: 1
[16:17:47.094] - relay: TRUE
[16:17:47.094] - stdout: TRUE
[16:17:47.094] - signal: TRUE
[16:17:47.094] - resignal: FALSE
[16:17:47.094] - force: TRUE
[16:17:47.094] - relayed: [n=1] TRUE
[16:17:47.094] - queued futures: [n=1] TRUE
 - flush all
[16:17:47.095] - relayed: [n=1] TRUE
[16:17:47.095] - queued futures: [n=1] TRUE
[16:17:47.095] signalConditionsASAP(NULL, pos=0) ... done
[16:17:47.095] resolve() on list ... DONE
[16:17:47.095]  - Number of value chunks collected: 1
[16:17:47.095] Resolving 1 futures (chunks) ... DONE
[16:17:47.095] Reducing values from 1 chunks ...
[16:17:47.095]  - Number of values collected after concatenation: 6
[16:17:47.095]  - Number of values expected: 6
[16:17:47.095] Reducing values from 1 chunks ... DONE
[16:17:47.095] future_lapply() ... DONE
[16:17:47.096] future_by_internal() ... DONE
[16:17:47.097] future_by_internal() ...
[16:17:47.097] future_lapply() ...
[16:17:47.098] Number of chunks: 1
[16:17:47.098] getGlobalsAndPackagesXApply() ...
[16:17:47.098]  - future.globals: TRUE
[16:17:47.098] getGlobalsAndPackages() ...
[16:17:47.098] Searching for globals...
[16:17:47.099] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:17:47.100] Searching for globals ... DONE
[16:17:47.100] Resolving globals: FALSE
[16:17:47.100] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[16:17:47.100] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[16:17:47.101] - globals: [1] ‘FUN’
[16:17:47.101] - packages: [1] ‘stats’
[16:17:47.101] getGlobalsAndPackages() ... DONE
[16:17:47.101]  - globals found/used: [n=1] ‘FUN’
[16:17:47.101]  - needed namespaces: [n=1] ‘stats’
[16:17:47.101] Finding globals ... DONE
[16:17:47.101]  - use_args: TRUE
[16:17:47.101]  - Getting '...' globals ...
[16:17:47.101] resolve() on list ...
[16:17:47.102]  recursive: 0
[16:17:47.102]  length: 1
[16:17:47.102]  elements: ‘...’
[16:17:47.102]  length: 0 (resolved future 1)
[16:17:47.102] resolve() on list ... DONE
[16:17:47.102]    - '...' content: [n=1] ‘singular.ok’
[16:17:47.102] List of 1
[16:17:47.102]  $ ...:List of 1
[16:17:47.102]   ..$ singular.ok: logi FALSE
[16:17:47.102]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.102]  - attr(*, "where")=List of 1
[16:17:47.102]   ..$ ...:<environment: 0x55b567b40438> 
[16:17:47.102]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.102]  - attr(*, "resolved")= logi TRUE
[16:17:47.102]  - attr(*, "total_size")= num NA
[16:17:47.106]  - Getting '...' globals ... DONE
[16:17:47.106] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:47.106] List of 2
[16:17:47.106]  $ ...future.FUN:function (x, ...)  
[16:17:47.106]  $ ...          :List of 1
[16:17:47.106]   ..$ singular.ok: logi FALSE
[16:17:47.106]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.106]  - attr(*, "where")=List of 2
[16:17:47.106]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:47.106]   ..$ ...          :<environment: 0x55b567b40438> 
[16:17:47.106]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.106]  - attr(*, "resolved")= logi FALSE
[16:17:47.106]  - attr(*, "total_size")= num 5384
[16:17:47.109] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:47.110] getGlobalsAndPackagesXApply() ... DONE
[16:17:47.110] Number of futures (= number of chunks): 1
[16:17:47.110] Launching 1 futures (chunks) ...
[16:17:47.110] Chunk #1 of 1 ...
[16:17:47.110]  - Finding globals in 'X' for chunk #1 ...
[16:17:47.110] getGlobalsAndPackages() ...
[16:17:47.110] Searching for globals...
[16:17:47.111] 
[16:17:47.111] Searching for globals ... DONE
[16:17:47.111] - globals: [0] <none>
[16:17:47.111] getGlobalsAndPackages() ... DONE
[16:17:47.111]    + additional globals found: [n=0] 
[16:17:47.111]    + additional namespaces needed: [n=0] 
[16:17:47.111]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:47.111]  - seeds: <none>
[16:17:47.111]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.111] getGlobalsAndPackages() ...
[16:17:47.112] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.112] Resolving globals: FALSE
[16:17:47.112] Tweak future expression to call with '...' arguments ...
[16:17:47.112] {
[16:17:47.112]     do.call(function(...) {
[16:17:47.112]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.112]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.112]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.112]             on.exit(options(oopts), add = TRUE)
[16:17:47.112]         }
[16:17:47.112]         {
[16:17:47.112]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.112]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.112]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.112]             })
[16:17:47.112]         }
[16:17:47.112]     }, args = future.call.arguments)
[16:17:47.112] }
[16:17:47.112] Tweak future expression to call with '...' arguments ... DONE
[16:17:47.112] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.113] 
[16:17:47.113] getGlobalsAndPackages() ... DONE
[16:17:47.113] run() for ‘Future’ ...
[16:17:47.113] - state: ‘created’
[16:17:47.113] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:17:47.113] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:47.114] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:47.114]   - Field: ‘label’
[16:17:47.114]   - Field: ‘local’
[16:17:47.114]   - Field: ‘owner’
[16:17:47.114]   - Field: ‘envir’
[16:17:47.114]   - Field: ‘packages’
[16:17:47.114]   - Field: ‘gc’
[16:17:47.114]   - Field: ‘conditions’
[16:17:47.114]   - Field: ‘expr’
[16:17:47.114]   - Field: ‘uuid’
[16:17:47.114]   - Field: ‘seed’
[16:17:47.115]   - Field: ‘version’
[16:17:47.115]   - Field: ‘result’
[16:17:47.115]   - Field: ‘asynchronous’
[16:17:47.115]   - Field: ‘calls’
[16:17:47.115]   - Field: ‘globals’
[16:17:47.115]   - Field: ‘stdout’
[16:17:47.115]   - Field: ‘earlySignal’
[16:17:47.115]   - Field: ‘lazy’
[16:17:47.115]   - Field: ‘state’
[16:17:47.115] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:47.115] - Launch lazy future ...
[16:17:47.116] Packages needed by the future expression (n = 1): ‘stats’
[16:17:47.116] Packages needed by future strategies (n = 0): <none>
[16:17:47.116] {
[16:17:47.116]     {
[16:17:47.116]         {
[16:17:47.116]             ...future.startTime <- base::Sys.time()
[16:17:47.116]             {
[16:17:47.116]                 {
[16:17:47.116]                   {
[16:17:47.116]                     {
[16:17:47.116]                       base::local({
[16:17:47.116]                         has_future <- base::requireNamespace("future", 
[16:17:47.116]                           quietly = TRUE)
[16:17:47.116]                         if (has_future) {
[16:17:47.116]                           ns <- base::getNamespace("future")
[16:17:47.116]                           version <- ns[[".package"]][["version"]]
[16:17:47.116]                           if (is.null(version)) 
[16:17:47.116]                             version <- utils::packageVersion("future")
[16:17:47.116]                         }
[16:17:47.116]                         else {
[16:17:47.116]                           version <- NULL
[16:17:47.116]                         }
[16:17:47.116]                         if (!has_future || version < "1.8.0") {
[16:17:47.116]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:47.116]                             "", base::R.version$version.string), 
[16:17:47.116]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:47.116]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:47.116]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:47.116]                               "release", "version")], collapse = " "), 
[16:17:47.116]                             hostname = base::Sys.info()[["nodename"]])
[16:17:47.116]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:47.116]                             info)
[16:17:47.116]                           info <- base::paste(info, collapse = "; ")
[16:17:47.116]                           if (!has_future) {
[16:17:47.116]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:47.116]                               info)
[16:17:47.116]                           }
[16:17:47.116]                           else {
[16:17:47.116]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:47.116]                               info, version)
[16:17:47.116]                           }
[16:17:47.116]                           base::stop(msg)
[16:17:47.116]                         }
[16:17:47.116]                       })
[16:17:47.116]                     }
[16:17:47.116]                     base::local({
[16:17:47.116]                       for (pkg in "stats") {
[16:17:47.116]                         base::loadNamespace(pkg)
[16:17:47.116]                         base::library(pkg, character.only = TRUE)
[16:17:47.116]                       }
[16:17:47.116]                     })
[16:17:47.116]                   }
[16:17:47.116]                   ...future.strategy.old <- future::plan("list")
[16:17:47.116]                   options(future.plan = NULL)
[16:17:47.116]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.116]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:47.116]                 }
[16:17:47.116]                 ...future.workdir <- getwd()
[16:17:47.116]             }
[16:17:47.116]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:47.116]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:47.116]         }
[16:17:47.116]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:47.116]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:47.116]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:47.116]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:47.116]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:47.116]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:47.116]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:47.116]             base::names(...future.oldOptions))
[16:17:47.116]     }
[16:17:47.116]     if (FALSE) {
[16:17:47.116]     }
[16:17:47.116]     else {
[16:17:47.116]         if (TRUE) {
[16:17:47.116]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:47.116]                 open = "w")
[16:17:47.116]         }
[16:17:47.116]         else {
[16:17:47.116]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:47.116]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:47.116]         }
[16:17:47.116]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:47.116]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:47.116]             base::sink(type = "output", split = FALSE)
[16:17:47.116]             base::close(...future.stdout)
[16:17:47.116]         }, add = TRUE)
[16:17:47.116]     }
[16:17:47.116]     ...future.frame <- base::sys.nframe()
[16:17:47.116]     ...future.conditions <- base::list()
[16:17:47.116]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:47.116]     if (FALSE) {
[16:17:47.116]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:47.116]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:47.116]     }
[16:17:47.116]     ...future.result <- base::tryCatch({
[16:17:47.116]         base::withCallingHandlers({
[16:17:47.116]             ...future.value <- base::withVisible(base::local({
[16:17:47.116]                 do.call(function(...) {
[16:17:47.116]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.116]                   if (!identical(...future.globals.maxSize.org, 
[16:17:47.116]                     ...future.globals.maxSize)) {
[16:17:47.116]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.116]                     on.exit(options(oopts), add = TRUE)
[16:17:47.116]                   }
[16:17:47.116]                   {
[16:17:47.116]                     lapply(seq_along(...future.elements_ii), 
[16:17:47.116]                       FUN = function(jj) {
[16:17:47.116]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.116]                         ...future.FUN(...future.X_jj, ...)
[16:17:47.116]                       })
[16:17:47.116]                   }
[16:17:47.116]                 }, args = future.call.arguments)
[16:17:47.116]             }))
[16:17:47.116]             future::FutureResult(value = ...future.value$value, 
[16:17:47.116]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.116]                   ...future.rng), globalenv = if (FALSE) 
[16:17:47.116]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:47.116]                     ...future.globalenv.names))
[16:17:47.116]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:47.116]         }, condition = base::local({
[16:17:47.116]             c <- base::c
[16:17:47.116]             inherits <- base::inherits
[16:17:47.116]             invokeRestart <- base::invokeRestart
[16:17:47.116]             length <- base::length
[16:17:47.116]             list <- base::list
[16:17:47.116]             seq.int <- base::seq.int
[16:17:47.116]             signalCondition <- base::signalCondition
[16:17:47.116]             sys.calls <- base::sys.calls
[16:17:47.116]             `[[` <- base::`[[`
[16:17:47.116]             `+` <- base::`+`
[16:17:47.116]             `<<-` <- base::`<<-`
[16:17:47.116]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:47.116]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:47.116]                   3L)]
[16:17:47.116]             }
[16:17:47.116]             function(cond) {
[16:17:47.116]                 is_error <- inherits(cond, "error")
[16:17:47.116]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:47.116]                   NULL)
[16:17:47.116]                 if (is_error) {
[16:17:47.116]                   sessionInformation <- function() {
[16:17:47.116]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:47.116]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:47.116]                       search = base::search(), system = base::Sys.info())
[16:17:47.116]                   }
[16:17:47.116]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.116]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:47.116]                     cond$call), session = sessionInformation(), 
[16:17:47.116]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:47.116]                   signalCondition(cond)
[16:17:47.116]                 }
[16:17:47.116]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:47.116]                 "immediateCondition"))) {
[16:17:47.116]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:47.116]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.116]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:47.116]                   if (TRUE && !signal) {
[16:17:47.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.116]                     {
[16:17:47.116]                       inherits <- base::inherits
[16:17:47.116]                       invokeRestart <- base::invokeRestart
[16:17:47.116]                       is.null <- base::is.null
[16:17:47.116]                       muffled <- FALSE
[16:17:47.116]                       if (inherits(cond, "message")) {
[16:17:47.116]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.116]                         if (muffled) 
[16:17:47.116]                           invokeRestart("muffleMessage")
[16:17:47.116]                       }
[16:17:47.116]                       else if (inherits(cond, "warning")) {
[16:17:47.116]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.116]                         if (muffled) 
[16:17:47.116]                           invokeRestart("muffleWarning")
[16:17:47.116]                       }
[16:17:47.116]                       else if (inherits(cond, "condition")) {
[16:17:47.116]                         if (!is.null(pattern)) {
[16:17:47.116]                           computeRestarts <- base::computeRestarts
[16:17:47.116]                           grepl <- base::grepl
[16:17:47.116]                           restarts <- computeRestarts(cond)
[16:17:47.116]                           for (restart in restarts) {
[16:17:47.116]                             name <- restart$name
[16:17:47.116]                             if (is.null(name)) 
[16:17:47.116]                               next
[16:17:47.116]                             if (!grepl(pattern, name)) 
[16:17:47.116]                               next
[16:17:47.116]                             invokeRestart(restart)
[16:17:47.116]                             muffled <- TRUE
[16:17:47.116]                             break
[16:17:47.116]                           }
[16:17:47.116]                         }
[16:17:47.116]                       }
[16:17:47.116]                       invisible(muffled)
[16:17:47.116]                     }
[16:17:47.116]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.116]                   }
[16:17:47.116]                 }
[16:17:47.116]                 else {
[16:17:47.116]                   if (TRUE) {
[16:17:47.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.116]                     {
[16:17:47.116]                       inherits <- base::inherits
[16:17:47.116]                       invokeRestart <- base::invokeRestart
[16:17:47.116]                       is.null <- base::is.null
[16:17:47.116]                       muffled <- FALSE
[16:17:47.116]                       if (inherits(cond, "message")) {
[16:17:47.116]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.116]                         if (muffled) 
[16:17:47.116]                           invokeRestart("muffleMessage")
[16:17:47.116]                       }
[16:17:47.116]                       else if (inherits(cond, "warning")) {
[16:17:47.116]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.116]                         if (muffled) 
[16:17:47.116]                           invokeRestart("muffleWarning")
[16:17:47.116]                       }
[16:17:47.116]                       else if (inherits(cond, "condition")) {
[16:17:47.116]                         if (!is.null(pattern)) {
[16:17:47.116]                           computeRestarts <- base::computeRestarts
[16:17:47.116]                           grepl <- base::grepl
[16:17:47.116]                           restarts <- computeRestarts(cond)
[16:17:47.116]                           for (restart in restarts) {
[16:17:47.116]                             name <- restart$name
[16:17:47.116]                             if (is.null(name)) 
[16:17:47.116]                               next
[16:17:47.116]                             if (!grepl(pattern, name)) 
[16:17:47.116]                               next
[16:17:47.116]                             invokeRestart(restart)
[16:17:47.116]                             muffled <- TRUE
[16:17:47.116]                             break
[16:17:47.116]                           }
[16:17:47.116]                         }
[16:17:47.116]                       }
[16:17:47.116]                       invisible(muffled)
[16:17:47.116]                     }
[16:17:47.116]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.116]                   }
[16:17:47.116]                 }
[16:17:47.116]             }
[16:17:47.116]         }))
[16:17:47.116]     }, error = function(ex) {
[16:17:47.116]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:47.116]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.116]                 ...future.rng), started = ...future.startTime, 
[16:17:47.116]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:47.116]             version = "1.8"), class = "FutureResult")
[16:17:47.116]     }, finally = {
[16:17:47.116]         if (!identical(...future.workdir, getwd())) 
[16:17:47.116]             setwd(...future.workdir)
[16:17:47.116]         {
[16:17:47.116]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:47.116]                 ...future.oldOptions$nwarnings <- NULL
[16:17:47.116]             }
[16:17:47.116]             base::options(...future.oldOptions)
[16:17:47.116]             if (.Platform$OS.type == "windows") {
[16:17:47.116]                 old_names <- names(...future.oldEnvVars)
[16:17:47.116]                 envs <- base::Sys.getenv()
[16:17:47.116]                 names <- names(envs)
[16:17:47.116]                 common <- intersect(names, old_names)
[16:17:47.116]                 added <- setdiff(names, old_names)
[16:17:47.116]                 removed <- setdiff(old_names, names)
[16:17:47.116]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:47.116]                   envs[common]]
[16:17:47.116]                 NAMES <- toupper(changed)
[16:17:47.116]                 args <- list()
[16:17:47.116]                 for (kk in seq_along(NAMES)) {
[16:17:47.116]                   name <- changed[[kk]]
[16:17:47.116]                   NAME <- NAMES[[kk]]
[16:17:47.116]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.116]                     next
[16:17:47.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.116]                 }
[16:17:47.116]                 NAMES <- toupper(added)
[16:17:47.116]                 for (kk in seq_along(NAMES)) {
[16:17:47.116]                   name <- added[[kk]]
[16:17:47.116]                   NAME <- NAMES[[kk]]
[16:17:47.116]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.116]                     next
[16:17:47.116]                   args[[name]] <- ""
[16:17:47.116]                 }
[16:17:47.116]                 NAMES <- toupper(removed)
[16:17:47.116]                 for (kk in seq_along(NAMES)) {
[16:17:47.116]                   name <- removed[[kk]]
[16:17:47.116]                   NAME <- NAMES[[kk]]
[16:17:47.116]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.116]                     next
[16:17:47.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.116]                 }
[16:17:47.116]                 if (length(args) > 0) 
[16:17:47.116]                   base::do.call(base::Sys.setenv, args = args)
[16:17:47.116]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:47.116]             }
[16:17:47.116]             else {
[16:17:47.116]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:47.116]             }
[16:17:47.116]             {
[16:17:47.116]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:47.116]                   0L) {
[16:17:47.116]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:47.116]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:47.116]                   base::options(opts)
[16:17:47.116]                 }
[16:17:47.116]                 {
[16:17:47.116]                   {
[16:17:47.116]                     NULL
[16:17:47.116]                     RNGkind("Mersenne-Twister")
[16:17:47.116]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:47.116]                       inherits = FALSE)
[16:17:47.116]                   }
[16:17:47.116]                   options(future.plan = NULL)
[16:17:47.116]                   if (is.na(NA_character_)) 
[16:17:47.116]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.116]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:47.116]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:47.116]                     .init = FALSE)
[16:17:47.116]                 }
[16:17:47.116]             }
[16:17:47.116]         }
[16:17:47.116]     })
[16:17:47.116]     if (TRUE) {
[16:17:47.116]         base::sink(type = "output", split = FALSE)
[16:17:47.116]         if (TRUE) {
[16:17:47.116]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:47.116]         }
[16:17:47.116]         else {
[16:17:47.116]             ...future.result["stdout"] <- base::list(NULL)
[16:17:47.116]         }
[16:17:47.116]         base::close(...future.stdout)
[16:17:47.116]         ...future.stdout <- NULL
[16:17:47.116]     }
[16:17:47.116]     ...future.result$conditions <- ...future.conditions
[16:17:47.116]     ...future.result$finished <- base::Sys.time()
[16:17:47.116]     ...future.result
[16:17:47.116] }
[16:17:47.118] assign_globals() ...
[16:17:47.118] List of 5
[16:17:47.118]  $ ...future.FUN            :function (x, ...)  
[16:17:47.118]  $ future.call.arguments    :List of 1
[16:17:47.118]   ..$ singular.ok: logi FALSE
[16:17:47.118]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.118]  $ ...future.elements_ii    :List of 3
[16:17:47.118]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:47.118]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:17:47.118]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.118]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:47.118]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:47.118]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:17:47.118]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.118]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:17:47.118]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:47.118]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:17:47.118]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.118]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:17:47.118]  $ ...future.seeds_ii       : NULL
[16:17:47.118]  $ ...future.globals.maxSize: NULL
[16:17:47.118]  - attr(*, "where")=List of 5
[16:17:47.118]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:47.118]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:47.118]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:47.118]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:47.118]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:47.118]  - attr(*, "resolved")= logi FALSE
[16:17:47.118]  - attr(*, "total_size")= num 5384
[16:17:47.118]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.118]  - attr(*, "already-done")= logi TRUE
[16:17:47.128] - reassign environment for ‘...future.FUN’
[16:17:47.128] - copied ‘...future.FUN’ to environment
[16:17:47.128] - copied ‘future.call.arguments’ to environment
[16:17:47.128] - copied ‘...future.elements_ii’ to environment
[16:17:47.128] - copied ‘...future.seeds_ii’ to environment
[16:17:47.128] - copied ‘...future.globals.maxSize’ to environment
[16:17:47.128] assign_globals() ... done
[16:17:47.129] plan(): Setting new future strategy stack:
[16:17:47.129] List of future strategies:
[16:17:47.129] 1. sequential:
[16:17:47.129]    - args: function (..., envir = parent.frame())
[16:17:47.129]    - tweaked: FALSE
[16:17:47.129]    - call: NULL
[16:17:47.129] plan(): nbrOfWorkers() = 1
[16:17:47.132] plan(): Setting new future strategy stack:
[16:17:47.132] List of future strategies:
[16:17:47.132] 1. sequential:
[16:17:47.132]    - args: function (..., envir = parent.frame())
[16:17:47.132]    - tweaked: FALSE
[16:17:47.132]    - call: plan(strategy)
[16:17:47.132] plan(): nbrOfWorkers() = 1
[16:17:47.132] SequentialFuture started (and completed)
[16:17:47.132] - Launch lazy future ... done
[16:17:47.132] run() for ‘SequentialFuture’ ... done
[16:17:47.133] Created future:
[16:17:47.133] SequentialFuture:
[16:17:47.133] Label: ‘future_by-1’
[16:17:47.133] Expression:
[16:17:47.133] {
[16:17:47.133]     do.call(function(...) {
[16:17:47.133]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.133]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.133]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.133]             on.exit(options(oopts), add = TRUE)
[16:17:47.133]         }
[16:17:47.133]         {
[16:17:47.133]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.133]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.133]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.133]             })
[16:17:47.133]         }
[16:17:47.133]     }, args = future.call.arguments)
[16:17:47.133] }
[16:17:47.133] Lazy evaluation: FALSE
[16:17:47.133] Asynchronous evaluation: FALSE
[16:17:47.133] Local evaluation: TRUE
[16:17:47.133] Environment: R_GlobalEnv
[16:17:47.133] Capture standard output: TRUE
[16:17:47.133] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:47.133] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:47.133] Packages: 1 packages (‘stats’)
[16:17:47.133] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:47.133] Resolved: TRUE
[16:17:47.133] Value: 26.06 KiB of class ‘list’
[16:17:47.133] Early signaling: FALSE
[16:17:47.133] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:47.133] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:47.134] Chunk #1 of 1 ... DONE
[16:17:47.134] Launching 1 futures (chunks) ... DONE
[16:17:47.134] Resolving 1 futures (chunks) ...
[16:17:47.134] resolve() on list ...
[16:17:47.134]  recursive: 0
[16:17:47.134]  length: 1
[16:17:47.135] 
[16:17:47.135] resolved() for ‘SequentialFuture’ ...
[16:17:47.135] - state: ‘finished’
[16:17:47.135] - run: TRUE
[16:17:47.135] - result: ‘FutureResult’
[16:17:47.135] resolved() for ‘SequentialFuture’ ... done
[16:17:47.135] Future #1
[16:17:47.135] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:47.135] - nx: 1
[16:17:47.135] - relay: TRUE
[16:17:47.135] - stdout: TRUE
[16:17:47.136] - signal: TRUE
[16:17:47.136] - resignal: FALSE
[16:17:47.136] - force: TRUE
[16:17:47.136] - relayed: [n=1] FALSE
[16:17:47.136] - queued futures: [n=1] FALSE
[16:17:47.136]  - until=1
[16:17:47.136]  - relaying element #1
[16:17:47.136] - relayed: [n=1] TRUE
[16:17:47.136] - queued futures: [n=1] TRUE
[16:17:47.136] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:47.137]  length: 0 (resolved future 1)
[16:17:47.137] Relaying remaining futures
[16:17:47.137] signalConditionsASAP(NULL, pos=0) ...
[16:17:47.137] - nx: 1
[16:17:47.137] - relay: TRUE
[16:17:47.137] - stdout: TRUE
[16:17:47.137] - signal: TRUE
[16:17:47.137] - resignal: FALSE
[16:17:47.137] - force: TRUE
[16:17:47.137] - relayed: [n=1] TRUE
[16:17:47.137] - queued futures: [n=1] TRUE
 - flush all
[16:17:47.137] - relayed: [n=1] TRUE
[16:17:47.138] - queued futures: [n=1] TRUE
[16:17:47.138] signalConditionsASAP(NULL, pos=0) ... done
[16:17:47.138] resolve() on list ... DONE
[16:17:47.138]  - Number of value chunks collected: 1
[16:17:47.138] Resolving 1 futures (chunks) ... DONE
[16:17:47.138] Reducing values from 1 chunks ...
[16:17:47.138]  - Number of values collected after concatenation: 3
[16:17:47.138]  - Number of values expected: 3
[16:17:47.138] Reducing values from 1 chunks ... DONE
[16:17:47.138] future_lapply() ... DONE
[16:17:47.138] future_by_internal() ... DONE
[16:17:47.143] future_by_internal() ...
[16:17:47.144] future_lapply() ...
[16:17:47.145] Number of chunks: 1
[16:17:47.145] getGlobalsAndPackagesXApply() ...
[16:17:47.145]  - future.globals: TRUE
[16:17:47.145] getGlobalsAndPackages() ...
[16:17:47.145] Searching for globals...
[16:17:47.146] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:17:47.147] Searching for globals ... DONE
[16:17:47.147] Resolving globals: FALSE
[16:17:47.147] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[16:17:47.147] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[16:17:47.148] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[16:17:47.148] - packages: [1] ‘stats’
[16:17:47.148] getGlobalsAndPackages() ... DONE
[16:17:47.148]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[16:17:47.148]  - needed namespaces: [n=1] ‘stats’
[16:17:47.148] Finding globals ... DONE
[16:17:47.148]  - use_args: TRUE
[16:17:47.148]  - Getting '...' globals ...
[16:17:47.149] resolve() on list ...
[16:17:47.149]  recursive: 0
[16:17:47.149]  length: 1
[16:17:47.149]  elements: ‘...’
[16:17:47.149]  length: 0 (resolved future 1)
[16:17:47.149] resolve() on list ... DONE
[16:17:47.149]    - '...' content: [n=0] 
[16:17:47.149] List of 1
[16:17:47.149]  $ ...: list()
[16:17:47.149]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.149]  - attr(*, "where")=List of 1
[16:17:47.149]   ..$ ...:<environment: 0x55b5681a0250> 
[16:17:47.149]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.149]  - attr(*, "resolved")= logi TRUE
[16:17:47.149]  - attr(*, "total_size")= num NA
[16:17:47.152]  - Getting '...' globals ... DONE
[16:17:47.152] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[16:17:47.152] List of 4
[16:17:47.152]  $ ...future.FUN:function (x)  
[16:17:47.152]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:17:47.152]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:47.152]  $ ...          : list()
[16:17:47.152]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.152]  - attr(*, "where")=List of 4
[16:17:47.152]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:47.152]   ..$ breaks       :<environment: R_EmptyEnv> 
[16:17:47.152]   ..$ wool         :<environment: R_EmptyEnv> 
[16:17:47.152]   ..$ ...          :<environment: 0x55b5681a0250> 
[16:17:47.152]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.152]  - attr(*, "resolved")= logi FALSE
[16:17:47.152]  - attr(*, "total_size")= num 2320
[16:17:47.155] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:47.156] getGlobalsAndPackagesXApply() ... DONE
[16:17:47.156] Number of futures (= number of chunks): 1
[16:17:47.156] Launching 1 futures (chunks) ...
[16:17:47.156] Chunk #1 of 1 ...
[16:17:47.156]  - Finding globals in 'X' for chunk #1 ...
[16:17:47.156] getGlobalsAndPackages() ...
[16:17:47.156] Searching for globals...
[16:17:47.157] 
[16:17:47.157] Searching for globals ... DONE
[16:17:47.157] - globals: [0] <none>
[16:17:47.157] getGlobalsAndPackages() ... DONE
[16:17:47.158]    + additional globals found: [n=0] 
[16:17:47.158]    + additional namespaces needed: [n=0] 
[16:17:47.158]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:47.158]  - seeds: <none>
[16:17:47.158]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.159] getGlobalsAndPackages() ...
[16:17:47.159] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.159] Resolving globals: FALSE
[16:17:47.159] Tweak future expression to call with '...' arguments ...
[16:17:47.159] {
[16:17:47.159]     do.call(function(...) {
[16:17:47.159]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.159]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.159]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.159]             on.exit(options(oopts), add = TRUE)
[16:17:47.159]         }
[16:17:47.159]         {
[16:17:47.159]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.159]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.159]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.159]             })
[16:17:47.159]         }
[16:17:47.159]     }, args = future.call.arguments)
[16:17:47.159] }
[16:17:47.159] Tweak future expression to call with '...' arguments ... DONE
[16:17:47.160] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.160] 
[16:17:47.160] getGlobalsAndPackages() ... DONE
[16:17:47.160] run() for ‘Future’ ...
[16:17:47.160] - state: ‘created’
[16:17:47.160] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:17:47.161] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:47.161] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:47.161]   - Field: ‘label’
[16:17:47.161]   - Field: ‘local’
[16:17:47.161]   - Field: ‘owner’
[16:17:47.161]   - Field: ‘envir’
[16:17:47.161]   - Field: ‘packages’
[16:17:47.161]   - Field: ‘gc’
[16:17:47.161]   - Field: ‘conditions’
[16:17:47.162]   - Field: ‘expr’
[16:17:47.162]   - Field: ‘uuid’
[16:17:47.162]   - Field: ‘seed’
[16:17:47.162]   - Field: ‘version’
[16:17:47.162]   - Field: ‘result’
[16:17:47.162]   - Field: ‘asynchronous’
[16:17:47.162]   - Field: ‘calls’
[16:17:47.162]   - Field: ‘globals’
[16:17:47.162]   - Field: ‘stdout’
[16:17:47.162]   - Field: ‘earlySignal’
[16:17:47.162]   - Field: ‘lazy’
[16:17:47.163]   - Field: ‘state’
[16:17:47.163] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:47.163] - Launch lazy future ...
[16:17:47.163] Packages needed by the future expression (n = 1): ‘stats’
[16:17:47.163] Packages needed by future strategies (n = 0): <none>
[16:17:47.163] {
[16:17:47.163]     {
[16:17:47.163]         {
[16:17:47.163]             ...future.startTime <- base::Sys.time()
[16:17:47.163]             {
[16:17:47.163]                 {
[16:17:47.163]                   {
[16:17:47.163]                     {
[16:17:47.163]                       base::local({
[16:17:47.163]                         has_future <- base::requireNamespace("future", 
[16:17:47.163]                           quietly = TRUE)
[16:17:47.163]                         if (has_future) {
[16:17:47.163]                           ns <- base::getNamespace("future")
[16:17:47.163]                           version <- ns[[".package"]][["version"]]
[16:17:47.163]                           if (is.null(version)) 
[16:17:47.163]                             version <- utils::packageVersion("future")
[16:17:47.163]                         }
[16:17:47.163]                         else {
[16:17:47.163]                           version <- NULL
[16:17:47.163]                         }
[16:17:47.163]                         if (!has_future || version < "1.8.0") {
[16:17:47.163]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:47.163]                             "", base::R.version$version.string), 
[16:17:47.163]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:47.163]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:47.163]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:47.163]                               "release", "version")], collapse = " "), 
[16:17:47.163]                             hostname = base::Sys.info()[["nodename"]])
[16:17:47.163]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:47.163]                             info)
[16:17:47.163]                           info <- base::paste(info, collapse = "; ")
[16:17:47.163]                           if (!has_future) {
[16:17:47.163]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:47.163]                               info)
[16:17:47.163]                           }
[16:17:47.163]                           else {
[16:17:47.163]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:47.163]                               info, version)
[16:17:47.163]                           }
[16:17:47.163]                           base::stop(msg)
[16:17:47.163]                         }
[16:17:47.163]                       })
[16:17:47.163]                     }
[16:17:47.163]                     base::local({
[16:17:47.163]                       for (pkg in "stats") {
[16:17:47.163]                         base::loadNamespace(pkg)
[16:17:47.163]                         base::library(pkg, character.only = TRUE)
[16:17:47.163]                       }
[16:17:47.163]                     })
[16:17:47.163]                   }
[16:17:47.163]                   ...future.strategy.old <- future::plan("list")
[16:17:47.163]                   options(future.plan = NULL)
[16:17:47.163]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.163]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:47.163]                 }
[16:17:47.163]                 ...future.workdir <- getwd()
[16:17:47.163]             }
[16:17:47.163]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:47.163]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:47.163]         }
[16:17:47.163]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:47.163]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:47.163]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:47.163]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:47.163]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:47.163]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:47.163]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:47.163]             base::names(...future.oldOptions))
[16:17:47.163]     }
[16:17:47.163]     if (FALSE) {
[16:17:47.163]     }
[16:17:47.163]     else {
[16:17:47.163]         if (TRUE) {
[16:17:47.163]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:47.163]                 open = "w")
[16:17:47.163]         }
[16:17:47.163]         else {
[16:17:47.163]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:47.163]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:47.163]         }
[16:17:47.163]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:47.163]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:47.163]             base::sink(type = "output", split = FALSE)
[16:17:47.163]             base::close(...future.stdout)
[16:17:47.163]         }, add = TRUE)
[16:17:47.163]     }
[16:17:47.163]     ...future.frame <- base::sys.nframe()
[16:17:47.163]     ...future.conditions <- base::list()
[16:17:47.163]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:47.163]     if (FALSE) {
[16:17:47.163]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:47.163]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:47.163]     }
[16:17:47.163]     ...future.result <- base::tryCatch({
[16:17:47.163]         base::withCallingHandlers({
[16:17:47.163]             ...future.value <- base::withVisible(base::local({
[16:17:47.163]                 do.call(function(...) {
[16:17:47.163]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.163]                   if (!identical(...future.globals.maxSize.org, 
[16:17:47.163]                     ...future.globals.maxSize)) {
[16:17:47.163]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.163]                     on.exit(options(oopts), add = TRUE)
[16:17:47.163]                   }
[16:17:47.163]                   {
[16:17:47.163]                     lapply(seq_along(...future.elements_ii), 
[16:17:47.163]                       FUN = function(jj) {
[16:17:47.163]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.163]                         ...future.FUN(...future.X_jj, ...)
[16:17:47.163]                       })
[16:17:47.163]                   }
[16:17:47.163]                 }, args = future.call.arguments)
[16:17:47.163]             }))
[16:17:47.163]             future::FutureResult(value = ...future.value$value, 
[16:17:47.163]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.163]                   ...future.rng), globalenv = if (FALSE) 
[16:17:47.163]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:47.163]                     ...future.globalenv.names))
[16:17:47.163]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:47.163]         }, condition = base::local({
[16:17:47.163]             c <- base::c
[16:17:47.163]             inherits <- base::inherits
[16:17:47.163]             invokeRestart <- base::invokeRestart
[16:17:47.163]             length <- base::length
[16:17:47.163]             list <- base::list
[16:17:47.163]             seq.int <- base::seq.int
[16:17:47.163]             signalCondition <- base::signalCondition
[16:17:47.163]             sys.calls <- base::sys.calls
[16:17:47.163]             `[[` <- base::`[[`
[16:17:47.163]             `+` <- base::`+`
[16:17:47.163]             `<<-` <- base::`<<-`
[16:17:47.163]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:47.163]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:47.163]                   3L)]
[16:17:47.163]             }
[16:17:47.163]             function(cond) {
[16:17:47.163]                 is_error <- inherits(cond, "error")
[16:17:47.163]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:47.163]                   NULL)
[16:17:47.163]                 if (is_error) {
[16:17:47.163]                   sessionInformation <- function() {
[16:17:47.163]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:47.163]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:47.163]                       search = base::search(), system = base::Sys.info())
[16:17:47.163]                   }
[16:17:47.163]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.163]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:47.163]                     cond$call), session = sessionInformation(), 
[16:17:47.163]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:47.163]                   signalCondition(cond)
[16:17:47.163]                 }
[16:17:47.163]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:47.163]                 "immediateCondition"))) {
[16:17:47.163]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:47.163]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.163]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:47.163]                   if (TRUE && !signal) {
[16:17:47.163]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.163]                     {
[16:17:47.163]                       inherits <- base::inherits
[16:17:47.163]                       invokeRestart <- base::invokeRestart
[16:17:47.163]                       is.null <- base::is.null
[16:17:47.163]                       muffled <- FALSE
[16:17:47.163]                       if (inherits(cond, "message")) {
[16:17:47.163]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.163]                         if (muffled) 
[16:17:47.163]                           invokeRestart("muffleMessage")
[16:17:47.163]                       }
[16:17:47.163]                       else if (inherits(cond, "warning")) {
[16:17:47.163]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.163]                         if (muffled) 
[16:17:47.163]                           invokeRestart("muffleWarning")
[16:17:47.163]                       }
[16:17:47.163]                       else if (inherits(cond, "condition")) {
[16:17:47.163]                         if (!is.null(pattern)) {
[16:17:47.163]                           computeRestarts <- base::computeRestarts
[16:17:47.163]                           grepl <- base::grepl
[16:17:47.163]                           restarts <- computeRestarts(cond)
[16:17:47.163]                           for (restart in restarts) {
[16:17:47.163]                             name <- restart$name
[16:17:47.163]                             if (is.null(name)) 
[16:17:47.163]                               next
[16:17:47.163]                             if (!grepl(pattern, name)) 
[16:17:47.163]                               next
[16:17:47.163]                             invokeRestart(restart)
[16:17:47.163]                             muffled <- TRUE
[16:17:47.163]                             break
[16:17:47.163]                           }
[16:17:47.163]                         }
[16:17:47.163]                       }
[16:17:47.163]                       invisible(muffled)
[16:17:47.163]                     }
[16:17:47.163]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.163]                   }
[16:17:47.163]                 }
[16:17:47.163]                 else {
[16:17:47.163]                   if (TRUE) {
[16:17:47.163]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.163]                     {
[16:17:47.163]                       inherits <- base::inherits
[16:17:47.163]                       invokeRestart <- base::invokeRestart
[16:17:47.163]                       is.null <- base::is.null
[16:17:47.163]                       muffled <- FALSE
[16:17:47.163]                       if (inherits(cond, "message")) {
[16:17:47.163]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.163]                         if (muffled) 
[16:17:47.163]                           invokeRestart("muffleMessage")
[16:17:47.163]                       }
[16:17:47.163]                       else if (inherits(cond, "warning")) {
[16:17:47.163]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.163]                         if (muffled) 
[16:17:47.163]                           invokeRestart("muffleWarning")
[16:17:47.163]                       }
[16:17:47.163]                       else if (inherits(cond, "condition")) {
[16:17:47.163]                         if (!is.null(pattern)) {
[16:17:47.163]                           computeRestarts <- base::computeRestarts
[16:17:47.163]                           grepl <- base::grepl
[16:17:47.163]                           restarts <- computeRestarts(cond)
[16:17:47.163]                           for (restart in restarts) {
[16:17:47.163]                             name <- restart$name
[16:17:47.163]                             if (is.null(name)) 
[16:17:47.163]                               next
[16:17:47.163]                             if (!grepl(pattern, name)) 
[16:17:47.163]                               next
[16:17:47.163]                             invokeRestart(restart)
[16:17:47.163]                             muffled <- TRUE
[16:17:47.163]                             break
[16:17:47.163]                           }
[16:17:47.163]                         }
[16:17:47.163]                       }
[16:17:47.163]                       invisible(muffled)
[16:17:47.163]                     }
[16:17:47.163]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.163]                   }
[16:17:47.163]                 }
[16:17:47.163]             }
[16:17:47.163]         }))
[16:17:47.163]     }, error = function(ex) {
[16:17:47.163]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:47.163]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.163]                 ...future.rng), started = ...future.startTime, 
[16:17:47.163]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:47.163]             version = "1.8"), class = "FutureResult")
[16:17:47.163]     }, finally = {
[16:17:47.163]         if (!identical(...future.workdir, getwd())) 
[16:17:47.163]             setwd(...future.workdir)
[16:17:47.163]         {
[16:17:47.163]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:47.163]                 ...future.oldOptions$nwarnings <- NULL
[16:17:47.163]             }
[16:17:47.163]             base::options(...future.oldOptions)
[16:17:47.163]             if (.Platform$OS.type == "windows") {
[16:17:47.163]                 old_names <- names(...future.oldEnvVars)
[16:17:47.163]                 envs <- base::Sys.getenv()
[16:17:47.163]                 names <- names(envs)
[16:17:47.163]                 common <- intersect(names, old_names)
[16:17:47.163]                 added <- setdiff(names, old_names)
[16:17:47.163]                 removed <- setdiff(old_names, names)
[16:17:47.163]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:47.163]                   envs[common]]
[16:17:47.163]                 NAMES <- toupper(changed)
[16:17:47.163]                 args <- list()
[16:17:47.163]                 for (kk in seq_along(NAMES)) {
[16:17:47.163]                   name <- changed[[kk]]
[16:17:47.163]                   NAME <- NAMES[[kk]]
[16:17:47.163]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.163]                     next
[16:17:47.163]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.163]                 }
[16:17:47.163]                 NAMES <- toupper(added)
[16:17:47.163]                 for (kk in seq_along(NAMES)) {
[16:17:47.163]                   name <- added[[kk]]
[16:17:47.163]                   NAME <- NAMES[[kk]]
[16:17:47.163]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.163]                     next
[16:17:47.163]                   args[[name]] <- ""
[16:17:47.163]                 }
[16:17:47.163]                 NAMES <- toupper(removed)
[16:17:47.163]                 for (kk in seq_along(NAMES)) {
[16:17:47.163]                   name <- removed[[kk]]
[16:17:47.163]                   NAME <- NAMES[[kk]]
[16:17:47.163]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.163]                     next
[16:17:47.163]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.163]                 }
[16:17:47.163]                 if (length(args) > 0) 
[16:17:47.163]                   base::do.call(base::Sys.setenv, args = args)
[16:17:47.163]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:47.163]             }
[16:17:47.163]             else {
[16:17:47.163]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:47.163]             }
[16:17:47.163]             {
[16:17:47.163]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:47.163]                   0L) {
[16:17:47.163]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:47.163]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:47.163]                   base::options(opts)
[16:17:47.163]                 }
[16:17:47.163]                 {
[16:17:47.163]                   {
[16:17:47.163]                     NULL
[16:17:47.163]                     RNGkind("Mersenne-Twister")
[16:17:47.163]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:47.163]                       inherits = FALSE)
[16:17:47.163]                   }
[16:17:47.163]                   options(future.plan = NULL)
[16:17:47.163]                   if (is.na(NA_character_)) 
[16:17:47.163]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.163]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:47.163]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:47.163]                     .init = FALSE)
[16:17:47.163]                 }
[16:17:47.163]             }
[16:17:47.163]         }
[16:17:47.163]     })
[16:17:47.163]     if (TRUE) {
[16:17:47.163]         base::sink(type = "output", split = FALSE)
[16:17:47.163]         if (TRUE) {
[16:17:47.163]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:47.163]         }
[16:17:47.163]         else {
[16:17:47.163]             ...future.result["stdout"] <- base::list(NULL)
[16:17:47.163]         }
[16:17:47.163]         base::close(...future.stdout)
[16:17:47.163]         ...future.stdout <- NULL
[16:17:47.163]     }
[16:17:47.163]     ...future.result$conditions <- ...future.conditions
[16:17:47.163]     ...future.result$finished <- base::Sys.time()
[16:17:47.163]     ...future.result
[16:17:47.163] }
[16:17:47.165] assign_globals() ...
[16:17:47.165] List of 7
[16:17:47.165]  $ ...future.FUN            :function (x)  
[16:17:47.165]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:17:47.165]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:47.165]  $ future.call.arguments    : list()
[16:17:47.165]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.165]  $ ...future.elements_ii    :List of 3
[16:17:47.165]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:47.165]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:17:47.165]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.165]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:47.165]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:47.165]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:17:47.165]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.165]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:17:47.165]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:47.165]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:17:47.165]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.165]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:17:47.165]  $ ...future.seeds_ii       : NULL
[16:17:47.165]  $ ...future.globals.maxSize: NULL
[16:17:47.165]  - attr(*, "where")=List of 7
[16:17:47.165]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:47.165]   ..$ breaks                   :<environment: R_EmptyEnv> 
[16:17:47.165]   ..$ wool                     :<environment: R_EmptyEnv> 
[16:17:47.165]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:47.165]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:47.165]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:47.165]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:47.165]  - attr(*, "resolved")= logi FALSE
[16:17:47.165]  - attr(*, "total_size")= num 2320
[16:17:47.165]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.165]  - attr(*, "already-done")= logi TRUE
[16:17:47.174] - reassign environment for ‘...future.FUN’
[16:17:47.174] - copied ‘...future.FUN’ to environment
[16:17:47.174] - copied ‘breaks’ to environment
[16:17:47.175] - copied ‘wool’ to environment
[16:17:47.175] - copied ‘future.call.arguments’ to environment
[16:17:47.175] - copied ‘...future.elements_ii’ to environment
[16:17:47.175] - copied ‘...future.seeds_ii’ to environment
[16:17:47.175] - copied ‘...future.globals.maxSize’ to environment
[16:17:47.175] assign_globals() ... done
[16:17:47.175] plan(): Setting new future strategy stack:
[16:17:47.175] List of future strategies:
[16:17:47.175] 1. sequential:
[16:17:47.175]    - args: function (..., envir = parent.frame())
[16:17:47.175]    - tweaked: FALSE
[16:17:47.175]    - call: NULL
[16:17:47.176] plan(): nbrOfWorkers() = 1
[16:17:47.179] plan(): Setting new future strategy stack:
[16:17:47.180] List of future strategies:
[16:17:47.180] 1. sequential:
[16:17:47.180]    - args: function (..., envir = parent.frame())
[16:17:47.180]    - tweaked: FALSE
[16:17:47.180]    - call: plan(strategy)
[16:17:47.180] plan(): nbrOfWorkers() = 1
[16:17:47.180] SequentialFuture started (and completed)
[16:17:47.180] - Launch lazy future ... done
[16:17:47.180] run() for ‘SequentialFuture’ ... done
[16:17:47.181] Created future:
[16:17:47.181] SequentialFuture:
[16:17:47.181] Label: ‘future_by-1’
[16:17:47.181] Expression:
[16:17:47.181] {
[16:17:47.181]     do.call(function(...) {
[16:17:47.181]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.181]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.181]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.181]             on.exit(options(oopts), add = TRUE)
[16:17:47.181]         }
[16:17:47.181]         {
[16:17:47.181]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.181]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.181]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.181]             })
[16:17:47.181]         }
[16:17:47.181]     }, args = future.call.arguments)
[16:17:47.181] }
[16:17:47.181] Lazy evaluation: FALSE
[16:17:47.181] Asynchronous evaluation: FALSE
[16:17:47.181] Local evaluation: TRUE
[16:17:47.181] Environment: 0x55b5675d3280
[16:17:47.181] Capture standard output: TRUE
[16:17:47.181] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:47.181] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[16:17:47.181] Packages: 1 packages (‘stats’)
[16:17:47.181] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:47.181] Resolved: TRUE
[16:17:47.181] Value: 25.57 KiB of class ‘list’
[16:17:47.181] Early signaling: FALSE
[16:17:47.181] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:47.181] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:47.182] Chunk #1 of 1 ... DONE
[16:17:47.182] Launching 1 futures (chunks) ... DONE
[16:17:47.182] Resolving 1 futures (chunks) ...
[16:17:47.182] resolve() on list ...
[16:17:47.182]  recursive: 0
[16:17:47.183]  length: 1
[16:17:47.183] 
[16:17:47.183] resolved() for ‘SequentialFuture’ ...
[16:17:47.183] - state: ‘finished’
[16:17:47.183] - run: TRUE
[16:17:47.183] - result: ‘FutureResult’
[16:17:47.183] resolved() for ‘SequentialFuture’ ... done
[16:17:47.183] Future #1
[16:17:47.183] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:47.183] - nx: 1
[16:17:47.184] - relay: TRUE
[16:17:47.184] - stdout: TRUE
[16:17:47.184] - signal: TRUE
[16:17:47.184] - resignal: FALSE
[16:17:47.184] - force: TRUE
[16:17:47.184] - relayed: [n=1] FALSE
[16:17:47.184] - queued futures: [n=1] FALSE
[16:17:47.184]  - until=1
[16:17:47.184]  - relaying element #1
[16:17:47.184] - relayed: [n=1] TRUE
[16:17:47.184] - queued futures: [n=1] TRUE
[16:17:47.185] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:47.185]  length: 0 (resolved future 1)
[16:17:47.185] Relaying remaining futures
[16:17:47.185] signalConditionsASAP(NULL, pos=0) ...
[16:17:47.185] - nx: 1
[16:17:47.185] - relay: TRUE
[16:17:47.185] - stdout: TRUE
[16:17:47.185] - signal: TRUE
[16:17:47.185] - resignal: FALSE
[16:17:47.185] - force: TRUE
[16:17:47.185] - relayed: [n=1] TRUE
[16:17:47.185] - queued futures: [n=1] TRUE
 - flush all
[16:17:47.186] - relayed: [n=1] TRUE
[16:17:47.186] - queued futures: [n=1] TRUE
[16:17:47.186] signalConditionsASAP(NULL, pos=0) ... done
[16:17:47.186] resolve() on list ... DONE
[16:17:47.186]  - Number of value chunks collected: 1
[16:17:47.186] Resolving 1 futures (chunks) ... DONE
[16:17:47.186] Reducing values from 1 chunks ...
[16:17:47.186]  - Number of values collected after concatenation: 3
[16:17:47.186]  - Number of values expected: 3
[16:17:47.186] Reducing values from 1 chunks ... DONE
[16:17:47.186] future_lapply() ... DONE
[16:17:47.187] future_by_internal() ... DONE
[16:17:47.187] future_by_internal() ...
[16:17:47.187] future_lapply() ...
[16:17:47.188] Number of chunks: 1
[16:17:47.188] getGlobalsAndPackagesXApply() ...
[16:17:47.188]  - future.globals: TRUE
[16:17:47.188] getGlobalsAndPackages() ...
[16:17:47.188] Searching for globals...
[16:17:47.189] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:47.189] Searching for globals ... DONE
[16:17:47.189] Resolving globals: FALSE
[16:17:47.190] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:47.190] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:47.190] - globals: [1] ‘FUN’
[16:17:47.190] 
[16:17:47.190] getGlobalsAndPackages() ... DONE
[16:17:47.190]  - globals found/used: [n=1] ‘FUN’
[16:17:47.190]  - needed namespaces: [n=0] 
[16:17:47.190] Finding globals ... DONE
[16:17:47.191]  - use_args: TRUE
[16:17:47.191]  - Getting '...' globals ...
[16:17:47.191] resolve() on list ...
[16:17:47.191]  recursive: 0
[16:17:47.191]  length: 1
[16:17:47.191]  elements: ‘...’
[16:17:47.191]  length: 0 (resolved future 1)
[16:17:47.191] resolve() on list ... DONE
[16:17:47.192]    - '...' content: [n=0] 
[16:17:47.192] List of 1
[16:17:47.192]  $ ...: list()
[16:17:47.192]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.192]  - attr(*, "where")=List of 1
[16:17:47.192]   ..$ ...:<environment: 0x55b567628d50> 
[16:17:47.192]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.192]  - attr(*, "resolved")= logi TRUE
[16:17:47.192]  - attr(*, "total_size")= num NA
[16:17:47.194]  - Getting '...' globals ... DONE
[16:17:47.194] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:47.194] List of 2
[16:17:47.194]  $ ...future.FUN:function (object, ...)  
[16:17:47.194]  $ ...          : list()
[16:17:47.194]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.194]  - attr(*, "where")=List of 2
[16:17:47.194]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:47.194]   ..$ ...          :<environment: 0x55b567628d50> 
[16:17:47.194]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.194]  - attr(*, "resolved")= logi FALSE
[16:17:47.194]  - attr(*, "total_size")= num 1240
[16:17:47.198] Packages to be attached in all futures: [n=0] 
[16:17:47.198] getGlobalsAndPackagesXApply() ... DONE
[16:17:47.198] Number of futures (= number of chunks): 1
[16:17:47.198] Launching 1 futures (chunks) ...
[16:17:47.198] Chunk #1 of 1 ...
[16:17:47.198]  - Finding globals in 'X' for chunk #1 ...
[16:17:47.199] getGlobalsAndPackages() ...
[16:17:47.199] Searching for globals...
[16:17:47.199] 
[16:17:47.199] Searching for globals ... DONE
[16:17:47.199] - globals: [0] <none>
[16:17:47.199] getGlobalsAndPackages() ... DONE
[16:17:47.199]    + additional globals found: [n=0] 
[16:17:47.200]    + additional namespaces needed: [n=0] 
[16:17:47.200]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:47.200]  - seeds: <none>
[16:17:47.200]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.200] getGlobalsAndPackages() ...
[16:17:47.200] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.200] Resolving globals: FALSE
[16:17:47.200] Tweak future expression to call with '...' arguments ...
[16:17:47.200] {
[16:17:47.200]     do.call(function(...) {
[16:17:47.200]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.200]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.200]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.200]             on.exit(options(oopts), add = TRUE)
[16:17:47.200]         }
[16:17:47.200]         {
[16:17:47.200]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.200]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.200]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.200]             })
[16:17:47.200]         }
[16:17:47.200]     }, args = future.call.arguments)
[16:17:47.200] }
[16:17:47.201] Tweak future expression to call with '...' arguments ... DONE
[16:17:47.201] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.201] 
[16:17:47.201] getGlobalsAndPackages() ... DONE
[16:17:47.201] run() for ‘Future’ ...
[16:17:47.201] - state: ‘created’
[16:17:47.202] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:17:47.202] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:47.202] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:47.202]   - Field: ‘label’
[16:17:47.202]   - Field: ‘local’
[16:17:47.202]   - Field: ‘owner’
[16:17:47.202]   - Field: ‘envir’
[16:17:47.202]   - Field: ‘packages’
[16:17:47.203]   - Field: ‘gc’
[16:17:47.203]   - Field: ‘conditions’
[16:17:47.203]   - Field: ‘expr’
[16:17:47.203]   - Field: ‘uuid’
[16:17:47.203]   - Field: ‘seed’
[16:17:47.203]   - Field: ‘version’
[16:17:47.203]   - Field: ‘result’
[16:17:47.203]   - Field: ‘asynchronous’
[16:17:47.203]   - Field: ‘calls’
[16:17:47.203]   - Field: ‘globals’
[16:17:47.203]   - Field: ‘stdout’
[16:17:47.203]   - Field: ‘earlySignal’
[16:17:47.204]   - Field: ‘lazy’
[16:17:47.204]   - Field: ‘state’
[16:17:47.204] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:47.204] - Launch lazy future ...
[16:17:47.204] Packages needed by the future expression (n = 0): <none>
[16:17:47.204] Packages needed by future strategies (n = 0): <none>
[16:17:47.204] {
[16:17:47.204]     {
[16:17:47.204]         {
[16:17:47.204]             ...future.startTime <- base::Sys.time()
[16:17:47.204]             {
[16:17:47.204]                 {
[16:17:47.204]                   {
[16:17:47.204]                     base::local({
[16:17:47.204]                       has_future <- base::requireNamespace("future", 
[16:17:47.204]                         quietly = TRUE)
[16:17:47.204]                       if (has_future) {
[16:17:47.204]                         ns <- base::getNamespace("future")
[16:17:47.204]                         version <- ns[[".package"]][["version"]]
[16:17:47.204]                         if (is.null(version)) 
[16:17:47.204]                           version <- utils::packageVersion("future")
[16:17:47.204]                       }
[16:17:47.204]                       else {
[16:17:47.204]                         version <- NULL
[16:17:47.204]                       }
[16:17:47.204]                       if (!has_future || version < "1.8.0") {
[16:17:47.204]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:47.204]                           "", base::R.version$version.string), 
[16:17:47.204]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:47.204]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:47.204]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:47.204]                             "release", "version")], collapse = " "), 
[16:17:47.204]                           hostname = base::Sys.info()[["nodename"]])
[16:17:47.204]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:47.204]                           info)
[16:17:47.204]                         info <- base::paste(info, collapse = "; ")
[16:17:47.204]                         if (!has_future) {
[16:17:47.204]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:47.204]                             info)
[16:17:47.204]                         }
[16:17:47.204]                         else {
[16:17:47.204]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:47.204]                             info, version)
[16:17:47.204]                         }
[16:17:47.204]                         base::stop(msg)
[16:17:47.204]                       }
[16:17:47.204]                     })
[16:17:47.204]                   }
[16:17:47.204]                   ...future.strategy.old <- future::plan("list")
[16:17:47.204]                   options(future.plan = NULL)
[16:17:47.204]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.204]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:47.204]                 }
[16:17:47.204]                 ...future.workdir <- getwd()
[16:17:47.204]             }
[16:17:47.204]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:47.204]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:47.204]         }
[16:17:47.204]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:47.204]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:47.204]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:47.204]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:47.204]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:47.204]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:47.204]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:47.204]             base::names(...future.oldOptions))
[16:17:47.204]     }
[16:17:47.204]     if (FALSE) {
[16:17:47.204]     }
[16:17:47.204]     else {
[16:17:47.204]         if (TRUE) {
[16:17:47.204]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:47.204]                 open = "w")
[16:17:47.204]         }
[16:17:47.204]         else {
[16:17:47.204]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:47.204]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:47.204]         }
[16:17:47.204]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:47.204]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:47.204]             base::sink(type = "output", split = FALSE)
[16:17:47.204]             base::close(...future.stdout)
[16:17:47.204]         }, add = TRUE)
[16:17:47.204]     }
[16:17:47.204]     ...future.frame <- base::sys.nframe()
[16:17:47.204]     ...future.conditions <- base::list()
[16:17:47.204]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:47.204]     if (FALSE) {
[16:17:47.204]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:47.204]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:47.204]     }
[16:17:47.204]     ...future.result <- base::tryCatch({
[16:17:47.204]         base::withCallingHandlers({
[16:17:47.204]             ...future.value <- base::withVisible(base::local({
[16:17:47.204]                 do.call(function(...) {
[16:17:47.204]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.204]                   if (!identical(...future.globals.maxSize.org, 
[16:17:47.204]                     ...future.globals.maxSize)) {
[16:17:47.204]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.204]                     on.exit(options(oopts), add = TRUE)
[16:17:47.204]                   }
[16:17:47.204]                   {
[16:17:47.204]                     lapply(seq_along(...future.elements_ii), 
[16:17:47.204]                       FUN = function(jj) {
[16:17:47.204]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.204]                         ...future.FUN(...future.X_jj, ...)
[16:17:47.204]                       })
[16:17:47.204]                   }
[16:17:47.204]                 }, args = future.call.arguments)
[16:17:47.204]             }))
[16:17:47.204]             future::FutureResult(value = ...future.value$value, 
[16:17:47.204]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.204]                   ...future.rng), globalenv = if (FALSE) 
[16:17:47.204]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:47.204]                     ...future.globalenv.names))
[16:17:47.204]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:47.204]         }, condition = base::local({
[16:17:47.204]             c <- base::c
[16:17:47.204]             inherits <- base::inherits
[16:17:47.204]             invokeRestart <- base::invokeRestart
[16:17:47.204]             length <- base::length
[16:17:47.204]             list <- base::list
[16:17:47.204]             seq.int <- base::seq.int
[16:17:47.204]             signalCondition <- base::signalCondition
[16:17:47.204]             sys.calls <- base::sys.calls
[16:17:47.204]             `[[` <- base::`[[`
[16:17:47.204]             `+` <- base::`+`
[16:17:47.204]             `<<-` <- base::`<<-`
[16:17:47.204]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:47.204]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:47.204]                   3L)]
[16:17:47.204]             }
[16:17:47.204]             function(cond) {
[16:17:47.204]                 is_error <- inherits(cond, "error")
[16:17:47.204]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:47.204]                   NULL)
[16:17:47.204]                 if (is_error) {
[16:17:47.204]                   sessionInformation <- function() {
[16:17:47.204]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:47.204]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:47.204]                       search = base::search(), system = base::Sys.info())
[16:17:47.204]                   }
[16:17:47.204]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.204]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:47.204]                     cond$call), session = sessionInformation(), 
[16:17:47.204]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:47.204]                   signalCondition(cond)
[16:17:47.204]                 }
[16:17:47.204]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:47.204]                 "immediateCondition"))) {
[16:17:47.204]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:47.204]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.204]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:47.204]                   if (TRUE && !signal) {
[16:17:47.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.204]                     {
[16:17:47.204]                       inherits <- base::inherits
[16:17:47.204]                       invokeRestart <- base::invokeRestart
[16:17:47.204]                       is.null <- base::is.null
[16:17:47.204]                       muffled <- FALSE
[16:17:47.204]                       if (inherits(cond, "message")) {
[16:17:47.204]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.204]                         if (muffled) 
[16:17:47.204]                           invokeRestart("muffleMessage")
[16:17:47.204]                       }
[16:17:47.204]                       else if (inherits(cond, "warning")) {
[16:17:47.204]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.204]                         if (muffled) 
[16:17:47.204]                           invokeRestart("muffleWarning")
[16:17:47.204]                       }
[16:17:47.204]                       else if (inherits(cond, "condition")) {
[16:17:47.204]                         if (!is.null(pattern)) {
[16:17:47.204]                           computeRestarts <- base::computeRestarts
[16:17:47.204]                           grepl <- base::grepl
[16:17:47.204]                           restarts <- computeRestarts(cond)
[16:17:47.204]                           for (restart in restarts) {
[16:17:47.204]                             name <- restart$name
[16:17:47.204]                             if (is.null(name)) 
[16:17:47.204]                               next
[16:17:47.204]                             if (!grepl(pattern, name)) 
[16:17:47.204]                               next
[16:17:47.204]                             invokeRestart(restart)
[16:17:47.204]                             muffled <- TRUE
[16:17:47.204]                             break
[16:17:47.204]                           }
[16:17:47.204]                         }
[16:17:47.204]                       }
[16:17:47.204]                       invisible(muffled)
[16:17:47.204]                     }
[16:17:47.204]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.204]                   }
[16:17:47.204]                 }
[16:17:47.204]                 else {
[16:17:47.204]                   if (TRUE) {
[16:17:47.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.204]                     {
[16:17:47.204]                       inherits <- base::inherits
[16:17:47.204]                       invokeRestart <- base::invokeRestart
[16:17:47.204]                       is.null <- base::is.null
[16:17:47.204]                       muffled <- FALSE
[16:17:47.204]                       if (inherits(cond, "message")) {
[16:17:47.204]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.204]                         if (muffled) 
[16:17:47.204]                           invokeRestart("muffleMessage")
[16:17:47.204]                       }
[16:17:47.204]                       else if (inherits(cond, "warning")) {
[16:17:47.204]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.204]                         if (muffled) 
[16:17:47.204]                           invokeRestart("muffleWarning")
[16:17:47.204]                       }
[16:17:47.204]                       else if (inherits(cond, "condition")) {
[16:17:47.204]                         if (!is.null(pattern)) {
[16:17:47.204]                           computeRestarts <- base::computeRestarts
[16:17:47.204]                           grepl <- base::grepl
[16:17:47.204]                           restarts <- computeRestarts(cond)
[16:17:47.204]                           for (restart in restarts) {
[16:17:47.204]                             name <- restart$name
[16:17:47.204]                             if (is.null(name)) 
[16:17:47.204]                               next
[16:17:47.204]                             if (!grepl(pattern, name)) 
[16:17:47.204]                               next
[16:17:47.204]                             invokeRestart(restart)
[16:17:47.204]                             muffled <- TRUE
[16:17:47.204]                             break
[16:17:47.204]                           }
[16:17:47.204]                         }
[16:17:47.204]                       }
[16:17:47.204]                       invisible(muffled)
[16:17:47.204]                     }
[16:17:47.204]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.204]                   }
[16:17:47.204]                 }
[16:17:47.204]             }
[16:17:47.204]         }))
[16:17:47.204]     }, error = function(ex) {
[16:17:47.204]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:47.204]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.204]                 ...future.rng), started = ...future.startTime, 
[16:17:47.204]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:47.204]             version = "1.8"), class = "FutureResult")
[16:17:47.204]     }, finally = {
[16:17:47.204]         if (!identical(...future.workdir, getwd())) 
[16:17:47.204]             setwd(...future.workdir)
[16:17:47.204]         {
[16:17:47.204]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:47.204]                 ...future.oldOptions$nwarnings <- NULL
[16:17:47.204]             }
[16:17:47.204]             base::options(...future.oldOptions)
[16:17:47.204]             if (.Platform$OS.type == "windows") {
[16:17:47.204]                 old_names <- names(...future.oldEnvVars)
[16:17:47.204]                 envs <- base::Sys.getenv()
[16:17:47.204]                 names <- names(envs)
[16:17:47.204]                 common <- intersect(names, old_names)
[16:17:47.204]                 added <- setdiff(names, old_names)
[16:17:47.204]                 removed <- setdiff(old_names, names)
[16:17:47.204]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:47.204]                   envs[common]]
[16:17:47.204]                 NAMES <- toupper(changed)
[16:17:47.204]                 args <- list()
[16:17:47.204]                 for (kk in seq_along(NAMES)) {
[16:17:47.204]                   name <- changed[[kk]]
[16:17:47.204]                   NAME <- NAMES[[kk]]
[16:17:47.204]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.204]                     next
[16:17:47.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.204]                 }
[16:17:47.204]                 NAMES <- toupper(added)
[16:17:47.204]                 for (kk in seq_along(NAMES)) {
[16:17:47.204]                   name <- added[[kk]]
[16:17:47.204]                   NAME <- NAMES[[kk]]
[16:17:47.204]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.204]                     next
[16:17:47.204]                   args[[name]] <- ""
[16:17:47.204]                 }
[16:17:47.204]                 NAMES <- toupper(removed)
[16:17:47.204]                 for (kk in seq_along(NAMES)) {
[16:17:47.204]                   name <- removed[[kk]]
[16:17:47.204]                   NAME <- NAMES[[kk]]
[16:17:47.204]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.204]                     next
[16:17:47.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.204]                 }
[16:17:47.204]                 if (length(args) > 0) 
[16:17:47.204]                   base::do.call(base::Sys.setenv, args = args)
[16:17:47.204]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:47.204]             }
[16:17:47.204]             else {
[16:17:47.204]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:47.204]             }
[16:17:47.204]             {
[16:17:47.204]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:47.204]                   0L) {
[16:17:47.204]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:47.204]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:47.204]                   base::options(opts)
[16:17:47.204]                 }
[16:17:47.204]                 {
[16:17:47.204]                   {
[16:17:47.204]                     NULL
[16:17:47.204]                     RNGkind("Mersenne-Twister")
[16:17:47.204]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:47.204]                       inherits = FALSE)
[16:17:47.204]                   }
[16:17:47.204]                   options(future.plan = NULL)
[16:17:47.204]                   if (is.na(NA_character_)) 
[16:17:47.204]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.204]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:47.204]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:47.204]                     .init = FALSE)
[16:17:47.204]                 }
[16:17:47.204]             }
[16:17:47.204]         }
[16:17:47.204]     })
[16:17:47.204]     if (TRUE) {
[16:17:47.204]         base::sink(type = "output", split = FALSE)
[16:17:47.204]         if (TRUE) {
[16:17:47.204]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:47.204]         }
[16:17:47.204]         else {
[16:17:47.204]             ...future.result["stdout"] <- base::list(NULL)
[16:17:47.204]         }
[16:17:47.204]         base::close(...future.stdout)
[16:17:47.204]         ...future.stdout <- NULL
[16:17:47.204]     }
[16:17:47.204]     ...future.result$conditions <- ...future.conditions
[16:17:47.204]     ...future.result$finished <- base::Sys.time()
[16:17:47.204]     ...future.result
[16:17:47.204] }
[16:17:47.206] assign_globals() ...
[16:17:47.206] List of 5
[16:17:47.206]  $ ...future.FUN            :function (object, ...)  
[16:17:47.206]  $ future.call.arguments    : list()
[16:17:47.206]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.206]  $ ...future.elements_ii    :List of 3
[16:17:47.206]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:47.206]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:17:47.206]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.206]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:47.206]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:47.206]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:17:47.206]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.206]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:17:47.206]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:47.206]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:17:47.206]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.206]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:17:47.206]  $ ...future.seeds_ii       : NULL
[16:17:47.206]  $ ...future.globals.maxSize: NULL
[16:17:47.206]  - attr(*, "where")=List of 5
[16:17:47.206]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:47.206]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:47.206]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:47.206]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:47.206]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:47.206]  - attr(*, "resolved")= logi FALSE
[16:17:47.206]  - attr(*, "total_size")= num 1240
[16:17:47.206]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.206]  - attr(*, "already-done")= logi TRUE
[16:17:47.215] - copied ‘...future.FUN’ to environment
[16:17:47.215] - copied ‘future.call.arguments’ to environment
[16:17:47.215] - copied ‘...future.elements_ii’ to environment
[16:17:47.216] - copied ‘...future.seeds_ii’ to environment
[16:17:47.216] - copied ‘...future.globals.maxSize’ to environment
[16:17:47.216] assign_globals() ... done
[16:17:47.216] plan(): Setting new future strategy stack:
[16:17:47.216] List of future strategies:
[16:17:47.216] 1. sequential:
[16:17:47.216]    - args: function (..., envir = parent.frame())
[16:17:47.216]    - tweaked: FALSE
[16:17:47.216]    - call: NULL
[16:17:47.216] plan(): nbrOfWorkers() = 1
[16:17:47.219] plan(): Setting new future strategy stack:
[16:17:47.219] List of future strategies:
[16:17:47.219] 1. sequential:
[16:17:47.219]    - args: function (..., envir = parent.frame())
[16:17:47.219]    - tweaked: FALSE
[16:17:47.219]    - call: plan(strategy)
[16:17:47.219] plan(): nbrOfWorkers() = 1
[16:17:47.219] SequentialFuture started (and completed)
[16:17:47.219] - Launch lazy future ... done
[16:17:47.219] run() for ‘SequentialFuture’ ... done
[16:17:47.219] Created future:
[16:17:47.220] SequentialFuture:
[16:17:47.220] Label: ‘future_by-1’
[16:17:47.220] Expression:
[16:17:47.220] {
[16:17:47.220]     do.call(function(...) {
[16:17:47.220]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.220]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.220]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.220]             on.exit(options(oopts), add = TRUE)
[16:17:47.220]         }
[16:17:47.220]         {
[16:17:47.220]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.220]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.220]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.220]             })
[16:17:47.220]         }
[16:17:47.220]     }, args = future.call.arguments)
[16:17:47.220] }
[16:17:47.220] Lazy evaluation: FALSE
[16:17:47.220] Asynchronous evaluation: FALSE
[16:17:47.220] Local evaluation: TRUE
[16:17:47.220] Environment: 0x55b567589ba0
[16:17:47.220] Capture standard output: TRUE
[16:17:47.220] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:47.220] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:47.220] Packages: <none>
[16:17:47.220] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:47.220] Resolved: TRUE
[16:17:47.220] Value: 5.37 KiB of class ‘list’
[16:17:47.220] Early signaling: FALSE
[16:17:47.220] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:47.220] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:47.221] Chunk #1 of 1 ... DONE
[16:17:47.221] Launching 1 futures (chunks) ... DONE
[16:17:47.221] Resolving 1 futures (chunks) ...
[16:17:47.221] resolve() on list ...
[16:17:47.221]  recursive: 0
[16:17:47.221]  length: 1
[16:17:47.221] 
[16:17:47.221] resolved() for ‘SequentialFuture’ ...
[16:17:47.222] - state: ‘finished’
[16:17:47.222] - run: TRUE
[16:17:47.222] - result: ‘FutureResult’
[16:17:47.222] resolved() for ‘SequentialFuture’ ... done
[16:17:47.222] Future #1
[16:17:47.222] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:47.222] - nx: 1
[16:17:47.222] - relay: TRUE
[16:17:47.222] - stdout: TRUE
[16:17:47.222] - signal: TRUE
[16:17:47.222] - resignal: FALSE
[16:17:47.222] - force: TRUE
[16:17:47.223] - relayed: [n=1] FALSE
[16:17:47.223] - queued futures: [n=1] FALSE
[16:17:47.223]  - until=1
[16:17:47.223]  - relaying element #1
[16:17:47.223] - relayed: [n=1] TRUE
[16:17:47.223] - queued futures: [n=1] TRUE
[16:17:47.223] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:47.223]  length: 0 (resolved future 1)
[16:17:47.223] Relaying remaining futures
[16:17:47.223] signalConditionsASAP(NULL, pos=0) ...
[16:17:47.224] - nx: 1
[16:17:47.224] - relay: TRUE
[16:17:47.224] - stdout: TRUE
[16:17:47.224] - signal: TRUE
[16:17:47.224] - resignal: FALSE
[16:17:47.224] - force: TRUE
[16:17:47.224] - relayed: [n=1] TRUE
[16:17:47.224] - queued futures: [n=1] TRUE
 - flush all
[16:17:47.224] - relayed: [n=1] TRUE
[16:17:47.224] - queued futures: [n=1] TRUE
[16:17:47.224] signalConditionsASAP(NULL, pos=0) ... done
[16:17:47.224] resolve() on list ... DONE
[16:17:47.225]  - Number of value chunks collected: 1
[16:17:47.225] Resolving 1 futures (chunks) ... DONE
[16:17:47.225] Reducing values from 1 chunks ...
[16:17:47.225]  - Number of values collected after concatenation: 3
[16:17:47.225]  - Number of values expected: 3
[16:17:47.225] Reducing values from 1 chunks ... DONE
[16:17:47.225] future_lapply() ... DONE
[16:17:47.225] future_by_internal() ... DONE
[16:17:47.226] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[16:17:47.226] future_lapply() ...
[16:17:47.227] Number of chunks: 1
[16:17:47.227] getGlobalsAndPackagesXApply() ...
[16:17:47.227]  - future.globals: TRUE
[16:17:47.227] getGlobalsAndPackages() ...
[16:17:47.227] Searching for globals...
[16:17:47.228] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:47.228] Searching for globals ... DONE
[16:17:47.228] Resolving globals: FALSE
[16:17:47.229] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:47.229] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:47.229] - globals: [1] ‘FUN’
[16:17:47.229] 
[16:17:47.229] getGlobalsAndPackages() ... DONE
[16:17:47.229]  - globals found/used: [n=1] ‘FUN’
[16:17:47.229]  - needed namespaces: [n=0] 
[16:17:47.230] Finding globals ... DONE
[16:17:47.230]  - use_args: TRUE
[16:17:47.230]  - Getting '...' globals ...
[16:17:47.230] resolve() on list ...
[16:17:47.230]  recursive: 0
[16:17:47.230]  length: 1
[16:17:47.230]  elements: ‘...’
[16:17:47.230]  length: 0 (resolved future 1)
[16:17:47.230] resolve() on list ... DONE
[16:17:47.231]    - '...' content: [n=0] 
[16:17:47.231] List of 1
[16:17:47.231]  $ ...: list()
[16:17:47.231]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.231]  - attr(*, "where")=List of 1
[16:17:47.231]   ..$ ...:<environment: 0x55b567c99a10> 
[16:17:47.231]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.231]  - attr(*, "resolved")= logi TRUE
[16:17:47.231]  - attr(*, "total_size")= num NA
[16:17:47.234]  - Getting '...' globals ... DONE
[16:17:47.234] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:47.234] List of 2
[16:17:47.234]  $ ...future.FUN:function (object, ...)  
[16:17:47.234]  $ ...          : list()
[16:17:47.234]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.234]  - attr(*, "where")=List of 2
[16:17:47.234]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:47.234]   ..$ ...          :<environment: 0x55b567c99a10> 
[16:17:47.234]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.234]  - attr(*, "resolved")= logi FALSE
[16:17:47.234]  - attr(*, "total_size")= num 1240
[16:17:47.237] Packages to be attached in all futures: [n=0] 
[16:17:47.237] getGlobalsAndPackagesXApply() ... DONE
[16:17:47.237] Number of futures (= number of chunks): 1
[16:17:47.237] Launching 1 futures (chunks) ...
[16:17:47.237] Chunk #1 of 1 ...
[16:17:47.238]  - Finding globals in 'X' for chunk #1 ...
[16:17:47.238] getGlobalsAndPackages() ...
[16:17:47.238] Searching for globals...
[16:17:47.238] 
[16:17:47.238] Searching for globals ... DONE
[16:17:47.238] - globals: [0] <none>
[16:17:47.238] getGlobalsAndPackages() ... DONE
[16:17:47.239]    + additional globals found: [n=0] 
[16:17:47.239]    + additional namespaces needed: [n=0] 
[16:17:47.239]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:47.239]  - seeds: <none>
[16:17:47.239]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.239] getGlobalsAndPackages() ...
[16:17:47.239] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.239] Resolving globals: FALSE
[16:17:47.239] Tweak future expression to call with '...' arguments ...
[16:17:47.239] {
[16:17:47.239]     do.call(function(...) {
[16:17:47.239]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.239]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.239]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.239]             on.exit(options(oopts), add = TRUE)
[16:17:47.239]         }
[16:17:47.239]         {
[16:17:47.239]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.239]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.239]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.239]             })
[16:17:47.239]         }
[16:17:47.239]     }, args = future.call.arguments)
[16:17:47.239] }
[16:17:47.240] Tweak future expression to call with '...' arguments ... DONE
[16:17:47.240] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.240] 
[16:17:47.240] getGlobalsAndPackages() ... DONE
[16:17:47.240] run() for ‘Future’ ...
[16:17:47.241] - state: ‘created’
[16:17:47.241] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:17:47.241] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:47.241] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:47.241]   - Field: ‘label’
[16:17:47.241]   - Field: ‘local’
[16:17:47.241]   - Field: ‘owner’
[16:17:47.241]   - Field: ‘envir’
[16:17:47.242]   - Field: ‘packages’
[16:17:47.242]   - Field: ‘gc’
[16:17:47.242]   - Field: ‘conditions’
[16:17:47.242]   - Field: ‘expr’
[16:17:47.242]   - Field: ‘uuid’
[16:17:47.242]   - Field: ‘seed’
[16:17:47.242]   - Field: ‘version’
[16:17:47.242]   - Field: ‘result’
[16:17:47.242]   - Field: ‘asynchronous’
[16:17:47.242]   - Field: ‘calls’
[16:17:47.242]   - Field: ‘globals’
[16:17:47.242]   - Field: ‘stdout’
[16:17:47.243]   - Field: ‘earlySignal’
[16:17:47.243]   - Field: ‘lazy’
[16:17:47.243]   - Field: ‘state’
[16:17:47.243] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:47.243] - Launch lazy future ...
[16:17:47.243] Packages needed by the future expression (n = 0): <none>
[16:17:47.243] Packages needed by future strategies (n = 0): <none>
[16:17:47.244] {
[16:17:47.244]     {
[16:17:47.244]         {
[16:17:47.244]             ...future.startTime <- base::Sys.time()
[16:17:47.244]             {
[16:17:47.244]                 {
[16:17:47.244]                   {
[16:17:47.244]                     base::local({
[16:17:47.244]                       has_future <- base::requireNamespace("future", 
[16:17:47.244]                         quietly = TRUE)
[16:17:47.244]                       if (has_future) {
[16:17:47.244]                         ns <- base::getNamespace("future")
[16:17:47.244]                         version <- ns[[".package"]][["version"]]
[16:17:47.244]                         if (is.null(version)) 
[16:17:47.244]                           version <- utils::packageVersion("future")
[16:17:47.244]                       }
[16:17:47.244]                       else {
[16:17:47.244]                         version <- NULL
[16:17:47.244]                       }
[16:17:47.244]                       if (!has_future || version < "1.8.0") {
[16:17:47.244]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:47.244]                           "", base::R.version$version.string), 
[16:17:47.244]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:47.244]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:47.244]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:47.244]                             "release", "version")], collapse = " "), 
[16:17:47.244]                           hostname = base::Sys.info()[["nodename"]])
[16:17:47.244]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:47.244]                           info)
[16:17:47.244]                         info <- base::paste(info, collapse = "; ")
[16:17:47.244]                         if (!has_future) {
[16:17:47.244]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:47.244]                             info)
[16:17:47.244]                         }
[16:17:47.244]                         else {
[16:17:47.244]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:47.244]                             info, version)
[16:17:47.244]                         }
[16:17:47.244]                         base::stop(msg)
[16:17:47.244]                       }
[16:17:47.244]                     })
[16:17:47.244]                   }
[16:17:47.244]                   ...future.strategy.old <- future::plan("list")
[16:17:47.244]                   options(future.plan = NULL)
[16:17:47.244]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.244]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:47.244]                 }
[16:17:47.244]                 ...future.workdir <- getwd()
[16:17:47.244]             }
[16:17:47.244]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:47.244]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:47.244]         }
[16:17:47.244]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:47.244]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:47.244]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:47.244]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:47.244]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:47.244]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:47.244]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:47.244]             base::names(...future.oldOptions))
[16:17:47.244]     }
[16:17:47.244]     if (FALSE) {
[16:17:47.244]     }
[16:17:47.244]     else {
[16:17:47.244]         if (TRUE) {
[16:17:47.244]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:47.244]                 open = "w")
[16:17:47.244]         }
[16:17:47.244]         else {
[16:17:47.244]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:47.244]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:47.244]         }
[16:17:47.244]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:47.244]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:47.244]             base::sink(type = "output", split = FALSE)
[16:17:47.244]             base::close(...future.stdout)
[16:17:47.244]         }, add = TRUE)
[16:17:47.244]     }
[16:17:47.244]     ...future.frame <- base::sys.nframe()
[16:17:47.244]     ...future.conditions <- base::list()
[16:17:47.244]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:47.244]     if (FALSE) {
[16:17:47.244]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:47.244]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:47.244]     }
[16:17:47.244]     ...future.result <- base::tryCatch({
[16:17:47.244]         base::withCallingHandlers({
[16:17:47.244]             ...future.value <- base::withVisible(base::local({
[16:17:47.244]                 do.call(function(...) {
[16:17:47.244]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.244]                   if (!identical(...future.globals.maxSize.org, 
[16:17:47.244]                     ...future.globals.maxSize)) {
[16:17:47.244]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.244]                     on.exit(options(oopts), add = TRUE)
[16:17:47.244]                   }
[16:17:47.244]                   {
[16:17:47.244]                     lapply(seq_along(...future.elements_ii), 
[16:17:47.244]                       FUN = function(jj) {
[16:17:47.244]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.244]                         ...future.FUN(...future.X_jj, ...)
[16:17:47.244]                       })
[16:17:47.244]                   }
[16:17:47.244]                 }, args = future.call.arguments)
[16:17:47.244]             }))
[16:17:47.244]             future::FutureResult(value = ...future.value$value, 
[16:17:47.244]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.244]                   ...future.rng), globalenv = if (FALSE) 
[16:17:47.244]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:47.244]                     ...future.globalenv.names))
[16:17:47.244]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:47.244]         }, condition = base::local({
[16:17:47.244]             c <- base::c
[16:17:47.244]             inherits <- base::inherits
[16:17:47.244]             invokeRestart <- base::invokeRestart
[16:17:47.244]             length <- base::length
[16:17:47.244]             list <- base::list
[16:17:47.244]             seq.int <- base::seq.int
[16:17:47.244]             signalCondition <- base::signalCondition
[16:17:47.244]             sys.calls <- base::sys.calls
[16:17:47.244]             `[[` <- base::`[[`
[16:17:47.244]             `+` <- base::`+`
[16:17:47.244]             `<<-` <- base::`<<-`
[16:17:47.244]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:47.244]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:47.244]                   3L)]
[16:17:47.244]             }
[16:17:47.244]             function(cond) {
[16:17:47.244]                 is_error <- inherits(cond, "error")
[16:17:47.244]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:47.244]                   NULL)
[16:17:47.244]                 if (is_error) {
[16:17:47.244]                   sessionInformation <- function() {
[16:17:47.244]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:47.244]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:47.244]                       search = base::search(), system = base::Sys.info())
[16:17:47.244]                   }
[16:17:47.244]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.244]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:47.244]                     cond$call), session = sessionInformation(), 
[16:17:47.244]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:47.244]                   signalCondition(cond)
[16:17:47.244]                 }
[16:17:47.244]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:47.244]                 "immediateCondition"))) {
[16:17:47.244]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:47.244]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.244]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:47.244]                   if (TRUE && !signal) {
[16:17:47.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.244]                     {
[16:17:47.244]                       inherits <- base::inherits
[16:17:47.244]                       invokeRestart <- base::invokeRestart
[16:17:47.244]                       is.null <- base::is.null
[16:17:47.244]                       muffled <- FALSE
[16:17:47.244]                       if (inherits(cond, "message")) {
[16:17:47.244]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.244]                         if (muffled) 
[16:17:47.244]                           invokeRestart("muffleMessage")
[16:17:47.244]                       }
[16:17:47.244]                       else if (inherits(cond, "warning")) {
[16:17:47.244]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.244]                         if (muffled) 
[16:17:47.244]                           invokeRestart("muffleWarning")
[16:17:47.244]                       }
[16:17:47.244]                       else if (inherits(cond, "condition")) {
[16:17:47.244]                         if (!is.null(pattern)) {
[16:17:47.244]                           computeRestarts <- base::computeRestarts
[16:17:47.244]                           grepl <- base::grepl
[16:17:47.244]                           restarts <- computeRestarts(cond)
[16:17:47.244]                           for (restart in restarts) {
[16:17:47.244]                             name <- restart$name
[16:17:47.244]                             if (is.null(name)) 
[16:17:47.244]                               next
[16:17:47.244]                             if (!grepl(pattern, name)) 
[16:17:47.244]                               next
[16:17:47.244]                             invokeRestart(restart)
[16:17:47.244]                             muffled <- TRUE
[16:17:47.244]                             break
[16:17:47.244]                           }
[16:17:47.244]                         }
[16:17:47.244]                       }
[16:17:47.244]                       invisible(muffled)
[16:17:47.244]                     }
[16:17:47.244]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.244]                   }
[16:17:47.244]                 }
[16:17:47.244]                 else {
[16:17:47.244]                   if (TRUE) {
[16:17:47.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.244]                     {
[16:17:47.244]                       inherits <- base::inherits
[16:17:47.244]                       invokeRestart <- base::invokeRestart
[16:17:47.244]                       is.null <- base::is.null
[16:17:47.244]                       muffled <- FALSE
[16:17:47.244]                       if (inherits(cond, "message")) {
[16:17:47.244]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.244]                         if (muffled) 
[16:17:47.244]                           invokeRestart("muffleMessage")
[16:17:47.244]                       }
[16:17:47.244]                       else if (inherits(cond, "warning")) {
[16:17:47.244]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.244]                         if (muffled) 
[16:17:47.244]                           invokeRestart("muffleWarning")
[16:17:47.244]                       }
[16:17:47.244]                       else if (inherits(cond, "condition")) {
[16:17:47.244]                         if (!is.null(pattern)) {
[16:17:47.244]                           computeRestarts <- base::computeRestarts
[16:17:47.244]                           grepl <- base::grepl
[16:17:47.244]                           restarts <- computeRestarts(cond)
[16:17:47.244]                           for (restart in restarts) {
[16:17:47.244]                             name <- restart$name
[16:17:47.244]                             if (is.null(name)) 
[16:17:47.244]                               next
[16:17:47.244]                             if (!grepl(pattern, name)) 
[16:17:47.244]                               next
[16:17:47.244]                             invokeRestart(restart)
[16:17:47.244]                             muffled <- TRUE
[16:17:47.244]                             break
[16:17:47.244]                           }
[16:17:47.244]                         }
[16:17:47.244]                       }
[16:17:47.244]                       invisible(muffled)
[16:17:47.244]                     }
[16:17:47.244]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.244]                   }
[16:17:47.244]                 }
[16:17:47.244]             }
[16:17:47.244]         }))
[16:17:47.244]     }, error = function(ex) {
[16:17:47.244]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:47.244]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.244]                 ...future.rng), started = ...future.startTime, 
[16:17:47.244]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:47.244]             version = "1.8"), class = "FutureResult")
[16:17:47.244]     }, finally = {
[16:17:47.244]         if (!identical(...future.workdir, getwd())) 
[16:17:47.244]             setwd(...future.workdir)
[16:17:47.244]         {
[16:17:47.244]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:47.244]                 ...future.oldOptions$nwarnings <- NULL
[16:17:47.244]             }
[16:17:47.244]             base::options(...future.oldOptions)
[16:17:47.244]             if (.Platform$OS.type == "windows") {
[16:17:47.244]                 old_names <- names(...future.oldEnvVars)
[16:17:47.244]                 envs <- base::Sys.getenv()
[16:17:47.244]                 names <- names(envs)
[16:17:47.244]                 common <- intersect(names, old_names)
[16:17:47.244]                 added <- setdiff(names, old_names)
[16:17:47.244]                 removed <- setdiff(old_names, names)
[16:17:47.244]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:47.244]                   envs[common]]
[16:17:47.244]                 NAMES <- toupper(changed)
[16:17:47.244]                 args <- list()
[16:17:47.244]                 for (kk in seq_along(NAMES)) {
[16:17:47.244]                   name <- changed[[kk]]
[16:17:47.244]                   NAME <- NAMES[[kk]]
[16:17:47.244]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.244]                     next
[16:17:47.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.244]                 }
[16:17:47.244]                 NAMES <- toupper(added)
[16:17:47.244]                 for (kk in seq_along(NAMES)) {
[16:17:47.244]                   name <- added[[kk]]
[16:17:47.244]                   NAME <- NAMES[[kk]]
[16:17:47.244]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.244]                     next
[16:17:47.244]                   args[[name]] <- ""
[16:17:47.244]                 }
[16:17:47.244]                 NAMES <- toupper(removed)
[16:17:47.244]                 for (kk in seq_along(NAMES)) {
[16:17:47.244]                   name <- removed[[kk]]
[16:17:47.244]                   NAME <- NAMES[[kk]]
[16:17:47.244]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.244]                     next
[16:17:47.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.244]                 }
[16:17:47.244]                 if (length(args) > 0) 
[16:17:47.244]                   base::do.call(base::Sys.setenv, args = args)
[16:17:47.244]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:47.244]             }
[16:17:47.244]             else {
[16:17:47.244]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:47.244]             }
[16:17:47.244]             {
[16:17:47.244]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:47.244]                   0L) {
[16:17:47.244]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:47.244]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:47.244]                   base::options(opts)
[16:17:47.244]                 }
[16:17:47.244]                 {
[16:17:47.244]                   {
[16:17:47.244]                     NULL
[16:17:47.244]                     RNGkind("Mersenne-Twister")
[16:17:47.244]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:47.244]                       inherits = FALSE)
[16:17:47.244]                   }
[16:17:47.244]                   options(future.plan = NULL)
[16:17:47.244]                   if (is.na(NA_character_)) 
[16:17:47.244]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.244]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:47.244]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:47.244]                     .init = FALSE)
[16:17:47.244]                 }
[16:17:47.244]             }
[16:17:47.244]         }
[16:17:47.244]     })
[16:17:47.244]     if (TRUE) {
[16:17:47.244]         base::sink(type = "output", split = FALSE)
[16:17:47.244]         if (TRUE) {
[16:17:47.244]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:47.244]         }
[16:17:47.244]         else {
[16:17:47.244]             ...future.result["stdout"] <- base::list(NULL)
[16:17:47.244]         }
[16:17:47.244]         base::close(...future.stdout)
[16:17:47.244]         ...future.stdout <- NULL
[16:17:47.244]     }
[16:17:47.244]     ...future.result$conditions <- ...future.conditions
[16:17:47.244]     ...future.result$finished <- base::Sys.time()
[16:17:47.244]     ...future.result
[16:17:47.244] }
[16:17:47.245] assign_globals() ...
[16:17:47.245] List of 5
[16:17:47.245]  $ ...future.FUN            :function (object, ...)  
[16:17:47.245]  $ future.call.arguments    : list()
[16:17:47.245]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.245]  $ ...future.elements_ii    :List of 3
[16:17:47.245]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:47.245]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:17:47.245]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.245]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:47.245]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:47.245]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:17:47.245]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.245]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:17:47.245]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:47.245]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:17:47.245]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.245]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:17:47.245]  $ ...future.seeds_ii       : NULL
[16:17:47.245]  $ ...future.globals.maxSize: NULL
[16:17:47.245]  - attr(*, "where")=List of 5
[16:17:47.245]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:47.245]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:47.245]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:47.245]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:47.245]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:47.245]  - attr(*, "resolved")= logi FALSE
[16:17:47.245]  - attr(*, "total_size")= num 1240
[16:17:47.245]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.245]  - attr(*, "already-done")= logi TRUE
[16:17:47.255] - copied ‘...future.FUN’ to environment
[16:17:47.255] - copied ‘future.call.arguments’ to environment
[16:17:47.255] - copied ‘...future.elements_ii’ to environment
[16:17:47.255] - copied ‘...future.seeds_ii’ to environment
[16:17:47.255] - copied ‘...future.globals.maxSize’ to environment
[16:17:47.255] assign_globals() ... done
[16:17:47.255] plan(): Setting new future strategy stack:
[16:17:47.255] List of future strategies:
[16:17:47.255] 1. sequential:
[16:17:47.255]    - args: function (..., envir = parent.frame())
[16:17:47.255]    - tweaked: FALSE
[16:17:47.255]    - call: NULL
[16:17:47.256] plan(): nbrOfWorkers() = 1
[16:17:47.258] plan(): Setting new future strategy stack:
[16:17:47.258] List of future strategies:
[16:17:47.258] 1. sequential:
[16:17:47.258]    - args: function (..., envir = parent.frame())
[16:17:47.258]    - tweaked: FALSE
[16:17:47.258]    - call: plan(strategy)
[16:17:47.258] plan(): nbrOfWorkers() = 1
[16:17:47.258] SequentialFuture started (and completed)
[16:17:47.258] - Launch lazy future ... done
[16:17:47.259] run() for ‘SequentialFuture’ ... done
[16:17:47.259] Created future:
[16:17:47.259] SequentialFuture:
[16:17:47.259] Label: ‘future_by-1’
[16:17:47.259] Expression:
[16:17:47.259] {
[16:17:47.259]     do.call(function(...) {
[16:17:47.259]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.259]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.259]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.259]             on.exit(options(oopts), add = TRUE)
[16:17:47.259]         }
[16:17:47.259]         {
[16:17:47.259]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.259]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.259]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.259]             })
[16:17:47.259]         }
[16:17:47.259]     }, args = future.call.arguments)
[16:17:47.259] }
[16:17:47.259] Lazy evaluation: FALSE
[16:17:47.259] Asynchronous evaluation: FALSE
[16:17:47.259] Local evaluation: TRUE
[16:17:47.259] Environment: 0x55b567c42580
[16:17:47.259] Capture standard output: TRUE
[16:17:47.259] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:47.259] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:47.259] Packages: <none>
[16:17:47.259] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:47.259] Resolved: TRUE
[16:17:47.259] Value: 5.37 KiB of class ‘list’
[16:17:47.259] Early signaling: FALSE
[16:17:47.259] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:47.259] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:47.260] Chunk #1 of 1 ... DONE
[16:17:47.260] Launching 1 futures (chunks) ... DONE
[16:17:47.260] Resolving 1 futures (chunks) ...
[16:17:47.260] resolve() on list ...
[16:17:47.260]  recursive: 0
[16:17:47.260]  length: 1
[16:17:47.261] 
[16:17:47.261] resolved() for ‘SequentialFuture’ ...
[16:17:47.261] - state: ‘finished’
[16:17:47.261] - run: TRUE
[16:17:47.261] - result: ‘FutureResult’
[16:17:47.261] resolved() for ‘SequentialFuture’ ... done
[16:17:47.261] Future #1
[16:17:47.261] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:47.261] - nx: 1
[16:17:47.261] - relay: TRUE
[16:17:47.261] - stdout: TRUE
[16:17:47.262] - signal: TRUE
[16:17:47.262] - resignal: FALSE
[16:17:47.262] - force: TRUE
[16:17:47.262] - relayed: [n=1] FALSE
[16:17:47.262] - queued futures: [n=1] FALSE
[16:17:47.262]  - until=1
[16:17:47.262]  - relaying element #1
[16:17:47.262] - relayed: [n=1] TRUE
[16:17:47.262] - queued futures: [n=1] TRUE
[16:17:47.262] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:47.262]  length: 0 (resolved future 1)
[16:17:47.263] Relaying remaining futures
[16:17:47.263] signalConditionsASAP(NULL, pos=0) ...
[16:17:47.263] - nx: 1
[16:17:47.263] - relay: TRUE
[16:17:47.263] - stdout: TRUE
[16:17:47.263] - signal: TRUE
[16:17:47.263] - resignal: FALSE
[16:17:47.263] - force: TRUE
[16:17:47.263] - relayed: [n=1] TRUE
[16:17:47.263] - queued futures: [n=1] TRUE
 - flush all
[16:17:47.263] - relayed: [n=1] TRUE
[16:17:47.263] - queued futures: [n=1] TRUE
[16:17:47.264] signalConditionsASAP(NULL, pos=0) ... done
[16:17:47.264] resolve() on list ... DONE
[16:17:47.264]  - Number of value chunks collected: 1
[16:17:47.264] Resolving 1 futures (chunks) ... DONE
[16:17:47.264] Reducing values from 1 chunks ...
[16:17:47.264]  - Number of values collected after concatenation: 3
[16:17:47.264]  - Number of values expected: 3
[16:17:47.264] Reducing values from 1 chunks ... DONE
[16:17:47.264] future_lapply() ... DONE
[16:17:47.264] future_by_internal() ... DONE
[16:17:47.265] future_by_internal() ...
- plan('multicore') ...
[16:17:47.266] plan(): Setting new future strategy stack:
[16:17:47.266] List of future strategies:
[16:17:47.266] 1. multicore:
[16:17:47.266]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:47.266]    - tweaked: FALSE
[16:17:47.266]    - call: plan(strategy)
[16:17:47.270] plan(): nbrOfWorkers() = 2
[16:17:47.271] future_by_internal() ...
[16:17:47.271] future_lapply() ...
[16:17:47.275] Number of chunks: 2
[16:17:47.275] getGlobalsAndPackagesXApply() ...
[16:17:47.276]  - future.globals: TRUE
[16:17:47.276] getGlobalsAndPackages() ...
[16:17:47.276] Searching for globals...
[16:17:47.277] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:47.277] Searching for globals ... DONE
[16:17:47.277] Resolving globals: FALSE
[16:17:47.277] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:47.278] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:47.278] - globals: [1] ‘FUN’
[16:17:47.278] 
[16:17:47.278] getGlobalsAndPackages() ... DONE
[16:17:47.278]  - globals found/used: [n=1] ‘FUN’
[16:17:47.278]  - needed namespaces: [n=0] 
[16:17:47.278] Finding globals ... DONE
[16:17:47.278]  - use_args: TRUE
[16:17:47.278]  - Getting '...' globals ...
[16:17:47.279] resolve() on list ...
[16:17:47.279]  recursive: 0
[16:17:47.279]  length: 1
[16:17:47.279]  elements: ‘...’
[16:17:47.279]  length: 0 (resolved future 1)
[16:17:47.279] resolve() on list ... DONE
[16:17:47.279]    - '...' content: [n=0] 
[16:17:47.279] List of 1
[16:17:47.279]  $ ...: list()
[16:17:47.279]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.279]  - attr(*, "where")=List of 1
[16:17:47.279]   ..$ ...:<environment: 0x55b567e80798> 
[16:17:47.279]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.279]  - attr(*, "resolved")= logi TRUE
[16:17:47.279]  - attr(*, "total_size")= num NA
[16:17:47.282]  - Getting '...' globals ... DONE
[16:17:47.282] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:47.282] List of 2
[16:17:47.282]  $ ...future.FUN:function (object, ...)  
[16:17:47.282]  $ ...          : list()
[16:17:47.282]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.282]  - attr(*, "where")=List of 2
[16:17:47.282]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:47.282]   ..$ ...          :<environment: 0x55b567e80798> 
[16:17:47.282]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.282]  - attr(*, "resolved")= logi FALSE
[16:17:47.282]  - attr(*, "total_size")= num 1240
[16:17:47.285] Packages to be attached in all futures: [n=0] 
[16:17:47.285] getGlobalsAndPackagesXApply() ... DONE
[16:17:47.285] Number of futures (= number of chunks): 2
[16:17:47.285] Launching 2 futures (chunks) ...
[16:17:47.285] Chunk #1 of 2 ...
[16:17:47.285]  - Finding globals in 'X' for chunk #1 ...
[16:17:47.285] getGlobalsAndPackages() ...
[16:17:47.286] Searching for globals...
[16:17:47.286] 
[16:17:47.286] Searching for globals ... DONE
[16:17:47.286] - globals: [0] <none>
[16:17:47.286] getGlobalsAndPackages() ... DONE
[16:17:47.286]    + additional globals found: [n=0] 
[16:17:47.286]    + additional namespaces needed: [n=0] 
[16:17:47.286]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:47.287]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:47.287]  - seeds: <none>
[16:17:47.287]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.287] getGlobalsAndPackages() ...
[16:17:47.287] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.287] Resolving globals: FALSE
[16:17:47.287] Tweak future expression to call with '...' arguments ...
[16:17:47.287] {
[16:17:47.287]     do.call(function(...) {
[16:17:47.287]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.287]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.287]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.287]             on.exit(options(oopts), add = TRUE)
[16:17:47.287]         }
[16:17:47.287]         {
[16:17:47.287]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.287]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.287]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.287]             })
[16:17:47.287]         }
[16:17:47.287]     }, args = future.call.arguments)
[16:17:47.287] }
[16:17:47.287] Tweak future expression to call with '...' arguments ... DONE
[16:17:47.288] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.288] 
[16:17:47.288] getGlobalsAndPackages() ... DONE
[16:17:47.288] run() for ‘Future’ ...
[16:17:47.288] - state: ‘created’
[16:17:47.289] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:47.293] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:47.293] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:47.293]   - Field: ‘label’
[16:17:47.294]   - Field: ‘local’
[16:17:47.294]   - Field: ‘owner’
[16:17:47.294]   - Field: ‘envir’
[16:17:47.294]   - Field: ‘workers’
[16:17:47.294]   - Field: ‘packages’
[16:17:47.294]   - Field: ‘gc’
[16:17:47.294]   - Field: ‘job’
[16:17:47.294]   - Field: ‘conditions’
[16:17:47.294]   - Field: ‘expr’
[16:17:47.294]   - Field: ‘uuid’
[16:17:47.295]   - Field: ‘seed’
[16:17:47.295]   - Field: ‘version’
[16:17:47.295]   - Field: ‘result’
[16:17:47.295]   - Field: ‘asynchronous’
[16:17:47.295]   - Field: ‘calls’
[16:17:47.295]   - Field: ‘globals’
[16:17:47.295]   - Field: ‘stdout’
[16:17:47.295]   - Field: ‘earlySignal’
[16:17:47.295]   - Field: ‘lazy’
[16:17:47.295]   - Field: ‘state’
[16:17:47.295] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:47.296] - Launch lazy future ...
[16:17:47.297] Packages needed by the future expression (n = 0): <none>
[16:17:47.297] Packages needed by future strategies (n = 0): <none>
[16:17:47.297] {
[16:17:47.297]     {
[16:17:47.297]         {
[16:17:47.297]             ...future.startTime <- base::Sys.time()
[16:17:47.297]             {
[16:17:47.297]                 {
[16:17:47.297]                   {
[16:17:47.297]                     {
[16:17:47.297]                       base::local({
[16:17:47.297]                         has_future <- base::requireNamespace("future", 
[16:17:47.297]                           quietly = TRUE)
[16:17:47.297]                         if (has_future) {
[16:17:47.297]                           ns <- base::getNamespace("future")
[16:17:47.297]                           version <- ns[[".package"]][["version"]]
[16:17:47.297]                           if (is.null(version)) 
[16:17:47.297]                             version <- utils::packageVersion("future")
[16:17:47.297]                         }
[16:17:47.297]                         else {
[16:17:47.297]                           version <- NULL
[16:17:47.297]                         }
[16:17:47.297]                         if (!has_future || version < "1.8.0") {
[16:17:47.297]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:47.297]                             "", base::R.version$version.string), 
[16:17:47.297]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:47.297]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:47.297]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:47.297]                               "release", "version")], collapse = " "), 
[16:17:47.297]                             hostname = base::Sys.info()[["nodename"]])
[16:17:47.297]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:47.297]                             info)
[16:17:47.297]                           info <- base::paste(info, collapse = "; ")
[16:17:47.297]                           if (!has_future) {
[16:17:47.297]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:47.297]                               info)
[16:17:47.297]                           }
[16:17:47.297]                           else {
[16:17:47.297]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:47.297]                               info, version)
[16:17:47.297]                           }
[16:17:47.297]                           base::stop(msg)
[16:17:47.297]                         }
[16:17:47.297]                       })
[16:17:47.297]                     }
[16:17:47.297]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:47.297]                     base::options(mc.cores = 1L)
[16:17:47.297]                   }
[16:17:47.297]                   ...future.strategy.old <- future::plan("list")
[16:17:47.297]                   options(future.plan = NULL)
[16:17:47.297]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.297]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:47.297]                 }
[16:17:47.297]                 ...future.workdir <- getwd()
[16:17:47.297]             }
[16:17:47.297]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:47.297]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:47.297]         }
[16:17:47.297]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:47.297]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:47.297]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:47.297]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:47.297]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:47.297]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:47.297]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:47.297]             base::names(...future.oldOptions))
[16:17:47.297]     }
[16:17:47.297]     if (FALSE) {
[16:17:47.297]     }
[16:17:47.297]     else {
[16:17:47.297]         if (TRUE) {
[16:17:47.297]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:47.297]                 open = "w")
[16:17:47.297]         }
[16:17:47.297]         else {
[16:17:47.297]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:47.297]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:47.297]         }
[16:17:47.297]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:47.297]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:47.297]             base::sink(type = "output", split = FALSE)
[16:17:47.297]             base::close(...future.stdout)
[16:17:47.297]         }, add = TRUE)
[16:17:47.297]     }
[16:17:47.297]     ...future.frame <- base::sys.nframe()
[16:17:47.297]     ...future.conditions <- base::list()
[16:17:47.297]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:47.297]     if (FALSE) {
[16:17:47.297]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:47.297]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:47.297]     }
[16:17:47.297]     ...future.result <- base::tryCatch({
[16:17:47.297]         base::withCallingHandlers({
[16:17:47.297]             ...future.value <- base::withVisible(base::local({
[16:17:47.297]                 withCallingHandlers({
[16:17:47.297]                   {
[16:17:47.297]                     do.call(function(...) {
[16:17:47.297]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.297]                       if (!identical(...future.globals.maxSize.org, 
[16:17:47.297]                         ...future.globals.maxSize)) {
[16:17:47.297]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.297]                         on.exit(options(oopts), add = TRUE)
[16:17:47.297]                       }
[16:17:47.297]                       {
[16:17:47.297]                         lapply(seq_along(...future.elements_ii), 
[16:17:47.297]                           FUN = function(jj) {
[16:17:47.297]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.297]                             ...future.FUN(...future.X_jj, ...)
[16:17:47.297]                           })
[16:17:47.297]                       }
[16:17:47.297]                     }, args = future.call.arguments)
[16:17:47.297]                   }
[16:17:47.297]                 }, immediateCondition = function(cond) {
[16:17:47.297]                   save_rds <- function (object, pathname, ...) 
[16:17:47.297]                   {
[16:17:47.297]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:47.297]                     if (file_test("-f", pathname_tmp)) {
[16:17:47.297]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.297]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:47.297]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.297]                         fi_tmp[["mtime"]])
[16:17:47.297]                     }
[16:17:47.297]                     tryCatch({
[16:17:47.297]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:47.297]                     }, error = function(ex) {
[16:17:47.297]                       msg <- conditionMessage(ex)
[16:17:47.297]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.297]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:47.297]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.297]                         fi_tmp[["mtime"]], msg)
[16:17:47.297]                       ex$message <- msg
[16:17:47.297]                       stop(ex)
[16:17:47.297]                     })
[16:17:47.297]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:47.297]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:47.297]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:47.297]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.297]                       fi <- file.info(pathname)
[16:17:47.297]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:47.297]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.297]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:47.297]                         fi[["size"]], fi[["mtime"]])
[16:17:47.297]                       stop(msg)
[16:17:47.297]                     }
[16:17:47.297]                     invisible(pathname)
[16:17:47.297]                   }
[16:17:47.297]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:47.297]                     rootPath = tempdir()) 
[16:17:47.297]                   {
[16:17:47.297]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:47.297]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:47.297]                       tmpdir = path, fileext = ".rds")
[16:17:47.297]                     save_rds(obj, file)
[16:17:47.297]                   }
[16:17:47.297]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1cUuyG/.future/immediateConditions")
[16:17:47.297]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.297]                   {
[16:17:47.297]                     inherits <- base::inherits
[16:17:47.297]                     invokeRestart <- base::invokeRestart
[16:17:47.297]                     is.null <- base::is.null
[16:17:47.297]                     muffled <- FALSE
[16:17:47.297]                     if (inherits(cond, "message")) {
[16:17:47.297]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:47.297]                       if (muffled) 
[16:17:47.297]                         invokeRestart("muffleMessage")
[16:17:47.297]                     }
[16:17:47.297]                     else if (inherits(cond, "warning")) {
[16:17:47.297]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:47.297]                       if (muffled) 
[16:17:47.297]                         invokeRestart("muffleWarning")
[16:17:47.297]                     }
[16:17:47.297]                     else if (inherits(cond, "condition")) {
[16:17:47.297]                       if (!is.null(pattern)) {
[16:17:47.297]                         computeRestarts <- base::computeRestarts
[16:17:47.297]                         grepl <- base::grepl
[16:17:47.297]                         restarts <- computeRestarts(cond)
[16:17:47.297]                         for (restart in restarts) {
[16:17:47.297]                           name <- restart$name
[16:17:47.297]                           if (is.null(name)) 
[16:17:47.297]                             next
[16:17:47.297]                           if (!grepl(pattern, name)) 
[16:17:47.297]                             next
[16:17:47.297]                           invokeRestart(restart)
[16:17:47.297]                           muffled <- TRUE
[16:17:47.297]                           break
[16:17:47.297]                         }
[16:17:47.297]                       }
[16:17:47.297]                     }
[16:17:47.297]                     invisible(muffled)
[16:17:47.297]                   }
[16:17:47.297]                   muffleCondition(cond)
[16:17:47.297]                 })
[16:17:47.297]             }))
[16:17:47.297]             future::FutureResult(value = ...future.value$value, 
[16:17:47.297]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.297]                   ...future.rng), globalenv = if (FALSE) 
[16:17:47.297]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:47.297]                     ...future.globalenv.names))
[16:17:47.297]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:47.297]         }, condition = base::local({
[16:17:47.297]             c <- base::c
[16:17:47.297]             inherits <- base::inherits
[16:17:47.297]             invokeRestart <- base::invokeRestart
[16:17:47.297]             length <- base::length
[16:17:47.297]             list <- base::list
[16:17:47.297]             seq.int <- base::seq.int
[16:17:47.297]             signalCondition <- base::signalCondition
[16:17:47.297]             sys.calls <- base::sys.calls
[16:17:47.297]             `[[` <- base::`[[`
[16:17:47.297]             `+` <- base::`+`
[16:17:47.297]             `<<-` <- base::`<<-`
[16:17:47.297]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:47.297]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:47.297]                   3L)]
[16:17:47.297]             }
[16:17:47.297]             function(cond) {
[16:17:47.297]                 is_error <- inherits(cond, "error")
[16:17:47.297]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:47.297]                   NULL)
[16:17:47.297]                 if (is_error) {
[16:17:47.297]                   sessionInformation <- function() {
[16:17:47.297]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:47.297]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:47.297]                       search = base::search(), system = base::Sys.info())
[16:17:47.297]                   }
[16:17:47.297]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.297]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:47.297]                     cond$call), session = sessionInformation(), 
[16:17:47.297]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:47.297]                   signalCondition(cond)
[16:17:47.297]                 }
[16:17:47.297]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:47.297]                 "immediateCondition"))) {
[16:17:47.297]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:47.297]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.297]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:47.297]                   if (TRUE && !signal) {
[16:17:47.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.297]                     {
[16:17:47.297]                       inherits <- base::inherits
[16:17:47.297]                       invokeRestart <- base::invokeRestart
[16:17:47.297]                       is.null <- base::is.null
[16:17:47.297]                       muffled <- FALSE
[16:17:47.297]                       if (inherits(cond, "message")) {
[16:17:47.297]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.297]                         if (muffled) 
[16:17:47.297]                           invokeRestart("muffleMessage")
[16:17:47.297]                       }
[16:17:47.297]                       else if (inherits(cond, "warning")) {
[16:17:47.297]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.297]                         if (muffled) 
[16:17:47.297]                           invokeRestart("muffleWarning")
[16:17:47.297]                       }
[16:17:47.297]                       else if (inherits(cond, "condition")) {
[16:17:47.297]                         if (!is.null(pattern)) {
[16:17:47.297]                           computeRestarts <- base::computeRestarts
[16:17:47.297]                           grepl <- base::grepl
[16:17:47.297]                           restarts <- computeRestarts(cond)
[16:17:47.297]                           for (restart in restarts) {
[16:17:47.297]                             name <- restart$name
[16:17:47.297]                             if (is.null(name)) 
[16:17:47.297]                               next
[16:17:47.297]                             if (!grepl(pattern, name)) 
[16:17:47.297]                               next
[16:17:47.297]                             invokeRestart(restart)
[16:17:47.297]                             muffled <- TRUE
[16:17:47.297]                             break
[16:17:47.297]                           }
[16:17:47.297]                         }
[16:17:47.297]                       }
[16:17:47.297]                       invisible(muffled)
[16:17:47.297]                     }
[16:17:47.297]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.297]                   }
[16:17:47.297]                 }
[16:17:47.297]                 else {
[16:17:47.297]                   if (TRUE) {
[16:17:47.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.297]                     {
[16:17:47.297]                       inherits <- base::inherits
[16:17:47.297]                       invokeRestart <- base::invokeRestart
[16:17:47.297]                       is.null <- base::is.null
[16:17:47.297]                       muffled <- FALSE
[16:17:47.297]                       if (inherits(cond, "message")) {
[16:17:47.297]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.297]                         if (muffled) 
[16:17:47.297]                           invokeRestart("muffleMessage")
[16:17:47.297]                       }
[16:17:47.297]                       else if (inherits(cond, "warning")) {
[16:17:47.297]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.297]                         if (muffled) 
[16:17:47.297]                           invokeRestart("muffleWarning")
[16:17:47.297]                       }
[16:17:47.297]                       else if (inherits(cond, "condition")) {
[16:17:47.297]                         if (!is.null(pattern)) {
[16:17:47.297]                           computeRestarts <- base::computeRestarts
[16:17:47.297]                           grepl <- base::grepl
[16:17:47.297]                           restarts <- computeRestarts(cond)
[16:17:47.297]                           for (restart in restarts) {
[16:17:47.297]                             name <- restart$name
[16:17:47.297]                             if (is.null(name)) 
[16:17:47.297]                               next
[16:17:47.297]                             if (!grepl(pattern, name)) 
[16:17:47.297]                               next
[16:17:47.297]                             invokeRestart(restart)
[16:17:47.297]                             muffled <- TRUE
[16:17:47.297]                             break
[16:17:47.297]                           }
[16:17:47.297]                         }
[16:17:47.297]                       }
[16:17:47.297]                       invisible(muffled)
[16:17:47.297]                     }
[16:17:47.297]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.297]                   }
[16:17:47.297]                 }
[16:17:47.297]             }
[16:17:47.297]         }))
[16:17:47.297]     }, error = function(ex) {
[16:17:47.297]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:47.297]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.297]                 ...future.rng), started = ...future.startTime, 
[16:17:47.297]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:47.297]             version = "1.8"), class = "FutureResult")
[16:17:47.297]     }, finally = {
[16:17:47.297]         if (!identical(...future.workdir, getwd())) 
[16:17:47.297]             setwd(...future.workdir)
[16:17:47.297]         {
[16:17:47.297]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:47.297]                 ...future.oldOptions$nwarnings <- NULL
[16:17:47.297]             }
[16:17:47.297]             base::options(...future.oldOptions)
[16:17:47.297]             if (.Platform$OS.type == "windows") {
[16:17:47.297]                 old_names <- names(...future.oldEnvVars)
[16:17:47.297]                 envs <- base::Sys.getenv()
[16:17:47.297]                 names <- names(envs)
[16:17:47.297]                 common <- intersect(names, old_names)
[16:17:47.297]                 added <- setdiff(names, old_names)
[16:17:47.297]                 removed <- setdiff(old_names, names)
[16:17:47.297]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:47.297]                   envs[common]]
[16:17:47.297]                 NAMES <- toupper(changed)
[16:17:47.297]                 args <- list()
[16:17:47.297]                 for (kk in seq_along(NAMES)) {
[16:17:47.297]                   name <- changed[[kk]]
[16:17:47.297]                   NAME <- NAMES[[kk]]
[16:17:47.297]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.297]                     next
[16:17:47.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.297]                 }
[16:17:47.297]                 NAMES <- toupper(added)
[16:17:47.297]                 for (kk in seq_along(NAMES)) {
[16:17:47.297]                   name <- added[[kk]]
[16:17:47.297]                   NAME <- NAMES[[kk]]
[16:17:47.297]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.297]                     next
[16:17:47.297]                   args[[name]] <- ""
[16:17:47.297]                 }
[16:17:47.297]                 NAMES <- toupper(removed)
[16:17:47.297]                 for (kk in seq_along(NAMES)) {
[16:17:47.297]                   name <- removed[[kk]]
[16:17:47.297]                   NAME <- NAMES[[kk]]
[16:17:47.297]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.297]                     next
[16:17:47.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.297]                 }
[16:17:47.297]                 if (length(args) > 0) 
[16:17:47.297]                   base::do.call(base::Sys.setenv, args = args)
[16:17:47.297]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:47.297]             }
[16:17:47.297]             else {
[16:17:47.297]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:47.297]             }
[16:17:47.297]             {
[16:17:47.297]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:47.297]                   0L) {
[16:17:47.297]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:47.297]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:47.297]                   base::options(opts)
[16:17:47.297]                 }
[16:17:47.297]                 {
[16:17:47.297]                   {
[16:17:47.297]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:47.297]                     NULL
[16:17:47.297]                   }
[16:17:47.297]                   options(future.plan = NULL)
[16:17:47.297]                   if (is.na(NA_character_)) 
[16:17:47.297]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.297]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:47.297]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:47.297]                     .init = FALSE)
[16:17:47.297]                 }
[16:17:47.297]             }
[16:17:47.297]         }
[16:17:47.297]     })
[16:17:47.297]     if (TRUE) {
[16:17:47.297]         base::sink(type = "output", split = FALSE)
[16:17:47.297]         if (TRUE) {
[16:17:47.297]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:47.297]         }
[16:17:47.297]         else {
[16:17:47.297]             ...future.result["stdout"] <- base::list(NULL)
[16:17:47.297]         }
[16:17:47.297]         base::close(...future.stdout)
[16:17:47.297]         ...future.stdout <- NULL
[16:17:47.297]     }
[16:17:47.297]     ...future.result$conditions <- ...future.conditions
[16:17:47.297]     ...future.result$finished <- base::Sys.time()
[16:17:47.297]     ...future.result
[16:17:47.297] }
[16:17:47.300] assign_globals() ...
[16:17:47.300] List of 5
[16:17:47.300]  $ ...future.FUN            :function (object, ...)  
[16:17:47.300]  $ future.call.arguments    : list()
[16:17:47.300]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.300]  $ ...future.elements_ii    :List of 1
[16:17:47.300]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:17:47.300]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:17:47.300]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.300]  $ ...future.seeds_ii       : NULL
[16:17:47.300]  $ ...future.globals.maxSize: NULL
[16:17:47.300]  - attr(*, "where")=List of 5
[16:17:47.300]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:47.300]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:47.300]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:47.300]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:47.300]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:47.300]  - attr(*, "resolved")= logi FALSE
[16:17:47.300]  - attr(*, "total_size")= num 1240
[16:17:47.300]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.300]  - attr(*, "already-done")= logi TRUE
[16:17:47.305] - copied ‘...future.FUN’ to environment
[16:17:47.305] - copied ‘future.call.arguments’ to environment
[16:17:47.305] - copied ‘...future.elements_ii’ to environment
[16:17:47.305] - copied ‘...future.seeds_ii’ to environment
[16:17:47.305] - copied ‘...future.globals.maxSize’ to environment
[16:17:47.305] assign_globals() ... done
[16:17:47.306] requestCore(): workers = 2
[16:17:47.309] MulticoreFuture started
[16:17:47.309] - Launch lazy future ... done
[16:17:47.310] run() for ‘MulticoreFuture’ ... done
[16:17:47.310] plan(): Setting new future strategy stack:
[16:17:47.310] Created future:
[16:17:47.310] List of future strategies:
[16:17:47.310] 1. sequential:
[16:17:47.310]    - args: function (..., envir = parent.frame())
[16:17:47.310]    - tweaked: FALSE
[16:17:47.310]    - call: NULL
[16:17:47.311] plan(): nbrOfWorkers() = 1
[16:17:47.314] plan(): Setting new future strategy stack:
[16:17:47.314] List of future strategies:
[16:17:47.314] 1. multicore:
[16:17:47.314]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:47.314]    - tweaked: FALSE
[16:17:47.314]    - call: plan(strategy)
[16:17:47.319] plan(): nbrOfWorkers() = 2
[16:17:47.310] MulticoreFuture:
[16:17:47.310] Label: ‘future_by-1’
[16:17:47.310] Expression:
[16:17:47.310] {
[16:17:47.310]     do.call(function(...) {
[16:17:47.310]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.310]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.310]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.310]             on.exit(options(oopts), add = TRUE)
[16:17:47.310]         }
[16:17:47.310]         {
[16:17:47.310]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.310]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.310]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.310]             })
[16:17:47.310]         }
[16:17:47.310]     }, args = future.call.arguments)
[16:17:47.310] }
[16:17:47.310] Lazy evaluation: FALSE
[16:17:47.310] Asynchronous evaluation: TRUE
[16:17:47.310] Local evaluation: TRUE
[16:17:47.310] Environment: R_GlobalEnv
[16:17:47.310] Capture standard output: TRUE
[16:17:47.310] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:47.310] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:47.310] Packages: <none>
[16:17:47.310] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:47.310] Resolved: TRUE
[16:17:47.310] Value: <not collected>
[16:17:47.310] Conditions captured: <none>
[16:17:47.310] Early signaling: FALSE
[16:17:47.310] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:47.310] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:47.321] Chunk #1 of 2 ... DONE
[16:17:47.321] Chunk #2 of 2 ...
[16:17:47.321]  - Finding globals in 'X' for chunk #2 ...
[16:17:47.321] getGlobalsAndPackages() ...
[16:17:47.321] Searching for globals...
[16:17:47.322] 
[16:17:47.322] Searching for globals ... DONE
[16:17:47.322] - globals: [0] <none>
[16:17:47.322] getGlobalsAndPackages() ... DONE
[16:17:47.323]    + additional globals found: [n=0] 
[16:17:47.323]    + additional namespaces needed: [n=0] 
[16:17:47.323]  - Finding globals in 'X' for chunk #2 ... DONE
[16:17:47.323]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:47.323]  - seeds: <none>
[16:17:47.323]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.323] getGlobalsAndPackages() ...
[16:17:47.324] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.324] Resolving globals: FALSE
[16:17:47.324] Tweak future expression to call with '...' arguments ...
[16:17:47.324] {
[16:17:47.324]     do.call(function(...) {
[16:17:47.324]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.324]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.324]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.324]             on.exit(options(oopts), add = TRUE)
[16:17:47.324]         }
[16:17:47.324]         {
[16:17:47.324]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.324]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.324]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.324]             })
[16:17:47.324]         }
[16:17:47.324]     }, args = future.call.arguments)
[16:17:47.324] }
[16:17:47.325] Tweak future expression to call with '...' arguments ... DONE
[16:17:47.325] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.325] 
[16:17:47.325] getGlobalsAndPackages() ... DONE
[16:17:47.326] run() for ‘Future’ ...
[16:17:47.326] - state: ‘created’
[16:17:47.326] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:47.336] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:47.336] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:47.336]   - Field: ‘label’
[16:17:47.337]   - Field: ‘local’
[16:17:47.337]   - Field: ‘owner’
[16:17:47.337]   - Field: ‘envir’
[16:17:47.337]   - Field: ‘workers’
[16:17:47.338]   - Field: ‘packages’
[16:17:47.338]   - Field: ‘gc’
[16:17:47.338]   - Field: ‘job’
[16:17:47.339]   - Field: ‘conditions’
[16:17:47.339]   - Field: ‘expr’
[16:17:47.339]   - Field: ‘uuid’
[16:17:47.339]   - Field: ‘seed’
[16:17:47.339]   - Field: ‘version’
[16:17:47.340]   - Field: ‘result’
[16:17:47.340]   - Field: ‘asynchronous’
[16:17:47.340]   - Field: ‘calls’
[16:17:47.341]   - Field: ‘globals’
[16:17:47.341]   - Field: ‘stdout’
[16:17:47.341]   - Field: ‘earlySignal’
[16:17:47.341]   - Field: ‘lazy’
[16:17:47.341]   - Field: ‘state’
[16:17:47.342] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:47.342] - Launch lazy future ...
[16:17:47.342] Packages needed by the future expression (n = 0): <none>
[16:17:47.342] Packages needed by future strategies (n = 0): <none>
[16:17:47.343] {
[16:17:47.343]     {
[16:17:47.343]         {
[16:17:47.343]             ...future.startTime <- base::Sys.time()
[16:17:47.343]             {
[16:17:47.343]                 {
[16:17:47.343]                   {
[16:17:47.343]                     {
[16:17:47.343]                       base::local({
[16:17:47.343]                         has_future <- base::requireNamespace("future", 
[16:17:47.343]                           quietly = TRUE)
[16:17:47.343]                         if (has_future) {
[16:17:47.343]                           ns <- base::getNamespace("future")
[16:17:47.343]                           version <- ns[[".package"]][["version"]]
[16:17:47.343]                           if (is.null(version)) 
[16:17:47.343]                             version <- utils::packageVersion("future")
[16:17:47.343]                         }
[16:17:47.343]                         else {
[16:17:47.343]                           version <- NULL
[16:17:47.343]                         }
[16:17:47.343]                         if (!has_future || version < "1.8.0") {
[16:17:47.343]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:47.343]                             "", base::R.version$version.string), 
[16:17:47.343]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:47.343]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:47.343]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:47.343]                               "release", "version")], collapse = " "), 
[16:17:47.343]                             hostname = base::Sys.info()[["nodename"]])
[16:17:47.343]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:47.343]                             info)
[16:17:47.343]                           info <- base::paste(info, collapse = "; ")
[16:17:47.343]                           if (!has_future) {
[16:17:47.343]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:47.343]                               info)
[16:17:47.343]                           }
[16:17:47.343]                           else {
[16:17:47.343]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:47.343]                               info, version)
[16:17:47.343]                           }
[16:17:47.343]                           base::stop(msg)
[16:17:47.343]                         }
[16:17:47.343]                       })
[16:17:47.343]                     }
[16:17:47.343]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:47.343]                     base::options(mc.cores = 1L)
[16:17:47.343]                   }
[16:17:47.343]                   ...future.strategy.old <- future::plan("list")
[16:17:47.343]                   options(future.plan = NULL)
[16:17:47.343]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.343]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:47.343]                 }
[16:17:47.343]                 ...future.workdir <- getwd()
[16:17:47.343]             }
[16:17:47.343]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:47.343]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:47.343]         }
[16:17:47.343]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:47.343]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:47.343]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:47.343]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:47.343]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:47.343]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:47.343]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:47.343]             base::names(...future.oldOptions))
[16:17:47.343]     }
[16:17:47.343]     if (FALSE) {
[16:17:47.343]     }
[16:17:47.343]     else {
[16:17:47.343]         if (TRUE) {
[16:17:47.343]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:47.343]                 open = "w")
[16:17:47.343]         }
[16:17:47.343]         else {
[16:17:47.343]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:47.343]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:47.343]         }
[16:17:47.343]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:47.343]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:47.343]             base::sink(type = "output", split = FALSE)
[16:17:47.343]             base::close(...future.stdout)
[16:17:47.343]         }, add = TRUE)
[16:17:47.343]     }
[16:17:47.343]     ...future.frame <- base::sys.nframe()
[16:17:47.343]     ...future.conditions <- base::list()
[16:17:47.343]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:47.343]     if (FALSE) {
[16:17:47.343]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:47.343]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:47.343]     }
[16:17:47.343]     ...future.result <- base::tryCatch({
[16:17:47.343]         base::withCallingHandlers({
[16:17:47.343]             ...future.value <- base::withVisible(base::local({
[16:17:47.343]                 withCallingHandlers({
[16:17:47.343]                   {
[16:17:47.343]                     do.call(function(...) {
[16:17:47.343]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.343]                       if (!identical(...future.globals.maxSize.org, 
[16:17:47.343]                         ...future.globals.maxSize)) {
[16:17:47.343]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.343]                         on.exit(options(oopts), add = TRUE)
[16:17:47.343]                       }
[16:17:47.343]                       {
[16:17:47.343]                         lapply(seq_along(...future.elements_ii), 
[16:17:47.343]                           FUN = function(jj) {
[16:17:47.343]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.343]                             ...future.FUN(...future.X_jj, ...)
[16:17:47.343]                           })
[16:17:47.343]                       }
[16:17:47.343]                     }, args = future.call.arguments)
[16:17:47.343]                   }
[16:17:47.343]                 }, immediateCondition = function(cond) {
[16:17:47.343]                   save_rds <- function (object, pathname, ...) 
[16:17:47.343]                   {
[16:17:47.343]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:47.343]                     if (file_test("-f", pathname_tmp)) {
[16:17:47.343]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.343]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:47.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.343]                         fi_tmp[["mtime"]])
[16:17:47.343]                     }
[16:17:47.343]                     tryCatch({
[16:17:47.343]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:47.343]                     }, error = function(ex) {
[16:17:47.343]                       msg <- conditionMessage(ex)
[16:17:47.343]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.343]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:47.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.343]                         fi_tmp[["mtime"]], msg)
[16:17:47.343]                       ex$message <- msg
[16:17:47.343]                       stop(ex)
[16:17:47.343]                     })
[16:17:47.343]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:47.343]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:47.343]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:47.343]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.343]                       fi <- file.info(pathname)
[16:17:47.343]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:47.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.343]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:47.343]                         fi[["size"]], fi[["mtime"]])
[16:17:47.343]                       stop(msg)
[16:17:47.343]                     }
[16:17:47.343]                     invisible(pathname)
[16:17:47.343]                   }
[16:17:47.343]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:47.343]                     rootPath = tempdir()) 
[16:17:47.343]                   {
[16:17:47.343]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:47.343]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:47.343]                       tmpdir = path, fileext = ".rds")
[16:17:47.343]                     save_rds(obj, file)
[16:17:47.343]                   }
[16:17:47.343]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1cUuyG/.future/immediateConditions")
[16:17:47.343]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.343]                   {
[16:17:47.343]                     inherits <- base::inherits
[16:17:47.343]                     invokeRestart <- base::invokeRestart
[16:17:47.343]                     is.null <- base::is.null
[16:17:47.343]                     muffled <- FALSE
[16:17:47.343]                     if (inherits(cond, "message")) {
[16:17:47.343]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:47.343]                       if (muffled) 
[16:17:47.343]                         invokeRestart("muffleMessage")
[16:17:47.343]                     }
[16:17:47.343]                     else if (inherits(cond, "warning")) {
[16:17:47.343]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:47.343]                       if (muffled) 
[16:17:47.343]                         invokeRestart("muffleWarning")
[16:17:47.343]                     }
[16:17:47.343]                     else if (inherits(cond, "condition")) {
[16:17:47.343]                       if (!is.null(pattern)) {
[16:17:47.343]                         computeRestarts <- base::computeRestarts
[16:17:47.343]                         grepl <- base::grepl
[16:17:47.343]                         restarts <- computeRestarts(cond)
[16:17:47.343]                         for (restart in restarts) {
[16:17:47.343]                           name <- restart$name
[16:17:47.343]                           if (is.null(name)) 
[16:17:47.343]                             next
[16:17:47.343]                           if (!grepl(pattern, name)) 
[16:17:47.343]                             next
[16:17:47.343]                           invokeRestart(restart)
[16:17:47.343]                           muffled <- TRUE
[16:17:47.343]                           break
[16:17:47.343]                         }
[16:17:47.343]                       }
[16:17:47.343]                     }
[16:17:47.343]                     invisible(muffled)
[16:17:47.343]                   }
[16:17:47.343]                   muffleCondition(cond)
[16:17:47.343]                 })
[16:17:47.343]             }))
[16:17:47.343]             future::FutureResult(value = ...future.value$value, 
[16:17:47.343]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.343]                   ...future.rng), globalenv = if (FALSE) 
[16:17:47.343]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:47.343]                     ...future.globalenv.names))
[16:17:47.343]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:47.343]         }, condition = base::local({
[16:17:47.343]             c <- base::c
[16:17:47.343]             inherits <- base::inherits
[16:17:47.343]             invokeRestart <- base::invokeRestart
[16:17:47.343]             length <- base::length
[16:17:47.343]             list <- base::list
[16:17:47.343]             seq.int <- base::seq.int
[16:17:47.343]             signalCondition <- base::signalCondition
[16:17:47.343]             sys.calls <- base::sys.calls
[16:17:47.343]             `[[` <- base::`[[`
[16:17:47.343]             `+` <- base::`+`
[16:17:47.343]             `<<-` <- base::`<<-`
[16:17:47.343]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:47.343]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:47.343]                   3L)]
[16:17:47.343]             }
[16:17:47.343]             function(cond) {
[16:17:47.343]                 is_error <- inherits(cond, "error")
[16:17:47.343]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:47.343]                   NULL)
[16:17:47.343]                 if (is_error) {
[16:17:47.343]                   sessionInformation <- function() {
[16:17:47.343]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:47.343]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:47.343]                       search = base::search(), system = base::Sys.info())
[16:17:47.343]                   }
[16:17:47.343]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.343]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:47.343]                     cond$call), session = sessionInformation(), 
[16:17:47.343]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:47.343]                   signalCondition(cond)
[16:17:47.343]                 }
[16:17:47.343]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:47.343]                 "immediateCondition"))) {
[16:17:47.343]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:47.343]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.343]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:47.343]                   if (TRUE && !signal) {
[16:17:47.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.343]                     {
[16:17:47.343]                       inherits <- base::inherits
[16:17:47.343]                       invokeRestart <- base::invokeRestart
[16:17:47.343]                       is.null <- base::is.null
[16:17:47.343]                       muffled <- FALSE
[16:17:47.343]                       if (inherits(cond, "message")) {
[16:17:47.343]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.343]                         if (muffled) 
[16:17:47.343]                           invokeRestart("muffleMessage")
[16:17:47.343]                       }
[16:17:47.343]                       else if (inherits(cond, "warning")) {
[16:17:47.343]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.343]                         if (muffled) 
[16:17:47.343]                           invokeRestart("muffleWarning")
[16:17:47.343]                       }
[16:17:47.343]                       else if (inherits(cond, "condition")) {
[16:17:47.343]                         if (!is.null(pattern)) {
[16:17:47.343]                           computeRestarts <- base::computeRestarts
[16:17:47.343]                           grepl <- base::grepl
[16:17:47.343]                           restarts <- computeRestarts(cond)
[16:17:47.343]                           for (restart in restarts) {
[16:17:47.343]                             name <- restart$name
[16:17:47.343]                             if (is.null(name)) 
[16:17:47.343]                               next
[16:17:47.343]                             if (!grepl(pattern, name)) 
[16:17:47.343]                               next
[16:17:47.343]                             invokeRestart(restart)
[16:17:47.343]                             muffled <- TRUE
[16:17:47.343]                             break
[16:17:47.343]                           }
[16:17:47.343]                         }
[16:17:47.343]                       }
[16:17:47.343]                       invisible(muffled)
[16:17:47.343]                     }
[16:17:47.343]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.343]                   }
[16:17:47.343]                 }
[16:17:47.343]                 else {
[16:17:47.343]                   if (TRUE) {
[16:17:47.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.343]                     {
[16:17:47.343]                       inherits <- base::inherits
[16:17:47.343]                       invokeRestart <- base::invokeRestart
[16:17:47.343]                       is.null <- base::is.null
[16:17:47.343]                       muffled <- FALSE
[16:17:47.343]                       if (inherits(cond, "message")) {
[16:17:47.343]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.343]                         if (muffled) 
[16:17:47.343]                           invokeRestart("muffleMessage")
[16:17:47.343]                       }
[16:17:47.343]                       else if (inherits(cond, "warning")) {
[16:17:47.343]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.343]                         if (muffled) 
[16:17:47.343]                           invokeRestart("muffleWarning")
[16:17:47.343]                       }
[16:17:47.343]                       else if (inherits(cond, "condition")) {
[16:17:47.343]                         if (!is.null(pattern)) {
[16:17:47.343]                           computeRestarts <- base::computeRestarts
[16:17:47.343]                           grepl <- base::grepl
[16:17:47.343]                           restarts <- computeRestarts(cond)
[16:17:47.343]                           for (restart in restarts) {
[16:17:47.343]                             name <- restart$name
[16:17:47.343]                             if (is.null(name)) 
[16:17:47.343]                               next
[16:17:47.343]                             if (!grepl(pattern, name)) 
[16:17:47.343]                               next
[16:17:47.343]                             invokeRestart(restart)
[16:17:47.343]                             muffled <- TRUE
[16:17:47.343]                             break
[16:17:47.343]                           }
[16:17:47.343]                         }
[16:17:47.343]                       }
[16:17:47.343]                       invisible(muffled)
[16:17:47.343]                     }
[16:17:47.343]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.343]                   }
[16:17:47.343]                 }
[16:17:47.343]             }
[16:17:47.343]         }))
[16:17:47.343]     }, error = function(ex) {
[16:17:47.343]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:47.343]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.343]                 ...future.rng), started = ...future.startTime, 
[16:17:47.343]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:47.343]             version = "1.8"), class = "FutureResult")
[16:17:47.343]     }, finally = {
[16:17:47.343]         if (!identical(...future.workdir, getwd())) 
[16:17:47.343]             setwd(...future.workdir)
[16:17:47.343]         {
[16:17:47.343]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:47.343]                 ...future.oldOptions$nwarnings <- NULL
[16:17:47.343]             }
[16:17:47.343]             base::options(...future.oldOptions)
[16:17:47.343]             if (.Platform$OS.type == "windows") {
[16:17:47.343]                 old_names <- names(...future.oldEnvVars)
[16:17:47.343]                 envs <- base::Sys.getenv()
[16:17:47.343]                 names <- names(envs)
[16:17:47.343]                 common <- intersect(names, old_names)
[16:17:47.343]                 added <- setdiff(names, old_names)
[16:17:47.343]                 removed <- setdiff(old_names, names)
[16:17:47.343]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:47.343]                   envs[common]]
[16:17:47.343]                 NAMES <- toupper(changed)
[16:17:47.343]                 args <- list()
[16:17:47.343]                 for (kk in seq_along(NAMES)) {
[16:17:47.343]                   name <- changed[[kk]]
[16:17:47.343]                   NAME <- NAMES[[kk]]
[16:17:47.343]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.343]                     next
[16:17:47.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.343]                 }
[16:17:47.343]                 NAMES <- toupper(added)
[16:17:47.343]                 for (kk in seq_along(NAMES)) {
[16:17:47.343]                   name <- added[[kk]]
[16:17:47.343]                   NAME <- NAMES[[kk]]
[16:17:47.343]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.343]                     next
[16:17:47.343]                   args[[name]] <- ""
[16:17:47.343]                 }
[16:17:47.343]                 NAMES <- toupper(removed)
[16:17:47.343]                 for (kk in seq_along(NAMES)) {
[16:17:47.343]                   name <- removed[[kk]]
[16:17:47.343]                   NAME <- NAMES[[kk]]
[16:17:47.343]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.343]                     next
[16:17:47.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.343]                 }
[16:17:47.343]                 if (length(args) > 0) 
[16:17:47.343]                   base::do.call(base::Sys.setenv, args = args)
[16:17:47.343]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:47.343]             }
[16:17:47.343]             else {
[16:17:47.343]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:47.343]             }
[16:17:47.343]             {
[16:17:47.343]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:47.343]                   0L) {
[16:17:47.343]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:47.343]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:47.343]                   base::options(opts)
[16:17:47.343]                 }
[16:17:47.343]                 {
[16:17:47.343]                   {
[16:17:47.343]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:47.343]                     NULL
[16:17:47.343]                   }
[16:17:47.343]                   options(future.plan = NULL)
[16:17:47.343]                   if (is.na(NA_character_)) 
[16:17:47.343]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.343]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:47.343]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:47.343]                     .init = FALSE)
[16:17:47.343]                 }
[16:17:47.343]             }
[16:17:47.343]         }
[16:17:47.343]     })
[16:17:47.343]     if (TRUE) {
[16:17:47.343]         base::sink(type = "output", split = FALSE)
[16:17:47.343]         if (TRUE) {
[16:17:47.343]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:47.343]         }
[16:17:47.343]         else {
[16:17:47.343]             ...future.result["stdout"] <- base::list(NULL)
[16:17:47.343]         }
[16:17:47.343]         base::close(...future.stdout)
[16:17:47.343]         ...future.stdout <- NULL
[16:17:47.343]     }
[16:17:47.343]     ...future.result$conditions <- ...future.conditions
[16:17:47.343]     ...future.result$finished <- base::Sys.time()
[16:17:47.343]     ...future.result
[16:17:47.343] }
[16:17:47.346] assign_globals() ...
[16:17:47.346] List of 5
[16:17:47.346]  $ ...future.FUN            :function (object, ...)  
[16:17:47.346]  $ future.call.arguments    : list()
[16:17:47.346]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.346]  $ ...future.elements_ii    :List of 2
[16:17:47.346]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:17:47.346]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:17:47.346]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.346]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:17:47.346]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:17:47.346]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.346]  $ ...future.seeds_ii       : NULL
[16:17:47.346]  $ ...future.globals.maxSize: NULL
[16:17:47.346]  - attr(*, "where")=List of 5
[16:17:47.346]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:47.346]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:47.346]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:47.346]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:47.346]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:47.346]  - attr(*, "resolved")= logi FALSE
[16:17:47.346]  - attr(*, "total_size")= num 1240
[16:17:47.346]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.346]  - attr(*, "already-done")= logi TRUE
[16:17:47.355] - copied ‘...future.FUN’ to environment
[16:17:47.355] - copied ‘future.call.arguments’ to environment
[16:17:47.355] - copied ‘...future.elements_ii’ to environment
[16:17:47.356] - copied ‘...future.seeds_ii’ to environment
[16:17:47.356] - copied ‘...future.globals.maxSize’ to environment
[16:17:47.356] assign_globals() ... done
[16:17:47.356] requestCore(): workers = 2
[16:17:47.361] MulticoreFuture started
[16:17:47.361] - Launch lazy future ... done
[16:17:47.361] run() for ‘MulticoreFuture’ ... done
[16:17:47.362] Created future:
[16:17:47.362] plan(): Setting new future strategy stack:
[16:17:47.362] List of future strategies:
[16:17:47.362] 1. sequential:
[16:17:47.362]    - args: function (..., envir = parent.frame())
[16:17:47.362]    - tweaked: FALSE
[16:17:47.362]    - call: NULL
[16:17:47.363] plan(): nbrOfWorkers() = 1
[16:17:47.362] MulticoreFuture:
[16:17:47.362] Label: ‘future_by-2’
[16:17:47.362] Expression:
[16:17:47.362] {
[16:17:47.362]     do.call(function(...) {
[16:17:47.362]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.362]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.362]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.362]             on.exit(options(oopts), add = TRUE)
[16:17:47.362]         }
[16:17:47.362]         {
[16:17:47.362]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.362]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.362]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.362]             })
[16:17:47.362]         }
[16:17:47.362]     }, args = future.call.arguments)
[16:17:47.362] }
[16:17:47.362] Lazy evaluation: FALSE
[16:17:47.362] Asynchronous evaluation: TRUE
[16:17:47.362] Local evaluation: TRUE
[16:17:47.362] Environment: R_GlobalEnv
[16:17:47.362] Capture standard output: TRUE
[16:17:47.362] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:47.362] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:47.362] Packages: <none>
[16:17:47.362] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:47.362] Resolved: FALSE
[16:17:47.362] Value: <not collected>
[16:17:47.362] Conditions captured: <none>
[16:17:47.362] Early signaling: FALSE
[16:17:47.362] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:47.362] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:47.375] Chunk #2 of 2 ... DONE
[16:17:47.375] Launching 2 futures (chunks) ... DONE
[16:17:47.375] Resolving 2 futures (chunks) ...
[16:17:47.378] plan(): Setting new future strategy stack:
[16:17:47.378] List of future strategies:
[16:17:47.378] 1. multicore:
[16:17:47.378]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:47.378]    - tweaked: FALSE
[16:17:47.378]    - call: plan(strategy)
[16:17:47.382] plan(): nbrOfWorkers() = 2
[16:17:47.383] resolve() on list ...
[16:17:47.383]  recursive: 0
[16:17:47.383]  length: 2
[16:17:47.383] 
[16:17:47.383] Future #1
[16:17:47.384] result() for MulticoreFuture ...
[16:17:47.386] result() for MulticoreFuture ...
[16:17:47.386] result() for MulticoreFuture ... done
[16:17:47.386] result() for MulticoreFuture ... done
[16:17:47.386] result() for MulticoreFuture ...
[16:17:47.386] result() for MulticoreFuture ... done
[16:17:47.387] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:17:47.387] - nx: 2
[16:17:47.387] - relay: TRUE
[16:17:47.387] - stdout: TRUE
[16:17:47.387] - signal: TRUE
[16:17:47.388] - resignal: FALSE
[16:17:47.388] - force: TRUE
[16:17:47.388] - relayed: [n=2] FALSE, FALSE
[16:17:47.388] - queued futures: [n=2] FALSE, FALSE
[16:17:47.389]  - until=1
[16:17:47.389]  - relaying element #1
[16:17:47.389] result() for MulticoreFuture ...
[16:17:47.389] result() for MulticoreFuture ... done
[16:17:47.389] result() for MulticoreFuture ...
[16:17:47.390] result() for MulticoreFuture ... done
[16:17:47.390] result() for MulticoreFuture ...
[16:17:47.390] result() for MulticoreFuture ... done
[16:17:47.390] result() for MulticoreFuture ...
[16:17:47.391] result() for MulticoreFuture ... done
[16:17:47.391] - relayed: [n=2] TRUE, FALSE
[16:17:47.391] - queued futures: [n=2] TRUE, FALSE
[16:17:47.391] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:17:47.391]  length: 1 (resolved future 1)
[16:17:47.392] Future #2
[16:17:47.392] result() for MulticoreFuture ...
[16:17:47.393] result() for MulticoreFuture ...
[16:17:47.393] result() for MulticoreFuture ... done
[16:17:47.393] result() for MulticoreFuture ... done
[16:17:47.393] result() for MulticoreFuture ...
[16:17:47.393] result() for MulticoreFuture ... done
[16:17:47.393] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:17:47.394] - nx: 2
[16:17:47.394] - relay: TRUE
[16:17:47.394] - stdout: TRUE
[16:17:47.394] - signal: TRUE
[16:17:47.394] - resignal: FALSE
[16:17:47.394] - force: TRUE
[16:17:47.394] - relayed: [n=2] TRUE, FALSE
[16:17:47.395] - queued futures: [n=2] TRUE, FALSE
[16:17:47.395]  - until=2
[16:17:47.395]  - relaying element #2
[16:17:47.395] result() for MulticoreFuture ...
[16:17:47.395] result() for MulticoreFuture ... done
[16:17:47.395] result() for MulticoreFuture ...
[16:17:47.395] result() for MulticoreFuture ... done
[16:17:47.396] result() for MulticoreFuture ...
[16:17:47.396] result() for MulticoreFuture ... done
[16:17:47.396] result() for MulticoreFuture ...
[16:17:47.396] result() for MulticoreFuture ... done
[16:17:47.396] - relayed: [n=2] TRUE, TRUE
[16:17:47.396] - queued futures: [n=2] TRUE, TRUE
[16:17:47.396] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:17:47.396]  length: 0 (resolved future 2)
[16:17:47.396] Relaying remaining futures
[16:17:47.397] signalConditionsASAP(NULL, pos=0) ...
[16:17:47.397] - nx: 2
[16:17:47.397] - relay: TRUE
[16:17:47.397] - stdout: TRUE
[16:17:47.397] - signal: TRUE
[16:17:47.397] - resignal: FALSE
[16:17:47.397] - force: TRUE
[16:17:47.397] - relayed: [n=2] TRUE, TRUE
[16:17:47.397] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:47.397] - relayed: [n=2] TRUE, TRUE
[16:17:47.398] - queued futures: [n=2] TRUE, TRUE
[16:17:47.398] signalConditionsASAP(NULL, pos=0) ... done
[16:17:47.398] resolve() on list ... DONE
[16:17:47.398] result() for MulticoreFuture ...
[16:17:47.398] result() for MulticoreFuture ... done
[16:17:47.398] result() for MulticoreFuture ...
[16:17:47.398] result() for MulticoreFuture ... done
[16:17:47.398] result() for MulticoreFuture ...
[16:17:47.398] result() for MulticoreFuture ... done
[16:17:47.399] result() for MulticoreFuture ...
[16:17:47.399] result() for MulticoreFuture ... done
[16:17:47.399]  - Number of value chunks collected: 2
[16:17:47.399] Resolving 2 futures (chunks) ... DONE
[16:17:47.399] Reducing values from 2 chunks ...
[16:17:47.399]  - Number of values collected after concatenation: 3
[16:17:47.399]  - Number of values expected: 3
[16:17:47.399] Reducing values from 2 chunks ... DONE
[16:17:47.399] future_lapply() ... DONE
[16:17:47.399] future_by_internal() ... DONE
[16:17:47.400] future_by_internal() ...
[16:17:47.400] future_lapply() ...
[16:17:47.405] Number of chunks: 2
[16:17:47.405] getGlobalsAndPackagesXApply() ...
[16:17:47.405]  - future.globals: TRUE
[16:17:47.405] getGlobalsAndPackages() ...
[16:17:47.405] Searching for globals...
[16:17:47.406] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:47.406] Searching for globals ... DONE
[16:17:47.407] Resolving globals: FALSE
[16:17:47.407] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:47.407] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:47.407] - globals: [1] ‘FUN’
[16:17:47.408] 
[16:17:47.408] getGlobalsAndPackages() ... DONE
[16:17:47.408]  - globals found/used: [n=1] ‘FUN’
[16:17:47.408]  - needed namespaces: [n=0] 
[16:17:47.408] Finding globals ... DONE
[16:17:47.408]  - use_args: TRUE
[16:17:47.408]  - Getting '...' globals ...
[16:17:47.408] resolve() on list ...
[16:17:47.409]  recursive: 0
[16:17:47.409]  length: 1
[16:17:47.409]  elements: ‘...’
[16:17:47.409]  length: 0 (resolved future 1)
[16:17:47.409] resolve() on list ... DONE
[16:17:47.409]    - '...' content: [n=1] ‘digits’
[16:17:47.409] List of 1
[16:17:47.409]  $ ...:List of 1
[16:17:47.409]   ..$ digits: int 2
[16:17:47.409]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.409]  - attr(*, "where")=List of 1
[16:17:47.409]   ..$ ...:<environment: 0x55b565b775a0> 
[16:17:47.409]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.409]  - attr(*, "resolved")= logi TRUE
[16:17:47.409]  - attr(*, "total_size")= num NA
[16:17:47.414]  - Getting '...' globals ... DONE
[16:17:47.414] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:47.414] List of 2
[16:17:47.414]  $ ...future.FUN:function (object, ...)  
[16:17:47.414]  $ ...          :List of 1
[16:17:47.414]   ..$ digits: int 2
[16:17:47.414]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.414]  - attr(*, "where")=List of 2
[16:17:47.414]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:47.414]   ..$ ...          :<environment: 0x55b565b775a0> 
[16:17:47.414]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.414]  - attr(*, "resolved")= logi FALSE
[16:17:47.414]  - attr(*, "total_size")= num 1296
[16:17:47.418] Packages to be attached in all futures: [n=0] 
[16:17:47.418] getGlobalsAndPackagesXApply() ... DONE
[16:17:47.418] Number of futures (= number of chunks): 2
[16:17:47.418] Launching 2 futures (chunks) ...
[16:17:47.418] Chunk #1 of 2 ...
[16:17:47.418]  - Finding globals in 'X' for chunk #1 ...
[16:17:47.418] getGlobalsAndPackages() ...
[16:17:47.418] Searching for globals...
[16:17:47.419] 
[16:17:47.419] Searching for globals ... DONE
[16:17:47.419] - globals: [0] <none>
[16:17:47.419] getGlobalsAndPackages() ... DONE
[16:17:47.419]    + additional globals found: [n=0] 
[16:17:47.419]    + additional namespaces needed: [n=0] 
[16:17:47.419]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:47.419]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:47.419]  - seeds: <none>
[16:17:47.420]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.420] getGlobalsAndPackages() ...
[16:17:47.420] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.420] Resolving globals: FALSE
[16:17:47.420] Tweak future expression to call with '...' arguments ...
[16:17:47.420] {
[16:17:47.420]     do.call(function(...) {
[16:17:47.420]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.420]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.420]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.420]             on.exit(options(oopts), add = TRUE)
[16:17:47.420]         }
[16:17:47.420]         {
[16:17:47.420]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.420]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.420]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.420]             })
[16:17:47.420]         }
[16:17:47.420]     }, args = future.call.arguments)
[16:17:47.420] }
[16:17:47.420] Tweak future expression to call with '...' arguments ... DONE
[16:17:47.421] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.421] 
[16:17:47.421] getGlobalsAndPackages() ... DONE
[16:17:47.421] run() for ‘Future’ ...
[16:17:47.421] - state: ‘created’
[16:17:47.422] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:47.425] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:47.425] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:47.425]   - Field: ‘label’
[16:17:47.426]   - Field: ‘local’
[16:17:47.426]   - Field: ‘owner’
[16:17:47.426]   - Field: ‘envir’
[16:17:47.426]   - Field: ‘workers’
[16:17:47.426]   - Field: ‘packages’
[16:17:47.426]   - Field: ‘gc’
[16:17:47.426]   - Field: ‘job’
[16:17:47.426]   - Field: ‘conditions’
[16:17:47.426]   - Field: ‘expr’
[16:17:47.426]   - Field: ‘uuid’
[16:17:47.426]   - Field: ‘seed’
[16:17:47.427]   - Field: ‘version’
[16:17:47.427]   - Field: ‘result’
[16:17:47.427]   - Field: ‘asynchronous’
[16:17:47.427]   - Field: ‘calls’
[16:17:47.427]   - Field: ‘globals’
[16:17:47.427]   - Field: ‘stdout’
[16:17:47.427]   - Field: ‘earlySignal’
[16:17:47.427]   - Field: ‘lazy’
[16:17:47.427]   - Field: ‘state’
[16:17:47.427] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:47.427] - Launch lazy future ...
[16:17:47.428] Packages needed by the future expression (n = 0): <none>
[16:17:47.428] Packages needed by future strategies (n = 0): <none>
[16:17:47.428] {
[16:17:47.428]     {
[16:17:47.428]         {
[16:17:47.428]             ...future.startTime <- base::Sys.time()
[16:17:47.428]             {
[16:17:47.428]                 {
[16:17:47.428]                   {
[16:17:47.428]                     {
[16:17:47.428]                       base::local({
[16:17:47.428]                         has_future <- base::requireNamespace("future", 
[16:17:47.428]                           quietly = TRUE)
[16:17:47.428]                         if (has_future) {
[16:17:47.428]                           ns <- base::getNamespace("future")
[16:17:47.428]                           version <- ns[[".package"]][["version"]]
[16:17:47.428]                           if (is.null(version)) 
[16:17:47.428]                             version <- utils::packageVersion("future")
[16:17:47.428]                         }
[16:17:47.428]                         else {
[16:17:47.428]                           version <- NULL
[16:17:47.428]                         }
[16:17:47.428]                         if (!has_future || version < "1.8.0") {
[16:17:47.428]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:47.428]                             "", base::R.version$version.string), 
[16:17:47.428]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:47.428]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:47.428]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:47.428]                               "release", "version")], collapse = " "), 
[16:17:47.428]                             hostname = base::Sys.info()[["nodename"]])
[16:17:47.428]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:47.428]                             info)
[16:17:47.428]                           info <- base::paste(info, collapse = "; ")
[16:17:47.428]                           if (!has_future) {
[16:17:47.428]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:47.428]                               info)
[16:17:47.428]                           }
[16:17:47.428]                           else {
[16:17:47.428]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:47.428]                               info, version)
[16:17:47.428]                           }
[16:17:47.428]                           base::stop(msg)
[16:17:47.428]                         }
[16:17:47.428]                       })
[16:17:47.428]                     }
[16:17:47.428]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:47.428]                     base::options(mc.cores = 1L)
[16:17:47.428]                   }
[16:17:47.428]                   ...future.strategy.old <- future::plan("list")
[16:17:47.428]                   options(future.plan = NULL)
[16:17:47.428]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.428]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:47.428]                 }
[16:17:47.428]                 ...future.workdir <- getwd()
[16:17:47.428]             }
[16:17:47.428]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:47.428]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:47.428]         }
[16:17:47.428]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:47.428]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:47.428]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:47.428]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:47.428]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:47.428]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:47.428]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:47.428]             base::names(...future.oldOptions))
[16:17:47.428]     }
[16:17:47.428]     if (FALSE) {
[16:17:47.428]     }
[16:17:47.428]     else {
[16:17:47.428]         if (TRUE) {
[16:17:47.428]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:47.428]                 open = "w")
[16:17:47.428]         }
[16:17:47.428]         else {
[16:17:47.428]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:47.428]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:47.428]         }
[16:17:47.428]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:47.428]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:47.428]             base::sink(type = "output", split = FALSE)
[16:17:47.428]             base::close(...future.stdout)
[16:17:47.428]         }, add = TRUE)
[16:17:47.428]     }
[16:17:47.428]     ...future.frame <- base::sys.nframe()
[16:17:47.428]     ...future.conditions <- base::list()
[16:17:47.428]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:47.428]     if (FALSE) {
[16:17:47.428]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:47.428]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:47.428]     }
[16:17:47.428]     ...future.result <- base::tryCatch({
[16:17:47.428]         base::withCallingHandlers({
[16:17:47.428]             ...future.value <- base::withVisible(base::local({
[16:17:47.428]                 withCallingHandlers({
[16:17:47.428]                   {
[16:17:47.428]                     do.call(function(...) {
[16:17:47.428]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.428]                       if (!identical(...future.globals.maxSize.org, 
[16:17:47.428]                         ...future.globals.maxSize)) {
[16:17:47.428]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.428]                         on.exit(options(oopts), add = TRUE)
[16:17:47.428]                       }
[16:17:47.428]                       {
[16:17:47.428]                         lapply(seq_along(...future.elements_ii), 
[16:17:47.428]                           FUN = function(jj) {
[16:17:47.428]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.428]                             ...future.FUN(...future.X_jj, ...)
[16:17:47.428]                           })
[16:17:47.428]                       }
[16:17:47.428]                     }, args = future.call.arguments)
[16:17:47.428]                   }
[16:17:47.428]                 }, immediateCondition = function(cond) {
[16:17:47.428]                   save_rds <- function (object, pathname, ...) 
[16:17:47.428]                   {
[16:17:47.428]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:47.428]                     if (file_test("-f", pathname_tmp)) {
[16:17:47.428]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.428]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:47.428]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.428]                         fi_tmp[["mtime"]])
[16:17:47.428]                     }
[16:17:47.428]                     tryCatch({
[16:17:47.428]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:47.428]                     }, error = function(ex) {
[16:17:47.428]                       msg <- conditionMessage(ex)
[16:17:47.428]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.428]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:47.428]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.428]                         fi_tmp[["mtime"]], msg)
[16:17:47.428]                       ex$message <- msg
[16:17:47.428]                       stop(ex)
[16:17:47.428]                     })
[16:17:47.428]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:47.428]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:47.428]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:47.428]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.428]                       fi <- file.info(pathname)
[16:17:47.428]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:47.428]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.428]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:47.428]                         fi[["size"]], fi[["mtime"]])
[16:17:47.428]                       stop(msg)
[16:17:47.428]                     }
[16:17:47.428]                     invisible(pathname)
[16:17:47.428]                   }
[16:17:47.428]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:47.428]                     rootPath = tempdir()) 
[16:17:47.428]                   {
[16:17:47.428]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:47.428]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:47.428]                       tmpdir = path, fileext = ".rds")
[16:17:47.428]                     save_rds(obj, file)
[16:17:47.428]                   }
[16:17:47.428]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1cUuyG/.future/immediateConditions")
[16:17:47.428]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.428]                   {
[16:17:47.428]                     inherits <- base::inherits
[16:17:47.428]                     invokeRestart <- base::invokeRestart
[16:17:47.428]                     is.null <- base::is.null
[16:17:47.428]                     muffled <- FALSE
[16:17:47.428]                     if (inherits(cond, "message")) {
[16:17:47.428]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:47.428]                       if (muffled) 
[16:17:47.428]                         invokeRestart("muffleMessage")
[16:17:47.428]                     }
[16:17:47.428]                     else if (inherits(cond, "warning")) {
[16:17:47.428]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:47.428]                       if (muffled) 
[16:17:47.428]                         invokeRestart("muffleWarning")
[16:17:47.428]                     }
[16:17:47.428]                     else if (inherits(cond, "condition")) {
[16:17:47.428]                       if (!is.null(pattern)) {
[16:17:47.428]                         computeRestarts <- base::computeRestarts
[16:17:47.428]                         grepl <- base::grepl
[16:17:47.428]                         restarts <- computeRestarts(cond)
[16:17:47.428]                         for (restart in restarts) {
[16:17:47.428]                           name <- restart$name
[16:17:47.428]                           if (is.null(name)) 
[16:17:47.428]                             next
[16:17:47.428]                           if (!grepl(pattern, name)) 
[16:17:47.428]                             next
[16:17:47.428]                           invokeRestart(restart)
[16:17:47.428]                           muffled <- TRUE
[16:17:47.428]                           break
[16:17:47.428]                         }
[16:17:47.428]                       }
[16:17:47.428]                     }
[16:17:47.428]                     invisible(muffled)
[16:17:47.428]                   }
[16:17:47.428]                   muffleCondition(cond)
[16:17:47.428]                 })
[16:17:47.428]             }))
[16:17:47.428]             future::FutureResult(value = ...future.value$value, 
[16:17:47.428]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.428]                   ...future.rng), globalenv = if (FALSE) 
[16:17:47.428]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:47.428]                     ...future.globalenv.names))
[16:17:47.428]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:47.428]         }, condition = base::local({
[16:17:47.428]             c <- base::c
[16:17:47.428]             inherits <- base::inherits
[16:17:47.428]             invokeRestart <- base::invokeRestart
[16:17:47.428]             length <- base::length
[16:17:47.428]             list <- base::list
[16:17:47.428]             seq.int <- base::seq.int
[16:17:47.428]             signalCondition <- base::signalCondition
[16:17:47.428]             sys.calls <- base::sys.calls
[16:17:47.428]             `[[` <- base::`[[`
[16:17:47.428]             `+` <- base::`+`
[16:17:47.428]             `<<-` <- base::`<<-`
[16:17:47.428]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:47.428]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:47.428]                   3L)]
[16:17:47.428]             }
[16:17:47.428]             function(cond) {
[16:17:47.428]                 is_error <- inherits(cond, "error")
[16:17:47.428]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:47.428]                   NULL)
[16:17:47.428]                 if (is_error) {
[16:17:47.428]                   sessionInformation <- function() {
[16:17:47.428]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:47.428]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:47.428]                       search = base::search(), system = base::Sys.info())
[16:17:47.428]                   }
[16:17:47.428]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.428]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:47.428]                     cond$call), session = sessionInformation(), 
[16:17:47.428]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:47.428]                   signalCondition(cond)
[16:17:47.428]                 }
[16:17:47.428]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:47.428]                 "immediateCondition"))) {
[16:17:47.428]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:47.428]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.428]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:47.428]                   if (TRUE && !signal) {
[16:17:47.428]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.428]                     {
[16:17:47.428]                       inherits <- base::inherits
[16:17:47.428]                       invokeRestart <- base::invokeRestart
[16:17:47.428]                       is.null <- base::is.null
[16:17:47.428]                       muffled <- FALSE
[16:17:47.428]                       if (inherits(cond, "message")) {
[16:17:47.428]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.428]                         if (muffled) 
[16:17:47.428]                           invokeRestart("muffleMessage")
[16:17:47.428]                       }
[16:17:47.428]                       else if (inherits(cond, "warning")) {
[16:17:47.428]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.428]                         if (muffled) 
[16:17:47.428]                           invokeRestart("muffleWarning")
[16:17:47.428]                       }
[16:17:47.428]                       else if (inherits(cond, "condition")) {
[16:17:47.428]                         if (!is.null(pattern)) {
[16:17:47.428]                           computeRestarts <- base::computeRestarts
[16:17:47.428]                           grepl <- base::grepl
[16:17:47.428]                           restarts <- computeRestarts(cond)
[16:17:47.428]                           for (restart in restarts) {
[16:17:47.428]                             name <- restart$name
[16:17:47.428]                             if (is.null(name)) 
[16:17:47.428]                               next
[16:17:47.428]                             if (!grepl(pattern, name)) 
[16:17:47.428]                               next
[16:17:47.428]                             invokeRestart(restart)
[16:17:47.428]                             muffled <- TRUE
[16:17:47.428]                             break
[16:17:47.428]                           }
[16:17:47.428]                         }
[16:17:47.428]                       }
[16:17:47.428]                       invisible(muffled)
[16:17:47.428]                     }
[16:17:47.428]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.428]                   }
[16:17:47.428]                 }
[16:17:47.428]                 else {
[16:17:47.428]                   if (TRUE) {
[16:17:47.428]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.428]                     {
[16:17:47.428]                       inherits <- base::inherits
[16:17:47.428]                       invokeRestart <- base::invokeRestart
[16:17:47.428]                       is.null <- base::is.null
[16:17:47.428]                       muffled <- FALSE
[16:17:47.428]                       if (inherits(cond, "message")) {
[16:17:47.428]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.428]                         if (muffled) 
[16:17:47.428]                           invokeRestart("muffleMessage")
[16:17:47.428]                       }
[16:17:47.428]                       else if (inherits(cond, "warning")) {
[16:17:47.428]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.428]                         if (muffled) 
[16:17:47.428]                           invokeRestart("muffleWarning")
[16:17:47.428]                       }
[16:17:47.428]                       else if (inherits(cond, "condition")) {
[16:17:47.428]                         if (!is.null(pattern)) {
[16:17:47.428]                           computeRestarts <- base::computeRestarts
[16:17:47.428]                           grepl <- base::grepl
[16:17:47.428]                           restarts <- computeRestarts(cond)
[16:17:47.428]                           for (restart in restarts) {
[16:17:47.428]                             name <- restart$name
[16:17:47.428]                             if (is.null(name)) 
[16:17:47.428]                               next
[16:17:47.428]                             if (!grepl(pattern, name)) 
[16:17:47.428]                               next
[16:17:47.428]                             invokeRestart(restart)
[16:17:47.428]                             muffled <- TRUE
[16:17:47.428]                             break
[16:17:47.428]                           }
[16:17:47.428]                         }
[16:17:47.428]                       }
[16:17:47.428]                       invisible(muffled)
[16:17:47.428]                     }
[16:17:47.428]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.428]                   }
[16:17:47.428]                 }
[16:17:47.428]             }
[16:17:47.428]         }))
[16:17:47.428]     }, error = function(ex) {
[16:17:47.428]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:47.428]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.428]                 ...future.rng), started = ...future.startTime, 
[16:17:47.428]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:47.428]             version = "1.8"), class = "FutureResult")
[16:17:47.428]     }, finally = {
[16:17:47.428]         if (!identical(...future.workdir, getwd())) 
[16:17:47.428]             setwd(...future.workdir)
[16:17:47.428]         {
[16:17:47.428]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:47.428]                 ...future.oldOptions$nwarnings <- NULL
[16:17:47.428]             }
[16:17:47.428]             base::options(...future.oldOptions)
[16:17:47.428]             if (.Platform$OS.type == "windows") {
[16:17:47.428]                 old_names <- names(...future.oldEnvVars)
[16:17:47.428]                 envs <- base::Sys.getenv()
[16:17:47.428]                 names <- names(envs)
[16:17:47.428]                 common <- intersect(names, old_names)
[16:17:47.428]                 added <- setdiff(names, old_names)
[16:17:47.428]                 removed <- setdiff(old_names, names)
[16:17:47.428]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:47.428]                   envs[common]]
[16:17:47.428]                 NAMES <- toupper(changed)
[16:17:47.428]                 args <- list()
[16:17:47.428]                 for (kk in seq_along(NAMES)) {
[16:17:47.428]                   name <- changed[[kk]]
[16:17:47.428]                   NAME <- NAMES[[kk]]
[16:17:47.428]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.428]                     next
[16:17:47.428]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.428]                 }
[16:17:47.428]                 NAMES <- toupper(added)
[16:17:47.428]                 for (kk in seq_along(NAMES)) {
[16:17:47.428]                   name <- added[[kk]]
[16:17:47.428]                   NAME <- NAMES[[kk]]
[16:17:47.428]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.428]                     next
[16:17:47.428]                   args[[name]] <- ""
[16:17:47.428]                 }
[16:17:47.428]                 NAMES <- toupper(removed)
[16:17:47.428]                 for (kk in seq_along(NAMES)) {
[16:17:47.428]                   name <- removed[[kk]]
[16:17:47.428]                   NAME <- NAMES[[kk]]
[16:17:47.428]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.428]                     next
[16:17:47.428]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.428]                 }
[16:17:47.428]                 if (length(args) > 0) 
[16:17:47.428]                   base::do.call(base::Sys.setenv, args = args)
[16:17:47.428]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:47.428]             }
[16:17:47.428]             else {
[16:17:47.428]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:47.428]             }
[16:17:47.428]             {
[16:17:47.428]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:47.428]                   0L) {
[16:17:47.428]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:47.428]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:47.428]                   base::options(opts)
[16:17:47.428]                 }
[16:17:47.428]                 {
[16:17:47.428]                   {
[16:17:47.428]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:47.428]                     NULL
[16:17:47.428]                   }
[16:17:47.428]                   options(future.plan = NULL)
[16:17:47.428]                   if (is.na(NA_character_)) 
[16:17:47.428]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.428]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:47.428]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:47.428]                     .init = FALSE)
[16:17:47.428]                 }
[16:17:47.428]             }
[16:17:47.428]         }
[16:17:47.428]     })
[16:17:47.428]     if (TRUE) {
[16:17:47.428]         base::sink(type = "output", split = FALSE)
[16:17:47.428]         if (TRUE) {
[16:17:47.428]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:47.428]         }
[16:17:47.428]         else {
[16:17:47.428]             ...future.result["stdout"] <- base::list(NULL)
[16:17:47.428]         }
[16:17:47.428]         base::close(...future.stdout)
[16:17:47.428]         ...future.stdout <- NULL
[16:17:47.428]     }
[16:17:47.428]     ...future.result$conditions <- ...future.conditions
[16:17:47.428]     ...future.result$finished <- base::Sys.time()
[16:17:47.428]     ...future.result
[16:17:47.428] }
[16:17:47.431] assign_globals() ...
[16:17:47.431] List of 5
[16:17:47.431]  $ ...future.FUN            :function (object, ...)  
[16:17:47.431]  $ future.call.arguments    :List of 1
[16:17:47.431]   ..$ digits: int 2
[16:17:47.431]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.431]  $ ...future.elements_ii    :List of 3
[16:17:47.431]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[16:17:47.431]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[16:17:47.431]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[16:17:47.431]  $ ...future.seeds_ii       : NULL
[16:17:47.431]  $ ...future.globals.maxSize: NULL
[16:17:47.431]  - attr(*, "where")=List of 5
[16:17:47.431]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:47.431]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:47.431]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:47.431]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:47.431]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:47.431]  - attr(*, "resolved")= logi FALSE
[16:17:47.431]  - attr(*, "total_size")= num 1296
[16:17:47.431]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.431]  - attr(*, "already-done")= logi TRUE
[16:17:47.438] - copied ‘...future.FUN’ to environment
[16:17:47.438] - copied ‘future.call.arguments’ to environment
[16:17:47.438] - copied ‘...future.elements_ii’ to environment
[16:17:47.438] - copied ‘...future.seeds_ii’ to environment
[16:17:47.438] - copied ‘...future.globals.maxSize’ to environment
[16:17:47.438] assign_globals() ... done
[16:17:47.438] requestCore(): workers = 2
[16:17:47.440] MulticoreFuture started
[16:17:47.441] - Launch lazy future ... done
[16:17:47.442] run() for ‘MulticoreFuture’ ... done
[16:17:47.442] plan(): Setting new future strategy stack:
[16:17:47.442] Created future:
[16:17:47.442] List of future strategies:
[16:17:47.442] 1. sequential:
[16:17:47.442]    - args: function (..., envir = parent.frame())
[16:17:47.442]    - tweaked: FALSE
[16:17:47.442]    - call: NULL
[16:17:47.443] plan(): nbrOfWorkers() = 1
[16:17:47.448] plan(): Setting new future strategy stack:
[16:17:47.448] List of future strategies:
[16:17:47.448] 1. multicore:
[16:17:47.448]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:47.448]    - tweaked: FALSE
[16:17:47.448]    - call: plan(strategy)
[16:17:47.454] plan(): nbrOfWorkers() = 2
[16:17:47.443] MulticoreFuture:
[16:17:47.443] Label: ‘future_by-1’
[16:17:47.443] Expression:
[16:17:47.443] {
[16:17:47.443]     do.call(function(...) {
[16:17:47.443]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.443]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.443]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.443]             on.exit(options(oopts), add = TRUE)
[16:17:47.443]         }
[16:17:47.443]         {
[16:17:47.443]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.443]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.443]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.443]             })
[16:17:47.443]         }
[16:17:47.443]     }, args = future.call.arguments)
[16:17:47.443] }
[16:17:47.443] Lazy evaluation: FALSE
[16:17:47.443] Asynchronous evaluation: TRUE
[16:17:47.443] Local evaluation: TRUE
[16:17:47.443] Environment: R_GlobalEnv
[16:17:47.443] Capture standard output: TRUE
[16:17:47.443] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:47.443] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:47.443] Packages: <none>
[16:17:47.443] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:47.443] Resolved: TRUE
[16:17:47.443] Value: <not collected>
[16:17:47.443] Conditions captured: <none>
[16:17:47.443] Early signaling: FALSE
[16:17:47.443] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:47.443] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:47.456] Chunk #1 of 2 ... DONE
[16:17:47.456] Chunk #2 of 2 ...
[16:17:47.456]  - Finding globals in 'X' for chunk #2 ...
[16:17:47.457] getGlobalsAndPackages() ...
[16:17:47.457] Searching for globals...
[16:17:47.457] 
[16:17:47.458] Searching for globals ... DONE
[16:17:47.458] - globals: [0] <none>
[16:17:47.458] getGlobalsAndPackages() ... DONE
[16:17:47.458]    + additional globals found: [n=0] 
[16:17:47.458]    + additional namespaces needed: [n=0] 
[16:17:47.458]  - Finding globals in 'X' for chunk #2 ... DONE
[16:17:47.459]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:47.459]  - seeds: <none>
[16:17:47.459]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.459] getGlobalsAndPackages() ...
[16:17:47.459] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.460] Resolving globals: FALSE
[16:17:47.460] Tweak future expression to call with '...' arguments ...
[16:17:47.460] {
[16:17:47.460]     do.call(function(...) {
[16:17:47.460]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.460]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.460]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.460]             on.exit(options(oopts), add = TRUE)
[16:17:47.460]         }
[16:17:47.460]         {
[16:17:47.460]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.460]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.460]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.460]             })
[16:17:47.460]         }
[16:17:47.460]     }, args = future.call.arguments)
[16:17:47.460] }
[16:17:47.460] Tweak future expression to call with '...' arguments ... DONE
[16:17:47.461] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.461] 
[16:17:47.462] getGlobalsAndPackages() ... DONE
[16:17:47.462] run() for ‘Future’ ...
[16:17:47.462] - state: ‘created’
[16:17:47.462] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:47.467] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:47.467] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:47.467]   - Field: ‘label’
[16:17:47.467]   - Field: ‘local’
[16:17:47.468]   - Field: ‘owner’
[16:17:47.468]   - Field: ‘envir’
[16:17:47.468]   - Field: ‘workers’
[16:17:47.468]   - Field: ‘packages’
[16:17:47.468]   - Field: ‘gc’
[16:17:47.468]   - Field: ‘job’
[16:17:47.469]   - Field: ‘conditions’
[16:17:47.469]   - Field: ‘expr’
[16:17:47.469]   - Field: ‘uuid’
[16:17:47.469]   - Field: ‘seed’
[16:17:47.469]   - Field: ‘version’
[16:17:47.469]   - Field: ‘result’
[16:17:47.469]   - Field: ‘asynchronous’
[16:17:47.469]   - Field: ‘calls’
[16:17:47.470]   - Field: ‘globals’
[16:17:47.470]   - Field: ‘stdout’
[16:17:47.470]   - Field: ‘earlySignal’
[16:17:47.470]   - Field: ‘lazy’
[16:17:47.470]   - Field: ‘state’
[16:17:47.470] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:47.470] - Launch lazy future ...
[16:17:47.471] Packages needed by the future expression (n = 0): <none>
[16:17:47.471] Packages needed by future strategies (n = 0): <none>
[16:17:47.472] {
[16:17:47.472]     {
[16:17:47.472]         {
[16:17:47.472]             ...future.startTime <- base::Sys.time()
[16:17:47.472]             {
[16:17:47.472]                 {
[16:17:47.472]                   {
[16:17:47.472]                     {
[16:17:47.472]                       base::local({
[16:17:47.472]                         has_future <- base::requireNamespace("future", 
[16:17:47.472]                           quietly = TRUE)
[16:17:47.472]                         if (has_future) {
[16:17:47.472]                           ns <- base::getNamespace("future")
[16:17:47.472]                           version <- ns[[".package"]][["version"]]
[16:17:47.472]                           if (is.null(version)) 
[16:17:47.472]                             version <- utils::packageVersion("future")
[16:17:47.472]                         }
[16:17:47.472]                         else {
[16:17:47.472]                           version <- NULL
[16:17:47.472]                         }
[16:17:47.472]                         if (!has_future || version < "1.8.0") {
[16:17:47.472]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:47.472]                             "", base::R.version$version.string), 
[16:17:47.472]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:47.472]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:47.472]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:47.472]                               "release", "version")], collapse = " "), 
[16:17:47.472]                             hostname = base::Sys.info()[["nodename"]])
[16:17:47.472]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:47.472]                             info)
[16:17:47.472]                           info <- base::paste(info, collapse = "; ")
[16:17:47.472]                           if (!has_future) {
[16:17:47.472]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:47.472]                               info)
[16:17:47.472]                           }
[16:17:47.472]                           else {
[16:17:47.472]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:47.472]                               info, version)
[16:17:47.472]                           }
[16:17:47.472]                           base::stop(msg)
[16:17:47.472]                         }
[16:17:47.472]                       })
[16:17:47.472]                     }
[16:17:47.472]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:47.472]                     base::options(mc.cores = 1L)
[16:17:47.472]                   }
[16:17:47.472]                   ...future.strategy.old <- future::plan("list")
[16:17:47.472]                   options(future.plan = NULL)
[16:17:47.472]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.472]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:47.472]                 }
[16:17:47.472]                 ...future.workdir <- getwd()
[16:17:47.472]             }
[16:17:47.472]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:47.472]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:47.472]         }
[16:17:47.472]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:47.472]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:47.472]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:47.472]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:47.472]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:47.472]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:47.472]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:47.472]             base::names(...future.oldOptions))
[16:17:47.472]     }
[16:17:47.472]     if (FALSE) {
[16:17:47.472]     }
[16:17:47.472]     else {
[16:17:47.472]         if (TRUE) {
[16:17:47.472]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:47.472]                 open = "w")
[16:17:47.472]         }
[16:17:47.472]         else {
[16:17:47.472]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:47.472]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:47.472]         }
[16:17:47.472]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:47.472]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:47.472]             base::sink(type = "output", split = FALSE)
[16:17:47.472]             base::close(...future.stdout)
[16:17:47.472]         }, add = TRUE)
[16:17:47.472]     }
[16:17:47.472]     ...future.frame <- base::sys.nframe()
[16:17:47.472]     ...future.conditions <- base::list()
[16:17:47.472]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:47.472]     if (FALSE) {
[16:17:47.472]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:47.472]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:47.472]     }
[16:17:47.472]     ...future.result <- base::tryCatch({
[16:17:47.472]         base::withCallingHandlers({
[16:17:47.472]             ...future.value <- base::withVisible(base::local({
[16:17:47.472]                 withCallingHandlers({
[16:17:47.472]                   {
[16:17:47.472]                     do.call(function(...) {
[16:17:47.472]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.472]                       if (!identical(...future.globals.maxSize.org, 
[16:17:47.472]                         ...future.globals.maxSize)) {
[16:17:47.472]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.472]                         on.exit(options(oopts), add = TRUE)
[16:17:47.472]                       }
[16:17:47.472]                       {
[16:17:47.472]                         lapply(seq_along(...future.elements_ii), 
[16:17:47.472]                           FUN = function(jj) {
[16:17:47.472]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.472]                             ...future.FUN(...future.X_jj, ...)
[16:17:47.472]                           })
[16:17:47.472]                       }
[16:17:47.472]                     }, args = future.call.arguments)
[16:17:47.472]                   }
[16:17:47.472]                 }, immediateCondition = function(cond) {
[16:17:47.472]                   save_rds <- function (object, pathname, ...) 
[16:17:47.472]                   {
[16:17:47.472]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:47.472]                     if (file_test("-f", pathname_tmp)) {
[16:17:47.472]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.472]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:47.472]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.472]                         fi_tmp[["mtime"]])
[16:17:47.472]                     }
[16:17:47.472]                     tryCatch({
[16:17:47.472]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:47.472]                     }, error = function(ex) {
[16:17:47.472]                       msg <- conditionMessage(ex)
[16:17:47.472]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.472]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:47.472]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.472]                         fi_tmp[["mtime"]], msg)
[16:17:47.472]                       ex$message <- msg
[16:17:47.472]                       stop(ex)
[16:17:47.472]                     })
[16:17:47.472]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:47.472]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:47.472]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:47.472]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.472]                       fi <- file.info(pathname)
[16:17:47.472]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:47.472]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.472]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:47.472]                         fi[["size"]], fi[["mtime"]])
[16:17:47.472]                       stop(msg)
[16:17:47.472]                     }
[16:17:47.472]                     invisible(pathname)
[16:17:47.472]                   }
[16:17:47.472]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:47.472]                     rootPath = tempdir()) 
[16:17:47.472]                   {
[16:17:47.472]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:47.472]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:47.472]                       tmpdir = path, fileext = ".rds")
[16:17:47.472]                     save_rds(obj, file)
[16:17:47.472]                   }
[16:17:47.472]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1cUuyG/.future/immediateConditions")
[16:17:47.472]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.472]                   {
[16:17:47.472]                     inherits <- base::inherits
[16:17:47.472]                     invokeRestart <- base::invokeRestart
[16:17:47.472]                     is.null <- base::is.null
[16:17:47.472]                     muffled <- FALSE
[16:17:47.472]                     if (inherits(cond, "message")) {
[16:17:47.472]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:47.472]                       if (muffled) 
[16:17:47.472]                         invokeRestart("muffleMessage")
[16:17:47.472]                     }
[16:17:47.472]                     else if (inherits(cond, "warning")) {
[16:17:47.472]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:47.472]                       if (muffled) 
[16:17:47.472]                         invokeRestart("muffleWarning")
[16:17:47.472]                     }
[16:17:47.472]                     else if (inherits(cond, "condition")) {
[16:17:47.472]                       if (!is.null(pattern)) {
[16:17:47.472]                         computeRestarts <- base::computeRestarts
[16:17:47.472]                         grepl <- base::grepl
[16:17:47.472]                         restarts <- computeRestarts(cond)
[16:17:47.472]                         for (restart in restarts) {
[16:17:47.472]                           name <- restart$name
[16:17:47.472]                           if (is.null(name)) 
[16:17:47.472]                             next
[16:17:47.472]                           if (!grepl(pattern, name)) 
[16:17:47.472]                             next
[16:17:47.472]                           invokeRestart(restart)
[16:17:47.472]                           muffled <- TRUE
[16:17:47.472]                           break
[16:17:47.472]                         }
[16:17:47.472]                       }
[16:17:47.472]                     }
[16:17:47.472]                     invisible(muffled)
[16:17:47.472]                   }
[16:17:47.472]                   muffleCondition(cond)
[16:17:47.472]                 })
[16:17:47.472]             }))
[16:17:47.472]             future::FutureResult(value = ...future.value$value, 
[16:17:47.472]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.472]                   ...future.rng), globalenv = if (FALSE) 
[16:17:47.472]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:47.472]                     ...future.globalenv.names))
[16:17:47.472]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:47.472]         }, condition = base::local({
[16:17:47.472]             c <- base::c
[16:17:47.472]             inherits <- base::inherits
[16:17:47.472]             invokeRestart <- base::invokeRestart
[16:17:47.472]             length <- base::length
[16:17:47.472]             list <- base::list
[16:17:47.472]             seq.int <- base::seq.int
[16:17:47.472]             signalCondition <- base::signalCondition
[16:17:47.472]             sys.calls <- base::sys.calls
[16:17:47.472]             `[[` <- base::`[[`
[16:17:47.472]             `+` <- base::`+`
[16:17:47.472]             `<<-` <- base::`<<-`
[16:17:47.472]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:47.472]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:47.472]                   3L)]
[16:17:47.472]             }
[16:17:47.472]             function(cond) {
[16:17:47.472]                 is_error <- inherits(cond, "error")
[16:17:47.472]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:47.472]                   NULL)
[16:17:47.472]                 if (is_error) {
[16:17:47.472]                   sessionInformation <- function() {
[16:17:47.472]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:47.472]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:47.472]                       search = base::search(), system = base::Sys.info())
[16:17:47.472]                   }
[16:17:47.472]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.472]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:47.472]                     cond$call), session = sessionInformation(), 
[16:17:47.472]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:47.472]                   signalCondition(cond)
[16:17:47.472]                 }
[16:17:47.472]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:47.472]                 "immediateCondition"))) {
[16:17:47.472]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:47.472]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.472]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:47.472]                   if (TRUE && !signal) {
[16:17:47.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.472]                     {
[16:17:47.472]                       inherits <- base::inherits
[16:17:47.472]                       invokeRestart <- base::invokeRestart
[16:17:47.472]                       is.null <- base::is.null
[16:17:47.472]                       muffled <- FALSE
[16:17:47.472]                       if (inherits(cond, "message")) {
[16:17:47.472]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.472]                         if (muffled) 
[16:17:47.472]                           invokeRestart("muffleMessage")
[16:17:47.472]                       }
[16:17:47.472]                       else if (inherits(cond, "warning")) {
[16:17:47.472]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.472]                         if (muffled) 
[16:17:47.472]                           invokeRestart("muffleWarning")
[16:17:47.472]                       }
[16:17:47.472]                       else if (inherits(cond, "condition")) {
[16:17:47.472]                         if (!is.null(pattern)) {
[16:17:47.472]                           computeRestarts <- base::computeRestarts
[16:17:47.472]                           grepl <- base::grepl
[16:17:47.472]                           restarts <- computeRestarts(cond)
[16:17:47.472]                           for (restart in restarts) {
[16:17:47.472]                             name <- restart$name
[16:17:47.472]                             if (is.null(name)) 
[16:17:47.472]                               next
[16:17:47.472]                             if (!grepl(pattern, name)) 
[16:17:47.472]                               next
[16:17:47.472]                             invokeRestart(restart)
[16:17:47.472]                             muffled <- TRUE
[16:17:47.472]                             break
[16:17:47.472]                           }
[16:17:47.472]                         }
[16:17:47.472]                       }
[16:17:47.472]                       invisible(muffled)
[16:17:47.472]                     }
[16:17:47.472]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.472]                   }
[16:17:47.472]                 }
[16:17:47.472]                 else {
[16:17:47.472]                   if (TRUE) {
[16:17:47.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.472]                     {
[16:17:47.472]                       inherits <- base::inherits
[16:17:47.472]                       invokeRestart <- base::invokeRestart
[16:17:47.472]                       is.null <- base::is.null
[16:17:47.472]                       muffled <- FALSE
[16:17:47.472]                       if (inherits(cond, "message")) {
[16:17:47.472]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.472]                         if (muffled) 
[16:17:47.472]                           invokeRestart("muffleMessage")
[16:17:47.472]                       }
[16:17:47.472]                       else if (inherits(cond, "warning")) {
[16:17:47.472]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.472]                         if (muffled) 
[16:17:47.472]                           invokeRestart("muffleWarning")
[16:17:47.472]                       }
[16:17:47.472]                       else if (inherits(cond, "condition")) {
[16:17:47.472]                         if (!is.null(pattern)) {
[16:17:47.472]                           computeRestarts <- base::computeRestarts
[16:17:47.472]                           grepl <- base::grepl
[16:17:47.472]                           restarts <- computeRestarts(cond)
[16:17:47.472]                           for (restart in restarts) {
[16:17:47.472]                             name <- restart$name
[16:17:47.472]                             if (is.null(name)) 
[16:17:47.472]                               next
[16:17:47.472]                             if (!grepl(pattern, name)) 
[16:17:47.472]                               next
[16:17:47.472]                             invokeRestart(restart)
[16:17:47.472]                             muffled <- TRUE
[16:17:47.472]                             break
[16:17:47.472]                           }
[16:17:47.472]                         }
[16:17:47.472]                       }
[16:17:47.472]                       invisible(muffled)
[16:17:47.472]                     }
[16:17:47.472]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.472]                   }
[16:17:47.472]                 }
[16:17:47.472]             }
[16:17:47.472]         }))
[16:17:47.472]     }, error = function(ex) {
[16:17:47.472]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:47.472]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.472]                 ...future.rng), started = ...future.startTime, 
[16:17:47.472]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:47.472]             version = "1.8"), class = "FutureResult")
[16:17:47.472]     }, finally = {
[16:17:47.472]         if (!identical(...future.workdir, getwd())) 
[16:17:47.472]             setwd(...future.workdir)
[16:17:47.472]         {
[16:17:47.472]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:47.472]                 ...future.oldOptions$nwarnings <- NULL
[16:17:47.472]             }
[16:17:47.472]             base::options(...future.oldOptions)
[16:17:47.472]             if (.Platform$OS.type == "windows") {
[16:17:47.472]                 old_names <- names(...future.oldEnvVars)
[16:17:47.472]                 envs <- base::Sys.getenv()
[16:17:47.472]                 names <- names(envs)
[16:17:47.472]                 common <- intersect(names, old_names)
[16:17:47.472]                 added <- setdiff(names, old_names)
[16:17:47.472]                 removed <- setdiff(old_names, names)
[16:17:47.472]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:47.472]                   envs[common]]
[16:17:47.472]                 NAMES <- toupper(changed)
[16:17:47.472]                 args <- list()
[16:17:47.472]                 for (kk in seq_along(NAMES)) {
[16:17:47.472]                   name <- changed[[kk]]
[16:17:47.472]                   NAME <- NAMES[[kk]]
[16:17:47.472]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.472]                     next
[16:17:47.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.472]                 }
[16:17:47.472]                 NAMES <- toupper(added)
[16:17:47.472]                 for (kk in seq_along(NAMES)) {
[16:17:47.472]                   name <- added[[kk]]
[16:17:47.472]                   NAME <- NAMES[[kk]]
[16:17:47.472]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.472]                     next
[16:17:47.472]                   args[[name]] <- ""
[16:17:47.472]                 }
[16:17:47.472]                 NAMES <- toupper(removed)
[16:17:47.472]                 for (kk in seq_along(NAMES)) {
[16:17:47.472]                   name <- removed[[kk]]
[16:17:47.472]                   NAME <- NAMES[[kk]]
[16:17:47.472]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.472]                     next
[16:17:47.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.472]                 }
[16:17:47.472]                 if (length(args) > 0) 
[16:17:47.472]                   base::do.call(base::Sys.setenv, args = args)
[16:17:47.472]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:47.472]             }
[16:17:47.472]             else {
[16:17:47.472]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:47.472]             }
[16:17:47.472]             {
[16:17:47.472]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:47.472]                   0L) {
[16:17:47.472]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:47.472]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:47.472]                   base::options(opts)
[16:17:47.472]                 }
[16:17:47.472]                 {
[16:17:47.472]                   {
[16:17:47.472]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:47.472]                     NULL
[16:17:47.472]                   }
[16:17:47.472]                   options(future.plan = NULL)
[16:17:47.472]                   if (is.na(NA_character_)) 
[16:17:47.472]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.472]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:47.472]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:47.472]                     .init = FALSE)
[16:17:47.472]                 }
[16:17:47.472]             }
[16:17:47.472]         }
[16:17:47.472]     })
[16:17:47.472]     if (TRUE) {
[16:17:47.472]         base::sink(type = "output", split = FALSE)
[16:17:47.472]         if (TRUE) {
[16:17:47.472]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:47.472]         }
[16:17:47.472]         else {
[16:17:47.472]             ...future.result["stdout"] <- base::list(NULL)
[16:17:47.472]         }
[16:17:47.472]         base::close(...future.stdout)
[16:17:47.472]         ...future.stdout <- NULL
[16:17:47.472]     }
[16:17:47.472]     ...future.result$conditions <- ...future.conditions
[16:17:47.472]     ...future.result$finished <- base::Sys.time()
[16:17:47.472]     ...future.result
[16:17:47.472] }
[16:17:47.475] assign_globals() ...
[16:17:47.475] List of 5
[16:17:47.475]  $ ...future.FUN            :function (object, ...)  
[16:17:47.475]  $ future.call.arguments    :List of 1
[16:17:47.475]   ..$ digits: int 2
[16:17:47.475]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.475]  $ ...future.elements_ii    :List of 3
[16:17:47.475]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[16:17:47.475]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[16:17:47.475]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[16:17:47.475]  $ ...future.seeds_ii       : NULL
[16:17:47.475]  $ ...future.globals.maxSize: NULL
[16:17:47.475]  - attr(*, "where")=List of 5
[16:17:47.475]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:47.475]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:47.475]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:47.475]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:47.475]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:47.475]  - attr(*, "resolved")= logi FALSE
[16:17:47.475]  - attr(*, "total_size")= num 1296
[16:17:47.475]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.475]  - attr(*, "already-done")= logi TRUE
[16:17:47.484] - copied ‘...future.FUN’ to environment
[16:17:47.485] - copied ‘future.call.arguments’ to environment
[16:17:47.485] - copied ‘...future.elements_ii’ to environment
[16:17:47.485] - copied ‘...future.seeds_ii’ to environment
[16:17:47.485] - copied ‘...future.globals.maxSize’ to environment
[16:17:47.485] assign_globals() ... done
[16:17:47.485] requestCore(): workers = 2
[16:17:47.488] MulticoreFuture started
[16:17:47.488] - Launch lazy future ... done
[16:17:47.489] run() for ‘MulticoreFuture’ ... done
[16:17:47.489] plan(): Setting new future strategy stack:
[16:17:47.490] Created future:
[16:17:47.489] List of future strategies:
[16:17:47.489] 1. sequential:
[16:17:47.489]    - args: function (..., envir = parent.frame())
[16:17:47.489]    - tweaked: FALSE
[16:17:47.489]    - call: NULL
[16:17:47.491] plan(): nbrOfWorkers() = 1
[16:17:47.495] plan(): Setting new future strategy stack:
[16:17:47.495] List of future strategies:
[16:17:47.495] 1. multicore:
[16:17:47.495]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:47.495]    - tweaked: FALSE
[16:17:47.495]    - call: plan(strategy)
[16:17:47.502] plan(): nbrOfWorkers() = 2
[16:17:47.490] MulticoreFuture:
[16:17:47.490] Label: ‘future_by-2’
[16:17:47.490] Expression:
[16:17:47.490] {
[16:17:47.490]     do.call(function(...) {
[16:17:47.490]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.490]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.490]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.490]             on.exit(options(oopts), add = TRUE)
[16:17:47.490]         }
[16:17:47.490]         {
[16:17:47.490]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.490]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.490]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.490]             })
[16:17:47.490]         }
[16:17:47.490]     }, args = future.call.arguments)
[16:17:47.490] }
[16:17:47.490] Lazy evaluation: FALSE
[16:17:47.490] Asynchronous evaluation: TRUE
[16:17:47.490] Local evaluation: TRUE
[16:17:47.490] Environment: R_GlobalEnv
[16:17:47.490] Capture standard output: TRUE
[16:17:47.490] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:47.490] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:47.490] Packages: <none>
[16:17:47.490] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:47.490] Resolved: TRUE
[16:17:47.490] Value: <not collected>
[16:17:47.490] Conditions captured: <none>
[16:17:47.490] Early signaling: FALSE
[16:17:47.490] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:47.490] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:47.503] Chunk #2 of 2 ... DONE
[16:17:47.503] Launching 2 futures (chunks) ... DONE
[16:17:47.503] Resolving 2 futures (chunks) ...
[16:17:47.503] resolve() on list ...
[16:17:47.504]  recursive: 0
[16:17:47.504]  length: 2
[16:17:47.504] 
[16:17:47.505] Future #1
[16:17:47.505] result() for MulticoreFuture ...
[16:17:47.506] result() for MulticoreFuture ...
[16:17:47.506] result() for MulticoreFuture ... done
[16:17:47.506] result() for MulticoreFuture ... done
[16:17:47.506] result() for MulticoreFuture ...
[16:17:47.507] result() for MulticoreFuture ... done
[16:17:47.507] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:17:47.507] - nx: 2
[16:17:47.507] - relay: TRUE
[16:17:47.507] - stdout: TRUE
[16:17:47.508] - signal: TRUE
[16:17:47.508] - resignal: FALSE
[16:17:47.508] - force: TRUE
[16:17:47.508] - relayed: [n=2] FALSE, FALSE
[16:17:47.508] - queued futures: [n=2] FALSE, FALSE
[16:17:47.509]  - until=1
[16:17:47.509]  - relaying element #1
[16:17:47.509] result() for MulticoreFuture ...
[16:17:47.510] result() for MulticoreFuture ... done
[16:17:47.510] result() for MulticoreFuture ...
[16:17:47.510] result() for MulticoreFuture ... done
[16:17:47.510] result() for MulticoreFuture ...
[16:17:47.510] result() for MulticoreFuture ... done
[16:17:47.510] result() for MulticoreFuture ...
[16:17:47.510] result() for MulticoreFuture ... done
[16:17:47.511] - relayed: [n=2] TRUE, FALSE
[16:17:47.511] - queued futures: [n=2] TRUE, FALSE
[16:17:47.511] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:17:47.511]  length: 1 (resolved future 1)
[16:17:47.511] Future #2
[16:17:47.512] result() for MulticoreFuture ...
[16:17:47.512] result() for MulticoreFuture ...
[16:17:47.512] result() for MulticoreFuture ... done
[16:17:47.513] result() for MulticoreFuture ... done
[16:17:47.513] result() for MulticoreFuture ...
[16:17:47.513] result() for MulticoreFuture ... done
[16:17:47.513] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:17:47.513] - nx: 2
[16:17:47.513] - relay: TRUE
[16:17:47.513] - stdout: TRUE
[16:17:47.513] - signal: TRUE
[16:17:47.514] - resignal: FALSE
[16:17:47.514] - force: TRUE
[16:17:47.514] - relayed: [n=2] TRUE, FALSE
[16:17:47.514] - queued futures: [n=2] TRUE, FALSE
[16:17:47.514]  - until=2
[16:17:47.514]  - relaying element #2
[16:17:47.514] result() for MulticoreFuture ...
[16:17:47.514] result() for MulticoreFuture ... done
[16:17:47.515] result() for MulticoreFuture ...
[16:17:47.515] result() for MulticoreFuture ... done
[16:17:47.515] result() for MulticoreFuture ...
[16:17:47.515] result() for MulticoreFuture ... done
[16:17:47.515] result() for MulticoreFuture ...
[16:17:47.515] result() for MulticoreFuture ... done
[16:17:47.515] - relayed: [n=2] TRUE, TRUE
[16:17:47.515] - queued futures: [n=2] TRUE, TRUE
[16:17:47.515] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:17:47.516]  length: 0 (resolved future 2)
[16:17:47.516] Relaying remaining futures
[16:17:47.516] signalConditionsASAP(NULL, pos=0) ...
[16:17:47.516] - nx: 2
[16:17:47.516] - relay: TRUE
[16:17:47.516] - stdout: TRUE
[16:17:47.516] - signal: TRUE
[16:17:47.516] - resignal: FALSE
[16:17:47.516] - force: TRUE
[16:17:47.516] - relayed: [n=2] TRUE, TRUE
[16:17:47.517] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:47.517] - relayed: [n=2] TRUE, TRUE
[16:17:47.517] - queued futures: [n=2] TRUE, TRUE
[16:17:47.517] signalConditionsASAP(NULL, pos=0) ... done
[16:17:47.517] resolve() on list ... DONE
[16:17:47.517] result() for MulticoreFuture ...
[16:17:47.517] result() for MulticoreFuture ... done
[16:17:47.517] result() for MulticoreFuture ...
[16:17:47.518] result() for MulticoreFuture ... done
[16:17:47.518] result() for MulticoreFuture ...
[16:17:47.518] result() for MulticoreFuture ... done
[16:17:47.518] result() for MulticoreFuture ...
[16:17:47.518] result() for MulticoreFuture ... done
[16:17:47.518]  - Number of value chunks collected: 2
[16:17:47.518] Resolving 2 futures (chunks) ... DONE
[16:17:47.518] Reducing values from 2 chunks ...
[16:17:47.518]  - Number of values collected after concatenation: 6
[16:17:47.518]  - Number of values expected: 6
[16:17:47.519] Reducing values from 2 chunks ... DONE
[16:17:47.519] future_lapply() ... DONE
[16:17:47.519] future_by_internal() ... DONE
[16:17:47.520] future_by_internal() ...
[16:17:47.521] future_lapply() ...
[16:17:47.526] Number of chunks: 2
[16:17:47.526] getGlobalsAndPackagesXApply() ...
[16:17:47.526]  - future.globals: TRUE
[16:17:47.526] getGlobalsAndPackages() ...
[16:17:47.526] Searching for globals...
[16:17:47.531] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:17:47.531] Searching for globals ... DONE
[16:17:47.531] Resolving globals: FALSE
[16:17:47.532] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[16:17:47.532] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[16:17:47.532] - globals: [1] ‘FUN’
[16:17:47.532] - packages: [1] ‘stats’
[16:17:47.533] getGlobalsAndPackages() ... DONE
[16:17:47.533]  - globals found/used: [n=1] ‘FUN’
[16:17:47.533]  - needed namespaces: [n=1] ‘stats’
[16:17:47.533] Finding globals ... DONE
[16:17:47.533]  - use_args: TRUE
[16:17:47.533]  - Getting '...' globals ...
[16:17:47.534] resolve() on list ...
[16:17:47.534]  recursive: 0
[16:17:47.534]  length: 1
[16:17:47.534]  elements: ‘...’
[16:17:47.534]  length: 0 (resolved future 1)
[16:17:47.534] resolve() on list ... DONE
[16:17:47.534]    - '...' content: [n=1] ‘singular.ok’
[16:17:47.534] List of 1
[16:17:47.534]  $ ...:List of 1
[16:17:47.534]   ..$ singular.ok: logi FALSE
[16:17:47.534]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.534]  - attr(*, "where")=List of 1
[16:17:47.534]   ..$ ...:<environment: 0x55b567d99680> 
[16:17:47.534]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.534]  - attr(*, "resolved")= logi TRUE
[16:17:47.534]  - attr(*, "total_size")= num NA
[16:17:47.538]  - Getting '...' globals ... DONE
[16:17:47.538] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:47.538] List of 2
[16:17:47.538]  $ ...future.FUN:function (x, ...)  
[16:17:47.538]  $ ...          :List of 1
[16:17:47.538]   ..$ singular.ok: logi FALSE
[16:17:47.538]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.538]  - attr(*, "where")=List of 2
[16:17:47.538]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:47.538]   ..$ ...          :<environment: 0x55b567d99680> 
[16:17:47.538]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.538]  - attr(*, "resolved")= logi FALSE
[16:17:47.538]  - attr(*, "total_size")= num 5384
[16:17:47.541] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:47.541] getGlobalsAndPackagesXApply() ... DONE
[16:17:47.541] Number of futures (= number of chunks): 2
[16:17:47.541] Launching 2 futures (chunks) ...
[16:17:47.542] Chunk #1 of 2 ...
[16:17:47.542]  - Finding globals in 'X' for chunk #1 ...
[16:17:47.542] getGlobalsAndPackages() ...
[16:17:47.542] Searching for globals...
[16:17:47.542] 
[16:17:47.542] Searching for globals ... DONE
[16:17:47.542] - globals: [0] <none>
[16:17:47.543] getGlobalsAndPackages() ... DONE
[16:17:47.543]    + additional globals found: [n=0] 
[16:17:47.543]    + additional namespaces needed: [n=0] 
[16:17:47.543]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:47.543]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:47.543]  - seeds: <none>
[16:17:47.543]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.543] getGlobalsAndPackages() ...
[16:17:47.543] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.543] Resolving globals: FALSE
[16:17:47.544] Tweak future expression to call with '...' arguments ...
[16:17:47.544] {
[16:17:47.544]     do.call(function(...) {
[16:17:47.544]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.544]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.544]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.544]             on.exit(options(oopts), add = TRUE)
[16:17:47.544]         }
[16:17:47.544]         {
[16:17:47.544]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.544]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.544]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.544]             })
[16:17:47.544]         }
[16:17:47.544]     }, args = future.call.arguments)
[16:17:47.544] }
[16:17:47.544] Tweak future expression to call with '...' arguments ... DONE
[16:17:47.544] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.544] 
[16:17:47.545] getGlobalsAndPackages() ... DONE
[16:17:47.545] run() for ‘Future’ ...
[16:17:47.545] - state: ‘created’
[16:17:47.545] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:47.549] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:47.549] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:47.549]   - Field: ‘label’
[16:17:47.549]   - Field: ‘local’
[16:17:47.549]   - Field: ‘owner’
[16:17:47.549]   - Field: ‘envir’
[16:17:47.549]   - Field: ‘workers’
[16:17:47.549]   - Field: ‘packages’
[16:17:47.550]   - Field: ‘gc’
[16:17:47.550]   - Field: ‘job’
[16:17:47.550]   - Field: ‘conditions’
[16:17:47.550]   - Field: ‘expr’
[16:17:47.550]   - Field: ‘uuid’
[16:17:47.550]   - Field: ‘seed’
[16:17:47.550]   - Field: ‘version’
[16:17:47.550]   - Field: ‘result’
[16:17:47.550]   - Field: ‘asynchronous’
[16:17:47.550]   - Field: ‘calls’
[16:17:47.551]   - Field: ‘globals’
[16:17:47.551]   - Field: ‘stdout’
[16:17:47.551]   - Field: ‘earlySignal’
[16:17:47.551]   - Field: ‘lazy’
[16:17:47.553]   - Field: ‘state’
[16:17:47.553] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:47.553] - Launch lazy future ...
[16:17:47.553] Packages needed by the future expression (n = 1): ‘stats’
[16:17:47.553] Packages needed by future strategies (n = 0): <none>
[16:17:47.554] {
[16:17:47.554]     {
[16:17:47.554]         {
[16:17:47.554]             ...future.startTime <- base::Sys.time()
[16:17:47.554]             {
[16:17:47.554]                 {
[16:17:47.554]                   {
[16:17:47.554]                     {
[16:17:47.554]                       {
[16:17:47.554]                         base::local({
[16:17:47.554]                           has_future <- base::requireNamespace("future", 
[16:17:47.554]                             quietly = TRUE)
[16:17:47.554]                           if (has_future) {
[16:17:47.554]                             ns <- base::getNamespace("future")
[16:17:47.554]                             version <- ns[[".package"]][["version"]]
[16:17:47.554]                             if (is.null(version)) 
[16:17:47.554]                               version <- utils::packageVersion("future")
[16:17:47.554]                           }
[16:17:47.554]                           else {
[16:17:47.554]                             version <- NULL
[16:17:47.554]                           }
[16:17:47.554]                           if (!has_future || version < "1.8.0") {
[16:17:47.554]                             info <- base::c(r_version = base::gsub("R version ", 
[16:17:47.554]                               "", base::R.version$version.string), 
[16:17:47.554]                               platform = base::sprintf("%s (%s-bit)", 
[16:17:47.554]                                 base::R.version$platform, 8 * 
[16:17:47.554]                                   base::.Machine$sizeof.pointer), 
[16:17:47.554]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:47.554]                                 "release", "version")], collapse = " "), 
[16:17:47.554]                               hostname = base::Sys.info()[["nodename"]])
[16:17:47.554]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:17:47.554]                               info)
[16:17:47.554]                             info <- base::paste(info, collapse = "; ")
[16:17:47.554]                             if (!has_future) {
[16:17:47.554]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:47.554]                                 info)
[16:17:47.554]                             }
[16:17:47.554]                             else {
[16:17:47.554]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:47.554]                                 info, version)
[16:17:47.554]                             }
[16:17:47.554]                             base::stop(msg)
[16:17:47.554]                           }
[16:17:47.554]                         })
[16:17:47.554]                       }
[16:17:47.554]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:47.554]                       base::options(mc.cores = 1L)
[16:17:47.554]                     }
[16:17:47.554]                     base::local({
[16:17:47.554]                       for (pkg in "stats") {
[16:17:47.554]                         base::loadNamespace(pkg)
[16:17:47.554]                         base::library(pkg, character.only = TRUE)
[16:17:47.554]                       }
[16:17:47.554]                     })
[16:17:47.554]                   }
[16:17:47.554]                   ...future.strategy.old <- future::plan("list")
[16:17:47.554]                   options(future.plan = NULL)
[16:17:47.554]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.554]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:47.554]                 }
[16:17:47.554]                 ...future.workdir <- getwd()
[16:17:47.554]             }
[16:17:47.554]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:47.554]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:47.554]         }
[16:17:47.554]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:47.554]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:47.554]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:47.554]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:47.554]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:47.554]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:47.554]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:47.554]             base::names(...future.oldOptions))
[16:17:47.554]     }
[16:17:47.554]     if (FALSE) {
[16:17:47.554]     }
[16:17:47.554]     else {
[16:17:47.554]         if (TRUE) {
[16:17:47.554]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:47.554]                 open = "w")
[16:17:47.554]         }
[16:17:47.554]         else {
[16:17:47.554]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:47.554]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:47.554]         }
[16:17:47.554]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:47.554]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:47.554]             base::sink(type = "output", split = FALSE)
[16:17:47.554]             base::close(...future.stdout)
[16:17:47.554]         }, add = TRUE)
[16:17:47.554]     }
[16:17:47.554]     ...future.frame <- base::sys.nframe()
[16:17:47.554]     ...future.conditions <- base::list()
[16:17:47.554]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:47.554]     if (FALSE) {
[16:17:47.554]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:47.554]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:47.554]     }
[16:17:47.554]     ...future.result <- base::tryCatch({
[16:17:47.554]         base::withCallingHandlers({
[16:17:47.554]             ...future.value <- base::withVisible(base::local({
[16:17:47.554]                 withCallingHandlers({
[16:17:47.554]                   {
[16:17:47.554]                     do.call(function(...) {
[16:17:47.554]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.554]                       if (!identical(...future.globals.maxSize.org, 
[16:17:47.554]                         ...future.globals.maxSize)) {
[16:17:47.554]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.554]                         on.exit(options(oopts), add = TRUE)
[16:17:47.554]                       }
[16:17:47.554]                       {
[16:17:47.554]                         lapply(seq_along(...future.elements_ii), 
[16:17:47.554]                           FUN = function(jj) {
[16:17:47.554]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.554]                             ...future.FUN(...future.X_jj, ...)
[16:17:47.554]                           })
[16:17:47.554]                       }
[16:17:47.554]                     }, args = future.call.arguments)
[16:17:47.554]                   }
[16:17:47.554]                 }, immediateCondition = function(cond) {
[16:17:47.554]                   save_rds <- function (object, pathname, ...) 
[16:17:47.554]                   {
[16:17:47.554]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:47.554]                     if (file_test("-f", pathname_tmp)) {
[16:17:47.554]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.554]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:47.554]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.554]                         fi_tmp[["mtime"]])
[16:17:47.554]                     }
[16:17:47.554]                     tryCatch({
[16:17:47.554]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:47.554]                     }, error = function(ex) {
[16:17:47.554]                       msg <- conditionMessage(ex)
[16:17:47.554]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.554]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:47.554]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.554]                         fi_tmp[["mtime"]], msg)
[16:17:47.554]                       ex$message <- msg
[16:17:47.554]                       stop(ex)
[16:17:47.554]                     })
[16:17:47.554]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:47.554]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:47.554]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:47.554]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.554]                       fi <- file.info(pathname)
[16:17:47.554]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:47.554]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.554]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:47.554]                         fi[["size"]], fi[["mtime"]])
[16:17:47.554]                       stop(msg)
[16:17:47.554]                     }
[16:17:47.554]                     invisible(pathname)
[16:17:47.554]                   }
[16:17:47.554]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:47.554]                     rootPath = tempdir()) 
[16:17:47.554]                   {
[16:17:47.554]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:47.554]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:47.554]                       tmpdir = path, fileext = ".rds")
[16:17:47.554]                     save_rds(obj, file)
[16:17:47.554]                   }
[16:17:47.554]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1cUuyG/.future/immediateConditions")
[16:17:47.554]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.554]                   {
[16:17:47.554]                     inherits <- base::inherits
[16:17:47.554]                     invokeRestart <- base::invokeRestart
[16:17:47.554]                     is.null <- base::is.null
[16:17:47.554]                     muffled <- FALSE
[16:17:47.554]                     if (inherits(cond, "message")) {
[16:17:47.554]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:47.554]                       if (muffled) 
[16:17:47.554]                         invokeRestart("muffleMessage")
[16:17:47.554]                     }
[16:17:47.554]                     else if (inherits(cond, "warning")) {
[16:17:47.554]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:47.554]                       if (muffled) 
[16:17:47.554]                         invokeRestart("muffleWarning")
[16:17:47.554]                     }
[16:17:47.554]                     else if (inherits(cond, "condition")) {
[16:17:47.554]                       if (!is.null(pattern)) {
[16:17:47.554]                         computeRestarts <- base::computeRestarts
[16:17:47.554]                         grepl <- base::grepl
[16:17:47.554]                         restarts <- computeRestarts(cond)
[16:17:47.554]                         for (restart in restarts) {
[16:17:47.554]                           name <- restart$name
[16:17:47.554]                           if (is.null(name)) 
[16:17:47.554]                             next
[16:17:47.554]                           if (!grepl(pattern, name)) 
[16:17:47.554]                             next
[16:17:47.554]                           invokeRestart(restart)
[16:17:47.554]                           muffled <- TRUE
[16:17:47.554]                           break
[16:17:47.554]                         }
[16:17:47.554]                       }
[16:17:47.554]                     }
[16:17:47.554]                     invisible(muffled)
[16:17:47.554]                   }
[16:17:47.554]                   muffleCondition(cond)
[16:17:47.554]                 })
[16:17:47.554]             }))
[16:17:47.554]             future::FutureResult(value = ...future.value$value, 
[16:17:47.554]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.554]                   ...future.rng), globalenv = if (FALSE) 
[16:17:47.554]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:47.554]                     ...future.globalenv.names))
[16:17:47.554]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:47.554]         }, condition = base::local({
[16:17:47.554]             c <- base::c
[16:17:47.554]             inherits <- base::inherits
[16:17:47.554]             invokeRestart <- base::invokeRestart
[16:17:47.554]             length <- base::length
[16:17:47.554]             list <- base::list
[16:17:47.554]             seq.int <- base::seq.int
[16:17:47.554]             signalCondition <- base::signalCondition
[16:17:47.554]             sys.calls <- base::sys.calls
[16:17:47.554]             `[[` <- base::`[[`
[16:17:47.554]             `+` <- base::`+`
[16:17:47.554]             `<<-` <- base::`<<-`
[16:17:47.554]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:47.554]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:47.554]                   3L)]
[16:17:47.554]             }
[16:17:47.554]             function(cond) {
[16:17:47.554]                 is_error <- inherits(cond, "error")
[16:17:47.554]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:47.554]                   NULL)
[16:17:47.554]                 if (is_error) {
[16:17:47.554]                   sessionInformation <- function() {
[16:17:47.554]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:47.554]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:47.554]                       search = base::search(), system = base::Sys.info())
[16:17:47.554]                   }
[16:17:47.554]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.554]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:47.554]                     cond$call), session = sessionInformation(), 
[16:17:47.554]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:47.554]                   signalCondition(cond)
[16:17:47.554]                 }
[16:17:47.554]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:47.554]                 "immediateCondition"))) {
[16:17:47.554]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:47.554]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.554]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:47.554]                   if (TRUE && !signal) {
[16:17:47.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.554]                     {
[16:17:47.554]                       inherits <- base::inherits
[16:17:47.554]                       invokeRestart <- base::invokeRestart
[16:17:47.554]                       is.null <- base::is.null
[16:17:47.554]                       muffled <- FALSE
[16:17:47.554]                       if (inherits(cond, "message")) {
[16:17:47.554]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.554]                         if (muffled) 
[16:17:47.554]                           invokeRestart("muffleMessage")
[16:17:47.554]                       }
[16:17:47.554]                       else if (inherits(cond, "warning")) {
[16:17:47.554]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.554]                         if (muffled) 
[16:17:47.554]                           invokeRestart("muffleWarning")
[16:17:47.554]                       }
[16:17:47.554]                       else if (inherits(cond, "condition")) {
[16:17:47.554]                         if (!is.null(pattern)) {
[16:17:47.554]                           computeRestarts <- base::computeRestarts
[16:17:47.554]                           grepl <- base::grepl
[16:17:47.554]                           restarts <- computeRestarts(cond)
[16:17:47.554]                           for (restart in restarts) {
[16:17:47.554]                             name <- restart$name
[16:17:47.554]                             if (is.null(name)) 
[16:17:47.554]                               next
[16:17:47.554]                             if (!grepl(pattern, name)) 
[16:17:47.554]                               next
[16:17:47.554]                             invokeRestart(restart)
[16:17:47.554]                             muffled <- TRUE
[16:17:47.554]                             break
[16:17:47.554]                           }
[16:17:47.554]                         }
[16:17:47.554]                       }
[16:17:47.554]                       invisible(muffled)
[16:17:47.554]                     }
[16:17:47.554]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.554]                   }
[16:17:47.554]                 }
[16:17:47.554]                 else {
[16:17:47.554]                   if (TRUE) {
[16:17:47.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.554]                     {
[16:17:47.554]                       inherits <- base::inherits
[16:17:47.554]                       invokeRestart <- base::invokeRestart
[16:17:47.554]                       is.null <- base::is.null
[16:17:47.554]                       muffled <- FALSE
[16:17:47.554]                       if (inherits(cond, "message")) {
[16:17:47.554]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.554]                         if (muffled) 
[16:17:47.554]                           invokeRestart("muffleMessage")
[16:17:47.554]                       }
[16:17:47.554]                       else if (inherits(cond, "warning")) {
[16:17:47.554]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.554]                         if (muffled) 
[16:17:47.554]                           invokeRestart("muffleWarning")
[16:17:47.554]                       }
[16:17:47.554]                       else if (inherits(cond, "condition")) {
[16:17:47.554]                         if (!is.null(pattern)) {
[16:17:47.554]                           computeRestarts <- base::computeRestarts
[16:17:47.554]                           grepl <- base::grepl
[16:17:47.554]                           restarts <- computeRestarts(cond)
[16:17:47.554]                           for (restart in restarts) {
[16:17:47.554]                             name <- restart$name
[16:17:47.554]                             if (is.null(name)) 
[16:17:47.554]                               next
[16:17:47.554]                             if (!grepl(pattern, name)) 
[16:17:47.554]                               next
[16:17:47.554]                             invokeRestart(restart)
[16:17:47.554]                             muffled <- TRUE
[16:17:47.554]                             break
[16:17:47.554]                           }
[16:17:47.554]                         }
[16:17:47.554]                       }
[16:17:47.554]                       invisible(muffled)
[16:17:47.554]                     }
[16:17:47.554]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.554]                   }
[16:17:47.554]                 }
[16:17:47.554]             }
[16:17:47.554]         }))
[16:17:47.554]     }, error = function(ex) {
[16:17:47.554]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:47.554]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.554]                 ...future.rng), started = ...future.startTime, 
[16:17:47.554]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:47.554]             version = "1.8"), class = "FutureResult")
[16:17:47.554]     }, finally = {
[16:17:47.554]         if (!identical(...future.workdir, getwd())) 
[16:17:47.554]             setwd(...future.workdir)
[16:17:47.554]         {
[16:17:47.554]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:47.554]                 ...future.oldOptions$nwarnings <- NULL
[16:17:47.554]             }
[16:17:47.554]             base::options(...future.oldOptions)
[16:17:47.554]             if (.Platform$OS.type == "windows") {
[16:17:47.554]                 old_names <- names(...future.oldEnvVars)
[16:17:47.554]                 envs <- base::Sys.getenv()
[16:17:47.554]                 names <- names(envs)
[16:17:47.554]                 common <- intersect(names, old_names)
[16:17:47.554]                 added <- setdiff(names, old_names)
[16:17:47.554]                 removed <- setdiff(old_names, names)
[16:17:47.554]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:47.554]                   envs[common]]
[16:17:47.554]                 NAMES <- toupper(changed)
[16:17:47.554]                 args <- list()
[16:17:47.554]                 for (kk in seq_along(NAMES)) {
[16:17:47.554]                   name <- changed[[kk]]
[16:17:47.554]                   NAME <- NAMES[[kk]]
[16:17:47.554]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.554]                     next
[16:17:47.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.554]                 }
[16:17:47.554]                 NAMES <- toupper(added)
[16:17:47.554]                 for (kk in seq_along(NAMES)) {
[16:17:47.554]                   name <- added[[kk]]
[16:17:47.554]                   NAME <- NAMES[[kk]]
[16:17:47.554]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.554]                     next
[16:17:47.554]                   args[[name]] <- ""
[16:17:47.554]                 }
[16:17:47.554]                 NAMES <- toupper(removed)
[16:17:47.554]                 for (kk in seq_along(NAMES)) {
[16:17:47.554]                   name <- removed[[kk]]
[16:17:47.554]                   NAME <- NAMES[[kk]]
[16:17:47.554]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.554]                     next
[16:17:47.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.554]                 }
[16:17:47.554]                 if (length(args) > 0) 
[16:17:47.554]                   base::do.call(base::Sys.setenv, args = args)
[16:17:47.554]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:47.554]             }
[16:17:47.554]             else {
[16:17:47.554]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:47.554]             }
[16:17:47.554]             {
[16:17:47.554]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:47.554]                   0L) {
[16:17:47.554]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:47.554]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:47.554]                   base::options(opts)
[16:17:47.554]                 }
[16:17:47.554]                 {
[16:17:47.554]                   {
[16:17:47.554]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:47.554]                     NULL
[16:17:47.554]                   }
[16:17:47.554]                   options(future.plan = NULL)
[16:17:47.554]                   if (is.na(NA_character_)) 
[16:17:47.554]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.554]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:47.554]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:47.554]                     .init = FALSE)
[16:17:47.554]                 }
[16:17:47.554]             }
[16:17:47.554]         }
[16:17:47.554]     })
[16:17:47.554]     if (TRUE) {
[16:17:47.554]         base::sink(type = "output", split = FALSE)
[16:17:47.554]         if (TRUE) {
[16:17:47.554]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:47.554]         }
[16:17:47.554]         else {
[16:17:47.554]             ...future.result["stdout"] <- base::list(NULL)
[16:17:47.554]         }
[16:17:47.554]         base::close(...future.stdout)
[16:17:47.554]         ...future.stdout <- NULL
[16:17:47.554]     }
[16:17:47.554]     ...future.result$conditions <- ...future.conditions
[16:17:47.554]     ...future.result$finished <- base::Sys.time()
[16:17:47.554]     ...future.result
[16:17:47.554] }
[16:17:47.556] assign_globals() ...
[16:17:47.557] List of 5
[16:17:47.557]  $ ...future.FUN            :function (x, ...)  
[16:17:47.557]  $ future.call.arguments    :List of 1
[16:17:47.557]   ..$ singular.ok: logi FALSE
[16:17:47.557]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.557]  $ ...future.elements_ii    :List of 1
[16:17:47.557]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:47.557]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:17:47.557]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.557]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:47.557]  $ ...future.seeds_ii       : NULL
[16:17:47.557]  $ ...future.globals.maxSize: NULL
[16:17:47.557]  - attr(*, "where")=List of 5
[16:17:47.557]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:47.557]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:47.557]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:47.557]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:47.557]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:47.557]  - attr(*, "resolved")= logi FALSE
[16:17:47.557]  - attr(*, "total_size")= num 5384
[16:17:47.557]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.557]  - attr(*, "already-done")= logi TRUE
[16:17:47.563] - reassign environment for ‘...future.FUN’
[16:17:47.563] - copied ‘...future.FUN’ to environment
[16:17:47.563] - copied ‘future.call.arguments’ to environment
[16:17:47.563] - copied ‘...future.elements_ii’ to environment
[16:17:47.563] - copied ‘...future.seeds_ii’ to environment
[16:17:47.564] - copied ‘...future.globals.maxSize’ to environment
[16:17:47.564] assign_globals() ... done
[16:17:47.564] requestCore(): workers = 2
[16:17:47.566] MulticoreFuture started
[16:17:47.566] - Launch lazy future ... done
[16:17:47.566] run() for ‘MulticoreFuture’ ... done
[16:17:47.567] Created future:
[16:17:47.567] plan(): Setting new future strategy stack:
[16:17:47.568] List of future strategies:
[16:17:47.568] 1. sequential:
[16:17:47.568]    - args: function (..., envir = parent.frame())
[16:17:47.568]    - tweaked: FALSE
[16:17:47.568]    - call: NULL
[16:17:47.568] plan(): nbrOfWorkers() = 1
[16:17:47.572] plan(): Setting new future strategy stack:
[16:17:47.573] List of future strategies:
[16:17:47.573] 1. multicore:
[16:17:47.573]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:47.573]    - tweaked: FALSE
[16:17:47.573]    - call: plan(strategy)
[16:17:47.578] plan(): nbrOfWorkers() = 2
[16:17:47.567] MulticoreFuture:
[16:17:47.567] Label: ‘future_by-1’
[16:17:47.567] Expression:
[16:17:47.567] {
[16:17:47.567]     do.call(function(...) {
[16:17:47.567]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.567]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.567]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.567]             on.exit(options(oopts), add = TRUE)
[16:17:47.567]         }
[16:17:47.567]         {
[16:17:47.567]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.567]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.567]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.567]             })
[16:17:47.567]         }
[16:17:47.567]     }, args = future.call.arguments)
[16:17:47.567] }
[16:17:47.567] Lazy evaluation: FALSE
[16:17:47.567] Asynchronous evaluation: TRUE
[16:17:47.567] Local evaluation: TRUE
[16:17:47.567] Environment: R_GlobalEnv
[16:17:47.567] Capture standard output: TRUE
[16:17:47.567] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:47.567] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:47.567] Packages: 1 packages (‘stats’)
[16:17:47.567] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:47.567] Resolved: TRUE
[16:17:47.567] Value: <not collected>
[16:17:47.567] Conditions captured: <none>
[16:17:47.567] Early signaling: FALSE
[16:17:47.567] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:47.567] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:47.580] Chunk #1 of 2 ... DONE
[16:17:47.580] Chunk #2 of 2 ...
[16:17:47.580]  - Finding globals in 'X' for chunk #2 ...
[16:17:47.580] getGlobalsAndPackages() ...
[16:17:47.581] Searching for globals...
[16:17:47.581] 
[16:17:47.582] Searching for globals ... DONE
[16:17:47.582] - globals: [0] <none>
[16:17:47.582] getGlobalsAndPackages() ... DONE
[16:17:47.582]    + additional globals found: [n=0] 
[16:17:47.582]    + additional namespaces needed: [n=0] 
[16:17:47.582]  - Finding globals in 'X' for chunk #2 ... DONE
[16:17:47.582]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:47.582]  - seeds: <none>
[16:17:47.583]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.583] getGlobalsAndPackages() ...
[16:17:47.583] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.583] Resolving globals: FALSE
[16:17:47.583] Tweak future expression to call with '...' arguments ...
[16:17:47.583] {
[16:17:47.583]     do.call(function(...) {
[16:17:47.583]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.583]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.583]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.583]             on.exit(options(oopts), add = TRUE)
[16:17:47.583]         }
[16:17:47.583]         {
[16:17:47.583]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.583]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.583]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.583]             })
[16:17:47.583]         }
[16:17:47.583]     }, args = future.call.arguments)
[16:17:47.583] }
[16:17:47.584] Tweak future expression to call with '...' arguments ... DONE
[16:17:47.584] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.585] 
[16:17:47.585] getGlobalsAndPackages() ... DONE
[16:17:47.585] run() for ‘Future’ ...
[16:17:47.586] - state: ‘created’
[16:17:47.586] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:47.590] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:47.591] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:47.591]   - Field: ‘label’
[16:17:47.591]   - Field: ‘local’
[16:17:47.591]   - Field: ‘owner’
[16:17:47.591]   - Field: ‘envir’
[16:17:47.591]   - Field: ‘workers’
[16:17:47.591]   - Field: ‘packages’
[16:17:47.592]   - Field: ‘gc’
[16:17:47.592]   - Field: ‘job’
[16:17:47.592]   - Field: ‘conditions’
[16:17:47.592]   - Field: ‘expr’
[16:17:47.592]   - Field: ‘uuid’
[16:17:47.592]   - Field: ‘seed’
[16:17:47.593]   - Field: ‘version’
[16:17:47.593]   - Field: ‘result’
[16:17:47.593]   - Field: ‘asynchronous’
[16:17:47.593]   - Field: ‘calls’
[16:17:47.593]   - Field: ‘globals’
[16:17:47.593]   - Field: ‘stdout’
[16:17:47.593]   - Field: ‘earlySignal’
[16:17:47.594]   - Field: ‘lazy’
[16:17:47.594]   - Field: ‘state’
[16:17:47.594] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:47.597] - Launch lazy future ...
[16:17:47.598] Packages needed by the future expression (n = 1): ‘stats’
[16:17:47.598] Packages needed by future strategies (n = 0): <none>
[16:17:47.599] {
[16:17:47.599]     {
[16:17:47.599]         {
[16:17:47.599]             ...future.startTime <- base::Sys.time()
[16:17:47.599]             {
[16:17:47.599]                 {
[16:17:47.599]                   {
[16:17:47.599]                     {
[16:17:47.599]                       {
[16:17:47.599]                         base::local({
[16:17:47.599]                           has_future <- base::requireNamespace("future", 
[16:17:47.599]                             quietly = TRUE)
[16:17:47.599]                           if (has_future) {
[16:17:47.599]                             ns <- base::getNamespace("future")
[16:17:47.599]                             version <- ns[[".package"]][["version"]]
[16:17:47.599]                             if (is.null(version)) 
[16:17:47.599]                               version <- utils::packageVersion("future")
[16:17:47.599]                           }
[16:17:47.599]                           else {
[16:17:47.599]                             version <- NULL
[16:17:47.599]                           }
[16:17:47.599]                           if (!has_future || version < "1.8.0") {
[16:17:47.599]                             info <- base::c(r_version = base::gsub("R version ", 
[16:17:47.599]                               "", base::R.version$version.string), 
[16:17:47.599]                               platform = base::sprintf("%s (%s-bit)", 
[16:17:47.599]                                 base::R.version$platform, 8 * 
[16:17:47.599]                                   base::.Machine$sizeof.pointer), 
[16:17:47.599]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:47.599]                                 "release", "version")], collapse = " "), 
[16:17:47.599]                               hostname = base::Sys.info()[["nodename"]])
[16:17:47.599]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:17:47.599]                               info)
[16:17:47.599]                             info <- base::paste(info, collapse = "; ")
[16:17:47.599]                             if (!has_future) {
[16:17:47.599]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:47.599]                                 info)
[16:17:47.599]                             }
[16:17:47.599]                             else {
[16:17:47.599]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:47.599]                                 info, version)
[16:17:47.599]                             }
[16:17:47.599]                             base::stop(msg)
[16:17:47.599]                           }
[16:17:47.599]                         })
[16:17:47.599]                       }
[16:17:47.599]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:47.599]                       base::options(mc.cores = 1L)
[16:17:47.599]                     }
[16:17:47.599]                     base::local({
[16:17:47.599]                       for (pkg in "stats") {
[16:17:47.599]                         base::loadNamespace(pkg)
[16:17:47.599]                         base::library(pkg, character.only = TRUE)
[16:17:47.599]                       }
[16:17:47.599]                     })
[16:17:47.599]                   }
[16:17:47.599]                   ...future.strategy.old <- future::plan("list")
[16:17:47.599]                   options(future.plan = NULL)
[16:17:47.599]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.599]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:47.599]                 }
[16:17:47.599]                 ...future.workdir <- getwd()
[16:17:47.599]             }
[16:17:47.599]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:47.599]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:47.599]         }
[16:17:47.599]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:47.599]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:47.599]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:47.599]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:47.599]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:47.599]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:47.599]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:47.599]             base::names(...future.oldOptions))
[16:17:47.599]     }
[16:17:47.599]     if (FALSE) {
[16:17:47.599]     }
[16:17:47.599]     else {
[16:17:47.599]         if (TRUE) {
[16:17:47.599]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:47.599]                 open = "w")
[16:17:47.599]         }
[16:17:47.599]         else {
[16:17:47.599]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:47.599]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:47.599]         }
[16:17:47.599]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:47.599]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:47.599]             base::sink(type = "output", split = FALSE)
[16:17:47.599]             base::close(...future.stdout)
[16:17:47.599]         }, add = TRUE)
[16:17:47.599]     }
[16:17:47.599]     ...future.frame <- base::sys.nframe()
[16:17:47.599]     ...future.conditions <- base::list()
[16:17:47.599]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:47.599]     if (FALSE) {
[16:17:47.599]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:47.599]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:47.599]     }
[16:17:47.599]     ...future.result <- base::tryCatch({
[16:17:47.599]         base::withCallingHandlers({
[16:17:47.599]             ...future.value <- base::withVisible(base::local({
[16:17:47.599]                 withCallingHandlers({
[16:17:47.599]                   {
[16:17:47.599]                     do.call(function(...) {
[16:17:47.599]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.599]                       if (!identical(...future.globals.maxSize.org, 
[16:17:47.599]                         ...future.globals.maxSize)) {
[16:17:47.599]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.599]                         on.exit(options(oopts), add = TRUE)
[16:17:47.599]                       }
[16:17:47.599]                       {
[16:17:47.599]                         lapply(seq_along(...future.elements_ii), 
[16:17:47.599]                           FUN = function(jj) {
[16:17:47.599]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.599]                             ...future.FUN(...future.X_jj, ...)
[16:17:47.599]                           })
[16:17:47.599]                       }
[16:17:47.599]                     }, args = future.call.arguments)
[16:17:47.599]                   }
[16:17:47.599]                 }, immediateCondition = function(cond) {
[16:17:47.599]                   save_rds <- function (object, pathname, ...) 
[16:17:47.599]                   {
[16:17:47.599]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:47.599]                     if (file_test("-f", pathname_tmp)) {
[16:17:47.599]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.599]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:47.599]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.599]                         fi_tmp[["mtime"]])
[16:17:47.599]                     }
[16:17:47.599]                     tryCatch({
[16:17:47.599]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:47.599]                     }, error = function(ex) {
[16:17:47.599]                       msg <- conditionMessage(ex)
[16:17:47.599]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.599]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:47.599]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.599]                         fi_tmp[["mtime"]], msg)
[16:17:47.599]                       ex$message <- msg
[16:17:47.599]                       stop(ex)
[16:17:47.599]                     })
[16:17:47.599]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:47.599]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:47.599]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:47.599]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.599]                       fi <- file.info(pathname)
[16:17:47.599]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:47.599]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.599]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:47.599]                         fi[["size"]], fi[["mtime"]])
[16:17:47.599]                       stop(msg)
[16:17:47.599]                     }
[16:17:47.599]                     invisible(pathname)
[16:17:47.599]                   }
[16:17:47.599]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:47.599]                     rootPath = tempdir()) 
[16:17:47.599]                   {
[16:17:47.599]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:47.599]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:47.599]                       tmpdir = path, fileext = ".rds")
[16:17:47.599]                     save_rds(obj, file)
[16:17:47.599]                   }
[16:17:47.599]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1cUuyG/.future/immediateConditions")
[16:17:47.599]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.599]                   {
[16:17:47.599]                     inherits <- base::inherits
[16:17:47.599]                     invokeRestart <- base::invokeRestart
[16:17:47.599]                     is.null <- base::is.null
[16:17:47.599]                     muffled <- FALSE
[16:17:47.599]                     if (inherits(cond, "message")) {
[16:17:47.599]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:47.599]                       if (muffled) 
[16:17:47.599]                         invokeRestart("muffleMessage")
[16:17:47.599]                     }
[16:17:47.599]                     else if (inherits(cond, "warning")) {
[16:17:47.599]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:47.599]                       if (muffled) 
[16:17:47.599]                         invokeRestart("muffleWarning")
[16:17:47.599]                     }
[16:17:47.599]                     else if (inherits(cond, "condition")) {
[16:17:47.599]                       if (!is.null(pattern)) {
[16:17:47.599]                         computeRestarts <- base::computeRestarts
[16:17:47.599]                         grepl <- base::grepl
[16:17:47.599]                         restarts <- computeRestarts(cond)
[16:17:47.599]                         for (restart in restarts) {
[16:17:47.599]                           name <- restart$name
[16:17:47.599]                           if (is.null(name)) 
[16:17:47.599]                             next
[16:17:47.599]                           if (!grepl(pattern, name)) 
[16:17:47.599]                             next
[16:17:47.599]                           invokeRestart(restart)
[16:17:47.599]                           muffled <- TRUE
[16:17:47.599]                           break
[16:17:47.599]                         }
[16:17:47.599]                       }
[16:17:47.599]                     }
[16:17:47.599]                     invisible(muffled)
[16:17:47.599]                   }
[16:17:47.599]                   muffleCondition(cond)
[16:17:47.599]                 })
[16:17:47.599]             }))
[16:17:47.599]             future::FutureResult(value = ...future.value$value, 
[16:17:47.599]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.599]                   ...future.rng), globalenv = if (FALSE) 
[16:17:47.599]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:47.599]                     ...future.globalenv.names))
[16:17:47.599]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:47.599]         }, condition = base::local({
[16:17:47.599]             c <- base::c
[16:17:47.599]             inherits <- base::inherits
[16:17:47.599]             invokeRestart <- base::invokeRestart
[16:17:47.599]             length <- base::length
[16:17:47.599]             list <- base::list
[16:17:47.599]             seq.int <- base::seq.int
[16:17:47.599]             signalCondition <- base::signalCondition
[16:17:47.599]             sys.calls <- base::sys.calls
[16:17:47.599]             `[[` <- base::`[[`
[16:17:47.599]             `+` <- base::`+`
[16:17:47.599]             `<<-` <- base::`<<-`
[16:17:47.599]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:47.599]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:47.599]                   3L)]
[16:17:47.599]             }
[16:17:47.599]             function(cond) {
[16:17:47.599]                 is_error <- inherits(cond, "error")
[16:17:47.599]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:47.599]                   NULL)
[16:17:47.599]                 if (is_error) {
[16:17:47.599]                   sessionInformation <- function() {
[16:17:47.599]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:47.599]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:47.599]                       search = base::search(), system = base::Sys.info())
[16:17:47.599]                   }
[16:17:47.599]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.599]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:47.599]                     cond$call), session = sessionInformation(), 
[16:17:47.599]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:47.599]                   signalCondition(cond)
[16:17:47.599]                 }
[16:17:47.599]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:47.599]                 "immediateCondition"))) {
[16:17:47.599]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:47.599]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.599]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:47.599]                   if (TRUE && !signal) {
[16:17:47.599]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.599]                     {
[16:17:47.599]                       inherits <- base::inherits
[16:17:47.599]                       invokeRestart <- base::invokeRestart
[16:17:47.599]                       is.null <- base::is.null
[16:17:47.599]                       muffled <- FALSE
[16:17:47.599]                       if (inherits(cond, "message")) {
[16:17:47.599]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.599]                         if (muffled) 
[16:17:47.599]                           invokeRestart("muffleMessage")
[16:17:47.599]                       }
[16:17:47.599]                       else if (inherits(cond, "warning")) {
[16:17:47.599]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.599]                         if (muffled) 
[16:17:47.599]                           invokeRestart("muffleWarning")
[16:17:47.599]                       }
[16:17:47.599]                       else if (inherits(cond, "condition")) {
[16:17:47.599]                         if (!is.null(pattern)) {
[16:17:47.599]                           computeRestarts <- base::computeRestarts
[16:17:47.599]                           grepl <- base::grepl
[16:17:47.599]                           restarts <- computeRestarts(cond)
[16:17:47.599]                           for (restart in restarts) {
[16:17:47.599]                             name <- restart$name
[16:17:47.599]                             if (is.null(name)) 
[16:17:47.599]                               next
[16:17:47.599]                             if (!grepl(pattern, name)) 
[16:17:47.599]                               next
[16:17:47.599]                             invokeRestart(restart)
[16:17:47.599]                             muffled <- TRUE
[16:17:47.599]                             break
[16:17:47.599]                           }
[16:17:47.599]                         }
[16:17:47.599]                       }
[16:17:47.599]                       invisible(muffled)
[16:17:47.599]                     }
[16:17:47.599]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.599]                   }
[16:17:47.599]                 }
[16:17:47.599]                 else {
[16:17:47.599]                   if (TRUE) {
[16:17:47.599]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.599]                     {
[16:17:47.599]                       inherits <- base::inherits
[16:17:47.599]                       invokeRestart <- base::invokeRestart
[16:17:47.599]                       is.null <- base::is.null
[16:17:47.599]                       muffled <- FALSE
[16:17:47.599]                       if (inherits(cond, "message")) {
[16:17:47.599]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.599]                         if (muffled) 
[16:17:47.599]                           invokeRestart("muffleMessage")
[16:17:47.599]                       }
[16:17:47.599]                       else if (inherits(cond, "warning")) {
[16:17:47.599]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.599]                         if (muffled) 
[16:17:47.599]                           invokeRestart("muffleWarning")
[16:17:47.599]                       }
[16:17:47.599]                       else if (inherits(cond, "condition")) {
[16:17:47.599]                         if (!is.null(pattern)) {
[16:17:47.599]                           computeRestarts <- base::computeRestarts
[16:17:47.599]                           grepl <- base::grepl
[16:17:47.599]                           restarts <- computeRestarts(cond)
[16:17:47.599]                           for (restart in restarts) {
[16:17:47.599]                             name <- restart$name
[16:17:47.599]                             if (is.null(name)) 
[16:17:47.599]                               next
[16:17:47.599]                             if (!grepl(pattern, name)) 
[16:17:47.599]                               next
[16:17:47.599]                             invokeRestart(restart)
[16:17:47.599]                             muffled <- TRUE
[16:17:47.599]                             break
[16:17:47.599]                           }
[16:17:47.599]                         }
[16:17:47.599]                       }
[16:17:47.599]                       invisible(muffled)
[16:17:47.599]                     }
[16:17:47.599]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.599]                   }
[16:17:47.599]                 }
[16:17:47.599]             }
[16:17:47.599]         }))
[16:17:47.599]     }, error = function(ex) {
[16:17:47.599]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:47.599]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.599]                 ...future.rng), started = ...future.startTime, 
[16:17:47.599]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:47.599]             version = "1.8"), class = "FutureResult")
[16:17:47.599]     }, finally = {
[16:17:47.599]         if (!identical(...future.workdir, getwd())) 
[16:17:47.599]             setwd(...future.workdir)
[16:17:47.599]         {
[16:17:47.599]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:47.599]                 ...future.oldOptions$nwarnings <- NULL
[16:17:47.599]             }
[16:17:47.599]             base::options(...future.oldOptions)
[16:17:47.599]             if (.Platform$OS.type == "windows") {
[16:17:47.599]                 old_names <- names(...future.oldEnvVars)
[16:17:47.599]                 envs <- base::Sys.getenv()
[16:17:47.599]                 names <- names(envs)
[16:17:47.599]                 common <- intersect(names, old_names)
[16:17:47.599]                 added <- setdiff(names, old_names)
[16:17:47.599]                 removed <- setdiff(old_names, names)
[16:17:47.599]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:47.599]                   envs[common]]
[16:17:47.599]                 NAMES <- toupper(changed)
[16:17:47.599]                 args <- list()
[16:17:47.599]                 for (kk in seq_along(NAMES)) {
[16:17:47.599]                   name <- changed[[kk]]
[16:17:47.599]                   NAME <- NAMES[[kk]]
[16:17:47.599]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.599]                     next
[16:17:47.599]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.599]                 }
[16:17:47.599]                 NAMES <- toupper(added)
[16:17:47.599]                 for (kk in seq_along(NAMES)) {
[16:17:47.599]                   name <- added[[kk]]
[16:17:47.599]                   NAME <- NAMES[[kk]]
[16:17:47.599]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.599]                     next
[16:17:47.599]                   args[[name]] <- ""
[16:17:47.599]                 }
[16:17:47.599]                 NAMES <- toupper(removed)
[16:17:47.599]                 for (kk in seq_along(NAMES)) {
[16:17:47.599]                   name <- removed[[kk]]
[16:17:47.599]                   NAME <- NAMES[[kk]]
[16:17:47.599]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.599]                     next
[16:17:47.599]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.599]                 }
[16:17:47.599]                 if (length(args) > 0) 
[16:17:47.599]                   base::do.call(base::Sys.setenv, args = args)
[16:17:47.599]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:47.599]             }
[16:17:47.599]             else {
[16:17:47.599]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:47.599]             }
[16:17:47.599]             {
[16:17:47.599]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:47.599]                   0L) {
[16:17:47.599]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:47.599]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:47.599]                   base::options(opts)
[16:17:47.599]                 }
[16:17:47.599]                 {
[16:17:47.599]                   {
[16:17:47.599]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:47.599]                     NULL
[16:17:47.599]                   }
[16:17:47.599]                   options(future.plan = NULL)
[16:17:47.599]                   if (is.na(NA_character_)) 
[16:17:47.599]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.599]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:47.599]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:47.599]                     .init = FALSE)
[16:17:47.599]                 }
[16:17:47.599]             }
[16:17:47.599]         }
[16:17:47.599]     })
[16:17:47.599]     if (TRUE) {
[16:17:47.599]         base::sink(type = "output", split = FALSE)
[16:17:47.599]         if (TRUE) {
[16:17:47.599]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:47.599]         }
[16:17:47.599]         else {
[16:17:47.599]             ...future.result["stdout"] <- base::list(NULL)
[16:17:47.599]         }
[16:17:47.599]         base::close(...future.stdout)
[16:17:47.599]         ...future.stdout <- NULL
[16:17:47.599]     }
[16:17:47.599]     ...future.result$conditions <- ...future.conditions
[16:17:47.599]     ...future.result$finished <- base::Sys.time()
[16:17:47.599]     ...future.result
[16:17:47.599] }
[16:17:47.602] assign_globals() ...
[16:17:47.603] List of 5
[16:17:47.603]  $ ...future.FUN            :function (x, ...)  
[16:17:47.603]  $ future.call.arguments    :List of 1
[16:17:47.603]   ..$ singular.ok: logi FALSE
[16:17:47.603]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.603]  $ ...future.elements_ii    :List of 2
[16:17:47.603]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:47.603]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:17:47.603]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.603]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:17:47.603]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:47.603]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:17:47.603]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.603]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:17:47.603]  $ ...future.seeds_ii       : NULL
[16:17:47.603]  $ ...future.globals.maxSize: NULL
[16:17:47.603]  - attr(*, "where")=List of 5
[16:17:47.603]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:47.603]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:47.603]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:47.603]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:47.603]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:47.603]  - attr(*, "resolved")= logi FALSE
[16:17:47.603]  - attr(*, "total_size")= num 5384
[16:17:47.603]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.603]  - attr(*, "already-done")= logi TRUE
[16:17:47.616] - reassign environment for ‘...future.FUN’
[16:17:47.616] - copied ‘...future.FUN’ to environment
[16:17:47.616] - copied ‘future.call.arguments’ to environment
[16:17:47.616] - copied ‘...future.elements_ii’ to environment
[16:17:47.616] - copied ‘...future.seeds_ii’ to environment
[16:17:47.616] - copied ‘...future.globals.maxSize’ to environment
[16:17:47.616] assign_globals() ... done
[16:17:47.616] requestCore(): workers = 2
[16:17:47.618] MulticoreFuture started
[16:17:47.619] - Launch lazy future ... done
[16:17:47.619] run() for ‘MulticoreFuture’ ... done
[16:17:47.619] Created future:
[16:17:47.620] plan(): Setting new future strategy stack:
[16:17:47.620] List of future strategies:
[16:17:47.620] 1. sequential:
[16:17:47.620]    - args: function (..., envir = parent.frame())
[16:17:47.620]    - tweaked: FALSE
[16:17:47.620]    - call: NULL
[16:17:47.621] plan(): nbrOfWorkers() = 1
[16:17:47.626] plan(): Setting new future strategy stack:
[16:17:47.626] List of future strategies:
[16:17:47.626] 1. multicore:
[16:17:47.626]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:47.626]    - tweaked: FALSE
[16:17:47.626]    - call: plan(strategy)
[16:17:47.632] plan(): nbrOfWorkers() = 2
[16:17:47.620] MulticoreFuture:
[16:17:47.620] Label: ‘future_by-2’
[16:17:47.620] Expression:
[16:17:47.620] {
[16:17:47.620]     do.call(function(...) {
[16:17:47.620]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.620]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.620]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.620]             on.exit(options(oopts), add = TRUE)
[16:17:47.620]         }
[16:17:47.620]         {
[16:17:47.620]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.620]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.620]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.620]             })
[16:17:47.620]         }
[16:17:47.620]     }, args = future.call.arguments)
[16:17:47.620] }
[16:17:47.620] Lazy evaluation: FALSE
[16:17:47.620] Asynchronous evaluation: TRUE
[16:17:47.620] Local evaluation: TRUE
[16:17:47.620] Environment: R_GlobalEnv
[16:17:47.620] Capture standard output: TRUE
[16:17:47.620] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:47.620] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:47.620] Packages: 1 packages (‘stats’)
[16:17:47.620] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:47.620] Resolved: FALSE
[16:17:47.620] Value: <not collected>
[16:17:47.620] Conditions captured: <none>
[16:17:47.620] Early signaling: FALSE
[16:17:47.620] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:47.620] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:47.633] Chunk #2 of 2 ... DONE
[16:17:47.633] Launching 2 futures (chunks) ... DONE
[16:17:47.633] Resolving 2 futures (chunks) ...
[16:17:47.633] resolve() on list ...
[16:17:47.634]  recursive: 0
[16:17:47.634]  length: 2
[16:17:47.634] 
[16:17:47.634] Future #1
[16:17:47.634] result() for MulticoreFuture ...
[16:17:47.636] result() for MulticoreFuture ...
[16:17:47.636] result() for MulticoreFuture ... done
[16:17:47.636] result() for MulticoreFuture ... done
[16:17:47.636] result() for MulticoreFuture ...
[16:17:47.636] result() for MulticoreFuture ... done
[16:17:47.637] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:17:47.637] - nx: 2
[16:17:47.637] - relay: TRUE
[16:17:47.637] - stdout: TRUE
[16:17:47.637] - signal: TRUE
[16:17:47.637] - resignal: FALSE
[16:17:47.637] - force: TRUE
[16:17:47.637] - relayed: [n=2] FALSE, FALSE
[16:17:47.638] - queued futures: [n=2] FALSE, FALSE
[16:17:47.638]  - until=1
[16:17:47.638]  - relaying element #1
[16:17:47.638] result() for MulticoreFuture ...
[16:17:47.638] result() for MulticoreFuture ... done
[16:17:47.638] result() for MulticoreFuture ...
[16:17:47.638] result() for MulticoreFuture ... done
[16:17:47.639] result() for MulticoreFuture ...
[16:17:47.639] result() for MulticoreFuture ... done
[16:17:47.639] result() for MulticoreFuture ...
[16:17:47.639] result() for MulticoreFuture ... done
[16:17:47.639] - relayed: [n=2] TRUE, FALSE
[16:17:47.639] - queued futures: [n=2] TRUE, FALSE
[16:17:47.639] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:17:47.640]  length: 1 (resolved future 1)
[16:17:47.640] Future #2
[16:17:47.640] result() for MulticoreFuture ...
[16:17:47.641] result() for MulticoreFuture ...
[16:17:47.641] result() for MulticoreFuture ... done
[16:17:47.642] result() for MulticoreFuture ... done
[16:17:47.642] result() for MulticoreFuture ...
[16:17:47.642] result() for MulticoreFuture ... done
[16:17:47.642] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:17:47.645] - nx: 2
[16:17:47.645] - relay: TRUE
[16:17:47.645] - stdout: TRUE
[16:17:47.645] - signal: TRUE
[16:17:47.646] - resignal: FALSE
[16:17:47.646] - force: TRUE
[16:17:47.646] - relayed: [n=2] TRUE, FALSE
[16:17:47.646] - queued futures: [n=2] TRUE, FALSE
[16:17:47.646]  - until=2
[16:17:47.646]  - relaying element #2
[16:17:47.646] result() for MulticoreFuture ...
[16:17:47.647] result() for MulticoreFuture ... done
[16:17:47.647] result() for MulticoreFuture ...
[16:17:47.647] result() for MulticoreFuture ... done
[16:17:47.647] result() for MulticoreFuture ...
[16:17:47.647] result() for MulticoreFuture ... done
[16:17:47.648] result() for MulticoreFuture ...
[16:17:47.648] result() for MulticoreFuture ... done
[16:17:47.648] - relayed: [n=2] TRUE, TRUE
[16:17:47.648] - queued futures: [n=2] TRUE, TRUE
[16:17:47.648] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:17:47.648]  length: 0 (resolved future 2)
[16:17:47.648] Relaying remaining futures
[16:17:47.649] signalConditionsASAP(NULL, pos=0) ...
[16:17:47.649] - nx: 2
[16:17:47.649] - relay: TRUE
[16:17:47.649] - stdout: TRUE
[16:17:47.649] - signal: TRUE
[16:17:47.649] - resignal: FALSE
[16:17:47.649] - force: TRUE
[16:17:47.650] - relayed: [n=2] TRUE, TRUE
[16:17:47.650] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:47.650] - relayed: [n=2] TRUE, TRUE
[16:17:47.650] - queued futures: [n=2] TRUE, TRUE
[16:17:47.650] signalConditionsASAP(NULL, pos=0) ... done
[16:17:47.650] resolve() on list ... DONE
[16:17:47.650] result() for MulticoreFuture ...
[16:17:47.651] result() for MulticoreFuture ... done
[16:17:47.651] result() for MulticoreFuture ...
[16:17:47.651] result() for MulticoreFuture ... done
[16:17:47.651] result() for MulticoreFuture ...
[16:17:47.651] result() for MulticoreFuture ... done
[16:17:47.651] result() for MulticoreFuture ...
[16:17:47.651] result() for MulticoreFuture ... done
[16:17:47.652]  - Number of value chunks collected: 2
[16:17:47.652] Resolving 2 futures (chunks) ... DONE
[16:17:47.652] Reducing values from 2 chunks ...
[16:17:47.652]  - Number of values collected after concatenation: 3
[16:17:47.652]  - Number of values expected: 3
[16:17:47.652] Reducing values from 2 chunks ... DONE
[16:17:47.652] future_lapply() ... DONE
[16:17:47.653] future_by_internal() ... DONE
[16:17:47.657] future_by_internal() ...
[16:17:47.658] future_lapply() ...
[16:17:47.662] Number of chunks: 2
[16:17:47.663] getGlobalsAndPackagesXApply() ...
[16:17:47.663]  - future.globals: TRUE
[16:17:47.663] getGlobalsAndPackages() ...
[16:17:47.663] Searching for globals...
[16:17:47.665] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:17:47.665] Searching for globals ... DONE
[16:17:47.665] Resolving globals: FALSE
[16:17:47.665] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[16:17:47.666] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[16:17:47.666] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[16:17:47.667] - packages: [1] ‘stats’
[16:17:47.668] getGlobalsAndPackages() ... DONE
[16:17:47.668]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[16:17:47.668]  - needed namespaces: [n=1] ‘stats’
[16:17:47.668] Finding globals ... DONE
[16:17:47.668]  - use_args: TRUE
[16:17:47.668]  - Getting '...' globals ...
[16:17:47.668] resolve() on list ...
[16:17:47.669]  recursive: 0
[16:17:47.669]  length: 1
[16:17:47.669]  elements: ‘...’
[16:17:47.669]  length: 0 (resolved future 1)
[16:17:47.669] resolve() on list ... DONE
[16:17:47.669]    - '...' content: [n=0] 
[16:17:47.669] List of 1
[16:17:47.669]  $ ...: list()
[16:17:47.669]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.669]  - attr(*, "where")=List of 1
[16:17:47.669]   ..$ ...:<environment: 0x55b565cf5678> 
[16:17:47.669]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.669]  - attr(*, "resolved")= logi TRUE
[16:17:47.669]  - attr(*, "total_size")= num NA
[16:17:47.672]  - Getting '...' globals ... DONE
[16:17:47.672] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[16:17:47.672] List of 4
[16:17:47.672]  $ ...future.FUN:function (x)  
[16:17:47.672]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:17:47.672]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:47.672]  $ ...          : list()
[16:17:47.672]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.672]  - attr(*, "where")=List of 4
[16:17:47.672]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:47.672]   ..$ breaks       :<environment: R_EmptyEnv> 
[16:17:47.672]   ..$ wool         :<environment: R_EmptyEnv> 
[16:17:47.672]   ..$ ...          :<environment: 0x55b565cf5678> 
[16:17:47.672]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.672]  - attr(*, "resolved")= logi FALSE
[16:17:47.672]  - attr(*, "total_size")= num 2320
[16:17:47.676] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:47.676] getGlobalsAndPackagesXApply() ... DONE
[16:17:47.676] Number of futures (= number of chunks): 2
[16:17:47.677] Launching 2 futures (chunks) ...
[16:17:47.677] Chunk #1 of 2 ...
[16:17:47.677]  - Finding globals in 'X' for chunk #1 ...
[16:17:47.677] getGlobalsAndPackages() ...
[16:17:47.677] Searching for globals...
[16:17:47.677] 
[16:17:47.677] Searching for globals ... DONE
[16:17:47.678] - globals: [0] <none>
[16:17:47.678] getGlobalsAndPackages() ... DONE
[16:17:47.678]    + additional globals found: [n=0] 
[16:17:47.678]    + additional namespaces needed: [n=0] 
[16:17:47.678]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:47.678]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:47.678]  - seeds: <none>
[16:17:47.678]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.678] getGlobalsAndPackages() ...
[16:17:47.678] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.678] Resolving globals: FALSE
[16:17:47.679] Tweak future expression to call with '...' arguments ...
[16:17:47.679] {
[16:17:47.679]     do.call(function(...) {
[16:17:47.679]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.679]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.679]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.679]             on.exit(options(oopts), add = TRUE)
[16:17:47.679]         }
[16:17:47.679]         {
[16:17:47.679]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.679]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.679]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.679]             })
[16:17:47.679]         }
[16:17:47.679]     }, args = future.call.arguments)
[16:17:47.679] }
[16:17:47.679] Tweak future expression to call with '...' arguments ... DONE
[16:17:47.679] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.679] 
[16:17:47.680] getGlobalsAndPackages() ... DONE
[16:17:47.680] run() for ‘Future’ ...
[16:17:47.680] - state: ‘created’
[16:17:47.680] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:47.684] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:47.684] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:47.684]   - Field: ‘label’
[16:17:47.684]   - Field: ‘local’
[16:17:47.684]   - Field: ‘owner’
[16:17:47.684]   - Field: ‘envir’
[16:17:47.684]   - Field: ‘workers’
[16:17:47.684]   - Field: ‘packages’
[16:17:47.684]   - Field: ‘gc’
[16:17:47.685]   - Field: ‘job’
[16:17:47.685]   - Field: ‘conditions’
[16:17:47.685]   - Field: ‘expr’
[16:17:47.685]   - Field: ‘uuid’
[16:17:47.685]   - Field: ‘seed’
[16:17:47.685]   - Field: ‘version’
[16:17:47.685]   - Field: ‘result’
[16:17:47.685]   - Field: ‘asynchronous’
[16:17:47.685]   - Field: ‘calls’
[16:17:47.685]   - Field: ‘globals’
[16:17:47.685]   - Field: ‘stdout’
[16:17:47.685]   - Field: ‘earlySignal’
[16:17:47.686]   - Field: ‘lazy’
[16:17:47.686]   - Field: ‘state’
[16:17:47.686] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:47.686] - Launch lazy future ...
[16:17:47.686] Packages needed by the future expression (n = 1): ‘stats’
[16:17:47.686] Packages needed by future strategies (n = 0): <none>
[16:17:47.688] {
[16:17:47.688]     {
[16:17:47.688]         {
[16:17:47.688]             ...future.startTime <- base::Sys.time()
[16:17:47.688]             {
[16:17:47.688]                 {
[16:17:47.688]                   {
[16:17:47.688]                     {
[16:17:47.688]                       {
[16:17:47.688]                         base::local({
[16:17:47.688]                           has_future <- base::requireNamespace("future", 
[16:17:47.688]                             quietly = TRUE)
[16:17:47.688]                           if (has_future) {
[16:17:47.688]                             ns <- base::getNamespace("future")
[16:17:47.688]                             version <- ns[[".package"]][["version"]]
[16:17:47.688]                             if (is.null(version)) 
[16:17:47.688]                               version <- utils::packageVersion("future")
[16:17:47.688]                           }
[16:17:47.688]                           else {
[16:17:47.688]                             version <- NULL
[16:17:47.688]                           }
[16:17:47.688]                           if (!has_future || version < "1.8.0") {
[16:17:47.688]                             info <- base::c(r_version = base::gsub("R version ", 
[16:17:47.688]                               "", base::R.version$version.string), 
[16:17:47.688]                               platform = base::sprintf("%s (%s-bit)", 
[16:17:47.688]                                 base::R.version$platform, 8 * 
[16:17:47.688]                                   base::.Machine$sizeof.pointer), 
[16:17:47.688]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:47.688]                                 "release", "version")], collapse = " "), 
[16:17:47.688]                               hostname = base::Sys.info()[["nodename"]])
[16:17:47.688]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:17:47.688]                               info)
[16:17:47.688]                             info <- base::paste(info, collapse = "; ")
[16:17:47.688]                             if (!has_future) {
[16:17:47.688]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:47.688]                                 info)
[16:17:47.688]                             }
[16:17:47.688]                             else {
[16:17:47.688]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:47.688]                                 info, version)
[16:17:47.688]                             }
[16:17:47.688]                             base::stop(msg)
[16:17:47.688]                           }
[16:17:47.688]                         })
[16:17:47.688]                       }
[16:17:47.688]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:47.688]                       base::options(mc.cores = 1L)
[16:17:47.688]                     }
[16:17:47.688]                     base::local({
[16:17:47.688]                       for (pkg in "stats") {
[16:17:47.688]                         base::loadNamespace(pkg)
[16:17:47.688]                         base::library(pkg, character.only = TRUE)
[16:17:47.688]                       }
[16:17:47.688]                     })
[16:17:47.688]                   }
[16:17:47.688]                   ...future.strategy.old <- future::plan("list")
[16:17:47.688]                   options(future.plan = NULL)
[16:17:47.688]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.688]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:47.688]                 }
[16:17:47.688]                 ...future.workdir <- getwd()
[16:17:47.688]             }
[16:17:47.688]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:47.688]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:47.688]         }
[16:17:47.688]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:47.688]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:47.688]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:47.688]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:47.688]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:47.688]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:47.688]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:47.688]             base::names(...future.oldOptions))
[16:17:47.688]     }
[16:17:47.688]     if (FALSE) {
[16:17:47.688]     }
[16:17:47.688]     else {
[16:17:47.688]         if (TRUE) {
[16:17:47.688]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:47.688]                 open = "w")
[16:17:47.688]         }
[16:17:47.688]         else {
[16:17:47.688]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:47.688]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:47.688]         }
[16:17:47.688]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:47.688]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:47.688]             base::sink(type = "output", split = FALSE)
[16:17:47.688]             base::close(...future.stdout)
[16:17:47.688]         }, add = TRUE)
[16:17:47.688]     }
[16:17:47.688]     ...future.frame <- base::sys.nframe()
[16:17:47.688]     ...future.conditions <- base::list()
[16:17:47.688]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:47.688]     if (FALSE) {
[16:17:47.688]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:47.688]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:47.688]     }
[16:17:47.688]     ...future.result <- base::tryCatch({
[16:17:47.688]         base::withCallingHandlers({
[16:17:47.688]             ...future.value <- base::withVisible(base::local({
[16:17:47.688]                 withCallingHandlers({
[16:17:47.688]                   {
[16:17:47.688]                     do.call(function(...) {
[16:17:47.688]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.688]                       if (!identical(...future.globals.maxSize.org, 
[16:17:47.688]                         ...future.globals.maxSize)) {
[16:17:47.688]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.688]                         on.exit(options(oopts), add = TRUE)
[16:17:47.688]                       }
[16:17:47.688]                       {
[16:17:47.688]                         lapply(seq_along(...future.elements_ii), 
[16:17:47.688]                           FUN = function(jj) {
[16:17:47.688]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.688]                             ...future.FUN(...future.X_jj, ...)
[16:17:47.688]                           })
[16:17:47.688]                       }
[16:17:47.688]                     }, args = future.call.arguments)
[16:17:47.688]                   }
[16:17:47.688]                 }, immediateCondition = function(cond) {
[16:17:47.688]                   save_rds <- function (object, pathname, ...) 
[16:17:47.688]                   {
[16:17:47.688]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:47.688]                     if (file_test("-f", pathname_tmp)) {
[16:17:47.688]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.688]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:47.688]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.688]                         fi_tmp[["mtime"]])
[16:17:47.688]                     }
[16:17:47.688]                     tryCatch({
[16:17:47.688]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:47.688]                     }, error = function(ex) {
[16:17:47.688]                       msg <- conditionMessage(ex)
[16:17:47.688]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.688]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:47.688]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.688]                         fi_tmp[["mtime"]], msg)
[16:17:47.688]                       ex$message <- msg
[16:17:47.688]                       stop(ex)
[16:17:47.688]                     })
[16:17:47.688]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:47.688]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:47.688]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:47.688]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.688]                       fi <- file.info(pathname)
[16:17:47.688]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:47.688]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.688]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:47.688]                         fi[["size"]], fi[["mtime"]])
[16:17:47.688]                       stop(msg)
[16:17:47.688]                     }
[16:17:47.688]                     invisible(pathname)
[16:17:47.688]                   }
[16:17:47.688]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:47.688]                     rootPath = tempdir()) 
[16:17:47.688]                   {
[16:17:47.688]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:47.688]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:47.688]                       tmpdir = path, fileext = ".rds")
[16:17:47.688]                     save_rds(obj, file)
[16:17:47.688]                   }
[16:17:47.688]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1cUuyG/.future/immediateConditions")
[16:17:47.688]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.688]                   {
[16:17:47.688]                     inherits <- base::inherits
[16:17:47.688]                     invokeRestart <- base::invokeRestart
[16:17:47.688]                     is.null <- base::is.null
[16:17:47.688]                     muffled <- FALSE
[16:17:47.688]                     if (inherits(cond, "message")) {
[16:17:47.688]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:47.688]                       if (muffled) 
[16:17:47.688]                         invokeRestart("muffleMessage")
[16:17:47.688]                     }
[16:17:47.688]                     else if (inherits(cond, "warning")) {
[16:17:47.688]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:47.688]                       if (muffled) 
[16:17:47.688]                         invokeRestart("muffleWarning")
[16:17:47.688]                     }
[16:17:47.688]                     else if (inherits(cond, "condition")) {
[16:17:47.688]                       if (!is.null(pattern)) {
[16:17:47.688]                         computeRestarts <- base::computeRestarts
[16:17:47.688]                         grepl <- base::grepl
[16:17:47.688]                         restarts <- computeRestarts(cond)
[16:17:47.688]                         for (restart in restarts) {
[16:17:47.688]                           name <- restart$name
[16:17:47.688]                           if (is.null(name)) 
[16:17:47.688]                             next
[16:17:47.688]                           if (!grepl(pattern, name)) 
[16:17:47.688]                             next
[16:17:47.688]                           invokeRestart(restart)
[16:17:47.688]                           muffled <- TRUE
[16:17:47.688]                           break
[16:17:47.688]                         }
[16:17:47.688]                       }
[16:17:47.688]                     }
[16:17:47.688]                     invisible(muffled)
[16:17:47.688]                   }
[16:17:47.688]                   muffleCondition(cond)
[16:17:47.688]                 })
[16:17:47.688]             }))
[16:17:47.688]             future::FutureResult(value = ...future.value$value, 
[16:17:47.688]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.688]                   ...future.rng), globalenv = if (FALSE) 
[16:17:47.688]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:47.688]                     ...future.globalenv.names))
[16:17:47.688]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:47.688]         }, condition = base::local({
[16:17:47.688]             c <- base::c
[16:17:47.688]             inherits <- base::inherits
[16:17:47.688]             invokeRestart <- base::invokeRestart
[16:17:47.688]             length <- base::length
[16:17:47.688]             list <- base::list
[16:17:47.688]             seq.int <- base::seq.int
[16:17:47.688]             signalCondition <- base::signalCondition
[16:17:47.688]             sys.calls <- base::sys.calls
[16:17:47.688]             `[[` <- base::`[[`
[16:17:47.688]             `+` <- base::`+`
[16:17:47.688]             `<<-` <- base::`<<-`
[16:17:47.688]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:47.688]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:47.688]                   3L)]
[16:17:47.688]             }
[16:17:47.688]             function(cond) {
[16:17:47.688]                 is_error <- inherits(cond, "error")
[16:17:47.688]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:47.688]                   NULL)
[16:17:47.688]                 if (is_error) {
[16:17:47.688]                   sessionInformation <- function() {
[16:17:47.688]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:47.688]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:47.688]                       search = base::search(), system = base::Sys.info())
[16:17:47.688]                   }
[16:17:47.688]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.688]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:47.688]                     cond$call), session = sessionInformation(), 
[16:17:47.688]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:47.688]                   signalCondition(cond)
[16:17:47.688]                 }
[16:17:47.688]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:47.688]                 "immediateCondition"))) {
[16:17:47.688]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:47.688]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.688]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:47.688]                   if (TRUE && !signal) {
[16:17:47.688]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.688]                     {
[16:17:47.688]                       inherits <- base::inherits
[16:17:47.688]                       invokeRestart <- base::invokeRestart
[16:17:47.688]                       is.null <- base::is.null
[16:17:47.688]                       muffled <- FALSE
[16:17:47.688]                       if (inherits(cond, "message")) {
[16:17:47.688]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.688]                         if (muffled) 
[16:17:47.688]                           invokeRestart("muffleMessage")
[16:17:47.688]                       }
[16:17:47.688]                       else if (inherits(cond, "warning")) {
[16:17:47.688]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.688]                         if (muffled) 
[16:17:47.688]                           invokeRestart("muffleWarning")
[16:17:47.688]                       }
[16:17:47.688]                       else if (inherits(cond, "condition")) {
[16:17:47.688]                         if (!is.null(pattern)) {
[16:17:47.688]                           computeRestarts <- base::computeRestarts
[16:17:47.688]                           grepl <- base::grepl
[16:17:47.688]                           restarts <- computeRestarts(cond)
[16:17:47.688]                           for (restart in restarts) {
[16:17:47.688]                             name <- restart$name
[16:17:47.688]                             if (is.null(name)) 
[16:17:47.688]                               next
[16:17:47.688]                             if (!grepl(pattern, name)) 
[16:17:47.688]                               next
[16:17:47.688]                             invokeRestart(restart)
[16:17:47.688]                             muffled <- TRUE
[16:17:47.688]                             break
[16:17:47.688]                           }
[16:17:47.688]                         }
[16:17:47.688]                       }
[16:17:47.688]                       invisible(muffled)
[16:17:47.688]                     }
[16:17:47.688]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.688]                   }
[16:17:47.688]                 }
[16:17:47.688]                 else {
[16:17:47.688]                   if (TRUE) {
[16:17:47.688]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.688]                     {
[16:17:47.688]                       inherits <- base::inherits
[16:17:47.688]                       invokeRestart <- base::invokeRestart
[16:17:47.688]                       is.null <- base::is.null
[16:17:47.688]                       muffled <- FALSE
[16:17:47.688]                       if (inherits(cond, "message")) {
[16:17:47.688]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.688]                         if (muffled) 
[16:17:47.688]                           invokeRestart("muffleMessage")
[16:17:47.688]                       }
[16:17:47.688]                       else if (inherits(cond, "warning")) {
[16:17:47.688]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.688]                         if (muffled) 
[16:17:47.688]                           invokeRestart("muffleWarning")
[16:17:47.688]                       }
[16:17:47.688]                       else if (inherits(cond, "condition")) {
[16:17:47.688]                         if (!is.null(pattern)) {
[16:17:47.688]                           computeRestarts <- base::computeRestarts
[16:17:47.688]                           grepl <- base::grepl
[16:17:47.688]                           restarts <- computeRestarts(cond)
[16:17:47.688]                           for (restart in restarts) {
[16:17:47.688]                             name <- restart$name
[16:17:47.688]                             if (is.null(name)) 
[16:17:47.688]                               next
[16:17:47.688]                             if (!grepl(pattern, name)) 
[16:17:47.688]                               next
[16:17:47.688]                             invokeRestart(restart)
[16:17:47.688]                             muffled <- TRUE
[16:17:47.688]                             break
[16:17:47.688]                           }
[16:17:47.688]                         }
[16:17:47.688]                       }
[16:17:47.688]                       invisible(muffled)
[16:17:47.688]                     }
[16:17:47.688]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.688]                   }
[16:17:47.688]                 }
[16:17:47.688]             }
[16:17:47.688]         }))
[16:17:47.688]     }, error = function(ex) {
[16:17:47.688]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:47.688]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.688]                 ...future.rng), started = ...future.startTime, 
[16:17:47.688]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:47.688]             version = "1.8"), class = "FutureResult")
[16:17:47.688]     }, finally = {
[16:17:47.688]         if (!identical(...future.workdir, getwd())) 
[16:17:47.688]             setwd(...future.workdir)
[16:17:47.688]         {
[16:17:47.688]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:47.688]                 ...future.oldOptions$nwarnings <- NULL
[16:17:47.688]             }
[16:17:47.688]             base::options(...future.oldOptions)
[16:17:47.688]             if (.Platform$OS.type == "windows") {
[16:17:47.688]                 old_names <- names(...future.oldEnvVars)
[16:17:47.688]                 envs <- base::Sys.getenv()
[16:17:47.688]                 names <- names(envs)
[16:17:47.688]                 common <- intersect(names, old_names)
[16:17:47.688]                 added <- setdiff(names, old_names)
[16:17:47.688]                 removed <- setdiff(old_names, names)
[16:17:47.688]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:47.688]                   envs[common]]
[16:17:47.688]                 NAMES <- toupper(changed)
[16:17:47.688]                 args <- list()
[16:17:47.688]                 for (kk in seq_along(NAMES)) {
[16:17:47.688]                   name <- changed[[kk]]
[16:17:47.688]                   NAME <- NAMES[[kk]]
[16:17:47.688]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.688]                     next
[16:17:47.688]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.688]                 }
[16:17:47.688]                 NAMES <- toupper(added)
[16:17:47.688]                 for (kk in seq_along(NAMES)) {
[16:17:47.688]                   name <- added[[kk]]
[16:17:47.688]                   NAME <- NAMES[[kk]]
[16:17:47.688]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.688]                     next
[16:17:47.688]                   args[[name]] <- ""
[16:17:47.688]                 }
[16:17:47.688]                 NAMES <- toupper(removed)
[16:17:47.688]                 for (kk in seq_along(NAMES)) {
[16:17:47.688]                   name <- removed[[kk]]
[16:17:47.688]                   NAME <- NAMES[[kk]]
[16:17:47.688]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.688]                     next
[16:17:47.688]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.688]                 }
[16:17:47.688]                 if (length(args) > 0) 
[16:17:47.688]                   base::do.call(base::Sys.setenv, args = args)
[16:17:47.688]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:47.688]             }
[16:17:47.688]             else {
[16:17:47.688]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:47.688]             }
[16:17:47.688]             {
[16:17:47.688]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:47.688]                   0L) {
[16:17:47.688]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:47.688]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:47.688]                   base::options(opts)
[16:17:47.688]                 }
[16:17:47.688]                 {
[16:17:47.688]                   {
[16:17:47.688]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:47.688]                     NULL
[16:17:47.688]                   }
[16:17:47.688]                   options(future.plan = NULL)
[16:17:47.688]                   if (is.na(NA_character_)) 
[16:17:47.688]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.688]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:47.688]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:47.688]                     .init = FALSE)
[16:17:47.688]                 }
[16:17:47.688]             }
[16:17:47.688]         }
[16:17:47.688]     })
[16:17:47.688]     if (TRUE) {
[16:17:47.688]         base::sink(type = "output", split = FALSE)
[16:17:47.688]         if (TRUE) {
[16:17:47.688]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:47.688]         }
[16:17:47.688]         else {
[16:17:47.688]             ...future.result["stdout"] <- base::list(NULL)
[16:17:47.688]         }
[16:17:47.688]         base::close(...future.stdout)
[16:17:47.688]         ...future.stdout <- NULL
[16:17:47.688]     }
[16:17:47.688]     ...future.result$conditions <- ...future.conditions
[16:17:47.688]     ...future.result$finished <- base::Sys.time()
[16:17:47.688]     ...future.result
[16:17:47.688] }
[16:17:47.690] assign_globals() ...
[16:17:47.690] List of 7
[16:17:47.690]  $ ...future.FUN            :function (x)  
[16:17:47.690]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:17:47.690]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:47.690]  $ future.call.arguments    : list()
[16:17:47.690]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.690]  $ ...future.elements_ii    :List of 1
[16:17:47.690]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:47.690]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:17:47.690]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.690]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:47.690]  $ ...future.seeds_ii       : NULL
[16:17:47.690]  $ ...future.globals.maxSize: NULL
[16:17:47.690]  - attr(*, "where")=List of 7
[16:17:47.690]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:47.690]   ..$ breaks                   :<environment: R_EmptyEnv> 
[16:17:47.690]   ..$ wool                     :<environment: R_EmptyEnv> 
[16:17:47.690]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:47.690]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:47.690]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:47.690]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:47.690]  - attr(*, "resolved")= logi FALSE
[16:17:47.690]  - attr(*, "total_size")= num 2320
[16:17:47.690]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.690]  - attr(*, "already-done")= logi TRUE
[16:17:47.698] - reassign environment for ‘...future.FUN’
[16:17:47.698] - copied ‘...future.FUN’ to environment
[16:17:47.698] - copied ‘breaks’ to environment
[16:17:47.698] - copied ‘wool’ to environment
[16:17:47.698] - copied ‘future.call.arguments’ to environment
[16:17:47.698] - copied ‘...future.elements_ii’ to environment
[16:17:47.698] - copied ‘...future.seeds_ii’ to environment
[16:17:47.698] - copied ‘...future.globals.maxSize’ to environment
[16:17:47.698] assign_globals() ... done
[16:17:47.699] requestCore(): workers = 2
[16:17:47.701] MulticoreFuture started
[16:17:47.701] - Launch lazy future ... done
[16:17:47.701] run() for ‘MulticoreFuture’ ... done
[16:17:47.701] Created future:
[16:17:47.702] plan(): Setting new future strategy stack:
[16:17:47.702] List of future strategies:
[16:17:47.702] 1. sequential:
[16:17:47.702]    - args: function (..., envir = parent.frame())
[16:17:47.702]    - tweaked: FALSE
[16:17:47.702]    - call: NULL
[16:17:47.703] plan(): nbrOfWorkers() = 1
[16:17:47.707] plan(): Setting new future strategy stack:
[16:17:47.707] List of future strategies:
[16:17:47.707] 1. multicore:
[16:17:47.707]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:47.707]    - tweaked: FALSE
[16:17:47.707]    - call: plan(strategy)
[16:17:47.713] plan(): nbrOfWorkers() = 2
[16:17:47.702] MulticoreFuture:
[16:17:47.702] Label: ‘future_by-1’
[16:17:47.702] Expression:
[16:17:47.702] {
[16:17:47.702]     do.call(function(...) {
[16:17:47.702]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.702]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.702]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.702]             on.exit(options(oopts), add = TRUE)
[16:17:47.702]         }
[16:17:47.702]         {
[16:17:47.702]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.702]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.702]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.702]             })
[16:17:47.702]         }
[16:17:47.702]     }, args = future.call.arguments)
[16:17:47.702] }
[16:17:47.702] Lazy evaluation: FALSE
[16:17:47.702] Asynchronous evaluation: TRUE
[16:17:47.702] Local evaluation: TRUE
[16:17:47.702] Environment: 0x55b5665356d8
[16:17:47.702] Capture standard output: TRUE
[16:17:47.702] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:47.702] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[16:17:47.702] Packages: 1 packages (‘stats’)
[16:17:47.702] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:47.702] Resolved: TRUE
[16:17:47.702] Value: <not collected>
[16:17:47.702] Conditions captured: <none>
[16:17:47.702] Early signaling: FALSE
[16:17:47.702] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:47.702] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:47.715] Chunk #1 of 2 ... DONE
[16:17:47.715] Chunk #2 of 2 ...
[16:17:47.715]  - Finding globals in 'X' for chunk #2 ...
[16:17:47.715] getGlobalsAndPackages() ...
[16:17:47.715] Searching for globals...
[16:17:47.716] 
[16:17:47.716] Searching for globals ... DONE
[16:17:47.716] - globals: [0] <none>
[16:17:47.716] getGlobalsAndPackages() ... DONE
[16:17:47.717]    + additional globals found: [n=0] 
[16:17:47.717]    + additional namespaces needed: [n=0] 
[16:17:47.717]  - Finding globals in 'X' for chunk #2 ... DONE
[16:17:47.717]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:47.717]  - seeds: <none>
[16:17:47.717]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.717] getGlobalsAndPackages() ...
[16:17:47.718] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.718] Resolving globals: FALSE
[16:17:47.718] Tweak future expression to call with '...' arguments ...
[16:17:47.718] {
[16:17:47.718]     do.call(function(...) {
[16:17:47.718]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.718]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.718]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.718]             on.exit(options(oopts), add = TRUE)
[16:17:47.718]         }
[16:17:47.718]         {
[16:17:47.718]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.718]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.718]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.718]             })
[16:17:47.718]         }
[16:17:47.718]     }, args = future.call.arguments)
[16:17:47.718] }
[16:17:47.718] Tweak future expression to call with '...' arguments ... DONE
[16:17:47.719] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.719] 
[16:17:47.719] getGlobalsAndPackages() ... DONE
[16:17:47.720] run() for ‘Future’ ...
[16:17:47.720] - state: ‘created’
[16:17:47.720] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:47.725] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:47.725] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:47.725]   - Field: ‘label’
[16:17:47.725]   - Field: ‘local’
[16:17:47.726]   - Field: ‘owner’
[16:17:47.726]   - Field: ‘envir’
[16:17:47.726]   - Field: ‘workers’
[16:17:47.726]   - Field: ‘packages’
[16:17:47.726]   - Field: ‘gc’
[16:17:47.726]   - Field: ‘job’
[16:17:47.729]   - Field: ‘conditions’
[16:17:47.730]   - Field: ‘expr’
[16:17:47.730]   - Field: ‘uuid’
[16:17:47.730]   - Field: ‘seed’
[16:17:47.730]   - Field: ‘version’
[16:17:47.731]   - Field: ‘result’
[16:17:47.731]   - Field: ‘asynchronous’
[16:17:47.731]   - Field: ‘calls’
[16:17:47.731]   - Field: ‘globals’
[16:17:47.732]   - Field: ‘stdout’
[16:17:47.732]   - Field: ‘earlySignal’
[16:17:47.732]   - Field: ‘lazy’
[16:17:47.732]   - Field: ‘state’
[16:17:47.733] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:47.733] - Launch lazy future ...
[16:17:47.734] Packages needed by the future expression (n = 1): ‘stats’
[16:17:47.734] Packages needed by future strategies (n = 0): <none>
[16:17:47.735] {
[16:17:47.735]     {
[16:17:47.735]         {
[16:17:47.735]             ...future.startTime <- base::Sys.time()
[16:17:47.735]             {
[16:17:47.735]                 {
[16:17:47.735]                   {
[16:17:47.735]                     {
[16:17:47.735]                       {
[16:17:47.735]                         base::local({
[16:17:47.735]                           has_future <- base::requireNamespace("future", 
[16:17:47.735]                             quietly = TRUE)
[16:17:47.735]                           if (has_future) {
[16:17:47.735]                             ns <- base::getNamespace("future")
[16:17:47.735]                             version <- ns[[".package"]][["version"]]
[16:17:47.735]                             if (is.null(version)) 
[16:17:47.735]                               version <- utils::packageVersion("future")
[16:17:47.735]                           }
[16:17:47.735]                           else {
[16:17:47.735]                             version <- NULL
[16:17:47.735]                           }
[16:17:47.735]                           if (!has_future || version < "1.8.0") {
[16:17:47.735]                             info <- base::c(r_version = base::gsub("R version ", 
[16:17:47.735]                               "", base::R.version$version.string), 
[16:17:47.735]                               platform = base::sprintf("%s (%s-bit)", 
[16:17:47.735]                                 base::R.version$platform, 8 * 
[16:17:47.735]                                   base::.Machine$sizeof.pointer), 
[16:17:47.735]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:47.735]                                 "release", "version")], collapse = " "), 
[16:17:47.735]                               hostname = base::Sys.info()[["nodename"]])
[16:17:47.735]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:17:47.735]                               info)
[16:17:47.735]                             info <- base::paste(info, collapse = "; ")
[16:17:47.735]                             if (!has_future) {
[16:17:47.735]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:47.735]                                 info)
[16:17:47.735]                             }
[16:17:47.735]                             else {
[16:17:47.735]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:47.735]                                 info, version)
[16:17:47.735]                             }
[16:17:47.735]                             base::stop(msg)
[16:17:47.735]                           }
[16:17:47.735]                         })
[16:17:47.735]                       }
[16:17:47.735]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:47.735]                       base::options(mc.cores = 1L)
[16:17:47.735]                     }
[16:17:47.735]                     base::local({
[16:17:47.735]                       for (pkg in "stats") {
[16:17:47.735]                         base::loadNamespace(pkg)
[16:17:47.735]                         base::library(pkg, character.only = TRUE)
[16:17:47.735]                       }
[16:17:47.735]                     })
[16:17:47.735]                   }
[16:17:47.735]                   ...future.strategy.old <- future::plan("list")
[16:17:47.735]                   options(future.plan = NULL)
[16:17:47.735]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.735]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:47.735]                 }
[16:17:47.735]                 ...future.workdir <- getwd()
[16:17:47.735]             }
[16:17:47.735]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:47.735]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:47.735]         }
[16:17:47.735]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:47.735]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:47.735]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:47.735]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:47.735]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:47.735]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:47.735]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:47.735]             base::names(...future.oldOptions))
[16:17:47.735]     }
[16:17:47.735]     if (FALSE) {
[16:17:47.735]     }
[16:17:47.735]     else {
[16:17:47.735]         if (TRUE) {
[16:17:47.735]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:47.735]                 open = "w")
[16:17:47.735]         }
[16:17:47.735]         else {
[16:17:47.735]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:47.735]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:47.735]         }
[16:17:47.735]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:47.735]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:47.735]             base::sink(type = "output", split = FALSE)
[16:17:47.735]             base::close(...future.stdout)
[16:17:47.735]         }, add = TRUE)
[16:17:47.735]     }
[16:17:47.735]     ...future.frame <- base::sys.nframe()
[16:17:47.735]     ...future.conditions <- base::list()
[16:17:47.735]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:47.735]     if (FALSE) {
[16:17:47.735]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:47.735]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:47.735]     }
[16:17:47.735]     ...future.result <- base::tryCatch({
[16:17:47.735]         base::withCallingHandlers({
[16:17:47.735]             ...future.value <- base::withVisible(base::local({
[16:17:47.735]                 withCallingHandlers({
[16:17:47.735]                   {
[16:17:47.735]                     do.call(function(...) {
[16:17:47.735]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.735]                       if (!identical(...future.globals.maxSize.org, 
[16:17:47.735]                         ...future.globals.maxSize)) {
[16:17:47.735]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.735]                         on.exit(options(oopts), add = TRUE)
[16:17:47.735]                       }
[16:17:47.735]                       {
[16:17:47.735]                         lapply(seq_along(...future.elements_ii), 
[16:17:47.735]                           FUN = function(jj) {
[16:17:47.735]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.735]                             ...future.FUN(...future.X_jj, ...)
[16:17:47.735]                           })
[16:17:47.735]                       }
[16:17:47.735]                     }, args = future.call.arguments)
[16:17:47.735]                   }
[16:17:47.735]                 }, immediateCondition = function(cond) {
[16:17:47.735]                   save_rds <- function (object, pathname, ...) 
[16:17:47.735]                   {
[16:17:47.735]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:47.735]                     if (file_test("-f", pathname_tmp)) {
[16:17:47.735]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.735]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:47.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.735]                         fi_tmp[["mtime"]])
[16:17:47.735]                     }
[16:17:47.735]                     tryCatch({
[16:17:47.735]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:47.735]                     }, error = function(ex) {
[16:17:47.735]                       msg <- conditionMessage(ex)
[16:17:47.735]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.735]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:47.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.735]                         fi_tmp[["mtime"]], msg)
[16:17:47.735]                       ex$message <- msg
[16:17:47.735]                       stop(ex)
[16:17:47.735]                     })
[16:17:47.735]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:47.735]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:47.735]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:47.735]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.735]                       fi <- file.info(pathname)
[16:17:47.735]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:47.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.735]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:47.735]                         fi[["size"]], fi[["mtime"]])
[16:17:47.735]                       stop(msg)
[16:17:47.735]                     }
[16:17:47.735]                     invisible(pathname)
[16:17:47.735]                   }
[16:17:47.735]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:47.735]                     rootPath = tempdir()) 
[16:17:47.735]                   {
[16:17:47.735]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:47.735]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:47.735]                       tmpdir = path, fileext = ".rds")
[16:17:47.735]                     save_rds(obj, file)
[16:17:47.735]                   }
[16:17:47.735]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1cUuyG/.future/immediateConditions")
[16:17:47.735]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.735]                   {
[16:17:47.735]                     inherits <- base::inherits
[16:17:47.735]                     invokeRestart <- base::invokeRestart
[16:17:47.735]                     is.null <- base::is.null
[16:17:47.735]                     muffled <- FALSE
[16:17:47.735]                     if (inherits(cond, "message")) {
[16:17:47.735]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:47.735]                       if (muffled) 
[16:17:47.735]                         invokeRestart("muffleMessage")
[16:17:47.735]                     }
[16:17:47.735]                     else if (inherits(cond, "warning")) {
[16:17:47.735]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:47.735]                       if (muffled) 
[16:17:47.735]                         invokeRestart("muffleWarning")
[16:17:47.735]                     }
[16:17:47.735]                     else if (inherits(cond, "condition")) {
[16:17:47.735]                       if (!is.null(pattern)) {
[16:17:47.735]                         computeRestarts <- base::computeRestarts
[16:17:47.735]                         grepl <- base::grepl
[16:17:47.735]                         restarts <- computeRestarts(cond)
[16:17:47.735]                         for (restart in restarts) {
[16:17:47.735]                           name <- restart$name
[16:17:47.735]                           if (is.null(name)) 
[16:17:47.735]                             next
[16:17:47.735]                           if (!grepl(pattern, name)) 
[16:17:47.735]                             next
[16:17:47.735]                           invokeRestart(restart)
[16:17:47.735]                           muffled <- TRUE
[16:17:47.735]                           break
[16:17:47.735]                         }
[16:17:47.735]                       }
[16:17:47.735]                     }
[16:17:47.735]                     invisible(muffled)
[16:17:47.735]                   }
[16:17:47.735]                   muffleCondition(cond)
[16:17:47.735]                 })
[16:17:47.735]             }))
[16:17:47.735]             future::FutureResult(value = ...future.value$value, 
[16:17:47.735]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.735]                   ...future.rng), globalenv = if (FALSE) 
[16:17:47.735]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:47.735]                     ...future.globalenv.names))
[16:17:47.735]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:47.735]         }, condition = base::local({
[16:17:47.735]             c <- base::c
[16:17:47.735]             inherits <- base::inherits
[16:17:47.735]             invokeRestart <- base::invokeRestart
[16:17:47.735]             length <- base::length
[16:17:47.735]             list <- base::list
[16:17:47.735]             seq.int <- base::seq.int
[16:17:47.735]             signalCondition <- base::signalCondition
[16:17:47.735]             sys.calls <- base::sys.calls
[16:17:47.735]             `[[` <- base::`[[`
[16:17:47.735]             `+` <- base::`+`
[16:17:47.735]             `<<-` <- base::`<<-`
[16:17:47.735]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:47.735]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:47.735]                   3L)]
[16:17:47.735]             }
[16:17:47.735]             function(cond) {
[16:17:47.735]                 is_error <- inherits(cond, "error")
[16:17:47.735]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:47.735]                   NULL)
[16:17:47.735]                 if (is_error) {
[16:17:47.735]                   sessionInformation <- function() {
[16:17:47.735]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:47.735]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:47.735]                       search = base::search(), system = base::Sys.info())
[16:17:47.735]                   }
[16:17:47.735]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.735]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:47.735]                     cond$call), session = sessionInformation(), 
[16:17:47.735]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:47.735]                   signalCondition(cond)
[16:17:47.735]                 }
[16:17:47.735]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:47.735]                 "immediateCondition"))) {
[16:17:47.735]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:47.735]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.735]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:47.735]                   if (TRUE && !signal) {
[16:17:47.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.735]                     {
[16:17:47.735]                       inherits <- base::inherits
[16:17:47.735]                       invokeRestart <- base::invokeRestart
[16:17:47.735]                       is.null <- base::is.null
[16:17:47.735]                       muffled <- FALSE
[16:17:47.735]                       if (inherits(cond, "message")) {
[16:17:47.735]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.735]                         if (muffled) 
[16:17:47.735]                           invokeRestart("muffleMessage")
[16:17:47.735]                       }
[16:17:47.735]                       else if (inherits(cond, "warning")) {
[16:17:47.735]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.735]                         if (muffled) 
[16:17:47.735]                           invokeRestart("muffleWarning")
[16:17:47.735]                       }
[16:17:47.735]                       else if (inherits(cond, "condition")) {
[16:17:47.735]                         if (!is.null(pattern)) {
[16:17:47.735]                           computeRestarts <- base::computeRestarts
[16:17:47.735]                           grepl <- base::grepl
[16:17:47.735]                           restarts <- computeRestarts(cond)
[16:17:47.735]                           for (restart in restarts) {
[16:17:47.735]                             name <- restart$name
[16:17:47.735]                             if (is.null(name)) 
[16:17:47.735]                               next
[16:17:47.735]                             if (!grepl(pattern, name)) 
[16:17:47.735]                               next
[16:17:47.735]                             invokeRestart(restart)
[16:17:47.735]                             muffled <- TRUE
[16:17:47.735]                             break
[16:17:47.735]                           }
[16:17:47.735]                         }
[16:17:47.735]                       }
[16:17:47.735]                       invisible(muffled)
[16:17:47.735]                     }
[16:17:47.735]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.735]                   }
[16:17:47.735]                 }
[16:17:47.735]                 else {
[16:17:47.735]                   if (TRUE) {
[16:17:47.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.735]                     {
[16:17:47.735]                       inherits <- base::inherits
[16:17:47.735]                       invokeRestart <- base::invokeRestart
[16:17:47.735]                       is.null <- base::is.null
[16:17:47.735]                       muffled <- FALSE
[16:17:47.735]                       if (inherits(cond, "message")) {
[16:17:47.735]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.735]                         if (muffled) 
[16:17:47.735]                           invokeRestart("muffleMessage")
[16:17:47.735]                       }
[16:17:47.735]                       else if (inherits(cond, "warning")) {
[16:17:47.735]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.735]                         if (muffled) 
[16:17:47.735]                           invokeRestart("muffleWarning")
[16:17:47.735]                       }
[16:17:47.735]                       else if (inherits(cond, "condition")) {
[16:17:47.735]                         if (!is.null(pattern)) {
[16:17:47.735]                           computeRestarts <- base::computeRestarts
[16:17:47.735]                           grepl <- base::grepl
[16:17:47.735]                           restarts <- computeRestarts(cond)
[16:17:47.735]                           for (restart in restarts) {
[16:17:47.735]                             name <- restart$name
[16:17:47.735]                             if (is.null(name)) 
[16:17:47.735]                               next
[16:17:47.735]                             if (!grepl(pattern, name)) 
[16:17:47.735]                               next
[16:17:47.735]                             invokeRestart(restart)
[16:17:47.735]                             muffled <- TRUE
[16:17:47.735]                             break
[16:17:47.735]                           }
[16:17:47.735]                         }
[16:17:47.735]                       }
[16:17:47.735]                       invisible(muffled)
[16:17:47.735]                     }
[16:17:47.735]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.735]                   }
[16:17:47.735]                 }
[16:17:47.735]             }
[16:17:47.735]         }))
[16:17:47.735]     }, error = function(ex) {
[16:17:47.735]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:47.735]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.735]                 ...future.rng), started = ...future.startTime, 
[16:17:47.735]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:47.735]             version = "1.8"), class = "FutureResult")
[16:17:47.735]     }, finally = {
[16:17:47.735]         if (!identical(...future.workdir, getwd())) 
[16:17:47.735]             setwd(...future.workdir)
[16:17:47.735]         {
[16:17:47.735]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:47.735]                 ...future.oldOptions$nwarnings <- NULL
[16:17:47.735]             }
[16:17:47.735]             base::options(...future.oldOptions)
[16:17:47.735]             if (.Platform$OS.type == "windows") {
[16:17:47.735]                 old_names <- names(...future.oldEnvVars)
[16:17:47.735]                 envs <- base::Sys.getenv()
[16:17:47.735]                 names <- names(envs)
[16:17:47.735]                 common <- intersect(names, old_names)
[16:17:47.735]                 added <- setdiff(names, old_names)
[16:17:47.735]                 removed <- setdiff(old_names, names)
[16:17:47.735]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:47.735]                   envs[common]]
[16:17:47.735]                 NAMES <- toupper(changed)
[16:17:47.735]                 args <- list()
[16:17:47.735]                 for (kk in seq_along(NAMES)) {
[16:17:47.735]                   name <- changed[[kk]]
[16:17:47.735]                   NAME <- NAMES[[kk]]
[16:17:47.735]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.735]                     next
[16:17:47.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.735]                 }
[16:17:47.735]                 NAMES <- toupper(added)
[16:17:47.735]                 for (kk in seq_along(NAMES)) {
[16:17:47.735]                   name <- added[[kk]]
[16:17:47.735]                   NAME <- NAMES[[kk]]
[16:17:47.735]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.735]                     next
[16:17:47.735]                   args[[name]] <- ""
[16:17:47.735]                 }
[16:17:47.735]                 NAMES <- toupper(removed)
[16:17:47.735]                 for (kk in seq_along(NAMES)) {
[16:17:47.735]                   name <- removed[[kk]]
[16:17:47.735]                   NAME <- NAMES[[kk]]
[16:17:47.735]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.735]                     next
[16:17:47.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.735]                 }
[16:17:47.735]                 if (length(args) > 0) 
[16:17:47.735]                   base::do.call(base::Sys.setenv, args = args)
[16:17:47.735]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:47.735]             }
[16:17:47.735]             else {
[16:17:47.735]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:47.735]             }
[16:17:47.735]             {
[16:17:47.735]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:47.735]                   0L) {
[16:17:47.735]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:47.735]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:47.735]                   base::options(opts)
[16:17:47.735]                 }
[16:17:47.735]                 {
[16:17:47.735]                   {
[16:17:47.735]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:47.735]                     NULL
[16:17:47.735]                   }
[16:17:47.735]                   options(future.plan = NULL)
[16:17:47.735]                   if (is.na(NA_character_)) 
[16:17:47.735]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.735]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:47.735]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:47.735]                     .init = FALSE)
[16:17:47.735]                 }
[16:17:47.735]             }
[16:17:47.735]         }
[16:17:47.735]     })
[16:17:47.735]     if (TRUE) {
[16:17:47.735]         base::sink(type = "output", split = FALSE)
[16:17:47.735]         if (TRUE) {
[16:17:47.735]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:47.735]         }
[16:17:47.735]         else {
[16:17:47.735]             ...future.result["stdout"] <- base::list(NULL)
[16:17:47.735]         }
[16:17:47.735]         base::close(...future.stdout)
[16:17:47.735]         ...future.stdout <- NULL
[16:17:47.735]     }
[16:17:47.735]     ...future.result$conditions <- ...future.conditions
[16:17:47.735]     ...future.result$finished <- base::Sys.time()
[16:17:47.735]     ...future.result
[16:17:47.735] }
[16:17:47.738] assign_globals() ...
[16:17:47.738] List of 7
[16:17:47.738]  $ ...future.FUN            :function (x)  
[16:17:47.738]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:17:47.738]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:47.738]  $ future.call.arguments    : list()
[16:17:47.738]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.738]  $ ...future.elements_ii    :List of 2
[16:17:47.738]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:47.738]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:17:47.738]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.738]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:17:47.738]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:47.738]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:17:47.738]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.738]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:17:47.738]  $ ...future.seeds_ii       : NULL
[16:17:47.738]  $ ...future.globals.maxSize: NULL
[16:17:47.738]  - attr(*, "where")=List of 7
[16:17:47.738]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:47.738]   ..$ breaks                   :<environment: R_EmptyEnv> 
[16:17:47.738]   ..$ wool                     :<environment: R_EmptyEnv> 
[16:17:47.738]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:47.738]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:47.738]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:47.738]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:47.738]  - attr(*, "resolved")= logi FALSE
[16:17:47.738]  - attr(*, "total_size")= num 2320
[16:17:47.738]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.738]  - attr(*, "already-done")= logi TRUE
[16:17:47.750] - reassign environment for ‘...future.FUN’
[16:17:47.750] - copied ‘...future.FUN’ to environment
[16:17:47.750] - copied ‘breaks’ to environment
[16:17:47.750] - copied ‘wool’ to environment
[16:17:47.751] - copied ‘future.call.arguments’ to environment
[16:17:47.751] - copied ‘...future.elements_ii’ to environment
[16:17:47.751] - copied ‘...future.seeds_ii’ to environment
[16:17:47.751] - copied ‘...future.globals.maxSize’ to environment
[16:17:47.751] assign_globals() ... done
[16:17:47.751] requestCore(): workers = 2
[16:17:47.753] MulticoreFuture started
[16:17:47.754] - Launch lazy future ... done
[16:17:47.754] run() for ‘MulticoreFuture’ ... done
[16:17:47.754] Created future:
[16:17:47.755] plan(): Setting new future strategy stack:
[16:17:47.755] List of future strategies:
[16:17:47.755] 1. sequential:
[16:17:47.755]    - args: function (..., envir = parent.frame())
[16:17:47.755]    - tweaked: FALSE
[16:17:47.755]    - call: NULL
[16:17:47.756] plan(): nbrOfWorkers() = 1
[16:17:47.761] plan(): Setting new future strategy stack:
[16:17:47.761] List of future strategies:
[16:17:47.761] 1. multicore:
[16:17:47.761]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:47.761]    - tweaked: FALSE
[16:17:47.761]    - call: plan(strategy)
[16:17:47.754] MulticoreFuture:
[16:17:47.754] Label: ‘future_by-2’
[16:17:47.754] Expression:
[16:17:47.754] {
[16:17:47.754]     do.call(function(...) {
[16:17:47.754]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.754]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.754]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.754]             on.exit(options(oopts), add = TRUE)
[16:17:47.754]         }
[16:17:47.754]         {
[16:17:47.754]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.754]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.754]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.754]             })
[16:17:47.754]         }
[16:17:47.754]     }, args = future.call.arguments)
[16:17:47.754] }
[16:17:47.754] Lazy evaluation: FALSE
[16:17:47.754] Asynchronous evaluation: TRUE
[16:17:47.754] Local evaluation: TRUE
[16:17:47.754] Environment: 0x55b5665356d8
[16:17:47.754] Capture standard output: TRUE
[16:17:47.754] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:47.754] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[16:17:47.754] Packages: 1 packages (‘stats’)
[16:17:47.754] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:47.754] Resolved: FALSE
[16:17:47.754] Value: <not collected>
[16:17:47.754] Conditions captured: <none>
[16:17:47.754] Early signaling: FALSE
[16:17:47.754] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:47.754] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:47.768] Chunk #2 of 2 ... DONE
[16:17:47.768] Launching 2 futures (chunks) ... DONE
[16:17:47.768] Resolving 2 futures (chunks) ...
[16:17:47.768] resolve() on list ...
[16:17:47.768]  recursive: 0
[16:17:47.769]  length: 2
[16:17:47.769] 
[16:17:47.769] Future #1
[16:17:47.769] result() for MulticoreFuture ...
[16:17:47.771] result() for MulticoreFuture ...
[16:17:47.771] result() for MulticoreFuture ... done
[16:17:47.771] result() for MulticoreFuture ... done
[16:17:47.771] result() for MulticoreFuture ...
[16:17:47.771] plan(): nbrOfWorkers() = 2
[16:17:47.771] result() for MulticoreFuture ... done
[16:17:47.772] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:17:47.776] - nx: 2
[16:17:47.776] - relay: TRUE
[16:17:47.777] - stdout: TRUE
[16:17:47.777] - signal: TRUE
[16:17:47.777] - resignal: FALSE
[16:17:47.777] - force: TRUE
[16:17:47.777] - relayed: [n=2] FALSE, FALSE
[16:17:47.777] - queued futures: [n=2] FALSE, FALSE
[16:17:47.778]  - until=1
[16:17:47.778]  - relaying element #1
[16:17:47.778] result() for MulticoreFuture ...
[16:17:47.778] result() for MulticoreFuture ... done
[16:17:47.778] result() for MulticoreFuture ...
[16:17:47.779] result() for MulticoreFuture ... done
[16:17:47.779] result() for MulticoreFuture ...
[16:17:47.779] result() for MulticoreFuture ... done
[16:17:47.779] result() for MulticoreFuture ...
[16:17:47.780] result() for MulticoreFuture ... done
[16:17:47.780] - relayed: [n=2] TRUE, FALSE
[16:17:47.780] - queued futures: [n=2] TRUE, FALSE
[16:17:47.781] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:17:47.781]  length: 1 (resolved future 1)
[16:17:47.781] Future #2
[16:17:47.781] result() for MulticoreFuture ...
[16:17:47.783] result() for MulticoreFuture ...
[16:17:47.783] result() for MulticoreFuture ... done
[16:17:47.783] result() for MulticoreFuture ... done
[16:17:47.784] result() for MulticoreFuture ...
[16:17:47.784] result() for MulticoreFuture ... done
[16:17:47.784] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:17:47.784] - nx: 2
[16:17:47.784] - relay: TRUE
[16:17:47.785] - stdout: TRUE
[16:17:47.785] - signal: TRUE
[16:17:47.785] - resignal: FALSE
[16:17:47.785] - force: TRUE
[16:17:47.785] - relayed: [n=2] TRUE, FALSE
[16:17:47.785] - queued futures: [n=2] TRUE, FALSE
[16:17:47.785]  - until=2
[16:17:47.786]  - relaying element #2
[16:17:47.786] result() for MulticoreFuture ...
[16:17:47.786] result() for MulticoreFuture ... done
[16:17:47.786] result() for MulticoreFuture ...
[16:17:47.786] result() for MulticoreFuture ... done
[16:17:47.786] result() for MulticoreFuture ...
[16:17:47.786] result() for MulticoreFuture ... done
[16:17:47.787] result() for MulticoreFuture ...
[16:17:47.787] result() for MulticoreFuture ... done
[16:17:47.787] - relayed: [n=2] TRUE, TRUE
[16:17:47.787] - queued futures: [n=2] TRUE, TRUE
[16:17:47.787] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:17:47.787]  length: 0 (resolved future 2)
[16:17:47.788] Relaying remaining futures
[16:17:47.788] signalConditionsASAP(NULL, pos=0) ...
[16:17:47.788] - nx: 2
[16:17:47.788] - relay: TRUE
[16:17:47.788] - stdout: TRUE
[16:17:47.788] - signal: TRUE
[16:17:47.788] - resignal: FALSE
[16:17:47.788] - force: TRUE
[16:17:47.788] - relayed: [n=2] TRUE, TRUE
[16:17:47.788] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:47.789] - relayed: [n=2] TRUE, TRUE
[16:17:47.789] - queued futures: [n=2] TRUE, TRUE
[16:17:47.789] signalConditionsASAP(NULL, pos=0) ... done
[16:17:47.789] resolve() on list ... DONE
[16:17:47.789] result() for MulticoreFuture ...
[16:17:47.789] result() for MulticoreFuture ... done
[16:17:47.789] result() for MulticoreFuture ...
[16:17:47.789] result() for MulticoreFuture ... done
[16:17:47.789] result() for MulticoreFuture ...
[16:17:47.790] result() for MulticoreFuture ... done
[16:17:47.790] result() for MulticoreFuture ...
[16:17:47.790] result() for MulticoreFuture ... done
[16:17:47.790]  - Number of value chunks collected: 2
[16:17:47.790] Resolving 2 futures (chunks) ... DONE
[16:17:47.790] Reducing values from 2 chunks ...
[16:17:47.790]  - Number of values collected after concatenation: 3
[16:17:47.790]  - Number of values expected: 3
[16:17:47.790] Reducing values from 2 chunks ... DONE
[16:17:47.791] future_lapply() ... DONE
[16:17:47.791] future_by_internal() ... DONE
[16:17:47.791] future_by_internal() ...
[16:17:47.792] future_lapply() ...
[16:17:47.796] Number of chunks: 2
[16:17:47.796] getGlobalsAndPackagesXApply() ...
[16:17:47.796]  - future.globals: TRUE
[16:17:47.797] getGlobalsAndPackages() ...
[16:17:47.797] Searching for globals...
[16:17:47.798] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:47.798] Searching for globals ... DONE
[16:17:47.798] Resolving globals: FALSE
[16:17:47.798] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:47.799] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:47.799] - globals: [1] ‘FUN’
[16:17:47.799] 
[16:17:47.799] getGlobalsAndPackages() ... DONE
[16:17:47.799]  - globals found/used: [n=1] ‘FUN’
[16:17:47.799]  - needed namespaces: [n=0] 
[16:17:47.799] Finding globals ... DONE
[16:17:47.800]  - use_args: TRUE
[16:17:47.800]  - Getting '...' globals ...
[16:17:47.800] resolve() on list ...
[16:17:47.800]  recursive: 0
[16:17:47.800]  length: 1
[16:17:47.800]  elements: ‘...’
[16:17:47.800]  length: 0 (resolved future 1)
[16:17:47.801] resolve() on list ... DONE
[16:17:47.801]    - '...' content: [n=0] 
[16:17:47.801] List of 1
[16:17:47.801]  $ ...: list()
[16:17:47.801]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.801]  - attr(*, "where")=List of 1
[16:17:47.801]   ..$ ...:<environment: 0x55b566005a18> 
[16:17:47.801]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.801]  - attr(*, "resolved")= logi TRUE
[16:17:47.801]  - attr(*, "total_size")= num NA
[16:17:47.838]  - Getting '...' globals ... DONE
[16:17:47.839] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:47.839] List of 2
[16:17:47.839]  $ ...future.FUN:function (object, ...)  
[16:17:47.839]  $ ...          : list()
[16:17:47.839]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.839]  - attr(*, "where")=List of 2
[16:17:47.839]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:47.839]   ..$ ...          :<environment: 0x55b566005a18> 
[16:17:47.839]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.839]  - attr(*, "resolved")= logi FALSE
[16:17:47.839]  - attr(*, "total_size")= num 1240
[16:17:47.841] Packages to be attached in all futures: [n=0] 
[16:17:47.841] getGlobalsAndPackagesXApply() ... DONE
[16:17:47.842] Number of futures (= number of chunks): 2
[16:17:47.842] Launching 2 futures (chunks) ...
[16:17:47.842] Chunk #1 of 2 ...
[16:17:47.842]  - Finding globals in 'X' for chunk #1 ...
[16:17:47.842] getGlobalsAndPackages() ...
[16:17:47.842] Searching for globals...
[16:17:47.842] 
[16:17:47.843] Searching for globals ... DONE
[16:17:47.843] - globals: [0] <none>
[16:17:47.843] getGlobalsAndPackages() ... DONE
[16:17:47.843]    + additional globals found: [n=0] 
[16:17:47.843]    + additional namespaces needed: [n=0] 
[16:17:47.843]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:47.843]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:47.843]  - seeds: <none>
[16:17:47.843]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.843] getGlobalsAndPackages() ...
[16:17:47.843] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.844] Resolving globals: FALSE
[16:17:47.844] Tweak future expression to call with '...' arguments ...
[16:17:47.844] {
[16:17:47.844]     do.call(function(...) {
[16:17:47.844]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.844]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.844]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.844]             on.exit(options(oopts), add = TRUE)
[16:17:47.844]         }
[16:17:47.844]         {
[16:17:47.844]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.844]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.844]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.844]             })
[16:17:47.844]         }
[16:17:47.844]     }, args = future.call.arguments)
[16:17:47.844] }
[16:17:47.844] Tweak future expression to call with '...' arguments ... DONE
[16:17:47.844] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.845] 
[16:17:47.845] getGlobalsAndPackages() ... DONE
[16:17:47.845] run() for ‘Future’ ...
[16:17:47.845] - state: ‘created’
[16:17:47.845] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:47.849] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:47.849] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:47.849]   - Field: ‘label’
[16:17:47.849]   - Field: ‘local’
[16:17:47.849]   - Field: ‘owner’
[16:17:47.849]   - Field: ‘envir’
[16:17:47.850]   - Field: ‘workers’
[16:17:47.850]   - Field: ‘packages’
[16:17:47.850]   - Field: ‘gc’
[16:17:47.850]   - Field: ‘job’
[16:17:47.850]   - Field: ‘conditions’
[16:17:47.850]   - Field: ‘expr’
[16:17:47.850]   - Field: ‘uuid’
[16:17:47.850]   - Field: ‘seed’
[16:17:47.850]   - Field: ‘version’
[16:17:47.850]   - Field: ‘result’
[16:17:47.850]   - Field: ‘asynchronous’
[16:17:47.851]   - Field: ‘calls’
[16:17:47.851]   - Field: ‘globals’
[16:17:47.851]   - Field: ‘stdout’
[16:17:47.851]   - Field: ‘earlySignal’
[16:17:47.851]   - Field: ‘lazy’
[16:17:47.851]   - Field: ‘state’
[16:17:47.851] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:47.851] - Launch lazy future ...
[16:17:47.851] Packages needed by the future expression (n = 0): <none>
[16:17:47.852] Packages needed by future strategies (n = 0): <none>
[16:17:47.852] {
[16:17:47.852]     {
[16:17:47.852]         {
[16:17:47.852]             ...future.startTime <- base::Sys.time()
[16:17:47.852]             {
[16:17:47.852]                 {
[16:17:47.852]                   {
[16:17:47.852]                     {
[16:17:47.852]                       base::local({
[16:17:47.852]                         has_future <- base::requireNamespace("future", 
[16:17:47.852]                           quietly = TRUE)
[16:17:47.852]                         if (has_future) {
[16:17:47.852]                           ns <- base::getNamespace("future")
[16:17:47.852]                           version <- ns[[".package"]][["version"]]
[16:17:47.852]                           if (is.null(version)) 
[16:17:47.852]                             version <- utils::packageVersion("future")
[16:17:47.852]                         }
[16:17:47.852]                         else {
[16:17:47.852]                           version <- NULL
[16:17:47.852]                         }
[16:17:47.852]                         if (!has_future || version < "1.8.0") {
[16:17:47.852]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:47.852]                             "", base::R.version$version.string), 
[16:17:47.852]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:47.852]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:47.852]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:47.852]                               "release", "version")], collapse = " "), 
[16:17:47.852]                             hostname = base::Sys.info()[["nodename"]])
[16:17:47.852]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:47.852]                             info)
[16:17:47.852]                           info <- base::paste(info, collapse = "; ")
[16:17:47.852]                           if (!has_future) {
[16:17:47.852]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:47.852]                               info)
[16:17:47.852]                           }
[16:17:47.852]                           else {
[16:17:47.852]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:47.852]                               info, version)
[16:17:47.852]                           }
[16:17:47.852]                           base::stop(msg)
[16:17:47.852]                         }
[16:17:47.852]                       })
[16:17:47.852]                     }
[16:17:47.852]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:47.852]                     base::options(mc.cores = 1L)
[16:17:47.852]                   }
[16:17:47.852]                   ...future.strategy.old <- future::plan("list")
[16:17:47.852]                   options(future.plan = NULL)
[16:17:47.852]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.852]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:47.852]                 }
[16:17:47.852]                 ...future.workdir <- getwd()
[16:17:47.852]             }
[16:17:47.852]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:47.852]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:47.852]         }
[16:17:47.852]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:47.852]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:47.852]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:47.852]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:47.852]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:47.852]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:47.852]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:47.852]             base::names(...future.oldOptions))
[16:17:47.852]     }
[16:17:47.852]     if (FALSE) {
[16:17:47.852]     }
[16:17:47.852]     else {
[16:17:47.852]         if (TRUE) {
[16:17:47.852]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:47.852]                 open = "w")
[16:17:47.852]         }
[16:17:47.852]         else {
[16:17:47.852]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:47.852]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:47.852]         }
[16:17:47.852]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:47.852]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:47.852]             base::sink(type = "output", split = FALSE)
[16:17:47.852]             base::close(...future.stdout)
[16:17:47.852]         }, add = TRUE)
[16:17:47.852]     }
[16:17:47.852]     ...future.frame <- base::sys.nframe()
[16:17:47.852]     ...future.conditions <- base::list()
[16:17:47.852]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:47.852]     if (FALSE) {
[16:17:47.852]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:47.852]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:47.852]     }
[16:17:47.852]     ...future.result <- base::tryCatch({
[16:17:47.852]         base::withCallingHandlers({
[16:17:47.852]             ...future.value <- base::withVisible(base::local({
[16:17:47.852]                 withCallingHandlers({
[16:17:47.852]                   {
[16:17:47.852]                     do.call(function(...) {
[16:17:47.852]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.852]                       if (!identical(...future.globals.maxSize.org, 
[16:17:47.852]                         ...future.globals.maxSize)) {
[16:17:47.852]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.852]                         on.exit(options(oopts), add = TRUE)
[16:17:47.852]                       }
[16:17:47.852]                       {
[16:17:47.852]                         lapply(seq_along(...future.elements_ii), 
[16:17:47.852]                           FUN = function(jj) {
[16:17:47.852]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.852]                             ...future.FUN(...future.X_jj, ...)
[16:17:47.852]                           })
[16:17:47.852]                       }
[16:17:47.852]                     }, args = future.call.arguments)
[16:17:47.852]                   }
[16:17:47.852]                 }, immediateCondition = function(cond) {
[16:17:47.852]                   save_rds <- function (object, pathname, ...) 
[16:17:47.852]                   {
[16:17:47.852]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:47.852]                     if (file_test("-f", pathname_tmp)) {
[16:17:47.852]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.852]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:47.852]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.852]                         fi_tmp[["mtime"]])
[16:17:47.852]                     }
[16:17:47.852]                     tryCatch({
[16:17:47.852]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:47.852]                     }, error = function(ex) {
[16:17:47.852]                       msg <- conditionMessage(ex)
[16:17:47.852]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.852]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:47.852]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.852]                         fi_tmp[["mtime"]], msg)
[16:17:47.852]                       ex$message <- msg
[16:17:47.852]                       stop(ex)
[16:17:47.852]                     })
[16:17:47.852]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:47.852]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:47.852]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:47.852]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.852]                       fi <- file.info(pathname)
[16:17:47.852]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:47.852]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.852]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:47.852]                         fi[["size"]], fi[["mtime"]])
[16:17:47.852]                       stop(msg)
[16:17:47.852]                     }
[16:17:47.852]                     invisible(pathname)
[16:17:47.852]                   }
[16:17:47.852]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:47.852]                     rootPath = tempdir()) 
[16:17:47.852]                   {
[16:17:47.852]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:47.852]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:47.852]                       tmpdir = path, fileext = ".rds")
[16:17:47.852]                     save_rds(obj, file)
[16:17:47.852]                   }
[16:17:47.852]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1cUuyG/.future/immediateConditions")
[16:17:47.852]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.852]                   {
[16:17:47.852]                     inherits <- base::inherits
[16:17:47.852]                     invokeRestart <- base::invokeRestart
[16:17:47.852]                     is.null <- base::is.null
[16:17:47.852]                     muffled <- FALSE
[16:17:47.852]                     if (inherits(cond, "message")) {
[16:17:47.852]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:47.852]                       if (muffled) 
[16:17:47.852]                         invokeRestart("muffleMessage")
[16:17:47.852]                     }
[16:17:47.852]                     else if (inherits(cond, "warning")) {
[16:17:47.852]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:47.852]                       if (muffled) 
[16:17:47.852]                         invokeRestart("muffleWarning")
[16:17:47.852]                     }
[16:17:47.852]                     else if (inherits(cond, "condition")) {
[16:17:47.852]                       if (!is.null(pattern)) {
[16:17:47.852]                         computeRestarts <- base::computeRestarts
[16:17:47.852]                         grepl <- base::grepl
[16:17:47.852]                         restarts <- computeRestarts(cond)
[16:17:47.852]                         for (restart in restarts) {
[16:17:47.852]                           name <- restart$name
[16:17:47.852]                           if (is.null(name)) 
[16:17:47.852]                             next
[16:17:47.852]                           if (!grepl(pattern, name)) 
[16:17:47.852]                             next
[16:17:47.852]                           invokeRestart(restart)
[16:17:47.852]                           muffled <- TRUE
[16:17:47.852]                           break
[16:17:47.852]                         }
[16:17:47.852]                       }
[16:17:47.852]                     }
[16:17:47.852]                     invisible(muffled)
[16:17:47.852]                   }
[16:17:47.852]                   muffleCondition(cond)
[16:17:47.852]                 })
[16:17:47.852]             }))
[16:17:47.852]             future::FutureResult(value = ...future.value$value, 
[16:17:47.852]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.852]                   ...future.rng), globalenv = if (FALSE) 
[16:17:47.852]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:47.852]                     ...future.globalenv.names))
[16:17:47.852]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:47.852]         }, condition = base::local({
[16:17:47.852]             c <- base::c
[16:17:47.852]             inherits <- base::inherits
[16:17:47.852]             invokeRestart <- base::invokeRestart
[16:17:47.852]             length <- base::length
[16:17:47.852]             list <- base::list
[16:17:47.852]             seq.int <- base::seq.int
[16:17:47.852]             signalCondition <- base::signalCondition
[16:17:47.852]             sys.calls <- base::sys.calls
[16:17:47.852]             `[[` <- base::`[[`
[16:17:47.852]             `+` <- base::`+`
[16:17:47.852]             `<<-` <- base::`<<-`
[16:17:47.852]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:47.852]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:47.852]                   3L)]
[16:17:47.852]             }
[16:17:47.852]             function(cond) {
[16:17:47.852]                 is_error <- inherits(cond, "error")
[16:17:47.852]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:47.852]                   NULL)
[16:17:47.852]                 if (is_error) {
[16:17:47.852]                   sessionInformation <- function() {
[16:17:47.852]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:47.852]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:47.852]                       search = base::search(), system = base::Sys.info())
[16:17:47.852]                   }
[16:17:47.852]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.852]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:47.852]                     cond$call), session = sessionInformation(), 
[16:17:47.852]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:47.852]                   signalCondition(cond)
[16:17:47.852]                 }
[16:17:47.852]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:47.852]                 "immediateCondition"))) {
[16:17:47.852]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:47.852]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.852]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:47.852]                   if (TRUE && !signal) {
[16:17:47.852]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.852]                     {
[16:17:47.852]                       inherits <- base::inherits
[16:17:47.852]                       invokeRestart <- base::invokeRestart
[16:17:47.852]                       is.null <- base::is.null
[16:17:47.852]                       muffled <- FALSE
[16:17:47.852]                       if (inherits(cond, "message")) {
[16:17:47.852]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.852]                         if (muffled) 
[16:17:47.852]                           invokeRestart("muffleMessage")
[16:17:47.852]                       }
[16:17:47.852]                       else if (inherits(cond, "warning")) {
[16:17:47.852]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.852]                         if (muffled) 
[16:17:47.852]                           invokeRestart("muffleWarning")
[16:17:47.852]                       }
[16:17:47.852]                       else if (inherits(cond, "condition")) {
[16:17:47.852]                         if (!is.null(pattern)) {
[16:17:47.852]                           computeRestarts <- base::computeRestarts
[16:17:47.852]                           grepl <- base::grepl
[16:17:47.852]                           restarts <- computeRestarts(cond)
[16:17:47.852]                           for (restart in restarts) {
[16:17:47.852]                             name <- restart$name
[16:17:47.852]                             if (is.null(name)) 
[16:17:47.852]                               next
[16:17:47.852]                             if (!grepl(pattern, name)) 
[16:17:47.852]                               next
[16:17:47.852]                             invokeRestart(restart)
[16:17:47.852]                             muffled <- TRUE
[16:17:47.852]                             break
[16:17:47.852]                           }
[16:17:47.852]                         }
[16:17:47.852]                       }
[16:17:47.852]                       invisible(muffled)
[16:17:47.852]                     }
[16:17:47.852]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.852]                   }
[16:17:47.852]                 }
[16:17:47.852]                 else {
[16:17:47.852]                   if (TRUE) {
[16:17:47.852]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.852]                     {
[16:17:47.852]                       inherits <- base::inherits
[16:17:47.852]                       invokeRestart <- base::invokeRestart
[16:17:47.852]                       is.null <- base::is.null
[16:17:47.852]                       muffled <- FALSE
[16:17:47.852]                       if (inherits(cond, "message")) {
[16:17:47.852]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.852]                         if (muffled) 
[16:17:47.852]                           invokeRestart("muffleMessage")
[16:17:47.852]                       }
[16:17:47.852]                       else if (inherits(cond, "warning")) {
[16:17:47.852]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.852]                         if (muffled) 
[16:17:47.852]                           invokeRestart("muffleWarning")
[16:17:47.852]                       }
[16:17:47.852]                       else if (inherits(cond, "condition")) {
[16:17:47.852]                         if (!is.null(pattern)) {
[16:17:47.852]                           computeRestarts <- base::computeRestarts
[16:17:47.852]                           grepl <- base::grepl
[16:17:47.852]                           restarts <- computeRestarts(cond)
[16:17:47.852]                           for (restart in restarts) {
[16:17:47.852]                             name <- restart$name
[16:17:47.852]                             if (is.null(name)) 
[16:17:47.852]                               next
[16:17:47.852]                             if (!grepl(pattern, name)) 
[16:17:47.852]                               next
[16:17:47.852]                             invokeRestart(restart)
[16:17:47.852]                             muffled <- TRUE
[16:17:47.852]                             break
[16:17:47.852]                           }
[16:17:47.852]                         }
[16:17:47.852]                       }
[16:17:47.852]                       invisible(muffled)
[16:17:47.852]                     }
[16:17:47.852]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.852]                   }
[16:17:47.852]                 }
[16:17:47.852]             }
[16:17:47.852]         }))
[16:17:47.852]     }, error = function(ex) {
[16:17:47.852]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:47.852]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.852]                 ...future.rng), started = ...future.startTime, 
[16:17:47.852]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:47.852]             version = "1.8"), class = "FutureResult")
[16:17:47.852]     }, finally = {
[16:17:47.852]         if (!identical(...future.workdir, getwd())) 
[16:17:47.852]             setwd(...future.workdir)
[16:17:47.852]         {
[16:17:47.852]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:47.852]                 ...future.oldOptions$nwarnings <- NULL
[16:17:47.852]             }
[16:17:47.852]             base::options(...future.oldOptions)
[16:17:47.852]             if (.Platform$OS.type == "windows") {
[16:17:47.852]                 old_names <- names(...future.oldEnvVars)
[16:17:47.852]                 envs <- base::Sys.getenv()
[16:17:47.852]                 names <- names(envs)
[16:17:47.852]                 common <- intersect(names, old_names)
[16:17:47.852]                 added <- setdiff(names, old_names)
[16:17:47.852]                 removed <- setdiff(old_names, names)
[16:17:47.852]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:47.852]                   envs[common]]
[16:17:47.852]                 NAMES <- toupper(changed)
[16:17:47.852]                 args <- list()
[16:17:47.852]                 for (kk in seq_along(NAMES)) {
[16:17:47.852]                   name <- changed[[kk]]
[16:17:47.852]                   NAME <- NAMES[[kk]]
[16:17:47.852]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.852]                     next
[16:17:47.852]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.852]                 }
[16:17:47.852]                 NAMES <- toupper(added)
[16:17:47.852]                 for (kk in seq_along(NAMES)) {
[16:17:47.852]                   name <- added[[kk]]
[16:17:47.852]                   NAME <- NAMES[[kk]]
[16:17:47.852]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.852]                     next
[16:17:47.852]                   args[[name]] <- ""
[16:17:47.852]                 }
[16:17:47.852]                 NAMES <- toupper(removed)
[16:17:47.852]                 for (kk in seq_along(NAMES)) {
[16:17:47.852]                   name <- removed[[kk]]
[16:17:47.852]                   NAME <- NAMES[[kk]]
[16:17:47.852]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.852]                     next
[16:17:47.852]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.852]                 }
[16:17:47.852]                 if (length(args) > 0) 
[16:17:47.852]                   base::do.call(base::Sys.setenv, args = args)
[16:17:47.852]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:47.852]             }
[16:17:47.852]             else {
[16:17:47.852]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:47.852]             }
[16:17:47.852]             {
[16:17:47.852]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:47.852]                   0L) {
[16:17:47.852]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:47.852]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:47.852]                   base::options(opts)
[16:17:47.852]                 }
[16:17:47.852]                 {
[16:17:47.852]                   {
[16:17:47.852]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:47.852]                     NULL
[16:17:47.852]                   }
[16:17:47.852]                   options(future.plan = NULL)
[16:17:47.852]                   if (is.na(NA_character_)) 
[16:17:47.852]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.852]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:47.852]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:47.852]                     .init = FALSE)
[16:17:47.852]                 }
[16:17:47.852]             }
[16:17:47.852]         }
[16:17:47.852]     })
[16:17:47.852]     if (TRUE) {
[16:17:47.852]         base::sink(type = "output", split = FALSE)
[16:17:47.852]         if (TRUE) {
[16:17:47.852]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:47.852]         }
[16:17:47.852]         else {
[16:17:47.852]             ...future.result["stdout"] <- base::list(NULL)
[16:17:47.852]         }
[16:17:47.852]         base::close(...future.stdout)
[16:17:47.852]         ...future.stdout <- NULL
[16:17:47.852]     }
[16:17:47.852]     ...future.result$conditions <- ...future.conditions
[16:17:47.852]     ...future.result$finished <- base::Sys.time()
[16:17:47.852]     ...future.result
[16:17:47.852] }
[16:17:47.854] assign_globals() ...
[16:17:47.854] List of 5
[16:17:47.854]  $ ...future.FUN            :function (object, ...)  
[16:17:47.854]  $ future.call.arguments    : list()
[16:17:47.854]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.854]  $ ...future.elements_ii    :List of 1
[16:17:47.854]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:47.854]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:17:47.854]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.854]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:47.854]  $ ...future.seeds_ii       : NULL
[16:17:47.854]  $ ...future.globals.maxSize: NULL
[16:17:47.854]  - attr(*, "where")=List of 5
[16:17:47.854]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:47.854]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:47.854]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:47.854]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:47.854]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:47.854]  - attr(*, "resolved")= logi FALSE
[16:17:47.854]  - attr(*, "total_size")= num 1240
[16:17:47.854]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.854]  - attr(*, "already-done")= logi TRUE
[16:17:47.860] - copied ‘...future.FUN’ to environment
[16:17:47.860] - copied ‘future.call.arguments’ to environment
[16:17:47.860] - copied ‘...future.elements_ii’ to environment
[16:17:47.860] - copied ‘...future.seeds_ii’ to environment
[16:17:47.860] - copied ‘...future.globals.maxSize’ to environment
[16:17:47.860] assign_globals() ... done
[16:17:47.860] requestCore(): workers = 2
[16:17:47.863] MulticoreFuture started
[16:17:47.863] - Launch lazy future ... done
[16:17:47.863] run() for ‘MulticoreFuture’ ... done
[16:17:47.864] plan(): Setting new future strategy stack:
[16:17:47.864] Created future:
[16:17:47.864] List of future strategies:
[16:17:47.864] 1. sequential:
[16:17:47.864]    - args: function (..., envir = parent.frame())
[16:17:47.864]    - tweaked: FALSE
[16:17:47.864]    - call: NULL
[16:17:47.865] plan(): nbrOfWorkers() = 1
[16:17:47.869] plan(): Setting new future strategy stack:
[16:17:47.869] List of future strategies:
[16:17:47.869] 1. multicore:
[16:17:47.869]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:47.869]    - tweaked: FALSE
[16:17:47.869]    - call: plan(strategy)
[16:17:47.874] plan(): nbrOfWorkers() = 2
[16:17:47.864] MulticoreFuture:
[16:17:47.864] Label: ‘future_by-1’
[16:17:47.864] Expression:
[16:17:47.864] {
[16:17:47.864]     do.call(function(...) {
[16:17:47.864]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.864]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.864]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.864]             on.exit(options(oopts), add = TRUE)
[16:17:47.864]         }
[16:17:47.864]         {
[16:17:47.864]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.864]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.864]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.864]             })
[16:17:47.864]         }
[16:17:47.864]     }, args = future.call.arguments)
[16:17:47.864] }
[16:17:47.864] Lazy evaluation: FALSE
[16:17:47.864] Asynchronous evaluation: TRUE
[16:17:47.864] Local evaluation: TRUE
[16:17:47.864] Environment: 0x55b5663e6b18
[16:17:47.864] Capture standard output: TRUE
[16:17:47.864] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:47.864] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:47.864] Packages: <none>
[16:17:47.864] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:47.864] Resolved: TRUE
[16:17:47.864] Value: <not collected>
[16:17:47.864] Conditions captured: <none>
[16:17:47.864] Early signaling: FALSE
[16:17:47.864] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:47.864] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:47.875] Chunk #1 of 2 ... DONE
[16:17:47.875] Chunk #2 of 2 ...
[16:17:47.875]  - Finding globals in 'X' for chunk #2 ...
[16:17:47.876] getGlobalsAndPackages() ...
[16:17:47.876] Searching for globals...
[16:17:47.877] 
[16:17:47.877] Searching for globals ... DONE
[16:17:47.877] - globals: [0] <none>
[16:17:47.877] getGlobalsAndPackages() ... DONE
[16:17:47.877]    + additional globals found: [n=0] 
[16:17:47.877]    + additional namespaces needed: [n=0] 
[16:17:47.877]  - Finding globals in 'X' for chunk #2 ... DONE
[16:17:47.877]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:47.878]  - seeds: <none>
[16:17:47.878]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.878] getGlobalsAndPackages() ...
[16:17:47.878] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.878] Resolving globals: FALSE
[16:17:47.878] Tweak future expression to call with '...' arguments ...
[16:17:47.879] {
[16:17:47.879]     do.call(function(...) {
[16:17:47.879]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.879]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.879]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.879]             on.exit(options(oopts), add = TRUE)
[16:17:47.879]         }
[16:17:47.879]         {
[16:17:47.879]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.879]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.879]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.879]             })
[16:17:47.879]         }
[16:17:47.879]     }, args = future.call.arguments)
[16:17:47.879] }
[16:17:47.879] Tweak future expression to call with '...' arguments ... DONE
[16:17:47.880] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.880] 
[16:17:47.880] getGlobalsAndPackages() ... DONE
[16:17:47.881] run() for ‘Future’ ...
[16:17:47.881] - state: ‘created’
[16:17:47.881] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:47.885] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:47.886] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:47.886]   - Field: ‘label’
[16:17:47.886]   - Field: ‘local’
[16:17:47.886]   - Field: ‘owner’
[16:17:47.886]   - Field: ‘envir’
[16:17:47.886]   - Field: ‘workers’
[16:17:47.887]   - Field: ‘packages’
[16:17:47.887]   - Field: ‘gc’
[16:17:47.887]   - Field: ‘job’
[16:17:47.887]   - Field: ‘conditions’
[16:17:47.887]   - Field: ‘expr’
[16:17:47.887]   - Field: ‘uuid’
[16:17:47.887]   - Field: ‘seed’
[16:17:47.888]   - Field: ‘version’
[16:17:47.888]   - Field: ‘result’
[16:17:47.888]   - Field: ‘asynchronous’
[16:17:47.888]   - Field: ‘calls’
[16:17:47.888]   - Field: ‘globals’
[16:17:47.888]   - Field: ‘stdout’
[16:17:47.888]   - Field: ‘earlySignal’
[16:17:47.889]   - Field: ‘lazy’
[16:17:47.889]   - Field: ‘state’
[16:17:47.889] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:47.889] - Launch lazy future ...
[16:17:47.890] Packages needed by the future expression (n = 0): <none>
[16:17:47.890] Packages needed by future strategies (n = 0): <none>
[16:17:47.891] {
[16:17:47.891]     {
[16:17:47.891]         {
[16:17:47.891]             ...future.startTime <- base::Sys.time()
[16:17:47.891]             {
[16:17:47.891]                 {
[16:17:47.891]                   {
[16:17:47.891]                     {
[16:17:47.891]                       base::local({
[16:17:47.891]                         has_future <- base::requireNamespace("future", 
[16:17:47.891]                           quietly = TRUE)
[16:17:47.891]                         if (has_future) {
[16:17:47.891]                           ns <- base::getNamespace("future")
[16:17:47.891]                           version <- ns[[".package"]][["version"]]
[16:17:47.891]                           if (is.null(version)) 
[16:17:47.891]                             version <- utils::packageVersion("future")
[16:17:47.891]                         }
[16:17:47.891]                         else {
[16:17:47.891]                           version <- NULL
[16:17:47.891]                         }
[16:17:47.891]                         if (!has_future || version < "1.8.0") {
[16:17:47.891]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:47.891]                             "", base::R.version$version.string), 
[16:17:47.891]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:47.891]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:47.891]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:47.891]                               "release", "version")], collapse = " "), 
[16:17:47.891]                             hostname = base::Sys.info()[["nodename"]])
[16:17:47.891]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:47.891]                             info)
[16:17:47.891]                           info <- base::paste(info, collapse = "; ")
[16:17:47.891]                           if (!has_future) {
[16:17:47.891]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:47.891]                               info)
[16:17:47.891]                           }
[16:17:47.891]                           else {
[16:17:47.891]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:47.891]                               info, version)
[16:17:47.891]                           }
[16:17:47.891]                           base::stop(msg)
[16:17:47.891]                         }
[16:17:47.891]                       })
[16:17:47.891]                     }
[16:17:47.891]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:47.891]                     base::options(mc.cores = 1L)
[16:17:47.891]                   }
[16:17:47.891]                   ...future.strategy.old <- future::plan("list")
[16:17:47.891]                   options(future.plan = NULL)
[16:17:47.891]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.891]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:47.891]                 }
[16:17:47.891]                 ...future.workdir <- getwd()
[16:17:47.891]             }
[16:17:47.891]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:47.891]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:47.891]         }
[16:17:47.891]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:47.891]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:47.891]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:47.891]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:47.891]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:47.891]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:47.891]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:47.891]             base::names(...future.oldOptions))
[16:17:47.891]     }
[16:17:47.891]     if (FALSE) {
[16:17:47.891]     }
[16:17:47.891]     else {
[16:17:47.891]         if (TRUE) {
[16:17:47.891]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:47.891]                 open = "w")
[16:17:47.891]         }
[16:17:47.891]         else {
[16:17:47.891]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:47.891]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:47.891]         }
[16:17:47.891]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:47.891]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:47.891]             base::sink(type = "output", split = FALSE)
[16:17:47.891]             base::close(...future.stdout)
[16:17:47.891]         }, add = TRUE)
[16:17:47.891]     }
[16:17:47.891]     ...future.frame <- base::sys.nframe()
[16:17:47.891]     ...future.conditions <- base::list()
[16:17:47.891]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:47.891]     if (FALSE) {
[16:17:47.891]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:47.891]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:47.891]     }
[16:17:47.891]     ...future.result <- base::tryCatch({
[16:17:47.891]         base::withCallingHandlers({
[16:17:47.891]             ...future.value <- base::withVisible(base::local({
[16:17:47.891]                 withCallingHandlers({
[16:17:47.891]                   {
[16:17:47.891]                     do.call(function(...) {
[16:17:47.891]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.891]                       if (!identical(...future.globals.maxSize.org, 
[16:17:47.891]                         ...future.globals.maxSize)) {
[16:17:47.891]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.891]                         on.exit(options(oopts), add = TRUE)
[16:17:47.891]                       }
[16:17:47.891]                       {
[16:17:47.891]                         lapply(seq_along(...future.elements_ii), 
[16:17:47.891]                           FUN = function(jj) {
[16:17:47.891]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.891]                             ...future.FUN(...future.X_jj, ...)
[16:17:47.891]                           })
[16:17:47.891]                       }
[16:17:47.891]                     }, args = future.call.arguments)
[16:17:47.891]                   }
[16:17:47.891]                 }, immediateCondition = function(cond) {
[16:17:47.891]                   save_rds <- function (object, pathname, ...) 
[16:17:47.891]                   {
[16:17:47.891]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:47.891]                     if (file_test("-f", pathname_tmp)) {
[16:17:47.891]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.891]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:47.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.891]                         fi_tmp[["mtime"]])
[16:17:47.891]                     }
[16:17:47.891]                     tryCatch({
[16:17:47.891]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:47.891]                     }, error = function(ex) {
[16:17:47.891]                       msg <- conditionMessage(ex)
[16:17:47.891]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.891]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:47.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.891]                         fi_tmp[["mtime"]], msg)
[16:17:47.891]                       ex$message <- msg
[16:17:47.891]                       stop(ex)
[16:17:47.891]                     })
[16:17:47.891]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:47.891]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:47.891]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:47.891]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.891]                       fi <- file.info(pathname)
[16:17:47.891]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:47.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.891]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:47.891]                         fi[["size"]], fi[["mtime"]])
[16:17:47.891]                       stop(msg)
[16:17:47.891]                     }
[16:17:47.891]                     invisible(pathname)
[16:17:47.891]                   }
[16:17:47.891]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:47.891]                     rootPath = tempdir()) 
[16:17:47.891]                   {
[16:17:47.891]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:47.891]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:47.891]                       tmpdir = path, fileext = ".rds")
[16:17:47.891]                     save_rds(obj, file)
[16:17:47.891]                   }
[16:17:47.891]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1cUuyG/.future/immediateConditions")
[16:17:47.891]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.891]                   {
[16:17:47.891]                     inherits <- base::inherits
[16:17:47.891]                     invokeRestart <- base::invokeRestart
[16:17:47.891]                     is.null <- base::is.null
[16:17:47.891]                     muffled <- FALSE
[16:17:47.891]                     if (inherits(cond, "message")) {
[16:17:47.891]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:47.891]                       if (muffled) 
[16:17:47.891]                         invokeRestart("muffleMessage")
[16:17:47.891]                     }
[16:17:47.891]                     else if (inherits(cond, "warning")) {
[16:17:47.891]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:47.891]                       if (muffled) 
[16:17:47.891]                         invokeRestart("muffleWarning")
[16:17:47.891]                     }
[16:17:47.891]                     else if (inherits(cond, "condition")) {
[16:17:47.891]                       if (!is.null(pattern)) {
[16:17:47.891]                         computeRestarts <- base::computeRestarts
[16:17:47.891]                         grepl <- base::grepl
[16:17:47.891]                         restarts <- computeRestarts(cond)
[16:17:47.891]                         for (restart in restarts) {
[16:17:47.891]                           name <- restart$name
[16:17:47.891]                           if (is.null(name)) 
[16:17:47.891]                             next
[16:17:47.891]                           if (!grepl(pattern, name)) 
[16:17:47.891]                             next
[16:17:47.891]                           invokeRestart(restart)
[16:17:47.891]                           muffled <- TRUE
[16:17:47.891]                           break
[16:17:47.891]                         }
[16:17:47.891]                       }
[16:17:47.891]                     }
[16:17:47.891]                     invisible(muffled)
[16:17:47.891]                   }
[16:17:47.891]                   muffleCondition(cond)
[16:17:47.891]                 })
[16:17:47.891]             }))
[16:17:47.891]             future::FutureResult(value = ...future.value$value, 
[16:17:47.891]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.891]                   ...future.rng), globalenv = if (FALSE) 
[16:17:47.891]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:47.891]                     ...future.globalenv.names))
[16:17:47.891]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:47.891]         }, condition = base::local({
[16:17:47.891]             c <- base::c
[16:17:47.891]             inherits <- base::inherits
[16:17:47.891]             invokeRestart <- base::invokeRestart
[16:17:47.891]             length <- base::length
[16:17:47.891]             list <- base::list
[16:17:47.891]             seq.int <- base::seq.int
[16:17:47.891]             signalCondition <- base::signalCondition
[16:17:47.891]             sys.calls <- base::sys.calls
[16:17:47.891]             `[[` <- base::`[[`
[16:17:47.891]             `+` <- base::`+`
[16:17:47.891]             `<<-` <- base::`<<-`
[16:17:47.891]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:47.891]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:47.891]                   3L)]
[16:17:47.891]             }
[16:17:47.891]             function(cond) {
[16:17:47.891]                 is_error <- inherits(cond, "error")
[16:17:47.891]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:47.891]                   NULL)
[16:17:47.891]                 if (is_error) {
[16:17:47.891]                   sessionInformation <- function() {
[16:17:47.891]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:47.891]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:47.891]                       search = base::search(), system = base::Sys.info())
[16:17:47.891]                   }
[16:17:47.891]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.891]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:47.891]                     cond$call), session = sessionInformation(), 
[16:17:47.891]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:47.891]                   signalCondition(cond)
[16:17:47.891]                 }
[16:17:47.891]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:47.891]                 "immediateCondition"))) {
[16:17:47.891]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:47.891]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.891]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:47.891]                   if (TRUE && !signal) {
[16:17:47.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.891]                     {
[16:17:47.891]                       inherits <- base::inherits
[16:17:47.891]                       invokeRestart <- base::invokeRestart
[16:17:47.891]                       is.null <- base::is.null
[16:17:47.891]                       muffled <- FALSE
[16:17:47.891]                       if (inherits(cond, "message")) {
[16:17:47.891]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.891]                         if (muffled) 
[16:17:47.891]                           invokeRestart("muffleMessage")
[16:17:47.891]                       }
[16:17:47.891]                       else if (inherits(cond, "warning")) {
[16:17:47.891]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.891]                         if (muffled) 
[16:17:47.891]                           invokeRestart("muffleWarning")
[16:17:47.891]                       }
[16:17:47.891]                       else if (inherits(cond, "condition")) {
[16:17:47.891]                         if (!is.null(pattern)) {
[16:17:47.891]                           computeRestarts <- base::computeRestarts
[16:17:47.891]                           grepl <- base::grepl
[16:17:47.891]                           restarts <- computeRestarts(cond)
[16:17:47.891]                           for (restart in restarts) {
[16:17:47.891]                             name <- restart$name
[16:17:47.891]                             if (is.null(name)) 
[16:17:47.891]                               next
[16:17:47.891]                             if (!grepl(pattern, name)) 
[16:17:47.891]                               next
[16:17:47.891]                             invokeRestart(restart)
[16:17:47.891]                             muffled <- TRUE
[16:17:47.891]                             break
[16:17:47.891]                           }
[16:17:47.891]                         }
[16:17:47.891]                       }
[16:17:47.891]                       invisible(muffled)
[16:17:47.891]                     }
[16:17:47.891]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.891]                   }
[16:17:47.891]                 }
[16:17:47.891]                 else {
[16:17:47.891]                   if (TRUE) {
[16:17:47.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.891]                     {
[16:17:47.891]                       inherits <- base::inherits
[16:17:47.891]                       invokeRestart <- base::invokeRestart
[16:17:47.891]                       is.null <- base::is.null
[16:17:47.891]                       muffled <- FALSE
[16:17:47.891]                       if (inherits(cond, "message")) {
[16:17:47.891]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.891]                         if (muffled) 
[16:17:47.891]                           invokeRestart("muffleMessage")
[16:17:47.891]                       }
[16:17:47.891]                       else if (inherits(cond, "warning")) {
[16:17:47.891]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.891]                         if (muffled) 
[16:17:47.891]                           invokeRestart("muffleWarning")
[16:17:47.891]                       }
[16:17:47.891]                       else if (inherits(cond, "condition")) {
[16:17:47.891]                         if (!is.null(pattern)) {
[16:17:47.891]                           computeRestarts <- base::computeRestarts
[16:17:47.891]                           grepl <- base::grepl
[16:17:47.891]                           restarts <- computeRestarts(cond)
[16:17:47.891]                           for (restart in restarts) {
[16:17:47.891]                             name <- restart$name
[16:17:47.891]                             if (is.null(name)) 
[16:17:47.891]                               next
[16:17:47.891]                             if (!grepl(pattern, name)) 
[16:17:47.891]                               next
[16:17:47.891]                             invokeRestart(restart)
[16:17:47.891]                             muffled <- TRUE
[16:17:47.891]                             break
[16:17:47.891]                           }
[16:17:47.891]                         }
[16:17:47.891]                       }
[16:17:47.891]                       invisible(muffled)
[16:17:47.891]                     }
[16:17:47.891]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.891]                   }
[16:17:47.891]                 }
[16:17:47.891]             }
[16:17:47.891]         }))
[16:17:47.891]     }, error = function(ex) {
[16:17:47.891]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:47.891]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.891]                 ...future.rng), started = ...future.startTime, 
[16:17:47.891]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:47.891]             version = "1.8"), class = "FutureResult")
[16:17:47.891]     }, finally = {
[16:17:47.891]         if (!identical(...future.workdir, getwd())) 
[16:17:47.891]             setwd(...future.workdir)
[16:17:47.891]         {
[16:17:47.891]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:47.891]                 ...future.oldOptions$nwarnings <- NULL
[16:17:47.891]             }
[16:17:47.891]             base::options(...future.oldOptions)
[16:17:47.891]             if (.Platform$OS.type == "windows") {
[16:17:47.891]                 old_names <- names(...future.oldEnvVars)
[16:17:47.891]                 envs <- base::Sys.getenv()
[16:17:47.891]                 names <- names(envs)
[16:17:47.891]                 common <- intersect(names, old_names)
[16:17:47.891]                 added <- setdiff(names, old_names)
[16:17:47.891]                 removed <- setdiff(old_names, names)
[16:17:47.891]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:47.891]                   envs[common]]
[16:17:47.891]                 NAMES <- toupper(changed)
[16:17:47.891]                 args <- list()
[16:17:47.891]                 for (kk in seq_along(NAMES)) {
[16:17:47.891]                   name <- changed[[kk]]
[16:17:47.891]                   NAME <- NAMES[[kk]]
[16:17:47.891]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.891]                     next
[16:17:47.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.891]                 }
[16:17:47.891]                 NAMES <- toupper(added)
[16:17:47.891]                 for (kk in seq_along(NAMES)) {
[16:17:47.891]                   name <- added[[kk]]
[16:17:47.891]                   NAME <- NAMES[[kk]]
[16:17:47.891]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.891]                     next
[16:17:47.891]                   args[[name]] <- ""
[16:17:47.891]                 }
[16:17:47.891]                 NAMES <- toupper(removed)
[16:17:47.891]                 for (kk in seq_along(NAMES)) {
[16:17:47.891]                   name <- removed[[kk]]
[16:17:47.891]                   NAME <- NAMES[[kk]]
[16:17:47.891]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.891]                     next
[16:17:47.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.891]                 }
[16:17:47.891]                 if (length(args) > 0) 
[16:17:47.891]                   base::do.call(base::Sys.setenv, args = args)
[16:17:47.891]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:47.891]             }
[16:17:47.891]             else {
[16:17:47.891]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:47.891]             }
[16:17:47.891]             {
[16:17:47.891]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:47.891]                   0L) {
[16:17:47.891]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:47.891]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:47.891]                   base::options(opts)
[16:17:47.891]                 }
[16:17:47.891]                 {
[16:17:47.891]                   {
[16:17:47.891]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:47.891]                     NULL
[16:17:47.891]                   }
[16:17:47.891]                   options(future.plan = NULL)
[16:17:47.891]                   if (is.na(NA_character_)) 
[16:17:47.891]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.891]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:47.891]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:47.891]                     .init = FALSE)
[16:17:47.891]                 }
[16:17:47.891]             }
[16:17:47.891]         }
[16:17:47.891]     })
[16:17:47.891]     if (TRUE) {
[16:17:47.891]         base::sink(type = "output", split = FALSE)
[16:17:47.891]         if (TRUE) {
[16:17:47.891]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:47.891]         }
[16:17:47.891]         else {
[16:17:47.891]             ...future.result["stdout"] <- base::list(NULL)
[16:17:47.891]         }
[16:17:47.891]         base::close(...future.stdout)
[16:17:47.891]         ...future.stdout <- NULL
[16:17:47.891]     }
[16:17:47.891]     ...future.result$conditions <- ...future.conditions
[16:17:47.891]     ...future.result$finished <- base::Sys.time()
[16:17:47.891]     ...future.result
[16:17:47.891] }
[16:17:47.893] assign_globals() ...
[16:17:47.893] List of 5
[16:17:47.893]  $ ...future.FUN            :function (object, ...)  
[16:17:47.893]  $ future.call.arguments    : list()
[16:17:47.893]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.893]  $ ...future.elements_ii    :List of 2
[16:17:47.893]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:47.893]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:17:47.893]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.893]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:17:47.893]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:47.893]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:17:47.893]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.893]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:17:47.893]  $ ...future.seeds_ii       : NULL
[16:17:47.893]  $ ...future.globals.maxSize: NULL
[16:17:47.893]  - attr(*, "where")=List of 5
[16:17:47.893]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:47.893]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:47.893]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:47.893]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:47.893]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:47.893]  - attr(*, "resolved")= logi FALSE
[16:17:47.893]  - attr(*, "total_size")= num 1240
[16:17:47.893]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.893]  - attr(*, "already-done")= logi TRUE
[16:17:47.904] - copied ‘...future.FUN’ to environment
[16:17:47.904] - copied ‘future.call.arguments’ to environment
[16:17:47.904] - copied ‘...future.elements_ii’ to environment
[16:17:47.904] - copied ‘...future.seeds_ii’ to environment
[16:17:47.904] - copied ‘...future.globals.maxSize’ to environment
[16:17:47.904] assign_globals() ... done
[16:17:47.904] requestCore(): workers = 2
[16:17:47.907] MulticoreFuture started
[16:17:47.907] - Launch lazy future ... done
[16:17:47.907] run() for ‘MulticoreFuture’ ... done
[16:17:47.908] Created future:
[16:17:47.908] plan(): Setting new future strategy stack:
[16:17:47.908] List of future strategies:
[16:17:47.908] 1. sequential:
[16:17:47.908]    - args: function (..., envir = parent.frame())
[16:17:47.908]    - tweaked: FALSE
[16:17:47.908]    - call: NULL
[16:17:47.909] plan(): nbrOfWorkers() = 1
[16:17:47.913] plan(): Setting new future strategy stack:
[16:17:47.913] List of future strategies:
[16:17:47.913] 1. multicore:
[16:17:47.913]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:47.913]    - tweaked: FALSE
[16:17:47.913]    - call: plan(strategy)
[16:17:47.918] plan(): nbrOfWorkers() = 2
[16:17:47.908] MulticoreFuture:
[16:17:47.908] Label: ‘future_by-2’
[16:17:47.908] Expression:
[16:17:47.908] {
[16:17:47.908]     do.call(function(...) {
[16:17:47.908]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.908]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.908]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.908]             on.exit(options(oopts), add = TRUE)
[16:17:47.908]         }
[16:17:47.908]         {
[16:17:47.908]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.908]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.908]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.908]             })
[16:17:47.908]         }
[16:17:47.908]     }, args = future.call.arguments)
[16:17:47.908] }
[16:17:47.908] Lazy evaluation: FALSE
[16:17:47.908] Asynchronous evaluation: TRUE
[16:17:47.908] Local evaluation: TRUE
[16:17:47.908] Environment: 0x55b5663e6b18
[16:17:47.908] Capture standard output: TRUE
[16:17:47.908] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:47.908] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:47.908] Packages: <none>
[16:17:47.908] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:47.908] Resolved: TRUE
[16:17:47.908] Value: <not collected>
[16:17:47.908] Conditions captured: <none>
[16:17:47.908] Early signaling: FALSE
[16:17:47.908] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:47.908] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:47.919] Chunk #2 of 2 ... DONE
[16:17:47.919] Launching 2 futures (chunks) ... DONE
[16:17:47.919] Resolving 2 futures (chunks) ...
[16:17:47.919] resolve() on list ...
[16:17:47.919]  recursive: 0
[16:17:47.920]  length: 2
[16:17:47.920] 
[16:17:47.920] Future #1
[16:17:47.920] result() for MulticoreFuture ...
[16:17:47.921] result() for MulticoreFuture ...
[16:17:47.921] result() for MulticoreFuture ... done
[16:17:47.921] result() for MulticoreFuture ... done
[16:17:47.922] result() for MulticoreFuture ...
[16:17:47.922] result() for MulticoreFuture ... done
[16:17:47.922] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:17:47.922] - nx: 2
[16:17:47.922] - relay: TRUE
[16:17:47.922] - stdout: TRUE
[16:17:47.922] - signal: TRUE
[16:17:47.923] - resignal: FALSE
[16:17:47.923] - force: TRUE
[16:17:47.923] - relayed: [n=2] FALSE, FALSE
[16:17:47.923] - queued futures: [n=2] FALSE, FALSE
[16:17:47.923]  - until=1
[16:17:47.923]  - relaying element #1
[16:17:47.923] result() for MulticoreFuture ...
[16:17:47.923] result() for MulticoreFuture ... done
[16:17:47.924] result() for MulticoreFuture ...
[16:17:47.924] result() for MulticoreFuture ... done
[16:17:47.924] result() for MulticoreFuture ...
[16:17:47.924] result() for MulticoreFuture ... done
[16:17:47.924] result() for MulticoreFuture ...
[16:17:47.924] result() for MulticoreFuture ... done
[16:17:47.924] - relayed: [n=2] TRUE, FALSE
[16:17:47.925] - queued futures: [n=2] TRUE, FALSE
[16:17:47.925] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:17:47.925]  length: 1 (resolved future 1)
[16:17:47.925] Future #2
[16:17:47.925] result() for MulticoreFuture ...
[16:17:47.926] result() for MulticoreFuture ...
[16:17:47.926] result() for MulticoreFuture ... done
[16:17:47.926] result() for MulticoreFuture ... done
[16:17:47.926] result() for MulticoreFuture ...
[16:17:47.926] result() for MulticoreFuture ... done
[16:17:47.927] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:17:47.927] - nx: 2
[16:17:47.927] - relay: TRUE
[16:17:47.927] - stdout: TRUE
[16:17:47.927] - signal: TRUE
[16:17:47.927] - resignal: FALSE
[16:17:47.927] - force: TRUE
[16:17:47.927] - relayed: [n=2] TRUE, FALSE
[16:17:47.928] - queued futures: [n=2] TRUE, FALSE
[16:17:47.928]  - until=2
[16:17:47.928]  - relaying element #2
[16:17:47.928] result() for MulticoreFuture ...
[16:17:47.928] result() for MulticoreFuture ... done
[16:17:47.928] result() for MulticoreFuture ...
[16:17:47.928] result() for MulticoreFuture ... done
[16:17:47.929] result() for MulticoreFuture ...
[16:17:47.929] result() for MulticoreFuture ... done
[16:17:47.929] result() for MulticoreFuture ...
[16:17:47.929] result() for MulticoreFuture ... done
[16:17:47.929] - relayed: [n=2] TRUE, TRUE
[16:17:47.929] - queued futures: [n=2] TRUE, TRUE
[16:17:47.929] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:17:47.929]  length: 0 (resolved future 2)
[16:17:47.929] Relaying remaining futures
[16:17:47.930] signalConditionsASAP(NULL, pos=0) ...
[16:17:47.930] - nx: 2
[16:17:47.930] - relay: TRUE
[16:17:47.930] - stdout: TRUE
[16:17:47.930] - signal: TRUE
[16:17:47.930] - resignal: FALSE
[16:17:47.930] - force: TRUE
[16:17:47.930] - relayed: [n=2] TRUE, TRUE
[16:17:47.930] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:47.931] - relayed: [n=2] TRUE, TRUE
[16:17:47.931] - queued futures: [n=2] TRUE, TRUE
[16:17:47.931] signalConditionsASAP(NULL, pos=0) ... done
[16:17:47.931] resolve() on list ... DONE
[16:17:47.931] result() for MulticoreFuture ...
[16:17:47.931] result() for MulticoreFuture ... done
[16:17:47.931] result() for MulticoreFuture ...
[16:17:47.931] result() for MulticoreFuture ... done
[16:17:47.932] result() for MulticoreFuture ...
[16:17:47.932] result() for MulticoreFuture ... done
[16:17:47.932] result() for MulticoreFuture ...
[16:17:47.932] result() for MulticoreFuture ... done
[16:17:47.932]  - Number of value chunks collected: 2
[16:17:47.932] Resolving 2 futures (chunks) ... DONE
[16:17:47.932] Reducing values from 2 chunks ...
[16:17:47.933]  - Number of values collected after concatenation: 3
[16:17:47.933]  - Number of values expected: 3
[16:17:47.933] Reducing values from 2 chunks ... DONE
[16:17:47.933] future_lapply() ... DONE
[16:17:47.933] future_by_internal() ... DONE
[16:17:47.934] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[16:17:47.935] future_lapply() ...
[16:17:47.940] Number of chunks: 2
[16:17:47.940] getGlobalsAndPackagesXApply() ...
[16:17:47.940]  - future.globals: TRUE
[16:17:47.940] getGlobalsAndPackages() ...
[16:17:47.940] Searching for globals...
[16:17:47.942] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:47.942] Searching for globals ... DONE
[16:17:47.942] Resolving globals: FALSE
[16:17:47.943] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:47.943] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:47.943] - globals: [1] ‘FUN’
[16:17:47.943] 
[16:17:47.943] getGlobalsAndPackages() ... DONE
[16:17:47.944]  - globals found/used: [n=1] ‘FUN’
[16:17:47.944]  - needed namespaces: [n=0] 
[16:17:47.944] Finding globals ... DONE
[16:17:47.944]  - use_args: TRUE
[16:17:47.944]  - Getting '...' globals ...
[16:17:47.945] resolve() on list ...
[16:17:47.945]  recursive: 0
[16:17:47.945]  length: 1
[16:17:47.945]  elements: ‘...’
[16:17:47.945]  length: 0 (resolved future 1)
[16:17:47.945] resolve() on list ... DONE
[16:17:47.945]    - '...' content: [n=0] 
[16:17:47.945] List of 1
[16:17:47.945]  $ ...: list()
[16:17:47.945]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.945]  - attr(*, "where")=List of 1
[16:17:47.945]   ..$ ...:<environment: 0x55b56965a110> 
[16:17:47.945]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.945]  - attr(*, "resolved")= logi TRUE
[16:17:47.945]  - attr(*, "total_size")= num NA
[16:17:47.949]  - Getting '...' globals ... DONE
[16:17:47.949] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:47.949] List of 2
[16:17:47.949]  $ ...future.FUN:function (object, ...)  
[16:17:47.949]  $ ...          : list()
[16:17:47.949]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.949]  - attr(*, "where")=List of 2
[16:17:47.949]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:47.949]   ..$ ...          :<environment: 0x55b56965a110> 
[16:17:47.949]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.949]  - attr(*, "resolved")= logi FALSE
[16:17:47.949]  - attr(*, "total_size")= num 1240
[16:17:47.953] Packages to be attached in all futures: [n=0] 
[16:17:47.953] getGlobalsAndPackagesXApply() ... DONE
[16:17:47.953] Number of futures (= number of chunks): 2
[16:17:47.953] Launching 2 futures (chunks) ...
[16:17:47.953] Chunk #1 of 2 ...
[16:17:47.953]  - Finding globals in 'X' for chunk #1 ...
[16:17:47.954] getGlobalsAndPackages() ...
[16:17:47.954] Searching for globals...
[16:17:47.954] 
[16:17:47.954] Searching for globals ... DONE
[16:17:47.954] - globals: [0] <none>
[16:17:47.954] getGlobalsAndPackages() ... DONE
[16:17:47.955]    + additional globals found: [n=0] 
[16:17:47.955]    + additional namespaces needed: [n=0] 
[16:17:47.955]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:47.955]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:47.955]  - seeds: <none>
[16:17:47.955]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.955] getGlobalsAndPackages() ...
[16:17:47.955] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.956] Resolving globals: FALSE
[16:17:47.956] Tweak future expression to call with '...' arguments ...
[16:17:47.956] {
[16:17:47.956]     do.call(function(...) {
[16:17:47.956]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.956]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.956]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.956]             on.exit(options(oopts), add = TRUE)
[16:17:47.956]         }
[16:17:47.956]         {
[16:17:47.956]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.956]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.956]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.956]             })
[16:17:47.956]         }
[16:17:47.956]     }, args = future.call.arguments)
[16:17:47.956] }
[16:17:47.956] Tweak future expression to call with '...' arguments ... DONE
[16:17:47.957] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.957] 
[16:17:47.957] getGlobalsAndPackages() ... DONE
[16:17:47.957] run() for ‘Future’ ...
[16:17:47.957] - state: ‘created’
[16:17:47.958] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:47.962] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:47.962] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:47.962]   - Field: ‘label’
[16:17:47.962]   - Field: ‘local’
[16:17:47.962]   - Field: ‘owner’
[16:17:47.962]   - Field: ‘envir’
[16:17:47.962]   - Field: ‘workers’
[16:17:47.963]   - Field: ‘packages’
[16:17:47.963]   - Field: ‘gc’
[16:17:47.963]   - Field: ‘job’
[16:17:47.963]   - Field: ‘conditions’
[16:17:47.963]   - Field: ‘expr’
[16:17:47.963]   - Field: ‘uuid’
[16:17:47.963]   - Field: ‘seed’
[16:17:47.963]   - Field: ‘version’
[16:17:47.964]   - Field: ‘result’
[16:17:47.964]   - Field: ‘asynchronous’
[16:17:47.964]   - Field: ‘calls’
[16:17:47.964]   - Field: ‘globals’
[16:17:47.964]   - Field: ‘stdout’
[16:17:47.964]   - Field: ‘earlySignal’
[16:17:47.964]   - Field: ‘lazy’
[16:17:47.964]   - Field: ‘state’
[16:17:47.965] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:47.965] - Launch lazy future ...
[16:17:47.965] Packages needed by the future expression (n = 0): <none>
[16:17:47.965] Packages needed by future strategies (n = 0): <none>
[16:17:47.966] {
[16:17:47.966]     {
[16:17:47.966]         {
[16:17:47.966]             ...future.startTime <- base::Sys.time()
[16:17:47.966]             {
[16:17:47.966]                 {
[16:17:47.966]                   {
[16:17:47.966]                     {
[16:17:47.966]                       base::local({
[16:17:47.966]                         has_future <- base::requireNamespace("future", 
[16:17:47.966]                           quietly = TRUE)
[16:17:47.966]                         if (has_future) {
[16:17:47.966]                           ns <- base::getNamespace("future")
[16:17:47.966]                           version <- ns[[".package"]][["version"]]
[16:17:47.966]                           if (is.null(version)) 
[16:17:47.966]                             version <- utils::packageVersion("future")
[16:17:47.966]                         }
[16:17:47.966]                         else {
[16:17:47.966]                           version <- NULL
[16:17:47.966]                         }
[16:17:47.966]                         if (!has_future || version < "1.8.0") {
[16:17:47.966]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:47.966]                             "", base::R.version$version.string), 
[16:17:47.966]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:47.966]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:47.966]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:47.966]                               "release", "version")], collapse = " "), 
[16:17:47.966]                             hostname = base::Sys.info()[["nodename"]])
[16:17:47.966]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:47.966]                             info)
[16:17:47.966]                           info <- base::paste(info, collapse = "; ")
[16:17:47.966]                           if (!has_future) {
[16:17:47.966]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:47.966]                               info)
[16:17:47.966]                           }
[16:17:47.966]                           else {
[16:17:47.966]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:47.966]                               info, version)
[16:17:47.966]                           }
[16:17:47.966]                           base::stop(msg)
[16:17:47.966]                         }
[16:17:47.966]                       })
[16:17:47.966]                     }
[16:17:47.966]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:47.966]                     base::options(mc.cores = 1L)
[16:17:47.966]                   }
[16:17:47.966]                   ...future.strategy.old <- future::plan("list")
[16:17:47.966]                   options(future.plan = NULL)
[16:17:47.966]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.966]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:47.966]                 }
[16:17:47.966]                 ...future.workdir <- getwd()
[16:17:47.966]             }
[16:17:47.966]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:47.966]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:47.966]         }
[16:17:47.966]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:47.966]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:47.966]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:47.966]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:47.966]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:47.966]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:47.966]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:47.966]             base::names(...future.oldOptions))
[16:17:47.966]     }
[16:17:47.966]     if (FALSE) {
[16:17:47.966]     }
[16:17:47.966]     else {
[16:17:47.966]         if (TRUE) {
[16:17:47.966]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:47.966]                 open = "w")
[16:17:47.966]         }
[16:17:47.966]         else {
[16:17:47.966]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:47.966]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:47.966]         }
[16:17:47.966]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:47.966]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:47.966]             base::sink(type = "output", split = FALSE)
[16:17:47.966]             base::close(...future.stdout)
[16:17:47.966]         }, add = TRUE)
[16:17:47.966]     }
[16:17:47.966]     ...future.frame <- base::sys.nframe()
[16:17:47.966]     ...future.conditions <- base::list()
[16:17:47.966]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:47.966]     if (FALSE) {
[16:17:47.966]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:47.966]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:47.966]     }
[16:17:47.966]     ...future.result <- base::tryCatch({
[16:17:47.966]         base::withCallingHandlers({
[16:17:47.966]             ...future.value <- base::withVisible(base::local({
[16:17:47.966]                 withCallingHandlers({
[16:17:47.966]                   {
[16:17:47.966]                     do.call(function(...) {
[16:17:47.966]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.966]                       if (!identical(...future.globals.maxSize.org, 
[16:17:47.966]                         ...future.globals.maxSize)) {
[16:17:47.966]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.966]                         on.exit(options(oopts), add = TRUE)
[16:17:47.966]                       }
[16:17:47.966]                       {
[16:17:47.966]                         lapply(seq_along(...future.elements_ii), 
[16:17:47.966]                           FUN = function(jj) {
[16:17:47.966]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.966]                             ...future.FUN(...future.X_jj, ...)
[16:17:47.966]                           })
[16:17:47.966]                       }
[16:17:47.966]                     }, args = future.call.arguments)
[16:17:47.966]                   }
[16:17:47.966]                 }, immediateCondition = function(cond) {
[16:17:47.966]                   save_rds <- function (object, pathname, ...) 
[16:17:47.966]                   {
[16:17:47.966]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:47.966]                     if (file_test("-f", pathname_tmp)) {
[16:17:47.966]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.966]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:47.966]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.966]                         fi_tmp[["mtime"]])
[16:17:47.966]                     }
[16:17:47.966]                     tryCatch({
[16:17:47.966]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:47.966]                     }, error = function(ex) {
[16:17:47.966]                       msg <- conditionMessage(ex)
[16:17:47.966]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.966]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:47.966]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.966]                         fi_tmp[["mtime"]], msg)
[16:17:47.966]                       ex$message <- msg
[16:17:47.966]                       stop(ex)
[16:17:47.966]                     })
[16:17:47.966]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:47.966]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:47.966]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:47.966]                       fi_tmp <- file.info(pathname_tmp)
[16:17:47.966]                       fi <- file.info(pathname)
[16:17:47.966]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:47.966]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:47.966]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:47.966]                         fi[["size"]], fi[["mtime"]])
[16:17:47.966]                       stop(msg)
[16:17:47.966]                     }
[16:17:47.966]                     invisible(pathname)
[16:17:47.966]                   }
[16:17:47.966]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:47.966]                     rootPath = tempdir()) 
[16:17:47.966]                   {
[16:17:47.966]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:47.966]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:47.966]                       tmpdir = path, fileext = ".rds")
[16:17:47.966]                     save_rds(obj, file)
[16:17:47.966]                   }
[16:17:47.966]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1cUuyG/.future/immediateConditions")
[16:17:47.966]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.966]                   {
[16:17:47.966]                     inherits <- base::inherits
[16:17:47.966]                     invokeRestart <- base::invokeRestart
[16:17:47.966]                     is.null <- base::is.null
[16:17:47.966]                     muffled <- FALSE
[16:17:47.966]                     if (inherits(cond, "message")) {
[16:17:47.966]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:47.966]                       if (muffled) 
[16:17:47.966]                         invokeRestart("muffleMessage")
[16:17:47.966]                     }
[16:17:47.966]                     else if (inherits(cond, "warning")) {
[16:17:47.966]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:47.966]                       if (muffled) 
[16:17:47.966]                         invokeRestart("muffleWarning")
[16:17:47.966]                     }
[16:17:47.966]                     else if (inherits(cond, "condition")) {
[16:17:47.966]                       if (!is.null(pattern)) {
[16:17:47.966]                         computeRestarts <- base::computeRestarts
[16:17:47.966]                         grepl <- base::grepl
[16:17:47.966]                         restarts <- computeRestarts(cond)
[16:17:47.966]                         for (restart in restarts) {
[16:17:47.966]                           name <- restart$name
[16:17:47.966]                           if (is.null(name)) 
[16:17:47.966]                             next
[16:17:47.966]                           if (!grepl(pattern, name)) 
[16:17:47.966]                             next
[16:17:47.966]                           invokeRestart(restart)
[16:17:47.966]                           muffled <- TRUE
[16:17:47.966]                           break
[16:17:47.966]                         }
[16:17:47.966]                       }
[16:17:47.966]                     }
[16:17:47.966]                     invisible(muffled)
[16:17:47.966]                   }
[16:17:47.966]                   muffleCondition(cond)
[16:17:47.966]                 })
[16:17:47.966]             }))
[16:17:47.966]             future::FutureResult(value = ...future.value$value, 
[16:17:47.966]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.966]                   ...future.rng), globalenv = if (FALSE) 
[16:17:47.966]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:47.966]                     ...future.globalenv.names))
[16:17:47.966]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:47.966]         }, condition = base::local({
[16:17:47.966]             c <- base::c
[16:17:47.966]             inherits <- base::inherits
[16:17:47.966]             invokeRestart <- base::invokeRestart
[16:17:47.966]             length <- base::length
[16:17:47.966]             list <- base::list
[16:17:47.966]             seq.int <- base::seq.int
[16:17:47.966]             signalCondition <- base::signalCondition
[16:17:47.966]             sys.calls <- base::sys.calls
[16:17:47.966]             `[[` <- base::`[[`
[16:17:47.966]             `+` <- base::`+`
[16:17:47.966]             `<<-` <- base::`<<-`
[16:17:47.966]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:47.966]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:47.966]                   3L)]
[16:17:47.966]             }
[16:17:47.966]             function(cond) {
[16:17:47.966]                 is_error <- inherits(cond, "error")
[16:17:47.966]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:47.966]                   NULL)
[16:17:47.966]                 if (is_error) {
[16:17:47.966]                   sessionInformation <- function() {
[16:17:47.966]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:47.966]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:47.966]                       search = base::search(), system = base::Sys.info())
[16:17:47.966]                   }
[16:17:47.966]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.966]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:47.966]                     cond$call), session = sessionInformation(), 
[16:17:47.966]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:47.966]                   signalCondition(cond)
[16:17:47.966]                 }
[16:17:47.966]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:47.966]                 "immediateCondition"))) {
[16:17:47.966]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:47.966]                   ...future.conditions[[length(...future.conditions) + 
[16:17:47.966]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:47.966]                   if (TRUE && !signal) {
[16:17:47.966]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.966]                     {
[16:17:47.966]                       inherits <- base::inherits
[16:17:47.966]                       invokeRestart <- base::invokeRestart
[16:17:47.966]                       is.null <- base::is.null
[16:17:47.966]                       muffled <- FALSE
[16:17:47.966]                       if (inherits(cond, "message")) {
[16:17:47.966]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.966]                         if (muffled) 
[16:17:47.966]                           invokeRestart("muffleMessage")
[16:17:47.966]                       }
[16:17:47.966]                       else if (inherits(cond, "warning")) {
[16:17:47.966]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.966]                         if (muffled) 
[16:17:47.966]                           invokeRestart("muffleWarning")
[16:17:47.966]                       }
[16:17:47.966]                       else if (inherits(cond, "condition")) {
[16:17:47.966]                         if (!is.null(pattern)) {
[16:17:47.966]                           computeRestarts <- base::computeRestarts
[16:17:47.966]                           grepl <- base::grepl
[16:17:47.966]                           restarts <- computeRestarts(cond)
[16:17:47.966]                           for (restart in restarts) {
[16:17:47.966]                             name <- restart$name
[16:17:47.966]                             if (is.null(name)) 
[16:17:47.966]                               next
[16:17:47.966]                             if (!grepl(pattern, name)) 
[16:17:47.966]                               next
[16:17:47.966]                             invokeRestart(restart)
[16:17:47.966]                             muffled <- TRUE
[16:17:47.966]                             break
[16:17:47.966]                           }
[16:17:47.966]                         }
[16:17:47.966]                       }
[16:17:47.966]                       invisible(muffled)
[16:17:47.966]                     }
[16:17:47.966]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.966]                   }
[16:17:47.966]                 }
[16:17:47.966]                 else {
[16:17:47.966]                   if (TRUE) {
[16:17:47.966]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:47.966]                     {
[16:17:47.966]                       inherits <- base::inherits
[16:17:47.966]                       invokeRestart <- base::invokeRestart
[16:17:47.966]                       is.null <- base::is.null
[16:17:47.966]                       muffled <- FALSE
[16:17:47.966]                       if (inherits(cond, "message")) {
[16:17:47.966]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:47.966]                         if (muffled) 
[16:17:47.966]                           invokeRestart("muffleMessage")
[16:17:47.966]                       }
[16:17:47.966]                       else if (inherits(cond, "warning")) {
[16:17:47.966]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:47.966]                         if (muffled) 
[16:17:47.966]                           invokeRestart("muffleWarning")
[16:17:47.966]                       }
[16:17:47.966]                       else if (inherits(cond, "condition")) {
[16:17:47.966]                         if (!is.null(pattern)) {
[16:17:47.966]                           computeRestarts <- base::computeRestarts
[16:17:47.966]                           grepl <- base::grepl
[16:17:47.966]                           restarts <- computeRestarts(cond)
[16:17:47.966]                           for (restart in restarts) {
[16:17:47.966]                             name <- restart$name
[16:17:47.966]                             if (is.null(name)) 
[16:17:47.966]                               next
[16:17:47.966]                             if (!grepl(pattern, name)) 
[16:17:47.966]                               next
[16:17:47.966]                             invokeRestart(restart)
[16:17:47.966]                             muffled <- TRUE
[16:17:47.966]                             break
[16:17:47.966]                           }
[16:17:47.966]                         }
[16:17:47.966]                       }
[16:17:47.966]                       invisible(muffled)
[16:17:47.966]                     }
[16:17:47.966]                     muffleCondition(cond, pattern = "^muffle")
[16:17:47.966]                   }
[16:17:47.966]                 }
[16:17:47.966]             }
[16:17:47.966]         }))
[16:17:47.966]     }, error = function(ex) {
[16:17:47.966]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:47.966]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:47.966]                 ...future.rng), started = ...future.startTime, 
[16:17:47.966]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:47.966]             version = "1.8"), class = "FutureResult")
[16:17:47.966]     }, finally = {
[16:17:47.966]         if (!identical(...future.workdir, getwd())) 
[16:17:47.966]             setwd(...future.workdir)
[16:17:47.966]         {
[16:17:47.966]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:47.966]                 ...future.oldOptions$nwarnings <- NULL
[16:17:47.966]             }
[16:17:47.966]             base::options(...future.oldOptions)
[16:17:47.966]             if (.Platform$OS.type == "windows") {
[16:17:47.966]                 old_names <- names(...future.oldEnvVars)
[16:17:47.966]                 envs <- base::Sys.getenv()
[16:17:47.966]                 names <- names(envs)
[16:17:47.966]                 common <- intersect(names, old_names)
[16:17:47.966]                 added <- setdiff(names, old_names)
[16:17:47.966]                 removed <- setdiff(old_names, names)
[16:17:47.966]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:47.966]                   envs[common]]
[16:17:47.966]                 NAMES <- toupper(changed)
[16:17:47.966]                 args <- list()
[16:17:47.966]                 for (kk in seq_along(NAMES)) {
[16:17:47.966]                   name <- changed[[kk]]
[16:17:47.966]                   NAME <- NAMES[[kk]]
[16:17:47.966]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.966]                     next
[16:17:47.966]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.966]                 }
[16:17:47.966]                 NAMES <- toupper(added)
[16:17:47.966]                 for (kk in seq_along(NAMES)) {
[16:17:47.966]                   name <- added[[kk]]
[16:17:47.966]                   NAME <- NAMES[[kk]]
[16:17:47.966]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.966]                     next
[16:17:47.966]                   args[[name]] <- ""
[16:17:47.966]                 }
[16:17:47.966]                 NAMES <- toupper(removed)
[16:17:47.966]                 for (kk in seq_along(NAMES)) {
[16:17:47.966]                   name <- removed[[kk]]
[16:17:47.966]                   NAME <- NAMES[[kk]]
[16:17:47.966]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:47.966]                     next
[16:17:47.966]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:47.966]                 }
[16:17:47.966]                 if (length(args) > 0) 
[16:17:47.966]                   base::do.call(base::Sys.setenv, args = args)
[16:17:47.966]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:47.966]             }
[16:17:47.966]             else {
[16:17:47.966]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:47.966]             }
[16:17:47.966]             {
[16:17:47.966]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:47.966]                   0L) {
[16:17:47.966]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:47.966]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:47.966]                   base::options(opts)
[16:17:47.966]                 }
[16:17:47.966]                 {
[16:17:47.966]                   {
[16:17:47.966]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:47.966]                     NULL
[16:17:47.966]                   }
[16:17:47.966]                   options(future.plan = NULL)
[16:17:47.966]                   if (is.na(NA_character_)) 
[16:17:47.966]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:47.966]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:47.966]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:47.966]                     .init = FALSE)
[16:17:47.966]                 }
[16:17:47.966]             }
[16:17:47.966]         }
[16:17:47.966]     })
[16:17:47.966]     if (TRUE) {
[16:17:47.966]         base::sink(type = "output", split = FALSE)
[16:17:47.966]         if (TRUE) {
[16:17:47.966]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:47.966]         }
[16:17:47.966]         else {
[16:17:47.966]             ...future.result["stdout"] <- base::list(NULL)
[16:17:47.966]         }
[16:17:47.966]         base::close(...future.stdout)
[16:17:47.966]         ...future.stdout <- NULL
[16:17:47.966]     }
[16:17:47.966]     ...future.result$conditions <- ...future.conditions
[16:17:47.966]     ...future.result$finished <- base::Sys.time()
[16:17:47.966]     ...future.result
[16:17:47.966] }
[16:17:47.969] assign_globals() ...
[16:17:47.969] List of 5
[16:17:47.969]  $ ...future.FUN            :function (object, ...)  
[16:17:47.969]  $ future.call.arguments    : list()
[16:17:47.969]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:47.969]  $ ...future.elements_ii    :List of 1
[16:17:47.969]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:47.969]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:17:47.969]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:47.969]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:47.969]  $ ...future.seeds_ii       : NULL
[16:17:47.969]  $ ...future.globals.maxSize: NULL
[16:17:47.969]  - attr(*, "where")=List of 5
[16:17:47.969]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:47.969]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:47.969]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:47.969]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:47.969]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:47.969]  - attr(*, "resolved")= logi FALSE
[16:17:47.969]  - attr(*, "total_size")= num 1240
[16:17:47.969]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:47.969]  - attr(*, "already-done")= logi TRUE
[16:17:47.979] - copied ‘...future.FUN’ to environment
[16:17:47.979] - copied ‘future.call.arguments’ to environment
[16:17:47.979] - copied ‘...future.elements_ii’ to environment
[16:17:47.979] - copied ‘...future.seeds_ii’ to environment
[16:17:47.979] - copied ‘...future.globals.maxSize’ to environment
[16:17:47.979] assign_globals() ... done
[16:17:47.979] requestCore(): workers = 2
[16:17:47.982] MulticoreFuture started
[16:17:47.982] - Launch lazy future ... done
[16:17:47.982] run() for ‘MulticoreFuture’ ... done
[16:17:47.982] Created future:
[16:17:47.983] plan(): Setting new future strategy stack:
[16:17:47.983] List of future strategies:
[16:17:47.983] 1. sequential:
[16:17:47.983]    - args: function (..., envir = parent.frame())
[16:17:47.983]    - tweaked: FALSE
[16:17:47.983]    - call: NULL
[16:17:47.984] plan(): nbrOfWorkers() = 1
[16:17:47.987] plan(): Setting new future strategy stack:
[16:17:47.987] List of future strategies:
[16:17:47.987] 1. multicore:
[16:17:47.987]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:47.987]    - tweaked: FALSE
[16:17:47.987]    - call: plan(strategy)
[16:17:47.992] plan(): nbrOfWorkers() = 2
[16:17:47.983] MulticoreFuture:
[16:17:47.983] Label: ‘future_by-1’
[16:17:47.983] Expression:
[16:17:47.983] {
[16:17:47.983]     do.call(function(...) {
[16:17:47.983]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.983]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.983]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.983]             on.exit(options(oopts), add = TRUE)
[16:17:47.983]         }
[16:17:47.983]         {
[16:17:47.983]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.983]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.983]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.983]             })
[16:17:47.983]         }
[16:17:47.983]     }, args = future.call.arguments)
[16:17:47.983] }
[16:17:47.983] Lazy evaluation: FALSE
[16:17:47.983] Asynchronous evaluation: TRUE
[16:17:47.983] Local evaluation: TRUE
[16:17:47.983] Environment: 0x55b569629098
[16:17:47.983] Capture standard output: TRUE
[16:17:47.983] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:47.983] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:47.983] Packages: <none>
[16:17:47.983] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:47.983] Resolved: TRUE
[16:17:47.983] Value: <not collected>
[16:17:47.983] Conditions captured: <none>
[16:17:47.983] Early signaling: FALSE
[16:17:47.983] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:47.983] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:47.993] Chunk #1 of 2 ... DONE
[16:17:47.993] Chunk #2 of 2 ...
[16:17:47.994]  - Finding globals in 'X' for chunk #2 ...
[16:17:47.994] getGlobalsAndPackages() ...
[16:17:47.994] Searching for globals...
[16:17:47.995] 
[16:17:47.995] Searching for globals ... DONE
[16:17:47.995] - globals: [0] <none>
[16:17:47.995] getGlobalsAndPackages() ... DONE
[16:17:47.995]    + additional globals found: [n=0] 
[16:17:47.995]    + additional namespaces needed: [n=0] 
[16:17:47.996]  - Finding globals in 'X' for chunk #2 ... DONE
[16:17:47.996]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:47.996]  - seeds: <none>
[16:17:47.996]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.996] getGlobalsAndPackages() ...
[16:17:47.996] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.997] Resolving globals: FALSE
[16:17:47.997] Tweak future expression to call with '...' arguments ...
[16:17:47.997] {
[16:17:47.997]     do.call(function(...) {
[16:17:47.997]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:47.997]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:47.997]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:47.997]             on.exit(options(oopts), add = TRUE)
[16:17:47.997]         }
[16:17:47.997]         {
[16:17:47.997]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:47.997]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:47.997]                 ...future.FUN(...future.X_jj, ...)
[16:17:47.997]             })
[16:17:47.997]         }
[16:17:47.997]     }, args = future.call.arguments)
[16:17:47.997] }
[16:17:47.997] Tweak future expression to call with '...' arguments ... DONE
[16:17:47.998] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:47.998] 
[16:17:47.998] getGlobalsAndPackages() ... DONE
[16:17:47.999] run() for ‘Future’ ...
[16:17:47.999] - state: ‘created’
[16:17:47.999] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:48.003] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:48.004] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:48.004]   - Field: ‘label’
[16:17:48.004]   - Field: ‘local’
[16:17:48.004]   - Field: ‘owner’
[16:17:48.004]   - Field: ‘envir’
[16:17:48.004]   - Field: ‘workers’
[16:17:48.005]   - Field: ‘packages’
[16:17:48.005]   - Field: ‘gc’
[16:17:48.005]   - Field: ‘job’
[16:17:48.005]   - Field: ‘conditions’
[16:17:48.005]   - Field: ‘expr’
[16:17:48.005]   - Field: ‘uuid’
[16:17:48.005]   - Field: ‘seed’
[16:17:48.006]   - Field: ‘version’
[16:17:48.006]   - Field: ‘result’
[16:17:48.006]   - Field: ‘asynchronous’
[16:17:48.006]   - Field: ‘calls’
[16:17:48.006]   - Field: ‘globals’
[16:17:48.006]   - Field: ‘stdout’
[16:17:48.006]   - Field: ‘earlySignal’
[16:17:48.006]   - Field: ‘lazy’
[16:17:48.007]   - Field: ‘state’
[16:17:48.007] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:48.007] - Launch lazy future ...
[16:17:48.007] Packages needed by the future expression (n = 0): <none>
[16:17:48.007] Packages needed by future strategies (n = 0): <none>
[16:17:48.008] {
[16:17:48.008]     {
[16:17:48.008]         {
[16:17:48.008]             ...future.startTime <- base::Sys.time()
[16:17:48.008]             {
[16:17:48.008]                 {
[16:17:48.008]                   {
[16:17:48.008]                     {
[16:17:48.008]                       base::local({
[16:17:48.008]                         has_future <- base::requireNamespace("future", 
[16:17:48.008]                           quietly = TRUE)
[16:17:48.008]                         if (has_future) {
[16:17:48.008]                           ns <- base::getNamespace("future")
[16:17:48.008]                           version <- ns[[".package"]][["version"]]
[16:17:48.008]                           if (is.null(version)) 
[16:17:48.008]                             version <- utils::packageVersion("future")
[16:17:48.008]                         }
[16:17:48.008]                         else {
[16:17:48.008]                           version <- NULL
[16:17:48.008]                         }
[16:17:48.008]                         if (!has_future || version < "1.8.0") {
[16:17:48.008]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:48.008]                             "", base::R.version$version.string), 
[16:17:48.008]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:48.008]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:48.008]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:48.008]                               "release", "version")], collapse = " "), 
[16:17:48.008]                             hostname = base::Sys.info()[["nodename"]])
[16:17:48.008]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:48.008]                             info)
[16:17:48.008]                           info <- base::paste(info, collapse = "; ")
[16:17:48.008]                           if (!has_future) {
[16:17:48.008]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:48.008]                               info)
[16:17:48.008]                           }
[16:17:48.008]                           else {
[16:17:48.008]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:48.008]                               info, version)
[16:17:48.008]                           }
[16:17:48.008]                           base::stop(msg)
[16:17:48.008]                         }
[16:17:48.008]                       })
[16:17:48.008]                     }
[16:17:48.008]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:48.008]                     base::options(mc.cores = 1L)
[16:17:48.008]                   }
[16:17:48.008]                   ...future.strategy.old <- future::plan("list")
[16:17:48.008]                   options(future.plan = NULL)
[16:17:48.008]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:48.008]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:48.008]                 }
[16:17:48.008]                 ...future.workdir <- getwd()
[16:17:48.008]             }
[16:17:48.008]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:48.008]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:48.008]         }
[16:17:48.008]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:48.008]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:48.008]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:48.008]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:48.008]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:48.008]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:48.008]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:48.008]             base::names(...future.oldOptions))
[16:17:48.008]     }
[16:17:48.008]     if (FALSE) {
[16:17:48.008]     }
[16:17:48.008]     else {
[16:17:48.008]         if (TRUE) {
[16:17:48.008]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:48.008]                 open = "w")
[16:17:48.008]         }
[16:17:48.008]         else {
[16:17:48.008]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:48.008]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:48.008]         }
[16:17:48.008]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:48.008]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:48.008]             base::sink(type = "output", split = FALSE)
[16:17:48.008]             base::close(...future.stdout)
[16:17:48.008]         }, add = TRUE)
[16:17:48.008]     }
[16:17:48.008]     ...future.frame <- base::sys.nframe()
[16:17:48.008]     ...future.conditions <- base::list()
[16:17:48.008]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:48.008]     if (FALSE) {
[16:17:48.008]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:48.008]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:48.008]     }
[16:17:48.008]     ...future.result <- base::tryCatch({
[16:17:48.008]         base::withCallingHandlers({
[16:17:48.008]             ...future.value <- base::withVisible(base::local({
[16:17:48.008]                 withCallingHandlers({
[16:17:48.008]                   {
[16:17:48.008]                     do.call(function(...) {
[16:17:48.008]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:48.008]                       if (!identical(...future.globals.maxSize.org, 
[16:17:48.008]                         ...future.globals.maxSize)) {
[16:17:48.008]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:48.008]                         on.exit(options(oopts), add = TRUE)
[16:17:48.008]                       }
[16:17:48.008]                       {
[16:17:48.008]                         lapply(seq_along(...future.elements_ii), 
[16:17:48.008]                           FUN = function(jj) {
[16:17:48.008]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:48.008]                             ...future.FUN(...future.X_jj, ...)
[16:17:48.008]                           })
[16:17:48.008]                       }
[16:17:48.008]                     }, args = future.call.arguments)
[16:17:48.008]                   }
[16:17:48.008]                 }, immediateCondition = function(cond) {
[16:17:48.008]                   save_rds <- function (object, pathname, ...) 
[16:17:48.008]                   {
[16:17:48.008]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:48.008]                     if (file_test("-f", pathname_tmp)) {
[16:17:48.008]                       fi_tmp <- file.info(pathname_tmp)
[16:17:48.008]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:48.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:48.008]                         fi_tmp[["mtime"]])
[16:17:48.008]                     }
[16:17:48.008]                     tryCatch({
[16:17:48.008]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:48.008]                     }, error = function(ex) {
[16:17:48.008]                       msg <- conditionMessage(ex)
[16:17:48.008]                       fi_tmp <- file.info(pathname_tmp)
[16:17:48.008]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:48.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:48.008]                         fi_tmp[["mtime"]], msg)
[16:17:48.008]                       ex$message <- msg
[16:17:48.008]                       stop(ex)
[16:17:48.008]                     })
[16:17:48.008]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:48.008]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:48.008]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:48.008]                       fi_tmp <- file.info(pathname_tmp)
[16:17:48.008]                       fi <- file.info(pathname)
[16:17:48.008]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:48.008]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:48.008]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:48.008]                         fi[["size"]], fi[["mtime"]])
[16:17:48.008]                       stop(msg)
[16:17:48.008]                     }
[16:17:48.008]                     invisible(pathname)
[16:17:48.008]                   }
[16:17:48.008]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:48.008]                     rootPath = tempdir()) 
[16:17:48.008]                   {
[16:17:48.008]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:48.008]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:48.008]                       tmpdir = path, fileext = ".rds")
[16:17:48.008]                     save_rds(obj, file)
[16:17:48.008]                   }
[16:17:48.008]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1cUuyG/.future/immediateConditions")
[16:17:48.008]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:48.008]                   {
[16:17:48.008]                     inherits <- base::inherits
[16:17:48.008]                     invokeRestart <- base::invokeRestart
[16:17:48.008]                     is.null <- base::is.null
[16:17:48.008]                     muffled <- FALSE
[16:17:48.008]                     if (inherits(cond, "message")) {
[16:17:48.008]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:48.008]                       if (muffled) 
[16:17:48.008]                         invokeRestart("muffleMessage")
[16:17:48.008]                     }
[16:17:48.008]                     else if (inherits(cond, "warning")) {
[16:17:48.008]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:48.008]                       if (muffled) 
[16:17:48.008]                         invokeRestart("muffleWarning")
[16:17:48.008]                     }
[16:17:48.008]                     else if (inherits(cond, "condition")) {
[16:17:48.008]                       if (!is.null(pattern)) {
[16:17:48.008]                         computeRestarts <- base::computeRestarts
[16:17:48.008]                         grepl <- base::grepl
[16:17:48.008]                         restarts <- computeRestarts(cond)
[16:17:48.008]                         for (restart in restarts) {
[16:17:48.008]                           name <- restart$name
[16:17:48.008]                           if (is.null(name)) 
[16:17:48.008]                             next
[16:17:48.008]                           if (!grepl(pattern, name)) 
[16:17:48.008]                             next
[16:17:48.008]                           invokeRestart(restart)
[16:17:48.008]                           muffled <- TRUE
[16:17:48.008]                           break
[16:17:48.008]                         }
[16:17:48.008]                       }
[16:17:48.008]                     }
[16:17:48.008]                     invisible(muffled)
[16:17:48.008]                   }
[16:17:48.008]                   muffleCondition(cond)
[16:17:48.008]                 })
[16:17:48.008]             }))
[16:17:48.008]             future::FutureResult(value = ...future.value$value, 
[16:17:48.008]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:48.008]                   ...future.rng), globalenv = if (FALSE) 
[16:17:48.008]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:48.008]                     ...future.globalenv.names))
[16:17:48.008]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:48.008]         }, condition = base::local({
[16:17:48.008]             c <- base::c
[16:17:48.008]             inherits <- base::inherits
[16:17:48.008]             invokeRestart <- base::invokeRestart
[16:17:48.008]             length <- base::length
[16:17:48.008]             list <- base::list
[16:17:48.008]             seq.int <- base::seq.int
[16:17:48.008]             signalCondition <- base::signalCondition
[16:17:48.008]             sys.calls <- base::sys.calls
[16:17:48.008]             `[[` <- base::`[[`
[16:17:48.008]             `+` <- base::`+`
[16:17:48.008]             `<<-` <- base::`<<-`
[16:17:48.008]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:48.008]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:48.008]                   3L)]
[16:17:48.008]             }
[16:17:48.008]             function(cond) {
[16:17:48.008]                 is_error <- inherits(cond, "error")
[16:17:48.008]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:48.008]                   NULL)
[16:17:48.008]                 if (is_error) {
[16:17:48.008]                   sessionInformation <- function() {
[16:17:48.008]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:48.008]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:48.008]                       search = base::search(), system = base::Sys.info())
[16:17:48.008]                   }
[16:17:48.008]                   ...future.conditions[[length(...future.conditions) + 
[16:17:48.008]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:48.008]                     cond$call), session = sessionInformation(), 
[16:17:48.008]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:48.008]                   signalCondition(cond)
[16:17:48.008]                 }
[16:17:48.008]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:48.008]                 "immediateCondition"))) {
[16:17:48.008]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:48.008]                   ...future.conditions[[length(...future.conditions) + 
[16:17:48.008]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:48.008]                   if (TRUE && !signal) {
[16:17:48.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:48.008]                     {
[16:17:48.008]                       inherits <- base::inherits
[16:17:48.008]                       invokeRestart <- base::invokeRestart
[16:17:48.008]                       is.null <- base::is.null
[16:17:48.008]                       muffled <- FALSE
[16:17:48.008]                       if (inherits(cond, "message")) {
[16:17:48.008]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:48.008]                         if (muffled) 
[16:17:48.008]                           invokeRestart("muffleMessage")
[16:17:48.008]                       }
[16:17:48.008]                       else if (inherits(cond, "warning")) {
[16:17:48.008]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:48.008]                         if (muffled) 
[16:17:48.008]                           invokeRestart("muffleWarning")
[16:17:48.008]                       }
[16:17:48.008]                       else if (inherits(cond, "condition")) {
[16:17:48.008]                         if (!is.null(pattern)) {
[16:17:48.008]                           computeRestarts <- base::computeRestarts
[16:17:48.008]                           grepl <- base::grepl
[16:17:48.008]                           restarts <- computeRestarts(cond)
[16:17:48.008]                           for (restart in restarts) {
[16:17:48.008]                             name <- restart$name
[16:17:48.008]                             if (is.null(name)) 
[16:17:48.008]                               next
[16:17:48.008]                             if (!grepl(pattern, name)) 
[16:17:48.008]                               next
[16:17:48.008]                             invokeRestart(restart)
[16:17:48.008]                             muffled <- TRUE
[16:17:48.008]                             break
[16:17:48.008]                           }
[16:17:48.008]                         }
[16:17:48.008]                       }
[16:17:48.008]                       invisible(muffled)
[16:17:48.008]                     }
[16:17:48.008]                     muffleCondition(cond, pattern = "^muffle")
[16:17:48.008]                   }
[16:17:48.008]                 }
[16:17:48.008]                 else {
[16:17:48.008]                   if (TRUE) {
[16:17:48.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:48.008]                     {
[16:17:48.008]                       inherits <- base::inherits
[16:17:48.008]                       invokeRestart <- base::invokeRestart
[16:17:48.008]                       is.null <- base::is.null
[16:17:48.008]                       muffled <- FALSE
[16:17:48.008]                       if (inherits(cond, "message")) {
[16:17:48.008]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:48.008]                         if (muffled) 
[16:17:48.008]                           invokeRestart("muffleMessage")
[16:17:48.008]                       }
[16:17:48.008]                       else if (inherits(cond, "warning")) {
[16:17:48.008]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:48.008]                         if (muffled) 
[16:17:48.008]                           invokeRestart("muffleWarning")
[16:17:48.008]                       }
[16:17:48.008]                       else if (inherits(cond, "condition")) {
[16:17:48.008]                         if (!is.null(pattern)) {
[16:17:48.008]                           computeRestarts <- base::computeRestarts
[16:17:48.008]                           grepl <- base::grepl
[16:17:48.008]                           restarts <- computeRestarts(cond)
[16:17:48.008]                           for (restart in restarts) {
[16:17:48.008]                             name <- restart$name
[16:17:48.008]                             if (is.null(name)) 
[16:17:48.008]                               next
[16:17:48.008]                             if (!grepl(pattern, name)) 
[16:17:48.008]                               next
[16:17:48.008]                             invokeRestart(restart)
[16:17:48.008]                             muffled <- TRUE
[16:17:48.008]                             break
[16:17:48.008]                           }
[16:17:48.008]                         }
[16:17:48.008]                       }
[16:17:48.008]                       invisible(muffled)
[16:17:48.008]                     }
[16:17:48.008]                     muffleCondition(cond, pattern = "^muffle")
[16:17:48.008]                   }
[16:17:48.008]                 }
[16:17:48.008]             }
[16:17:48.008]         }))
[16:17:48.008]     }, error = function(ex) {
[16:17:48.008]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:48.008]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:48.008]                 ...future.rng), started = ...future.startTime, 
[16:17:48.008]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:48.008]             version = "1.8"), class = "FutureResult")
[16:17:48.008]     }, finally = {
[16:17:48.008]         if (!identical(...future.workdir, getwd())) 
[16:17:48.008]             setwd(...future.workdir)
[16:17:48.008]         {
[16:17:48.008]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:48.008]                 ...future.oldOptions$nwarnings <- NULL
[16:17:48.008]             }
[16:17:48.008]             base::options(...future.oldOptions)
[16:17:48.008]             if (.Platform$OS.type == "windows") {
[16:17:48.008]                 old_names <- names(...future.oldEnvVars)
[16:17:48.008]                 envs <- base::Sys.getenv()
[16:17:48.008]                 names <- names(envs)
[16:17:48.008]                 common <- intersect(names, old_names)
[16:17:48.008]                 added <- setdiff(names, old_names)
[16:17:48.008]                 removed <- setdiff(old_names, names)
[16:17:48.008]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:48.008]                   envs[common]]
[16:17:48.008]                 NAMES <- toupper(changed)
[16:17:48.008]                 args <- list()
[16:17:48.008]                 for (kk in seq_along(NAMES)) {
[16:17:48.008]                   name <- changed[[kk]]
[16:17:48.008]                   NAME <- NAMES[[kk]]
[16:17:48.008]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:48.008]                     next
[16:17:48.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:48.008]                 }
[16:17:48.008]                 NAMES <- toupper(added)
[16:17:48.008]                 for (kk in seq_along(NAMES)) {
[16:17:48.008]                   name <- added[[kk]]
[16:17:48.008]                   NAME <- NAMES[[kk]]
[16:17:48.008]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:48.008]                     next
[16:17:48.008]                   args[[name]] <- ""
[16:17:48.008]                 }
[16:17:48.008]                 NAMES <- toupper(removed)
[16:17:48.008]                 for (kk in seq_along(NAMES)) {
[16:17:48.008]                   name <- removed[[kk]]
[16:17:48.008]                   NAME <- NAMES[[kk]]
[16:17:48.008]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:48.008]                     next
[16:17:48.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:48.008]                 }
[16:17:48.008]                 if (length(args) > 0) 
[16:17:48.008]                   base::do.call(base::Sys.setenv, args = args)
[16:17:48.008]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:48.008]             }
[16:17:48.008]             else {
[16:17:48.008]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:48.008]             }
[16:17:48.008]             {
[16:17:48.008]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:48.008]                   0L) {
[16:17:48.008]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:48.008]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:48.008]                   base::options(opts)
[16:17:48.008]                 }
[16:17:48.008]                 {
[16:17:48.008]                   {
[16:17:48.008]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:48.008]                     NULL
[16:17:48.008]                   }
[16:17:48.008]                   options(future.plan = NULL)
[16:17:48.008]                   if (is.na(NA_character_)) 
[16:17:48.008]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:48.008]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:48.008]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:48.008]                     .init = FALSE)
[16:17:48.008]                 }
[16:17:48.008]             }
[16:17:48.008]         }
[16:17:48.008]     })
[16:17:48.008]     if (TRUE) {
[16:17:48.008]         base::sink(type = "output", split = FALSE)
[16:17:48.008]         if (TRUE) {
[16:17:48.008]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:48.008]         }
[16:17:48.008]         else {
[16:17:48.008]             ...future.result["stdout"] <- base::list(NULL)
[16:17:48.008]         }
[16:17:48.008]         base::close(...future.stdout)
[16:17:48.008]         ...future.stdout <- NULL
[16:17:48.008]     }
[16:17:48.008]     ...future.result$conditions <- ...future.conditions
[16:17:48.008]     ...future.result$finished <- base::Sys.time()
[16:17:48.008]     ...future.result
[16:17:48.008] }
[16:17:48.012] assign_globals() ...
[16:17:48.012] List of 5
[16:17:48.012]  $ ...future.FUN            :function (object, ...)  
[16:17:48.012]  $ future.call.arguments    : list()
[16:17:48.012]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:48.012]  $ ...future.elements_ii    :List of 2
[16:17:48.012]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:48.012]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:17:48.012]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:48.012]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:17:48.012]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:17:48.012]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:17:48.012]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:17:48.012]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:17:48.012]  $ ...future.seeds_ii       : NULL
[16:17:48.012]  $ ...future.globals.maxSize: NULL
[16:17:48.012]  - attr(*, "where")=List of 5
[16:17:48.012]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:48.012]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:48.012]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:48.012]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:48.012]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:48.012]  - attr(*, "resolved")= logi FALSE
[16:17:48.012]  - attr(*, "total_size")= num 1240
[16:17:48.012]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:48.012]  - attr(*, "already-done")= logi TRUE
[16:17:48.023] - copied ‘...future.FUN’ to environment
[16:17:48.023] - copied ‘future.call.arguments’ to environment
[16:17:48.024] - copied ‘...future.elements_ii’ to environment
[16:17:48.024] - copied ‘...future.seeds_ii’ to environment
[16:17:48.024] - copied ‘...future.globals.maxSize’ to environment
[16:17:48.024] assign_globals() ... done
[16:17:48.024] requestCore(): workers = 2
[16:17:48.027] MulticoreFuture started
[16:17:48.027] - Launch lazy future ... done
[16:17:48.028] run() for ‘MulticoreFuture’ ... done
[16:17:48.028] Created future:
[16:17:48.029] plan(): Setting new future strategy stack:
[16:17:48.029] List of future strategies:
[16:17:48.029] 1. sequential:
[16:17:48.029]    - args: function (..., envir = parent.frame())
[16:17:48.029]    - tweaked: FALSE
[16:17:48.029]    - call: NULL
[16:17:48.030] plan(): nbrOfWorkers() = 1
[16:17:48.034] plan(): Setting new future strategy stack:
[16:17:48.034] List of future strategies:
[16:17:48.034] 1. multicore:
[16:17:48.034]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:48.034]    - tweaked: FALSE
[16:17:48.034]    - call: plan(strategy)
[16:17:48.040] plan(): nbrOfWorkers() = 2
[16:17:48.028] MulticoreFuture:
[16:17:48.028] Label: ‘future_by-2’
[16:17:48.028] Expression:
[16:17:48.028] {
[16:17:48.028]     do.call(function(...) {
[16:17:48.028]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:48.028]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:48.028]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:48.028]             on.exit(options(oopts), add = TRUE)
[16:17:48.028]         }
[16:17:48.028]         {
[16:17:48.028]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:48.028]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:48.028]                 ...future.FUN(...future.X_jj, ...)
[16:17:48.028]             })
[16:17:48.028]         }
[16:17:48.028]     }, args = future.call.arguments)
[16:17:48.028] }
[16:17:48.028] Lazy evaluation: FALSE
[16:17:48.028] Asynchronous evaluation: TRUE
[16:17:48.028] Local evaluation: TRUE
[16:17:48.028] Environment: 0x55b569629098
[16:17:48.028] Capture standard output: TRUE
[16:17:48.028] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:48.028] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:48.028] Packages: <none>
[16:17:48.028] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:48.028] Resolved: TRUE
[16:17:48.028] Value: <not collected>
[16:17:48.028] Conditions captured: <none>
[16:17:48.028] Early signaling: FALSE
[16:17:48.028] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:48.028] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:48.041] Chunk #2 of 2 ... DONE
[16:17:48.041] Launching 2 futures (chunks) ... DONE
[16:17:48.041] Resolving 2 futures (chunks) ...
[16:17:48.041] resolve() on list ...
[16:17:48.041]  recursive: 0
[16:17:48.042]  length: 2
[16:17:48.042] 
[16:17:48.042] Future #1
[16:17:48.042] result() for MulticoreFuture ...
[16:17:48.043] result() for MulticoreFuture ...
[16:17:48.044] result() for MulticoreFuture ... done
[16:17:48.044] result() for MulticoreFuture ... done
[16:17:48.044] result() for MulticoreFuture ...
[16:17:48.044] result() for MulticoreFuture ... done
[16:17:48.044] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:17:48.044] - nx: 2
[16:17:48.045] - relay: TRUE
[16:17:48.045] - stdout: TRUE
[16:17:48.045] - signal: TRUE
[16:17:48.045] - resignal: FALSE
[16:17:48.045] - force: TRUE
[16:17:48.045] - relayed: [n=2] FALSE, FALSE
[16:17:48.045] - queued futures: [n=2] FALSE, FALSE
[16:17:48.046]  - until=1
[16:17:48.046]  - relaying element #1
[16:17:48.046] result() for MulticoreFuture ...
[16:17:48.046] result() for MulticoreFuture ... done
[16:17:48.046] result() for MulticoreFuture ...
[16:17:48.046] result() for MulticoreFuture ... done
[16:17:48.047] result() for MulticoreFuture ...
[16:17:48.047] result() for MulticoreFuture ... done
[16:17:48.047] result() for MulticoreFuture ...
[16:17:48.047] result() for MulticoreFuture ... done
[16:17:48.047] - relayed: [n=2] TRUE, FALSE
[16:17:48.047] - queued futures: [n=2] TRUE, FALSE
[16:17:48.047] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:17:48.048]  length: 1 (resolved future 1)
[16:17:48.048] Future #2
[16:17:48.048] result() for MulticoreFuture ...
[16:17:48.049] result() for MulticoreFuture ...
[16:17:48.049] result() for MulticoreFuture ... done
[16:17:48.049] result() for MulticoreFuture ... done
[16:17:48.049] result() for MulticoreFuture ...
[16:17:48.050] result() for MulticoreFuture ... done
[16:17:48.050] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:17:48.050] - nx: 2
[16:17:48.050] - relay: TRUE
[16:17:48.050] - stdout: TRUE
[16:17:48.051] - signal: TRUE
[16:17:48.051] - resignal: FALSE
[16:17:48.051] - force: TRUE
[16:17:48.051] - relayed: [n=2] TRUE, FALSE
[16:17:48.051] - queued futures: [n=2] TRUE, FALSE
[16:17:48.051]  - until=2
[16:17:48.051]  - relaying element #2
[16:17:48.052] result() for MulticoreFuture ...
[16:17:48.052] result() for MulticoreFuture ... done
[16:17:48.052] result() for MulticoreFuture ...
[16:17:48.052] result() for MulticoreFuture ... done
[16:17:48.052] result() for MulticoreFuture ...
[16:17:48.052] result() for MulticoreFuture ... done
[16:17:48.053] result() for MulticoreFuture ...
[16:17:48.053] result() for MulticoreFuture ... done
[16:17:48.053] - relayed: [n=2] TRUE, TRUE
[16:17:48.053] - queued futures: [n=2] TRUE, TRUE
[16:17:48.053] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:17:48.053]  length: 0 (resolved future 2)
[16:17:48.053] Relaying remaining futures
[16:17:48.053] signalConditionsASAP(NULL, pos=0) ...
[16:17:48.053] - nx: 2
[16:17:48.054] - relay: TRUE
[16:17:48.054] - stdout: TRUE
[16:17:48.054] - signal: TRUE
[16:17:48.054] - resignal: FALSE
[16:17:48.054] - force: TRUE
[16:17:48.054] - relayed: [n=2] TRUE, TRUE
[16:17:48.054] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:48.054] - relayed: [n=2] TRUE, TRUE
[16:17:48.054] - queued futures: [n=2] TRUE, TRUE
[16:17:48.054] signalConditionsASAP(NULL, pos=0) ... done
[16:17:48.055] resolve() on list ... DONE
[16:17:48.055] result() for MulticoreFuture ...
[16:17:48.055] result() for MulticoreFuture ... done
[16:17:48.055] result() for MulticoreFuture ...
[16:17:48.055] result() for MulticoreFuture ... done
[16:17:48.055] result() for MulticoreFuture ...
[16:17:48.055] result() for MulticoreFuture ... done
[16:17:48.055] result() for MulticoreFuture ...
[16:17:48.055] result() for MulticoreFuture ... done
[16:17:48.056]  - Number of value chunks collected: 2
[16:17:48.056] Resolving 2 futures (chunks) ... DONE
[16:17:48.056] Reducing values from 2 chunks ...
[16:17:48.056]  - Number of values collected after concatenation: 3
[16:17:48.056]  - Number of values expected: 3
[16:17:48.056] Reducing values from 2 chunks ... DONE
[16:17:48.056] future_lapply() ... DONE
[16:17:48.056] future_by_internal() ... DONE
[16:17:48.058] future_by_internal() ...
- plan('multisession') ...
[16:17:48.058] plan(): Setting new future strategy stack:
[16:17:48.058] List of future strategies:
[16:17:48.058] 1. multisession:
[16:17:48.058]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:17:48.058]    - tweaked: FALSE
[16:17:48.058]    - call: plan(strategy)
[16:17:48.059] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:17:48.059] multisession:
[16:17:48.059] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:17:48.059] - tweaked: FALSE
[16:17:48.059] - call: plan(strategy)
[16:17:48.066] getGlobalsAndPackages() ...
[16:17:48.066] Not searching for globals
[16:17:48.066] - globals: [0] <none>
[16:17:48.066] getGlobalsAndPackages() ... DONE
[16:17:48.067] [local output] makeClusterPSOCK() ...
[16:17:48.117] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:17:48.118] [local output] Base port: 11305
[16:17:48.118] [local output] Getting setup options for 2 cluster nodes ...
[16:17:48.118] [local output]  - Node 1 of 2 ...
[16:17:48.119] [local output] localMachine=TRUE => revtunnel=FALSE

[16:17:48.119] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp1cUuyG/worker.rank=1.parallelly.parent=68149.10a3526cc80fb.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp1cUuyG/worker.rank=1.parallelly.parent=68149.10a3526cc80fb.pid")'’
[16:17:48.308] - Possible to infer worker's PID: TRUE
[16:17:48.309] [local output] Rscript port: 11305

[16:17:48.309] [local output]  - Node 2 of 2 ...
[16:17:48.309] [local output] localMachine=TRUE => revtunnel=FALSE

[16:17:48.310] [local output] Rscript port: 11305

[16:17:48.310] [local output] Getting setup options for 2 cluster nodes ... done
[16:17:48.310] [local output]  - Parallel setup requested for some PSOCK nodes
[16:17:48.311] [local output] Setting up PSOCK nodes in parallel
[16:17:48.311] List of 36
[16:17:48.311]  $ worker          : chr "localhost"
[16:17:48.311]   ..- attr(*, "localhost")= logi TRUE
[16:17:48.311]  $ master          : chr "localhost"
[16:17:48.311]  $ port            : int 11305
[16:17:48.311]  $ connectTimeout  : num 120
[16:17:48.311]  $ timeout         : num 2592000
[16:17:48.311]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:17:48.311]  $ homogeneous     : logi TRUE
[16:17:48.311]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:17:48.311]  $ rscript_envs    : NULL
[16:17:48.311]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:17:48.311]  $ rscript_startup : NULL
[16:17:48.311]  $ rscript_sh      : chr "sh"
[16:17:48.311]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:17:48.311]  $ methods         : logi TRUE
[16:17:48.311]  $ socketOptions   : chr "no-delay"
[16:17:48.311]  $ useXDR          : logi FALSE
[16:17:48.311]  $ outfile         : chr "/dev/null"
[16:17:48.311]  $ renice          : int NA
[16:17:48.311]  $ rshcmd          : NULL
[16:17:48.311]  $ user            : chr(0) 
[16:17:48.311]  $ revtunnel       : logi FALSE
[16:17:48.311]  $ rshlogfile      : NULL
[16:17:48.311]  $ rshopts         : chr(0) 
[16:17:48.311]  $ rank            : int 1
[16:17:48.311]  $ manual          : logi FALSE
[16:17:48.311]  $ dryrun          : logi FALSE
[16:17:48.311]  $ quiet           : logi FALSE
[16:17:48.311]  $ setup_strategy  : chr "parallel"
[16:17:48.311]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:17:48.311]  $ pidfile         : chr "/tmp/Rtmp1cUuyG/worker.rank=1.parallelly.parent=68149.10a3526cc80fb.pid"
[16:17:48.311]  $ rshcmd_label    : NULL
[16:17:48.311]  $ rsh_call        : NULL
[16:17:48.311]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:17:48.311]  $ localMachine    : logi TRUE
[16:17:48.311]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:17:48.311]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:17:48.311]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:17:48.311]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:17:48.311]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:17:48.311]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:17:48.311]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:17:48.311]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:17:48.311]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:17:48.311]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:17:48.311]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:17:48.311]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:17:48.311]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:17:48.311]  $ arguments       :List of 28
[16:17:48.311]   ..$ worker          : chr "localhost"
[16:17:48.311]   ..$ master          : NULL
[16:17:48.311]   ..$ port            : int 11305
[16:17:48.311]   ..$ connectTimeout  : num 120
[16:17:48.311]   ..$ timeout         : num 2592000
[16:17:48.311]   ..$ rscript         : NULL
[16:17:48.311]   ..$ homogeneous     : NULL
[16:17:48.311]   ..$ rscript_args    : NULL
[16:17:48.311]   ..$ rscript_envs    : NULL
[16:17:48.311]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:17:48.311]   ..$ rscript_startup : NULL
[16:17:48.311]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:17:48.311]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:17:48.311]   ..$ methods         : logi TRUE
[16:17:48.311]   ..$ socketOptions   : chr "no-delay"
[16:17:48.311]   ..$ useXDR          : logi FALSE
[16:17:48.311]   ..$ outfile         : chr "/dev/null"
[16:17:48.311]   ..$ renice          : int NA
[16:17:48.311]   ..$ rshcmd          : NULL
[16:17:48.311]   ..$ user            : NULL
[16:17:48.311]   ..$ revtunnel       : logi NA
[16:17:48.311]   ..$ rshlogfile      : NULL
[16:17:48.311]   ..$ rshopts         : NULL
[16:17:48.311]   ..$ rank            : int 1
[16:17:48.311]   ..$ manual          : logi FALSE
[16:17:48.311]   ..$ dryrun          : logi FALSE
[16:17:48.311]   ..$ quiet           : logi FALSE
[16:17:48.311]   ..$ setup_strategy  : chr "parallel"
[16:17:48.311]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:17:48.328] [local output] System call to launch all workers:
[16:17:48.328] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp1cUuyG/worker.rank=1.parallelly.parent=68149.10a3526cc80fb.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11305 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:17:48.328] [local output] Starting PSOCK main server
[16:17:48.334] [local output] Workers launched
[16:17:48.334] [local output] Waiting for workers to connect back
[16:17:48.334]  - [local output] 0 workers out of 2 ready
[16:17:48.597]  - [local output] 0 workers out of 2 ready
[16:17:48.597]  - [local output] 1 workers out of 2 ready
[16:17:48.601]  - [local output] 1 workers out of 2 ready
[16:17:48.602]  - [local output] 2 workers out of 2 ready
[16:17:48.602] [local output] Launching of workers completed
[16:17:48.602] [local output] Collecting session information from workers
[16:17:48.603] [local output]  - Worker #1 of 2
[16:17:48.603] [local output]  - Worker #2 of 2
[16:17:48.603] [local output] makeClusterPSOCK() ... done
[16:17:48.614] Packages needed by the future expression (n = 0): <none>
[16:17:48.614] Packages needed by future strategies (n = 0): <none>
[16:17:48.615] {
[16:17:48.615]     {
[16:17:48.615]         {
[16:17:48.615]             ...future.startTime <- base::Sys.time()
[16:17:48.615]             {
[16:17:48.615]                 {
[16:17:48.615]                   {
[16:17:48.615]                     {
[16:17:48.615]                       base::local({
[16:17:48.615]                         has_future <- base::requireNamespace("future", 
[16:17:48.615]                           quietly = TRUE)
[16:17:48.615]                         if (has_future) {
[16:17:48.615]                           ns <- base::getNamespace("future")
[16:17:48.615]                           version <- ns[[".package"]][["version"]]
[16:17:48.615]                           if (is.null(version)) 
[16:17:48.615]                             version <- utils::packageVersion("future")
[16:17:48.615]                         }
[16:17:48.615]                         else {
[16:17:48.615]                           version <- NULL
[16:17:48.615]                         }
[16:17:48.615]                         if (!has_future || version < "1.8.0") {
[16:17:48.615]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:48.615]                             "", base::R.version$version.string), 
[16:17:48.615]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:48.615]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:48.615]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:48.615]                               "release", "version")], collapse = " "), 
[16:17:48.615]                             hostname = base::Sys.info()[["nodename"]])
[16:17:48.615]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:48.615]                             info)
[16:17:48.615]                           info <- base::paste(info, collapse = "; ")
[16:17:48.615]                           if (!has_future) {
[16:17:48.615]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:48.615]                               info)
[16:17:48.615]                           }
[16:17:48.615]                           else {
[16:17:48.615]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:48.615]                               info, version)
[16:17:48.615]                           }
[16:17:48.615]                           base::stop(msg)
[16:17:48.615]                         }
[16:17:48.615]                       })
[16:17:48.615]                     }
[16:17:48.615]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:48.615]                     base::options(mc.cores = 1L)
[16:17:48.615]                   }
[16:17:48.615]                   ...future.strategy.old <- future::plan("list")
[16:17:48.615]                   options(future.plan = NULL)
[16:17:48.615]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:48.615]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:48.615]                 }
[16:17:48.615]                 ...future.workdir <- getwd()
[16:17:48.615]             }
[16:17:48.615]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:48.615]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:48.615]         }
[16:17:48.615]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:48.615]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:48.615]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:48.615]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:48.615]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:48.615]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:48.615]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:48.615]             base::names(...future.oldOptions))
[16:17:48.615]     }
[16:17:48.615]     if (FALSE) {
[16:17:48.615]     }
[16:17:48.615]     else {
[16:17:48.615]         if (TRUE) {
[16:17:48.615]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:48.615]                 open = "w")
[16:17:48.615]         }
[16:17:48.615]         else {
[16:17:48.615]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:48.615]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:48.615]         }
[16:17:48.615]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:48.615]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:48.615]             base::sink(type = "output", split = FALSE)
[16:17:48.615]             base::close(...future.stdout)
[16:17:48.615]         }, add = TRUE)
[16:17:48.615]     }
[16:17:48.615]     ...future.frame <- base::sys.nframe()
[16:17:48.615]     ...future.conditions <- base::list()
[16:17:48.615]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:48.615]     if (FALSE) {
[16:17:48.615]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:48.615]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:48.615]     }
[16:17:48.615]     ...future.result <- base::tryCatch({
[16:17:48.615]         base::withCallingHandlers({
[16:17:48.615]             ...future.value <- base::withVisible(base::local({
[16:17:48.615]                 ...future.makeSendCondition <- base::local({
[16:17:48.615]                   sendCondition <- NULL
[16:17:48.615]                   function(frame = 1L) {
[16:17:48.615]                     if (is.function(sendCondition)) 
[16:17:48.615]                       return(sendCondition)
[16:17:48.615]                     ns <- getNamespace("parallel")
[16:17:48.615]                     if (exists("sendData", mode = "function", 
[16:17:48.615]                       envir = ns)) {
[16:17:48.615]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:48.615]                         envir = ns)
[16:17:48.615]                       envir <- sys.frame(frame)
[16:17:48.615]                       master <- NULL
[16:17:48.615]                       while (!identical(envir, .GlobalEnv) && 
[16:17:48.615]                         !identical(envir, emptyenv())) {
[16:17:48.615]                         if (exists("master", mode = "list", envir = envir, 
[16:17:48.615]                           inherits = FALSE)) {
[16:17:48.615]                           master <- get("master", mode = "list", 
[16:17:48.615]                             envir = envir, inherits = FALSE)
[16:17:48.615]                           if (inherits(master, c("SOCKnode", 
[16:17:48.615]                             "SOCK0node"))) {
[16:17:48.615]                             sendCondition <<- function(cond) {
[16:17:48.615]                               data <- list(type = "VALUE", value = cond, 
[16:17:48.615]                                 success = TRUE)
[16:17:48.615]                               parallel_sendData(master, data)
[16:17:48.615]                             }
[16:17:48.615]                             return(sendCondition)
[16:17:48.615]                           }
[16:17:48.615]                         }
[16:17:48.615]                         frame <- frame + 1L
[16:17:48.615]                         envir <- sys.frame(frame)
[16:17:48.615]                       }
[16:17:48.615]                     }
[16:17:48.615]                     sendCondition <<- function(cond) NULL
[16:17:48.615]                   }
[16:17:48.615]                 })
[16:17:48.615]                 withCallingHandlers({
[16:17:48.615]                   NA
[16:17:48.615]                 }, immediateCondition = function(cond) {
[16:17:48.615]                   sendCondition <- ...future.makeSendCondition()
[16:17:48.615]                   sendCondition(cond)
[16:17:48.615]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:48.615]                   {
[16:17:48.615]                     inherits <- base::inherits
[16:17:48.615]                     invokeRestart <- base::invokeRestart
[16:17:48.615]                     is.null <- base::is.null
[16:17:48.615]                     muffled <- FALSE
[16:17:48.615]                     if (inherits(cond, "message")) {
[16:17:48.615]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:48.615]                       if (muffled) 
[16:17:48.615]                         invokeRestart("muffleMessage")
[16:17:48.615]                     }
[16:17:48.615]                     else if (inherits(cond, "warning")) {
[16:17:48.615]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:48.615]                       if (muffled) 
[16:17:48.615]                         invokeRestart("muffleWarning")
[16:17:48.615]                     }
[16:17:48.615]                     else if (inherits(cond, "condition")) {
[16:17:48.615]                       if (!is.null(pattern)) {
[16:17:48.615]                         computeRestarts <- base::computeRestarts
[16:17:48.615]                         grepl <- base::grepl
[16:17:48.615]                         restarts <- computeRestarts(cond)
[16:17:48.615]                         for (restart in restarts) {
[16:17:48.615]                           name <- restart$name
[16:17:48.615]                           if (is.null(name)) 
[16:17:48.615]                             next
[16:17:48.615]                           if (!grepl(pattern, name)) 
[16:17:48.615]                             next
[16:17:48.615]                           invokeRestart(restart)
[16:17:48.615]                           muffled <- TRUE
[16:17:48.615]                           break
[16:17:48.615]                         }
[16:17:48.615]                       }
[16:17:48.615]                     }
[16:17:48.615]                     invisible(muffled)
[16:17:48.615]                   }
[16:17:48.615]                   muffleCondition(cond)
[16:17:48.615]                 })
[16:17:48.615]             }))
[16:17:48.615]             future::FutureResult(value = ...future.value$value, 
[16:17:48.615]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:48.615]                   ...future.rng), globalenv = if (FALSE) 
[16:17:48.615]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:48.615]                     ...future.globalenv.names))
[16:17:48.615]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:48.615]         }, condition = base::local({
[16:17:48.615]             c <- base::c
[16:17:48.615]             inherits <- base::inherits
[16:17:48.615]             invokeRestart <- base::invokeRestart
[16:17:48.615]             length <- base::length
[16:17:48.615]             list <- base::list
[16:17:48.615]             seq.int <- base::seq.int
[16:17:48.615]             signalCondition <- base::signalCondition
[16:17:48.615]             sys.calls <- base::sys.calls
[16:17:48.615]             `[[` <- base::`[[`
[16:17:48.615]             `+` <- base::`+`
[16:17:48.615]             `<<-` <- base::`<<-`
[16:17:48.615]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:48.615]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:48.615]                   3L)]
[16:17:48.615]             }
[16:17:48.615]             function(cond) {
[16:17:48.615]                 is_error <- inherits(cond, "error")
[16:17:48.615]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:48.615]                   NULL)
[16:17:48.615]                 if (is_error) {
[16:17:48.615]                   sessionInformation <- function() {
[16:17:48.615]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:48.615]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:48.615]                       search = base::search(), system = base::Sys.info())
[16:17:48.615]                   }
[16:17:48.615]                   ...future.conditions[[length(...future.conditions) + 
[16:17:48.615]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:48.615]                     cond$call), session = sessionInformation(), 
[16:17:48.615]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:48.615]                   signalCondition(cond)
[16:17:48.615]                 }
[16:17:48.615]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:48.615]                 "immediateCondition"))) {
[16:17:48.615]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:48.615]                   ...future.conditions[[length(...future.conditions) + 
[16:17:48.615]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:48.615]                   if (TRUE && !signal) {
[16:17:48.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:48.615]                     {
[16:17:48.615]                       inherits <- base::inherits
[16:17:48.615]                       invokeRestart <- base::invokeRestart
[16:17:48.615]                       is.null <- base::is.null
[16:17:48.615]                       muffled <- FALSE
[16:17:48.615]                       if (inherits(cond, "message")) {
[16:17:48.615]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:48.615]                         if (muffled) 
[16:17:48.615]                           invokeRestart("muffleMessage")
[16:17:48.615]                       }
[16:17:48.615]                       else if (inherits(cond, "warning")) {
[16:17:48.615]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:48.615]                         if (muffled) 
[16:17:48.615]                           invokeRestart("muffleWarning")
[16:17:48.615]                       }
[16:17:48.615]                       else if (inherits(cond, "condition")) {
[16:17:48.615]                         if (!is.null(pattern)) {
[16:17:48.615]                           computeRestarts <- base::computeRestarts
[16:17:48.615]                           grepl <- base::grepl
[16:17:48.615]                           restarts <- computeRestarts(cond)
[16:17:48.615]                           for (restart in restarts) {
[16:17:48.615]                             name <- restart$name
[16:17:48.615]                             if (is.null(name)) 
[16:17:48.615]                               next
[16:17:48.615]                             if (!grepl(pattern, name)) 
[16:17:48.615]                               next
[16:17:48.615]                             invokeRestart(restart)
[16:17:48.615]                             muffled <- TRUE
[16:17:48.615]                             break
[16:17:48.615]                           }
[16:17:48.615]                         }
[16:17:48.615]                       }
[16:17:48.615]                       invisible(muffled)
[16:17:48.615]                     }
[16:17:48.615]                     muffleCondition(cond, pattern = "^muffle")
[16:17:48.615]                   }
[16:17:48.615]                 }
[16:17:48.615]                 else {
[16:17:48.615]                   if (TRUE) {
[16:17:48.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:48.615]                     {
[16:17:48.615]                       inherits <- base::inherits
[16:17:48.615]                       invokeRestart <- base::invokeRestart
[16:17:48.615]                       is.null <- base::is.null
[16:17:48.615]                       muffled <- FALSE
[16:17:48.615]                       if (inherits(cond, "message")) {
[16:17:48.615]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:48.615]                         if (muffled) 
[16:17:48.615]                           invokeRestart("muffleMessage")
[16:17:48.615]                       }
[16:17:48.615]                       else if (inherits(cond, "warning")) {
[16:17:48.615]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:48.615]                         if (muffled) 
[16:17:48.615]                           invokeRestart("muffleWarning")
[16:17:48.615]                       }
[16:17:48.615]                       else if (inherits(cond, "condition")) {
[16:17:48.615]                         if (!is.null(pattern)) {
[16:17:48.615]                           computeRestarts <- base::computeRestarts
[16:17:48.615]                           grepl <- base::grepl
[16:17:48.615]                           restarts <- computeRestarts(cond)
[16:17:48.615]                           for (restart in restarts) {
[16:17:48.615]                             name <- restart$name
[16:17:48.615]                             if (is.null(name)) 
[16:17:48.615]                               next
[16:17:48.615]                             if (!grepl(pattern, name)) 
[16:17:48.615]                               next
[16:17:48.615]                             invokeRestart(restart)
[16:17:48.615]                             muffled <- TRUE
[16:17:48.615]                             break
[16:17:48.615]                           }
[16:17:48.615]                         }
[16:17:48.615]                       }
[16:17:48.615]                       invisible(muffled)
[16:17:48.615]                     }
[16:17:48.615]                     muffleCondition(cond, pattern = "^muffle")
[16:17:48.615]                   }
[16:17:48.615]                 }
[16:17:48.615]             }
[16:17:48.615]         }))
[16:17:48.615]     }, error = function(ex) {
[16:17:48.615]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:48.615]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:48.615]                 ...future.rng), started = ...future.startTime, 
[16:17:48.615]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:48.615]             version = "1.8"), class = "FutureResult")
[16:17:48.615]     }, finally = {
[16:17:48.615]         if (!identical(...future.workdir, getwd())) 
[16:17:48.615]             setwd(...future.workdir)
[16:17:48.615]         {
[16:17:48.615]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:48.615]                 ...future.oldOptions$nwarnings <- NULL
[16:17:48.615]             }
[16:17:48.615]             base::options(...future.oldOptions)
[16:17:48.615]             if (.Platform$OS.type == "windows") {
[16:17:48.615]                 old_names <- names(...future.oldEnvVars)
[16:17:48.615]                 envs <- base::Sys.getenv()
[16:17:48.615]                 names <- names(envs)
[16:17:48.615]                 common <- intersect(names, old_names)
[16:17:48.615]                 added <- setdiff(names, old_names)
[16:17:48.615]                 removed <- setdiff(old_names, names)
[16:17:48.615]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:48.615]                   envs[common]]
[16:17:48.615]                 NAMES <- toupper(changed)
[16:17:48.615]                 args <- list()
[16:17:48.615]                 for (kk in seq_along(NAMES)) {
[16:17:48.615]                   name <- changed[[kk]]
[16:17:48.615]                   NAME <- NAMES[[kk]]
[16:17:48.615]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:48.615]                     next
[16:17:48.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:48.615]                 }
[16:17:48.615]                 NAMES <- toupper(added)
[16:17:48.615]                 for (kk in seq_along(NAMES)) {
[16:17:48.615]                   name <- added[[kk]]
[16:17:48.615]                   NAME <- NAMES[[kk]]
[16:17:48.615]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:48.615]                     next
[16:17:48.615]                   args[[name]] <- ""
[16:17:48.615]                 }
[16:17:48.615]                 NAMES <- toupper(removed)
[16:17:48.615]                 for (kk in seq_along(NAMES)) {
[16:17:48.615]                   name <- removed[[kk]]
[16:17:48.615]                   NAME <- NAMES[[kk]]
[16:17:48.615]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:48.615]                     next
[16:17:48.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:48.615]                 }
[16:17:48.615]                 if (length(args) > 0) 
[16:17:48.615]                   base::do.call(base::Sys.setenv, args = args)
[16:17:48.615]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:48.615]             }
[16:17:48.615]             else {
[16:17:48.615]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:48.615]             }
[16:17:48.615]             {
[16:17:48.615]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:48.615]                   0L) {
[16:17:48.615]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:48.615]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:48.615]                   base::options(opts)
[16:17:48.615]                 }
[16:17:48.615]                 {
[16:17:48.615]                   {
[16:17:48.615]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:48.615]                     NULL
[16:17:48.615]                   }
[16:17:48.615]                   options(future.plan = NULL)
[16:17:48.615]                   if (is.na(NA_character_)) 
[16:17:48.615]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:48.615]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:48.615]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:48.615]                     .init = FALSE)
[16:17:48.615]                 }
[16:17:48.615]             }
[16:17:48.615]         }
[16:17:48.615]     })
[16:17:48.615]     if (TRUE) {
[16:17:48.615]         base::sink(type = "output", split = FALSE)
[16:17:48.615]         if (TRUE) {
[16:17:48.615]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:48.615]         }
[16:17:48.615]         else {
[16:17:48.615]             ...future.result["stdout"] <- base::list(NULL)
[16:17:48.615]         }
[16:17:48.615]         base::close(...future.stdout)
[16:17:48.615]         ...future.stdout <- NULL
[16:17:48.615]     }
[16:17:48.615]     ...future.result$conditions <- ...future.conditions
[16:17:48.615]     ...future.result$finished <- base::Sys.time()
[16:17:48.615]     ...future.result
[16:17:48.615] }
[16:17:48.667] MultisessionFuture started
[16:17:48.667] result() for ClusterFuture ...
[16:17:48.668] receiveMessageFromWorker() for ClusterFuture ...
[16:17:48.668] - Validating connection of MultisessionFuture
[16:17:48.701] - received message: FutureResult
[16:17:48.701] - Received FutureResult
[16:17:48.701] - Erased future from FutureRegistry
[16:17:48.701] result() for ClusterFuture ...
[16:17:48.701] - result already collected: FutureResult
[16:17:48.701] result() for ClusterFuture ... done
[16:17:48.701] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:48.701] result() for ClusterFuture ... done
[16:17:48.702] result() for ClusterFuture ...
[16:17:48.702] - result already collected: FutureResult
[16:17:48.702] result() for ClusterFuture ... done
[16:17:48.702] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:17:48.706] plan(): nbrOfWorkers() = 2
[16:17:48.706] future_by_internal() ...
[16:17:48.706] future_lapply() ...
[16:17:48.710] Number of chunks: 2
[16:17:48.710] getGlobalsAndPackagesXApply() ...
[16:17:48.710]  - future.globals: TRUE
[16:17:48.710] getGlobalsAndPackages() ...
[16:17:48.710] Searching for globals...
[16:17:48.711] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:48.711] Searching for globals ... DONE
[16:17:48.712] Resolving globals: FALSE
[16:17:48.712] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:48.712] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:48.712] - globals: [1] ‘FUN’
[16:17:48.713] 
[16:17:48.713] getGlobalsAndPackages() ... DONE
[16:17:48.713]  - globals found/used: [n=1] ‘FUN’
[16:17:48.713]  - needed namespaces: [n=0] 
[16:17:48.713] Finding globals ... DONE
[16:17:48.713]  - use_args: TRUE
[16:17:48.713]  - Getting '...' globals ...
[16:17:48.713] resolve() on list ...
[16:17:48.714]  recursive: 0
[16:17:48.714]  length: 1
[16:17:48.714]  elements: ‘...’
[16:17:48.714]  length: 0 (resolved future 1)
[16:17:48.714] resolve() on list ... DONE
[16:17:48.714]    - '...' content: [n=0] 
[16:17:48.714] List of 1
[16:17:48.714]  $ ...: list()
[16:17:48.714]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:48.714]  - attr(*, "where")=List of 1
[16:17:48.714]   ..$ ...:<environment: 0x55b5692d97c8> 
[16:17:48.714]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:48.714]  - attr(*, "resolved")= logi TRUE
[16:17:48.714]  - attr(*, "total_size")= num NA
[16:17:48.717]  - Getting '...' globals ... DONE
[16:17:48.717] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:48.717] List of 2
[16:17:48.717]  $ ...future.FUN:function (object, ...)  
[16:17:48.717]  $ ...          : list()
[16:17:48.717]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:48.717]  - attr(*, "where")=List of 2
[16:17:48.717]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:48.717]   ..$ ...          :<environment: 0x55b5692d97c8> 
[16:17:48.717]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:48.717]  - attr(*, "resolved")= logi FALSE
[16:17:48.717]  - attr(*, "total_size")= num 1240
[16:17:48.719] Packages to be attached in all futures: [n=0] 
[16:17:48.719] getGlobalsAndPackagesXApply() ... DONE
[16:17:48.720] Number of futures (= number of chunks): 2
[16:17:48.720] Launching 2 futures (chunks) ...
[16:17:48.720] Chunk #1 of 2 ...
[16:17:48.720]  - Finding globals in 'X' for chunk #1 ...
[16:17:48.720] getGlobalsAndPackages() ...
[16:17:48.720] Searching for globals...
[16:17:48.721] 
[16:17:48.721] Searching for globals ... DONE
[16:17:48.721] - globals: [0] <none>
[16:17:48.721] getGlobalsAndPackages() ... DONE
[16:17:48.721]    + additional globals found: [n=0] 
[16:17:48.721]    + additional namespaces needed: [n=0] 
[16:17:48.721]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:48.721]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:48.721]  - seeds: <none>
[16:17:48.721]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:48.722] getGlobalsAndPackages() ...
[16:17:48.722] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:48.722] Resolving globals: FALSE
[16:17:48.722] Tweak future expression to call with '...' arguments ...
[16:17:48.722] {
[16:17:48.722]     do.call(function(...) {
[16:17:48.722]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:48.722]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:48.722]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:48.722]             on.exit(options(oopts), add = TRUE)
[16:17:48.722]         }
[16:17:48.722]         {
[16:17:48.722]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:48.722]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:48.722]                 ...future.FUN(...future.X_jj, ...)
[16:17:48.722]             })
[16:17:48.722]         }
[16:17:48.722]     }, args = future.call.arguments)
[16:17:48.722] }
[16:17:48.722] Tweak future expression to call with '...' arguments ... DONE
[16:17:48.723] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:48.723] 
[16:17:48.723] getGlobalsAndPackages() ... DONE
[16:17:48.723] run() for ‘Future’ ...
[16:17:48.723] - state: ‘created’
[16:17:48.723] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:48.737] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:48.737] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:48.737]   - Field: ‘node’
[16:17:48.737]   - Field: ‘label’
[16:17:48.737]   - Field: ‘local’
[16:17:48.737]   - Field: ‘owner’
[16:17:48.737]   - Field: ‘envir’
[16:17:48.738]   - Field: ‘workers’
[16:17:48.738]   - Field: ‘packages’
[16:17:48.738]   - Field: ‘gc’
[16:17:48.738]   - Field: ‘conditions’
[16:17:48.738]   - Field: ‘persistent’
[16:17:48.738]   - Field: ‘expr’
[16:17:48.738]   - Field: ‘uuid’
[16:17:48.738]   - Field: ‘seed’
[16:17:48.738]   - Field: ‘version’
[16:17:48.738]   - Field: ‘result’
[16:17:48.738]   - Field: ‘asynchronous’
[16:17:48.739]   - Field: ‘calls’
[16:17:48.739]   - Field: ‘globals’
[16:17:48.739]   - Field: ‘stdout’
[16:17:48.739]   - Field: ‘earlySignal’
[16:17:48.739]   - Field: ‘lazy’
[16:17:48.739]   - Field: ‘state’
[16:17:48.739] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:48.739] - Launch lazy future ...
[16:17:48.739] Packages needed by the future expression (n = 0): <none>
[16:17:48.740] Packages needed by future strategies (n = 0): <none>
[16:17:48.740] {
[16:17:48.740]     {
[16:17:48.740]         {
[16:17:48.740]             ...future.startTime <- base::Sys.time()
[16:17:48.740]             {
[16:17:48.740]                 {
[16:17:48.740]                   {
[16:17:48.740]                     {
[16:17:48.740]                       base::local({
[16:17:48.740]                         has_future <- base::requireNamespace("future", 
[16:17:48.740]                           quietly = TRUE)
[16:17:48.740]                         if (has_future) {
[16:17:48.740]                           ns <- base::getNamespace("future")
[16:17:48.740]                           version <- ns[[".package"]][["version"]]
[16:17:48.740]                           if (is.null(version)) 
[16:17:48.740]                             version <- utils::packageVersion("future")
[16:17:48.740]                         }
[16:17:48.740]                         else {
[16:17:48.740]                           version <- NULL
[16:17:48.740]                         }
[16:17:48.740]                         if (!has_future || version < "1.8.0") {
[16:17:48.740]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:48.740]                             "", base::R.version$version.string), 
[16:17:48.740]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:48.740]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:48.740]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:48.740]                               "release", "version")], collapse = " "), 
[16:17:48.740]                             hostname = base::Sys.info()[["nodename"]])
[16:17:48.740]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:48.740]                             info)
[16:17:48.740]                           info <- base::paste(info, collapse = "; ")
[16:17:48.740]                           if (!has_future) {
[16:17:48.740]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:48.740]                               info)
[16:17:48.740]                           }
[16:17:48.740]                           else {
[16:17:48.740]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:48.740]                               info, version)
[16:17:48.740]                           }
[16:17:48.740]                           base::stop(msg)
[16:17:48.740]                         }
[16:17:48.740]                       })
[16:17:48.740]                     }
[16:17:48.740]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:48.740]                     base::options(mc.cores = 1L)
[16:17:48.740]                   }
[16:17:48.740]                   ...future.strategy.old <- future::plan("list")
[16:17:48.740]                   options(future.plan = NULL)
[16:17:48.740]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:48.740]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:48.740]                 }
[16:17:48.740]                 ...future.workdir <- getwd()
[16:17:48.740]             }
[16:17:48.740]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:48.740]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:48.740]         }
[16:17:48.740]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:48.740]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:48.740]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:48.740]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:48.740]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:48.740]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:48.740]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:48.740]             base::names(...future.oldOptions))
[16:17:48.740]     }
[16:17:48.740]     if (FALSE) {
[16:17:48.740]     }
[16:17:48.740]     else {
[16:17:48.740]         if (TRUE) {
[16:17:48.740]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:48.740]                 open = "w")
[16:17:48.740]         }
[16:17:48.740]         else {
[16:17:48.740]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:48.740]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:48.740]         }
[16:17:48.740]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:48.740]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:48.740]             base::sink(type = "output", split = FALSE)
[16:17:48.740]             base::close(...future.stdout)
[16:17:48.740]         }, add = TRUE)
[16:17:48.740]     }
[16:17:48.740]     ...future.frame <- base::sys.nframe()
[16:17:48.740]     ...future.conditions <- base::list()
[16:17:48.740]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:48.740]     if (FALSE) {
[16:17:48.740]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:48.740]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:48.740]     }
[16:17:48.740]     ...future.result <- base::tryCatch({
[16:17:48.740]         base::withCallingHandlers({
[16:17:48.740]             ...future.value <- base::withVisible(base::local({
[16:17:48.740]                 ...future.makeSendCondition <- base::local({
[16:17:48.740]                   sendCondition <- NULL
[16:17:48.740]                   function(frame = 1L) {
[16:17:48.740]                     if (is.function(sendCondition)) 
[16:17:48.740]                       return(sendCondition)
[16:17:48.740]                     ns <- getNamespace("parallel")
[16:17:48.740]                     if (exists("sendData", mode = "function", 
[16:17:48.740]                       envir = ns)) {
[16:17:48.740]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:48.740]                         envir = ns)
[16:17:48.740]                       envir <- sys.frame(frame)
[16:17:48.740]                       master <- NULL
[16:17:48.740]                       while (!identical(envir, .GlobalEnv) && 
[16:17:48.740]                         !identical(envir, emptyenv())) {
[16:17:48.740]                         if (exists("master", mode = "list", envir = envir, 
[16:17:48.740]                           inherits = FALSE)) {
[16:17:48.740]                           master <- get("master", mode = "list", 
[16:17:48.740]                             envir = envir, inherits = FALSE)
[16:17:48.740]                           if (inherits(master, c("SOCKnode", 
[16:17:48.740]                             "SOCK0node"))) {
[16:17:48.740]                             sendCondition <<- function(cond) {
[16:17:48.740]                               data <- list(type = "VALUE", value = cond, 
[16:17:48.740]                                 success = TRUE)
[16:17:48.740]                               parallel_sendData(master, data)
[16:17:48.740]                             }
[16:17:48.740]                             return(sendCondition)
[16:17:48.740]                           }
[16:17:48.740]                         }
[16:17:48.740]                         frame <- frame + 1L
[16:17:48.740]                         envir <- sys.frame(frame)
[16:17:48.740]                       }
[16:17:48.740]                     }
[16:17:48.740]                     sendCondition <<- function(cond) NULL
[16:17:48.740]                   }
[16:17:48.740]                 })
[16:17:48.740]                 withCallingHandlers({
[16:17:48.740]                   {
[16:17:48.740]                     do.call(function(...) {
[16:17:48.740]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:48.740]                       if (!identical(...future.globals.maxSize.org, 
[16:17:48.740]                         ...future.globals.maxSize)) {
[16:17:48.740]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:48.740]                         on.exit(options(oopts), add = TRUE)
[16:17:48.740]                       }
[16:17:48.740]                       {
[16:17:48.740]                         lapply(seq_along(...future.elements_ii), 
[16:17:48.740]                           FUN = function(jj) {
[16:17:48.740]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:48.740]                             ...future.FUN(...future.X_jj, ...)
[16:17:48.740]                           })
[16:17:48.740]                       }
[16:17:48.740]                     }, args = future.call.arguments)
[16:17:48.740]                   }
[16:17:48.740]                 }, immediateCondition = function(cond) {
[16:17:48.740]                   sendCondition <- ...future.makeSendCondition()
[16:17:48.740]                   sendCondition(cond)
[16:17:48.740]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:48.740]                   {
[16:17:48.740]                     inherits <- base::inherits
[16:17:48.740]                     invokeRestart <- base::invokeRestart
[16:17:48.740]                     is.null <- base::is.null
[16:17:48.740]                     muffled <- FALSE
[16:17:48.740]                     if (inherits(cond, "message")) {
[16:17:48.740]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:48.740]                       if (muffled) 
[16:17:48.740]                         invokeRestart("muffleMessage")
[16:17:48.740]                     }
[16:17:48.740]                     else if (inherits(cond, "warning")) {
[16:17:48.740]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:48.740]                       if (muffled) 
[16:17:48.740]                         invokeRestart("muffleWarning")
[16:17:48.740]                     }
[16:17:48.740]                     else if (inherits(cond, "condition")) {
[16:17:48.740]                       if (!is.null(pattern)) {
[16:17:48.740]                         computeRestarts <- base::computeRestarts
[16:17:48.740]                         grepl <- base::grepl
[16:17:48.740]                         restarts <- computeRestarts(cond)
[16:17:48.740]                         for (restart in restarts) {
[16:17:48.740]                           name <- restart$name
[16:17:48.740]                           if (is.null(name)) 
[16:17:48.740]                             next
[16:17:48.740]                           if (!grepl(pattern, name)) 
[16:17:48.740]                             next
[16:17:48.740]                           invokeRestart(restart)
[16:17:48.740]                           muffled <- TRUE
[16:17:48.740]                           break
[16:17:48.740]                         }
[16:17:48.740]                       }
[16:17:48.740]                     }
[16:17:48.740]                     invisible(muffled)
[16:17:48.740]                   }
[16:17:48.740]                   muffleCondition(cond)
[16:17:48.740]                 })
[16:17:48.740]             }))
[16:17:48.740]             future::FutureResult(value = ...future.value$value, 
[16:17:48.740]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:48.740]                   ...future.rng), globalenv = if (FALSE) 
[16:17:48.740]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:48.740]                     ...future.globalenv.names))
[16:17:48.740]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:48.740]         }, condition = base::local({
[16:17:48.740]             c <- base::c
[16:17:48.740]             inherits <- base::inherits
[16:17:48.740]             invokeRestart <- base::invokeRestart
[16:17:48.740]             length <- base::length
[16:17:48.740]             list <- base::list
[16:17:48.740]             seq.int <- base::seq.int
[16:17:48.740]             signalCondition <- base::signalCondition
[16:17:48.740]             sys.calls <- base::sys.calls
[16:17:48.740]             `[[` <- base::`[[`
[16:17:48.740]             `+` <- base::`+`
[16:17:48.740]             `<<-` <- base::`<<-`
[16:17:48.740]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:48.740]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:48.740]                   3L)]
[16:17:48.740]             }
[16:17:48.740]             function(cond) {
[16:17:48.740]                 is_error <- inherits(cond, "error")
[16:17:48.740]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:48.740]                   NULL)
[16:17:48.740]                 if (is_error) {
[16:17:48.740]                   sessionInformation <- function() {
[16:17:48.740]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:48.740]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:48.740]                       search = base::search(), system = base::Sys.info())
[16:17:48.740]                   }
[16:17:48.740]                   ...future.conditions[[length(...future.conditions) + 
[16:17:48.740]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:48.740]                     cond$call), session = sessionInformation(), 
[16:17:48.740]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:48.740]                   signalCondition(cond)
[16:17:48.740]                 }
[16:17:48.740]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:48.740]                 "immediateCondition"))) {
[16:17:48.740]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:48.740]                   ...future.conditions[[length(...future.conditions) + 
[16:17:48.740]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:48.740]                   if (TRUE && !signal) {
[16:17:48.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:48.740]                     {
[16:17:48.740]                       inherits <- base::inherits
[16:17:48.740]                       invokeRestart <- base::invokeRestart
[16:17:48.740]                       is.null <- base::is.null
[16:17:48.740]                       muffled <- FALSE
[16:17:48.740]                       if (inherits(cond, "message")) {
[16:17:48.740]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:48.740]                         if (muffled) 
[16:17:48.740]                           invokeRestart("muffleMessage")
[16:17:48.740]                       }
[16:17:48.740]                       else if (inherits(cond, "warning")) {
[16:17:48.740]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:48.740]                         if (muffled) 
[16:17:48.740]                           invokeRestart("muffleWarning")
[16:17:48.740]                       }
[16:17:48.740]                       else if (inherits(cond, "condition")) {
[16:17:48.740]                         if (!is.null(pattern)) {
[16:17:48.740]                           computeRestarts <- base::computeRestarts
[16:17:48.740]                           grepl <- base::grepl
[16:17:48.740]                           restarts <- computeRestarts(cond)
[16:17:48.740]                           for (restart in restarts) {
[16:17:48.740]                             name <- restart$name
[16:17:48.740]                             if (is.null(name)) 
[16:17:48.740]                               next
[16:17:48.740]                             if (!grepl(pattern, name)) 
[16:17:48.740]                               next
[16:17:48.740]                             invokeRestart(restart)
[16:17:48.740]                             muffled <- TRUE
[16:17:48.740]                             break
[16:17:48.740]                           }
[16:17:48.740]                         }
[16:17:48.740]                       }
[16:17:48.740]                       invisible(muffled)
[16:17:48.740]                     }
[16:17:48.740]                     muffleCondition(cond, pattern = "^muffle")
[16:17:48.740]                   }
[16:17:48.740]                 }
[16:17:48.740]                 else {
[16:17:48.740]                   if (TRUE) {
[16:17:48.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:48.740]                     {
[16:17:48.740]                       inherits <- base::inherits
[16:17:48.740]                       invokeRestart <- base::invokeRestart
[16:17:48.740]                       is.null <- base::is.null
[16:17:48.740]                       muffled <- FALSE
[16:17:48.740]                       if (inherits(cond, "message")) {
[16:17:48.740]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:48.740]                         if (muffled) 
[16:17:48.740]                           invokeRestart("muffleMessage")
[16:17:48.740]                       }
[16:17:48.740]                       else if (inherits(cond, "warning")) {
[16:17:48.740]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:48.740]                         if (muffled) 
[16:17:48.740]                           invokeRestart("muffleWarning")
[16:17:48.740]                       }
[16:17:48.740]                       else if (inherits(cond, "condition")) {
[16:17:48.740]                         if (!is.null(pattern)) {
[16:17:48.740]                           computeRestarts <- base::computeRestarts
[16:17:48.740]                           grepl <- base::grepl
[16:17:48.740]                           restarts <- computeRestarts(cond)
[16:17:48.740]                           for (restart in restarts) {
[16:17:48.740]                             name <- restart$name
[16:17:48.740]                             if (is.null(name)) 
[16:17:48.740]                               next
[16:17:48.740]                             if (!grepl(pattern, name)) 
[16:17:48.740]                               next
[16:17:48.740]                             invokeRestart(restart)
[16:17:48.740]                             muffled <- TRUE
[16:17:48.740]                             break
[16:17:48.740]                           }
[16:17:48.740]                         }
[16:17:48.740]                       }
[16:17:48.740]                       invisible(muffled)
[16:17:48.740]                     }
[16:17:48.740]                     muffleCondition(cond, pattern = "^muffle")
[16:17:48.740]                   }
[16:17:48.740]                 }
[16:17:48.740]             }
[16:17:48.740]         }))
[16:17:48.740]     }, error = function(ex) {
[16:17:48.740]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:48.740]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:48.740]                 ...future.rng), started = ...future.startTime, 
[16:17:48.740]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:48.740]             version = "1.8"), class = "FutureResult")
[16:17:48.740]     }, finally = {
[16:17:48.740]         if (!identical(...future.workdir, getwd())) 
[16:17:48.740]             setwd(...future.workdir)
[16:17:48.740]         {
[16:17:48.740]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:48.740]                 ...future.oldOptions$nwarnings <- NULL
[16:17:48.740]             }
[16:17:48.740]             base::options(...future.oldOptions)
[16:17:48.740]             if (.Platform$OS.type == "windows") {
[16:17:48.740]                 old_names <- names(...future.oldEnvVars)
[16:17:48.740]                 envs <- base::Sys.getenv()
[16:17:48.740]                 names <- names(envs)
[16:17:48.740]                 common <- intersect(names, old_names)
[16:17:48.740]                 added <- setdiff(names, old_names)
[16:17:48.740]                 removed <- setdiff(old_names, names)
[16:17:48.740]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:48.740]                   envs[common]]
[16:17:48.740]                 NAMES <- toupper(changed)
[16:17:48.740]                 args <- list()
[16:17:48.740]                 for (kk in seq_along(NAMES)) {
[16:17:48.740]                   name <- changed[[kk]]
[16:17:48.740]                   NAME <- NAMES[[kk]]
[16:17:48.740]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:48.740]                     next
[16:17:48.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:48.740]                 }
[16:17:48.740]                 NAMES <- toupper(added)
[16:17:48.740]                 for (kk in seq_along(NAMES)) {
[16:17:48.740]                   name <- added[[kk]]
[16:17:48.740]                   NAME <- NAMES[[kk]]
[16:17:48.740]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:48.740]                     next
[16:17:48.740]                   args[[name]] <- ""
[16:17:48.740]                 }
[16:17:48.740]                 NAMES <- toupper(removed)
[16:17:48.740]                 for (kk in seq_along(NAMES)) {
[16:17:48.740]                   name <- removed[[kk]]
[16:17:48.740]                   NAME <- NAMES[[kk]]
[16:17:48.740]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:48.740]                     next
[16:17:48.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:48.740]                 }
[16:17:48.740]                 if (length(args) > 0) 
[16:17:48.740]                   base::do.call(base::Sys.setenv, args = args)
[16:17:48.740]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:48.740]             }
[16:17:48.740]             else {
[16:17:48.740]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:48.740]             }
[16:17:48.740]             {
[16:17:48.740]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:48.740]                   0L) {
[16:17:48.740]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:48.740]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:48.740]                   base::options(opts)
[16:17:48.740]                 }
[16:17:48.740]                 {
[16:17:48.740]                   {
[16:17:48.740]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:48.740]                     NULL
[16:17:48.740]                   }
[16:17:48.740]                   options(future.plan = NULL)
[16:17:48.740]                   if (is.na(NA_character_)) 
[16:17:48.740]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:48.740]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:48.740]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:48.740]                     .init = FALSE)
[16:17:48.740]                 }
[16:17:48.740]             }
[16:17:48.740]         }
[16:17:48.740]     })
[16:17:48.740]     if (TRUE) {
[16:17:48.740]         base::sink(type = "output", split = FALSE)
[16:17:48.740]         if (TRUE) {
[16:17:48.740]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:48.740]         }
[16:17:48.740]         else {
[16:17:48.740]             ...future.result["stdout"] <- base::list(NULL)
[16:17:48.740]         }
[16:17:48.740]         base::close(...future.stdout)
[16:17:48.740]         ...future.stdout <- NULL
[16:17:48.740]     }
[16:17:48.740]     ...future.result$conditions <- ...future.conditions
[16:17:48.740]     ...future.result$finished <- base::Sys.time()
[16:17:48.740]     ...future.result
[16:17:48.740] }
[16:17:48.743] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[16:17:48.743] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[16:17:48.743] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[16:17:48.744] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:17:48.744] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:17:48.744] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ...
[16:17:48.745] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ... DONE
[16:17:48.745] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:17:48.745] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:17:48.745] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:17:48.746] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:17:48.746] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[16:17:48.746] MultisessionFuture started
[16:17:48.746] - Launch lazy future ... done
[16:17:48.746] run() for ‘MultisessionFuture’ ... done
[16:17:48.747] Created future:
[16:17:48.747] MultisessionFuture:
[16:17:48.747] Label: ‘future_by-1’
[16:17:48.747] Expression:
[16:17:48.747] {
[16:17:48.747]     do.call(function(...) {
[16:17:48.747]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:48.747]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:48.747]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:48.747]             on.exit(options(oopts), add = TRUE)
[16:17:48.747]         }
[16:17:48.747]         {
[16:17:48.747]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:48.747]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:48.747]                 ...future.FUN(...future.X_jj, ...)
[16:17:48.747]             })
[16:17:48.747]         }
[16:17:48.747]     }, args = future.call.arguments)
[16:17:48.747] }
[16:17:48.747] Lazy evaluation: FALSE
[16:17:48.747] Asynchronous evaluation: TRUE
[16:17:48.747] Local evaluation: TRUE
[16:17:48.747] Environment: R_GlobalEnv
[16:17:48.747] Capture standard output: TRUE
[16:17:48.747] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:48.747] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:48.747] Packages: <none>
[16:17:48.747] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:48.747] Resolved: FALSE
[16:17:48.747] Value: <not collected>
[16:17:48.747] Conditions captured: <none>
[16:17:48.747] Early signaling: FALSE
[16:17:48.747] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:48.747] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:48.759] Chunk #1 of 2 ... DONE
[16:17:48.759] Chunk #2 of 2 ...
[16:17:48.759]  - Finding globals in 'X' for chunk #2 ...
[16:17:48.759] getGlobalsAndPackages() ...
[16:17:48.759] Searching for globals...
[16:17:48.760] 
[16:17:48.760] Searching for globals ... DONE
[16:17:48.760] - globals: [0] <none>
[16:17:48.760] getGlobalsAndPackages() ... DONE
[16:17:48.760]    + additional globals found: [n=0] 
[16:17:48.760]    + additional namespaces needed: [n=0] 
[16:17:48.760]  - Finding globals in 'X' for chunk #2 ... DONE
[16:17:48.760]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:48.760]  - seeds: <none>
[16:17:48.761]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:48.761] getGlobalsAndPackages() ...
[16:17:48.761] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:48.761] Resolving globals: FALSE
[16:17:48.761] Tweak future expression to call with '...' arguments ...
[16:17:48.761] {
[16:17:48.761]     do.call(function(...) {
[16:17:48.761]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:48.761]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:48.761]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:48.761]             on.exit(options(oopts), add = TRUE)
[16:17:48.761]         }
[16:17:48.761]         {
[16:17:48.761]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:48.761]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:48.761]                 ...future.FUN(...future.X_jj, ...)
[16:17:48.761]             })
[16:17:48.761]         }
[16:17:48.761]     }, args = future.call.arguments)
[16:17:48.761] }
[16:17:48.761] Tweak future expression to call with '...' arguments ... DONE
[16:17:48.762] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:48.762] 
[16:17:48.762] getGlobalsAndPackages() ... DONE
[16:17:48.762] run() for ‘Future’ ...
[16:17:48.762] - state: ‘created’
[16:17:48.763] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:48.776] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:48.777] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:48.777]   - Field: ‘node’
[16:17:48.777]   - Field: ‘label’
[16:17:48.777]   - Field: ‘local’
[16:17:48.777]   - Field: ‘owner’
[16:17:48.777]   - Field: ‘envir’
[16:17:48.777]   - Field: ‘workers’
[16:17:48.777]   - Field: ‘packages’
[16:17:48.777]   - Field: ‘gc’
[16:17:48.778]   - Field: ‘conditions’
[16:17:48.778]   - Field: ‘persistent’
[16:17:48.778]   - Field: ‘expr’
[16:17:48.778]   - Field: ‘uuid’
[16:17:48.778]   - Field: ‘seed’
[16:17:48.778]   - Field: ‘version’
[16:17:48.778]   - Field: ‘result’
[16:17:48.778]   - Field: ‘asynchronous’
[16:17:48.778]   - Field: ‘calls’
[16:17:48.778]   - Field: ‘globals’
[16:17:48.778]   - Field: ‘stdout’
[16:17:48.779]   - Field: ‘earlySignal’
[16:17:48.779]   - Field: ‘lazy’
[16:17:48.779]   - Field: ‘state’
[16:17:48.779] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:48.779] - Launch lazy future ...
[16:17:48.779] Packages needed by the future expression (n = 0): <none>
[16:17:48.779] Packages needed by future strategies (n = 0): <none>
[16:17:48.780] {
[16:17:48.780]     {
[16:17:48.780]         {
[16:17:48.780]             ...future.startTime <- base::Sys.time()
[16:17:48.780]             {
[16:17:48.780]                 {
[16:17:48.780]                   {
[16:17:48.780]                     {
[16:17:48.780]                       base::local({
[16:17:48.780]                         has_future <- base::requireNamespace("future", 
[16:17:48.780]                           quietly = TRUE)
[16:17:48.780]                         if (has_future) {
[16:17:48.780]                           ns <- base::getNamespace("future")
[16:17:48.780]                           version <- ns[[".package"]][["version"]]
[16:17:48.780]                           if (is.null(version)) 
[16:17:48.780]                             version <- utils::packageVersion("future")
[16:17:48.780]                         }
[16:17:48.780]                         else {
[16:17:48.780]                           version <- NULL
[16:17:48.780]                         }
[16:17:48.780]                         if (!has_future || version < "1.8.0") {
[16:17:48.780]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:48.780]                             "", base::R.version$version.string), 
[16:17:48.780]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:48.780]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:48.780]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:48.780]                               "release", "version")], collapse = " "), 
[16:17:48.780]                             hostname = base::Sys.info()[["nodename"]])
[16:17:48.780]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:48.780]                             info)
[16:17:48.780]                           info <- base::paste(info, collapse = "; ")
[16:17:48.780]                           if (!has_future) {
[16:17:48.780]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:48.780]                               info)
[16:17:48.780]                           }
[16:17:48.780]                           else {
[16:17:48.780]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:48.780]                               info, version)
[16:17:48.780]                           }
[16:17:48.780]                           base::stop(msg)
[16:17:48.780]                         }
[16:17:48.780]                       })
[16:17:48.780]                     }
[16:17:48.780]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:48.780]                     base::options(mc.cores = 1L)
[16:17:48.780]                   }
[16:17:48.780]                   ...future.strategy.old <- future::plan("list")
[16:17:48.780]                   options(future.plan = NULL)
[16:17:48.780]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:48.780]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:48.780]                 }
[16:17:48.780]                 ...future.workdir <- getwd()
[16:17:48.780]             }
[16:17:48.780]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:48.780]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:48.780]         }
[16:17:48.780]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:48.780]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:48.780]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:48.780]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:48.780]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:48.780]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:48.780]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:48.780]             base::names(...future.oldOptions))
[16:17:48.780]     }
[16:17:48.780]     if (FALSE) {
[16:17:48.780]     }
[16:17:48.780]     else {
[16:17:48.780]         if (TRUE) {
[16:17:48.780]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:48.780]                 open = "w")
[16:17:48.780]         }
[16:17:48.780]         else {
[16:17:48.780]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:48.780]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:48.780]         }
[16:17:48.780]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:48.780]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:48.780]             base::sink(type = "output", split = FALSE)
[16:17:48.780]             base::close(...future.stdout)
[16:17:48.780]         }, add = TRUE)
[16:17:48.780]     }
[16:17:48.780]     ...future.frame <- base::sys.nframe()
[16:17:48.780]     ...future.conditions <- base::list()
[16:17:48.780]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:48.780]     if (FALSE) {
[16:17:48.780]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:48.780]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:48.780]     }
[16:17:48.780]     ...future.result <- base::tryCatch({
[16:17:48.780]         base::withCallingHandlers({
[16:17:48.780]             ...future.value <- base::withVisible(base::local({
[16:17:48.780]                 ...future.makeSendCondition <- base::local({
[16:17:48.780]                   sendCondition <- NULL
[16:17:48.780]                   function(frame = 1L) {
[16:17:48.780]                     if (is.function(sendCondition)) 
[16:17:48.780]                       return(sendCondition)
[16:17:48.780]                     ns <- getNamespace("parallel")
[16:17:48.780]                     if (exists("sendData", mode = "function", 
[16:17:48.780]                       envir = ns)) {
[16:17:48.780]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:48.780]                         envir = ns)
[16:17:48.780]                       envir <- sys.frame(frame)
[16:17:48.780]                       master <- NULL
[16:17:48.780]                       while (!identical(envir, .GlobalEnv) && 
[16:17:48.780]                         !identical(envir, emptyenv())) {
[16:17:48.780]                         if (exists("master", mode = "list", envir = envir, 
[16:17:48.780]                           inherits = FALSE)) {
[16:17:48.780]                           master <- get("master", mode = "list", 
[16:17:48.780]                             envir = envir, inherits = FALSE)
[16:17:48.780]                           if (inherits(master, c("SOCKnode", 
[16:17:48.780]                             "SOCK0node"))) {
[16:17:48.780]                             sendCondition <<- function(cond) {
[16:17:48.780]                               data <- list(type = "VALUE", value = cond, 
[16:17:48.780]                                 success = TRUE)
[16:17:48.780]                               parallel_sendData(master, data)
[16:17:48.780]                             }
[16:17:48.780]                             return(sendCondition)
[16:17:48.780]                           }
[16:17:48.780]                         }
[16:17:48.780]                         frame <- frame + 1L
[16:17:48.780]                         envir <- sys.frame(frame)
[16:17:48.780]                       }
[16:17:48.780]                     }
[16:17:48.780]                     sendCondition <<- function(cond) NULL
[16:17:48.780]                   }
[16:17:48.780]                 })
[16:17:48.780]                 withCallingHandlers({
[16:17:48.780]                   {
[16:17:48.780]                     do.call(function(...) {
[16:17:48.780]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:48.780]                       if (!identical(...future.globals.maxSize.org, 
[16:17:48.780]                         ...future.globals.maxSize)) {
[16:17:48.780]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:48.780]                         on.exit(options(oopts), add = TRUE)
[16:17:48.780]                       }
[16:17:48.780]                       {
[16:17:48.780]                         lapply(seq_along(...future.elements_ii), 
[16:17:48.780]                           FUN = function(jj) {
[16:17:48.780]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:48.780]                             ...future.FUN(...future.X_jj, ...)
[16:17:48.780]                           })
[16:17:48.780]                       }
[16:17:48.780]                     }, args = future.call.arguments)
[16:17:48.780]                   }
[16:17:48.780]                 }, immediateCondition = function(cond) {
[16:17:48.780]                   sendCondition <- ...future.makeSendCondition()
[16:17:48.780]                   sendCondition(cond)
[16:17:48.780]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:48.780]                   {
[16:17:48.780]                     inherits <- base::inherits
[16:17:48.780]                     invokeRestart <- base::invokeRestart
[16:17:48.780]                     is.null <- base::is.null
[16:17:48.780]                     muffled <- FALSE
[16:17:48.780]                     if (inherits(cond, "message")) {
[16:17:48.780]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:48.780]                       if (muffled) 
[16:17:48.780]                         invokeRestart("muffleMessage")
[16:17:48.780]                     }
[16:17:48.780]                     else if (inherits(cond, "warning")) {
[16:17:48.780]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:48.780]                       if (muffled) 
[16:17:48.780]                         invokeRestart("muffleWarning")
[16:17:48.780]                     }
[16:17:48.780]                     else if (inherits(cond, "condition")) {
[16:17:48.780]                       if (!is.null(pattern)) {
[16:17:48.780]                         computeRestarts <- base::computeRestarts
[16:17:48.780]                         grepl <- base::grepl
[16:17:48.780]                         restarts <- computeRestarts(cond)
[16:17:48.780]                         for (restart in restarts) {
[16:17:48.780]                           name <- restart$name
[16:17:48.780]                           if (is.null(name)) 
[16:17:48.780]                             next
[16:17:48.780]                           if (!grepl(pattern, name)) 
[16:17:48.780]                             next
[16:17:48.780]                           invokeRestart(restart)
[16:17:48.780]                           muffled <- TRUE
[16:17:48.780]                           break
[16:17:48.780]                         }
[16:17:48.780]                       }
[16:17:48.780]                     }
[16:17:48.780]                     invisible(muffled)
[16:17:48.780]                   }
[16:17:48.780]                   muffleCondition(cond)
[16:17:48.780]                 })
[16:17:48.780]             }))
[16:17:48.780]             future::FutureResult(value = ...future.value$value, 
[16:17:48.780]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:48.780]                   ...future.rng), globalenv = if (FALSE) 
[16:17:48.780]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:48.780]                     ...future.globalenv.names))
[16:17:48.780]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:48.780]         }, condition = base::local({
[16:17:48.780]             c <- base::c
[16:17:48.780]             inherits <- base::inherits
[16:17:48.780]             invokeRestart <- base::invokeRestart
[16:17:48.780]             length <- base::length
[16:17:48.780]             list <- base::list
[16:17:48.780]             seq.int <- base::seq.int
[16:17:48.780]             signalCondition <- base::signalCondition
[16:17:48.780]             sys.calls <- base::sys.calls
[16:17:48.780]             `[[` <- base::`[[`
[16:17:48.780]             `+` <- base::`+`
[16:17:48.780]             `<<-` <- base::`<<-`
[16:17:48.780]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:48.780]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:48.780]                   3L)]
[16:17:48.780]             }
[16:17:48.780]             function(cond) {
[16:17:48.780]                 is_error <- inherits(cond, "error")
[16:17:48.780]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:48.780]                   NULL)
[16:17:48.780]                 if (is_error) {
[16:17:48.780]                   sessionInformation <- function() {
[16:17:48.780]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:48.780]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:48.780]                       search = base::search(), system = base::Sys.info())
[16:17:48.780]                   }
[16:17:48.780]                   ...future.conditions[[length(...future.conditions) + 
[16:17:48.780]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:48.780]                     cond$call), session = sessionInformation(), 
[16:17:48.780]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:48.780]                   signalCondition(cond)
[16:17:48.780]                 }
[16:17:48.780]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:48.780]                 "immediateCondition"))) {
[16:17:48.780]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:48.780]                   ...future.conditions[[length(...future.conditions) + 
[16:17:48.780]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:48.780]                   if (TRUE && !signal) {
[16:17:48.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:48.780]                     {
[16:17:48.780]                       inherits <- base::inherits
[16:17:48.780]                       invokeRestart <- base::invokeRestart
[16:17:48.780]                       is.null <- base::is.null
[16:17:48.780]                       muffled <- FALSE
[16:17:48.780]                       if (inherits(cond, "message")) {
[16:17:48.780]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:48.780]                         if (muffled) 
[16:17:48.780]                           invokeRestart("muffleMessage")
[16:17:48.780]                       }
[16:17:48.780]                       else if (inherits(cond, "warning")) {
[16:17:48.780]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:48.780]                         if (muffled) 
[16:17:48.780]                           invokeRestart("muffleWarning")
[16:17:48.780]                       }
[16:17:48.780]                       else if (inherits(cond, "condition")) {
[16:17:48.780]                         if (!is.null(pattern)) {
[16:17:48.780]                           computeRestarts <- base::computeRestarts
[16:17:48.780]                           grepl <- base::grepl
[16:17:48.780]                           restarts <- computeRestarts(cond)
[16:17:48.780]                           for (restart in restarts) {
[16:17:48.780]                             name <- restart$name
[16:17:48.780]                             if (is.null(name)) 
[16:17:48.780]                               next
[16:17:48.780]                             if (!grepl(pattern, name)) 
[16:17:48.780]                               next
[16:17:48.780]                             invokeRestart(restart)
[16:17:48.780]                             muffled <- TRUE
[16:17:48.780]                             break
[16:17:48.780]                           }
[16:17:48.780]                         }
[16:17:48.780]                       }
[16:17:48.780]                       invisible(muffled)
[16:17:48.780]                     }
[16:17:48.780]                     muffleCondition(cond, pattern = "^muffle")
[16:17:48.780]                   }
[16:17:48.780]                 }
[16:17:48.780]                 else {
[16:17:48.780]                   if (TRUE) {
[16:17:48.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:48.780]                     {
[16:17:48.780]                       inherits <- base::inherits
[16:17:48.780]                       invokeRestart <- base::invokeRestart
[16:17:48.780]                       is.null <- base::is.null
[16:17:48.780]                       muffled <- FALSE
[16:17:48.780]                       if (inherits(cond, "message")) {
[16:17:48.780]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:48.780]                         if (muffled) 
[16:17:48.780]                           invokeRestart("muffleMessage")
[16:17:48.780]                       }
[16:17:48.780]                       else if (inherits(cond, "warning")) {
[16:17:48.780]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:48.780]                         if (muffled) 
[16:17:48.780]                           invokeRestart("muffleWarning")
[16:17:48.780]                       }
[16:17:48.780]                       else if (inherits(cond, "condition")) {
[16:17:48.780]                         if (!is.null(pattern)) {
[16:17:48.780]                           computeRestarts <- base::computeRestarts
[16:17:48.780]                           grepl <- base::grepl
[16:17:48.780]                           restarts <- computeRestarts(cond)
[16:17:48.780]                           for (restart in restarts) {
[16:17:48.780]                             name <- restart$name
[16:17:48.780]                             if (is.null(name)) 
[16:17:48.780]                               next
[16:17:48.780]                             if (!grepl(pattern, name)) 
[16:17:48.780]                               next
[16:17:48.780]                             invokeRestart(restart)
[16:17:48.780]                             muffled <- TRUE
[16:17:48.780]                             break
[16:17:48.780]                           }
[16:17:48.780]                         }
[16:17:48.780]                       }
[16:17:48.780]                       invisible(muffled)
[16:17:48.780]                     }
[16:17:48.780]                     muffleCondition(cond, pattern = "^muffle")
[16:17:48.780]                   }
[16:17:48.780]                 }
[16:17:48.780]             }
[16:17:48.780]         }))
[16:17:48.780]     }, error = function(ex) {
[16:17:48.780]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:48.780]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:48.780]                 ...future.rng), started = ...future.startTime, 
[16:17:48.780]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:48.780]             version = "1.8"), class = "FutureResult")
[16:17:48.780]     }, finally = {
[16:17:48.780]         if (!identical(...future.workdir, getwd())) 
[16:17:48.780]             setwd(...future.workdir)
[16:17:48.780]         {
[16:17:48.780]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:48.780]                 ...future.oldOptions$nwarnings <- NULL
[16:17:48.780]             }
[16:17:48.780]             base::options(...future.oldOptions)
[16:17:48.780]             if (.Platform$OS.type == "windows") {
[16:17:48.780]                 old_names <- names(...future.oldEnvVars)
[16:17:48.780]                 envs <- base::Sys.getenv()
[16:17:48.780]                 names <- names(envs)
[16:17:48.780]                 common <- intersect(names, old_names)
[16:17:48.780]                 added <- setdiff(names, old_names)
[16:17:48.780]                 removed <- setdiff(old_names, names)
[16:17:48.780]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:48.780]                   envs[common]]
[16:17:48.780]                 NAMES <- toupper(changed)
[16:17:48.780]                 args <- list()
[16:17:48.780]                 for (kk in seq_along(NAMES)) {
[16:17:48.780]                   name <- changed[[kk]]
[16:17:48.780]                   NAME <- NAMES[[kk]]
[16:17:48.780]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:48.780]                     next
[16:17:48.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:48.780]                 }
[16:17:48.780]                 NAMES <- toupper(added)
[16:17:48.780]                 for (kk in seq_along(NAMES)) {
[16:17:48.780]                   name <- added[[kk]]
[16:17:48.780]                   NAME <- NAMES[[kk]]
[16:17:48.780]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:48.780]                     next
[16:17:48.780]                   args[[name]] <- ""
[16:17:48.780]                 }
[16:17:48.780]                 NAMES <- toupper(removed)
[16:17:48.780]                 for (kk in seq_along(NAMES)) {
[16:17:48.780]                   name <- removed[[kk]]
[16:17:48.780]                   NAME <- NAMES[[kk]]
[16:17:48.780]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:48.780]                     next
[16:17:48.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:48.780]                 }
[16:17:48.780]                 if (length(args) > 0) 
[16:17:48.780]                   base::do.call(base::Sys.setenv, args = args)
[16:17:48.780]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:48.780]             }
[16:17:48.780]             else {
[16:17:48.780]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:48.780]             }
[16:17:48.780]             {
[16:17:48.780]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:48.780]                   0L) {
[16:17:48.780]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:48.780]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:48.780]                   base::options(opts)
[16:17:48.780]                 }
[16:17:48.780]                 {
[16:17:48.780]                   {
[16:17:48.780]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:48.780]                     NULL
[16:17:48.780]                   }
[16:17:48.780]                   options(future.plan = NULL)
[16:17:48.780]                   if (is.na(NA_character_)) 
[16:17:48.780]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:48.780]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:48.780]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:48.780]                     .init = FALSE)
[16:17:48.780]                 }
[16:17:48.780]             }
[16:17:48.780]         }
[16:17:48.780]     })
[16:17:48.780]     if (TRUE) {
[16:17:48.780]         base::sink(type = "output", split = FALSE)
[16:17:48.780]         if (TRUE) {
[16:17:48.780]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:48.780]         }
[16:17:48.780]         else {
[16:17:48.780]             ...future.result["stdout"] <- base::list(NULL)
[16:17:48.780]         }
[16:17:48.780]         base::close(...future.stdout)
[16:17:48.780]         ...future.stdout <- NULL
[16:17:48.780]     }
[16:17:48.780]     ...future.result$conditions <- ...future.conditions
[16:17:48.780]     ...future.result$finished <- base::Sys.time()
[16:17:48.780]     ...future.result
[16:17:48.780] }
[16:17:48.835] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[16:17:48.836] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[16:17:48.836] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[16:17:48.836] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:17:48.837] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:17:48.837] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ...
[16:17:48.837] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ... DONE
[16:17:48.837] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:17:48.838] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:17:48.838] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:17:48.838] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:17:48.838] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[16:17:48.839] MultisessionFuture started
[16:17:48.839] - Launch lazy future ... done
[16:17:48.839] run() for ‘MultisessionFuture’ ... done
[16:17:48.839] Created future:
[16:17:48.839] MultisessionFuture:
[16:17:48.839] Label: ‘future_by-2’
[16:17:48.839] Expression:
[16:17:48.839] {
[16:17:48.839]     do.call(function(...) {
[16:17:48.839]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:48.839]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:48.839]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:48.839]             on.exit(options(oopts), add = TRUE)
[16:17:48.839]         }
[16:17:48.839]         {
[16:17:48.839]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:48.839]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:48.839]                 ...future.FUN(...future.X_jj, ...)
[16:17:48.839]             })
[16:17:48.839]         }
[16:17:48.839]     }, args = future.call.arguments)
[16:17:48.839] }
[16:17:48.839] Lazy evaluation: FALSE
[16:17:48.839] Asynchronous evaluation: TRUE
[16:17:48.839] Local evaluation: TRUE
[16:17:48.839] Environment: R_GlobalEnv
[16:17:48.839] Capture standard output: TRUE
[16:17:48.839] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:48.839] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:48.839] Packages: <none>
[16:17:48.839] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:48.839] Resolved: FALSE
[16:17:48.839] Value: <not collected>
[16:17:48.839] Conditions captured: <none>
[16:17:48.839] Early signaling: FALSE
[16:17:48.839] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:48.839] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:48.851] Chunk #2 of 2 ... DONE
[16:17:48.851] Launching 2 futures (chunks) ... DONE
[16:17:48.852] Resolving 2 futures (chunks) ...
[16:17:48.852] resolve() on list ...
[16:17:48.852]  recursive: 0
[16:17:48.852]  length: 2
[16:17:48.852] 
[16:17:48.853] receiveMessageFromWorker() for ClusterFuture ...
[16:17:48.853] - Validating connection of MultisessionFuture
[16:17:48.853] - received message: FutureResult
[16:17:48.853] - Received FutureResult
[16:17:48.853] - Erased future from FutureRegistry
[16:17:48.853] result() for ClusterFuture ...
[16:17:48.853] - result already collected: FutureResult
[16:17:48.853] result() for ClusterFuture ... done
[16:17:48.854] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:48.854] Future #1
[16:17:48.854] result() for ClusterFuture ...
[16:17:48.854] - result already collected: FutureResult
[16:17:48.854] result() for ClusterFuture ... done
[16:17:48.854] result() for ClusterFuture ...
[16:17:48.854] - result already collected: FutureResult
[16:17:48.854] result() for ClusterFuture ... done
[16:17:48.854] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:17:48.854] - nx: 2
[16:17:48.854] - relay: TRUE
[16:17:48.855] - stdout: TRUE
[16:17:48.855] - signal: TRUE
[16:17:48.855] - resignal: FALSE
[16:17:48.855] - force: TRUE
[16:17:48.855] - relayed: [n=2] FALSE, FALSE
[16:17:48.855] - queued futures: [n=2] FALSE, FALSE
[16:17:48.857]  - until=1
[16:17:48.857]  - relaying element #1
[16:17:48.858] result() for ClusterFuture ...
[16:17:48.858] - result already collected: FutureResult
[16:17:48.858] result() for ClusterFuture ... done
[16:17:48.858] result() for ClusterFuture ...
[16:17:48.858] - result already collected: FutureResult
[16:17:48.858] result() for ClusterFuture ... done
[16:17:48.858] result() for ClusterFuture ...
[16:17:48.858] - result already collected: FutureResult
[16:17:48.858] result() for ClusterFuture ... done
[16:17:48.858] result() for ClusterFuture ...
[16:17:48.858] - result already collected: FutureResult
[16:17:48.859] result() for ClusterFuture ... done
[16:17:48.859] - relayed: [n=2] TRUE, FALSE
[16:17:48.859] - queued futures: [n=2] TRUE, FALSE
[16:17:48.859] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:17:48.859]  length: 1 (resolved future 1)
[16:17:48.921] receiveMessageFromWorker() for ClusterFuture ...
[16:17:48.921] - Validating connection of MultisessionFuture
[16:17:48.921] - received message: FutureResult
[16:17:48.922] - Received FutureResult
[16:17:48.922] - Erased future from FutureRegistry
[16:17:48.922] result() for ClusterFuture ...
[16:17:48.922] - result already collected: FutureResult
[16:17:48.922] result() for ClusterFuture ... done
[16:17:48.922] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:48.922] Future #2
[16:17:48.922] result() for ClusterFuture ...
[16:17:48.922] - result already collected: FutureResult
[16:17:48.922] result() for ClusterFuture ... done
[16:17:48.923] result() for ClusterFuture ...
[16:17:48.923] - result already collected: FutureResult
[16:17:48.923] result() for ClusterFuture ... done
[16:17:48.923] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:17:48.923] - nx: 2
[16:17:48.923] - relay: TRUE
[16:17:48.923] - stdout: TRUE
[16:17:48.923] - signal: TRUE
[16:17:48.923] - resignal: FALSE
[16:17:48.923] - force: TRUE
[16:17:48.923] - relayed: [n=2] TRUE, FALSE
[16:17:48.923] - queued futures: [n=2] TRUE, FALSE
[16:17:48.924]  - until=2
[16:17:48.924]  - relaying element #2
[16:17:48.924] result() for ClusterFuture ...
[16:17:48.924] - result already collected: FutureResult
[16:17:48.924] result() for ClusterFuture ... done
[16:17:48.924] result() for ClusterFuture ...
[16:17:48.924] - result already collected: FutureResult
[16:17:48.924] result() for ClusterFuture ... done
[16:17:48.924] result() for ClusterFuture ...
[16:17:48.924] - result already collected: FutureResult
[16:17:48.925] result() for ClusterFuture ... done
[16:17:48.925] result() for ClusterFuture ...
[16:17:48.925] - result already collected: FutureResult
[16:17:48.925] result() for ClusterFuture ... done
[16:17:48.925] - relayed: [n=2] TRUE, TRUE
[16:17:48.925] - queued futures: [n=2] TRUE, TRUE
[16:17:48.925] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:17:48.925]  length: 0 (resolved future 2)
[16:17:48.925] Relaying remaining futures
[16:17:48.925] signalConditionsASAP(NULL, pos=0) ...
[16:17:48.925] - nx: 2
[16:17:48.925] - relay: TRUE
[16:17:48.926] - stdout: TRUE
[16:17:48.926] - signal: TRUE
[16:17:48.926] - resignal: FALSE
[16:17:48.926] - force: TRUE
[16:17:48.926] - relayed: [n=2] TRUE, TRUE
[16:17:48.926] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:48.926] - relayed: [n=2] TRUE, TRUE
[16:17:48.926] - queued futures: [n=2] TRUE, TRUE
[16:17:48.926] signalConditionsASAP(NULL, pos=0) ... done
[16:17:48.926] resolve() on list ... DONE
[16:17:48.926] result() for ClusterFuture ...
[16:17:48.927] - result already collected: FutureResult
[16:17:48.927] result() for ClusterFuture ... done
[16:17:48.927] result() for ClusterFuture ...
[16:17:48.927] - result already collected: FutureResult
[16:17:48.927] result() for ClusterFuture ... done
[16:17:48.927] result() for ClusterFuture ...
[16:17:48.927] - result already collected: FutureResult
[16:17:48.927] result() for ClusterFuture ... done
[16:17:48.927] result() for ClusterFuture ...
[16:17:48.927] - result already collected: FutureResult
[16:17:48.927] result() for ClusterFuture ... done
[16:17:48.928]  - Number of value chunks collected: 2
[16:17:48.928] Resolving 2 futures (chunks) ... DONE
[16:17:48.928] Reducing values from 2 chunks ...
[16:17:48.928]  - Number of values collected after concatenation: 3
[16:17:48.928]  - Number of values expected: 3
[16:17:48.928] Reducing values from 2 chunks ... DONE
[16:17:48.928] future_lapply() ... DONE
[16:17:48.928] future_by_internal() ... DONE
[16:17:48.928] future_by_internal() ...
[16:17:48.929] future_lapply() ...
[16:17:48.933] Number of chunks: 2
[16:17:48.933] getGlobalsAndPackagesXApply() ...
[16:17:48.934]  - future.globals: TRUE
[16:17:48.934] getGlobalsAndPackages() ...
[16:17:48.934] Searching for globals...
[16:17:48.935] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:48.935] Searching for globals ... DONE
[16:17:48.935] Resolving globals: FALSE
[16:17:48.936] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:48.936] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:48.936] - globals: [1] ‘FUN’
[16:17:48.936] 
[16:17:48.936] getGlobalsAndPackages() ... DONE
[16:17:48.936]  - globals found/used: [n=1] ‘FUN’
[16:17:48.937]  - needed namespaces: [n=0] 
[16:17:48.937] Finding globals ... DONE
[16:17:48.937]  - use_args: TRUE
[16:17:48.937]  - Getting '...' globals ...
[16:17:48.937] resolve() on list ...
[16:17:48.937]  recursive: 0
[16:17:48.937]  length: 1
[16:17:48.937]  elements: ‘...’
[16:17:48.938]  length: 0 (resolved future 1)
[16:17:48.938] resolve() on list ... DONE
[16:17:48.938]    - '...' content: [n=1] ‘digits’
[16:17:48.938] List of 1
[16:17:48.938]  $ ...:List of 1
[16:17:48.938]   ..$ digits: int 2
[16:17:48.938]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:48.938]  - attr(*, "where")=List of 1
[16:17:48.938]   ..$ ...:<environment: 0x55b569ceeb40> 
[16:17:48.938]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:48.938]  - attr(*, "resolved")= logi TRUE
[16:17:48.938]  - attr(*, "total_size")= num NA
[16:17:48.941]  - Getting '...' globals ... DONE
[16:17:48.941] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:48.941] List of 2
[16:17:48.941]  $ ...future.FUN:function (object, ...)  
[16:17:48.941]  $ ...          :List of 1
[16:17:48.941]   ..$ digits: int 2
[16:17:48.941]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:48.941]  - attr(*, "where")=List of 2
[16:17:48.941]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:48.941]   ..$ ...          :<environment: 0x55b569ceeb40> 
[16:17:48.941]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:48.941]  - attr(*, "resolved")= logi FALSE
[16:17:48.941]  - attr(*, "total_size")= num 1296
[16:17:48.944] Packages to be attached in all futures: [n=0] 
[16:17:48.944] getGlobalsAndPackagesXApply() ... DONE
[16:17:48.944] Number of futures (= number of chunks): 2
[16:17:48.944] Launching 2 futures (chunks) ...
[16:17:48.944] Chunk #1 of 2 ...
[16:17:48.945]  - Finding globals in 'X' for chunk #1 ...
[16:17:48.945] getGlobalsAndPackages() ...
[16:17:48.945] Searching for globals...
[16:17:48.945] 
[16:17:48.945] Searching for globals ... DONE
[16:17:48.945] - globals: [0] <none>
[16:17:48.945] getGlobalsAndPackages() ... DONE
[16:17:48.945]    + additional globals found: [n=0] 
[16:17:48.945]    + additional namespaces needed: [n=0] 
[16:17:48.946]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:48.946]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:48.946]  - seeds: <none>
[16:17:48.946]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:48.946] getGlobalsAndPackages() ...
[16:17:48.946] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:48.946] Resolving globals: FALSE
[16:17:48.946] Tweak future expression to call with '...' arguments ...
[16:17:48.946] {
[16:17:48.946]     do.call(function(...) {
[16:17:48.946]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:48.946]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:48.946]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:48.946]             on.exit(options(oopts), add = TRUE)
[16:17:48.946]         }
[16:17:48.946]         {
[16:17:48.946]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:48.946]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:48.946]                 ...future.FUN(...future.X_jj, ...)
[16:17:48.946]             })
[16:17:48.946]         }
[16:17:48.946]     }, args = future.call.arguments)
[16:17:48.946] }
[16:17:48.947] Tweak future expression to call with '...' arguments ... DONE
[16:17:48.947] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:48.947] 
[16:17:48.947] getGlobalsAndPackages() ... DONE
[16:17:48.947] run() for ‘Future’ ...
[16:17:48.947] - state: ‘created’
[16:17:48.948] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:48.961] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:48.961] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:48.961]   - Field: ‘node’
[16:17:48.961]   - Field: ‘label’
[16:17:48.961]   - Field: ‘local’
[16:17:48.962]   - Field: ‘owner’
[16:17:48.962]   - Field: ‘envir’
[16:17:48.962]   - Field: ‘workers’
[16:17:48.962]   - Field: ‘packages’
[16:17:48.962]   - Field: ‘gc’
[16:17:48.962]   - Field: ‘conditions’
[16:17:48.962]   - Field: ‘persistent’
[16:17:48.962]   - Field: ‘expr’
[16:17:48.962]   - Field: ‘uuid’
[16:17:48.962]   - Field: ‘seed’
[16:17:48.962]   - Field: ‘version’
[16:17:48.962]   - Field: ‘result’
[16:17:48.963]   - Field: ‘asynchronous’
[16:17:48.963]   - Field: ‘calls’
[16:17:48.963]   - Field: ‘globals’
[16:17:48.963]   - Field: ‘stdout’
[16:17:48.963]   - Field: ‘earlySignal’
[16:17:48.963]   - Field: ‘lazy’
[16:17:48.963]   - Field: ‘state’
[16:17:48.963] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:48.963] - Launch lazy future ...
[16:17:48.964] Packages needed by the future expression (n = 0): <none>
[16:17:48.964] Packages needed by future strategies (n = 0): <none>
[16:17:48.964] {
[16:17:48.964]     {
[16:17:48.964]         {
[16:17:48.964]             ...future.startTime <- base::Sys.time()
[16:17:48.964]             {
[16:17:48.964]                 {
[16:17:48.964]                   {
[16:17:48.964]                     {
[16:17:48.964]                       base::local({
[16:17:48.964]                         has_future <- base::requireNamespace("future", 
[16:17:48.964]                           quietly = TRUE)
[16:17:48.964]                         if (has_future) {
[16:17:48.964]                           ns <- base::getNamespace("future")
[16:17:48.964]                           version <- ns[[".package"]][["version"]]
[16:17:48.964]                           if (is.null(version)) 
[16:17:48.964]                             version <- utils::packageVersion("future")
[16:17:48.964]                         }
[16:17:48.964]                         else {
[16:17:48.964]                           version <- NULL
[16:17:48.964]                         }
[16:17:48.964]                         if (!has_future || version < "1.8.0") {
[16:17:48.964]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:48.964]                             "", base::R.version$version.string), 
[16:17:48.964]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:48.964]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:48.964]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:48.964]                               "release", "version")], collapse = " "), 
[16:17:48.964]                             hostname = base::Sys.info()[["nodename"]])
[16:17:48.964]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:48.964]                             info)
[16:17:48.964]                           info <- base::paste(info, collapse = "; ")
[16:17:48.964]                           if (!has_future) {
[16:17:48.964]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:48.964]                               info)
[16:17:48.964]                           }
[16:17:48.964]                           else {
[16:17:48.964]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:48.964]                               info, version)
[16:17:48.964]                           }
[16:17:48.964]                           base::stop(msg)
[16:17:48.964]                         }
[16:17:48.964]                       })
[16:17:48.964]                     }
[16:17:48.964]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:48.964]                     base::options(mc.cores = 1L)
[16:17:48.964]                   }
[16:17:48.964]                   ...future.strategy.old <- future::plan("list")
[16:17:48.964]                   options(future.plan = NULL)
[16:17:48.964]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:48.964]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:48.964]                 }
[16:17:48.964]                 ...future.workdir <- getwd()
[16:17:48.964]             }
[16:17:48.964]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:48.964]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:48.964]         }
[16:17:48.964]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:48.964]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:48.964]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:48.964]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:48.964]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:48.964]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:48.964]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:48.964]             base::names(...future.oldOptions))
[16:17:48.964]     }
[16:17:48.964]     if (FALSE) {
[16:17:48.964]     }
[16:17:48.964]     else {
[16:17:48.964]         if (TRUE) {
[16:17:48.964]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:48.964]                 open = "w")
[16:17:48.964]         }
[16:17:48.964]         else {
[16:17:48.964]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:48.964]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:48.964]         }
[16:17:48.964]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:48.964]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:48.964]             base::sink(type = "output", split = FALSE)
[16:17:48.964]             base::close(...future.stdout)
[16:17:48.964]         }, add = TRUE)
[16:17:48.964]     }
[16:17:48.964]     ...future.frame <- base::sys.nframe()
[16:17:48.964]     ...future.conditions <- base::list()
[16:17:48.964]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:48.964]     if (FALSE) {
[16:17:48.964]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:48.964]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:48.964]     }
[16:17:48.964]     ...future.result <- base::tryCatch({
[16:17:48.964]         base::withCallingHandlers({
[16:17:48.964]             ...future.value <- base::withVisible(base::local({
[16:17:48.964]                 ...future.makeSendCondition <- base::local({
[16:17:48.964]                   sendCondition <- NULL
[16:17:48.964]                   function(frame = 1L) {
[16:17:48.964]                     if (is.function(sendCondition)) 
[16:17:48.964]                       return(sendCondition)
[16:17:48.964]                     ns <- getNamespace("parallel")
[16:17:48.964]                     if (exists("sendData", mode = "function", 
[16:17:48.964]                       envir = ns)) {
[16:17:48.964]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:48.964]                         envir = ns)
[16:17:48.964]                       envir <- sys.frame(frame)
[16:17:48.964]                       master <- NULL
[16:17:48.964]                       while (!identical(envir, .GlobalEnv) && 
[16:17:48.964]                         !identical(envir, emptyenv())) {
[16:17:48.964]                         if (exists("master", mode = "list", envir = envir, 
[16:17:48.964]                           inherits = FALSE)) {
[16:17:48.964]                           master <- get("master", mode = "list", 
[16:17:48.964]                             envir = envir, inherits = FALSE)
[16:17:48.964]                           if (inherits(master, c("SOCKnode", 
[16:17:48.964]                             "SOCK0node"))) {
[16:17:48.964]                             sendCondition <<- function(cond) {
[16:17:48.964]                               data <- list(type = "VALUE", value = cond, 
[16:17:48.964]                                 success = TRUE)
[16:17:48.964]                               parallel_sendData(master, data)
[16:17:48.964]                             }
[16:17:48.964]                             return(sendCondition)
[16:17:48.964]                           }
[16:17:48.964]                         }
[16:17:48.964]                         frame <- frame + 1L
[16:17:48.964]                         envir <- sys.frame(frame)
[16:17:48.964]                       }
[16:17:48.964]                     }
[16:17:48.964]                     sendCondition <<- function(cond) NULL
[16:17:48.964]                   }
[16:17:48.964]                 })
[16:17:48.964]                 withCallingHandlers({
[16:17:48.964]                   {
[16:17:48.964]                     do.call(function(...) {
[16:17:48.964]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:48.964]                       if (!identical(...future.globals.maxSize.org, 
[16:17:48.964]                         ...future.globals.maxSize)) {
[16:17:48.964]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:48.964]                         on.exit(options(oopts), add = TRUE)
[16:17:48.964]                       }
[16:17:48.964]                       {
[16:17:48.964]                         lapply(seq_along(...future.elements_ii), 
[16:17:48.964]                           FUN = function(jj) {
[16:17:48.964]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:48.964]                             ...future.FUN(...future.X_jj, ...)
[16:17:48.964]                           })
[16:17:48.964]                       }
[16:17:48.964]                     }, args = future.call.arguments)
[16:17:48.964]                   }
[16:17:48.964]                 }, immediateCondition = function(cond) {
[16:17:48.964]                   sendCondition <- ...future.makeSendCondition()
[16:17:48.964]                   sendCondition(cond)
[16:17:48.964]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:48.964]                   {
[16:17:48.964]                     inherits <- base::inherits
[16:17:48.964]                     invokeRestart <- base::invokeRestart
[16:17:48.964]                     is.null <- base::is.null
[16:17:48.964]                     muffled <- FALSE
[16:17:48.964]                     if (inherits(cond, "message")) {
[16:17:48.964]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:48.964]                       if (muffled) 
[16:17:48.964]                         invokeRestart("muffleMessage")
[16:17:48.964]                     }
[16:17:48.964]                     else if (inherits(cond, "warning")) {
[16:17:48.964]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:48.964]                       if (muffled) 
[16:17:48.964]                         invokeRestart("muffleWarning")
[16:17:48.964]                     }
[16:17:48.964]                     else if (inherits(cond, "condition")) {
[16:17:48.964]                       if (!is.null(pattern)) {
[16:17:48.964]                         computeRestarts <- base::computeRestarts
[16:17:48.964]                         grepl <- base::grepl
[16:17:48.964]                         restarts <- computeRestarts(cond)
[16:17:48.964]                         for (restart in restarts) {
[16:17:48.964]                           name <- restart$name
[16:17:48.964]                           if (is.null(name)) 
[16:17:48.964]                             next
[16:17:48.964]                           if (!grepl(pattern, name)) 
[16:17:48.964]                             next
[16:17:48.964]                           invokeRestart(restart)
[16:17:48.964]                           muffled <- TRUE
[16:17:48.964]                           break
[16:17:48.964]                         }
[16:17:48.964]                       }
[16:17:48.964]                     }
[16:17:48.964]                     invisible(muffled)
[16:17:48.964]                   }
[16:17:48.964]                   muffleCondition(cond)
[16:17:48.964]                 })
[16:17:48.964]             }))
[16:17:48.964]             future::FutureResult(value = ...future.value$value, 
[16:17:48.964]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:48.964]                   ...future.rng), globalenv = if (FALSE) 
[16:17:48.964]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:48.964]                     ...future.globalenv.names))
[16:17:48.964]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:48.964]         }, condition = base::local({
[16:17:48.964]             c <- base::c
[16:17:48.964]             inherits <- base::inherits
[16:17:48.964]             invokeRestart <- base::invokeRestart
[16:17:48.964]             length <- base::length
[16:17:48.964]             list <- base::list
[16:17:48.964]             seq.int <- base::seq.int
[16:17:48.964]             signalCondition <- base::signalCondition
[16:17:48.964]             sys.calls <- base::sys.calls
[16:17:48.964]             `[[` <- base::`[[`
[16:17:48.964]             `+` <- base::`+`
[16:17:48.964]             `<<-` <- base::`<<-`
[16:17:48.964]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:48.964]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:48.964]                   3L)]
[16:17:48.964]             }
[16:17:48.964]             function(cond) {
[16:17:48.964]                 is_error <- inherits(cond, "error")
[16:17:48.964]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:48.964]                   NULL)
[16:17:48.964]                 if (is_error) {
[16:17:48.964]                   sessionInformation <- function() {
[16:17:48.964]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:48.964]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:48.964]                       search = base::search(), system = base::Sys.info())
[16:17:48.964]                   }
[16:17:48.964]                   ...future.conditions[[length(...future.conditions) + 
[16:17:48.964]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:48.964]                     cond$call), session = sessionInformation(), 
[16:17:48.964]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:48.964]                   signalCondition(cond)
[16:17:48.964]                 }
[16:17:48.964]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:48.964]                 "immediateCondition"))) {
[16:17:48.964]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:48.964]                   ...future.conditions[[length(...future.conditions) + 
[16:17:48.964]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:48.964]                   if (TRUE && !signal) {
[16:17:48.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:48.964]                     {
[16:17:48.964]                       inherits <- base::inherits
[16:17:48.964]                       invokeRestart <- base::invokeRestart
[16:17:48.964]                       is.null <- base::is.null
[16:17:48.964]                       muffled <- FALSE
[16:17:48.964]                       if (inherits(cond, "message")) {
[16:17:48.964]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:48.964]                         if (muffled) 
[16:17:48.964]                           invokeRestart("muffleMessage")
[16:17:48.964]                       }
[16:17:48.964]                       else if (inherits(cond, "warning")) {
[16:17:48.964]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:48.964]                         if (muffled) 
[16:17:48.964]                           invokeRestart("muffleWarning")
[16:17:48.964]                       }
[16:17:48.964]                       else if (inherits(cond, "condition")) {
[16:17:48.964]                         if (!is.null(pattern)) {
[16:17:48.964]                           computeRestarts <- base::computeRestarts
[16:17:48.964]                           grepl <- base::grepl
[16:17:48.964]                           restarts <- computeRestarts(cond)
[16:17:48.964]                           for (restart in restarts) {
[16:17:48.964]                             name <- restart$name
[16:17:48.964]                             if (is.null(name)) 
[16:17:48.964]                               next
[16:17:48.964]                             if (!grepl(pattern, name)) 
[16:17:48.964]                               next
[16:17:48.964]                             invokeRestart(restart)
[16:17:48.964]                             muffled <- TRUE
[16:17:48.964]                             break
[16:17:48.964]                           }
[16:17:48.964]                         }
[16:17:48.964]                       }
[16:17:48.964]                       invisible(muffled)
[16:17:48.964]                     }
[16:17:48.964]                     muffleCondition(cond, pattern = "^muffle")
[16:17:48.964]                   }
[16:17:48.964]                 }
[16:17:48.964]                 else {
[16:17:48.964]                   if (TRUE) {
[16:17:48.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:48.964]                     {
[16:17:48.964]                       inherits <- base::inherits
[16:17:48.964]                       invokeRestart <- base::invokeRestart
[16:17:48.964]                       is.null <- base::is.null
[16:17:48.964]                       muffled <- FALSE
[16:17:48.964]                       if (inherits(cond, "message")) {
[16:17:48.964]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:48.964]                         if (muffled) 
[16:17:48.964]                           invokeRestart("muffleMessage")
[16:17:48.964]                       }
[16:17:48.964]                       else if (inherits(cond, "warning")) {
[16:17:48.964]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:48.964]                         if (muffled) 
[16:17:48.964]                           invokeRestart("muffleWarning")
[16:17:48.964]                       }
[16:17:48.964]                       else if (inherits(cond, "condition")) {
[16:17:48.964]                         if (!is.null(pattern)) {
[16:17:48.964]                           computeRestarts <- base::computeRestarts
[16:17:48.964]                           grepl <- base::grepl
[16:17:48.964]                           restarts <- computeRestarts(cond)
[16:17:48.964]                           for (restart in restarts) {
[16:17:48.964]                             name <- restart$name
[16:17:48.964]                             if (is.null(name)) 
[16:17:48.964]                               next
[16:17:48.964]                             if (!grepl(pattern, name)) 
[16:17:48.964]                               next
[16:17:48.964]                             invokeRestart(restart)
[16:17:48.964]                             muffled <- TRUE
[16:17:48.964]                             break
[16:17:48.964]                           }
[16:17:48.964]                         }
[16:17:48.964]                       }
[16:17:48.964]                       invisible(muffled)
[16:17:48.964]                     }
[16:17:48.964]                     muffleCondition(cond, pattern = "^muffle")
[16:17:48.964]                   }
[16:17:48.964]                 }
[16:17:48.964]             }
[16:17:48.964]         }))
[16:17:48.964]     }, error = function(ex) {
[16:17:48.964]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:48.964]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:48.964]                 ...future.rng), started = ...future.startTime, 
[16:17:48.964]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:48.964]             version = "1.8"), class = "FutureResult")
[16:17:48.964]     }, finally = {
[16:17:48.964]         if (!identical(...future.workdir, getwd())) 
[16:17:48.964]             setwd(...future.workdir)
[16:17:48.964]         {
[16:17:48.964]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:48.964]                 ...future.oldOptions$nwarnings <- NULL
[16:17:48.964]             }
[16:17:48.964]             base::options(...future.oldOptions)
[16:17:48.964]             if (.Platform$OS.type == "windows") {
[16:17:48.964]                 old_names <- names(...future.oldEnvVars)
[16:17:48.964]                 envs <- base::Sys.getenv()
[16:17:48.964]                 names <- names(envs)
[16:17:48.964]                 common <- intersect(names, old_names)
[16:17:48.964]                 added <- setdiff(names, old_names)
[16:17:48.964]                 removed <- setdiff(old_names, names)
[16:17:48.964]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:48.964]                   envs[common]]
[16:17:48.964]                 NAMES <- toupper(changed)
[16:17:48.964]                 args <- list()
[16:17:48.964]                 for (kk in seq_along(NAMES)) {
[16:17:48.964]                   name <- changed[[kk]]
[16:17:48.964]                   NAME <- NAMES[[kk]]
[16:17:48.964]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:48.964]                     next
[16:17:48.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:48.964]                 }
[16:17:48.964]                 NAMES <- toupper(added)
[16:17:48.964]                 for (kk in seq_along(NAMES)) {
[16:17:48.964]                   name <- added[[kk]]
[16:17:48.964]                   NAME <- NAMES[[kk]]
[16:17:48.964]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:48.964]                     next
[16:17:48.964]                   args[[name]] <- ""
[16:17:48.964]                 }
[16:17:48.964]                 NAMES <- toupper(removed)
[16:17:48.964]                 for (kk in seq_along(NAMES)) {
[16:17:48.964]                   name <- removed[[kk]]
[16:17:48.964]                   NAME <- NAMES[[kk]]
[16:17:48.964]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:48.964]                     next
[16:17:48.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:48.964]                 }
[16:17:48.964]                 if (length(args) > 0) 
[16:17:48.964]                   base::do.call(base::Sys.setenv, args = args)
[16:17:48.964]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:48.964]             }
[16:17:48.964]             else {
[16:17:48.964]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:48.964]             }
[16:17:48.964]             {
[16:17:48.964]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:48.964]                   0L) {
[16:17:48.964]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:48.964]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:48.964]                   base::options(opts)
[16:17:48.964]                 }
[16:17:48.964]                 {
[16:17:48.964]                   {
[16:17:48.964]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:48.964]                     NULL
[16:17:48.964]                   }
[16:17:48.964]                   options(future.plan = NULL)
[16:17:48.964]                   if (is.na(NA_character_)) 
[16:17:48.964]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:48.964]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:48.964]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:48.964]                     .init = FALSE)
[16:17:48.964]                 }
[16:17:48.964]             }
[16:17:48.964]         }
[16:17:48.964]     })
[16:17:48.964]     if (TRUE) {
[16:17:48.964]         base::sink(type = "output", split = FALSE)
[16:17:48.964]         if (TRUE) {
[16:17:48.964]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:48.964]         }
[16:17:48.964]         else {
[16:17:48.964]             ...future.result["stdout"] <- base::list(NULL)
[16:17:48.964]         }
[16:17:48.964]         base::close(...future.stdout)
[16:17:48.964]         ...future.stdout <- NULL
[16:17:48.964]     }
[16:17:48.964]     ...future.result$conditions <- ...future.conditions
[16:17:48.964]     ...future.result$finished <- base::Sys.time()
[16:17:48.964]     ...future.result
[16:17:48.964] }
[16:17:48.967] Exporting 5 global objects (1.27 KiB) to cluster node #1 ...
[16:17:48.967] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[16:17:48.967] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[16:17:48.968] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[16:17:48.968] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[16:17:48.968] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ...
[16:17:48.968] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ... DONE
[16:17:48.968] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:17:48.969] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:17:48.969] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:17:48.969] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:17:48.969] Exporting 5 global objects (1.27 KiB) to cluster node #1 ... DONE
[16:17:48.970] MultisessionFuture started
[16:17:48.970] - Launch lazy future ... done
[16:17:48.970] run() for ‘MultisessionFuture’ ... done
[16:17:48.970] Created future:
[16:17:48.970] MultisessionFuture:
[16:17:48.970] Label: ‘future_by-1’
[16:17:48.970] Expression:
[16:17:48.970] {
[16:17:48.970]     do.call(function(...) {
[16:17:48.970]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:48.970]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:48.970]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:48.970]             on.exit(options(oopts), add = TRUE)
[16:17:48.970]         }
[16:17:48.970]         {
[16:17:48.970]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:48.970]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:48.970]                 ...future.FUN(...future.X_jj, ...)
[16:17:48.970]             })
[16:17:48.970]         }
[16:17:48.970]     }, args = future.call.arguments)
[16:17:48.970] }
[16:17:48.970] Lazy evaluation: FALSE
[16:17:48.970] Asynchronous evaluation: TRUE
[16:17:48.970] Local evaluation: TRUE
[16:17:48.970] Environment: R_GlobalEnv
[16:17:48.970] Capture standard output: TRUE
[16:17:48.970] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:48.970] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:48.970] Packages: <none>
[16:17:48.970] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:48.970] Resolved: FALSE
[16:17:48.970] Value: <not collected>
[16:17:48.970] Conditions captured: <none>
[16:17:48.970] Early signaling: FALSE
[16:17:48.970] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:48.970] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:48.981] Chunk #1 of 2 ... DONE
[16:17:48.982] Chunk #2 of 2 ...
[16:17:48.982]  - Finding globals in 'X' for chunk #2 ...
[16:17:48.982] getGlobalsAndPackages() ...
[16:17:48.982] Searching for globals...
[16:17:48.982] 
[16:17:48.982] Searching for globals ... DONE
[16:17:48.982] - globals: [0] <none>
[16:17:48.982] getGlobalsAndPackages() ... DONE
[16:17:48.982]    + additional globals found: [n=0] 
[16:17:48.983]    + additional namespaces needed: [n=0] 
[16:17:48.983]  - Finding globals in 'X' for chunk #2 ... DONE
[16:17:48.983]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:48.983]  - seeds: <none>
[16:17:48.983]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:48.983] getGlobalsAndPackages() ...
[16:17:48.983] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:48.983] Resolving globals: FALSE
[16:17:48.983] Tweak future expression to call with '...' arguments ...
[16:17:48.983] {
[16:17:48.983]     do.call(function(...) {
[16:17:48.983]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:48.983]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:48.983]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:48.983]             on.exit(options(oopts), add = TRUE)
[16:17:48.983]         }
[16:17:48.983]         {
[16:17:48.983]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:48.983]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:48.983]                 ...future.FUN(...future.X_jj, ...)
[16:17:48.983]             })
[16:17:48.983]         }
[16:17:48.983]     }, args = future.call.arguments)
[16:17:48.983] }
[16:17:48.984] Tweak future expression to call with '...' arguments ... DONE
[16:17:48.984] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:48.984] 
[16:17:48.984] getGlobalsAndPackages() ... DONE
[16:17:48.984] run() for ‘Future’ ...
[16:17:48.985] - state: ‘created’
[16:17:48.985] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:48.998] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:48.998] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:48.998]   - Field: ‘node’
[16:17:48.998]   - Field: ‘label’
[16:17:48.998]   - Field: ‘local’
[16:17:48.998]   - Field: ‘owner’
[16:17:48.998]   - Field: ‘envir’
[16:17:48.998]   - Field: ‘workers’
[16:17:48.999]   - Field: ‘packages’
[16:17:48.999]   - Field: ‘gc’
[16:17:48.999]   - Field: ‘conditions’
[16:17:48.999]   - Field: ‘persistent’
[16:17:48.999]   - Field: ‘expr’
[16:17:48.999]   - Field: ‘uuid’
[16:17:48.999]   - Field: ‘seed’
[16:17:48.999]   - Field: ‘version’
[16:17:48.999]   - Field: ‘result’
[16:17:48.999]   - Field: ‘asynchronous’
[16:17:48.999]   - Field: ‘calls’
[16:17:49.000]   - Field: ‘globals’
[16:17:49.000]   - Field: ‘stdout’
[16:17:49.000]   - Field: ‘earlySignal’
[16:17:49.000]   - Field: ‘lazy’
[16:17:49.000]   - Field: ‘state’
[16:17:49.000] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:49.000] - Launch lazy future ...
[16:17:49.000] Packages needed by the future expression (n = 0): <none>
[16:17:49.000] Packages needed by future strategies (n = 0): <none>
[16:17:49.001] {
[16:17:49.001]     {
[16:17:49.001]         {
[16:17:49.001]             ...future.startTime <- base::Sys.time()
[16:17:49.001]             {
[16:17:49.001]                 {
[16:17:49.001]                   {
[16:17:49.001]                     {
[16:17:49.001]                       base::local({
[16:17:49.001]                         has_future <- base::requireNamespace("future", 
[16:17:49.001]                           quietly = TRUE)
[16:17:49.001]                         if (has_future) {
[16:17:49.001]                           ns <- base::getNamespace("future")
[16:17:49.001]                           version <- ns[[".package"]][["version"]]
[16:17:49.001]                           if (is.null(version)) 
[16:17:49.001]                             version <- utils::packageVersion("future")
[16:17:49.001]                         }
[16:17:49.001]                         else {
[16:17:49.001]                           version <- NULL
[16:17:49.001]                         }
[16:17:49.001]                         if (!has_future || version < "1.8.0") {
[16:17:49.001]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:49.001]                             "", base::R.version$version.string), 
[16:17:49.001]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:49.001]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:49.001]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:49.001]                               "release", "version")], collapse = " "), 
[16:17:49.001]                             hostname = base::Sys.info()[["nodename"]])
[16:17:49.001]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:49.001]                             info)
[16:17:49.001]                           info <- base::paste(info, collapse = "; ")
[16:17:49.001]                           if (!has_future) {
[16:17:49.001]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:49.001]                               info)
[16:17:49.001]                           }
[16:17:49.001]                           else {
[16:17:49.001]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:49.001]                               info, version)
[16:17:49.001]                           }
[16:17:49.001]                           base::stop(msg)
[16:17:49.001]                         }
[16:17:49.001]                       })
[16:17:49.001]                     }
[16:17:49.001]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:49.001]                     base::options(mc.cores = 1L)
[16:17:49.001]                   }
[16:17:49.001]                   ...future.strategy.old <- future::plan("list")
[16:17:49.001]                   options(future.plan = NULL)
[16:17:49.001]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:49.001]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:49.001]                 }
[16:17:49.001]                 ...future.workdir <- getwd()
[16:17:49.001]             }
[16:17:49.001]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:49.001]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:49.001]         }
[16:17:49.001]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:49.001]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:49.001]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:49.001]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:49.001]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:49.001]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:49.001]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:49.001]             base::names(...future.oldOptions))
[16:17:49.001]     }
[16:17:49.001]     if (FALSE) {
[16:17:49.001]     }
[16:17:49.001]     else {
[16:17:49.001]         if (TRUE) {
[16:17:49.001]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:49.001]                 open = "w")
[16:17:49.001]         }
[16:17:49.001]         else {
[16:17:49.001]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:49.001]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:49.001]         }
[16:17:49.001]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:49.001]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:49.001]             base::sink(type = "output", split = FALSE)
[16:17:49.001]             base::close(...future.stdout)
[16:17:49.001]         }, add = TRUE)
[16:17:49.001]     }
[16:17:49.001]     ...future.frame <- base::sys.nframe()
[16:17:49.001]     ...future.conditions <- base::list()
[16:17:49.001]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:49.001]     if (FALSE) {
[16:17:49.001]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:49.001]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:49.001]     }
[16:17:49.001]     ...future.result <- base::tryCatch({
[16:17:49.001]         base::withCallingHandlers({
[16:17:49.001]             ...future.value <- base::withVisible(base::local({
[16:17:49.001]                 ...future.makeSendCondition <- base::local({
[16:17:49.001]                   sendCondition <- NULL
[16:17:49.001]                   function(frame = 1L) {
[16:17:49.001]                     if (is.function(sendCondition)) 
[16:17:49.001]                       return(sendCondition)
[16:17:49.001]                     ns <- getNamespace("parallel")
[16:17:49.001]                     if (exists("sendData", mode = "function", 
[16:17:49.001]                       envir = ns)) {
[16:17:49.001]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:49.001]                         envir = ns)
[16:17:49.001]                       envir <- sys.frame(frame)
[16:17:49.001]                       master <- NULL
[16:17:49.001]                       while (!identical(envir, .GlobalEnv) && 
[16:17:49.001]                         !identical(envir, emptyenv())) {
[16:17:49.001]                         if (exists("master", mode = "list", envir = envir, 
[16:17:49.001]                           inherits = FALSE)) {
[16:17:49.001]                           master <- get("master", mode = "list", 
[16:17:49.001]                             envir = envir, inherits = FALSE)
[16:17:49.001]                           if (inherits(master, c("SOCKnode", 
[16:17:49.001]                             "SOCK0node"))) {
[16:17:49.001]                             sendCondition <<- function(cond) {
[16:17:49.001]                               data <- list(type = "VALUE", value = cond, 
[16:17:49.001]                                 success = TRUE)
[16:17:49.001]                               parallel_sendData(master, data)
[16:17:49.001]                             }
[16:17:49.001]                             return(sendCondition)
[16:17:49.001]                           }
[16:17:49.001]                         }
[16:17:49.001]                         frame <- frame + 1L
[16:17:49.001]                         envir <- sys.frame(frame)
[16:17:49.001]                       }
[16:17:49.001]                     }
[16:17:49.001]                     sendCondition <<- function(cond) NULL
[16:17:49.001]                   }
[16:17:49.001]                 })
[16:17:49.001]                 withCallingHandlers({
[16:17:49.001]                   {
[16:17:49.001]                     do.call(function(...) {
[16:17:49.001]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.001]                       if (!identical(...future.globals.maxSize.org, 
[16:17:49.001]                         ...future.globals.maxSize)) {
[16:17:49.001]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.001]                         on.exit(options(oopts), add = TRUE)
[16:17:49.001]                       }
[16:17:49.001]                       {
[16:17:49.001]                         lapply(seq_along(...future.elements_ii), 
[16:17:49.001]                           FUN = function(jj) {
[16:17:49.001]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.001]                             ...future.FUN(...future.X_jj, ...)
[16:17:49.001]                           })
[16:17:49.001]                       }
[16:17:49.001]                     }, args = future.call.arguments)
[16:17:49.001]                   }
[16:17:49.001]                 }, immediateCondition = function(cond) {
[16:17:49.001]                   sendCondition <- ...future.makeSendCondition()
[16:17:49.001]                   sendCondition(cond)
[16:17:49.001]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.001]                   {
[16:17:49.001]                     inherits <- base::inherits
[16:17:49.001]                     invokeRestart <- base::invokeRestart
[16:17:49.001]                     is.null <- base::is.null
[16:17:49.001]                     muffled <- FALSE
[16:17:49.001]                     if (inherits(cond, "message")) {
[16:17:49.001]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:49.001]                       if (muffled) 
[16:17:49.001]                         invokeRestart("muffleMessage")
[16:17:49.001]                     }
[16:17:49.001]                     else if (inherits(cond, "warning")) {
[16:17:49.001]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:49.001]                       if (muffled) 
[16:17:49.001]                         invokeRestart("muffleWarning")
[16:17:49.001]                     }
[16:17:49.001]                     else if (inherits(cond, "condition")) {
[16:17:49.001]                       if (!is.null(pattern)) {
[16:17:49.001]                         computeRestarts <- base::computeRestarts
[16:17:49.001]                         grepl <- base::grepl
[16:17:49.001]                         restarts <- computeRestarts(cond)
[16:17:49.001]                         for (restart in restarts) {
[16:17:49.001]                           name <- restart$name
[16:17:49.001]                           if (is.null(name)) 
[16:17:49.001]                             next
[16:17:49.001]                           if (!grepl(pattern, name)) 
[16:17:49.001]                             next
[16:17:49.001]                           invokeRestart(restart)
[16:17:49.001]                           muffled <- TRUE
[16:17:49.001]                           break
[16:17:49.001]                         }
[16:17:49.001]                       }
[16:17:49.001]                     }
[16:17:49.001]                     invisible(muffled)
[16:17:49.001]                   }
[16:17:49.001]                   muffleCondition(cond)
[16:17:49.001]                 })
[16:17:49.001]             }))
[16:17:49.001]             future::FutureResult(value = ...future.value$value, 
[16:17:49.001]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:49.001]                   ...future.rng), globalenv = if (FALSE) 
[16:17:49.001]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:49.001]                     ...future.globalenv.names))
[16:17:49.001]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:49.001]         }, condition = base::local({
[16:17:49.001]             c <- base::c
[16:17:49.001]             inherits <- base::inherits
[16:17:49.001]             invokeRestart <- base::invokeRestart
[16:17:49.001]             length <- base::length
[16:17:49.001]             list <- base::list
[16:17:49.001]             seq.int <- base::seq.int
[16:17:49.001]             signalCondition <- base::signalCondition
[16:17:49.001]             sys.calls <- base::sys.calls
[16:17:49.001]             `[[` <- base::`[[`
[16:17:49.001]             `+` <- base::`+`
[16:17:49.001]             `<<-` <- base::`<<-`
[16:17:49.001]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:49.001]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:49.001]                   3L)]
[16:17:49.001]             }
[16:17:49.001]             function(cond) {
[16:17:49.001]                 is_error <- inherits(cond, "error")
[16:17:49.001]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:49.001]                   NULL)
[16:17:49.001]                 if (is_error) {
[16:17:49.001]                   sessionInformation <- function() {
[16:17:49.001]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:49.001]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:49.001]                       search = base::search(), system = base::Sys.info())
[16:17:49.001]                   }
[16:17:49.001]                   ...future.conditions[[length(...future.conditions) + 
[16:17:49.001]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:49.001]                     cond$call), session = sessionInformation(), 
[16:17:49.001]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:49.001]                   signalCondition(cond)
[16:17:49.001]                 }
[16:17:49.001]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:49.001]                 "immediateCondition"))) {
[16:17:49.001]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:49.001]                   ...future.conditions[[length(...future.conditions) + 
[16:17:49.001]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:49.001]                   if (TRUE && !signal) {
[16:17:49.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.001]                     {
[16:17:49.001]                       inherits <- base::inherits
[16:17:49.001]                       invokeRestart <- base::invokeRestart
[16:17:49.001]                       is.null <- base::is.null
[16:17:49.001]                       muffled <- FALSE
[16:17:49.001]                       if (inherits(cond, "message")) {
[16:17:49.001]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:49.001]                         if (muffled) 
[16:17:49.001]                           invokeRestart("muffleMessage")
[16:17:49.001]                       }
[16:17:49.001]                       else if (inherits(cond, "warning")) {
[16:17:49.001]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:49.001]                         if (muffled) 
[16:17:49.001]                           invokeRestart("muffleWarning")
[16:17:49.001]                       }
[16:17:49.001]                       else if (inherits(cond, "condition")) {
[16:17:49.001]                         if (!is.null(pattern)) {
[16:17:49.001]                           computeRestarts <- base::computeRestarts
[16:17:49.001]                           grepl <- base::grepl
[16:17:49.001]                           restarts <- computeRestarts(cond)
[16:17:49.001]                           for (restart in restarts) {
[16:17:49.001]                             name <- restart$name
[16:17:49.001]                             if (is.null(name)) 
[16:17:49.001]                               next
[16:17:49.001]                             if (!grepl(pattern, name)) 
[16:17:49.001]                               next
[16:17:49.001]                             invokeRestart(restart)
[16:17:49.001]                             muffled <- TRUE
[16:17:49.001]                             break
[16:17:49.001]                           }
[16:17:49.001]                         }
[16:17:49.001]                       }
[16:17:49.001]                       invisible(muffled)
[16:17:49.001]                     }
[16:17:49.001]                     muffleCondition(cond, pattern = "^muffle")
[16:17:49.001]                   }
[16:17:49.001]                 }
[16:17:49.001]                 else {
[16:17:49.001]                   if (TRUE) {
[16:17:49.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.001]                     {
[16:17:49.001]                       inherits <- base::inherits
[16:17:49.001]                       invokeRestart <- base::invokeRestart
[16:17:49.001]                       is.null <- base::is.null
[16:17:49.001]                       muffled <- FALSE
[16:17:49.001]                       if (inherits(cond, "message")) {
[16:17:49.001]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:49.001]                         if (muffled) 
[16:17:49.001]                           invokeRestart("muffleMessage")
[16:17:49.001]                       }
[16:17:49.001]                       else if (inherits(cond, "warning")) {
[16:17:49.001]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:49.001]                         if (muffled) 
[16:17:49.001]                           invokeRestart("muffleWarning")
[16:17:49.001]                       }
[16:17:49.001]                       else if (inherits(cond, "condition")) {
[16:17:49.001]                         if (!is.null(pattern)) {
[16:17:49.001]                           computeRestarts <- base::computeRestarts
[16:17:49.001]                           grepl <- base::grepl
[16:17:49.001]                           restarts <- computeRestarts(cond)
[16:17:49.001]                           for (restart in restarts) {
[16:17:49.001]                             name <- restart$name
[16:17:49.001]                             if (is.null(name)) 
[16:17:49.001]                               next
[16:17:49.001]                             if (!grepl(pattern, name)) 
[16:17:49.001]                               next
[16:17:49.001]                             invokeRestart(restart)
[16:17:49.001]                             muffled <- TRUE
[16:17:49.001]                             break
[16:17:49.001]                           }
[16:17:49.001]                         }
[16:17:49.001]                       }
[16:17:49.001]                       invisible(muffled)
[16:17:49.001]                     }
[16:17:49.001]                     muffleCondition(cond, pattern = "^muffle")
[16:17:49.001]                   }
[16:17:49.001]                 }
[16:17:49.001]             }
[16:17:49.001]         }))
[16:17:49.001]     }, error = function(ex) {
[16:17:49.001]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:49.001]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:49.001]                 ...future.rng), started = ...future.startTime, 
[16:17:49.001]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:49.001]             version = "1.8"), class = "FutureResult")
[16:17:49.001]     }, finally = {
[16:17:49.001]         if (!identical(...future.workdir, getwd())) 
[16:17:49.001]             setwd(...future.workdir)
[16:17:49.001]         {
[16:17:49.001]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:49.001]                 ...future.oldOptions$nwarnings <- NULL
[16:17:49.001]             }
[16:17:49.001]             base::options(...future.oldOptions)
[16:17:49.001]             if (.Platform$OS.type == "windows") {
[16:17:49.001]                 old_names <- names(...future.oldEnvVars)
[16:17:49.001]                 envs <- base::Sys.getenv()
[16:17:49.001]                 names <- names(envs)
[16:17:49.001]                 common <- intersect(names, old_names)
[16:17:49.001]                 added <- setdiff(names, old_names)
[16:17:49.001]                 removed <- setdiff(old_names, names)
[16:17:49.001]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:49.001]                   envs[common]]
[16:17:49.001]                 NAMES <- toupper(changed)
[16:17:49.001]                 args <- list()
[16:17:49.001]                 for (kk in seq_along(NAMES)) {
[16:17:49.001]                   name <- changed[[kk]]
[16:17:49.001]                   NAME <- NAMES[[kk]]
[16:17:49.001]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.001]                     next
[16:17:49.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:49.001]                 }
[16:17:49.001]                 NAMES <- toupper(added)
[16:17:49.001]                 for (kk in seq_along(NAMES)) {
[16:17:49.001]                   name <- added[[kk]]
[16:17:49.001]                   NAME <- NAMES[[kk]]
[16:17:49.001]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.001]                     next
[16:17:49.001]                   args[[name]] <- ""
[16:17:49.001]                 }
[16:17:49.001]                 NAMES <- toupper(removed)
[16:17:49.001]                 for (kk in seq_along(NAMES)) {
[16:17:49.001]                   name <- removed[[kk]]
[16:17:49.001]                   NAME <- NAMES[[kk]]
[16:17:49.001]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.001]                     next
[16:17:49.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:49.001]                 }
[16:17:49.001]                 if (length(args) > 0) 
[16:17:49.001]                   base::do.call(base::Sys.setenv, args = args)
[16:17:49.001]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:49.001]             }
[16:17:49.001]             else {
[16:17:49.001]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:49.001]             }
[16:17:49.001]             {
[16:17:49.001]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:49.001]                   0L) {
[16:17:49.001]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:49.001]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:49.001]                   base::options(opts)
[16:17:49.001]                 }
[16:17:49.001]                 {
[16:17:49.001]                   {
[16:17:49.001]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:49.001]                     NULL
[16:17:49.001]                   }
[16:17:49.001]                   options(future.plan = NULL)
[16:17:49.001]                   if (is.na(NA_character_)) 
[16:17:49.001]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:49.001]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:49.001]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:49.001]                     .init = FALSE)
[16:17:49.001]                 }
[16:17:49.001]             }
[16:17:49.001]         }
[16:17:49.001]     })
[16:17:49.001]     if (TRUE) {
[16:17:49.001]         base::sink(type = "output", split = FALSE)
[16:17:49.001]         if (TRUE) {
[16:17:49.001]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:49.001]         }
[16:17:49.001]         else {
[16:17:49.001]             ...future.result["stdout"] <- base::list(NULL)
[16:17:49.001]         }
[16:17:49.001]         base::close(...future.stdout)
[16:17:49.001]         ...future.stdout <- NULL
[16:17:49.001]     }
[16:17:49.001]     ...future.result$conditions <- ...future.conditions
[16:17:49.001]     ...future.result$finished <- base::Sys.time()
[16:17:49.001]     ...future.result
[16:17:49.001] }
[16:17:49.003] Exporting 5 global objects (1.27 KiB) to cluster node #2 ...
[16:17:49.003] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[16:17:49.004] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[16:17:49.004] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[16:17:49.004] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[16:17:49.005] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ...
[16:17:49.005] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ... DONE
[16:17:49.005] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:17:49.005] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:17:49.005] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:17:49.006] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:17:49.006] Exporting 5 global objects (1.27 KiB) to cluster node #2 ... DONE
[16:17:49.006] MultisessionFuture started
[16:17:49.006] - Launch lazy future ... done
[16:17:49.006] run() for ‘MultisessionFuture’ ... done
[16:17:49.007] Created future:
[16:17:49.007] MultisessionFuture:
[16:17:49.007] Label: ‘future_by-2’
[16:17:49.007] Expression:
[16:17:49.007] {
[16:17:49.007]     do.call(function(...) {
[16:17:49.007]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.007]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:49.007]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.007]             on.exit(options(oopts), add = TRUE)
[16:17:49.007]         }
[16:17:49.007]         {
[16:17:49.007]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:49.007]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.007]                 ...future.FUN(...future.X_jj, ...)
[16:17:49.007]             })
[16:17:49.007]         }
[16:17:49.007]     }, args = future.call.arguments)
[16:17:49.007] }
[16:17:49.007] Lazy evaluation: FALSE
[16:17:49.007] Asynchronous evaluation: TRUE
[16:17:49.007] Local evaluation: TRUE
[16:17:49.007] Environment: R_GlobalEnv
[16:17:49.007] Capture standard output: TRUE
[16:17:49.007] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:49.007] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:49.007] Packages: <none>
[16:17:49.007] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:49.007] Resolved: FALSE
[16:17:49.007] Value: <not collected>
[16:17:49.007] Conditions captured: <none>
[16:17:49.007] Early signaling: FALSE
[16:17:49.007] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:49.007] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:49.018] Chunk #2 of 2 ... DONE
[16:17:49.018] Launching 2 futures (chunks) ... DONE
[16:17:49.018] Resolving 2 futures (chunks) ...
[16:17:49.018] resolve() on list ...
[16:17:49.018]  recursive: 0
[16:17:49.018]  length: 2
[16:17:49.019] 
[16:17:49.019] receiveMessageFromWorker() for ClusterFuture ...
[16:17:49.019] - Validating connection of MultisessionFuture
[16:17:49.019] - received message: FutureResult
[16:17:49.019] - Received FutureResult
[16:17:49.019] - Erased future from FutureRegistry
[16:17:49.020] result() for ClusterFuture ...
[16:17:49.020] - result already collected: FutureResult
[16:17:49.020] result() for ClusterFuture ... done
[16:17:49.020] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:49.020] Future #1
[16:17:49.020] result() for ClusterFuture ...
[16:17:49.020] - result already collected: FutureResult
[16:17:49.020] result() for ClusterFuture ... done
[16:17:49.020] result() for ClusterFuture ...
[16:17:49.020] - result already collected: FutureResult
[16:17:49.020] result() for ClusterFuture ... done
[16:17:49.021] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:17:49.021] - nx: 2
[16:17:49.021] - relay: TRUE
[16:17:49.021] - stdout: TRUE
[16:17:49.021] - signal: TRUE
[16:17:49.021] - resignal: FALSE
[16:17:49.021] - force: TRUE
[16:17:49.021] - relayed: [n=2] FALSE, FALSE
[16:17:49.021] - queued futures: [n=2] FALSE, FALSE
[16:17:49.021]  - until=1
[16:17:49.021]  - relaying element #1
[16:17:49.022] result() for ClusterFuture ...
[16:17:49.022] - result already collected: FutureResult
[16:17:49.022] result() for ClusterFuture ... done
[16:17:49.022] result() for ClusterFuture ...
[16:17:49.022] - result already collected: FutureResult
[16:17:49.022] result() for ClusterFuture ... done
[16:17:49.022] result() for ClusterFuture ...
[16:17:49.022] - result already collected: FutureResult
[16:17:49.022] result() for ClusterFuture ... done
[16:17:49.022] result() for ClusterFuture ...
[16:17:49.022] - result already collected: FutureResult
[16:17:49.022] result() for ClusterFuture ... done
[16:17:49.023] - relayed: [n=2] TRUE, FALSE
[16:17:49.023] - queued futures: [n=2] TRUE, FALSE
[16:17:49.023] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:17:49.023]  length: 1 (resolved future 1)
[16:17:49.050] receiveMessageFromWorker() for ClusterFuture ...
[16:17:49.050] - Validating connection of MultisessionFuture
[16:17:49.051] - received message: FutureResult
[16:17:49.051] - Received FutureResult
[16:17:49.051] - Erased future from FutureRegistry
[16:17:49.051] result() for ClusterFuture ...
[16:17:49.051] - result already collected: FutureResult
[16:17:49.051] result() for ClusterFuture ... done
[16:17:49.051] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:49.051] Future #2
[16:17:49.051] result() for ClusterFuture ...
[16:17:49.051] - result already collected: FutureResult
[16:17:49.052] result() for ClusterFuture ... done
[16:17:49.052] result() for ClusterFuture ...
[16:17:49.052] - result already collected: FutureResult
[16:17:49.052] result() for ClusterFuture ... done
[16:17:49.052] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:17:49.052] - nx: 2
[16:17:49.052] - relay: TRUE
[16:17:49.052] - stdout: TRUE
[16:17:49.052] - signal: TRUE
[16:17:49.052] - resignal: FALSE
[16:17:49.052] - force: TRUE
[16:17:49.053] - relayed: [n=2] TRUE, FALSE
[16:17:49.053] - queued futures: [n=2] TRUE, FALSE
[16:17:49.053]  - until=2
[16:17:49.053]  - relaying element #2
[16:17:49.053] result() for ClusterFuture ...
[16:17:49.053] - result already collected: FutureResult
[16:17:49.053] result() for ClusterFuture ... done
[16:17:49.053] result() for ClusterFuture ...
[16:17:49.053] - result already collected: FutureResult
[16:17:49.053] result() for ClusterFuture ... done
[16:17:49.053] result() for ClusterFuture ...
[16:17:49.054] - result already collected: FutureResult
[16:17:49.054] result() for ClusterFuture ... done
[16:17:49.054] result() for ClusterFuture ...
[16:17:49.054] - result already collected: FutureResult
[16:17:49.054] result() for ClusterFuture ... done
[16:17:49.054] - relayed: [n=2] TRUE, TRUE
[16:17:49.054] - queued futures: [n=2] TRUE, TRUE
[16:17:49.054] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:17:49.054]  length: 0 (resolved future 2)
[16:17:49.054] Relaying remaining futures
[16:17:49.054] signalConditionsASAP(NULL, pos=0) ...
[16:17:49.055] - nx: 2
[16:17:49.055] - relay: TRUE
[16:17:49.055] - stdout: TRUE
[16:17:49.055] - signal: TRUE
[16:17:49.055] - resignal: FALSE
[16:17:49.055] - force: TRUE
[16:17:49.055] - relayed: [n=2] TRUE, TRUE
[16:17:49.055] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:49.055] - relayed: [n=2] TRUE, TRUE
[16:17:49.055] - queued futures: [n=2] TRUE, TRUE
[16:17:49.055] signalConditionsASAP(NULL, pos=0) ... done
[16:17:49.055] resolve() on list ... DONE
[16:17:49.056] result() for ClusterFuture ...
[16:17:49.056] - result already collected: FutureResult
[16:17:49.056] result() for ClusterFuture ... done
[16:17:49.056] result() for ClusterFuture ...
[16:17:49.056] - result already collected: FutureResult
[16:17:49.056] result() for ClusterFuture ... done
[16:17:49.056] result() for ClusterFuture ...
[16:17:49.056] - result already collected: FutureResult
[16:17:49.056] result() for ClusterFuture ... done
[16:17:49.056] result() for ClusterFuture ...
[16:17:49.056] - result already collected: FutureResult
[16:17:49.057] result() for ClusterFuture ... done
[16:17:49.057]  - Number of value chunks collected: 2
[16:17:49.057] Resolving 2 futures (chunks) ... DONE
[16:17:49.057] Reducing values from 2 chunks ...
[16:17:49.057]  - Number of values collected after concatenation: 6
[16:17:49.057]  - Number of values expected: 6
[16:17:49.057] Reducing values from 2 chunks ... DONE
[16:17:49.057] future_lapply() ... DONE
[16:17:49.057] future_by_internal() ... DONE
[16:17:49.058] future_by_internal() ...
[16:17:49.059] future_lapply() ...
[16:17:49.063] Number of chunks: 2
[16:17:49.063] getGlobalsAndPackagesXApply() ...
[16:17:49.063]  - future.globals: TRUE
[16:17:49.063] getGlobalsAndPackages() ...
[16:17:49.063] Searching for globals...
[16:17:49.065] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:17:49.065] Searching for globals ... DONE
[16:17:49.065] Resolving globals: FALSE
[16:17:49.066] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[16:17:49.066] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[16:17:49.066] - globals: [1] ‘FUN’
[16:17:49.066] - packages: [1] ‘stats’
[16:17:49.066] getGlobalsAndPackages() ... DONE
[16:17:49.067]  - globals found/used: [n=1] ‘FUN’
[16:17:49.067]  - needed namespaces: [n=1] ‘stats’
[16:17:49.067] Finding globals ... DONE
[16:17:49.067]  - use_args: TRUE
[16:17:49.067]  - Getting '...' globals ...
[16:17:49.067] resolve() on list ...
[16:17:49.067]  recursive: 0
[16:17:49.067]  length: 1
[16:17:49.067]  elements: ‘...’
[16:17:49.068]  length: 0 (resolved future 1)
[16:17:49.068] resolve() on list ... DONE
[16:17:49.068]    - '...' content: [n=1] ‘singular.ok’
[16:17:49.068] List of 1
[16:17:49.068]  $ ...:List of 1
[16:17:49.068]   ..$ singular.ok: logi FALSE
[16:17:49.068]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:49.068]  - attr(*, "where")=List of 1
[16:17:49.068]   ..$ ...:<environment: 0x55b567dfc270> 
[16:17:49.068]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:49.068]  - attr(*, "resolved")= logi TRUE
[16:17:49.068]  - attr(*, "total_size")= num NA
[16:17:49.073]  - Getting '...' globals ... DONE
[16:17:49.073] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:49.073] List of 2
[16:17:49.073]  $ ...future.FUN:function (x, ...)  
[16:17:49.073]  $ ...          :List of 1
[16:17:49.073]   ..$ singular.ok: logi FALSE
[16:17:49.073]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:49.073]  - attr(*, "where")=List of 2
[16:17:49.073]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:49.073]   ..$ ...          :<environment: 0x55b567dfc270> 
[16:17:49.073]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:49.073]  - attr(*, "resolved")= logi FALSE
[16:17:49.073]  - attr(*, "total_size")= num 5384
[16:17:49.076] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:49.076] getGlobalsAndPackagesXApply() ... DONE
[16:17:49.076] Number of futures (= number of chunks): 2
[16:17:49.076] Launching 2 futures (chunks) ...
[16:17:49.076] Chunk #1 of 2 ...
[16:17:49.077]  - Finding globals in 'X' for chunk #1 ...
[16:17:49.077] getGlobalsAndPackages() ...
[16:17:49.077] Searching for globals...
[16:17:49.077] 
[16:17:49.077] Searching for globals ... DONE
[16:17:49.077] - globals: [0] <none>
[16:17:49.077] getGlobalsAndPackages() ... DONE
[16:17:49.077]    + additional globals found: [n=0] 
[16:17:49.078]    + additional namespaces needed: [n=0] 
[16:17:49.078]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:49.078]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:49.078]  - seeds: <none>
[16:17:49.078]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.078] getGlobalsAndPackages() ...
[16:17:49.078] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.078] Resolving globals: FALSE
[16:17:49.078] Tweak future expression to call with '...' arguments ...
[16:17:49.078] {
[16:17:49.078]     do.call(function(...) {
[16:17:49.078]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.078]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:49.078]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.078]             on.exit(options(oopts), add = TRUE)
[16:17:49.078]         }
[16:17:49.078]         {
[16:17:49.078]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:49.078]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.078]                 ...future.FUN(...future.X_jj, ...)
[16:17:49.078]             })
[16:17:49.078]         }
[16:17:49.078]     }, args = future.call.arguments)
[16:17:49.078] }
[16:17:49.079] Tweak future expression to call with '...' arguments ... DONE
[16:17:49.079] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.079] 
[16:17:49.079] getGlobalsAndPackages() ... DONE
[16:17:49.079] run() for ‘Future’ ...
[16:17:49.080] - state: ‘created’
[16:17:49.080] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:49.093] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:49.093] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:49.093]   - Field: ‘node’
[16:17:49.093]   - Field: ‘label’
[16:17:49.093]   - Field: ‘local’
[16:17:49.093]   - Field: ‘owner’
[16:17:49.094]   - Field: ‘envir’
[16:17:49.094]   - Field: ‘workers’
[16:17:49.094]   - Field: ‘packages’
[16:17:49.094]   - Field: ‘gc’
[16:17:49.094]   - Field: ‘conditions’
[16:17:49.094]   - Field: ‘persistent’
[16:17:49.094]   - Field: ‘expr’
[16:17:49.094]   - Field: ‘uuid’
[16:17:49.094]   - Field: ‘seed’
[16:17:49.094]   - Field: ‘version’
[16:17:49.094]   - Field: ‘result’
[16:17:49.095]   - Field: ‘asynchronous’
[16:17:49.095]   - Field: ‘calls’
[16:17:49.095]   - Field: ‘globals’
[16:17:49.095]   - Field: ‘stdout’
[16:17:49.095]   - Field: ‘earlySignal’
[16:17:49.095]   - Field: ‘lazy’
[16:17:49.095]   - Field: ‘state’
[16:17:49.095] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:49.095] - Launch lazy future ...
[16:17:49.095] Packages needed by the future expression (n = 1): ‘stats’
[16:17:49.096] Packages needed by future strategies (n = 0): <none>
[16:17:49.096] {
[16:17:49.096]     {
[16:17:49.096]         {
[16:17:49.096]             ...future.startTime <- base::Sys.time()
[16:17:49.096]             {
[16:17:49.096]                 {
[16:17:49.096]                   {
[16:17:49.096]                     {
[16:17:49.096]                       {
[16:17:49.096]                         base::local({
[16:17:49.096]                           has_future <- base::requireNamespace("future", 
[16:17:49.096]                             quietly = TRUE)
[16:17:49.096]                           if (has_future) {
[16:17:49.096]                             ns <- base::getNamespace("future")
[16:17:49.096]                             version <- ns[[".package"]][["version"]]
[16:17:49.096]                             if (is.null(version)) 
[16:17:49.096]                               version <- utils::packageVersion("future")
[16:17:49.096]                           }
[16:17:49.096]                           else {
[16:17:49.096]                             version <- NULL
[16:17:49.096]                           }
[16:17:49.096]                           if (!has_future || version < "1.8.0") {
[16:17:49.096]                             info <- base::c(r_version = base::gsub("R version ", 
[16:17:49.096]                               "", base::R.version$version.string), 
[16:17:49.096]                               platform = base::sprintf("%s (%s-bit)", 
[16:17:49.096]                                 base::R.version$platform, 8 * 
[16:17:49.096]                                   base::.Machine$sizeof.pointer), 
[16:17:49.096]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:49.096]                                 "release", "version")], collapse = " "), 
[16:17:49.096]                               hostname = base::Sys.info()[["nodename"]])
[16:17:49.096]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:17:49.096]                               info)
[16:17:49.096]                             info <- base::paste(info, collapse = "; ")
[16:17:49.096]                             if (!has_future) {
[16:17:49.096]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:49.096]                                 info)
[16:17:49.096]                             }
[16:17:49.096]                             else {
[16:17:49.096]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:49.096]                                 info, version)
[16:17:49.096]                             }
[16:17:49.096]                             base::stop(msg)
[16:17:49.096]                           }
[16:17:49.096]                         })
[16:17:49.096]                       }
[16:17:49.096]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:49.096]                       base::options(mc.cores = 1L)
[16:17:49.096]                     }
[16:17:49.096]                     base::local({
[16:17:49.096]                       for (pkg in "stats") {
[16:17:49.096]                         base::loadNamespace(pkg)
[16:17:49.096]                         base::library(pkg, character.only = TRUE)
[16:17:49.096]                       }
[16:17:49.096]                     })
[16:17:49.096]                   }
[16:17:49.096]                   ...future.strategy.old <- future::plan("list")
[16:17:49.096]                   options(future.plan = NULL)
[16:17:49.096]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:49.096]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:49.096]                 }
[16:17:49.096]                 ...future.workdir <- getwd()
[16:17:49.096]             }
[16:17:49.096]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:49.096]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:49.096]         }
[16:17:49.096]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:49.096]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:49.096]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:49.096]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:49.096]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:49.096]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:49.096]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:49.096]             base::names(...future.oldOptions))
[16:17:49.096]     }
[16:17:49.096]     if (FALSE) {
[16:17:49.096]     }
[16:17:49.096]     else {
[16:17:49.096]         if (TRUE) {
[16:17:49.096]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:49.096]                 open = "w")
[16:17:49.096]         }
[16:17:49.096]         else {
[16:17:49.096]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:49.096]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:49.096]         }
[16:17:49.096]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:49.096]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:49.096]             base::sink(type = "output", split = FALSE)
[16:17:49.096]             base::close(...future.stdout)
[16:17:49.096]         }, add = TRUE)
[16:17:49.096]     }
[16:17:49.096]     ...future.frame <- base::sys.nframe()
[16:17:49.096]     ...future.conditions <- base::list()
[16:17:49.096]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:49.096]     if (FALSE) {
[16:17:49.096]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:49.096]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:49.096]     }
[16:17:49.096]     ...future.result <- base::tryCatch({
[16:17:49.096]         base::withCallingHandlers({
[16:17:49.096]             ...future.value <- base::withVisible(base::local({
[16:17:49.096]                 ...future.makeSendCondition <- base::local({
[16:17:49.096]                   sendCondition <- NULL
[16:17:49.096]                   function(frame = 1L) {
[16:17:49.096]                     if (is.function(sendCondition)) 
[16:17:49.096]                       return(sendCondition)
[16:17:49.096]                     ns <- getNamespace("parallel")
[16:17:49.096]                     if (exists("sendData", mode = "function", 
[16:17:49.096]                       envir = ns)) {
[16:17:49.096]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:49.096]                         envir = ns)
[16:17:49.096]                       envir <- sys.frame(frame)
[16:17:49.096]                       master <- NULL
[16:17:49.096]                       while (!identical(envir, .GlobalEnv) && 
[16:17:49.096]                         !identical(envir, emptyenv())) {
[16:17:49.096]                         if (exists("master", mode = "list", envir = envir, 
[16:17:49.096]                           inherits = FALSE)) {
[16:17:49.096]                           master <- get("master", mode = "list", 
[16:17:49.096]                             envir = envir, inherits = FALSE)
[16:17:49.096]                           if (inherits(master, c("SOCKnode", 
[16:17:49.096]                             "SOCK0node"))) {
[16:17:49.096]                             sendCondition <<- function(cond) {
[16:17:49.096]                               data <- list(type = "VALUE", value = cond, 
[16:17:49.096]                                 success = TRUE)
[16:17:49.096]                               parallel_sendData(master, data)
[16:17:49.096]                             }
[16:17:49.096]                             return(sendCondition)
[16:17:49.096]                           }
[16:17:49.096]                         }
[16:17:49.096]                         frame <- frame + 1L
[16:17:49.096]                         envir <- sys.frame(frame)
[16:17:49.096]                       }
[16:17:49.096]                     }
[16:17:49.096]                     sendCondition <<- function(cond) NULL
[16:17:49.096]                   }
[16:17:49.096]                 })
[16:17:49.096]                 withCallingHandlers({
[16:17:49.096]                   {
[16:17:49.096]                     do.call(function(...) {
[16:17:49.096]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.096]                       if (!identical(...future.globals.maxSize.org, 
[16:17:49.096]                         ...future.globals.maxSize)) {
[16:17:49.096]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.096]                         on.exit(options(oopts), add = TRUE)
[16:17:49.096]                       }
[16:17:49.096]                       {
[16:17:49.096]                         lapply(seq_along(...future.elements_ii), 
[16:17:49.096]                           FUN = function(jj) {
[16:17:49.096]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.096]                             ...future.FUN(...future.X_jj, ...)
[16:17:49.096]                           })
[16:17:49.096]                       }
[16:17:49.096]                     }, args = future.call.arguments)
[16:17:49.096]                   }
[16:17:49.096]                 }, immediateCondition = function(cond) {
[16:17:49.096]                   sendCondition <- ...future.makeSendCondition()
[16:17:49.096]                   sendCondition(cond)
[16:17:49.096]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.096]                   {
[16:17:49.096]                     inherits <- base::inherits
[16:17:49.096]                     invokeRestart <- base::invokeRestart
[16:17:49.096]                     is.null <- base::is.null
[16:17:49.096]                     muffled <- FALSE
[16:17:49.096]                     if (inherits(cond, "message")) {
[16:17:49.096]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:49.096]                       if (muffled) 
[16:17:49.096]                         invokeRestart("muffleMessage")
[16:17:49.096]                     }
[16:17:49.096]                     else if (inherits(cond, "warning")) {
[16:17:49.096]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:49.096]                       if (muffled) 
[16:17:49.096]                         invokeRestart("muffleWarning")
[16:17:49.096]                     }
[16:17:49.096]                     else if (inherits(cond, "condition")) {
[16:17:49.096]                       if (!is.null(pattern)) {
[16:17:49.096]                         computeRestarts <- base::computeRestarts
[16:17:49.096]                         grepl <- base::grepl
[16:17:49.096]                         restarts <- computeRestarts(cond)
[16:17:49.096]                         for (restart in restarts) {
[16:17:49.096]                           name <- restart$name
[16:17:49.096]                           if (is.null(name)) 
[16:17:49.096]                             next
[16:17:49.096]                           if (!grepl(pattern, name)) 
[16:17:49.096]                             next
[16:17:49.096]                           invokeRestart(restart)
[16:17:49.096]                           muffled <- TRUE
[16:17:49.096]                           break
[16:17:49.096]                         }
[16:17:49.096]                       }
[16:17:49.096]                     }
[16:17:49.096]                     invisible(muffled)
[16:17:49.096]                   }
[16:17:49.096]                   muffleCondition(cond)
[16:17:49.096]                 })
[16:17:49.096]             }))
[16:17:49.096]             future::FutureResult(value = ...future.value$value, 
[16:17:49.096]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:49.096]                   ...future.rng), globalenv = if (FALSE) 
[16:17:49.096]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:49.096]                     ...future.globalenv.names))
[16:17:49.096]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:49.096]         }, condition = base::local({
[16:17:49.096]             c <- base::c
[16:17:49.096]             inherits <- base::inherits
[16:17:49.096]             invokeRestart <- base::invokeRestart
[16:17:49.096]             length <- base::length
[16:17:49.096]             list <- base::list
[16:17:49.096]             seq.int <- base::seq.int
[16:17:49.096]             signalCondition <- base::signalCondition
[16:17:49.096]             sys.calls <- base::sys.calls
[16:17:49.096]             `[[` <- base::`[[`
[16:17:49.096]             `+` <- base::`+`
[16:17:49.096]             `<<-` <- base::`<<-`
[16:17:49.096]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:49.096]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:49.096]                   3L)]
[16:17:49.096]             }
[16:17:49.096]             function(cond) {
[16:17:49.096]                 is_error <- inherits(cond, "error")
[16:17:49.096]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:49.096]                   NULL)
[16:17:49.096]                 if (is_error) {
[16:17:49.096]                   sessionInformation <- function() {
[16:17:49.096]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:49.096]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:49.096]                       search = base::search(), system = base::Sys.info())
[16:17:49.096]                   }
[16:17:49.096]                   ...future.conditions[[length(...future.conditions) + 
[16:17:49.096]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:49.096]                     cond$call), session = sessionInformation(), 
[16:17:49.096]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:49.096]                   signalCondition(cond)
[16:17:49.096]                 }
[16:17:49.096]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:49.096]                 "immediateCondition"))) {
[16:17:49.096]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:49.096]                   ...future.conditions[[length(...future.conditions) + 
[16:17:49.096]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:49.096]                   if (TRUE && !signal) {
[16:17:49.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.096]                     {
[16:17:49.096]                       inherits <- base::inherits
[16:17:49.096]                       invokeRestart <- base::invokeRestart
[16:17:49.096]                       is.null <- base::is.null
[16:17:49.096]                       muffled <- FALSE
[16:17:49.096]                       if (inherits(cond, "message")) {
[16:17:49.096]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:49.096]                         if (muffled) 
[16:17:49.096]                           invokeRestart("muffleMessage")
[16:17:49.096]                       }
[16:17:49.096]                       else if (inherits(cond, "warning")) {
[16:17:49.096]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:49.096]                         if (muffled) 
[16:17:49.096]                           invokeRestart("muffleWarning")
[16:17:49.096]                       }
[16:17:49.096]                       else if (inherits(cond, "condition")) {
[16:17:49.096]                         if (!is.null(pattern)) {
[16:17:49.096]                           computeRestarts <- base::computeRestarts
[16:17:49.096]                           grepl <- base::grepl
[16:17:49.096]                           restarts <- computeRestarts(cond)
[16:17:49.096]                           for (restart in restarts) {
[16:17:49.096]                             name <- restart$name
[16:17:49.096]                             if (is.null(name)) 
[16:17:49.096]                               next
[16:17:49.096]                             if (!grepl(pattern, name)) 
[16:17:49.096]                               next
[16:17:49.096]                             invokeRestart(restart)
[16:17:49.096]                             muffled <- TRUE
[16:17:49.096]                             break
[16:17:49.096]                           }
[16:17:49.096]                         }
[16:17:49.096]                       }
[16:17:49.096]                       invisible(muffled)
[16:17:49.096]                     }
[16:17:49.096]                     muffleCondition(cond, pattern = "^muffle")
[16:17:49.096]                   }
[16:17:49.096]                 }
[16:17:49.096]                 else {
[16:17:49.096]                   if (TRUE) {
[16:17:49.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.096]                     {
[16:17:49.096]                       inherits <- base::inherits
[16:17:49.096]                       invokeRestart <- base::invokeRestart
[16:17:49.096]                       is.null <- base::is.null
[16:17:49.096]                       muffled <- FALSE
[16:17:49.096]                       if (inherits(cond, "message")) {
[16:17:49.096]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:49.096]                         if (muffled) 
[16:17:49.096]                           invokeRestart("muffleMessage")
[16:17:49.096]                       }
[16:17:49.096]                       else if (inherits(cond, "warning")) {
[16:17:49.096]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:49.096]                         if (muffled) 
[16:17:49.096]                           invokeRestart("muffleWarning")
[16:17:49.096]                       }
[16:17:49.096]                       else if (inherits(cond, "condition")) {
[16:17:49.096]                         if (!is.null(pattern)) {
[16:17:49.096]                           computeRestarts <- base::computeRestarts
[16:17:49.096]                           grepl <- base::grepl
[16:17:49.096]                           restarts <- computeRestarts(cond)
[16:17:49.096]                           for (restart in restarts) {
[16:17:49.096]                             name <- restart$name
[16:17:49.096]                             if (is.null(name)) 
[16:17:49.096]                               next
[16:17:49.096]                             if (!grepl(pattern, name)) 
[16:17:49.096]                               next
[16:17:49.096]                             invokeRestart(restart)
[16:17:49.096]                             muffled <- TRUE
[16:17:49.096]                             break
[16:17:49.096]                           }
[16:17:49.096]                         }
[16:17:49.096]                       }
[16:17:49.096]                       invisible(muffled)
[16:17:49.096]                     }
[16:17:49.096]                     muffleCondition(cond, pattern = "^muffle")
[16:17:49.096]                   }
[16:17:49.096]                 }
[16:17:49.096]             }
[16:17:49.096]         }))
[16:17:49.096]     }, error = function(ex) {
[16:17:49.096]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:49.096]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:49.096]                 ...future.rng), started = ...future.startTime, 
[16:17:49.096]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:49.096]             version = "1.8"), class = "FutureResult")
[16:17:49.096]     }, finally = {
[16:17:49.096]         if (!identical(...future.workdir, getwd())) 
[16:17:49.096]             setwd(...future.workdir)
[16:17:49.096]         {
[16:17:49.096]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:49.096]                 ...future.oldOptions$nwarnings <- NULL
[16:17:49.096]             }
[16:17:49.096]             base::options(...future.oldOptions)
[16:17:49.096]             if (.Platform$OS.type == "windows") {
[16:17:49.096]                 old_names <- names(...future.oldEnvVars)
[16:17:49.096]                 envs <- base::Sys.getenv()
[16:17:49.096]                 names <- names(envs)
[16:17:49.096]                 common <- intersect(names, old_names)
[16:17:49.096]                 added <- setdiff(names, old_names)
[16:17:49.096]                 removed <- setdiff(old_names, names)
[16:17:49.096]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:49.096]                   envs[common]]
[16:17:49.096]                 NAMES <- toupper(changed)
[16:17:49.096]                 args <- list()
[16:17:49.096]                 for (kk in seq_along(NAMES)) {
[16:17:49.096]                   name <- changed[[kk]]
[16:17:49.096]                   NAME <- NAMES[[kk]]
[16:17:49.096]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.096]                     next
[16:17:49.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:49.096]                 }
[16:17:49.096]                 NAMES <- toupper(added)
[16:17:49.096]                 for (kk in seq_along(NAMES)) {
[16:17:49.096]                   name <- added[[kk]]
[16:17:49.096]                   NAME <- NAMES[[kk]]
[16:17:49.096]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.096]                     next
[16:17:49.096]                   args[[name]] <- ""
[16:17:49.096]                 }
[16:17:49.096]                 NAMES <- toupper(removed)
[16:17:49.096]                 for (kk in seq_along(NAMES)) {
[16:17:49.096]                   name <- removed[[kk]]
[16:17:49.096]                   NAME <- NAMES[[kk]]
[16:17:49.096]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.096]                     next
[16:17:49.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:49.096]                 }
[16:17:49.096]                 if (length(args) > 0) 
[16:17:49.096]                   base::do.call(base::Sys.setenv, args = args)
[16:17:49.096]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:49.096]             }
[16:17:49.096]             else {
[16:17:49.096]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:49.096]             }
[16:17:49.096]             {
[16:17:49.096]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:49.096]                   0L) {
[16:17:49.096]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:49.096]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:49.096]                   base::options(opts)
[16:17:49.096]                 }
[16:17:49.096]                 {
[16:17:49.096]                   {
[16:17:49.096]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:49.096]                     NULL
[16:17:49.096]                   }
[16:17:49.096]                   options(future.plan = NULL)
[16:17:49.096]                   if (is.na(NA_character_)) 
[16:17:49.096]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:49.096]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:49.096]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:49.096]                     .init = FALSE)
[16:17:49.096]                 }
[16:17:49.096]             }
[16:17:49.096]         }
[16:17:49.096]     })
[16:17:49.096]     if (TRUE) {
[16:17:49.096]         base::sink(type = "output", split = FALSE)
[16:17:49.096]         if (TRUE) {
[16:17:49.096]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:49.096]         }
[16:17:49.096]         else {
[16:17:49.096]             ...future.result["stdout"] <- base::list(NULL)
[16:17:49.096]         }
[16:17:49.096]         base::close(...future.stdout)
[16:17:49.096]         ...future.stdout <- NULL
[16:17:49.096]     }
[16:17:49.096]     ...future.result$conditions <- ...future.conditions
[16:17:49.096]     ...future.result$finished <- base::Sys.time()
[16:17:49.096]     ...future.result
[16:17:49.096] }
[16:17:49.099] Exporting 5 global objects (5.26 KiB) to cluster node #1 ...
[16:17:49.099] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ...
[16:17:49.099] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ... DONE
[16:17:49.099] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[16:17:49.100] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[16:17:49.100] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[16:17:49.100] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[16:17:49.100] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:17:49.101] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:17:49.101] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:17:49.101] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:17:49.101] Exporting 5 global objects (5.26 KiB) to cluster node #1 ... DONE
[16:17:49.102] MultisessionFuture started
[16:17:49.102] - Launch lazy future ... done
[16:17:49.102] run() for ‘MultisessionFuture’ ... done
[16:17:49.102] Created future:
[16:17:49.102] MultisessionFuture:
[16:17:49.102] Label: ‘future_by-1’
[16:17:49.102] Expression:
[16:17:49.102] {
[16:17:49.102]     do.call(function(...) {
[16:17:49.102]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.102]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:49.102]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.102]             on.exit(options(oopts), add = TRUE)
[16:17:49.102]         }
[16:17:49.102]         {
[16:17:49.102]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:49.102]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.102]                 ...future.FUN(...future.X_jj, ...)
[16:17:49.102]             })
[16:17:49.102]         }
[16:17:49.102]     }, args = future.call.arguments)
[16:17:49.102] }
[16:17:49.102] Lazy evaluation: FALSE
[16:17:49.102] Asynchronous evaluation: TRUE
[16:17:49.102] Local evaluation: TRUE
[16:17:49.102] Environment: R_GlobalEnv
[16:17:49.102] Capture standard output: TRUE
[16:17:49.102] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:49.102] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:49.102] Packages: 1 packages (‘stats’)
[16:17:49.102] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:49.102] Resolved: FALSE
[16:17:49.102] Value: <not collected>
[16:17:49.102] Conditions captured: <none>
[16:17:49.102] Early signaling: FALSE
[16:17:49.102] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:49.102] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:49.114] Chunk #1 of 2 ... DONE
[16:17:49.114] Chunk #2 of 2 ...
[16:17:49.114]  - Finding globals in 'X' for chunk #2 ...
[16:17:49.114] getGlobalsAndPackages() ...
[16:17:49.114] Searching for globals...
[16:17:49.115] 
[16:17:49.115] Searching for globals ... DONE
[16:17:49.115] - globals: [0] <none>
[16:17:49.115] getGlobalsAndPackages() ... DONE
[16:17:49.115]    + additional globals found: [n=0] 
[16:17:49.115]    + additional namespaces needed: [n=0] 
[16:17:49.115]  - Finding globals in 'X' for chunk #2 ... DONE
[16:17:49.115]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:49.115]  - seeds: <none>
[16:17:49.115]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.115] getGlobalsAndPackages() ...
[16:17:49.116] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.116] Resolving globals: FALSE
[16:17:49.116] Tweak future expression to call with '...' arguments ...
[16:17:49.116] {
[16:17:49.116]     do.call(function(...) {
[16:17:49.116]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.116]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:49.116]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.116]             on.exit(options(oopts), add = TRUE)
[16:17:49.116]         }
[16:17:49.116]         {
[16:17:49.116]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:49.116]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.116]                 ...future.FUN(...future.X_jj, ...)
[16:17:49.116]             })
[16:17:49.116]         }
[16:17:49.116]     }, args = future.call.arguments)
[16:17:49.116] }
[16:17:49.116] Tweak future expression to call with '...' arguments ... DONE
[16:17:49.116] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.117] 
[16:17:49.117] getGlobalsAndPackages() ... DONE
[16:17:49.117] run() for ‘Future’ ...
[16:17:49.117] - state: ‘created’
[16:17:49.117] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:49.131] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:49.131] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:49.131]   - Field: ‘node’
[16:17:49.131]   - Field: ‘label’
[16:17:49.131]   - Field: ‘local’
[16:17:49.131]   - Field: ‘owner’
[16:17:49.131]   - Field: ‘envir’
[16:17:49.131]   - Field: ‘workers’
[16:17:49.131]   - Field: ‘packages’
[16:17:49.131]   - Field: ‘gc’
[16:17:49.132]   - Field: ‘conditions’
[16:17:49.132]   - Field: ‘persistent’
[16:17:49.132]   - Field: ‘expr’
[16:17:49.132]   - Field: ‘uuid’
[16:17:49.132]   - Field: ‘seed’
[16:17:49.132]   - Field: ‘version’
[16:17:49.132]   - Field: ‘result’
[16:17:49.132]   - Field: ‘asynchronous’
[16:17:49.132]   - Field: ‘calls’
[16:17:49.132]   - Field: ‘globals’
[16:17:49.132]   - Field: ‘stdout’
[16:17:49.133]   - Field: ‘earlySignal’
[16:17:49.133]   - Field: ‘lazy’
[16:17:49.133]   - Field: ‘state’
[16:17:49.133] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:49.133] - Launch lazy future ...
[16:17:49.133] Packages needed by the future expression (n = 1): ‘stats’
[16:17:49.133] Packages needed by future strategies (n = 0): <none>
[16:17:49.134] {
[16:17:49.134]     {
[16:17:49.134]         {
[16:17:49.134]             ...future.startTime <- base::Sys.time()
[16:17:49.134]             {
[16:17:49.134]                 {
[16:17:49.134]                   {
[16:17:49.134]                     {
[16:17:49.134]                       {
[16:17:49.134]                         base::local({
[16:17:49.134]                           has_future <- base::requireNamespace("future", 
[16:17:49.134]                             quietly = TRUE)
[16:17:49.134]                           if (has_future) {
[16:17:49.134]                             ns <- base::getNamespace("future")
[16:17:49.134]                             version <- ns[[".package"]][["version"]]
[16:17:49.134]                             if (is.null(version)) 
[16:17:49.134]                               version <- utils::packageVersion("future")
[16:17:49.134]                           }
[16:17:49.134]                           else {
[16:17:49.134]                             version <- NULL
[16:17:49.134]                           }
[16:17:49.134]                           if (!has_future || version < "1.8.0") {
[16:17:49.134]                             info <- base::c(r_version = base::gsub("R version ", 
[16:17:49.134]                               "", base::R.version$version.string), 
[16:17:49.134]                               platform = base::sprintf("%s (%s-bit)", 
[16:17:49.134]                                 base::R.version$platform, 8 * 
[16:17:49.134]                                   base::.Machine$sizeof.pointer), 
[16:17:49.134]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:49.134]                                 "release", "version")], collapse = " "), 
[16:17:49.134]                               hostname = base::Sys.info()[["nodename"]])
[16:17:49.134]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:17:49.134]                               info)
[16:17:49.134]                             info <- base::paste(info, collapse = "; ")
[16:17:49.134]                             if (!has_future) {
[16:17:49.134]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:49.134]                                 info)
[16:17:49.134]                             }
[16:17:49.134]                             else {
[16:17:49.134]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:49.134]                                 info, version)
[16:17:49.134]                             }
[16:17:49.134]                             base::stop(msg)
[16:17:49.134]                           }
[16:17:49.134]                         })
[16:17:49.134]                       }
[16:17:49.134]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:49.134]                       base::options(mc.cores = 1L)
[16:17:49.134]                     }
[16:17:49.134]                     base::local({
[16:17:49.134]                       for (pkg in "stats") {
[16:17:49.134]                         base::loadNamespace(pkg)
[16:17:49.134]                         base::library(pkg, character.only = TRUE)
[16:17:49.134]                       }
[16:17:49.134]                     })
[16:17:49.134]                   }
[16:17:49.134]                   ...future.strategy.old <- future::plan("list")
[16:17:49.134]                   options(future.plan = NULL)
[16:17:49.134]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:49.134]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:49.134]                 }
[16:17:49.134]                 ...future.workdir <- getwd()
[16:17:49.134]             }
[16:17:49.134]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:49.134]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:49.134]         }
[16:17:49.134]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:49.134]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:49.134]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:49.134]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:49.134]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:49.134]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:49.134]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:49.134]             base::names(...future.oldOptions))
[16:17:49.134]     }
[16:17:49.134]     if (FALSE) {
[16:17:49.134]     }
[16:17:49.134]     else {
[16:17:49.134]         if (TRUE) {
[16:17:49.134]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:49.134]                 open = "w")
[16:17:49.134]         }
[16:17:49.134]         else {
[16:17:49.134]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:49.134]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:49.134]         }
[16:17:49.134]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:49.134]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:49.134]             base::sink(type = "output", split = FALSE)
[16:17:49.134]             base::close(...future.stdout)
[16:17:49.134]         }, add = TRUE)
[16:17:49.134]     }
[16:17:49.134]     ...future.frame <- base::sys.nframe()
[16:17:49.134]     ...future.conditions <- base::list()
[16:17:49.134]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:49.134]     if (FALSE) {
[16:17:49.134]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:49.134]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:49.134]     }
[16:17:49.134]     ...future.result <- base::tryCatch({
[16:17:49.134]         base::withCallingHandlers({
[16:17:49.134]             ...future.value <- base::withVisible(base::local({
[16:17:49.134]                 ...future.makeSendCondition <- base::local({
[16:17:49.134]                   sendCondition <- NULL
[16:17:49.134]                   function(frame = 1L) {
[16:17:49.134]                     if (is.function(sendCondition)) 
[16:17:49.134]                       return(sendCondition)
[16:17:49.134]                     ns <- getNamespace("parallel")
[16:17:49.134]                     if (exists("sendData", mode = "function", 
[16:17:49.134]                       envir = ns)) {
[16:17:49.134]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:49.134]                         envir = ns)
[16:17:49.134]                       envir <- sys.frame(frame)
[16:17:49.134]                       master <- NULL
[16:17:49.134]                       while (!identical(envir, .GlobalEnv) && 
[16:17:49.134]                         !identical(envir, emptyenv())) {
[16:17:49.134]                         if (exists("master", mode = "list", envir = envir, 
[16:17:49.134]                           inherits = FALSE)) {
[16:17:49.134]                           master <- get("master", mode = "list", 
[16:17:49.134]                             envir = envir, inherits = FALSE)
[16:17:49.134]                           if (inherits(master, c("SOCKnode", 
[16:17:49.134]                             "SOCK0node"))) {
[16:17:49.134]                             sendCondition <<- function(cond) {
[16:17:49.134]                               data <- list(type = "VALUE", value = cond, 
[16:17:49.134]                                 success = TRUE)
[16:17:49.134]                               parallel_sendData(master, data)
[16:17:49.134]                             }
[16:17:49.134]                             return(sendCondition)
[16:17:49.134]                           }
[16:17:49.134]                         }
[16:17:49.134]                         frame <- frame + 1L
[16:17:49.134]                         envir <- sys.frame(frame)
[16:17:49.134]                       }
[16:17:49.134]                     }
[16:17:49.134]                     sendCondition <<- function(cond) NULL
[16:17:49.134]                   }
[16:17:49.134]                 })
[16:17:49.134]                 withCallingHandlers({
[16:17:49.134]                   {
[16:17:49.134]                     do.call(function(...) {
[16:17:49.134]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.134]                       if (!identical(...future.globals.maxSize.org, 
[16:17:49.134]                         ...future.globals.maxSize)) {
[16:17:49.134]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.134]                         on.exit(options(oopts), add = TRUE)
[16:17:49.134]                       }
[16:17:49.134]                       {
[16:17:49.134]                         lapply(seq_along(...future.elements_ii), 
[16:17:49.134]                           FUN = function(jj) {
[16:17:49.134]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.134]                             ...future.FUN(...future.X_jj, ...)
[16:17:49.134]                           })
[16:17:49.134]                       }
[16:17:49.134]                     }, args = future.call.arguments)
[16:17:49.134]                   }
[16:17:49.134]                 }, immediateCondition = function(cond) {
[16:17:49.134]                   sendCondition <- ...future.makeSendCondition()
[16:17:49.134]                   sendCondition(cond)
[16:17:49.134]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.134]                   {
[16:17:49.134]                     inherits <- base::inherits
[16:17:49.134]                     invokeRestart <- base::invokeRestart
[16:17:49.134]                     is.null <- base::is.null
[16:17:49.134]                     muffled <- FALSE
[16:17:49.134]                     if (inherits(cond, "message")) {
[16:17:49.134]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:49.134]                       if (muffled) 
[16:17:49.134]                         invokeRestart("muffleMessage")
[16:17:49.134]                     }
[16:17:49.134]                     else if (inherits(cond, "warning")) {
[16:17:49.134]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:49.134]                       if (muffled) 
[16:17:49.134]                         invokeRestart("muffleWarning")
[16:17:49.134]                     }
[16:17:49.134]                     else if (inherits(cond, "condition")) {
[16:17:49.134]                       if (!is.null(pattern)) {
[16:17:49.134]                         computeRestarts <- base::computeRestarts
[16:17:49.134]                         grepl <- base::grepl
[16:17:49.134]                         restarts <- computeRestarts(cond)
[16:17:49.134]                         for (restart in restarts) {
[16:17:49.134]                           name <- restart$name
[16:17:49.134]                           if (is.null(name)) 
[16:17:49.134]                             next
[16:17:49.134]                           if (!grepl(pattern, name)) 
[16:17:49.134]                             next
[16:17:49.134]                           invokeRestart(restart)
[16:17:49.134]                           muffled <- TRUE
[16:17:49.134]                           break
[16:17:49.134]                         }
[16:17:49.134]                       }
[16:17:49.134]                     }
[16:17:49.134]                     invisible(muffled)
[16:17:49.134]                   }
[16:17:49.134]                   muffleCondition(cond)
[16:17:49.134]                 })
[16:17:49.134]             }))
[16:17:49.134]             future::FutureResult(value = ...future.value$value, 
[16:17:49.134]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:49.134]                   ...future.rng), globalenv = if (FALSE) 
[16:17:49.134]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:49.134]                     ...future.globalenv.names))
[16:17:49.134]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:49.134]         }, condition = base::local({
[16:17:49.134]             c <- base::c
[16:17:49.134]             inherits <- base::inherits
[16:17:49.134]             invokeRestart <- base::invokeRestart
[16:17:49.134]             length <- base::length
[16:17:49.134]             list <- base::list
[16:17:49.134]             seq.int <- base::seq.int
[16:17:49.134]             signalCondition <- base::signalCondition
[16:17:49.134]             sys.calls <- base::sys.calls
[16:17:49.134]             `[[` <- base::`[[`
[16:17:49.134]             `+` <- base::`+`
[16:17:49.134]             `<<-` <- base::`<<-`
[16:17:49.134]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:49.134]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:49.134]                   3L)]
[16:17:49.134]             }
[16:17:49.134]             function(cond) {
[16:17:49.134]                 is_error <- inherits(cond, "error")
[16:17:49.134]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:49.134]                   NULL)
[16:17:49.134]                 if (is_error) {
[16:17:49.134]                   sessionInformation <- function() {
[16:17:49.134]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:49.134]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:49.134]                       search = base::search(), system = base::Sys.info())
[16:17:49.134]                   }
[16:17:49.134]                   ...future.conditions[[length(...future.conditions) + 
[16:17:49.134]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:49.134]                     cond$call), session = sessionInformation(), 
[16:17:49.134]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:49.134]                   signalCondition(cond)
[16:17:49.134]                 }
[16:17:49.134]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:49.134]                 "immediateCondition"))) {
[16:17:49.134]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:49.134]                   ...future.conditions[[length(...future.conditions) + 
[16:17:49.134]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:49.134]                   if (TRUE && !signal) {
[16:17:49.134]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.134]                     {
[16:17:49.134]                       inherits <- base::inherits
[16:17:49.134]                       invokeRestart <- base::invokeRestart
[16:17:49.134]                       is.null <- base::is.null
[16:17:49.134]                       muffled <- FALSE
[16:17:49.134]                       if (inherits(cond, "message")) {
[16:17:49.134]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:49.134]                         if (muffled) 
[16:17:49.134]                           invokeRestart("muffleMessage")
[16:17:49.134]                       }
[16:17:49.134]                       else if (inherits(cond, "warning")) {
[16:17:49.134]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:49.134]                         if (muffled) 
[16:17:49.134]                           invokeRestart("muffleWarning")
[16:17:49.134]                       }
[16:17:49.134]                       else if (inherits(cond, "condition")) {
[16:17:49.134]                         if (!is.null(pattern)) {
[16:17:49.134]                           computeRestarts <- base::computeRestarts
[16:17:49.134]                           grepl <- base::grepl
[16:17:49.134]                           restarts <- computeRestarts(cond)
[16:17:49.134]                           for (restart in restarts) {
[16:17:49.134]                             name <- restart$name
[16:17:49.134]                             if (is.null(name)) 
[16:17:49.134]                               next
[16:17:49.134]                             if (!grepl(pattern, name)) 
[16:17:49.134]                               next
[16:17:49.134]                             invokeRestart(restart)
[16:17:49.134]                             muffled <- TRUE
[16:17:49.134]                             break
[16:17:49.134]                           }
[16:17:49.134]                         }
[16:17:49.134]                       }
[16:17:49.134]                       invisible(muffled)
[16:17:49.134]                     }
[16:17:49.134]                     muffleCondition(cond, pattern = "^muffle")
[16:17:49.134]                   }
[16:17:49.134]                 }
[16:17:49.134]                 else {
[16:17:49.134]                   if (TRUE) {
[16:17:49.134]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.134]                     {
[16:17:49.134]                       inherits <- base::inherits
[16:17:49.134]                       invokeRestart <- base::invokeRestart
[16:17:49.134]                       is.null <- base::is.null
[16:17:49.134]                       muffled <- FALSE
[16:17:49.134]                       if (inherits(cond, "message")) {
[16:17:49.134]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:49.134]                         if (muffled) 
[16:17:49.134]                           invokeRestart("muffleMessage")
[16:17:49.134]                       }
[16:17:49.134]                       else if (inherits(cond, "warning")) {
[16:17:49.134]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:49.134]                         if (muffled) 
[16:17:49.134]                           invokeRestart("muffleWarning")
[16:17:49.134]                       }
[16:17:49.134]                       else if (inherits(cond, "condition")) {
[16:17:49.134]                         if (!is.null(pattern)) {
[16:17:49.134]                           computeRestarts <- base::computeRestarts
[16:17:49.134]                           grepl <- base::grepl
[16:17:49.134]                           restarts <- computeRestarts(cond)
[16:17:49.134]                           for (restart in restarts) {
[16:17:49.134]                             name <- restart$name
[16:17:49.134]                             if (is.null(name)) 
[16:17:49.134]                               next
[16:17:49.134]                             if (!grepl(pattern, name)) 
[16:17:49.134]                               next
[16:17:49.134]                             invokeRestart(restart)
[16:17:49.134]                             muffled <- TRUE
[16:17:49.134]                             break
[16:17:49.134]                           }
[16:17:49.134]                         }
[16:17:49.134]                       }
[16:17:49.134]                       invisible(muffled)
[16:17:49.134]                     }
[16:17:49.134]                     muffleCondition(cond, pattern = "^muffle")
[16:17:49.134]                   }
[16:17:49.134]                 }
[16:17:49.134]             }
[16:17:49.134]         }))
[16:17:49.134]     }, error = function(ex) {
[16:17:49.134]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:49.134]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:49.134]                 ...future.rng), started = ...future.startTime, 
[16:17:49.134]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:49.134]             version = "1.8"), class = "FutureResult")
[16:17:49.134]     }, finally = {
[16:17:49.134]         if (!identical(...future.workdir, getwd())) 
[16:17:49.134]             setwd(...future.workdir)
[16:17:49.134]         {
[16:17:49.134]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:49.134]                 ...future.oldOptions$nwarnings <- NULL
[16:17:49.134]             }
[16:17:49.134]             base::options(...future.oldOptions)
[16:17:49.134]             if (.Platform$OS.type == "windows") {
[16:17:49.134]                 old_names <- names(...future.oldEnvVars)
[16:17:49.134]                 envs <- base::Sys.getenv()
[16:17:49.134]                 names <- names(envs)
[16:17:49.134]                 common <- intersect(names, old_names)
[16:17:49.134]                 added <- setdiff(names, old_names)
[16:17:49.134]                 removed <- setdiff(old_names, names)
[16:17:49.134]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:49.134]                   envs[common]]
[16:17:49.134]                 NAMES <- toupper(changed)
[16:17:49.134]                 args <- list()
[16:17:49.134]                 for (kk in seq_along(NAMES)) {
[16:17:49.134]                   name <- changed[[kk]]
[16:17:49.134]                   NAME <- NAMES[[kk]]
[16:17:49.134]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.134]                     next
[16:17:49.134]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:49.134]                 }
[16:17:49.134]                 NAMES <- toupper(added)
[16:17:49.134]                 for (kk in seq_along(NAMES)) {
[16:17:49.134]                   name <- added[[kk]]
[16:17:49.134]                   NAME <- NAMES[[kk]]
[16:17:49.134]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.134]                     next
[16:17:49.134]                   args[[name]] <- ""
[16:17:49.134]                 }
[16:17:49.134]                 NAMES <- toupper(removed)
[16:17:49.134]                 for (kk in seq_along(NAMES)) {
[16:17:49.134]                   name <- removed[[kk]]
[16:17:49.134]                   NAME <- NAMES[[kk]]
[16:17:49.134]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.134]                     next
[16:17:49.134]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:49.134]                 }
[16:17:49.134]                 if (length(args) > 0) 
[16:17:49.134]                   base::do.call(base::Sys.setenv, args = args)
[16:17:49.134]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:49.134]             }
[16:17:49.134]             else {
[16:17:49.134]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:49.134]             }
[16:17:49.134]             {
[16:17:49.134]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:49.134]                   0L) {
[16:17:49.134]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:49.134]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:49.134]                   base::options(opts)
[16:17:49.134]                 }
[16:17:49.134]                 {
[16:17:49.134]                   {
[16:17:49.134]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:49.134]                     NULL
[16:17:49.134]                   }
[16:17:49.134]                   options(future.plan = NULL)
[16:17:49.134]                   if (is.na(NA_character_)) 
[16:17:49.134]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:49.134]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:49.134]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:49.134]                     .init = FALSE)
[16:17:49.134]                 }
[16:17:49.134]             }
[16:17:49.134]         }
[16:17:49.134]     })
[16:17:49.134]     if (TRUE) {
[16:17:49.134]         base::sink(type = "output", split = FALSE)
[16:17:49.134]         if (TRUE) {
[16:17:49.134]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:49.134]         }
[16:17:49.134]         else {
[16:17:49.134]             ...future.result["stdout"] <- base::list(NULL)
[16:17:49.134]         }
[16:17:49.134]         base::close(...future.stdout)
[16:17:49.134]         ...future.stdout <- NULL
[16:17:49.134]     }
[16:17:49.134]     ...future.result$conditions <- ...future.conditions
[16:17:49.134]     ...future.result$finished <- base::Sys.time()
[16:17:49.134]     ...future.result
[16:17:49.134] }
[16:17:49.136] Exporting 5 global objects (5.26 KiB) to cluster node #2 ...
[16:17:49.137] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ...
[16:17:49.137] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ... DONE
[16:17:49.137] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[16:17:49.137] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[16:17:49.138] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[16:17:49.138] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[16:17:49.138] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:17:49.138] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:17:49.139] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:17:49.139] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:17:49.139] Exporting 5 global objects (5.26 KiB) to cluster node #2 ... DONE
[16:17:49.139] MultisessionFuture started
[16:17:49.140] - Launch lazy future ... done
[16:17:49.140] run() for ‘MultisessionFuture’ ... done
[16:17:49.140] Created future:
[16:17:49.140] MultisessionFuture:
[16:17:49.140] Label: ‘future_by-2’
[16:17:49.140] Expression:
[16:17:49.140] {
[16:17:49.140]     do.call(function(...) {
[16:17:49.140]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.140]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:49.140]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.140]             on.exit(options(oopts), add = TRUE)
[16:17:49.140]         }
[16:17:49.140]         {
[16:17:49.140]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:49.140]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.140]                 ...future.FUN(...future.X_jj, ...)
[16:17:49.140]             })
[16:17:49.140]         }
[16:17:49.140]     }, args = future.call.arguments)
[16:17:49.140] }
[16:17:49.140] Lazy evaluation: FALSE
[16:17:49.140] Asynchronous evaluation: TRUE
[16:17:49.140] Local evaluation: TRUE
[16:17:49.140] Environment: R_GlobalEnv
[16:17:49.140] Capture standard output: TRUE
[16:17:49.140] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:49.140] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:49.140] Packages: 1 packages (‘stats’)
[16:17:49.140] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:49.140] Resolved: FALSE
[16:17:49.140] Value: <not collected>
[16:17:49.140] Conditions captured: <none>
[16:17:49.140] Early signaling: FALSE
[16:17:49.140] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:49.140] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:49.151] Chunk #2 of 2 ... DONE
[16:17:49.151] Launching 2 futures (chunks) ... DONE
[16:17:49.152] Resolving 2 futures (chunks) ...
[16:17:49.152] resolve() on list ...
[16:17:49.152]  recursive: 0
[16:17:49.152]  length: 2
[16:17:49.152] 
[16:17:49.152] receiveMessageFromWorker() for ClusterFuture ...
[16:17:49.153] - Validating connection of MultisessionFuture
[16:17:49.153] - received message: FutureResult
[16:17:49.153] - Received FutureResult
[16:17:49.153] - Erased future from FutureRegistry
[16:17:49.153] result() for ClusterFuture ...
[16:17:49.153] - result already collected: FutureResult
[16:17:49.153] result() for ClusterFuture ... done
[16:17:49.153] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:49.153] Future #1
[16:17:49.154] result() for ClusterFuture ...
[16:17:49.154] - result already collected: FutureResult
[16:17:49.154] result() for ClusterFuture ... done
[16:17:49.154] result() for ClusterFuture ...
[16:17:49.154] - result already collected: FutureResult
[16:17:49.154] result() for ClusterFuture ... done
[16:17:49.154] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:17:49.154] - nx: 2
[16:17:49.154] - relay: TRUE
[16:17:49.154] - stdout: TRUE
[16:17:49.154] - signal: TRUE
[16:17:49.154] - resignal: FALSE
[16:17:49.155] - force: TRUE
[16:17:49.155] - relayed: [n=2] FALSE, FALSE
[16:17:49.155] - queued futures: [n=2] FALSE, FALSE
[16:17:49.155]  - until=1
[16:17:49.155]  - relaying element #1
[16:17:49.155] result() for ClusterFuture ...
[16:17:49.155] - result already collected: FutureResult
[16:17:49.155] result() for ClusterFuture ... done
[16:17:49.155] result() for ClusterFuture ...
[16:17:49.155] - result already collected: FutureResult
[16:17:49.155] result() for ClusterFuture ... done
[16:17:49.156] result() for ClusterFuture ...
[16:17:49.156] - result already collected: FutureResult
[16:17:49.156] result() for ClusterFuture ... done
[16:17:49.156] result() for ClusterFuture ...
[16:17:49.156] - result already collected: FutureResult
[16:17:49.156] result() for ClusterFuture ... done
[16:17:49.156] - relayed: [n=2] TRUE, FALSE
[16:17:49.156] - queued futures: [n=2] TRUE, FALSE
[16:17:49.156] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:17:49.156]  length: 1 (resolved future 1)
[16:17:49.186] receiveMessageFromWorker() for ClusterFuture ...
[16:17:49.186] - Validating connection of MultisessionFuture
[16:17:49.186] - received message: FutureResult
[16:17:49.186] - Received FutureResult
[16:17:49.187] - Erased future from FutureRegistry
[16:17:49.187] result() for ClusterFuture ...
[16:17:49.187] - result already collected: FutureResult
[16:17:49.187] result() for ClusterFuture ... done
[16:17:49.187] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:49.187] Future #2
[16:17:49.187] result() for ClusterFuture ...
[16:17:49.187] - result already collected: FutureResult
[16:17:49.187] result() for ClusterFuture ... done
[16:17:49.188] result() for ClusterFuture ...
[16:17:49.188] - result already collected: FutureResult
[16:17:49.188] result() for ClusterFuture ... done
[16:17:49.188] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:17:49.188] - nx: 2
[16:17:49.188] - relay: TRUE
[16:17:49.188] - stdout: TRUE
[16:17:49.188] - signal: TRUE
[16:17:49.188] - resignal: FALSE
[16:17:49.188] - force: TRUE
[16:17:49.188] - relayed: [n=2] TRUE, FALSE
[16:17:49.188] - queued futures: [n=2] TRUE, FALSE
[16:17:49.189]  - until=2
[16:17:49.189]  - relaying element #2
[16:17:49.189] result() for ClusterFuture ...
[16:17:49.189] - result already collected: FutureResult
[16:17:49.189] result() for ClusterFuture ... done
[16:17:49.189] result() for ClusterFuture ...
[16:17:49.189] - result already collected: FutureResult
[16:17:49.189] result() for ClusterFuture ... done
[16:17:49.189] result() for ClusterFuture ...
[16:17:49.189] - result already collected: FutureResult
[16:17:49.189] result() for ClusterFuture ... done
[16:17:49.190] result() for ClusterFuture ...
[16:17:49.190] - result already collected: FutureResult
[16:17:49.190] result() for ClusterFuture ... done
[16:17:49.190] - relayed: [n=2] TRUE, TRUE
[16:17:49.190] - queued futures: [n=2] TRUE, TRUE
[16:17:49.190] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:17:49.190]  length: 0 (resolved future 2)
[16:17:49.190] Relaying remaining futures
[16:17:49.190] signalConditionsASAP(NULL, pos=0) ...
[16:17:49.190] - nx: 2
[16:17:49.190] - relay: TRUE
[16:17:49.191] - stdout: TRUE
[16:17:49.191] - signal: TRUE
[16:17:49.191] - resignal: FALSE
[16:17:49.191] - force: TRUE
[16:17:49.191] - relayed: [n=2] TRUE, TRUE
[16:17:49.191] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:49.191] - relayed: [n=2] TRUE, TRUE
[16:17:49.191] - queued futures: [n=2] TRUE, TRUE
[16:17:49.191] signalConditionsASAP(NULL, pos=0) ... done
[16:17:49.191] resolve() on list ... DONE
[16:17:49.191] result() for ClusterFuture ...
[16:17:49.192] - result already collected: FutureResult
[16:17:49.192] result() for ClusterFuture ... done
[16:17:49.192] result() for ClusterFuture ...
[16:17:49.192] - result already collected: FutureResult
[16:17:49.192] result() for ClusterFuture ... done
[16:17:49.192] result() for ClusterFuture ...
[16:17:49.192] - result already collected: FutureResult
[16:17:49.192] result() for ClusterFuture ... done
[16:17:49.192] result() for ClusterFuture ...
[16:17:49.192] - result already collected: FutureResult
[16:17:49.192] result() for ClusterFuture ... done
[16:17:49.193]  - Number of value chunks collected: 2
[16:17:49.193] Resolving 2 futures (chunks) ... DONE
[16:17:49.193] Reducing values from 2 chunks ...
[16:17:49.193]  - Number of values collected after concatenation: 3
[16:17:49.193]  - Number of values expected: 3
[16:17:49.193] Reducing values from 2 chunks ... DONE
[16:17:49.193] future_lapply() ... DONE
[16:17:49.193] future_by_internal() ... DONE
[16:17:49.197] future_by_internal() ...
[16:17:49.197] future_lapply() ...
[16:17:49.202] Number of chunks: 2
[16:17:49.202] getGlobalsAndPackagesXApply() ...
[16:17:49.202]  - future.globals: TRUE
[16:17:49.202] getGlobalsAndPackages() ...
[16:17:49.202] Searching for globals...
[16:17:49.204] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:17:49.204] Searching for globals ... DONE
[16:17:49.204] Resolving globals: FALSE
[16:17:49.205] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[16:17:49.205] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[16:17:49.205] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[16:17:49.205] - packages: [1] ‘stats’
[16:17:49.205] getGlobalsAndPackages() ... DONE
[16:17:49.205]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[16:17:49.205]  - needed namespaces: [n=1] ‘stats’
[16:17:49.206] Finding globals ... DONE
[16:17:49.206]  - use_args: TRUE
[16:17:49.206]  - Getting '...' globals ...
[16:17:49.206] resolve() on list ...
[16:17:49.206]  recursive: 0
[16:17:49.206]  length: 1
[16:17:49.206]  elements: ‘...’
[16:17:49.206]  length: 0 (resolved future 1)
[16:17:49.207] resolve() on list ... DONE
[16:17:49.207]    - '...' content: [n=0] 
[16:17:49.207] List of 1
[16:17:49.207]  $ ...: list()
[16:17:49.207]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:49.207]  - attr(*, "where")=List of 1
[16:17:49.207]   ..$ ...:<environment: 0x55b56886ba88> 
[16:17:49.207]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:49.207]  - attr(*, "resolved")= logi TRUE
[16:17:49.207]  - attr(*, "total_size")= num NA
[16:17:49.209]  - Getting '...' globals ... DONE
[16:17:49.210] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[16:17:49.210] List of 4
[16:17:49.210]  $ ...future.FUN:function (x)  
[16:17:49.210]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:17:49.210]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:17:49.210]  $ ...          : list()
[16:17:49.210]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:49.210]  - attr(*, "where")=List of 4
[16:17:49.210]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:49.210]   ..$ breaks       :<environment: R_EmptyEnv> 
[16:17:49.210]   ..$ wool         :<environment: R_EmptyEnv> 
[16:17:49.210]   ..$ ...          :<environment: 0x55b56886ba88> 
[16:17:49.210]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:49.210]  - attr(*, "resolved")= logi FALSE
[16:17:49.210]  - attr(*, "total_size")= num 2320
[16:17:49.213] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:49.214] getGlobalsAndPackagesXApply() ... DONE
[16:17:49.214] Number of futures (= number of chunks): 2
[16:17:49.214] Launching 2 futures (chunks) ...
[16:17:49.214] Chunk #1 of 2 ...
[16:17:49.214]  - Finding globals in 'X' for chunk #1 ...
[16:17:49.214] getGlobalsAndPackages() ...
[16:17:49.214] Searching for globals...
[16:17:49.215] 
[16:17:49.215] Searching for globals ... DONE
[16:17:49.215] - globals: [0] <none>
[16:17:49.215] getGlobalsAndPackages() ... DONE
[16:17:49.215]    + additional globals found: [n=0] 
[16:17:49.215]    + additional namespaces needed: [n=0] 
[16:17:49.215]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:49.215]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:49.215]  - seeds: <none>
[16:17:49.215]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.216] getGlobalsAndPackages() ...
[16:17:49.216] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.216] Resolving globals: FALSE
[16:17:49.216] Tweak future expression to call with '...' arguments ...
[16:17:49.216] {
[16:17:49.216]     do.call(function(...) {
[16:17:49.216]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.216]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:49.216]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.216]             on.exit(options(oopts), add = TRUE)
[16:17:49.216]         }
[16:17:49.216]         {
[16:17:49.216]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:49.216]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.216]                 ...future.FUN(...future.X_jj, ...)
[16:17:49.216]             })
[16:17:49.216]         }
[16:17:49.216]     }, args = future.call.arguments)
[16:17:49.216] }
[16:17:49.216] Tweak future expression to call with '...' arguments ... DONE
[16:17:49.217] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.217] 
[16:17:49.217] getGlobalsAndPackages() ... DONE
[16:17:49.217] run() for ‘Future’ ...
[16:17:49.217] - state: ‘created’
[16:17:49.217] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:49.231] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:49.231] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:49.231]   - Field: ‘node’
[16:17:49.232]   - Field: ‘label’
[16:17:49.232]   - Field: ‘local’
[16:17:49.232]   - Field: ‘owner’
[16:17:49.232]   - Field: ‘envir’
[16:17:49.232]   - Field: ‘workers’
[16:17:49.232]   - Field: ‘packages’
[16:17:49.232]   - Field: ‘gc’
[16:17:49.232]   - Field: ‘conditions’
[16:17:49.232]   - Field: ‘persistent’
[16:17:49.232]   - Field: ‘expr’
[16:17:49.233]   - Field: ‘uuid’
[16:17:49.233]   - Field: ‘seed’
[16:17:49.233]   - Field: ‘version’
[16:17:49.233]   - Field: ‘result’
[16:17:49.233]   - Field: ‘asynchronous’
[16:17:49.233]   - Field: ‘calls’
[16:17:49.233]   - Field: ‘globals’
[16:17:49.233]   - Field: ‘stdout’
[16:17:49.233]   - Field: ‘earlySignal’
[16:17:49.233]   - Field: ‘lazy’
[16:17:49.234]   - Field: ‘state’
[16:17:49.234] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:49.234] - Launch lazy future ...
[16:17:49.234] Packages needed by the future expression (n = 1): ‘stats’
[16:17:49.236] Packages needed by future strategies (n = 0): <none>
[16:17:49.237] {
[16:17:49.237]     {
[16:17:49.237]         {
[16:17:49.237]             ...future.startTime <- base::Sys.time()
[16:17:49.237]             {
[16:17:49.237]                 {
[16:17:49.237]                   {
[16:17:49.237]                     {
[16:17:49.237]                       {
[16:17:49.237]                         base::local({
[16:17:49.237]                           has_future <- base::requireNamespace("future", 
[16:17:49.237]                             quietly = TRUE)
[16:17:49.237]                           if (has_future) {
[16:17:49.237]                             ns <- base::getNamespace("future")
[16:17:49.237]                             version <- ns[[".package"]][["version"]]
[16:17:49.237]                             if (is.null(version)) 
[16:17:49.237]                               version <- utils::packageVersion("future")
[16:17:49.237]                           }
[16:17:49.237]                           else {
[16:17:49.237]                             version <- NULL
[16:17:49.237]                           }
[16:17:49.237]                           if (!has_future || version < "1.8.0") {
[16:17:49.237]                             info <- base::c(r_version = base::gsub("R version ", 
[16:17:49.237]                               "", base::R.version$version.string), 
[16:17:49.237]                               platform = base::sprintf("%s (%s-bit)", 
[16:17:49.237]                                 base::R.version$platform, 8 * 
[16:17:49.237]                                   base::.Machine$sizeof.pointer), 
[16:17:49.237]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:49.237]                                 "release", "version")], collapse = " "), 
[16:17:49.237]                               hostname = base::Sys.info()[["nodename"]])
[16:17:49.237]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:17:49.237]                               info)
[16:17:49.237]                             info <- base::paste(info, collapse = "; ")
[16:17:49.237]                             if (!has_future) {
[16:17:49.237]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:49.237]                                 info)
[16:17:49.237]                             }
[16:17:49.237]                             else {
[16:17:49.237]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:49.237]                                 info, version)
[16:17:49.237]                             }
[16:17:49.237]                             base::stop(msg)
[16:17:49.237]                           }
[16:17:49.237]                         })
[16:17:49.237]                       }
[16:17:49.237]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:49.237]                       base::options(mc.cores = 1L)
[16:17:49.237]                     }
[16:17:49.237]                     base::local({
[16:17:49.237]                       for (pkg in "stats") {
[16:17:49.237]                         base::loadNamespace(pkg)
[16:17:49.237]                         base::library(pkg, character.only = TRUE)
[16:17:49.237]                       }
[16:17:49.237]                     })
[16:17:49.237]                   }
[16:17:49.237]                   ...future.strategy.old <- future::plan("list")
[16:17:49.237]                   options(future.plan = NULL)
[16:17:49.237]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:49.237]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:49.237]                 }
[16:17:49.237]                 ...future.workdir <- getwd()
[16:17:49.237]             }
[16:17:49.237]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:49.237]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:49.237]         }
[16:17:49.237]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:49.237]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:49.237]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:49.237]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:49.237]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:49.237]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:49.237]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:49.237]             base::names(...future.oldOptions))
[16:17:49.237]     }
[16:17:49.237]     if (FALSE) {
[16:17:49.237]     }
[16:17:49.237]     else {
[16:17:49.237]         if (TRUE) {
[16:17:49.237]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:49.237]                 open = "w")
[16:17:49.237]         }
[16:17:49.237]         else {
[16:17:49.237]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:49.237]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:49.237]         }
[16:17:49.237]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:49.237]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:49.237]             base::sink(type = "output", split = FALSE)
[16:17:49.237]             base::close(...future.stdout)
[16:17:49.237]         }, add = TRUE)
[16:17:49.237]     }
[16:17:49.237]     ...future.frame <- base::sys.nframe()
[16:17:49.237]     ...future.conditions <- base::list()
[16:17:49.237]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:49.237]     if (FALSE) {
[16:17:49.237]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:49.237]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:49.237]     }
[16:17:49.237]     ...future.result <- base::tryCatch({
[16:17:49.237]         base::withCallingHandlers({
[16:17:49.237]             ...future.value <- base::withVisible(base::local({
[16:17:49.237]                 ...future.makeSendCondition <- base::local({
[16:17:49.237]                   sendCondition <- NULL
[16:17:49.237]                   function(frame = 1L) {
[16:17:49.237]                     if (is.function(sendCondition)) 
[16:17:49.237]                       return(sendCondition)
[16:17:49.237]                     ns <- getNamespace("parallel")
[16:17:49.237]                     if (exists("sendData", mode = "function", 
[16:17:49.237]                       envir = ns)) {
[16:17:49.237]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:49.237]                         envir = ns)
[16:17:49.237]                       envir <- sys.frame(frame)
[16:17:49.237]                       master <- NULL
[16:17:49.237]                       while (!identical(envir, .GlobalEnv) && 
[16:17:49.237]                         !identical(envir, emptyenv())) {
[16:17:49.237]                         if (exists("master", mode = "list", envir = envir, 
[16:17:49.237]                           inherits = FALSE)) {
[16:17:49.237]                           master <- get("master", mode = "list", 
[16:17:49.237]                             envir = envir, inherits = FALSE)
[16:17:49.237]                           if (inherits(master, c("SOCKnode", 
[16:17:49.237]                             "SOCK0node"))) {
[16:17:49.237]                             sendCondition <<- function(cond) {
[16:17:49.237]                               data <- list(type = "VALUE", value = cond, 
[16:17:49.237]                                 success = TRUE)
[16:17:49.237]                               parallel_sendData(master, data)
[16:17:49.237]                             }
[16:17:49.237]                             return(sendCondition)
[16:17:49.237]                           }
[16:17:49.237]                         }
[16:17:49.237]                         frame <- frame + 1L
[16:17:49.237]                         envir <- sys.frame(frame)
[16:17:49.237]                       }
[16:17:49.237]                     }
[16:17:49.237]                     sendCondition <<- function(cond) NULL
[16:17:49.237]                   }
[16:17:49.237]                 })
[16:17:49.237]                 withCallingHandlers({
[16:17:49.237]                   {
[16:17:49.237]                     do.call(function(...) {
[16:17:49.237]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.237]                       if (!identical(...future.globals.maxSize.org, 
[16:17:49.237]                         ...future.globals.maxSize)) {
[16:17:49.237]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.237]                         on.exit(options(oopts), add = TRUE)
[16:17:49.237]                       }
[16:17:49.237]                       {
[16:17:49.237]                         lapply(seq_along(...future.elements_ii), 
[16:17:49.237]                           FUN = function(jj) {
[16:17:49.237]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.237]                             ...future.FUN(...future.X_jj, ...)
[16:17:49.237]                           })
[16:17:49.237]                       }
[16:17:49.237]                     }, args = future.call.arguments)
[16:17:49.237]                   }
[16:17:49.237]                 }, immediateCondition = function(cond) {
[16:17:49.237]                   sendCondition <- ...future.makeSendCondition()
[16:17:49.237]                   sendCondition(cond)
[16:17:49.237]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.237]                   {
[16:17:49.237]                     inherits <- base::inherits
[16:17:49.237]                     invokeRestart <- base::invokeRestart
[16:17:49.237]                     is.null <- base::is.null
[16:17:49.237]                     muffled <- FALSE
[16:17:49.237]                     if (inherits(cond, "message")) {
[16:17:49.237]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:49.237]                       if (muffled) 
[16:17:49.237]                         invokeRestart("muffleMessage")
[16:17:49.237]                     }
[16:17:49.237]                     else if (inherits(cond, "warning")) {
[16:17:49.237]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:49.237]                       if (muffled) 
[16:17:49.237]                         invokeRestart("muffleWarning")
[16:17:49.237]                     }
[16:17:49.237]                     else if (inherits(cond, "condition")) {
[16:17:49.237]                       if (!is.null(pattern)) {
[16:17:49.237]                         computeRestarts <- base::computeRestarts
[16:17:49.237]                         grepl <- base::grepl
[16:17:49.237]                         restarts <- computeRestarts(cond)
[16:17:49.237]                         for (restart in restarts) {
[16:17:49.237]                           name <- restart$name
[16:17:49.237]                           if (is.null(name)) 
[16:17:49.237]                             next
[16:17:49.237]                           if (!grepl(pattern, name)) 
[16:17:49.237]                             next
[16:17:49.237]                           invokeRestart(restart)
[16:17:49.237]                           muffled <- TRUE
[16:17:49.237]                           break
[16:17:49.237]                         }
[16:17:49.237]                       }
[16:17:49.237]                     }
[16:17:49.237]                     invisible(muffled)
[16:17:49.237]                   }
[16:17:49.237]                   muffleCondition(cond)
[16:17:49.237]                 })
[16:17:49.237]             }))
[16:17:49.237]             future::FutureResult(value = ...future.value$value, 
[16:17:49.237]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:49.237]                   ...future.rng), globalenv = if (FALSE) 
[16:17:49.237]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:49.237]                     ...future.globalenv.names))
[16:17:49.237]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:49.237]         }, condition = base::local({
[16:17:49.237]             c <- base::c
[16:17:49.237]             inherits <- base::inherits
[16:17:49.237]             invokeRestart <- base::invokeRestart
[16:17:49.237]             length <- base::length
[16:17:49.237]             list <- base::list
[16:17:49.237]             seq.int <- base::seq.int
[16:17:49.237]             signalCondition <- base::signalCondition
[16:17:49.237]             sys.calls <- base::sys.calls
[16:17:49.237]             `[[` <- base::`[[`
[16:17:49.237]             `+` <- base::`+`
[16:17:49.237]             `<<-` <- base::`<<-`
[16:17:49.237]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:49.237]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:49.237]                   3L)]
[16:17:49.237]             }
[16:17:49.237]             function(cond) {
[16:17:49.237]                 is_error <- inherits(cond, "error")
[16:17:49.237]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:49.237]                   NULL)
[16:17:49.237]                 if (is_error) {
[16:17:49.237]                   sessionInformation <- function() {
[16:17:49.237]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:49.237]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:49.237]                       search = base::search(), system = base::Sys.info())
[16:17:49.237]                   }
[16:17:49.237]                   ...future.conditions[[length(...future.conditions) + 
[16:17:49.237]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:49.237]                     cond$call), session = sessionInformation(), 
[16:17:49.237]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:49.237]                   signalCondition(cond)
[16:17:49.237]                 }
[16:17:49.237]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:49.237]                 "immediateCondition"))) {
[16:17:49.237]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:49.237]                   ...future.conditions[[length(...future.conditions) + 
[16:17:49.237]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:49.237]                   if (TRUE && !signal) {
[16:17:49.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.237]                     {
[16:17:49.237]                       inherits <- base::inherits
[16:17:49.237]                       invokeRestart <- base::invokeRestart
[16:17:49.237]                       is.null <- base::is.null
[16:17:49.237]                       muffled <- FALSE
[16:17:49.237]                       if (inherits(cond, "message")) {
[16:17:49.237]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:49.237]                         if (muffled) 
[16:17:49.237]                           invokeRestart("muffleMessage")
[16:17:49.237]                       }
[16:17:49.237]                       else if (inherits(cond, "warning")) {
[16:17:49.237]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:49.237]                         if (muffled) 
[16:17:49.237]                           invokeRestart("muffleWarning")
[16:17:49.237]                       }
[16:17:49.237]                       else if (inherits(cond, "condition")) {
[16:17:49.237]                         if (!is.null(pattern)) {
[16:17:49.237]                           computeRestarts <- base::computeRestarts
[16:17:49.237]                           grepl <- base::grepl
[16:17:49.237]                           restarts <- computeRestarts(cond)
[16:17:49.237]                           for (restart in restarts) {
[16:17:49.237]                             name <- restart$name
[16:17:49.237]                             if (is.null(name)) 
[16:17:49.237]                               next
[16:17:49.237]                             if (!grepl(pattern, name)) 
[16:17:49.237]                               next
[16:17:49.237]                             invokeRestart(restart)
[16:17:49.237]                             muffled <- TRUE
[16:17:49.237]                             break
[16:17:49.237]                           }
[16:17:49.237]                         }
[16:17:49.237]                       }
[16:17:49.237]                       invisible(muffled)
[16:17:49.237]                     }
[16:17:49.237]                     muffleCondition(cond, pattern = "^muffle")
[16:17:49.237]                   }
[16:17:49.237]                 }
[16:17:49.237]                 else {
[16:17:49.237]                   if (TRUE) {
[16:17:49.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.237]                     {
[16:17:49.237]                       inherits <- base::inherits
[16:17:49.237]                       invokeRestart <- base::invokeRestart
[16:17:49.237]                       is.null <- base::is.null
[16:17:49.237]                       muffled <- FALSE
[16:17:49.237]                       if (inherits(cond, "message")) {
[16:17:49.237]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:49.237]                         if (muffled) 
[16:17:49.237]                           invokeRestart("muffleMessage")
[16:17:49.237]                       }
[16:17:49.237]                       else if (inherits(cond, "warning")) {
[16:17:49.237]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:49.237]                         if (muffled) 
[16:17:49.237]                           invokeRestart("muffleWarning")
[16:17:49.237]                       }
[16:17:49.237]                       else if (inherits(cond, "condition")) {
[16:17:49.237]                         if (!is.null(pattern)) {
[16:17:49.237]                           computeRestarts <- base::computeRestarts
[16:17:49.237]                           grepl <- base::grepl
[16:17:49.237]                           restarts <- computeRestarts(cond)
[16:17:49.237]                           for (restart in restarts) {
[16:17:49.237]                             name <- restart$name
[16:17:49.237]                             if (is.null(name)) 
[16:17:49.237]                               next
[16:17:49.237]                             if (!grepl(pattern, name)) 
[16:17:49.237]                               next
[16:17:49.237]                             invokeRestart(restart)
[16:17:49.237]                             muffled <- TRUE
[16:17:49.237]                             break
[16:17:49.237]                           }
[16:17:49.237]                         }
[16:17:49.237]                       }
[16:17:49.237]                       invisible(muffled)
[16:17:49.237]                     }
[16:17:49.237]                     muffleCondition(cond, pattern = "^muffle")
[16:17:49.237]                   }
[16:17:49.237]                 }
[16:17:49.237]             }
[16:17:49.237]         }))
[16:17:49.237]     }, error = function(ex) {
[16:17:49.237]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:49.237]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:49.237]                 ...future.rng), started = ...future.startTime, 
[16:17:49.237]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:49.237]             version = "1.8"), class = "FutureResult")
[16:17:49.237]     }, finally = {
[16:17:49.237]         if (!identical(...future.workdir, getwd())) 
[16:17:49.237]             setwd(...future.workdir)
[16:17:49.237]         {
[16:17:49.237]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:49.237]                 ...future.oldOptions$nwarnings <- NULL
[16:17:49.237]             }
[16:17:49.237]             base::options(...future.oldOptions)
[16:17:49.237]             if (.Platform$OS.type == "windows") {
[16:17:49.237]                 old_names <- names(...future.oldEnvVars)
[16:17:49.237]                 envs <- base::Sys.getenv()
[16:17:49.237]                 names <- names(envs)
[16:17:49.237]                 common <- intersect(names, old_names)
[16:17:49.237]                 added <- setdiff(names, old_names)
[16:17:49.237]                 removed <- setdiff(old_names, names)
[16:17:49.237]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:49.237]                   envs[common]]
[16:17:49.237]                 NAMES <- toupper(changed)
[16:17:49.237]                 args <- list()
[16:17:49.237]                 for (kk in seq_along(NAMES)) {
[16:17:49.237]                   name <- changed[[kk]]
[16:17:49.237]                   NAME <- NAMES[[kk]]
[16:17:49.237]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.237]                     next
[16:17:49.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:49.237]                 }
[16:17:49.237]                 NAMES <- toupper(added)
[16:17:49.237]                 for (kk in seq_along(NAMES)) {
[16:17:49.237]                   name <- added[[kk]]
[16:17:49.237]                   NAME <- NAMES[[kk]]
[16:17:49.237]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.237]                     next
[16:17:49.237]                   args[[name]] <- ""
[16:17:49.237]                 }
[16:17:49.237]                 NAMES <- toupper(removed)
[16:17:49.237]                 for (kk in seq_along(NAMES)) {
[16:17:49.237]                   name <- removed[[kk]]
[16:17:49.237]                   NAME <- NAMES[[kk]]
[16:17:49.237]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.237]                     next
[16:17:49.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:49.237]                 }
[16:17:49.237]                 if (length(args) > 0) 
[16:17:49.237]                   base::do.call(base::Sys.setenv, args = args)
[16:17:49.237]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:49.237]             }
[16:17:49.237]             else {
[16:17:49.237]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:49.237]             }
[16:17:49.237]             {
[16:17:49.237]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:49.237]                   0L) {
[16:17:49.237]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:49.237]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:49.237]                   base::options(opts)
[16:17:49.237]                 }
[16:17:49.237]                 {
[16:17:49.237]                   {
[16:17:49.237]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:49.237]                     NULL
[16:17:49.237]                   }
[16:17:49.237]                   options(future.plan = NULL)
[16:17:49.237]                   if (is.na(NA_character_)) 
[16:17:49.237]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:49.237]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:49.237]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:49.237]                     .init = FALSE)
[16:17:49.237]                 }
[16:17:49.237]             }
[16:17:49.237]         }
[16:17:49.237]     })
[16:17:49.237]     if (TRUE) {
[16:17:49.237]         base::sink(type = "output", split = FALSE)
[16:17:49.237]         if (TRUE) {
[16:17:49.237]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:49.237]         }
[16:17:49.237]         else {
[16:17:49.237]             ...future.result["stdout"] <- base::list(NULL)
[16:17:49.237]         }
[16:17:49.237]         base::close(...future.stdout)
[16:17:49.237]         ...future.stdout <- NULL
[16:17:49.237]     }
[16:17:49.237]     ...future.result$conditions <- ...future.conditions
[16:17:49.237]     ...future.result$finished <- base::Sys.time()
[16:17:49.237]     ...future.result
[16:17:49.237] }
[16:17:49.239] Exporting 7 global objects (2.27 KiB) to cluster node #1 ...
[16:17:49.239] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ...
[16:17:49.240] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ... DONE
[16:17:49.240] Exporting ‘breaks’ (480 bytes) to cluster node #1 ...
[16:17:49.240] Exporting ‘breaks’ (480 bytes) to cluster node #1 ... DONE
[16:17:49.240] Exporting ‘wool’ (776 bytes) to cluster node #1 ...
[16:17:49.241] Exporting ‘wool’ (776 bytes) to cluster node #1 ... DONE
[16:17:49.241] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:17:49.241] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:17:49.241] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[16:17:49.242] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[16:17:49.242] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:17:49.242] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:17:49.242] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:17:49.242] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:17:49.243] Exporting 7 global objects (2.27 KiB) to cluster node #1 ... DONE
[16:17:49.243] MultisessionFuture started
[16:17:49.243] - Launch lazy future ... done
[16:17:49.243] run() for ‘MultisessionFuture’ ... done
[16:17:49.243] Created future:
[16:17:49.243] MultisessionFuture:
[16:17:49.243] Label: ‘future_by-1’
[16:17:49.243] Expression:
[16:17:49.243] {
[16:17:49.243]     do.call(function(...) {
[16:17:49.243]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.243]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:49.243]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.243]             on.exit(options(oopts), add = TRUE)
[16:17:49.243]         }
[16:17:49.243]         {
[16:17:49.243]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:49.243]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.243]                 ...future.FUN(...future.X_jj, ...)
[16:17:49.243]             })
[16:17:49.243]         }
[16:17:49.243]     }, args = future.call.arguments)
[16:17:49.243] }
[16:17:49.243] Lazy evaluation: FALSE
[16:17:49.243] Asynchronous evaluation: TRUE
[16:17:49.243] Local evaluation: TRUE
[16:17:49.243] Environment: 0x55b568ba64b0
[16:17:49.243] Capture standard output: TRUE
[16:17:49.243] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:49.243] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[16:17:49.243] Packages: 1 packages (‘stats’)
[16:17:49.243] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:49.243] Resolved: FALSE
[16:17:49.243] Value: <not collected>
[16:17:49.243] Conditions captured: <none>
[16:17:49.243] Early signaling: FALSE
[16:17:49.243] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:49.243] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:49.255] Chunk #1 of 2 ... DONE
[16:17:49.255] Chunk #2 of 2 ...
[16:17:49.255]  - Finding globals in 'X' for chunk #2 ...
[16:17:49.255] getGlobalsAndPackages() ...
[16:17:49.256] Searching for globals...
[16:17:49.256] 
[16:17:49.256] Searching for globals ... DONE
[16:17:49.256] - globals: [0] <none>
[16:17:49.256] getGlobalsAndPackages() ... DONE
[16:17:49.256]    + additional globals found: [n=0] 
[16:17:49.256]    + additional namespaces needed: [n=0] 
[16:17:49.257]  - Finding globals in 'X' for chunk #2 ... DONE
[16:17:49.257]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:49.257]  - seeds: <none>
[16:17:49.257]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.257] getGlobalsAndPackages() ...
[16:17:49.257] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.257] Resolving globals: FALSE
[16:17:49.257] Tweak future expression to call with '...' arguments ...
[16:17:49.257] {
[16:17:49.257]     do.call(function(...) {
[16:17:49.257]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.257]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:49.257]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.257]             on.exit(options(oopts), add = TRUE)
[16:17:49.257]         }
[16:17:49.257]         {
[16:17:49.257]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:49.257]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.257]                 ...future.FUN(...future.X_jj, ...)
[16:17:49.257]             })
[16:17:49.257]         }
[16:17:49.257]     }, args = future.call.arguments)
[16:17:49.257] }
[16:17:49.258] Tweak future expression to call with '...' arguments ... DONE
[16:17:49.258] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.258] 
[16:17:49.258] getGlobalsAndPackages() ... DONE
[16:17:49.258] run() for ‘Future’ ...
[16:17:49.258] - state: ‘created’
[16:17:49.259] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:49.272] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:49.272] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:49.272]   - Field: ‘node’
[16:17:49.272]   - Field: ‘label’
[16:17:49.272]   - Field: ‘local’
[16:17:49.272]   - Field: ‘owner’
[16:17:49.272]   - Field: ‘envir’
[16:17:49.272]   - Field: ‘workers’
[16:17:49.273]   - Field: ‘packages’
[16:17:49.273]   - Field: ‘gc’
[16:17:49.273]   - Field: ‘conditions’
[16:17:49.273]   - Field: ‘persistent’
[16:17:49.273]   - Field: ‘expr’
[16:17:49.273]   - Field: ‘uuid’
[16:17:49.273]   - Field: ‘seed’
[16:17:49.273]   - Field: ‘version’
[16:17:49.273]   - Field: ‘result’
[16:17:49.273]   - Field: ‘asynchronous’
[16:17:49.273]   - Field: ‘calls’
[16:17:49.274]   - Field: ‘globals’
[16:17:49.274]   - Field: ‘stdout’
[16:17:49.274]   - Field: ‘earlySignal’
[16:17:49.274]   - Field: ‘lazy’
[16:17:49.274]   - Field: ‘state’
[16:17:49.274] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:49.274] - Launch lazy future ...
[16:17:49.274] Packages needed by the future expression (n = 1): ‘stats’
[16:17:49.274] Packages needed by future strategies (n = 0): <none>
[16:17:49.275] {
[16:17:49.275]     {
[16:17:49.275]         {
[16:17:49.275]             ...future.startTime <- base::Sys.time()
[16:17:49.275]             {
[16:17:49.275]                 {
[16:17:49.275]                   {
[16:17:49.275]                     {
[16:17:49.275]                       {
[16:17:49.275]                         base::local({
[16:17:49.275]                           has_future <- base::requireNamespace("future", 
[16:17:49.275]                             quietly = TRUE)
[16:17:49.275]                           if (has_future) {
[16:17:49.275]                             ns <- base::getNamespace("future")
[16:17:49.275]                             version <- ns[[".package"]][["version"]]
[16:17:49.275]                             if (is.null(version)) 
[16:17:49.275]                               version <- utils::packageVersion("future")
[16:17:49.275]                           }
[16:17:49.275]                           else {
[16:17:49.275]                             version <- NULL
[16:17:49.275]                           }
[16:17:49.275]                           if (!has_future || version < "1.8.0") {
[16:17:49.275]                             info <- base::c(r_version = base::gsub("R version ", 
[16:17:49.275]                               "", base::R.version$version.string), 
[16:17:49.275]                               platform = base::sprintf("%s (%s-bit)", 
[16:17:49.275]                                 base::R.version$platform, 8 * 
[16:17:49.275]                                   base::.Machine$sizeof.pointer), 
[16:17:49.275]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:49.275]                                 "release", "version")], collapse = " "), 
[16:17:49.275]                               hostname = base::Sys.info()[["nodename"]])
[16:17:49.275]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:17:49.275]                               info)
[16:17:49.275]                             info <- base::paste(info, collapse = "; ")
[16:17:49.275]                             if (!has_future) {
[16:17:49.275]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:49.275]                                 info)
[16:17:49.275]                             }
[16:17:49.275]                             else {
[16:17:49.275]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:49.275]                                 info, version)
[16:17:49.275]                             }
[16:17:49.275]                             base::stop(msg)
[16:17:49.275]                           }
[16:17:49.275]                         })
[16:17:49.275]                       }
[16:17:49.275]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:49.275]                       base::options(mc.cores = 1L)
[16:17:49.275]                     }
[16:17:49.275]                     base::local({
[16:17:49.275]                       for (pkg in "stats") {
[16:17:49.275]                         base::loadNamespace(pkg)
[16:17:49.275]                         base::library(pkg, character.only = TRUE)
[16:17:49.275]                       }
[16:17:49.275]                     })
[16:17:49.275]                   }
[16:17:49.275]                   ...future.strategy.old <- future::plan("list")
[16:17:49.275]                   options(future.plan = NULL)
[16:17:49.275]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:49.275]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:49.275]                 }
[16:17:49.275]                 ...future.workdir <- getwd()
[16:17:49.275]             }
[16:17:49.275]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:49.275]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:49.275]         }
[16:17:49.275]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:49.275]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:49.275]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:49.275]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:49.275]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:49.275]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:49.275]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:49.275]             base::names(...future.oldOptions))
[16:17:49.275]     }
[16:17:49.275]     if (FALSE) {
[16:17:49.275]     }
[16:17:49.275]     else {
[16:17:49.275]         if (TRUE) {
[16:17:49.275]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:49.275]                 open = "w")
[16:17:49.275]         }
[16:17:49.275]         else {
[16:17:49.275]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:49.275]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:49.275]         }
[16:17:49.275]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:49.275]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:49.275]             base::sink(type = "output", split = FALSE)
[16:17:49.275]             base::close(...future.stdout)
[16:17:49.275]         }, add = TRUE)
[16:17:49.275]     }
[16:17:49.275]     ...future.frame <- base::sys.nframe()
[16:17:49.275]     ...future.conditions <- base::list()
[16:17:49.275]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:49.275]     if (FALSE) {
[16:17:49.275]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:49.275]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:49.275]     }
[16:17:49.275]     ...future.result <- base::tryCatch({
[16:17:49.275]         base::withCallingHandlers({
[16:17:49.275]             ...future.value <- base::withVisible(base::local({
[16:17:49.275]                 ...future.makeSendCondition <- base::local({
[16:17:49.275]                   sendCondition <- NULL
[16:17:49.275]                   function(frame = 1L) {
[16:17:49.275]                     if (is.function(sendCondition)) 
[16:17:49.275]                       return(sendCondition)
[16:17:49.275]                     ns <- getNamespace("parallel")
[16:17:49.275]                     if (exists("sendData", mode = "function", 
[16:17:49.275]                       envir = ns)) {
[16:17:49.275]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:49.275]                         envir = ns)
[16:17:49.275]                       envir <- sys.frame(frame)
[16:17:49.275]                       master <- NULL
[16:17:49.275]                       while (!identical(envir, .GlobalEnv) && 
[16:17:49.275]                         !identical(envir, emptyenv())) {
[16:17:49.275]                         if (exists("master", mode = "list", envir = envir, 
[16:17:49.275]                           inherits = FALSE)) {
[16:17:49.275]                           master <- get("master", mode = "list", 
[16:17:49.275]                             envir = envir, inherits = FALSE)
[16:17:49.275]                           if (inherits(master, c("SOCKnode", 
[16:17:49.275]                             "SOCK0node"))) {
[16:17:49.275]                             sendCondition <<- function(cond) {
[16:17:49.275]                               data <- list(type = "VALUE", value = cond, 
[16:17:49.275]                                 success = TRUE)
[16:17:49.275]                               parallel_sendData(master, data)
[16:17:49.275]                             }
[16:17:49.275]                             return(sendCondition)
[16:17:49.275]                           }
[16:17:49.275]                         }
[16:17:49.275]                         frame <- frame + 1L
[16:17:49.275]                         envir <- sys.frame(frame)
[16:17:49.275]                       }
[16:17:49.275]                     }
[16:17:49.275]                     sendCondition <<- function(cond) NULL
[16:17:49.275]                   }
[16:17:49.275]                 })
[16:17:49.275]                 withCallingHandlers({
[16:17:49.275]                   {
[16:17:49.275]                     do.call(function(...) {
[16:17:49.275]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.275]                       if (!identical(...future.globals.maxSize.org, 
[16:17:49.275]                         ...future.globals.maxSize)) {
[16:17:49.275]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.275]                         on.exit(options(oopts), add = TRUE)
[16:17:49.275]                       }
[16:17:49.275]                       {
[16:17:49.275]                         lapply(seq_along(...future.elements_ii), 
[16:17:49.275]                           FUN = function(jj) {
[16:17:49.275]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.275]                             ...future.FUN(...future.X_jj, ...)
[16:17:49.275]                           })
[16:17:49.275]                       }
[16:17:49.275]                     }, args = future.call.arguments)
[16:17:49.275]                   }
[16:17:49.275]                 }, immediateCondition = function(cond) {
[16:17:49.275]                   sendCondition <- ...future.makeSendCondition()
[16:17:49.275]                   sendCondition(cond)
[16:17:49.275]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.275]                   {
[16:17:49.275]                     inherits <- base::inherits
[16:17:49.275]                     invokeRestart <- base::invokeRestart
[16:17:49.275]                     is.null <- base::is.null
[16:17:49.275]                     muffled <- FALSE
[16:17:49.275]                     if (inherits(cond, "message")) {
[16:17:49.275]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:49.275]                       if (muffled) 
[16:17:49.275]                         invokeRestart("muffleMessage")
[16:17:49.275]                     }
[16:17:49.275]                     else if (inherits(cond, "warning")) {
[16:17:49.275]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:49.275]                       if (muffled) 
[16:17:49.275]                         invokeRestart("muffleWarning")
[16:17:49.275]                     }
[16:17:49.275]                     else if (inherits(cond, "condition")) {
[16:17:49.275]                       if (!is.null(pattern)) {
[16:17:49.275]                         computeRestarts <- base::computeRestarts
[16:17:49.275]                         grepl <- base::grepl
[16:17:49.275]                         restarts <- computeRestarts(cond)
[16:17:49.275]                         for (restart in restarts) {
[16:17:49.275]                           name <- restart$name
[16:17:49.275]                           if (is.null(name)) 
[16:17:49.275]                             next
[16:17:49.275]                           if (!grepl(pattern, name)) 
[16:17:49.275]                             next
[16:17:49.275]                           invokeRestart(restart)
[16:17:49.275]                           muffled <- TRUE
[16:17:49.275]                           break
[16:17:49.275]                         }
[16:17:49.275]                       }
[16:17:49.275]                     }
[16:17:49.275]                     invisible(muffled)
[16:17:49.275]                   }
[16:17:49.275]                   muffleCondition(cond)
[16:17:49.275]                 })
[16:17:49.275]             }))
[16:17:49.275]             future::FutureResult(value = ...future.value$value, 
[16:17:49.275]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:49.275]                   ...future.rng), globalenv = if (FALSE) 
[16:17:49.275]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:49.275]                     ...future.globalenv.names))
[16:17:49.275]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:49.275]         }, condition = base::local({
[16:17:49.275]             c <- base::c
[16:17:49.275]             inherits <- base::inherits
[16:17:49.275]             invokeRestart <- base::invokeRestart
[16:17:49.275]             length <- base::length
[16:17:49.275]             list <- base::list
[16:17:49.275]             seq.int <- base::seq.int
[16:17:49.275]             signalCondition <- base::signalCondition
[16:17:49.275]             sys.calls <- base::sys.calls
[16:17:49.275]             `[[` <- base::`[[`
[16:17:49.275]             `+` <- base::`+`
[16:17:49.275]             `<<-` <- base::`<<-`
[16:17:49.275]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:49.275]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:49.275]                   3L)]
[16:17:49.275]             }
[16:17:49.275]             function(cond) {
[16:17:49.275]                 is_error <- inherits(cond, "error")
[16:17:49.275]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:49.275]                   NULL)
[16:17:49.275]                 if (is_error) {
[16:17:49.275]                   sessionInformation <- function() {
[16:17:49.275]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:49.275]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:49.275]                       search = base::search(), system = base::Sys.info())
[16:17:49.275]                   }
[16:17:49.275]                   ...future.conditions[[length(...future.conditions) + 
[16:17:49.275]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:49.275]                     cond$call), session = sessionInformation(), 
[16:17:49.275]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:49.275]                   signalCondition(cond)
[16:17:49.275]                 }
[16:17:49.275]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:49.275]                 "immediateCondition"))) {
[16:17:49.275]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:49.275]                   ...future.conditions[[length(...future.conditions) + 
[16:17:49.275]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:49.275]                   if (TRUE && !signal) {
[16:17:49.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.275]                     {
[16:17:49.275]                       inherits <- base::inherits
[16:17:49.275]                       invokeRestart <- base::invokeRestart
[16:17:49.275]                       is.null <- base::is.null
[16:17:49.275]                       muffled <- FALSE
[16:17:49.275]                       if (inherits(cond, "message")) {
[16:17:49.275]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:49.275]                         if (muffled) 
[16:17:49.275]                           invokeRestart("muffleMessage")
[16:17:49.275]                       }
[16:17:49.275]                       else if (inherits(cond, "warning")) {
[16:17:49.275]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:49.275]                         if (muffled) 
[16:17:49.275]                           invokeRestart("muffleWarning")
[16:17:49.275]                       }
[16:17:49.275]                       else if (inherits(cond, "condition")) {
[16:17:49.275]                         if (!is.null(pattern)) {
[16:17:49.275]                           computeRestarts <- base::computeRestarts
[16:17:49.275]                           grepl <- base::grepl
[16:17:49.275]                           restarts <- computeRestarts(cond)
[16:17:49.275]                           for (restart in restarts) {
[16:17:49.275]                             name <- restart$name
[16:17:49.275]                             if (is.null(name)) 
[16:17:49.275]                               next
[16:17:49.275]                             if (!grepl(pattern, name)) 
[16:17:49.275]                               next
[16:17:49.275]                             invokeRestart(restart)
[16:17:49.275]                             muffled <- TRUE
[16:17:49.275]                             break
[16:17:49.275]                           }
[16:17:49.275]                         }
[16:17:49.275]                       }
[16:17:49.275]                       invisible(muffled)
[16:17:49.275]                     }
[16:17:49.275]                     muffleCondition(cond, pattern = "^muffle")
[16:17:49.275]                   }
[16:17:49.275]                 }
[16:17:49.275]                 else {
[16:17:49.275]                   if (TRUE) {
[16:17:49.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.275]                     {
[16:17:49.275]                       inherits <- base::inherits
[16:17:49.275]                       invokeRestart <- base::invokeRestart
[16:17:49.275]                       is.null <- base::is.null
[16:17:49.275]                       muffled <- FALSE
[16:17:49.275]                       if (inherits(cond, "message")) {
[16:17:49.275]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:49.275]                         if (muffled) 
[16:17:49.275]                           invokeRestart("muffleMessage")
[16:17:49.275]                       }
[16:17:49.275]                       else if (inherits(cond, "warning")) {
[16:17:49.275]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:49.275]                         if (muffled) 
[16:17:49.275]                           invokeRestart("muffleWarning")
[16:17:49.275]                       }
[16:17:49.275]                       else if (inherits(cond, "condition")) {
[16:17:49.275]                         if (!is.null(pattern)) {
[16:17:49.275]                           computeRestarts <- base::computeRestarts
[16:17:49.275]                           grepl <- base::grepl
[16:17:49.275]                           restarts <- computeRestarts(cond)
[16:17:49.275]                           for (restart in restarts) {
[16:17:49.275]                             name <- restart$name
[16:17:49.275]                             if (is.null(name)) 
[16:17:49.275]                               next
[16:17:49.275]                             if (!grepl(pattern, name)) 
[16:17:49.275]                               next
[16:17:49.275]                             invokeRestart(restart)
[16:17:49.275]                             muffled <- TRUE
[16:17:49.275]                             break
[16:17:49.275]                           }
[16:17:49.275]                         }
[16:17:49.275]                       }
[16:17:49.275]                       invisible(muffled)
[16:17:49.275]                     }
[16:17:49.275]                     muffleCondition(cond, pattern = "^muffle")
[16:17:49.275]                   }
[16:17:49.275]                 }
[16:17:49.275]             }
[16:17:49.275]         }))
[16:17:49.275]     }, error = function(ex) {
[16:17:49.275]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:49.275]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:49.275]                 ...future.rng), started = ...future.startTime, 
[16:17:49.275]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:49.275]             version = "1.8"), class = "FutureResult")
[16:17:49.275]     }, finally = {
[16:17:49.275]         if (!identical(...future.workdir, getwd())) 
[16:17:49.275]             setwd(...future.workdir)
[16:17:49.275]         {
[16:17:49.275]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:49.275]                 ...future.oldOptions$nwarnings <- NULL
[16:17:49.275]             }
[16:17:49.275]             base::options(...future.oldOptions)
[16:17:49.275]             if (.Platform$OS.type == "windows") {
[16:17:49.275]                 old_names <- names(...future.oldEnvVars)
[16:17:49.275]                 envs <- base::Sys.getenv()
[16:17:49.275]                 names <- names(envs)
[16:17:49.275]                 common <- intersect(names, old_names)
[16:17:49.275]                 added <- setdiff(names, old_names)
[16:17:49.275]                 removed <- setdiff(old_names, names)
[16:17:49.275]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:49.275]                   envs[common]]
[16:17:49.275]                 NAMES <- toupper(changed)
[16:17:49.275]                 args <- list()
[16:17:49.275]                 for (kk in seq_along(NAMES)) {
[16:17:49.275]                   name <- changed[[kk]]
[16:17:49.275]                   NAME <- NAMES[[kk]]
[16:17:49.275]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.275]                     next
[16:17:49.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:49.275]                 }
[16:17:49.275]                 NAMES <- toupper(added)
[16:17:49.275]                 for (kk in seq_along(NAMES)) {
[16:17:49.275]                   name <- added[[kk]]
[16:17:49.275]                   NAME <- NAMES[[kk]]
[16:17:49.275]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.275]                     next
[16:17:49.275]                   args[[name]] <- ""
[16:17:49.275]                 }
[16:17:49.275]                 NAMES <- toupper(removed)
[16:17:49.275]                 for (kk in seq_along(NAMES)) {
[16:17:49.275]                   name <- removed[[kk]]
[16:17:49.275]                   NAME <- NAMES[[kk]]
[16:17:49.275]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.275]                     next
[16:17:49.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:49.275]                 }
[16:17:49.275]                 if (length(args) > 0) 
[16:17:49.275]                   base::do.call(base::Sys.setenv, args = args)
[16:17:49.275]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:49.275]             }
[16:17:49.275]             else {
[16:17:49.275]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:49.275]             }
[16:17:49.275]             {
[16:17:49.275]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:49.275]                   0L) {
[16:17:49.275]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:49.275]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:49.275]                   base::options(opts)
[16:17:49.275]                 }
[16:17:49.275]                 {
[16:17:49.275]                   {
[16:17:49.275]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:49.275]                     NULL
[16:17:49.275]                   }
[16:17:49.275]                   options(future.plan = NULL)
[16:17:49.275]                   if (is.na(NA_character_)) 
[16:17:49.275]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:49.275]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:49.275]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:49.275]                     .init = FALSE)
[16:17:49.275]                 }
[16:17:49.275]             }
[16:17:49.275]         }
[16:17:49.275]     })
[16:17:49.275]     if (TRUE) {
[16:17:49.275]         base::sink(type = "output", split = FALSE)
[16:17:49.275]         if (TRUE) {
[16:17:49.275]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:49.275]         }
[16:17:49.275]         else {
[16:17:49.275]             ...future.result["stdout"] <- base::list(NULL)
[16:17:49.275]         }
[16:17:49.275]         base::close(...future.stdout)
[16:17:49.275]         ...future.stdout <- NULL
[16:17:49.275]     }
[16:17:49.275]     ...future.result$conditions <- ...future.conditions
[16:17:49.275]     ...future.result$finished <- base::Sys.time()
[16:17:49.275]     ...future.result
[16:17:49.275] }
[16:17:49.277] Exporting 7 global objects (2.27 KiB) to cluster node #2 ...
[16:17:49.278] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ...
[16:17:49.278] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ... DONE
[16:17:49.278] Exporting ‘breaks’ (480 bytes) to cluster node #2 ...
[16:17:49.278] Exporting ‘breaks’ (480 bytes) to cluster node #2 ... DONE
[16:17:49.278] Exporting ‘wool’ (776 bytes) to cluster node #2 ...
[16:17:49.279] Exporting ‘wool’ (776 bytes) to cluster node #2 ... DONE
[16:17:49.279] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:17:49.279] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:17:49.280] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[16:17:49.280] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[16:17:49.280] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:17:49.280] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:17:49.280] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:17:49.281] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:17:49.281] Exporting 7 global objects (2.27 KiB) to cluster node #2 ... DONE
[16:17:49.281] MultisessionFuture started
[16:17:49.281] - Launch lazy future ... done
[16:17:49.281] run() for ‘MultisessionFuture’ ... done
[16:17:49.282] Created future:
[16:17:49.282] MultisessionFuture:
[16:17:49.282] Label: ‘future_by-2’
[16:17:49.282] Expression:
[16:17:49.282] {
[16:17:49.282]     do.call(function(...) {
[16:17:49.282]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.282]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:49.282]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.282]             on.exit(options(oopts), add = TRUE)
[16:17:49.282]         }
[16:17:49.282]         {
[16:17:49.282]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:49.282]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.282]                 ...future.FUN(...future.X_jj, ...)
[16:17:49.282]             })
[16:17:49.282]         }
[16:17:49.282]     }, args = future.call.arguments)
[16:17:49.282] }
[16:17:49.282] Lazy evaluation: FALSE
[16:17:49.282] Asynchronous evaluation: TRUE
[16:17:49.282] Local evaluation: TRUE
[16:17:49.282] Environment: 0x55b568ba64b0
[16:17:49.282] Capture standard output: TRUE
[16:17:49.282] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:49.282] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[16:17:49.282] Packages: 1 packages (‘stats’)
[16:17:49.282] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:49.282] Resolved: FALSE
[16:17:49.282] Value: <not collected>
[16:17:49.282] Conditions captured: <none>
[16:17:49.282] Early signaling: FALSE
[16:17:49.282] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:49.282] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:49.293] Chunk #2 of 2 ... DONE
[16:17:49.293] Launching 2 futures (chunks) ... DONE
[16:17:49.293] Resolving 2 futures (chunks) ...
[16:17:49.293] resolve() on list ...
[16:17:49.294]  recursive: 0
[16:17:49.294]  length: 2
[16:17:49.294] 
[16:17:49.294] receiveMessageFromWorker() for ClusterFuture ...
[16:17:49.294] - Validating connection of MultisessionFuture
[16:17:49.294] - received message: FutureResult
[16:17:49.295] - Received FutureResult
[16:17:49.295] - Erased future from FutureRegistry
[16:17:49.295] result() for ClusterFuture ...
[16:17:49.295] - result already collected: FutureResult
[16:17:49.295] result() for ClusterFuture ... done
[16:17:49.295] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:49.295] Future #1
[16:17:49.295] result() for ClusterFuture ...
[16:17:49.295] - result already collected: FutureResult
[16:17:49.295] result() for ClusterFuture ... done
[16:17:49.295] result() for ClusterFuture ...
[16:17:49.296] - result already collected: FutureResult
[16:17:49.296] result() for ClusterFuture ... done
[16:17:49.296] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:17:49.296] - nx: 2
[16:17:49.296] - relay: TRUE
[16:17:49.296] - stdout: TRUE
[16:17:49.296] - signal: TRUE
[16:17:49.296] - resignal: FALSE
[16:17:49.296] - force: TRUE
[16:17:49.296] - relayed: [n=2] FALSE, FALSE
[16:17:49.296] - queued futures: [n=2] FALSE, FALSE
[16:17:49.297]  - until=1
[16:17:49.297]  - relaying element #1
[16:17:49.297] result() for ClusterFuture ...
[16:17:49.297] - result already collected: FutureResult
[16:17:49.297] result() for ClusterFuture ... done
[16:17:49.297] result() for ClusterFuture ...
[16:17:49.297] - result already collected: FutureResult
[16:17:49.297] result() for ClusterFuture ... done
[16:17:49.297] result() for ClusterFuture ...
[16:17:49.297] - result already collected: FutureResult
[16:17:49.297] result() for ClusterFuture ... done
[16:17:49.298] result() for ClusterFuture ...
[16:17:49.298] - result already collected: FutureResult
[16:17:49.298] result() for ClusterFuture ... done
[16:17:49.298] - relayed: [n=2] TRUE, FALSE
[16:17:49.298] - queued futures: [n=2] TRUE, FALSE
[16:17:49.298] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:17:49.298]  length: 1 (resolved future 1)
[16:17:49.340] receiveMessageFromWorker() for ClusterFuture ...
[16:17:49.340] - Validating connection of MultisessionFuture
[16:17:49.340] - received message: FutureResult
[16:17:49.340] - Received FutureResult
[16:17:49.340] - Erased future from FutureRegistry
[16:17:49.340] result() for ClusterFuture ...
[16:17:49.340] - result already collected: FutureResult
[16:17:49.341] result() for ClusterFuture ... done
[16:17:49.341] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:49.341] Future #2
[16:17:49.341] result() for ClusterFuture ...
[16:17:49.341] - result already collected: FutureResult
[16:17:49.341] result() for ClusterFuture ... done
[16:17:49.341] result() for ClusterFuture ...
[16:17:49.341] - result already collected: FutureResult
[16:17:49.341] result() for ClusterFuture ... done
[16:17:49.341] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:17:49.341] - nx: 2
[16:17:49.341] - relay: TRUE
[16:17:49.342] - stdout: TRUE
[16:17:49.342] - signal: TRUE
[16:17:49.342] - resignal: FALSE
[16:17:49.342] - force: TRUE
[16:17:49.342] - relayed: [n=2] TRUE, FALSE
[16:17:49.342] - queued futures: [n=2] TRUE, FALSE
[16:17:49.342]  - until=2
[16:17:49.342]  - relaying element #2
[16:17:49.342] result() for ClusterFuture ...
[16:17:49.342] - result already collected: FutureResult
[16:17:49.342] result() for ClusterFuture ... done
[16:17:49.342] result() for ClusterFuture ...
[16:17:49.343] - result already collected: FutureResult
[16:17:49.343] result() for ClusterFuture ... done
[16:17:49.343] result() for ClusterFuture ...
[16:17:49.343] - result already collected: FutureResult
[16:17:49.343] result() for ClusterFuture ... done
[16:17:49.343] result() for ClusterFuture ...
[16:17:49.343] - result already collected: FutureResult
[16:17:49.343] result() for ClusterFuture ... done
[16:17:49.343] - relayed: [n=2] TRUE, TRUE
[16:17:49.343] - queued futures: [n=2] TRUE, TRUE
[16:17:49.343] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:17:49.343]  length: 0 (resolved future 2)
[16:17:49.344] Relaying remaining futures
[16:17:49.344] signalConditionsASAP(NULL, pos=0) ...
[16:17:49.344] - nx: 2
[16:17:49.344] - relay: TRUE
[16:17:49.344] - stdout: TRUE
[16:17:49.344] - signal: TRUE
[16:17:49.344] - resignal: FALSE
[16:17:49.344] - force: TRUE
[16:17:49.344] - relayed: [n=2] TRUE, TRUE
[16:17:49.344] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:49.344] - relayed: [n=2] TRUE, TRUE
[16:17:49.345] - queued futures: [n=2] TRUE, TRUE
[16:17:49.345] signalConditionsASAP(NULL, pos=0) ... done
[16:17:49.345] resolve() on list ... DONE
[16:17:49.345] result() for ClusterFuture ...
[16:17:49.345] - result already collected: FutureResult
[16:17:49.345] result() for ClusterFuture ... done
[16:17:49.345] result() for ClusterFuture ...
[16:17:49.345] - result already collected: FutureResult
[16:17:49.345] result() for ClusterFuture ... done
[16:17:49.345] result() for ClusterFuture ...
[16:17:49.345] - result already collected: FutureResult
[16:17:49.345] result() for ClusterFuture ... done
[16:17:49.346] result() for ClusterFuture ...
[16:17:49.346] - result already collected: FutureResult
[16:17:49.346] result() for ClusterFuture ... done
[16:17:49.346]  - Number of value chunks collected: 2
[16:17:49.346] Resolving 2 futures (chunks) ... DONE
[16:17:49.346] Reducing values from 2 chunks ...
[16:17:49.346]  - Number of values collected after concatenation: 3
[16:17:49.346]  - Number of values expected: 3
[16:17:49.346] Reducing values from 2 chunks ... DONE
[16:17:49.346] future_lapply() ... DONE
[16:17:49.346] future_by_internal() ... DONE
[16:17:49.347] future_by_internal() ...
[16:17:49.347] future_lapply() ...
[16:17:49.351] Number of chunks: 2
[16:17:49.352] getGlobalsAndPackagesXApply() ...
[16:17:49.352]  - future.globals: TRUE
[16:17:49.352] getGlobalsAndPackages() ...
[16:17:49.352] Searching for globals...
[16:17:49.353] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:49.353] Searching for globals ... DONE
[16:17:49.353] Resolving globals: FALSE
[16:17:49.354] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:49.354] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:49.354] - globals: [1] ‘FUN’
[16:17:49.354] 
[16:17:49.354] getGlobalsAndPackages() ... DONE
[16:17:49.354]  - globals found/used: [n=1] ‘FUN’
[16:17:49.355]  - needed namespaces: [n=0] 
[16:17:49.355] Finding globals ... DONE
[16:17:49.355]  - use_args: TRUE
[16:17:49.355]  - Getting '...' globals ...
[16:17:49.355] resolve() on list ...
[16:17:49.355]  recursive: 0
[16:17:49.355]  length: 1
[16:17:49.355]  elements: ‘...’
[16:17:49.356]  length: 0 (resolved future 1)
[16:17:49.356] resolve() on list ... DONE
[16:17:49.356]    - '...' content: [n=0] 
[16:17:49.356] List of 1
[16:17:49.356]  $ ...: list()
[16:17:49.356]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:49.356]  - attr(*, "where")=List of 1
[16:17:49.356]   ..$ ...:<environment: 0x55b5692d2808> 
[16:17:49.356]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:49.356]  - attr(*, "resolved")= logi TRUE
[16:17:49.356]  - attr(*, "total_size")= num NA
[16:17:49.358]  - Getting '...' globals ... DONE
[16:17:49.359] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:49.359] List of 2
[16:17:49.359]  $ ...future.FUN:function (object, ...)  
[16:17:49.359]  $ ...          : list()
[16:17:49.359]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:49.359]  - attr(*, "where")=List of 2
[16:17:49.359]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:49.359]   ..$ ...          :<environment: 0x55b5692d2808> 
[16:17:49.359]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:49.359]  - attr(*, "resolved")= logi FALSE
[16:17:49.359]  - attr(*, "total_size")= num 1240
[16:17:49.361] Packages to be attached in all futures: [n=0] 
[16:17:49.361] getGlobalsAndPackagesXApply() ... DONE
[16:17:49.361] Number of futures (= number of chunks): 2
[16:17:49.362] Launching 2 futures (chunks) ...
[16:17:49.362] Chunk #1 of 2 ...
[16:17:49.362]  - Finding globals in 'X' for chunk #1 ...
[16:17:49.362] getGlobalsAndPackages() ...
[16:17:49.362] Searching for globals...
[16:17:49.362] 
[16:17:49.362] Searching for globals ... DONE
[16:17:49.363] - globals: [0] <none>
[16:17:49.363] getGlobalsAndPackages() ... DONE
[16:17:49.363]    + additional globals found: [n=0] 
[16:17:49.363]    + additional namespaces needed: [n=0] 
[16:17:49.363]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:49.363]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:49.363]  - seeds: <none>
[16:17:49.363]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.363] getGlobalsAndPackages() ...
[16:17:49.363] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.363] Resolving globals: FALSE
[16:17:49.364] Tweak future expression to call with '...' arguments ...
[16:17:49.364] {
[16:17:49.364]     do.call(function(...) {
[16:17:49.364]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.364]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:49.364]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.364]             on.exit(options(oopts), add = TRUE)
[16:17:49.364]         }
[16:17:49.364]         {
[16:17:49.364]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:49.364]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.364]                 ...future.FUN(...future.X_jj, ...)
[16:17:49.364]             })
[16:17:49.364]         }
[16:17:49.364]     }, args = future.call.arguments)
[16:17:49.364] }
[16:17:49.364] Tweak future expression to call with '...' arguments ... DONE
[16:17:49.364] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.364] 
[16:17:49.365] getGlobalsAndPackages() ... DONE
[16:17:49.365] run() for ‘Future’ ...
[16:17:49.365] - state: ‘created’
[16:17:49.365] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:49.378] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:49.379] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:49.379]   - Field: ‘node’
[16:17:49.379]   - Field: ‘label’
[16:17:49.379]   - Field: ‘local’
[16:17:49.379]   - Field: ‘owner’
[16:17:49.379]   - Field: ‘envir’
[16:17:49.379]   - Field: ‘workers’
[16:17:49.379]   - Field: ‘packages’
[16:17:49.379]   - Field: ‘gc’
[16:17:49.379]   - Field: ‘conditions’
[16:17:49.379]   - Field: ‘persistent’
[16:17:49.380]   - Field: ‘expr’
[16:17:49.380]   - Field: ‘uuid’
[16:17:49.380]   - Field: ‘seed’
[16:17:49.380]   - Field: ‘version’
[16:17:49.380]   - Field: ‘result’
[16:17:49.380]   - Field: ‘asynchronous’
[16:17:49.380]   - Field: ‘calls’
[16:17:49.380]   - Field: ‘globals’
[16:17:49.380]   - Field: ‘stdout’
[16:17:49.380]   - Field: ‘earlySignal’
[16:17:49.381]   - Field: ‘lazy’
[16:17:49.381]   - Field: ‘state’
[16:17:49.381] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:49.381] - Launch lazy future ...
[16:17:49.381] Packages needed by the future expression (n = 0): <none>
[16:17:49.381] Packages needed by future strategies (n = 0): <none>
[16:17:49.382] {
[16:17:49.382]     {
[16:17:49.382]         {
[16:17:49.382]             ...future.startTime <- base::Sys.time()
[16:17:49.382]             {
[16:17:49.382]                 {
[16:17:49.382]                   {
[16:17:49.382]                     {
[16:17:49.382]                       base::local({
[16:17:49.382]                         has_future <- base::requireNamespace("future", 
[16:17:49.382]                           quietly = TRUE)
[16:17:49.382]                         if (has_future) {
[16:17:49.382]                           ns <- base::getNamespace("future")
[16:17:49.382]                           version <- ns[[".package"]][["version"]]
[16:17:49.382]                           if (is.null(version)) 
[16:17:49.382]                             version <- utils::packageVersion("future")
[16:17:49.382]                         }
[16:17:49.382]                         else {
[16:17:49.382]                           version <- NULL
[16:17:49.382]                         }
[16:17:49.382]                         if (!has_future || version < "1.8.0") {
[16:17:49.382]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:49.382]                             "", base::R.version$version.string), 
[16:17:49.382]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:49.382]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:49.382]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:49.382]                               "release", "version")], collapse = " "), 
[16:17:49.382]                             hostname = base::Sys.info()[["nodename"]])
[16:17:49.382]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:49.382]                             info)
[16:17:49.382]                           info <- base::paste(info, collapse = "; ")
[16:17:49.382]                           if (!has_future) {
[16:17:49.382]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:49.382]                               info)
[16:17:49.382]                           }
[16:17:49.382]                           else {
[16:17:49.382]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:49.382]                               info, version)
[16:17:49.382]                           }
[16:17:49.382]                           base::stop(msg)
[16:17:49.382]                         }
[16:17:49.382]                       })
[16:17:49.382]                     }
[16:17:49.382]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:49.382]                     base::options(mc.cores = 1L)
[16:17:49.382]                   }
[16:17:49.382]                   ...future.strategy.old <- future::plan("list")
[16:17:49.382]                   options(future.plan = NULL)
[16:17:49.382]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:49.382]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:49.382]                 }
[16:17:49.382]                 ...future.workdir <- getwd()
[16:17:49.382]             }
[16:17:49.382]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:49.382]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:49.382]         }
[16:17:49.382]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:49.382]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:49.382]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:49.382]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:49.382]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:49.382]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:49.382]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:49.382]             base::names(...future.oldOptions))
[16:17:49.382]     }
[16:17:49.382]     if (FALSE) {
[16:17:49.382]     }
[16:17:49.382]     else {
[16:17:49.382]         if (TRUE) {
[16:17:49.382]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:49.382]                 open = "w")
[16:17:49.382]         }
[16:17:49.382]         else {
[16:17:49.382]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:49.382]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:49.382]         }
[16:17:49.382]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:49.382]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:49.382]             base::sink(type = "output", split = FALSE)
[16:17:49.382]             base::close(...future.stdout)
[16:17:49.382]         }, add = TRUE)
[16:17:49.382]     }
[16:17:49.382]     ...future.frame <- base::sys.nframe()
[16:17:49.382]     ...future.conditions <- base::list()
[16:17:49.382]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:49.382]     if (FALSE) {
[16:17:49.382]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:49.382]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:49.382]     }
[16:17:49.382]     ...future.result <- base::tryCatch({
[16:17:49.382]         base::withCallingHandlers({
[16:17:49.382]             ...future.value <- base::withVisible(base::local({
[16:17:49.382]                 ...future.makeSendCondition <- base::local({
[16:17:49.382]                   sendCondition <- NULL
[16:17:49.382]                   function(frame = 1L) {
[16:17:49.382]                     if (is.function(sendCondition)) 
[16:17:49.382]                       return(sendCondition)
[16:17:49.382]                     ns <- getNamespace("parallel")
[16:17:49.382]                     if (exists("sendData", mode = "function", 
[16:17:49.382]                       envir = ns)) {
[16:17:49.382]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:49.382]                         envir = ns)
[16:17:49.382]                       envir <- sys.frame(frame)
[16:17:49.382]                       master <- NULL
[16:17:49.382]                       while (!identical(envir, .GlobalEnv) && 
[16:17:49.382]                         !identical(envir, emptyenv())) {
[16:17:49.382]                         if (exists("master", mode = "list", envir = envir, 
[16:17:49.382]                           inherits = FALSE)) {
[16:17:49.382]                           master <- get("master", mode = "list", 
[16:17:49.382]                             envir = envir, inherits = FALSE)
[16:17:49.382]                           if (inherits(master, c("SOCKnode", 
[16:17:49.382]                             "SOCK0node"))) {
[16:17:49.382]                             sendCondition <<- function(cond) {
[16:17:49.382]                               data <- list(type = "VALUE", value = cond, 
[16:17:49.382]                                 success = TRUE)
[16:17:49.382]                               parallel_sendData(master, data)
[16:17:49.382]                             }
[16:17:49.382]                             return(sendCondition)
[16:17:49.382]                           }
[16:17:49.382]                         }
[16:17:49.382]                         frame <- frame + 1L
[16:17:49.382]                         envir <- sys.frame(frame)
[16:17:49.382]                       }
[16:17:49.382]                     }
[16:17:49.382]                     sendCondition <<- function(cond) NULL
[16:17:49.382]                   }
[16:17:49.382]                 })
[16:17:49.382]                 withCallingHandlers({
[16:17:49.382]                   {
[16:17:49.382]                     do.call(function(...) {
[16:17:49.382]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.382]                       if (!identical(...future.globals.maxSize.org, 
[16:17:49.382]                         ...future.globals.maxSize)) {
[16:17:49.382]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.382]                         on.exit(options(oopts), add = TRUE)
[16:17:49.382]                       }
[16:17:49.382]                       {
[16:17:49.382]                         lapply(seq_along(...future.elements_ii), 
[16:17:49.382]                           FUN = function(jj) {
[16:17:49.382]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.382]                             ...future.FUN(...future.X_jj, ...)
[16:17:49.382]                           })
[16:17:49.382]                       }
[16:17:49.382]                     }, args = future.call.arguments)
[16:17:49.382]                   }
[16:17:49.382]                 }, immediateCondition = function(cond) {
[16:17:49.382]                   sendCondition <- ...future.makeSendCondition()
[16:17:49.382]                   sendCondition(cond)
[16:17:49.382]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.382]                   {
[16:17:49.382]                     inherits <- base::inherits
[16:17:49.382]                     invokeRestart <- base::invokeRestart
[16:17:49.382]                     is.null <- base::is.null
[16:17:49.382]                     muffled <- FALSE
[16:17:49.382]                     if (inherits(cond, "message")) {
[16:17:49.382]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:49.382]                       if (muffled) 
[16:17:49.382]                         invokeRestart("muffleMessage")
[16:17:49.382]                     }
[16:17:49.382]                     else if (inherits(cond, "warning")) {
[16:17:49.382]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:49.382]                       if (muffled) 
[16:17:49.382]                         invokeRestart("muffleWarning")
[16:17:49.382]                     }
[16:17:49.382]                     else if (inherits(cond, "condition")) {
[16:17:49.382]                       if (!is.null(pattern)) {
[16:17:49.382]                         computeRestarts <- base::computeRestarts
[16:17:49.382]                         grepl <- base::grepl
[16:17:49.382]                         restarts <- computeRestarts(cond)
[16:17:49.382]                         for (restart in restarts) {
[16:17:49.382]                           name <- restart$name
[16:17:49.382]                           if (is.null(name)) 
[16:17:49.382]                             next
[16:17:49.382]                           if (!grepl(pattern, name)) 
[16:17:49.382]                             next
[16:17:49.382]                           invokeRestart(restart)
[16:17:49.382]                           muffled <- TRUE
[16:17:49.382]                           break
[16:17:49.382]                         }
[16:17:49.382]                       }
[16:17:49.382]                     }
[16:17:49.382]                     invisible(muffled)
[16:17:49.382]                   }
[16:17:49.382]                   muffleCondition(cond)
[16:17:49.382]                 })
[16:17:49.382]             }))
[16:17:49.382]             future::FutureResult(value = ...future.value$value, 
[16:17:49.382]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:49.382]                   ...future.rng), globalenv = if (FALSE) 
[16:17:49.382]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:49.382]                     ...future.globalenv.names))
[16:17:49.382]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:49.382]         }, condition = base::local({
[16:17:49.382]             c <- base::c
[16:17:49.382]             inherits <- base::inherits
[16:17:49.382]             invokeRestart <- base::invokeRestart
[16:17:49.382]             length <- base::length
[16:17:49.382]             list <- base::list
[16:17:49.382]             seq.int <- base::seq.int
[16:17:49.382]             signalCondition <- base::signalCondition
[16:17:49.382]             sys.calls <- base::sys.calls
[16:17:49.382]             `[[` <- base::`[[`
[16:17:49.382]             `+` <- base::`+`
[16:17:49.382]             `<<-` <- base::`<<-`
[16:17:49.382]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:49.382]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:49.382]                   3L)]
[16:17:49.382]             }
[16:17:49.382]             function(cond) {
[16:17:49.382]                 is_error <- inherits(cond, "error")
[16:17:49.382]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:49.382]                   NULL)
[16:17:49.382]                 if (is_error) {
[16:17:49.382]                   sessionInformation <- function() {
[16:17:49.382]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:49.382]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:49.382]                       search = base::search(), system = base::Sys.info())
[16:17:49.382]                   }
[16:17:49.382]                   ...future.conditions[[length(...future.conditions) + 
[16:17:49.382]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:49.382]                     cond$call), session = sessionInformation(), 
[16:17:49.382]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:49.382]                   signalCondition(cond)
[16:17:49.382]                 }
[16:17:49.382]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:49.382]                 "immediateCondition"))) {
[16:17:49.382]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:49.382]                   ...future.conditions[[length(...future.conditions) + 
[16:17:49.382]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:49.382]                   if (TRUE && !signal) {
[16:17:49.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.382]                     {
[16:17:49.382]                       inherits <- base::inherits
[16:17:49.382]                       invokeRestart <- base::invokeRestart
[16:17:49.382]                       is.null <- base::is.null
[16:17:49.382]                       muffled <- FALSE
[16:17:49.382]                       if (inherits(cond, "message")) {
[16:17:49.382]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:49.382]                         if (muffled) 
[16:17:49.382]                           invokeRestart("muffleMessage")
[16:17:49.382]                       }
[16:17:49.382]                       else if (inherits(cond, "warning")) {
[16:17:49.382]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:49.382]                         if (muffled) 
[16:17:49.382]                           invokeRestart("muffleWarning")
[16:17:49.382]                       }
[16:17:49.382]                       else if (inherits(cond, "condition")) {
[16:17:49.382]                         if (!is.null(pattern)) {
[16:17:49.382]                           computeRestarts <- base::computeRestarts
[16:17:49.382]                           grepl <- base::grepl
[16:17:49.382]                           restarts <- computeRestarts(cond)
[16:17:49.382]                           for (restart in restarts) {
[16:17:49.382]                             name <- restart$name
[16:17:49.382]                             if (is.null(name)) 
[16:17:49.382]                               next
[16:17:49.382]                             if (!grepl(pattern, name)) 
[16:17:49.382]                               next
[16:17:49.382]                             invokeRestart(restart)
[16:17:49.382]                             muffled <- TRUE
[16:17:49.382]                             break
[16:17:49.382]                           }
[16:17:49.382]                         }
[16:17:49.382]                       }
[16:17:49.382]                       invisible(muffled)
[16:17:49.382]                     }
[16:17:49.382]                     muffleCondition(cond, pattern = "^muffle")
[16:17:49.382]                   }
[16:17:49.382]                 }
[16:17:49.382]                 else {
[16:17:49.382]                   if (TRUE) {
[16:17:49.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.382]                     {
[16:17:49.382]                       inherits <- base::inherits
[16:17:49.382]                       invokeRestart <- base::invokeRestart
[16:17:49.382]                       is.null <- base::is.null
[16:17:49.382]                       muffled <- FALSE
[16:17:49.382]                       if (inherits(cond, "message")) {
[16:17:49.382]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:49.382]                         if (muffled) 
[16:17:49.382]                           invokeRestart("muffleMessage")
[16:17:49.382]                       }
[16:17:49.382]                       else if (inherits(cond, "warning")) {
[16:17:49.382]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:49.382]                         if (muffled) 
[16:17:49.382]                           invokeRestart("muffleWarning")
[16:17:49.382]                       }
[16:17:49.382]                       else if (inherits(cond, "condition")) {
[16:17:49.382]                         if (!is.null(pattern)) {
[16:17:49.382]                           computeRestarts <- base::computeRestarts
[16:17:49.382]                           grepl <- base::grepl
[16:17:49.382]                           restarts <- computeRestarts(cond)
[16:17:49.382]                           for (restart in restarts) {
[16:17:49.382]                             name <- restart$name
[16:17:49.382]                             if (is.null(name)) 
[16:17:49.382]                               next
[16:17:49.382]                             if (!grepl(pattern, name)) 
[16:17:49.382]                               next
[16:17:49.382]                             invokeRestart(restart)
[16:17:49.382]                             muffled <- TRUE
[16:17:49.382]                             break
[16:17:49.382]                           }
[16:17:49.382]                         }
[16:17:49.382]                       }
[16:17:49.382]                       invisible(muffled)
[16:17:49.382]                     }
[16:17:49.382]                     muffleCondition(cond, pattern = "^muffle")
[16:17:49.382]                   }
[16:17:49.382]                 }
[16:17:49.382]             }
[16:17:49.382]         }))
[16:17:49.382]     }, error = function(ex) {
[16:17:49.382]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:49.382]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:49.382]                 ...future.rng), started = ...future.startTime, 
[16:17:49.382]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:49.382]             version = "1.8"), class = "FutureResult")
[16:17:49.382]     }, finally = {
[16:17:49.382]         if (!identical(...future.workdir, getwd())) 
[16:17:49.382]             setwd(...future.workdir)
[16:17:49.382]         {
[16:17:49.382]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:49.382]                 ...future.oldOptions$nwarnings <- NULL
[16:17:49.382]             }
[16:17:49.382]             base::options(...future.oldOptions)
[16:17:49.382]             if (.Platform$OS.type == "windows") {
[16:17:49.382]                 old_names <- names(...future.oldEnvVars)
[16:17:49.382]                 envs <- base::Sys.getenv()
[16:17:49.382]                 names <- names(envs)
[16:17:49.382]                 common <- intersect(names, old_names)
[16:17:49.382]                 added <- setdiff(names, old_names)
[16:17:49.382]                 removed <- setdiff(old_names, names)
[16:17:49.382]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:49.382]                   envs[common]]
[16:17:49.382]                 NAMES <- toupper(changed)
[16:17:49.382]                 args <- list()
[16:17:49.382]                 for (kk in seq_along(NAMES)) {
[16:17:49.382]                   name <- changed[[kk]]
[16:17:49.382]                   NAME <- NAMES[[kk]]
[16:17:49.382]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.382]                     next
[16:17:49.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:49.382]                 }
[16:17:49.382]                 NAMES <- toupper(added)
[16:17:49.382]                 for (kk in seq_along(NAMES)) {
[16:17:49.382]                   name <- added[[kk]]
[16:17:49.382]                   NAME <- NAMES[[kk]]
[16:17:49.382]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.382]                     next
[16:17:49.382]                   args[[name]] <- ""
[16:17:49.382]                 }
[16:17:49.382]                 NAMES <- toupper(removed)
[16:17:49.382]                 for (kk in seq_along(NAMES)) {
[16:17:49.382]                   name <- removed[[kk]]
[16:17:49.382]                   NAME <- NAMES[[kk]]
[16:17:49.382]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.382]                     next
[16:17:49.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:49.382]                 }
[16:17:49.382]                 if (length(args) > 0) 
[16:17:49.382]                   base::do.call(base::Sys.setenv, args = args)
[16:17:49.382]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:49.382]             }
[16:17:49.382]             else {
[16:17:49.382]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:49.382]             }
[16:17:49.382]             {
[16:17:49.382]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:49.382]                   0L) {
[16:17:49.382]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:49.382]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:49.382]                   base::options(opts)
[16:17:49.382]                 }
[16:17:49.382]                 {
[16:17:49.382]                   {
[16:17:49.382]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:49.382]                     NULL
[16:17:49.382]                   }
[16:17:49.382]                   options(future.plan = NULL)
[16:17:49.382]                   if (is.na(NA_character_)) 
[16:17:49.382]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:49.382]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:49.382]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:49.382]                     .init = FALSE)
[16:17:49.382]                 }
[16:17:49.382]             }
[16:17:49.382]         }
[16:17:49.382]     })
[16:17:49.382]     if (TRUE) {
[16:17:49.382]         base::sink(type = "output", split = FALSE)
[16:17:49.382]         if (TRUE) {
[16:17:49.382]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:49.382]         }
[16:17:49.382]         else {
[16:17:49.382]             ...future.result["stdout"] <- base::list(NULL)
[16:17:49.382]         }
[16:17:49.382]         base::close(...future.stdout)
[16:17:49.382]         ...future.stdout <- NULL
[16:17:49.382]     }
[16:17:49.382]     ...future.result$conditions <- ...future.conditions
[16:17:49.382]     ...future.result$finished <- base::Sys.time()
[16:17:49.382]     ...future.result
[16:17:49.382] }
[16:17:49.384] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[16:17:49.384] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[16:17:49.385] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[16:17:49.385] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:17:49.385] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:17:49.386] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[16:17:49.386] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[16:17:49.386] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:17:49.387] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:17:49.387] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:17:49.387] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:17:49.387] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[16:17:49.388] MultisessionFuture started
[16:17:49.388] - Launch lazy future ... done
[16:17:49.388] run() for ‘MultisessionFuture’ ... done
[16:17:49.388] Created future:
[16:17:49.388] MultisessionFuture:
[16:17:49.388] Label: ‘future_by-1’
[16:17:49.388] Expression:
[16:17:49.388] {
[16:17:49.388]     do.call(function(...) {
[16:17:49.388]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.388]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:49.388]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.388]             on.exit(options(oopts), add = TRUE)
[16:17:49.388]         }
[16:17:49.388]         {
[16:17:49.388]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:49.388]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.388]                 ...future.FUN(...future.X_jj, ...)
[16:17:49.388]             })
[16:17:49.388]         }
[16:17:49.388]     }, args = future.call.arguments)
[16:17:49.388] }
[16:17:49.388] Lazy evaluation: FALSE
[16:17:49.388] Asynchronous evaluation: TRUE
[16:17:49.388] Local evaluation: TRUE
[16:17:49.388] Environment: 0x55b5693011f0
[16:17:49.388] Capture standard output: TRUE
[16:17:49.388] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:49.388] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:49.388] Packages: <none>
[16:17:49.388] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:49.388] Resolved: FALSE
[16:17:49.388] Value: <not collected>
[16:17:49.388] Conditions captured: <none>
[16:17:49.388] Early signaling: FALSE
[16:17:49.388] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:49.388] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:49.400] Chunk #1 of 2 ... DONE
[16:17:49.400] Chunk #2 of 2 ...
[16:17:49.400]  - Finding globals in 'X' for chunk #2 ...
[16:17:49.400] getGlobalsAndPackages() ...
[16:17:49.400] Searching for globals...
[16:17:49.401] 
[16:17:49.401] Searching for globals ... DONE
[16:17:49.401] - globals: [0] <none>
[16:17:49.401] getGlobalsAndPackages() ... DONE
[16:17:49.401]    + additional globals found: [n=0] 
[16:17:49.401]    + additional namespaces needed: [n=0] 
[16:17:49.401]  - Finding globals in 'X' for chunk #2 ... DONE
[16:17:49.402]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:49.402]  - seeds: <none>
[16:17:49.402]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.402] getGlobalsAndPackages() ...
[16:17:49.402] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.402] Resolving globals: FALSE
[16:17:49.402] Tweak future expression to call with '...' arguments ...
[16:17:49.402] {
[16:17:49.402]     do.call(function(...) {
[16:17:49.402]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.402]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:49.402]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.402]             on.exit(options(oopts), add = TRUE)
[16:17:49.402]         }
[16:17:49.402]         {
[16:17:49.402]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:49.402]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.402]                 ...future.FUN(...future.X_jj, ...)
[16:17:49.402]             })
[16:17:49.402]         }
[16:17:49.402]     }, args = future.call.arguments)
[16:17:49.402] }
[16:17:49.403] Tweak future expression to call with '...' arguments ... DONE
[16:17:49.403] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.403] 
[16:17:49.403] getGlobalsAndPackages() ... DONE
[16:17:49.403] run() for ‘Future’ ...
[16:17:49.403] - state: ‘created’
[16:17:49.404] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:49.418] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:49.418] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:49.418]   - Field: ‘node’
[16:17:49.418]   - Field: ‘label’
[16:17:49.418]   - Field: ‘local’
[16:17:49.418]   - Field: ‘owner’
[16:17:49.418]   - Field: ‘envir’
[16:17:49.419]   - Field: ‘workers’
[16:17:49.419]   - Field: ‘packages’
[16:17:49.419]   - Field: ‘gc’
[16:17:49.419]   - Field: ‘conditions’
[16:17:49.419]   - Field: ‘persistent’
[16:17:49.419]   - Field: ‘expr’
[16:17:49.419]   - Field: ‘uuid’
[16:17:49.419]   - Field: ‘seed’
[16:17:49.419]   - Field: ‘version’
[16:17:49.419]   - Field: ‘result’
[16:17:49.419]   - Field: ‘asynchronous’
[16:17:49.420]   - Field: ‘calls’
[16:17:49.420]   - Field: ‘globals’
[16:17:49.420]   - Field: ‘stdout’
[16:17:49.420]   - Field: ‘earlySignal’
[16:17:49.420]   - Field: ‘lazy’
[16:17:49.420]   - Field: ‘state’
[16:17:49.420] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:49.420] - Launch lazy future ...
[16:17:49.421] Packages needed by the future expression (n = 0): <none>
[16:17:49.421] Packages needed by future strategies (n = 0): <none>
[16:17:49.421] {
[16:17:49.421]     {
[16:17:49.421]         {
[16:17:49.421]             ...future.startTime <- base::Sys.time()
[16:17:49.421]             {
[16:17:49.421]                 {
[16:17:49.421]                   {
[16:17:49.421]                     {
[16:17:49.421]                       base::local({
[16:17:49.421]                         has_future <- base::requireNamespace("future", 
[16:17:49.421]                           quietly = TRUE)
[16:17:49.421]                         if (has_future) {
[16:17:49.421]                           ns <- base::getNamespace("future")
[16:17:49.421]                           version <- ns[[".package"]][["version"]]
[16:17:49.421]                           if (is.null(version)) 
[16:17:49.421]                             version <- utils::packageVersion("future")
[16:17:49.421]                         }
[16:17:49.421]                         else {
[16:17:49.421]                           version <- NULL
[16:17:49.421]                         }
[16:17:49.421]                         if (!has_future || version < "1.8.0") {
[16:17:49.421]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:49.421]                             "", base::R.version$version.string), 
[16:17:49.421]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:49.421]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:49.421]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:49.421]                               "release", "version")], collapse = " "), 
[16:17:49.421]                             hostname = base::Sys.info()[["nodename"]])
[16:17:49.421]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:49.421]                             info)
[16:17:49.421]                           info <- base::paste(info, collapse = "; ")
[16:17:49.421]                           if (!has_future) {
[16:17:49.421]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:49.421]                               info)
[16:17:49.421]                           }
[16:17:49.421]                           else {
[16:17:49.421]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:49.421]                               info, version)
[16:17:49.421]                           }
[16:17:49.421]                           base::stop(msg)
[16:17:49.421]                         }
[16:17:49.421]                       })
[16:17:49.421]                     }
[16:17:49.421]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:49.421]                     base::options(mc.cores = 1L)
[16:17:49.421]                   }
[16:17:49.421]                   ...future.strategy.old <- future::plan("list")
[16:17:49.421]                   options(future.plan = NULL)
[16:17:49.421]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:49.421]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:49.421]                 }
[16:17:49.421]                 ...future.workdir <- getwd()
[16:17:49.421]             }
[16:17:49.421]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:49.421]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:49.421]         }
[16:17:49.421]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:49.421]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:49.421]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:49.421]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:49.421]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:49.421]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:49.421]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:49.421]             base::names(...future.oldOptions))
[16:17:49.421]     }
[16:17:49.421]     if (FALSE) {
[16:17:49.421]     }
[16:17:49.421]     else {
[16:17:49.421]         if (TRUE) {
[16:17:49.421]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:49.421]                 open = "w")
[16:17:49.421]         }
[16:17:49.421]         else {
[16:17:49.421]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:49.421]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:49.421]         }
[16:17:49.421]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:49.421]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:49.421]             base::sink(type = "output", split = FALSE)
[16:17:49.421]             base::close(...future.stdout)
[16:17:49.421]         }, add = TRUE)
[16:17:49.421]     }
[16:17:49.421]     ...future.frame <- base::sys.nframe()
[16:17:49.421]     ...future.conditions <- base::list()
[16:17:49.421]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:49.421]     if (FALSE) {
[16:17:49.421]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:49.421]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:49.421]     }
[16:17:49.421]     ...future.result <- base::tryCatch({
[16:17:49.421]         base::withCallingHandlers({
[16:17:49.421]             ...future.value <- base::withVisible(base::local({
[16:17:49.421]                 ...future.makeSendCondition <- base::local({
[16:17:49.421]                   sendCondition <- NULL
[16:17:49.421]                   function(frame = 1L) {
[16:17:49.421]                     if (is.function(sendCondition)) 
[16:17:49.421]                       return(sendCondition)
[16:17:49.421]                     ns <- getNamespace("parallel")
[16:17:49.421]                     if (exists("sendData", mode = "function", 
[16:17:49.421]                       envir = ns)) {
[16:17:49.421]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:49.421]                         envir = ns)
[16:17:49.421]                       envir <- sys.frame(frame)
[16:17:49.421]                       master <- NULL
[16:17:49.421]                       while (!identical(envir, .GlobalEnv) && 
[16:17:49.421]                         !identical(envir, emptyenv())) {
[16:17:49.421]                         if (exists("master", mode = "list", envir = envir, 
[16:17:49.421]                           inherits = FALSE)) {
[16:17:49.421]                           master <- get("master", mode = "list", 
[16:17:49.421]                             envir = envir, inherits = FALSE)
[16:17:49.421]                           if (inherits(master, c("SOCKnode", 
[16:17:49.421]                             "SOCK0node"))) {
[16:17:49.421]                             sendCondition <<- function(cond) {
[16:17:49.421]                               data <- list(type = "VALUE", value = cond, 
[16:17:49.421]                                 success = TRUE)
[16:17:49.421]                               parallel_sendData(master, data)
[16:17:49.421]                             }
[16:17:49.421]                             return(sendCondition)
[16:17:49.421]                           }
[16:17:49.421]                         }
[16:17:49.421]                         frame <- frame + 1L
[16:17:49.421]                         envir <- sys.frame(frame)
[16:17:49.421]                       }
[16:17:49.421]                     }
[16:17:49.421]                     sendCondition <<- function(cond) NULL
[16:17:49.421]                   }
[16:17:49.421]                 })
[16:17:49.421]                 withCallingHandlers({
[16:17:49.421]                   {
[16:17:49.421]                     do.call(function(...) {
[16:17:49.421]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.421]                       if (!identical(...future.globals.maxSize.org, 
[16:17:49.421]                         ...future.globals.maxSize)) {
[16:17:49.421]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.421]                         on.exit(options(oopts), add = TRUE)
[16:17:49.421]                       }
[16:17:49.421]                       {
[16:17:49.421]                         lapply(seq_along(...future.elements_ii), 
[16:17:49.421]                           FUN = function(jj) {
[16:17:49.421]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.421]                             ...future.FUN(...future.X_jj, ...)
[16:17:49.421]                           })
[16:17:49.421]                       }
[16:17:49.421]                     }, args = future.call.arguments)
[16:17:49.421]                   }
[16:17:49.421]                 }, immediateCondition = function(cond) {
[16:17:49.421]                   sendCondition <- ...future.makeSendCondition()
[16:17:49.421]                   sendCondition(cond)
[16:17:49.421]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.421]                   {
[16:17:49.421]                     inherits <- base::inherits
[16:17:49.421]                     invokeRestart <- base::invokeRestart
[16:17:49.421]                     is.null <- base::is.null
[16:17:49.421]                     muffled <- FALSE
[16:17:49.421]                     if (inherits(cond, "message")) {
[16:17:49.421]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:49.421]                       if (muffled) 
[16:17:49.421]                         invokeRestart("muffleMessage")
[16:17:49.421]                     }
[16:17:49.421]                     else if (inherits(cond, "warning")) {
[16:17:49.421]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:49.421]                       if (muffled) 
[16:17:49.421]                         invokeRestart("muffleWarning")
[16:17:49.421]                     }
[16:17:49.421]                     else if (inherits(cond, "condition")) {
[16:17:49.421]                       if (!is.null(pattern)) {
[16:17:49.421]                         computeRestarts <- base::computeRestarts
[16:17:49.421]                         grepl <- base::grepl
[16:17:49.421]                         restarts <- computeRestarts(cond)
[16:17:49.421]                         for (restart in restarts) {
[16:17:49.421]                           name <- restart$name
[16:17:49.421]                           if (is.null(name)) 
[16:17:49.421]                             next
[16:17:49.421]                           if (!grepl(pattern, name)) 
[16:17:49.421]                             next
[16:17:49.421]                           invokeRestart(restart)
[16:17:49.421]                           muffled <- TRUE
[16:17:49.421]                           break
[16:17:49.421]                         }
[16:17:49.421]                       }
[16:17:49.421]                     }
[16:17:49.421]                     invisible(muffled)
[16:17:49.421]                   }
[16:17:49.421]                   muffleCondition(cond)
[16:17:49.421]                 })
[16:17:49.421]             }))
[16:17:49.421]             future::FutureResult(value = ...future.value$value, 
[16:17:49.421]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:49.421]                   ...future.rng), globalenv = if (FALSE) 
[16:17:49.421]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:49.421]                     ...future.globalenv.names))
[16:17:49.421]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:49.421]         }, condition = base::local({
[16:17:49.421]             c <- base::c
[16:17:49.421]             inherits <- base::inherits
[16:17:49.421]             invokeRestart <- base::invokeRestart
[16:17:49.421]             length <- base::length
[16:17:49.421]             list <- base::list
[16:17:49.421]             seq.int <- base::seq.int
[16:17:49.421]             signalCondition <- base::signalCondition
[16:17:49.421]             sys.calls <- base::sys.calls
[16:17:49.421]             `[[` <- base::`[[`
[16:17:49.421]             `+` <- base::`+`
[16:17:49.421]             `<<-` <- base::`<<-`
[16:17:49.421]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:49.421]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:49.421]                   3L)]
[16:17:49.421]             }
[16:17:49.421]             function(cond) {
[16:17:49.421]                 is_error <- inherits(cond, "error")
[16:17:49.421]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:49.421]                   NULL)
[16:17:49.421]                 if (is_error) {
[16:17:49.421]                   sessionInformation <- function() {
[16:17:49.421]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:49.421]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:49.421]                       search = base::search(), system = base::Sys.info())
[16:17:49.421]                   }
[16:17:49.421]                   ...future.conditions[[length(...future.conditions) + 
[16:17:49.421]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:49.421]                     cond$call), session = sessionInformation(), 
[16:17:49.421]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:49.421]                   signalCondition(cond)
[16:17:49.421]                 }
[16:17:49.421]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:49.421]                 "immediateCondition"))) {
[16:17:49.421]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:49.421]                   ...future.conditions[[length(...future.conditions) + 
[16:17:49.421]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:49.421]                   if (TRUE && !signal) {
[16:17:49.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.421]                     {
[16:17:49.421]                       inherits <- base::inherits
[16:17:49.421]                       invokeRestart <- base::invokeRestart
[16:17:49.421]                       is.null <- base::is.null
[16:17:49.421]                       muffled <- FALSE
[16:17:49.421]                       if (inherits(cond, "message")) {
[16:17:49.421]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:49.421]                         if (muffled) 
[16:17:49.421]                           invokeRestart("muffleMessage")
[16:17:49.421]                       }
[16:17:49.421]                       else if (inherits(cond, "warning")) {
[16:17:49.421]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:49.421]                         if (muffled) 
[16:17:49.421]                           invokeRestart("muffleWarning")
[16:17:49.421]                       }
[16:17:49.421]                       else if (inherits(cond, "condition")) {
[16:17:49.421]                         if (!is.null(pattern)) {
[16:17:49.421]                           computeRestarts <- base::computeRestarts
[16:17:49.421]                           grepl <- base::grepl
[16:17:49.421]                           restarts <- computeRestarts(cond)
[16:17:49.421]                           for (restart in restarts) {
[16:17:49.421]                             name <- restart$name
[16:17:49.421]                             if (is.null(name)) 
[16:17:49.421]                               next
[16:17:49.421]                             if (!grepl(pattern, name)) 
[16:17:49.421]                               next
[16:17:49.421]                             invokeRestart(restart)
[16:17:49.421]                             muffled <- TRUE
[16:17:49.421]                             break
[16:17:49.421]                           }
[16:17:49.421]                         }
[16:17:49.421]                       }
[16:17:49.421]                       invisible(muffled)
[16:17:49.421]                     }
[16:17:49.421]                     muffleCondition(cond, pattern = "^muffle")
[16:17:49.421]                   }
[16:17:49.421]                 }
[16:17:49.421]                 else {
[16:17:49.421]                   if (TRUE) {
[16:17:49.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.421]                     {
[16:17:49.421]                       inherits <- base::inherits
[16:17:49.421]                       invokeRestart <- base::invokeRestart
[16:17:49.421]                       is.null <- base::is.null
[16:17:49.421]                       muffled <- FALSE
[16:17:49.421]                       if (inherits(cond, "message")) {
[16:17:49.421]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:49.421]                         if (muffled) 
[16:17:49.421]                           invokeRestart("muffleMessage")
[16:17:49.421]                       }
[16:17:49.421]                       else if (inherits(cond, "warning")) {
[16:17:49.421]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:49.421]                         if (muffled) 
[16:17:49.421]                           invokeRestart("muffleWarning")
[16:17:49.421]                       }
[16:17:49.421]                       else if (inherits(cond, "condition")) {
[16:17:49.421]                         if (!is.null(pattern)) {
[16:17:49.421]                           computeRestarts <- base::computeRestarts
[16:17:49.421]                           grepl <- base::grepl
[16:17:49.421]                           restarts <- computeRestarts(cond)
[16:17:49.421]                           for (restart in restarts) {
[16:17:49.421]                             name <- restart$name
[16:17:49.421]                             if (is.null(name)) 
[16:17:49.421]                               next
[16:17:49.421]                             if (!grepl(pattern, name)) 
[16:17:49.421]                               next
[16:17:49.421]                             invokeRestart(restart)
[16:17:49.421]                             muffled <- TRUE
[16:17:49.421]                             break
[16:17:49.421]                           }
[16:17:49.421]                         }
[16:17:49.421]                       }
[16:17:49.421]                       invisible(muffled)
[16:17:49.421]                     }
[16:17:49.421]                     muffleCondition(cond, pattern = "^muffle")
[16:17:49.421]                   }
[16:17:49.421]                 }
[16:17:49.421]             }
[16:17:49.421]         }))
[16:17:49.421]     }, error = function(ex) {
[16:17:49.421]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:49.421]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:49.421]                 ...future.rng), started = ...future.startTime, 
[16:17:49.421]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:49.421]             version = "1.8"), class = "FutureResult")
[16:17:49.421]     }, finally = {
[16:17:49.421]         if (!identical(...future.workdir, getwd())) 
[16:17:49.421]             setwd(...future.workdir)
[16:17:49.421]         {
[16:17:49.421]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:49.421]                 ...future.oldOptions$nwarnings <- NULL
[16:17:49.421]             }
[16:17:49.421]             base::options(...future.oldOptions)
[16:17:49.421]             if (.Platform$OS.type == "windows") {
[16:17:49.421]                 old_names <- names(...future.oldEnvVars)
[16:17:49.421]                 envs <- base::Sys.getenv()
[16:17:49.421]                 names <- names(envs)
[16:17:49.421]                 common <- intersect(names, old_names)
[16:17:49.421]                 added <- setdiff(names, old_names)
[16:17:49.421]                 removed <- setdiff(old_names, names)
[16:17:49.421]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:49.421]                   envs[common]]
[16:17:49.421]                 NAMES <- toupper(changed)
[16:17:49.421]                 args <- list()
[16:17:49.421]                 for (kk in seq_along(NAMES)) {
[16:17:49.421]                   name <- changed[[kk]]
[16:17:49.421]                   NAME <- NAMES[[kk]]
[16:17:49.421]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.421]                     next
[16:17:49.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:49.421]                 }
[16:17:49.421]                 NAMES <- toupper(added)
[16:17:49.421]                 for (kk in seq_along(NAMES)) {
[16:17:49.421]                   name <- added[[kk]]
[16:17:49.421]                   NAME <- NAMES[[kk]]
[16:17:49.421]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.421]                     next
[16:17:49.421]                   args[[name]] <- ""
[16:17:49.421]                 }
[16:17:49.421]                 NAMES <- toupper(removed)
[16:17:49.421]                 for (kk in seq_along(NAMES)) {
[16:17:49.421]                   name <- removed[[kk]]
[16:17:49.421]                   NAME <- NAMES[[kk]]
[16:17:49.421]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.421]                     next
[16:17:49.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:49.421]                 }
[16:17:49.421]                 if (length(args) > 0) 
[16:17:49.421]                   base::do.call(base::Sys.setenv, args = args)
[16:17:49.421]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:49.421]             }
[16:17:49.421]             else {
[16:17:49.421]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:49.421]             }
[16:17:49.421]             {
[16:17:49.421]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:49.421]                   0L) {
[16:17:49.421]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:49.421]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:49.421]                   base::options(opts)
[16:17:49.421]                 }
[16:17:49.421]                 {
[16:17:49.421]                   {
[16:17:49.421]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:49.421]                     NULL
[16:17:49.421]                   }
[16:17:49.421]                   options(future.plan = NULL)
[16:17:49.421]                   if (is.na(NA_character_)) 
[16:17:49.421]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:49.421]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:49.421]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:49.421]                     .init = FALSE)
[16:17:49.421]                 }
[16:17:49.421]             }
[16:17:49.421]         }
[16:17:49.421]     })
[16:17:49.421]     if (TRUE) {
[16:17:49.421]         base::sink(type = "output", split = FALSE)
[16:17:49.421]         if (TRUE) {
[16:17:49.421]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:49.421]         }
[16:17:49.421]         else {
[16:17:49.421]             ...future.result["stdout"] <- base::list(NULL)
[16:17:49.421]         }
[16:17:49.421]         base::close(...future.stdout)
[16:17:49.421]         ...future.stdout <- NULL
[16:17:49.421]     }
[16:17:49.421]     ...future.result$conditions <- ...future.conditions
[16:17:49.421]     ...future.result$finished <- base::Sys.time()
[16:17:49.421]     ...future.result
[16:17:49.421] }
[16:17:49.424] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[16:17:49.424] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[16:17:49.424] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[16:17:49.425] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:17:49.425] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:17:49.425] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[16:17:49.426] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[16:17:49.426] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:17:49.426] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:17:49.426] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:17:49.426] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:17:49.427] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[16:17:49.427] MultisessionFuture started
[16:17:49.427] - Launch lazy future ... done
[16:17:49.427] run() for ‘MultisessionFuture’ ... done
[16:17:49.427] Created future:
[16:17:49.427] MultisessionFuture:
[16:17:49.427] Label: ‘future_by-2’
[16:17:49.427] Expression:
[16:17:49.427] {
[16:17:49.427]     do.call(function(...) {
[16:17:49.427]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.427]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:49.427]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.427]             on.exit(options(oopts), add = TRUE)
[16:17:49.427]         }
[16:17:49.427]         {
[16:17:49.427]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:49.427]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.427]                 ...future.FUN(...future.X_jj, ...)
[16:17:49.427]             })
[16:17:49.427]         }
[16:17:49.427]     }, args = future.call.arguments)
[16:17:49.427] }
[16:17:49.427] Lazy evaluation: FALSE
[16:17:49.427] Asynchronous evaluation: TRUE
[16:17:49.427] Local evaluation: TRUE
[16:17:49.427] Environment: 0x55b5693011f0
[16:17:49.427] Capture standard output: TRUE
[16:17:49.427] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:49.427] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:49.427] Packages: <none>
[16:17:49.427] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:49.427] Resolved: FALSE
[16:17:49.427] Value: <not collected>
[16:17:49.427] Conditions captured: <none>
[16:17:49.427] Early signaling: FALSE
[16:17:49.427] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:49.427] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:49.439] Chunk #2 of 2 ... DONE
[16:17:49.440] Launching 2 futures (chunks) ... DONE
[16:17:49.440] Resolving 2 futures (chunks) ...
[16:17:49.440] resolve() on list ...
[16:17:49.440]  recursive: 0
[16:17:49.440]  length: 2
[16:17:49.440] 
[16:17:49.441] receiveMessageFromWorker() for ClusterFuture ...
[16:17:49.443] - Validating connection of MultisessionFuture
[16:17:49.443] - received message: FutureResult
[16:17:49.443] - Received FutureResult
[16:17:49.443] - Erased future from FutureRegistry
[16:17:49.443] result() for ClusterFuture ...
[16:17:49.443] - result already collected: FutureResult
[16:17:49.444] result() for ClusterFuture ... done
[16:17:49.444] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:49.444] Future #1
[16:17:49.444] result() for ClusterFuture ...
[16:17:49.444] - result already collected: FutureResult
[16:17:49.444] result() for ClusterFuture ... done
[16:17:49.444] result() for ClusterFuture ...
[16:17:49.444] - result already collected: FutureResult
[16:17:49.444] result() for ClusterFuture ... done
[16:17:49.444] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:17:49.444] - nx: 2
[16:17:49.445] - relay: TRUE
[16:17:49.445] - stdout: TRUE
[16:17:49.445] - signal: TRUE
[16:17:49.445] - resignal: FALSE
[16:17:49.445] - force: TRUE
[16:17:49.445] - relayed: [n=2] FALSE, FALSE
[16:17:49.445] - queued futures: [n=2] FALSE, FALSE
[16:17:49.445]  - until=1
[16:17:49.445]  - relaying element #1
[16:17:49.445] result() for ClusterFuture ...
[16:17:49.445] - result already collected: FutureResult
[16:17:49.445] result() for ClusterFuture ... done
[16:17:49.446] result() for ClusterFuture ...
[16:17:49.446] - result already collected: FutureResult
[16:17:49.446] result() for ClusterFuture ... done
[16:17:49.446] result() for ClusterFuture ...
[16:17:49.446] - result already collected: FutureResult
[16:17:49.446] result() for ClusterFuture ... done
[16:17:49.446] result() for ClusterFuture ...
[16:17:49.446] - result already collected: FutureResult
[16:17:49.446] result() for ClusterFuture ... done
[16:17:49.446] - relayed: [n=2] TRUE, FALSE
[16:17:49.446] - queued futures: [n=2] TRUE, FALSE
[16:17:49.447] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:17:49.447]  length: 1 (resolved future 1)
[16:17:49.471] receiveMessageFromWorker() for ClusterFuture ...
[16:17:49.471] - Validating connection of MultisessionFuture
[16:17:49.471] - received message: FutureResult
[16:17:49.471] - Received FutureResult
[16:17:49.471] - Erased future from FutureRegistry
[16:17:49.472] result() for ClusterFuture ...
[16:17:49.472] - result already collected: FutureResult
[16:17:49.472] result() for ClusterFuture ... done
[16:17:49.472] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:49.472] Future #2
[16:17:49.472] result() for ClusterFuture ...
[16:17:49.472] - result already collected: FutureResult
[16:17:49.472] result() for ClusterFuture ... done
[16:17:49.472] result() for ClusterFuture ...
[16:17:49.472] - result already collected: FutureResult
[16:17:49.472] result() for ClusterFuture ... done
[16:17:49.473] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:17:49.473] - nx: 2
[16:17:49.473] - relay: TRUE
[16:17:49.473] - stdout: TRUE
[16:17:49.473] - signal: TRUE
[16:17:49.473] - resignal: FALSE
[16:17:49.473] - force: TRUE
[16:17:49.473] - relayed: [n=2] TRUE, FALSE
[16:17:49.473] - queued futures: [n=2] TRUE, FALSE
[16:17:49.473]  - until=2
[16:17:49.473]  - relaying element #2
[16:17:49.473] result() for ClusterFuture ...
[16:17:49.474] - result already collected: FutureResult
[16:17:49.474] result() for ClusterFuture ... done
[16:17:49.474] result() for ClusterFuture ...
[16:17:49.474] - result already collected: FutureResult
[16:17:49.474] result() for ClusterFuture ... done
[16:17:49.474] result() for ClusterFuture ...
[16:17:49.474] - result already collected: FutureResult
[16:17:49.474] result() for ClusterFuture ... done
[16:17:49.474] result() for ClusterFuture ...
[16:17:49.474] - result already collected: FutureResult
[16:17:49.474] result() for ClusterFuture ... done
[16:17:49.474] - relayed: [n=2] TRUE, TRUE
[16:17:49.475] - queued futures: [n=2] TRUE, TRUE
[16:17:49.475] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:17:49.475]  length: 0 (resolved future 2)
[16:17:49.475] Relaying remaining futures
[16:17:49.475] signalConditionsASAP(NULL, pos=0) ...
[16:17:49.475] - nx: 2
[16:17:49.475] - relay: TRUE
[16:17:49.475] - stdout: TRUE
[16:17:49.475] - signal: TRUE
[16:17:49.475] - resignal: FALSE
[16:17:49.475] - force: TRUE
[16:17:49.475] - relayed: [n=2] TRUE, TRUE
[16:17:49.476] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:49.476] - relayed: [n=2] TRUE, TRUE
[16:17:49.476] - queued futures: [n=2] TRUE, TRUE
[16:17:49.476] signalConditionsASAP(NULL, pos=0) ... done
[16:17:49.476] resolve() on list ... DONE
[16:17:49.476] result() for ClusterFuture ...
[16:17:49.476] - result already collected: FutureResult
[16:17:49.476] result() for ClusterFuture ... done
[16:17:49.476] result() for ClusterFuture ...
[16:17:49.476] - result already collected: FutureResult
[16:17:49.476] result() for ClusterFuture ... done
[16:17:49.477] result() for ClusterFuture ...
[16:17:49.477] - result already collected: FutureResult
[16:17:49.477] result() for ClusterFuture ... done
[16:17:49.477] result() for ClusterFuture ...
[16:17:49.477] - result already collected: FutureResult
[16:17:49.477] result() for ClusterFuture ... done
[16:17:49.477]  - Number of value chunks collected: 2
[16:17:49.477] Resolving 2 futures (chunks) ... DONE
[16:17:49.477] Reducing values from 2 chunks ...
[16:17:49.477]  - Number of values collected after concatenation: 3
[16:17:49.477]  - Number of values expected: 3
[16:17:49.477] Reducing values from 2 chunks ... DONE
[16:17:49.478] future_lapply() ... DONE
[16:17:49.478] future_by_internal() ... DONE
[16:17:49.478] future_by_internal() ...
Warning: Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[16:17:49.479] future_lapply() ...
[16:17:49.483] Number of chunks: 2
[16:17:49.483] getGlobalsAndPackagesXApply() ...
[16:17:49.483]  - future.globals: TRUE
[16:17:49.483] getGlobalsAndPackages() ...
[16:17:49.483] Searching for globals...
[16:17:49.484] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:49.484] Searching for globals ... DONE
[16:17:49.485] Resolving globals: FALSE
[16:17:49.485] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:49.485] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:49.485] - globals: [1] ‘FUN’
[16:17:49.485] 
[16:17:49.485] getGlobalsAndPackages() ... DONE
[16:17:49.486]  - globals found/used: [n=1] ‘FUN’
[16:17:49.486]  - needed namespaces: [n=0] 
[16:17:49.486] Finding globals ... DONE
[16:17:49.486]  - use_args: TRUE
[16:17:49.486]  - Getting '...' globals ...
[16:17:49.486] resolve() on list ...
[16:17:49.486]  recursive: 0
[16:17:49.486]  length: 1
[16:17:49.486]  elements: ‘...’
[16:17:49.487]  length: 0 (resolved future 1)
[16:17:49.487] resolve() on list ... DONE
[16:17:49.487]    - '...' content: [n=0] 
[16:17:49.487] List of 1
[16:17:49.487]  $ ...: list()
[16:17:49.487]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:49.487]  - attr(*, "where")=List of 1
[16:17:49.487]   ..$ ...:<environment: 0x55b569baf108> 
[16:17:49.487]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:49.487]  - attr(*, "resolved")= logi TRUE
[16:17:49.487]  - attr(*, "total_size")= num NA
[16:17:49.489]  - Getting '...' globals ... DONE
[16:17:49.490] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:49.490] List of 2
[16:17:49.490]  $ ...future.FUN:function (object, ...)  
[16:17:49.490]  $ ...          : list()
[16:17:49.490]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:49.490]  - attr(*, "where")=List of 2
[16:17:49.490]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:49.490]   ..$ ...          :<environment: 0x55b569baf108> 
[16:17:49.490]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:49.490]  - attr(*, "resolved")= logi FALSE
[16:17:49.490]  - attr(*, "total_size")= num 1240
[16:17:49.492] Packages to be attached in all futures: [n=0] 
[16:17:49.492] getGlobalsAndPackagesXApply() ... DONE
[16:17:49.492] Number of futures (= number of chunks): 2
[16:17:49.493] Launching 2 futures (chunks) ...
[16:17:49.493] Chunk #1 of 2 ...
[16:17:49.493]  - Finding globals in 'X' for chunk #1 ...
[16:17:49.493] getGlobalsAndPackages() ...
[16:17:49.493] Searching for globals...
[16:17:49.493] 
[16:17:49.493] Searching for globals ... DONE
[16:17:49.493] - globals: [0] <none>
[16:17:49.494] getGlobalsAndPackages() ... DONE
[16:17:49.494]    + additional globals found: [n=0] 
[16:17:49.494]    + additional namespaces needed: [n=0] 
[16:17:49.494]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:49.494]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:49.494]  - seeds: <none>
[16:17:49.494]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.494] getGlobalsAndPackages() ...
[16:17:49.494] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.494] Resolving globals: FALSE
[16:17:49.494] Tweak future expression to call with '...' arguments ...
[16:17:49.495] {
[16:17:49.495]     do.call(function(...) {
[16:17:49.495]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.495]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:49.495]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.495]             on.exit(options(oopts), add = TRUE)
[16:17:49.495]         }
[16:17:49.495]         {
[16:17:49.495]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:49.495]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.495]                 ...future.FUN(...future.X_jj, ...)
[16:17:49.495]             })
[16:17:49.495]         }
[16:17:49.495]     }, args = future.call.arguments)
[16:17:49.495] }
[16:17:49.495] Tweak future expression to call with '...' arguments ... DONE
[16:17:49.495] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.495] 
[16:17:49.495] getGlobalsAndPackages() ... DONE
[16:17:49.496] run() for ‘Future’ ...
[16:17:49.496] - state: ‘created’
[16:17:49.496] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:49.509] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:49.509] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:49.509]   - Field: ‘node’
[16:17:49.510]   - Field: ‘label’
[16:17:49.510]   - Field: ‘local’
[16:17:49.510]   - Field: ‘owner’
[16:17:49.510]   - Field: ‘envir’
[16:17:49.510]   - Field: ‘workers’
[16:17:49.510]   - Field: ‘packages’
[16:17:49.510]   - Field: ‘gc’
[16:17:49.510]   - Field: ‘conditions’
[16:17:49.510]   - Field: ‘persistent’
[16:17:49.510]   - Field: ‘expr’
[16:17:49.510]   - Field: ‘uuid’
[16:17:49.511]   - Field: ‘seed’
[16:17:49.511]   - Field: ‘version’
[16:17:49.511]   - Field: ‘result’
[16:17:49.511]   - Field: ‘asynchronous’
[16:17:49.511]   - Field: ‘calls’
[16:17:49.511]   - Field: ‘globals’
[16:17:49.511]   - Field: ‘stdout’
[16:17:49.511]   - Field: ‘earlySignal’
[16:17:49.511]   - Field: ‘lazy’
[16:17:49.511]   - Field: ‘state’
[16:17:49.511] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:49.512] - Launch lazy future ...
[16:17:49.512] Packages needed by the future expression (n = 0): <none>
[16:17:49.512] Packages needed by future strategies (n = 0): <none>
[16:17:49.512] {
[16:17:49.512]     {
[16:17:49.512]         {
[16:17:49.512]             ...future.startTime <- base::Sys.time()
[16:17:49.512]             {
[16:17:49.512]                 {
[16:17:49.512]                   {
[16:17:49.512]                     {
[16:17:49.512]                       base::local({
[16:17:49.512]                         has_future <- base::requireNamespace("future", 
[16:17:49.512]                           quietly = TRUE)
[16:17:49.512]                         if (has_future) {
[16:17:49.512]                           ns <- base::getNamespace("future")
[16:17:49.512]                           version <- ns[[".package"]][["version"]]
[16:17:49.512]                           if (is.null(version)) 
[16:17:49.512]                             version <- utils::packageVersion("future")
[16:17:49.512]                         }
[16:17:49.512]                         else {
[16:17:49.512]                           version <- NULL
[16:17:49.512]                         }
[16:17:49.512]                         if (!has_future || version < "1.8.0") {
[16:17:49.512]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:49.512]                             "", base::R.version$version.string), 
[16:17:49.512]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:49.512]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:49.512]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:49.512]                               "release", "version")], collapse = " "), 
[16:17:49.512]                             hostname = base::Sys.info()[["nodename"]])
[16:17:49.512]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:49.512]                             info)
[16:17:49.512]                           info <- base::paste(info, collapse = "; ")
[16:17:49.512]                           if (!has_future) {
[16:17:49.512]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:49.512]                               info)
[16:17:49.512]                           }
[16:17:49.512]                           else {
[16:17:49.512]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:49.512]                               info, version)
[16:17:49.512]                           }
[16:17:49.512]                           base::stop(msg)
[16:17:49.512]                         }
[16:17:49.512]                       })
[16:17:49.512]                     }
[16:17:49.512]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:49.512]                     base::options(mc.cores = 1L)
[16:17:49.512]                   }
[16:17:49.512]                   ...future.strategy.old <- future::plan("list")
[16:17:49.512]                   options(future.plan = NULL)
[16:17:49.512]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:49.512]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:49.512]                 }
[16:17:49.512]                 ...future.workdir <- getwd()
[16:17:49.512]             }
[16:17:49.512]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:49.512]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:49.512]         }
[16:17:49.512]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:49.512]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:49.512]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:49.512]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:49.512]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:49.512]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:49.512]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:49.512]             base::names(...future.oldOptions))
[16:17:49.512]     }
[16:17:49.512]     if (FALSE) {
[16:17:49.512]     }
[16:17:49.512]     else {
[16:17:49.512]         if (TRUE) {
[16:17:49.512]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:49.512]                 open = "w")
[16:17:49.512]         }
[16:17:49.512]         else {
[16:17:49.512]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:49.512]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:49.512]         }
[16:17:49.512]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:49.512]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:49.512]             base::sink(type = "output", split = FALSE)
[16:17:49.512]             base::close(...future.stdout)
[16:17:49.512]         }, add = TRUE)
[16:17:49.512]     }
[16:17:49.512]     ...future.frame <- base::sys.nframe()
[16:17:49.512]     ...future.conditions <- base::list()
[16:17:49.512]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:49.512]     if (FALSE) {
[16:17:49.512]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:49.512]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:49.512]     }
[16:17:49.512]     ...future.result <- base::tryCatch({
[16:17:49.512]         base::withCallingHandlers({
[16:17:49.512]             ...future.value <- base::withVisible(base::local({
[16:17:49.512]                 ...future.makeSendCondition <- base::local({
[16:17:49.512]                   sendCondition <- NULL
[16:17:49.512]                   function(frame = 1L) {
[16:17:49.512]                     if (is.function(sendCondition)) 
[16:17:49.512]                       return(sendCondition)
[16:17:49.512]                     ns <- getNamespace("parallel")
[16:17:49.512]                     if (exists("sendData", mode = "function", 
[16:17:49.512]                       envir = ns)) {
[16:17:49.512]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:49.512]                         envir = ns)
[16:17:49.512]                       envir <- sys.frame(frame)
[16:17:49.512]                       master <- NULL
[16:17:49.512]                       while (!identical(envir, .GlobalEnv) && 
[16:17:49.512]                         !identical(envir, emptyenv())) {
[16:17:49.512]                         if (exists("master", mode = "list", envir = envir, 
[16:17:49.512]                           inherits = FALSE)) {
[16:17:49.512]                           master <- get("master", mode = "list", 
[16:17:49.512]                             envir = envir, inherits = FALSE)
[16:17:49.512]                           if (inherits(master, c("SOCKnode", 
[16:17:49.512]                             "SOCK0node"))) {
[16:17:49.512]                             sendCondition <<- function(cond) {
[16:17:49.512]                               data <- list(type = "VALUE", value = cond, 
[16:17:49.512]                                 success = TRUE)
[16:17:49.512]                               parallel_sendData(master, data)
[16:17:49.512]                             }
[16:17:49.512]                             return(sendCondition)
[16:17:49.512]                           }
[16:17:49.512]                         }
[16:17:49.512]                         frame <- frame + 1L
[16:17:49.512]                         envir <- sys.frame(frame)
[16:17:49.512]                       }
[16:17:49.512]                     }
[16:17:49.512]                     sendCondition <<- function(cond) NULL
[16:17:49.512]                   }
[16:17:49.512]                 })
[16:17:49.512]                 withCallingHandlers({
[16:17:49.512]                   {
[16:17:49.512]                     do.call(function(...) {
[16:17:49.512]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.512]                       if (!identical(...future.globals.maxSize.org, 
[16:17:49.512]                         ...future.globals.maxSize)) {
[16:17:49.512]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.512]                         on.exit(options(oopts), add = TRUE)
[16:17:49.512]                       }
[16:17:49.512]                       {
[16:17:49.512]                         lapply(seq_along(...future.elements_ii), 
[16:17:49.512]                           FUN = function(jj) {
[16:17:49.512]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.512]                             ...future.FUN(...future.X_jj, ...)
[16:17:49.512]                           })
[16:17:49.512]                       }
[16:17:49.512]                     }, args = future.call.arguments)
[16:17:49.512]                   }
[16:17:49.512]                 }, immediateCondition = function(cond) {
[16:17:49.512]                   sendCondition <- ...future.makeSendCondition()
[16:17:49.512]                   sendCondition(cond)
[16:17:49.512]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.512]                   {
[16:17:49.512]                     inherits <- base::inherits
[16:17:49.512]                     invokeRestart <- base::invokeRestart
[16:17:49.512]                     is.null <- base::is.null
[16:17:49.512]                     muffled <- FALSE
[16:17:49.512]                     if (inherits(cond, "message")) {
[16:17:49.512]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:49.512]                       if (muffled) 
[16:17:49.512]                         invokeRestart("muffleMessage")
[16:17:49.512]                     }
[16:17:49.512]                     else if (inherits(cond, "warning")) {
[16:17:49.512]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:49.512]                       if (muffled) 
[16:17:49.512]                         invokeRestart("muffleWarning")
[16:17:49.512]                     }
[16:17:49.512]                     else if (inherits(cond, "condition")) {
[16:17:49.512]                       if (!is.null(pattern)) {
[16:17:49.512]                         computeRestarts <- base::computeRestarts
[16:17:49.512]                         grepl <- base::grepl
[16:17:49.512]                         restarts <- computeRestarts(cond)
[16:17:49.512]                         for (restart in restarts) {
[16:17:49.512]                           name <- restart$name
[16:17:49.512]                           if (is.null(name)) 
[16:17:49.512]                             next
[16:17:49.512]                           if (!grepl(pattern, name)) 
[16:17:49.512]                             next
[16:17:49.512]                           invokeRestart(restart)
[16:17:49.512]                           muffled <- TRUE
[16:17:49.512]                           break
[16:17:49.512]                         }
[16:17:49.512]                       }
[16:17:49.512]                     }
[16:17:49.512]                     invisible(muffled)
[16:17:49.512]                   }
[16:17:49.512]                   muffleCondition(cond)
[16:17:49.512]                 })
[16:17:49.512]             }))
[16:17:49.512]             future::FutureResult(value = ...future.value$value, 
[16:17:49.512]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:49.512]                   ...future.rng), globalenv = if (FALSE) 
[16:17:49.512]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:49.512]                     ...future.globalenv.names))
[16:17:49.512]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:49.512]         }, condition = base::local({
[16:17:49.512]             c <- base::c
[16:17:49.512]             inherits <- base::inherits
[16:17:49.512]             invokeRestart <- base::invokeRestart
[16:17:49.512]             length <- base::length
[16:17:49.512]             list <- base::list
[16:17:49.512]             seq.int <- base::seq.int
[16:17:49.512]             signalCondition <- base::signalCondition
[16:17:49.512]             sys.calls <- base::sys.calls
[16:17:49.512]             `[[` <- base::`[[`
[16:17:49.512]             `+` <- base::`+`
[16:17:49.512]             `<<-` <- base::`<<-`
[16:17:49.512]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:49.512]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:49.512]                   3L)]
[16:17:49.512]             }
[16:17:49.512]             function(cond) {
[16:17:49.512]                 is_error <- inherits(cond, "error")
[16:17:49.512]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:49.512]                   NULL)
[16:17:49.512]                 if (is_error) {
[16:17:49.512]                   sessionInformation <- function() {
[16:17:49.512]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:49.512]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:49.512]                       search = base::search(), system = base::Sys.info())
[16:17:49.512]                   }
[16:17:49.512]                   ...future.conditions[[length(...future.conditions) + 
[16:17:49.512]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:49.512]                     cond$call), session = sessionInformation(), 
[16:17:49.512]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:49.512]                   signalCondition(cond)
[16:17:49.512]                 }
[16:17:49.512]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:49.512]                 "immediateCondition"))) {
[16:17:49.512]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:49.512]                   ...future.conditions[[length(...future.conditions) + 
[16:17:49.512]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:49.512]                   if (TRUE && !signal) {
[16:17:49.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.512]                     {
[16:17:49.512]                       inherits <- base::inherits
[16:17:49.512]                       invokeRestart <- base::invokeRestart
[16:17:49.512]                       is.null <- base::is.null
[16:17:49.512]                       muffled <- FALSE
[16:17:49.512]                       if (inherits(cond, "message")) {
[16:17:49.512]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:49.512]                         if (muffled) 
[16:17:49.512]                           invokeRestart("muffleMessage")
[16:17:49.512]                       }
[16:17:49.512]                       else if (inherits(cond, "warning")) {
[16:17:49.512]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:49.512]                         if (muffled) 
[16:17:49.512]                           invokeRestart("muffleWarning")
[16:17:49.512]                       }
[16:17:49.512]                       else if (inherits(cond, "condition")) {
[16:17:49.512]                         if (!is.null(pattern)) {
[16:17:49.512]                           computeRestarts <- base::computeRestarts
[16:17:49.512]                           grepl <- base::grepl
[16:17:49.512]                           restarts <- computeRestarts(cond)
[16:17:49.512]                           for (restart in restarts) {
[16:17:49.512]                             name <- restart$name
[16:17:49.512]                             if (is.null(name)) 
[16:17:49.512]                               next
[16:17:49.512]                             if (!grepl(pattern, name)) 
[16:17:49.512]                               next
[16:17:49.512]                             invokeRestart(restart)
[16:17:49.512]                             muffled <- TRUE
[16:17:49.512]                             break
[16:17:49.512]                           }
[16:17:49.512]                         }
[16:17:49.512]                       }
[16:17:49.512]                       invisible(muffled)
[16:17:49.512]                     }
[16:17:49.512]                     muffleCondition(cond, pattern = "^muffle")
[16:17:49.512]                   }
[16:17:49.512]                 }
[16:17:49.512]                 else {
[16:17:49.512]                   if (TRUE) {
[16:17:49.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.512]                     {
[16:17:49.512]                       inherits <- base::inherits
[16:17:49.512]                       invokeRestart <- base::invokeRestart
[16:17:49.512]                       is.null <- base::is.null
[16:17:49.512]                       muffled <- FALSE
[16:17:49.512]                       if (inherits(cond, "message")) {
[16:17:49.512]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:49.512]                         if (muffled) 
[16:17:49.512]                           invokeRestart("muffleMessage")
[16:17:49.512]                       }
[16:17:49.512]                       else if (inherits(cond, "warning")) {
[16:17:49.512]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:49.512]                         if (muffled) 
[16:17:49.512]                           invokeRestart("muffleWarning")
[16:17:49.512]                       }
[16:17:49.512]                       else if (inherits(cond, "condition")) {
[16:17:49.512]                         if (!is.null(pattern)) {
[16:17:49.512]                           computeRestarts <- base::computeRestarts
[16:17:49.512]                           grepl <- base::grepl
[16:17:49.512]                           restarts <- computeRestarts(cond)
[16:17:49.512]                           for (restart in restarts) {
[16:17:49.512]                             name <- restart$name
[16:17:49.512]                             if (is.null(name)) 
[16:17:49.512]                               next
[16:17:49.512]                             if (!grepl(pattern, name)) 
[16:17:49.512]                               next
[16:17:49.512]                             invokeRestart(restart)
[16:17:49.512]                             muffled <- TRUE
[16:17:49.512]                             break
[16:17:49.512]                           }
[16:17:49.512]                         }
[16:17:49.512]                       }
[16:17:49.512]                       invisible(muffled)
[16:17:49.512]                     }
[16:17:49.512]                     muffleCondition(cond, pattern = "^muffle")
[16:17:49.512]                   }
[16:17:49.512]                 }
[16:17:49.512]             }
[16:17:49.512]         }))
[16:17:49.512]     }, error = function(ex) {
[16:17:49.512]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:49.512]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:49.512]                 ...future.rng), started = ...future.startTime, 
[16:17:49.512]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:49.512]             version = "1.8"), class = "FutureResult")
[16:17:49.512]     }, finally = {
[16:17:49.512]         if (!identical(...future.workdir, getwd())) 
[16:17:49.512]             setwd(...future.workdir)
[16:17:49.512]         {
[16:17:49.512]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:49.512]                 ...future.oldOptions$nwarnings <- NULL
[16:17:49.512]             }
[16:17:49.512]             base::options(...future.oldOptions)
[16:17:49.512]             if (.Platform$OS.type == "windows") {
[16:17:49.512]                 old_names <- names(...future.oldEnvVars)
[16:17:49.512]                 envs <- base::Sys.getenv()
[16:17:49.512]                 names <- names(envs)
[16:17:49.512]                 common <- intersect(names, old_names)
[16:17:49.512]                 added <- setdiff(names, old_names)
[16:17:49.512]                 removed <- setdiff(old_names, names)
[16:17:49.512]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:49.512]                   envs[common]]
[16:17:49.512]                 NAMES <- toupper(changed)
[16:17:49.512]                 args <- list()
[16:17:49.512]                 for (kk in seq_along(NAMES)) {
[16:17:49.512]                   name <- changed[[kk]]
[16:17:49.512]                   NAME <- NAMES[[kk]]
[16:17:49.512]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.512]                     next
[16:17:49.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:49.512]                 }
[16:17:49.512]                 NAMES <- toupper(added)
[16:17:49.512]                 for (kk in seq_along(NAMES)) {
[16:17:49.512]                   name <- added[[kk]]
[16:17:49.512]                   NAME <- NAMES[[kk]]
[16:17:49.512]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.512]                     next
[16:17:49.512]                   args[[name]] <- ""
[16:17:49.512]                 }
[16:17:49.512]                 NAMES <- toupper(removed)
[16:17:49.512]                 for (kk in seq_along(NAMES)) {
[16:17:49.512]                   name <- removed[[kk]]
[16:17:49.512]                   NAME <- NAMES[[kk]]
[16:17:49.512]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.512]                     next
[16:17:49.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:49.512]                 }
[16:17:49.512]                 if (length(args) > 0) 
[16:17:49.512]                   base::do.call(base::Sys.setenv, args = args)
[16:17:49.512]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:49.512]             }
[16:17:49.512]             else {
[16:17:49.512]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:49.512]             }
[16:17:49.512]             {
[16:17:49.512]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:49.512]                   0L) {
[16:17:49.512]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:49.512]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:49.512]                   base::options(opts)
[16:17:49.512]                 }
[16:17:49.512]                 {
[16:17:49.512]                   {
[16:17:49.512]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:49.512]                     NULL
[16:17:49.512]                   }
[16:17:49.512]                   options(future.plan = NULL)
[16:17:49.512]                   if (is.na(NA_character_)) 
[16:17:49.512]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:49.512]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:49.512]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:49.512]                     .init = FALSE)
[16:17:49.512]                 }
[16:17:49.512]             }
[16:17:49.512]         }
[16:17:49.512]     })
[16:17:49.512]     if (TRUE) {
[16:17:49.512]         base::sink(type = "output", split = FALSE)
[16:17:49.512]         if (TRUE) {
[16:17:49.512]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:49.512]         }
[16:17:49.512]         else {
[16:17:49.512]             ...future.result["stdout"] <- base::list(NULL)
[16:17:49.512]         }
[16:17:49.512]         base::close(...future.stdout)
[16:17:49.512]         ...future.stdout <- NULL
[16:17:49.512]     }
[16:17:49.512]     ...future.result$conditions <- ...future.conditions
[16:17:49.512]     ...future.result$finished <- base::Sys.time()
[16:17:49.512]     ...future.result
[16:17:49.512] }
[16:17:49.515] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[16:17:49.515] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[16:17:49.515] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[16:17:49.516] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:17:49.516] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:17:49.516] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[16:17:49.517] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[16:17:49.517] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:17:49.517] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:17:49.517] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:17:49.518] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:17:49.518] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[16:17:49.518] MultisessionFuture started
[16:17:49.518] - Launch lazy future ... done
[16:17:49.519] run() for ‘MultisessionFuture’ ... done
[16:17:49.519] Created future:
[16:17:49.519] MultisessionFuture:
[16:17:49.519] Label: ‘future_by-1’
[16:17:49.519] Expression:
[16:17:49.519] {
[16:17:49.519]     do.call(function(...) {
[16:17:49.519]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.519]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:49.519]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.519]             on.exit(options(oopts), add = TRUE)
[16:17:49.519]         }
[16:17:49.519]         {
[16:17:49.519]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:49.519]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.519]                 ...future.FUN(...future.X_jj, ...)
[16:17:49.519]             })
[16:17:49.519]         }
[16:17:49.519]     }, args = future.call.arguments)
[16:17:49.519] }
[16:17:49.519] Lazy evaluation: FALSE
[16:17:49.519] Asynchronous evaluation: TRUE
[16:17:49.519] Local evaluation: TRUE
[16:17:49.519] Environment: 0x55b569bddd38
[16:17:49.519] Capture standard output: TRUE
[16:17:49.519] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:49.519] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:49.519] Packages: <none>
[16:17:49.519] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:49.519] Resolved: FALSE
[16:17:49.519] Value: <not collected>
[16:17:49.519] Conditions captured: <none>
[16:17:49.519] Early signaling: FALSE
[16:17:49.519] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:49.519] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:49.530] Chunk #1 of 2 ... DONE
[16:17:49.531] Chunk #2 of 2 ...
[16:17:49.531]  - Finding globals in 'X' for chunk #2 ...
[16:17:49.531] getGlobalsAndPackages() ...
[16:17:49.531] Searching for globals...
[16:17:49.531] 
[16:17:49.531] Searching for globals ... DONE
[16:17:49.532] - globals: [0] <none>
[16:17:49.532] getGlobalsAndPackages() ... DONE
[16:17:49.532]    + additional globals found: [n=0] 
[16:17:49.532]    + additional namespaces needed: [n=0] 
[16:17:49.532]  - Finding globals in 'X' for chunk #2 ... DONE
[16:17:49.532]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:49.532]  - seeds: <none>
[16:17:49.532]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.532] getGlobalsAndPackages() ...
[16:17:49.532] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.533] Resolving globals: FALSE
[16:17:49.533] Tweak future expression to call with '...' arguments ...
[16:17:49.533] {
[16:17:49.533]     do.call(function(...) {
[16:17:49.533]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.533]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:49.533]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.533]             on.exit(options(oopts), add = TRUE)
[16:17:49.533]         }
[16:17:49.533]         {
[16:17:49.533]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:49.533]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.533]                 ...future.FUN(...future.X_jj, ...)
[16:17:49.533]             })
[16:17:49.533]         }
[16:17:49.533]     }, args = future.call.arguments)
[16:17:49.533] }
[16:17:49.533] Tweak future expression to call with '...' arguments ... DONE
[16:17:49.533] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.533] 
[16:17:49.534] getGlobalsAndPackages() ... DONE
[16:17:49.534] run() for ‘Future’ ...
[16:17:49.534] - state: ‘created’
[16:17:49.534] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:49.547] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:49.547] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:49.547]   - Field: ‘node’
[16:17:49.547]   - Field: ‘label’
[16:17:49.547]   - Field: ‘local’
[16:17:49.548]   - Field: ‘owner’
[16:17:49.548]   - Field: ‘envir’
[16:17:49.548]   - Field: ‘workers’
[16:17:49.548]   - Field: ‘packages’
[16:17:49.548]   - Field: ‘gc’
[16:17:49.548]   - Field: ‘conditions’
[16:17:49.548]   - Field: ‘persistent’
[16:17:49.548]   - Field: ‘expr’
[16:17:49.548]   - Field: ‘uuid’
[16:17:49.548]   - Field: ‘seed’
[16:17:49.549]   - Field: ‘version’
[16:17:49.549]   - Field: ‘result’
[16:17:49.549]   - Field: ‘asynchronous’
[16:17:49.549]   - Field: ‘calls’
[16:17:49.549]   - Field: ‘globals’
[16:17:49.549]   - Field: ‘stdout’
[16:17:49.549]   - Field: ‘earlySignal’
[16:17:49.549]   - Field: ‘lazy’
[16:17:49.549]   - Field: ‘state’
[16:17:49.549] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:49.549] - Launch lazy future ...
[16:17:49.550] Packages needed by the future expression (n = 0): <none>
[16:17:49.550] Packages needed by future strategies (n = 0): <none>
[16:17:49.550] {
[16:17:49.550]     {
[16:17:49.550]         {
[16:17:49.550]             ...future.startTime <- base::Sys.time()
[16:17:49.550]             {
[16:17:49.550]                 {
[16:17:49.550]                   {
[16:17:49.550]                     {
[16:17:49.550]                       base::local({
[16:17:49.550]                         has_future <- base::requireNamespace("future", 
[16:17:49.550]                           quietly = TRUE)
[16:17:49.550]                         if (has_future) {
[16:17:49.550]                           ns <- base::getNamespace("future")
[16:17:49.550]                           version <- ns[[".package"]][["version"]]
[16:17:49.550]                           if (is.null(version)) 
[16:17:49.550]                             version <- utils::packageVersion("future")
[16:17:49.550]                         }
[16:17:49.550]                         else {
[16:17:49.550]                           version <- NULL
[16:17:49.550]                         }
[16:17:49.550]                         if (!has_future || version < "1.8.0") {
[16:17:49.550]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:49.550]                             "", base::R.version$version.string), 
[16:17:49.550]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:49.550]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:49.550]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:49.550]                               "release", "version")], collapse = " "), 
[16:17:49.550]                             hostname = base::Sys.info()[["nodename"]])
[16:17:49.550]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:49.550]                             info)
[16:17:49.550]                           info <- base::paste(info, collapse = "; ")
[16:17:49.550]                           if (!has_future) {
[16:17:49.550]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:49.550]                               info)
[16:17:49.550]                           }
[16:17:49.550]                           else {
[16:17:49.550]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:49.550]                               info, version)
[16:17:49.550]                           }
[16:17:49.550]                           base::stop(msg)
[16:17:49.550]                         }
[16:17:49.550]                       })
[16:17:49.550]                     }
[16:17:49.550]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:49.550]                     base::options(mc.cores = 1L)
[16:17:49.550]                   }
[16:17:49.550]                   ...future.strategy.old <- future::plan("list")
[16:17:49.550]                   options(future.plan = NULL)
[16:17:49.550]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:49.550]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:49.550]                 }
[16:17:49.550]                 ...future.workdir <- getwd()
[16:17:49.550]             }
[16:17:49.550]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:49.550]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:49.550]         }
[16:17:49.550]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:49.550]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:49.550]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:49.550]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:49.550]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:49.550]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:49.550]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:49.550]             base::names(...future.oldOptions))
[16:17:49.550]     }
[16:17:49.550]     if (FALSE) {
[16:17:49.550]     }
[16:17:49.550]     else {
[16:17:49.550]         if (TRUE) {
[16:17:49.550]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:49.550]                 open = "w")
[16:17:49.550]         }
[16:17:49.550]         else {
[16:17:49.550]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:49.550]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:49.550]         }
[16:17:49.550]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:49.550]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:49.550]             base::sink(type = "output", split = FALSE)
[16:17:49.550]             base::close(...future.stdout)
[16:17:49.550]         }, add = TRUE)
[16:17:49.550]     }
[16:17:49.550]     ...future.frame <- base::sys.nframe()
[16:17:49.550]     ...future.conditions <- base::list()
[16:17:49.550]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:49.550]     if (FALSE) {
[16:17:49.550]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:49.550]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:49.550]     }
[16:17:49.550]     ...future.result <- base::tryCatch({
[16:17:49.550]         base::withCallingHandlers({
[16:17:49.550]             ...future.value <- base::withVisible(base::local({
[16:17:49.550]                 ...future.makeSendCondition <- base::local({
[16:17:49.550]                   sendCondition <- NULL
[16:17:49.550]                   function(frame = 1L) {
[16:17:49.550]                     if (is.function(sendCondition)) 
[16:17:49.550]                       return(sendCondition)
[16:17:49.550]                     ns <- getNamespace("parallel")
[16:17:49.550]                     if (exists("sendData", mode = "function", 
[16:17:49.550]                       envir = ns)) {
[16:17:49.550]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:49.550]                         envir = ns)
[16:17:49.550]                       envir <- sys.frame(frame)
[16:17:49.550]                       master <- NULL
[16:17:49.550]                       while (!identical(envir, .GlobalEnv) && 
[16:17:49.550]                         !identical(envir, emptyenv())) {
[16:17:49.550]                         if (exists("master", mode = "list", envir = envir, 
[16:17:49.550]                           inherits = FALSE)) {
[16:17:49.550]                           master <- get("master", mode = "list", 
[16:17:49.550]                             envir = envir, inherits = FALSE)
[16:17:49.550]                           if (inherits(master, c("SOCKnode", 
[16:17:49.550]                             "SOCK0node"))) {
[16:17:49.550]                             sendCondition <<- function(cond) {
[16:17:49.550]                               data <- list(type = "VALUE", value = cond, 
[16:17:49.550]                                 success = TRUE)
[16:17:49.550]                               parallel_sendData(master, data)
[16:17:49.550]                             }
[16:17:49.550]                             return(sendCondition)
[16:17:49.550]                           }
[16:17:49.550]                         }
[16:17:49.550]                         frame <- frame + 1L
[16:17:49.550]                         envir <- sys.frame(frame)
[16:17:49.550]                       }
[16:17:49.550]                     }
[16:17:49.550]                     sendCondition <<- function(cond) NULL
[16:17:49.550]                   }
[16:17:49.550]                 })
[16:17:49.550]                 withCallingHandlers({
[16:17:49.550]                   {
[16:17:49.550]                     do.call(function(...) {
[16:17:49.550]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.550]                       if (!identical(...future.globals.maxSize.org, 
[16:17:49.550]                         ...future.globals.maxSize)) {
[16:17:49.550]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.550]                         on.exit(options(oopts), add = TRUE)
[16:17:49.550]                       }
[16:17:49.550]                       {
[16:17:49.550]                         lapply(seq_along(...future.elements_ii), 
[16:17:49.550]                           FUN = function(jj) {
[16:17:49.550]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.550]                             ...future.FUN(...future.X_jj, ...)
[16:17:49.550]                           })
[16:17:49.550]                       }
[16:17:49.550]                     }, args = future.call.arguments)
[16:17:49.550]                   }
[16:17:49.550]                 }, immediateCondition = function(cond) {
[16:17:49.550]                   sendCondition <- ...future.makeSendCondition()
[16:17:49.550]                   sendCondition(cond)
[16:17:49.550]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.550]                   {
[16:17:49.550]                     inherits <- base::inherits
[16:17:49.550]                     invokeRestart <- base::invokeRestart
[16:17:49.550]                     is.null <- base::is.null
[16:17:49.550]                     muffled <- FALSE
[16:17:49.550]                     if (inherits(cond, "message")) {
[16:17:49.550]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:49.550]                       if (muffled) 
[16:17:49.550]                         invokeRestart("muffleMessage")
[16:17:49.550]                     }
[16:17:49.550]                     else if (inherits(cond, "warning")) {
[16:17:49.550]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:49.550]                       if (muffled) 
[16:17:49.550]                         invokeRestart("muffleWarning")
[16:17:49.550]                     }
[16:17:49.550]                     else if (inherits(cond, "condition")) {
[16:17:49.550]                       if (!is.null(pattern)) {
[16:17:49.550]                         computeRestarts <- base::computeRestarts
[16:17:49.550]                         grepl <- base::grepl
[16:17:49.550]                         restarts <- computeRestarts(cond)
[16:17:49.550]                         for (restart in restarts) {
[16:17:49.550]                           name <- restart$name
[16:17:49.550]                           if (is.null(name)) 
[16:17:49.550]                             next
[16:17:49.550]                           if (!grepl(pattern, name)) 
[16:17:49.550]                             next
[16:17:49.550]                           invokeRestart(restart)
[16:17:49.550]                           muffled <- TRUE
[16:17:49.550]                           break
[16:17:49.550]                         }
[16:17:49.550]                       }
[16:17:49.550]                     }
[16:17:49.550]                     invisible(muffled)
[16:17:49.550]                   }
[16:17:49.550]                   muffleCondition(cond)
[16:17:49.550]                 })
[16:17:49.550]             }))
[16:17:49.550]             future::FutureResult(value = ...future.value$value, 
[16:17:49.550]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:49.550]                   ...future.rng), globalenv = if (FALSE) 
[16:17:49.550]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:49.550]                     ...future.globalenv.names))
[16:17:49.550]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:49.550]         }, condition = base::local({
[16:17:49.550]             c <- base::c
[16:17:49.550]             inherits <- base::inherits
[16:17:49.550]             invokeRestart <- base::invokeRestart
[16:17:49.550]             length <- base::length
[16:17:49.550]             list <- base::list
[16:17:49.550]             seq.int <- base::seq.int
[16:17:49.550]             signalCondition <- base::signalCondition
[16:17:49.550]             sys.calls <- base::sys.calls
[16:17:49.550]             `[[` <- base::`[[`
[16:17:49.550]             `+` <- base::`+`
[16:17:49.550]             `<<-` <- base::`<<-`
[16:17:49.550]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:49.550]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:49.550]                   3L)]
[16:17:49.550]             }
[16:17:49.550]             function(cond) {
[16:17:49.550]                 is_error <- inherits(cond, "error")
[16:17:49.550]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:49.550]                   NULL)
[16:17:49.550]                 if (is_error) {
[16:17:49.550]                   sessionInformation <- function() {
[16:17:49.550]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:49.550]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:49.550]                       search = base::search(), system = base::Sys.info())
[16:17:49.550]                   }
[16:17:49.550]                   ...future.conditions[[length(...future.conditions) + 
[16:17:49.550]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:49.550]                     cond$call), session = sessionInformation(), 
[16:17:49.550]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:49.550]                   signalCondition(cond)
[16:17:49.550]                 }
[16:17:49.550]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:49.550]                 "immediateCondition"))) {
[16:17:49.550]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:49.550]                   ...future.conditions[[length(...future.conditions) + 
[16:17:49.550]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:49.550]                   if (TRUE && !signal) {
[16:17:49.550]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.550]                     {
[16:17:49.550]                       inherits <- base::inherits
[16:17:49.550]                       invokeRestart <- base::invokeRestart
[16:17:49.550]                       is.null <- base::is.null
[16:17:49.550]                       muffled <- FALSE
[16:17:49.550]                       if (inherits(cond, "message")) {
[16:17:49.550]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:49.550]                         if (muffled) 
[16:17:49.550]                           invokeRestart("muffleMessage")
[16:17:49.550]                       }
[16:17:49.550]                       else if (inherits(cond, "warning")) {
[16:17:49.550]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:49.550]                         if (muffled) 
[16:17:49.550]                           invokeRestart("muffleWarning")
[16:17:49.550]                       }
[16:17:49.550]                       else if (inherits(cond, "condition")) {
[16:17:49.550]                         if (!is.null(pattern)) {
[16:17:49.550]                           computeRestarts <- base::computeRestarts
[16:17:49.550]                           grepl <- base::grepl
[16:17:49.550]                           restarts <- computeRestarts(cond)
[16:17:49.550]                           for (restart in restarts) {
[16:17:49.550]                             name <- restart$name
[16:17:49.550]                             if (is.null(name)) 
[16:17:49.550]                               next
[16:17:49.550]                             if (!grepl(pattern, name)) 
[16:17:49.550]                               next
[16:17:49.550]                             invokeRestart(restart)
[16:17:49.550]                             muffled <- TRUE
[16:17:49.550]                             break
[16:17:49.550]                           }
[16:17:49.550]                         }
[16:17:49.550]                       }
[16:17:49.550]                       invisible(muffled)
[16:17:49.550]                     }
[16:17:49.550]                     muffleCondition(cond, pattern = "^muffle")
[16:17:49.550]                   }
[16:17:49.550]                 }
[16:17:49.550]                 else {
[16:17:49.550]                   if (TRUE) {
[16:17:49.550]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.550]                     {
[16:17:49.550]                       inherits <- base::inherits
[16:17:49.550]                       invokeRestart <- base::invokeRestart
[16:17:49.550]                       is.null <- base::is.null
[16:17:49.550]                       muffled <- FALSE
[16:17:49.550]                       if (inherits(cond, "message")) {
[16:17:49.550]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:49.550]                         if (muffled) 
[16:17:49.550]                           invokeRestart("muffleMessage")
[16:17:49.550]                       }
[16:17:49.550]                       else if (inherits(cond, "warning")) {
[16:17:49.550]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:49.550]                         if (muffled) 
[16:17:49.550]                           invokeRestart("muffleWarning")
[16:17:49.550]                       }
[16:17:49.550]                       else if (inherits(cond, "condition")) {
[16:17:49.550]                         if (!is.null(pattern)) {
[16:17:49.550]                           computeRestarts <- base::computeRestarts
[16:17:49.550]                           grepl <- base::grepl
[16:17:49.550]                           restarts <- computeRestarts(cond)
[16:17:49.550]                           for (restart in restarts) {
[16:17:49.550]                             name <- restart$name
[16:17:49.550]                             if (is.null(name)) 
[16:17:49.550]                               next
[16:17:49.550]                             if (!grepl(pattern, name)) 
[16:17:49.550]                               next
[16:17:49.550]                             invokeRestart(restart)
[16:17:49.550]                             muffled <- TRUE
[16:17:49.550]                             break
[16:17:49.550]                           }
[16:17:49.550]                         }
[16:17:49.550]                       }
[16:17:49.550]                       invisible(muffled)
[16:17:49.550]                     }
[16:17:49.550]                     muffleCondition(cond, pattern = "^muffle")
[16:17:49.550]                   }
[16:17:49.550]                 }
[16:17:49.550]             }
[16:17:49.550]         }))
[16:17:49.550]     }, error = function(ex) {
[16:17:49.550]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:49.550]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:49.550]                 ...future.rng), started = ...future.startTime, 
[16:17:49.550]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:49.550]             version = "1.8"), class = "FutureResult")
[16:17:49.550]     }, finally = {
[16:17:49.550]         if (!identical(...future.workdir, getwd())) 
[16:17:49.550]             setwd(...future.workdir)
[16:17:49.550]         {
[16:17:49.550]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:49.550]                 ...future.oldOptions$nwarnings <- NULL
[16:17:49.550]             }
[16:17:49.550]             base::options(...future.oldOptions)
[16:17:49.550]             if (.Platform$OS.type == "windows") {
[16:17:49.550]                 old_names <- names(...future.oldEnvVars)
[16:17:49.550]                 envs <- base::Sys.getenv()
[16:17:49.550]                 names <- names(envs)
[16:17:49.550]                 common <- intersect(names, old_names)
[16:17:49.550]                 added <- setdiff(names, old_names)
[16:17:49.550]                 removed <- setdiff(old_names, names)
[16:17:49.550]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:49.550]                   envs[common]]
[16:17:49.550]                 NAMES <- toupper(changed)
[16:17:49.550]                 args <- list()
[16:17:49.550]                 for (kk in seq_along(NAMES)) {
[16:17:49.550]                   name <- changed[[kk]]
[16:17:49.550]                   NAME <- NAMES[[kk]]
[16:17:49.550]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.550]                     next
[16:17:49.550]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:49.550]                 }
[16:17:49.550]                 NAMES <- toupper(added)
[16:17:49.550]                 for (kk in seq_along(NAMES)) {
[16:17:49.550]                   name <- added[[kk]]
[16:17:49.550]                   NAME <- NAMES[[kk]]
[16:17:49.550]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.550]                     next
[16:17:49.550]                   args[[name]] <- ""
[16:17:49.550]                 }
[16:17:49.550]                 NAMES <- toupper(removed)
[16:17:49.550]                 for (kk in seq_along(NAMES)) {
[16:17:49.550]                   name <- removed[[kk]]
[16:17:49.550]                   NAME <- NAMES[[kk]]
[16:17:49.550]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.550]                     next
[16:17:49.550]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:49.550]                 }
[16:17:49.550]                 if (length(args) > 0) 
[16:17:49.550]                   base::do.call(base::Sys.setenv, args = args)
[16:17:49.550]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:49.550]             }
[16:17:49.550]             else {
[16:17:49.550]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:49.550]             }
[16:17:49.550]             {
[16:17:49.550]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:49.550]                   0L) {
[16:17:49.550]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:49.550]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:49.550]                   base::options(opts)
[16:17:49.550]                 }
[16:17:49.550]                 {
[16:17:49.550]                   {
[16:17:49.550]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:49.550]                     NULL
[16:17:49.550]                   }
[16:17:49.550]                   options(future.plan = NULL)
[16:17:49.550]                   if (is.na(NA_character_)) 
[16:17:49.550]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:49.550]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:49.550]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:49.550]                     .init = FALSE)
[16:17:49.550]                 }
[16:17:49.550]             }
[16:17:49.550]         }
[16:17:49.550]     })
[16:17:49.550]     if (TRUE) {
[16:17:49.550]         base::sink(type = "output", split = FALSE)
[16:17:49.550]         if (TRUE) {
[16:17:49.550]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:49.550]         }
[16:17:49.550]         else {
[16:17:49.550]             ...future.result["stdout"] <- base::list(NULL)
[16:17:49.550]         }
[16:17:49.550]         base::close(...future.stdout)
[16:17:49.550]         ...future.stdout <- NULL
[16:17:49.550]     }
[16:17:49.550]     ...future.result$conditions <- ...future.conditions
[16:17:49.550]     ...future.result$finished <- base::Sys.time()
[16:17:49.550]     ...future.result
[16:17:49.550] }
[16:17:49.553] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[16:17:49.553] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[16:17:49.553] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[16:17:49.553] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:17:49.554] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:17:49.554] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[16:17:49.554] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[16:17:49.554] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:17:49.555] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:17:49.555] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:17:49.555] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:17:49.555] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[16:17:49.556] MultisessionFuture started
[16:17:49.556] - Launch lazy future ... done
[16:17:49.556] run() for ‘MultisessionFuture’ ... done
[16:17:49.556] Created future:
[16:17:49.556] MultisessionFuture:
[16:17:49.556] Label: ‘future_by-2’
[16:17:49.556] Expression:
[16:17:49.556] {
[16:17:49.556]     do.call(function(...) {
[16:17:49.556]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.556]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:49.556]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.556]             on.exit(options(oopts), add = TRUE)
[16:17:49.556]         }
[16:17:49.556]         {
[16:17:49.556]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:49.556]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.556]                 ...future.FUN(...future.X_jj, ...)
[16:17:49.556]             })
[16:17:49.556]         }
[16:17:49.556]     }, args = future.call.arguments)
[16:17:49.556] }
[16:17:49.556] Lazy evaluation: FALSE
[16:17:49.556] Asynchronous evaluation: TRUE
[16:17:49.556] Local evaluation: TRUE
[16:17:49.556] Environment: 0x55b569bddd38
[16:17:49.556] Capture standard output: TRUE
[16:17:49.556] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:49.556] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:49.556] Packages: <none>
[16:17:49.556] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:49.556] Resolved: FALSE
[16:17:49.556] Value: <not collected>
[16:17:49.556] Conditions captured: <none>
[16:17:49.556] Early signaling: FALSE
[16:17:49.556] Owner process: a6c24eed-b262-5d8d-1e3b-238dd884e144
[16:17:49.556] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:49.568] Chunk #2 of 2 ... DONE
[16:17:49.568] Launching 2 futures (chunks) ... DONE
[16:17:49.568] Resolving 2 futures (chunks) ...
[16:17:49.568] resolve() on list ...
[16:17:49.568]  recursive: 0
[16:17:49.568]  length: 2
[16:17:49.569] 
[16:17:49.569] receiveMessageFromWorker() for ClusterFuture ...
[16:17:49.569] - Validating connection of MultisessionFuture
[16:17:49.569] - received message: FutureResult
[16:17:49.569] - Received FutureResult
[16:17:49.570] - Erased future from FutureRegistry
[16:17:49.570] result() for ClusterFuture ...
[16:17:49.570] - result already collected: FutureResult
[16:17:49.570] result() for ClusterFuture ... done
[16:17:49.570] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:49.570] Future #1
[16:17:49.570] result() for ClusterFuture ...
[16:17:49.570] - result already collected: FutureResult
[16:17:49.570] result() for ClusterFuture ... done
[16:17:49.570] result() for ClusterFuture ...
[16:17:49.570] - result already collected: FutureResult
[16:17:49.570] result() for ClusterFuture ... done
[16:17:49.571] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:17:49.571] - nx: 2
[16:17:49.571] - relay: TRUE
[16:17:49.571] - stdout: TRUE
[16:17:49.571] - signal: TRUE
[16:17:49.571] - resignal: FALSE
[16:17:49.571] - force: TRUE
[16:17:49.571] - relayed: [n=2] FALSE, FALSE
[16:17:49.571] - queued futures: [n=2] FALSE, FALSE
[16:17:49.571]  - until=1
[16:17:49.571]  - relaying element #1
[16:17:49.572] result() for ClusterFuture ...
[16:17:49.572] - result already collected: FutureResult
[16:17:49.572] result() for ClusterFuture ... done
[16:17:49.572] result() for ClusterFuture ...
[16:17:49.572] - result already collected: FutureResult
[16:17:49.572] result() for ClusterFuture ... done
[16:17:49.572] result() for ClusterFuture ...
[16:17:49.572] - result already collected: FutureResult
[16:17:49.572] result() for ClusterFuture ... done
[16:17:49.572] result() for ClusterFuture ...
[16:17:49.572] - result already collected: FutureResult
[16:17:49.573] result() for ClusterFuture ... done
[16:17:49.573] - relayed: [n=2] TRUE, FALSE
[16:17:49.573] - queued futures: [n=2] TRUE, FALSE
[16:17:49.573] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:17:49.573]  length: 1 (resolved future 1)
[16:17:49.599] receiveMessageFromWorker() for ClusterFuture ...
[16:17:49.599] - Validating connection of MultisessionFuture
[16:17:49.599] - received message: FutureResult
[16:17:49.599] - Received FutureResult
[16:17:49.600] - Erased future from FutureRegistry
[16:17:49.600] result() for ClusterFuture ...
[16:17:49.600] - result already collected: FutureResult
[16:17:49.600] result() for ClusterFuture ... done
[16:17:49.600] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:49.600] Future #2
[16:17:49.600] result() for ClusterFuture ...
[16:17:49.600] - result already collected: FutureResult
[16:17:49.600] result() for ClusterFuture ... done
[16:17:49.600] result() for ClusterFuture ...
[16:17:49.600] - result already collected: FutureResult
[16:17:49.601] result() for ClusterFuture ... done
[16:17:49.601] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:17:49.601] - nx: 2
[16:17:49.601] - relay: TRUE
[16:17:49.601] - stdout: TRUE
[16:17:49.601] - signal: TRUE
[16:17:49.601] - resignal: FALSE
[16:17:49.601] - force: TRUE
[16:17:49.601] - relayed: [n=2] TRUE, FALSE
[16:17:49.601] - queued futures: [n=2] TRUE, FALSE
[16:17:49.601]  - until=2
[16:17:49.601]  - relaying element #2
[16:17:49.602] result() for ClusterFuture ...
[16:17:49.602] - result already collected: FutureResult
[16:17:49.602] result() for ClusterFuture ... done
[16:17:49.602] result() for ClusterFuture ...
[16:17:49.602] - result already collected: FutureResult
[16:17:49.602] result() for ClusterFuture ... done
[16:17:49.602] result() for ClusterFuture ...
[16:17:49.602] - result already collected: FutureResult
[16:17:49.602] result() for ClusterFuture ... done
[16:17:49.602] result() for ClusterFuture ...
[16:17:49.602] - result already collected: FutureResult
[16:17:49.603] result() for ClusterFuture ... done
[16:17:49.603] - relayed: [n=2] TRUE, TRUE
[16:17:49.603] - queued futures: [n=2] TRUE, TRUE
[16:17:49.603] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:17:49.603]  length: 0 (resolved future 2)
[16:17:49.603] Relaying remaining futures
[16:17:49.603] signalConditionsASAP(NULL, pos=0) ...
[16:17:49.603] - nx: 2
[16:17:49.603] - relay: TRUE
[16:17:49.603] - stdout: TRUE
[16:17:49.603] - signal: TRUE
[16:17:49.604] - resignal: FALSE
[16:17:49.604] - force: TRUE
[16:17:49.604] - relayed: [n=2] TRUE, TRUE
[16:17:49.604] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:49.604] - relayed: [n=2] TRUE, TRUE
[16:17:49.604] - queued futures: [n=2] TRUE, TRUE
[16:17:49.604] signalConditionsASAP(NULL, pos=0) ... done
[16:17:49.604] resolve() on list ... DONE
[16:17:49.604] result() for ClusterFuture ...
[16:17:49.604] - result already collected: FutureResult
[16:17:49.605] result() for ClusterFuture ... done
[16:17:49.605] result() for ClusterFuture ...
[16:17:49.605] - result already collected: FutureResult
[16:17:49.605] result() for ClusterFuture ... done
[16:17:49.605] result() for ClusterFuture ...
[16:17:49.605] - result already collected: FutureResult
[16:17:49.605] result() for ClusterFuture ... done
[16:17:49.605] result() for ClusterFuture ...
[16:17:49.605] - result already collected: FutureResult
[16:17:49.605] result() for ClusterFuture ... done
[16:17:49.605]  - Number of value chunks collected: 2
[16:17:49.606] Resolving 2 futures (chunks) ... DONE
[16:17:49.606] Reducing values from 2 chunks ...
[16:17:49.606]  - Number of values collected after concatenation: 3
[16:17:49.606]  - Number of values expected: 3
[16:17:49.606] Reducing values from 2 chunks ... DONE
[16:17:49.606] future_lapply() ... DONE
[16:17:49.606] future_by_internal() ... DONE
[16:17:49.607] future_by_internal() ...
Testing with 2 cores ... DONE
> 
> message("*** future_by() ... DONE")
*** future_by() ... DONE
> 
> source("incl/end.R")
[16:17:49.608] plan(): Setting new future strategy stack:
[16:17:49.608] List of future strategies:
[16:17:49.608] 1. FutureStrategy:
[16:17:49.608]    - args: function (..., envir = parent.frame())
[16:17:49.608]    - tweaked: FALSE
[16:17:49.608]    - call: future::plan(oplan)
[16:17:49.609] plan(): nbrOfWorkers() = 1
> 
