
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[16:17:49.901] plan(): Setting new future strategy stack:
[16:17:49.902] List of future strategies:
[16:17:49.902] 1. sequential:
[16:17:49.902]    - args: function (..., envir = parent.frame())
[16:17:49.902]    - tweaked: FALSE
[16:17:49.902]    - call: future::plan("sequential")
[16:17:49.915] plan(): nbrOfWorkers() = 1
> 
> message("*** future_eapply() ...")
*** future_eapply() ...
> 
> message("- From example(eapply) ...")
- From example(eapply) ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   env <- new.env(hash = FALSE)
+   env$a <- 1:10
+   env$beta <- exp(-3:3)
+   env$logic <- c(TRUE, FALSE, FALSE, TRUE)
+   
+   y0 <- unlist(eapply(env, mean, USE.NAMES = FALSE))
+   y1 <- unlist(future_eapply(env, mean, USE.NAMES = FALSE))
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile, probs = 1:3/4)
+   y1 <- future_eapply(env, quantile, probs = 1:3/4)
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile)
+   y1 <- future_eapply(env, quantile)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_eapply(env, "quantile")
+   stopifnot(all.equal(y2, y0))
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[16:17:49.937] plan(): Setting new future strategy stack:
[16:17:49.937] List of future strategies:
[16:17:49.937] 1. sequential:
[16:17:49.937]    - args: function (..., envir = parent.frame())
[16:17:49.937]    - tweaked: FALSE
[16:17:49.937]    - call: plan(strategy)
[16:17:49.949] plan(): nbrOfWorkers() = 1
[16:17:49.949] future_lapply() ...
[16:17:49.953] Number of chunks: 1
[16:17:49.954] getGlobalsAndPackagesXApply() ...
[16:17:49.954]  - future.globals: TRUE
[16:17:49.955] getGlobalsAndPackages() ...
[16:17:49.955] Searching for globals...
[16:17:49.957] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:49.957] Searching for globals ... DONE
[16:17:49.957] Resolving globals: FALSE
[16:17:49.958] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:49.959] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:49.959] - globals: [1] ‘FUN’
[16:17:49.959] 
[16:17:49.959] getGlobalsAndPackages() ... DONE
[16:17:49.959]  - globals found/used: [n=1] ‘FUN’
[16:17:49.959]  - needed namespaces: [n=0] 
[16:17:49.959] Finding globals ... DONE
[16:17:49.959]  - use_args: TRUE
[16:17:49.959]  - Getting '...' globals ...
[16:17:49.960] resolve() on list ...
[16:17:49.960]  recursive: 0
[16:17:49.961]  length: 1
[16:17:49.961]  elements: ‘...’
[16:17:49.961]  length: 0 (resolved future 1)
[16:17:49.961] resolve() on list ... DONE
[16:17:49.961]    - '...' content: [n=0] 
[16:17:49.961] List of 1
[16:17:49.961]  $ ...: list()
[16:17:49.961]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:49.961]  - attr(*, "where")=List of 1
[16:17:49.961]   ..$ ...:<environment: 0x556da2e08fb0> 
[16:17:49.961]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:49.961]  - attr(*, "resolved")= logi TRUE
[16:17:49.961]  - attr(*, "total_size")= num NA
[16:17:49.966]  - Getting '...' globals ... DONE
[16:17:49.966] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:49.966] List of 2
[16:17:49.966]  $ ...future.FUN:function (x, ...)  
[16:17:49.966]  $ ...          : list()
[16:17:49.966]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:49.966]  - attr(*, "where")=List of 2
[16:17:49.966]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:49.966]   ..$ ...          :<environment: 0x556da2e08fb0> 
[16:17:49.966]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:49.966]  - attr(*, "resolved")= logi FALSE
[16:17:49.966]  - attr(*, "total_size")= num 1240
[16:17:49.969] Packages to be attached in all futures: [n=0] 
[16:17:49.969] getGlobalsAndPackagesXApply() ... DONE
[16:17:49.969] Number of futures (= number of chunks): 1
[16:17:49.969] Launching 1 futures (chunks) ...
[16:17:49.969] Chunk #1 of 1 ...
[16:17:49.970]  - Finding globals in 'X' for chunk #1 ...
[16:17:49.970] getGlobalsAndPackages() ...
[16:17:49.970] Searching for globals...
[16:17:49.970] 
[16:17:49.970] Searching for globals ... DONE
[16:17:49.970] - globals: [0] <none>
[16:17:49.970] getGlobalsAndPackages() ... DONE
[16:17:49.970]    + additional globals found: [n=0] 
[16:17:49.971]    + additional namespaces needed: [n=0] 
[16:17:49.971]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:49.971]  - seeds: <none>
[16:17:49.971]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.971] getGlobalsAndPackages() ...
[16:17:49.971] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.971] Resolving globals: FALSE
[16:17:49.971] Tweak future expression to call with '...' arguments ...
[16:17:49.971] {
[16:17:49.971]     do.call(function(...) {
[16:17:49.971]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.971]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:49.971]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.971]             on.exit(options(oopts), add = TRUE)
[16:17:49.971]         }
[16:17:49.971]         {
[16:17:49.971]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:49.971]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.971]                 ...future.FUN(...future.X_jj, ...)
[16:17:49.971]             })
[16:17:49.971]         }
[16:17:49.971]     }, args = future.call.arguments)
[16:17:49.971] }
[16:17:49.972] Tweak future expression to call with '...' arguments ... DONE
[16:17:49.972] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:49.972] 
[16:17:49.972] getGlobalsAndPackages() ... DONE
[16:17:49.973] run() for ‘Future’ ...
[16:17:49.973] - state: ‘created’
[16:17:49.973] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:17:49.974] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:49.974] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:49.974]   - Field: ‘label’
[16:17:49.974]   - Field: ‘local’
[16:17:49.974]   - Field: ‘owner’
[16:17:49.974]   - Field: ‘envir’
[16:17:49.974]   - Field: ‘packages’
[16:17:49.974]   - Field: ‘gc’
[16:17:49.974]   - Field: ‘conditions’
[16:17:49.974]   - Field: ‘expr’
[16:17:49.975]   - Field: ‘uuid’
[16:17:49.975]   - Field: ‘seed’
[16:17:49.975]   - Field: ‘version’
[16:17:49.975]   - Field: ‘result’
[16:17:49.975]   - Field: ‘asynchronous’
[16:17:49.975]   - Field: ‘calls’
[16:17:49.975]   - Field: ‘globals’
[16:17:49.975]   - Field: ‘stdout’
[16:17:49.975]   - Field: ‘earlySignal’
[16:17:49.975]   - Field: ‘lazy’
[16:17:49.975]   - Field: ‘state’
[16:17:49.976] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:49.976] - Launch lazy future ...
[16:17:49.976] Packages needed by the future expression (n = 0): <none>
[16:17:49.977] Packages needed by future strategies (n = 0): <none>
[16:17:49.979] {
[16:17:49.979]     {
[16:17:49.979]         {
[16:17:49.979]             ...future.startTime <- base::Sys.time()
[16:17:49.979]             {
[16:17:49.979]                 {
[16:17:49.979]                   {
[16:17:49.979]                     base::local({
[16:17:49.979]                       has_future <- base::requireNamespace("future", 
[16:17:49.979]                         quietly = TRUE)
[16:17:49.979]                       if (has_future) {
[16:17:49.979]                         ns <- base::getNamespace("future")
[16:17:49.979]                         version <- ns[[".package"]][["version"]]
[16:17:49.979]                         if (is.null(version)) 
[16:17:49.979]                           version <- utils::packageVersion("future")
[16:17:49.979]                       }
[16:17:49.979]                       else {
[16:17:49.979]                         version <- NULL
[16:17:49.979]                       }
[16:17:49.979]                       if (!has_future || version < "1.8.0") {
[16:17:49.979]                         info <- base::c(r_version = base::gsub("R version ", 
[16:17:49.979]                           "", base::R.version$version.string), 
[16:17:49.979]                           platform = base::sprintf("%s (%s-bit)", 
[16:17:49.979]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:49.979]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:49.979]                             "release", "version")], collapse = " "), 
[16:17:49.979]                           hostname = base::Sys.info()[["nodename"]])
[16:17:49.979]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:17:49.979]                           info)
[16:17:49.979]                         info <- base::paste(info, collapse = "; ")
[16:17:49.979]                         if (!has_future) {
[16:17:49.979]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:49.979]                             info)
[16:17:49.979]                         }
[16:17:49.979]                         else {
[16:17:49.979]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:49.979]                             info, version)
[16:17:49.979]                         }
[16:17:49.979]                         base::stop(msg)
[16:17:49.979]                       }
[16:17:49.979]                     })
[16:17:49.979]                   }
[16:17:49.979]                   ...future.strategy.old <- future::plan("list")
[16:17:49.979]                   options(future.plan = NULL)
[16:17:49.979]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:49.979]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:49.979]                 }
[16:17:49.979]                 ...future.workdir <- getwd()
[16:17:49.979]             }
[16:17:49.979]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:49.979]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:49.979]         }
[16:17:49.979]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:49.979]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:49.979]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:49.979]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:49.979]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:49.979]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:49.979]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:49.979]             base::names(...future.oldOptions))
[16:17:49.979]     }
[16:17:49.979]     if (FALSE) {
[16:17:49.979]     }
[16:17:49.979]     else {
[16:17:49.979]         if (TRUE) {
[16:17:49.979]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:49.979]                 open = "w")
[16:17:49.979]         }
[16:17:49.979]         else {
[16:17:49.979]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:49.979]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:49.979]         }
[16:17:49.979]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:49.979]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:49.979]             base::sink(type = "output", split = FALSE)
[16:17:49.979]             base::close(...future.stdout)
[16:17:49.979]         }, add = TRUE)
[16:17:49.979]     }
[16:17:49.979]     ...future.frame <- base::sys.nframe()
[16:17:49.979]     ...future.conditions <- base::list()
[16:17:49.979]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:49.979]     if (FALSE) {
[16:17:49.979]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:49.979]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:49.979]     }
[16:17:49.979]     ...future.result <- base::tryCatch({
[16:17:49.979]         base::withCallingHandlers({
[16:17:49.979]             ...future.value <- base::withVisible(base::local({
[16:17:49.979]                 do.call(function(...) {
[16:17:49.979]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.979]                   if (!identical(...future.globals.maxSize.org, 
[16:17:49.979]                     ...future.globals.maxSize)) {
[16:17:49.979]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.979]                     on.exit(options(oopts), add = TRUE)
[16:17:49.979]                   }
[16:17:49.979]                   {
[16:17:49.979]                     lapply(seq_along(...future.elements_ii), 
[16:17:49.979]                       FUN = function(jj) {
[16:17:49.979]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.979]                         ...future.FUN(...future.X_jj, ...)
[16:17:49.979]                       })
[16:17:49.979]                   }
[16:17:49.979]                 }, args = future.call.arguments)
[16:17:49.979]             }))
[16:17:49.979]             future::FutureResult(value = ...future.value$value, 
[16:17:49.979]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:49.979]                   ...future.rng), globalenv = if (FALSE) 
[16:17:49.979]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:49.979]                     ...future.globalenv.names))
[16:17:49.979]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:49.979]         }, condition = base::local({
[16:17:49.979]             c <- base::c
[16:17:49.979]             inherits <- base::inherits
[16:17:49.979]             invokeRestart <- base::invokeRestart
[16:17:49.979]             length <- base::length
[16:17:49.979]             list <- base::list
[16:17:49.979]             seq.int <- base::seq.int
[16:17:49.979]             signalCondition <- base::signalCondition
[16:17:49.979]             sys.calls <- base::sys.calls
[16:17:49.979]             `[[` <- base::`[[`
[16:17:49.979]             `+` <- base::`+`
[16:17:49.979]             `<<-` <- base::`<<-`
[16:17:49.979]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:49.979]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:49.979]                   3L)]
[16:17:49.979]             }
[16:17:49.979]             function(cond) {
[16:17:49.979]                 is_error <- inherits(cond, "error")
[16:17:49.979]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:49.979]                   NULL)
[16:17:49.979]                 if (is_error) {
[16:17:49.979]                   sessionInformation <- function() {
[16:17:49.979]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:49.979]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:49.979]                       search = base::search(), system = base::Sys.info())
[16:17:49.979]                   }
[16:17:49.979]                   ...future.conditions[[length(...future.conditions) + 
[16:17:49.979]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:49.979]                     cond$call), session = sessionInformation(), 
[16:17:49.979]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:49.979]                   signalCondition(cond)
[16:17:49.979]                 }
[16:17:49.979]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:49.979]                 "immediateCondition"))) {
[16:17:49.979]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:49.979]                   ...future.conditions[[length(...future.conditions) + 
[16:17:49.979]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:49.979]                   if (TRUE && !signal) {
[16:17:49.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.979]                     {
[16:17:49.979]                       inherits <- base::inherits
[16:17:49.979]                       invokeRestart <- base::invokeRestart
[16:17:49.979]                       is.null <- base::is.null
[16:17:49.979]                       muffled <- FALSE
[16:17:49.979]                       if (inherits(cond, "message")) {
[16:17:49.979]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:49.979]                         if (muffled) 
[16:17:49.979]                           invokeRestart("muffleMessage")
[16:17:49.979]                       }
[16:17:49.979]                       else if (inherits(cond, "warning")) {
[16:17:49.979]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:49.979]                         if (muffled) 
[16:17:49.979]                           invokeRestart("muffleWarning")
[16:17:49.979]                       }
[16:17:49.979]                       else if (inherits(cond, "condition")) {
[16:17:49.979]                         if (!is.null(pattern)) {
[16:17:49.979]                           computeRestarts <- base::computeRestarts
[16:17:49.979]                           grepl <- base::grepl
[16:17:49.979]                           restarts <- computeRestarts(cond)
[16:17:49.979]                           for (restart in restarts) {
[16:17:49.979]                             name <- restart$name
[16:17:49.979]                             if (is.null(name)) 
[16:17:49.979]                               next
[16:17:49.979]                             if (!grepl(pattern, name)) 
[16:17:49.979]                               next
[16:17:49.979]                             invokeRestart(restart)
[16:17:49.979]                             muffled <- TRUE
[16:17:49.979]                             break
[16:17:49.979]                           }
[16:17:49.979]                         }
[16:17:49.979]                       }
[16:17:49.979]                       invisible(muffled)
[16:17:49.979]                     }
[16:17:49.979]                     muffleCondition(cond, pattern = "^muffle")
[16:17:49.979]                   }
[16:17:49.979]                 }
[16:17:49.979]                 else {
[16:17:49.979]                   if (TRUE) {
[16:17:49.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:49.979]                     {
[16:17:49.979]                       inherits <- base::inherits
[16:17:49.979]                       invokeRestart <- base::invokeRestart
[16:17:49.979]                       is.null <- base::is.null
[16:17:49.979]                       muffled <- FALSE
[16:17:49.979]                       if (inherits(cond, "message")) {
[16:17:49.979]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:49.979]                         if (muffled) 
[16:17:49.979]                           invokeRestart("muffleMessage")
[16:17:49.979]                       }
[16:17:49.979]                       else if (inherits(cond, "warning")) {
[16:17:49.979]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:49.979]                         if (muffled) 
[16:17:49.979]                           invokeRestart("muffleWarning")
[16:17:49.979]                       }
[16:17:49.979]                       else if (inherits(cond, "condition")) {
[16:17:49.979]                         if (!is.null(pattern)) {
[16:17:49.979]                           computeRestarts <- base::computeRestarts
[16:17:49.979]                           grepl <- base::grepl
[16:17:49.979]                           restarts <- computeRestarts(cond)
[16:17:49.979]                           for (restart in restarts) {
[16:17:49.979]                             name <- restart$name
[16:17:49.979]                             if (is.null(name)) 
[16:17:49.979]                               next
[16:17:49.979]                             if (!grepl(pattern, name)) 
[16:17:49.979]                               next
[16:17:49.979]                             invokeRestart(restart)
[16:17:49.979]                             muffled <- TRUE
[16:17:49.979]                             break
[16:17:49.979]                           }
[16:17:49.979]                         }
[16:17:49.979]                       }
[16:17:49.979]                       invisible(muffled)
[16:17:49.979]                     }
[16:17:49.979]                     muffleCondition(cond, pattern = "^muffle")
[16:17:49.979]                   }
[16:17:49.979]                 }
[16:17:49.979]             }
[16:17:49.979]         }))
[16:17:49.979]     }, error = function(ex) {
[16:17:49.979]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:49.979]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:49.979]                 ...future.rng), started = ...future.startTime, 
[16:17:49.979]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:49.979]             version = "1.8"), class = "FutureResult")
[16:17:49.979]     }, finally = {
[16:17:49.979]         if (!identical(...future.workdir, getwd())) 
[16:17:49.979]             setwd(...future.workdir)
[16:17:49.979]         {
[16:17:49.979]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:49.979]                 ...future.oldOptions$nwarnings <- NULL
[16:17:49.979]             }
[16:17:49.979]             base::options(...future.oldOptions)
[16:17:49.979]             if (.Platform$OS.type == "windows") {
[16:17:49.979]                 old_names <- names(...future.oldEnvVars)
[16:17:49.979]                 envs <- base::Sys.getenv()
[16:17:49.979]                 names <- names(envs)
[16:17:49.979]                 common <- intersect(names, old_names)
[16:17:49.979]                 added <- setdiff(names, old_names)
[16:17:49.979]                 removed <- setdiff(old_names, names)
[16:17:49.979]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:49.979]                   envs[common]]
[16:17:49.979]                 NAMES <- toupper(changed)
[16:17:49.979]                 args <- list()
[16:17:49.979]                 for (kk in seq_along(NAMES)) {
[16:17:49.979]                   name <- changed[[kk]]
[16:17:49.979]                   NAME <- NAMES[[kk]]
[16:17:49.979]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.979]                     next
[16:17:49.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:49.979]                 }
[16:17:49.979]                 NAMES <- toupper(added)
[16:17:49.979]                 for (kk in seq_along(NAMES)) {
[16:17:49.979]                   name <- added[[kk]]
[16:17:49.979]                   NAME <- NAMES[[kk]]
[16:17:49.979]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.979]                     next
[16:17:49.979]                   args[[name]] <- ""
[16:17:49.979]                 }
[16:17:49.979]                 NAMES <- toupper(removed)
[16:17:49.979]                 for (kk in seq_along(NAMES)) {
[16:17:49.979]                   name <- removed[[kk]]
[16:17:49.979]                   NAME <- NAMES[[kk]]
[16:17:49.979]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:49.979]                     next
[16:17:49.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:49.979]                 }
[16:17:49.979]                 if (length(args) > 0) 
[16:17:49.979]                   base::do.call(base::Sys.setenv, args = args)
[16:17:49.979]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:49.979]             }
[16:17:49.979]             else {
[16:17:49.979]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:49.979]             }
[16:17:49.979]             {
[16:17:49.979]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:49.979]                   0L) {
[16:17:49.979]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:49.979]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:49.979]                   base::options(opts)
[16:17:49.979]                 }
[16:17:49.979]                 {
[16:17:49.979]                   {
[16:17:49.979]                     NULL
[16:17:49.979]                     RNGkind("Mersenne-Twister")
[16:17:49.979]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:49.979]                       inherits = FALSE)
[16:17:49.979]                   }
[16:17:49.979]                   options(future.plan = NULL)
[16:17:49.979]                   if (is.na(NA_character_)) 
[16:17:49.979]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:49.979]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:49.979]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:49.979]                     .init = FALSE)
[16:17:49.979]                 }
[16:17:49.979]             }
[16:17:49.979]         }
[16:17:49.979]     })
[16:17:49.979]     if (TRUE) {
[16:17:49.979]         base::sink(type = "output", split = FALSE)
[16:17:49.979]         if (TRUE) {
[16:17:49.979]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:49.979]         }
[16:17:49.979]         else {
[16:17:49.979]             ...future.result["stdout"] <- base::list(NULL)
[16:17:49.979]         }
[16:17:49.979]         base::close(...future.stdout)
[16:17:49.979]         ...future.stdout <- NULL
[16:17:49.979]     }
[16:17:49.979]     ...future.result$conditions <- ...future.conditions
[16:17:49.979]     ...future.result$finished <- base::Sys.time()
[16:17:49.979]     ...future.result
[16:17:49.979] }
[16:17:49.981] assign_globals() ...
[16:17:49.981] List of 5
[16:17:49.981]  $ ...future.FUN            :function (x, ...)  
[16:17:49.981]  $ future.call.arguments    : list()
[16:17:49.981]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:49.981]  $ ...future.elements_ii    :List of 3
[16:17:49.981]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[16:17:49.981]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:17:49.981]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:17:49.981]  $ ...future.seeds_ii       : NULL
[16:17:49.981]  $ ...future.globals.maxSize: NULL
[16:17:49.981]  - attr(*, "where")=List of 5
[16:17:49.981]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:49.981]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:49.981]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:49.981]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:49.981]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:49.981]  - attr(*, "resolved")= logi FALSE
[16:17:49.981]  - attr(*, "total_size")= num 1240
[16:17:49.981]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:49.981]  - attr(*, "already-done")= logi TRUE
[16:17:49.986] - copied ‘...future.FUN’ to environment
[16:17:49.986] - copied ‘future.call.arguments’ to environment
[16:17:49.986] - copied ‘...future.elements_ii’ to environment
[16:17:49.986] - copied ‘...future.seeds_ii’ to environment
[16:17:49.986] - copied ‘...future.globals.maxSize’ to environment
[16:17:49.987] assign_globals() ... done
[16:17:49.987] plan(): Setting new future strategy stack:
[16:17:49.987] List of future strategies:
[16:17:49.987] 1. sequential:
[16:17:49.987]    - args: function (..., envir = parent.frame())
[16:17:49.987]    - tweaked: FALSE
[16:17:49.987]    - call: NULL
[16:17:49.987] plan(): nbrOfWorkers() = 1
[16:17:49.988] plan(): Setting new future strategy stack:
[16:17:49.989] List of future strategies:
[16:17:49.989] 1. sequential:
[16:17:49.989]    - args: function (..., envir = parent.frame())
[16:17:49.989]    - tweaked: FALSE
[16:17:49.989]    - call: plan(strategy)
[16:17:49.989] plan(): nbrOfWorkers() = 1
[16:17:49.989] SequentialFuture started (and completed)
[16:17:49.989] - Launch lazy future ... done
[16:17:49.990] run() for ‘SequentialFuture’ ... done
[16:17:49.990] Created future:
[16:17:49.990] SequentialFuture:
[16:17:49.990] Label: ‘future_eapply-1’
[16:17:49.990] Expression:
[16:17:49.990] {
[16:17:49.990]     do.call(function(...) {
[16:17:49.990]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:49.990]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:49.990]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:49.990]             on.exit(options(oopts), add = TRUE)
[16:17:49.990]         }
[16:17:49.990]         {
[16:17:49.990]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:49.990]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:49.990]                 ...future.FUN(...future.X_jj, ...)
[16:17:49.990]             })
[16:17:49.990]         }
[16:17:49.990]     }, args = future.call.arguments)
[16:17:49.990] }
[16:17:49.990] Lazy evaluation: FALSE
[16:17:49.990] Asynchronous evaluation: FALSE
[16:17:49.990] Local evaluation: TRUE
[16:17:49.990] Environment: R_GlobalEnv
[16:17:49.990] Capture standard output: TRUE
[16:17:49.990] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:49.990] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:49.990] Packages: <none>
[16:17:49.990] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:49.990] Resolved: TRUE
[16:17:49.990] Value: 168 bytes of class ‘list’
[16:17:49.990] Early signaling: FALSE
[16:17:49.990] Owner process: 95d59565-e757-824f-7f5c-7f754384cffc
[16:17:49.990] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:49.991] Chunk #1 of 1 ... DONE
[16:17:49.991] Launching 1 futures (chunks) ... DONE
[16:17:49.991] Resolving 1 futures (chunks) ...
[16:17:49.992] resolve() on list ...
[16:17:49.992]  recursive: 0
[16:17:49.992]  length: 1
[16:17:49.992] 
[16:17:49.992] resolved() for ‘SequentialFuture’ ...
[16:17:49.992] - state: ‘finished’
[16:17:49.992] - run: TRUE
[16:17:49.992] - result: ‘FutureResult’
[16:17:49.992] resolved() for ‘SequentialFuture’ ... done
[16:17:49.992] Future #1
[16:17:49.993] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:49.993] - nx: 1
[16:17:49.993] - relay: TRUE
[16:17:49.993] - stdout: TRUE
[16:17:49.993] - signal: TRUE
[16:17:49.993] - resignal: FALSE
[16:17:49.993] - force: TRUE
[16:17:49.993] - relayed: [n=1] FALSE
[16:17:49.994] - queued futures: [n=1] FALSE
[16:17:49.994]  - until=1
[16:17:49.994]  - relaying element #1
[16:17:49.994] - relayed: [n=1] TRUE
[16:17:49.994] - queued futures: [n=1] TRUE
[16:17:49.994] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:49.994]  length: 0 (resolved future 1)
[16:17:49.994] Relaying remaining futures
[16:17:49.995] signalConditionsASAP(NULL, pos=0) ...
[16:17:49.995] - nx: 1
[16:17:49.995] - relay: TRUE
[16:17:49.995] - stdout: TRUE
[16:17:49.995] - signal: TRUE
[16:17:49.995] - resignal: FALSE
[16:17:49.995] - force: TRUE
[16:17:49.995] - relayed: [n=1] TRUE
[16:17:49.995] - queued futures: [n=1] TRUE
 - flush all
[16:17:49.995] - relayed: [n=1] TRUE
[16:17:49.995] - queued futures: [n=1] TRUE
[16:17:49.995] signalConditionsASAP(NULL, pos=0) ... done
[16:17:49.996] resolve() on list ... DONE
[16:17:49.996]  - Number of value chunks collected: 1
[16:17:49.996] Resolving 1 futures (chunks) ... DONE
[16:17:49.996] Reducing values from 1 chunks ...
[16:17:49.996]  - Number of values collected after concatenation: 3
[16:17:49.996]  - Number of values expected: 3
[16:17:49.996] Reducing values from 1 chunks ... DONE
[16:17:49.996] future_lapply() ... DONE
[16:17:49.999] future_lapply() ...
[16:17:49.999] Number of chunks: 1
[16:17:49.999] getGlobalsAndPackagesXApply() ...
[16:17:49.999]  - future.globals: TRUE
[16:17:50.000] getGlobalsAndPackages() ...
[16:17:50.000] Searching for globals...
[16:17:50.001] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:50.001] Searching for globals ... DONE
[16:17:50.001] Resolving globals: FALSE
[16:17:50.001] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:17:50.002] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:17:50.002] - globals: [1] ‘FUN’
[16:17:50.002] - packages: [1] ‘stats’
[16:17:50.002] getGlobalsAndPackages() ... DONE
[16:17:50.002]  - globals found/used: [n=1] ‘FUN’
[16:17:50.002]  - needed namespaces: [n=1] ‘stats’
[16:17:50.002] Finding globals ... DONE
[16:17:50.002]  - use_args: TRUE
[16:17:50.002]  - Getting '...' globals ...
[16:17:50.003] resolve() on list ...
[16:17:50.003]  recursive: 0
[16:17:50.003]  length: 1
[16:17:50.003]  elements: ‘...’
[16:17:50.003]  length: 0 (resolved future 1)
[16:17:50.003] resolve() on list ... DONE
[16:17:50.003]    - '...' content: [n=1] ‘probs’
[16:17:50.003] List of 1
[16:17:50.003]  $ ...:List of 1
[16:17:50.003]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:17:50.003]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:50.003]  - attr(*, "where")=List of 1
[16:17:50.003]   ..$ ...:<environment: 0x556da4e72528> 
[16:17:50.003]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:50.003]  - attr(*, "resolved")= logi TRUE
[16:17:50.003]  - attr(*, "total_size")= num NA
[16:17:50.007]  - Getting '...' globals ... DONE
[16:17:50.007] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:50.008] List of 2
[16:17:50.008]  $ ...future.FUN:function (x, ...)  
[16:17:50.008]  $ ...          :List of 1
[16:17:50.008]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:17:50.008]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:50.008]  - attr(*, "where")=List of 2
[16:17:50.008]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:50.008]   ..$ ...          :<environment: 0x556da4e72528> 
[16:17:50.008]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:50.008]  - attr(*, "resolved")= logi FALSE
[16:17:50.008]  - attr(*, "total_size")= num 1328
[16:17:50.011] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:50.011] getGlobalsAndPackagesXApply() ... DONE
[16:17:50.011] Number of futures (= number of chunks): 1
[16:17:50.011] Launching 1 futures (chunks) ...
[16:17:50.011] Chunk #1 of 1 ...
[16:17:50.011]  - Finding globals in 'X' for chunk #1 ...
[16:17:50.011] getGlobalsAndPackages() ...
[16:17:50.011] Searching for globals...
[16:17:50.012] 
[16:17:50.012] Searching for globals ... DONE
[16:17:50.012] - globals: [0] <none>
[16:17:50.012] getGlobalsAndPackages() ... DONE
[16:17:50.012]    + additional globals found: [n=0] 
[16:17:50.012]    + additional namespaces needed: [n=0] 
[16:17:50.012]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:50.012]  - seeds: <none>
[16:17:50.012]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.012] getGlobalsAndPackages() ...
[16:17:50.013] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.013] Resolving globals: FALSE
[16:17:50.013] Tweak future expression to call with '...' arguments ...
[16:17:50.013] {
[16:17:50.013]     do.call(function(...) {
[16:17:50.013]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.013]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:50.013]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.013]             on.exit(options(oopts), add = TRUE)
[16:17:50.013]         }
[16:17:50.013]         {
[16:17:50.013]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:50.013]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.013]                 ...future.FUN(...future.X_jj, ...)
[16:17:50.013]             })
[16:17:50.013]         }
[16:17:50.013]     }, args = future.call.arguments)
[16:17:50.013] }
[16:17:50.013] Tweak future expression to call with '...' arguments ... DONE
[16:17:50.013] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.014] - packages: [1] ‘stats’
[16:17:50.014] getGlobalsAndPackages() ... DONE
[16:17:50.014] run() for ‘Future’ ...
[16:17:50.014] - state: ‘created’
[16:17:50.014] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:17:50.014] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:50.015] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:50.015]   - Field: ‘label’
[16:17:50.015]   - Field: ‘local’
[16:17:50.015]   - Field: ‘owner’
[16:17:50.015]   - Field: ‘envir’
[16:17:50.015]   - Field: ‘packages’
[16:17:50.015]   - Field: ‘gc’
[16:17:50.015]   - Field: ‘conditions’
[16:17:50.015]   - Field: ‘expr’
[16:17:50.015]   - Field: ‘uuid’
[16:17:50.015]   - Field: ‘seed’
[16:17:50.016]   - Field: ‘version’
[16:17:50.016]   - Field: ‘result’
[16:17:50.016]   - Field: ‘asynchronous’
[16:17:50.016]   - Field: ‘calls’
[16:17:50.016]   - Field: ‘globals’
[16:17:50.016]   - Field: ‘stdout’
[16:17:50.016]   - Field: ‘earlySignal’
[16:17:50.016]   - Field: ‘lazy’
[16:17:50.016]   - Field: ‘state’
[16:17:50.016] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:50.016] - Launch lazy future ...
[16:17:50.017] Packages needed by the future expression (n = 1): ‘stats’
[16:17:50.017] Packages needed by future strategies (n = 0): <none>
[16:17:50.017] {
[16:17:50.017]     {
[16:17:50.017]         {
[16:17:50.017]             ...future.startTime <- base::Sys.time()
[16:17:50.017]             {
[16:17:50.017]                 {
[16:17:50.017]                   {
[16:17:50.017]                     {
[16:17:50.017]                       base::local({
[16:17:50.017]                         has_future <- base::requireNamespace("future", 
[16:17:50.017]                           quietly = TRUE)
[16:17:50.017]                         if (has_future) {
[16:17:50.017]                           ns <- base::getNamespace("future")
[16:17:50.017]                           version <- ns[[".package"]][["version"]]
[16:17:50.017]                           if (is.null(version)) 
[16:17:50.017]                             version <- utils::packageVersion("future")
[16:17:50.017]                         }
[16:17:50.017]                         else {
[16:17:50.017]                           version <- NULL
[16:17:50.017]                         }
[16:17:50.017]                         if (!has_future || version < "1.8.0") {
[16:17:50.017]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:50.017]                             "", base::R.version$version.string), 
[16:17:50.017]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:50.017]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:50.017]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:50.017]                               "release", "version")], collapse = " "), 
[16:17:50.017]                             hostname = base::Sys.info()[["nodename"]])
[16:17:50.017]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:50.017]                             info)
[16:17:50.017]                           info <- base::paste(info, collapse = "; ")
[16:17:50.017]                           if (!has_future) {
[16:17:50.017]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:50.017]                               info)
[16:17:50.017]                           }
[16:17:50.017]                           else {
[16:17:50.017]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:50.017]                               info, version)
[16:17:50.017]                           }
[16:17:50.017]                           base::stop(msg)
[16:17:50.017]                         }
[16:17:50.017]                       })
[16:17:50.017]                     }
[16:17:50.017]                     base::local({
[16:17:50.017]                       for (pkg in "stats") {
[16:17:50.017]                         base::loadNamespace(pkg)
[16:17:50.017]                         base::library(pkg, character.only = TRUE)
[16:17:50.017]                       }
[16:17:50.017]                     })
[16:17:50.017]                   }
[16:17:50.017]                   ...future.strategy.old <- future::plan("list")
[16:17:50.017]                   options(future.plan = NULL)
[16:17:50.017]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:50.017]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:50.017]                 }
[16:17:50.017]                 ...future.workdir <- getwd()
[16:17:50.017]             }
[16:17:50.017]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:50.017]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:50.017]         }
[16:17:50.017]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:50.017]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:50.017]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:50.017]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:50.017]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:50.017]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:50.017]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:50.017]             base::names(...future.oldOptions))
[16:17:50.017]     }
[16:17:50.017]     if (FALSE) {
[16:17:50.017]     }
[16:17:50.017]     else {
[16:17:50.017]         if (TRUE) {
[16:17:50.017]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:50.017]                 open = "w")
[16:17:50.017]         }
[16:17:50.017]         else {
[16:17:50.017]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:50.017]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:50.017]         }
[16:17:50.017]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:50.017]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:50.017]             base::sink(type = "output", split = FALSE)
[16:17:50.017]             base::close(...future.stdout)
[16:17:50.017]         }, add = TRUE)
[16:17:50.017]     }
[16:17:50.017]     ...future.frame <- base::sys.nframe()
[16:17:50.017]     ...future.conditions <- base::list()
[16:17:50.017]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:50.017]     if (FALSE) {
[16:17:50.017]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:50.017]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:50.017]     }
[16:17:50.017]     ...future.result <- base::tryCatch({
[16:17:50.017]         base::withCallingHandlers({
[16:17:50.017]             ...future.value <- base::withVisible(base::local({
[16:17:50.017]                 do.call(function(...) {
[16:17:50.017]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.017]                   if (!identical(...future.globals.maxSize.org, 
[16:17:50.017]                     ...future.globals.maxSize)) {
[16:17:50.017]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.017]                     on.exit(options(oopts), add = TRUE)
[16:17:50.017]                   }
[16:17:50.017]                   {
[16:17:50.017]                     lapply(seq_along(...future.elements_ii), 
[16:17:50.017]                       FUN = function(jj) {
[16:17:50.017]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.017]                         ...future.FUN(...future.X_jj, ...)
[16:17:50.017]                       })
[16:17:50.017]                   }
[16:17:50.017]                 }, args = future.call.arguments)
[16:17:50.017]             }))
[16:17:50.017]             future::FutureResult(value = ...future.value$value, 
[16:17:50.017]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:50.017]                   ...future.rng), globalenv = if (FALSE) 
[16:17:50.017]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:50.017]                     ...future.globalenv.names))
[16:17:50.017]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:50.017]         }, condition = base::local({
[16:17:50.017]             c <- base::c
[16:17:50.017]             inherits <- base::inherits
[16:17:50.017]             invokeRestart <- base::invokeRestart
[16:17:50.017]             length <- base::length
[16:17:50.017]             list <- base::list
[16:17:50.017]             seq.int <- base::seq.int
[16:17:50.017]             signalCondition <- base::signalCondition
[16:17:50.017]             sys.calls <- base::sys.calls
[16:17:50.017]             `[[` <- base::`[[`
[16:17:50.017]             `+` <- base::`+`
[16:17:50.017]             `<<-` <- base::`<<-`
[16:17:50.017]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:50.017]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:50.017]                   3L)]
[16:17:50.017]             }
[16:17:50.017]             function(cond) {
[16:17:50.017]                 is_error <- inherits(cond, "error")
[16:17:50.017]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:50.017]                   NULL)
[16:17:50.017]                 if (is_error) {
[16:17:50.017]                   sessionInformation <- function() {
[16:17:50.017]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:50.017]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:50.017]                       search = base::search(), system = base::Sys.info())
[16:17:50.017]                   }
[16:17:50.017]                   ...future.conditions[[length(...future.conditions) + 
[16:17:50.017]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:50.017]                     cond$call), session = sessionInformation(), 
[16:17:50.017]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:50.017]                   signalCondition(cond)
[16:17:50.017]                 }
[16:17:50.017]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:50.017]                 "immediateCondition"))) {
[16:17:50.017]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:50.017]                   ...future.conditions[[length(...future.conditions) + 
[16:17:50.017]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:50.017]                   if (TRUE && !signal) {
[16:17:50.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.017]                     {
[16:17:50.017]                       inherits <- base::inherits
[16:17:50.017]                       invokeRestart <- base::invokeRestart
[16:17:50.017]                       is.null <- base::is.null
[16:17:50.017]                       muffled <- FALSE
[16:17:50.017]                       if (inherits(cond, "message")) {
[16:17:50.017]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:50.017]                         if (muffled) 
[16:17:50.017]                           invokeRestart("muffleMessage")
[16:17:50.017]                       }
[16:17:50.017]                       else if (inherits(cond, "warning")) {
[16:17:50.017]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:50.017]                         if (muffled) 
[16:17:50.017]                           invokeRestart("muffleWarning")
[16:17:50.017]                       }
[16:17:50.017]                       else if (inherits(cond, "condition")) {
[16:17:50.017]                         if (!is.null(pattern)) {
[16:17:50.017]                           computeRestarts <- base::computeRestarts
[16:17:50.017]                           grepl <- base::grepl
[16:17:50.017]                           restarts <- computeRestarts(cond)
[16:17:50.017]                           for (restart in restarts) {
[16:17:50.017]                             name <- restart$name
[16:17:50.017]                             if (is.null(name)) 
[16:17:50.017]                               next
[16:17:50.017]                             if (!grepl(pattern, name)) 
[16:17:50.017]                               next
[16:17:50.017]                             invokeRestart(restart)
[16:17:50.017]                             muffled <- TRUE
[16:17:50.017]                             break
[16:17:50.017]                           }
[16:17:50.017]                         }
[16:17:50.017]                       }
[16:17:50.017]                       invisible(muffled)
[16:17:50.017]                     }
[16:17:50.017]                     muffleCondition(cond, pattern = "^muffle")
[16:17:50.017]                   }
[16:17:50.017]                 }
[16:17:50.017]                 else {
[16:17:50.017]                   if (TRUE) {
[16:17:50.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.017]                     {
[16:17:50.017]                       inherits <- base::inherits
[16:17:50.017]                       invokeRestart <- base::invokeRestart
[16:17:50.017]                       is.null <- base::is.null
[16:17:50.017]                       muffled <- FALSE
[16:17:50.017]                       if (inherits(cond, "message")) {
[16:17:50.017]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:50.017]                         if (muffled) 
[16:17:50.017]                           invokeRestart("muffleMessage")
[16:17:50.017]                       }
[16:17:50.017]                       else if (inherits(cond, "warning")) {
[16:17:50.017]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:50.017]                         if (muffled) 
[16:17:50.017]                           invokeRestart("muffleWarning")
[16:17:50.017]                       }
[16:17:50.017]                       else if (inherits(cond, "condition")) {
[16:17:50.017]                         if (!is.null(pattern)) {
[16:17:50.017]                           computeRestarts <- base::computeRestarts
[16:17:50.017]                           grepl <- base::grepl
[16:17:50.017]                           restarts <- computeRestarts(cond)
[16:17:50.017]                           for (restart in restarts) {
[16:17:50.017]                             name <- restart$name
[16:17:50.017]                             if (is.null(name)) 
[16:17:50.017]                               next
[16:17:50.017]                             if (!grepl(pattern, name)) 
[16:17:50.017]                               next
[16:17:50.017]                             invokeRestart(restart)
[16:17:50.017]                             muffled <- TRUE
[16:17:50.017]                             break
[16:17:50.017]                           }
[16:17:50.017]                         }
[16:17:50.017]                       }
[16:17:50.017]                       invisible(muffled)
[16:17:50.017]                     }
[16:17:50.017]                     muffleCondition(cond, pattern = "^muffle")
[16:17:50.017]                   }
[16:17:50.017]                 }
[16:17:50.017]             }
[16:17:50.017]         }))
[16:17:50.017]     }, error = function(ex) {
[16:17:50.017]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:50.017]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:50.017]                 ...future.rng), started = ...future.startTime, 
[16:17:50.017]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:50.017]             version = "1.8"), class = "FutureResult")
[16:17:50.017]     }, finally = {
[16:17:50.017]         if (!identical(...future.workdir, getwd())) 
[16:17:50.017]             setwd(...future.workdir)
[16:17:50.017]         {
[16:17:50.017]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:50.017]                 ...future.oldOptions$nwarnings <- NULL
[16:17:50.017]             }
[16:17:50.017]             base::options(...future.oldOptions)
[16:17:50.017]             if (.Platform$OS.type == "windows") {
[16:17:50.017]                 old_names <- names(...future.oldEnvVars)
[16:17:50.017]                 envs <- base::Sys.getenv()
[16:17:50.017]                 names <- names(envs)
[16:17:50.017]                 common <- intersect(names, old_names)
[16:17:50.017]                 added <- setdiff(names, old_names)
[16:17:50.017]                 removed <- setdiff(old_names, names)
[16:17:50.017]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:50.017]                   envs[common]]
[16:17:50.017]                 NAMES <- toupper(changed)
[16:17:50.017]                 args <- list()
[16:17:50.017]                 for (kk in seq_along(NAMES)) {
[16:17:50.017]                   name <- changed[[kk]]
[16:17:50.017]                   NAME <- NAMES[[kk]]
[16:17:50.017]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.017]                     next
[16:17:50.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:50.017]                 }
[16:17:50.017]                 NAMES <- toupper(added)
[16:17:50.017]                 for (kk in seq_along(NAMES)) {
[16:17:50.017]                   name <- added[[kk]]
[16:17:50.017]                   NAME <- NAMES[[kk]]
[16:17:50.017]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.017]                     next
[16:17:50.017]                   args[[name]] <- ""
[16:17:50.017]                 }
[16:17:50.017]                 NAMES <- toupper(removed)
[16:17:50.017]                 for (kk in seq_along(NAMES)) {
[16:17:50.017]                   name <- removed[[kk]]
[16:17:50.017]                   NAME <- NAMES[[kk]]
[16:17:50.017]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.017]                     next
[16:17:50.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:50.017]                 }
[16:17:50.017]                 if (length(args) > 0) 
[16:17:50.017]                   base::do.call(base::Sys.setenv, args = args)
[16:17:50.017]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:50.017]             }
[16:17:50.017]             else {
[16:17:50.017]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:50.017]             }
[16:17:50.017]             {
[16:17:50.017]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:50.017]                   0L) {
[16:17:50.017]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:50.017]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:50.017]                   base::options(opts)
[16:17:50.017]                 }
[16:17:50.017]                 {
[16:17:50.017]                   {
[16:17:50.017]                     NULL
[16:17:50.017]                     RNGkind("Mersenne-Twister")
[16:17:50.017]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:50.017]                       inherits = FALSE)
[16:17:50.017]                   }
[16:17:50.017]                   options(future.plan = NULL)
[16:17:50.017]                   if (is.na(NA_character_)) 
[16:17:50.017]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:50.017]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:50.017]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:50.017]                     .init = FALSE)
[16:17:50.017]                 }
[16:17:50.017]             }
[16:17:50.017]         }
[16:17:50.017]     })
[16:17:50.017]     if (TRUE) {
[16:17:50.017]         base::sink(type = "output", split = FALSE)
[16:17:50.017]         if (TRUE) {
[16:17:50.017]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:50.017]         }
[16:17:50.017]         else {
[16:17:50.017]             ...future.result["stdout"] <- base::list(NULL)
[16:17:50.017]         }
[16:17:50.017]         base::close(...future.stdout)
[16:17:50.017]         ...future.stdout <- NULL
[16:17:50.017]     }
[16:17:50.017]     ...future.result$conditions <- ...future.conditions
[16:17:50.017]     ...future.result$finished <- base::Sys.time()
[16:17:50.017]     ...future.result
[16:17:50.017] }
[16:17:50.019] assign_globals() ...
[16:17:50.019] List of 5
[16:17:50.019]  $ ...future.FUN            :function (x, ...)  
[16:17:50.019]  $ future.call.arguments    :List of 1
[16:17:50.019]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:17:50.019]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:50.019]  $ ...future.elements_ii    :List of 3
[16:17:50.019]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:17:50.019]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:17:50.019]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:17:50.019]  $ ...future.seeds_ii       : NULL
[16:17:50.019]  $ ...future.globals.maxSize: NULL
[16:17:50.019]  - attr(*, "where")=List of 5
[16:17:50.019]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:50.019]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:50.019]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:50.019]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:50.019]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:50.019]  - attr(*, "resolved")= logi FALSE
[16:17:50.019]  - attr(*, "total_size")= num 1328
[16:17:50.019]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:50.019]  - attr(*, "already-done")= logi TRUE
[16:17:50.024] - copied ‘...future.FUN’ to environment
[16:17:50.024] - copied ‘future.call.arguments’ to environment
[16:17:50.024] - copied ‘...future.elements_ii’ to environment
[16:17:50.025] - copied ‘...future.seeds_ii’ to environment
[16:17:50.025] - copied ‘...future.globals.maxSize’ to environment
[16:17:50.025] assign_globals() ... done
[16:17:50.025] plan(): Setting new future strategy stack:
[16:17:50.025] List of future strategies:
[16:17:50.025] 1. sequential:
[16:17:50.025]    - args: function (..., envir = parent.frame())
[16:17:50.025]    - tweaked: FALSE
[16:17:50.025]    - call: NULL
[16:17:50.026] plan(): nbrOfWorkers() = 1
[16:17:50.027] plan(): Setting new future strategy stack:
[16:17:50.027] List of future strategies:
[16:17:50.027] 1. sequential:
[16:17:50.027]    - args: function (..., envir = parent.frame())
[16:17:50.027]    - tweaked: FALSE
[16:17:50.027]    - call: plan(strategy)
[16:17:50.027] plan(): nbrOfWorkers() = 1
[16:17:50.027] SequentialFuture started (and completed)
[16:17:50.027] - Launch lazy future ... done
[16:17:50.027] run() for ‘SequentialFuture’ ... done
[16:17:50.027] Created future:
[16:17:50.028] SequentialFuture:
[16:17:50.028] Label: ‘future_eapply-1’
[16:17:50.028] Expression:
[16:17:50.028] {
[16:17:50.028]     do.call(function(...) {
[16:17:50.028]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.028]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:50.028]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.028]             on.exit(options(oopts), add = TRUE)
[16:17:50.028]         }
[16:17:50.028]         {
[16:17:50.028]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:50.028]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.028]                 ...future.FUN(...future.X_jj, ...)
[16:17:50.028]             })
[16:17:50.028]         }
[16:17:50.028]     }, args = future.call.arguments)
[16:17:50.028] }
[16:17:50.028] Lazy evaluation: FALSE
[16:17:50.028] Asynchronous evaluation: FALSE
[16:17:50.028] Local evaluation: TRUE
[16:17:50.028] Environment: R_GlobalEnv
[16:17:50.028] Capture standard output: TRUE
[16:17:50.028] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:50.028] Globals: 5 objects totaling 1.56 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:50.028] Packages: 1 packages (‘stats’)
[16:17:50.028] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:50.028] Resolved: TRUE
[16:17:50.028] Value: 1.29 KiB of class ‘list’
[16:17:50.028] Early signaling: FALSE
[16:17:50.028] Owner process: 95d59565-e757-824f-7f5c-7f754384cffc
[16:17:50.028] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:50.029] Chunk #1 of 1 ... DONE
[16:17:50.029] Launching 1 futures (chunks) ... DONE
[16:17:50.029] Resolving 1 futures (chunks) ...
[16:17:50.029] resolve() on list ...
[16:17:50.029]  recursive: 0
[16:17:50.029]  length: 1
[16:17:50.029] 
[16:17:50.029] resolved() for ‘SequentialFuture’ ...
[16:17:50.029] - state: ‘finished’
[16:17:50.029] - run: TRUE
[16:17:50.029] - result: ‘FutureResult’
[16:17:50.030] resolved() for ‘SequentialFuture’ ... done
[16:17:50.030] Future #1
[16:17:50.031] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:50.031] - nx: 1
[16:17:50.031] - relay: TRUE
[16:17:50.031] - stdout: TRUE
[16:17:50.031] - signal: TRUE
[16:17:50.031] - resignal: FALSE
[16:17:50.031] - force: TRUE
[16:17:50.031] - relayed: [n=1] FALSE
[16:17:50.031] - queued futures: [n=1] FALSE
[16:17:50.031]  - until=1
[16:17:50.031]  - relaying element #1
[16:17:50.032] - relayed: [n=1] TRUE
[16:17:50.032] - queued futures: [n=1] TRUE
[16:17:50.032] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:50.032]  length: 0 (resolved future 1)
[16:17:50.032] Relaying remaining futures
[16:17:50.032] signalConditionsASAP(NULL, pos=0) ...
[16:17:50.032] - nx: 1
[16:17:50.032] - relay: TRUE
[16:17:50.032] - stdout: TRUE
[16:17:50.033] - signal: TRUE
[16:17:50.033] - resignal: FALSE
[16:17:50.033] - force: TRUE
[16:17:50.033] - relayed: [n=1] TRUE
[16:17:50.033] - queued futures: [n=1] TRUE
 - flush all
[16:17:50.033] - relayed: [n=1] TRUE
[16:17:50.033] - queued futures: [n=1] TRUE
[16:17:50.033] signalConditionsASAP(NULL, pos=0) ... done
[16:17:50.033] resolve() on list ... DONE
[16:17:50.033]  - Number of value chunks collected: 1
[16:17:50.033] Resolving 1 futures (chunks) ... DONE
[16:17:50.034] Reducing values from 1 chunks ...
[16:17:50.034]  - Number of values collected after concatenation: 3
[16:17:50.034]  - Number of values expected: 3
[16:17:50.034] Reducing values from 1 chunks ... DONE
[16:17:50.034] future_lapply() ... DONE
[16:17:50.035] future_lapply() ...
[16:17:50.036] Number of chunks: 1
[16:17:50.036] getGlobalsAndPackagesXApply() ...
[16:17:50.036]  - future.globals: TRUE
[16:17:50.036] getGlobalsAndPackages() ...
[16:17:50.036] Searching for globals...
[16:17:50.037] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:50.037] Searching for globals ... DONE
[16:17:50.037] Resolving globals: FALSE
[16:17:50.037] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:17:50.038] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:17:50.038] - globals: [1] ‘FUN’
[16:17:50.038] - packages: [1] ‘stats’
[16:17:50.038] getGlobalsAndPackages() ... DONE
[16:17:50.038]  - globals found/used: [n=1] ‘FUN’
[16:17:50.038]  - needed namespaces: [n=1] ‘stats’
[16:17:50.038] Finding globals ... DONE
[16:17:50.039]  - use_args: TRUE
[16:17:50.039]  - Getting '...' globals ...
[16:17:50.039] resolve() on list ...
[16:17:50.039]  recursive: 0
[16:17:50.039]  length: 1
[16:17:50.039]  elements: ‘...’
[16:17:50.039]  length: 0 (resolved future 1)
[16:17:50.039] resolve() on list ... DONE
[16:17:50.039]    - '...' content: [n=0] 
[16:17:50.040] List of 1
[16:17:50.040]  $ ...: list()
[16:17:50.040]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:50.040]  - attr(*, "where")=List of 1
[16:17:50.040]   ..$ ...:<environment: 0x556da2e51920> 
[16:17:50.040]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:50.040]  - attr(*, "resolved")= logi TRUE
[16:17:50.040]  - attr(*, "total_size")= num NA
[16:17:50.042]  - Getting '...' globals ... DONE
[16:17:50.042] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:50.042] List of 2
[16:17:50.042]  $ ...future.FUN:function (x, ...)  
[16:17:50.042]  $ ...          : list()
[16:17:50.042]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:50.042]  - attr(*, "where")=List of 2
[16:17:50.042]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:50.042]   ..$ ...          :<environment: 0x556da2e51920> 
[16:17:50.042]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:50.042]  - attr(*, "resolved")= logi FALSE
[16:17:50.042]  - attr(*, "total_size")= num 1248
[16:17:50.045] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:50.045] getGlobalsAndPackagesXApply() ... DONE
[16:17:50.045] Number of futures (= number of chunks): 1
[16:17:50.045] Launching 1 futures (chunks) ...
[16:17:50.045] Chunk #1 of 1 ...
[16:17:50.045]  - Finding globals in 'X' for chunk #1 ...
[16:17:50.045] getGlobalsAndPackages() ...
[16:17:50.045] Searching for globals...
[16:17:50.046] 
[16:17:50.046] Searching for globals ... DONE
[16:17:50.046] - globals: [0] <none>
[16:17:50.046] getGlobalsAndPackages() ... DONE
[16:17:50.046]    + additional globals found: [n=0] 
[16:17:50.046]    + additional namespaces needed: [n=0] 
[16:17:50.046]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:50.046]  - seeds: <none>
[16:17:50.046]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.046] getGlobalsAndPackages() ...
[16:17:50.046] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.047] Resolving globals: FALSE
[16:17:50.047] Tweak future expression to call with '...' arguments ...
[16:17:50.047] {
[16:17:50.047]     do.call(function(...) {
[16:17:50.047]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.047]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:50.047]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.047]             on.exit(options(oopts), add = TRUE)
[16:17:50.047]         }
[16:17:50.047]         {
[16:17:50.047]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:50.047]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.047]                 ...future.FUN(...future.X_jj, ...)
[16:17:50.047]             })
[16:17:50.047]         }
[16:17:50.047]     }, args = future.call.arguments)
[16:17:50.047] }
[16:17:50.047] Tweak future expression to call with '...' arguments ... DONE
[16:17:50.047] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.047] - packages: [1] ‘stats’
[16:17:50.048] getGlobalsAndPackages() ... DONE
[16:17:50.048] run() for ‘Future’ ...
[16:17:50.048] - state: ‘created’
[16:17:50.048] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:17:50.048] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:50.048] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:50.048]   - Field: ‘label’
[16:17:50.049]   - Field: ‘local’
[16:17:50.049]   - Field: ‘owner’
[16:17:50.049]   - Field: ‘envir’
[16:17:50.049]   - Field: ‘packages’
[16:17:50.049]   - Field: ‘gc’
[16:17:50.049]   - Field: ‘conditions’
[16:17:50.049]   - Field: ‘expr’
[16:17:50.049]   - Field: ‘uuid’
[16:17:50.049]   - Field: ‘seed’
[16:17:50.049]   - Field: ‘version’
[16:17:50.049]   - Field: ‘result’
[16:17:50.049]   - Field: ‘asynchronous’
[16:17:50.050]   - Field: ‘calls’
[16:17:50.050]   - Field: ‘globals’
[16:17:50.050]   - Field: ‘stdout’
[16:17:50.050]   - Field: ‘earlySignal’
[16:17:50.050]   - Field: ‘lazy’
[16:17:50.050]   - Field: ‘state’
[16:17:50.050] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:50.050] - Launch lazy future ...
[16:17:50.050] Packages needed by the future expression (n = 1): ‘stats’
[16:17:50.050] Packages needed by future strategies (n = 0): <none>
[16:17:50.051] {
[16:17:50.051]     {
[16:17:50.051]         {
[16:17:50.051]             ...future.startTime <- base::Sys.time()
[16:17:50.051]             {
[16:17:50.051]                 {
[16:17:50.051]                   {
[16:17:50.051]                     {
[16:17:50.051]                       base::local({
[16:17:50.051]                         has_future <- base::requireNamespace("future", 
[16:17:50.051]                           quietly = TRUE)
[16:17:50.051]                         if (has_future) {
[16:17:50.051]                           ns <- base::getNamespace("future")
[16:17:50.051]                           version <- ns[[".package"]][["version"]]
[16:17:50.051]                           if (is.null(version)) 
[16:17:50.051]                             version <- utils::packageVersion("future")
[16:17:50.051]                         }
[16:17:50.051]                         else {
[16:17:50.051]                           version <- NULL
[16:17:50.051]                         }
[16:17:50.051]                         if (!has_future || version < "1.8.0") {
[16:17:50.051]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:50.051]                             "", base::R.version$version.string), 
[16:17:50.051]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:50.051]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:50.051]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:50.051]                               "release", "version")], collapse = " "), 
[16:17:50.051]                             hostname = base::Sys.info()[["nodename"]])
[16:17:50.051]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:50.051]                             info)
[16:17:50.051]                           info <- base::paste(info, collapse = "; ")
[16:17:50.051]                           if (!has_future) {
[16:17:50.051]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:50.051]                               info)
[16:17:50.051]                           }
[16:17:50.051]                           else {
[16:17:50.051]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:50.051]                               info, version)
[16:17:50.051]                           }
[16:17:50.051]                           base::stop(msg)
[16:17:50.051]                         }
[16:17:50.051]                       })
[16:17:50.051]                     }
[16:17:50.051]                     base::local({
[16:17:50.051]                       for (pkg in "stats") {
[16:17:50.051]                         base::loadNamespace(pkg)
[16:17:50.051]                         base::library(pkg, character.only = TRUE)
[16:17:50.051]                       }
[16:17:50.051]                     })
[16:17:50.051]                   }
[16:17:50.051]                   ...future.strategy.old <- future::plan("list")
[16:17:50.051]                   options(future.plan = NULL)
[16:17:50.051]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:50.051]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:50.051]                 }
[16:17:50.051]                 ...future.workdir <- getwd()
[16:17:50.051]             }
[16:17:50.051]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:50.051]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:50.051]         }
[16:17:50.051]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:50.051]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:50.051]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:50.051]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:50.051]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:50.051]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:50.051]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:50.051]             base::names(...future.oldOptions))
[16:17:50.051]     }
[16:17:50.051]     if (FALSE) {
[16:17:50.051]     }
[16:17:50.051]     else {
[16:17:50.051]         if (TRUE) {
[16:17:50.051]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:50.051]                 open = "w")
[16:17:50.051]         }
[16:17:50.051]         else {
[16:17:50.051]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:50.051]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:50.051]         }
[16:17:50.051]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:50.051]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:50.051]             base::sink(type = "output", split = FALSE)
[16:17:50.051]             base::close(...future.stdout)
[16:17:50.051]         }, add = TRUE)
[16:17:50.051]     }
[16:17:50.051]     ...future.frame <- base::sys.nframe()
[16:17:50.051]     ...future.conditions <- base::list()
[16:17:50.051]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:50.051]     if (FALSE) {
[16:17:50.051]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:50.051]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:50.051]     }
[16:17:50.051]     ...future.result <- base::tryCatch({
[16:17:50.051]         base::withCallingHandlers({
[16:17:50.051]             ...future.value <- base::withVisible(base::local({
[16:17:50.051]                 do.call(function(...) {
[16:17:50.051]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.051]                   if (!identical(...future.globals.maxSize.org, 
[16:17:50.051]                     ...future.globals.maxSize)) {
[16:17:50.051]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.051]                     on.exit(options(oopts), add = TRUE)
[16:17:50.051]                   }
[16:17:50.051]                   {
[16:17:50.051]                     lapply(seq_along(...future.elements_ii), 
[16:17:50.051]                       FUN = function(jj) {
[16:17:50.051]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.051]                         ...future.FUN(...future.X_jj, ...)
[16:17:50.051]                       })
[16:17:50.051]                   }
[16:17:50.051]                 }, args = future.call.arguments)
[16:17:50.051]             }))
[16:17:50.051]             future::FutureResult(value = ...future.value$value, 
[16:17:50.051]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:50.051]                   ...future.rng), globalenv = if (FALSE) 
[16:17:50.051]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:50.051]                     ...future.globalenv.names))
[16:17:50.051]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:50.051]         }, condition = base::local({
[16:17:50.051]             c <- base::c
[16:17:50.051]             inherits <- base::inherits
[16:17:50.051]             invokeRestart <- base::invokeRestart
[16:17:50.051]             length <- base::length
[16:17:50.051]             list <- base::list
[16:17:50.051]             seq.int <- base::seq.int
[16:17:50.051]             signalCondition <- base::signalCondition
[16:17:50.051]             sys.calls <- base::sys.calls
[16:17:50.051]             `[[` <- base::`[[`
[16:17:50.051]             `+` <- base::`+`
[16:17:50.051]             `<<-` <- base::`<<-`
[16:17:50.051]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:50.051]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:50.051]                   3L)]
[16:17:50.051]             }
[16:17:50.051]             function(cond) {
[16:17:50.051]                 is_error <- inherits(cond, "error")
[16:17:50.051]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:50.051]                   NULL)
[16:17:50.051]                 if (is_error) {
[16:17:50.051]                   sessionInformation <- function() {
[16:17:50.051]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:50.051]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:50.051]                       search = base::search(), system = base::Sys.info())
[16:17:50.051]                   }
[16:17:50.051]                   ...future.conditions[[length(...future.conditions) + 
[16:17:50.051]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:50.051]                     cond$call), session = sessionInformation(), 
[16:17:50.051]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:50.051]                   signalCondition(cond)
[16:17:50.051]                 }
[16:17:50.051]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:50.051]                 "immediateCondition"))) {
[16:17:50.051]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:50.051]                   ...future.conditions[[length(...future.conditions) + 
[16:17:50.051]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:50.051]                   if (TRUE && !signal) {
[16:17:50.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.051]                     {
[16:17:50.051]                       inherits <- base::inherits
[16:17:50.051]                       invokeRestart <- base::invokeRestart
[16:17:50.051]                       is.null <- base::is.null
[16:17:50.051]                       muffled <- FALSE
[16:17:50.051]                       if (inherits(cond, "message")) {
[16:17:50.051]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:50.051]                         if (muffled) 
[16:17:50.051]                           invokeRestart("muffleMessage")
[16:17:50.051]                       }
[16:17:50.051]                       else if (inherits(cond, "warning")) {
[16:17:50.051]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:50.051]                         if (muffled) 
[16:17:50.051]                           invokeRestart("muffleWarning")
[16:17:50.051]                       }
[16:17:50.051]                       else if (inherits(cond, "condition")) {
[16:17:50.051]                         if (!is.null(pattern)) {
[16:17:50.051]                           computeRestarts <- base::computeRestarts
[16:17:50.051]                           grepl <- base::grepl
[16:17:50.051]                           restarts <- computeRestarts(cond)
[16:17:50.051]                           for (restart in restarts) {
[16:17:50.051]                             name <- restart$name
[16:17:50.051]                             if (is.null(name)) 
[16:17:50.051]                               next
[16:17:50.051]                             if (!grepl(pattern, name)) 
[16:17:50.051]                               next
[16:17:50.051]                             invokeRestart(restart)
[16:17:50.051]                             muffled <- TRUE
[16:17:50.051]                             break
[16:17:50.051]                           }
[16:17:50.051]                         }
[16:17:50.051]                       }
[16:17:50.051]                       invisible(muffled)
[16:17:50.051]                     }
[16:17:50.051]                     muffleCondition(cond, pattern = "^muffle")
[16:17:50.051]                   }
[16:17:50.051]                 }
[16:17:50.051]                 else {
[16:17:50.051]                   if (TRUE) {
[16:17:50.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.051]                     {
[16:17:50.051]                       inherits <- base::inherits
[16:17:50.051]                       invokeRestart <- base::invokeRestart
[16:17:50.051]                       is.null <- base::is.null
[16:17:50.051]                       muffled <- FALSE
[16:17:50.051]                       if (inherits(cond, "message")) {
[16:17:50.051]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:50.051]                         if (muffled) 
[16:17:50.051]                           invokeRestart("muffleMessage")
[16:17:50.051]                       }
[16:17:50.051]                       else if (inherits(cond, "warning")) {
[16:17:50.051]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:50.051]                         if (muffled) 
[16:17:50.051]                           invokeRestart("muffleWarning")
[16:17:50.051]                       }
[16:17:50.051]                       else if (inherits(cond, "condition")) {
[16:17:50.051]                         if (!is.null(pattern)) {
[16:17:50.051]                           computeRestarts <- base::computeRestarts
[16:17:50.051]                           grepl <- base::grepl
[16:17:50.051]                           restarts <- computeRestarts(cond)
[16:17:50.051]                           for (restart in restarts) {
[16:17:50.051]                             name <- restart$name
[16:17:50.051]                             if (is.null(name)) 
[16:17:50.051]                               next
[16:17:50.051]                             if (!grepl(pattern, name)) 
[16:17:50.051]                               next
[16:17:50.051]                             invokeRestart(restart)
[16:17:50.051]                             muffled <- TRUE
[16:17:50.051]                             break
[16:17:50.051]                           }
[16:17:50.051]                         }
[16:17:50.051]                       }
[16:17:50.051]                       invisible(muffled)
[16:17:50.051]                     }
[16:17:50.051]                     muffleCondition(cond, pattern = "^muffle")
[16:17:50.051]                   }
[16:17:50.051]                 }
[16:17:50.051]             }
[16:17:50.051]         }))
[16:17:50.051]     }, error = function(ex) {
[16:17:50.051]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:50.051]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:50.051]                 ...future.rng), started = ...future.startTime, 
[16:17:50.051]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:50.051]             version = "1.8"), class = "FutureResult")
[16:17:50.051]     }, finally = {
[16:17:50.051]         if (!identical(...future.workdir, getwd())) 
[16:17:50.051]             setwd(...future.workdir)
[16:17:50.051]         {
[16:17:50.051]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:50.051]                 ...future.oldOptions$nwarnings <- NULL
[16:17:50.051]             }
[16:17:50.051]             base::options(...future.oldOptions)
[16:17:50.051]             if (.Platform$OS.type == "windows") {
[16:17:50.051]                 old_names <- names(...future.oldEnvVars)
[16:17:50.051]                 envs <- base::Sys.getenv()
[16:17:50.051]                 names <- names(envs)
[16:17:50.051]                 common <- intersect(names, old_names)
[16:17:50.051]                 added <- setdiff(names, old_names)
[16:17:50.051]                 removed <- setdiff(old_names, names)
[16:17:50.051]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:50.051]                   envs[common]]
[16:17:50.051]                 NAMES <- toupper(changed)
[16:17:50.051]                 args <- list()
[16:17:50.051]                 for (kk in seq_along(NAMES)) {
[16:17:50.051]                   name <- changed[[kk]]
[16:17:50.051]                   NAME <- NAMES[[kk]]
[16:17:50.051]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.051]                     next
[16:17:50.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:50.051]                 }
[16:17:50.051]                 NAMES <- toupper(added)
[16:17:50.051]                 for (kk in seq_along(NAMES)) {
[16:17:50.051]                   name <- added[[kk]]
[16:17:50.051]                   NAME <- NAMES[[kk]]
[16:17:50.051]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.051]                     next
[16:17:50.051]                   args[[name]] <- ""
[16:17:50.051]                 }
[16:17:50.051]                 NAMES <- toupper(removed)
[16:17:50.051]                 for (kk in seq_along(NAMES)) {
[16:17:50.051]                   name <- removed[[kk]]
[16:17:50.051]                   NAME <- NAMES[[kk]]
[16:17:50.051]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.051]                     next
[16:17:50.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:50.051]                 }
[16:17:50.051]                 if (length(args) > 0) 
[16:17:50.051]                   base::do.call(base::Sys.setenv, args = args)
[16:17:50.051]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:50.051]             }
[16:17:50.051]             else {
[16:17:50.051]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:50.051]             }
[16:17:50.051]             {
[16:17:50.051]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:50.051]                   0L) {
[16:17:50.051]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:50.051]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:50.051]                   base::options(opts)
[16:17:50.051]                 }
[16:17:50.051]                 {
[16:17:50.051]                   {
[16:17:50.051]                     NULL
[16:17:50.051]                     RNGkind("Mersenne-Twister")
[16:17:50.051]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:50.051]                       inherits = FALSE)
[16:17:50.051]                   }
[16:17:50.051]                   options(future.plan = NULL)
[16:17:50.051]                   if (is.na(NA_character_)) 
[16:17:50.051]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:50.051]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:50.051]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:50.051]                     .init = FALSE)
[16:17:50.051]                 }
[16:17:50.051]             }
[16:17:50.051]         }
[16:17:50.051]     })
[16:17:50.051]     if (TRUE) {
[16:17:50.051]         base::sink(type = "output", split = FALSE)
[16:17:50.051]         if (TRUE) {
[16:17:50.051]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:50.051]         }
[16:17:50.051]         else {
[16:17:50.051]             ...future.result["stdout"] <- base::list(NULL)
[16:17:50.051]         }
[16:17:50.051]         base::close(...future.stdout)
[16:17:50.051]         ...future.stdout <- NULL
[16:17:50.051]     }
[16:17:50.051]     ...future.result$conditions <- ...future.conditions
[16:17:50.051]     ...future.result$finished <- base::Sys.time()
[16:17:50.051]     ...future.result
[16:17:50.051] }
[16:17:50.053] assign_globals() ...
[16:17:50.053] List of 5
[16:17:50.053]  $ ...future.FUN            :function (x, ...)  
[16:17:50.053]  $ future.call.arguments    : list()
[16:17:50.053]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:50.053]  $ ...future.elements_ii    :List of 3
[16:17:50.053]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:17:50.053]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:17:50.053]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:17:50.053]  $ ...future.seeds_ii       : NULL
[16:17:50.053]  $ ...future.globals.maxSize: NULL
[16:17:50.053]  - attr(*, "where")=List of 5
[16:17:50.053]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:50.053]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:50.053]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:50.053]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:50.053]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:50.053]  - attr(*, "resolved")= logi FALSE
[16:17:50.053]  - attr(*, "total_size")= num 1248
[16:17:50.053]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:50.053]  - attr(*, "already-done")= logi TRUE
[16:17:50.058] - copied ‘...future.FUN’ to environment
[16:17:50.059] - copied ‘future.call.arguments’ to environment
[16:17:50.059] - copied ‘...future.elements_ii’ to environment
[16:17:50.059] - copied ‘...future.seeds_ii’ to environment
[16:17:50.059] - copied ‘...future.globals.maxSize’ to environment
[16:17:50.059] assign_globals() ... done
[16:17:50.059] plan(): Setting new future strategy stack:
[16:17:50.059] List of future strategies:
[16:17:50.059] 1. sequential:
[16:17:50.059]    - args: function (..., envir = parent.frame())
[16:17:50.059]    - tweaked: FALSE
[16:17:50.059]    - call: NULL
[16:17:50.060] plan(): nbrOfWorkers() = 1
[16:17:50.061] plan(): Setting new future strategy stack:
[16:17:50.061] List of future strategies:
[16:17:50.061] 1. sequential:
[16:17:50.061]    - args: function (..., envir = parent.frame())
[16:17:50.061]    - tweaked: FALSE
[16:17:50.061]    - call: plan(strategy)
[16:17:50.061] plan(): nbrOfWorkers() = 1
[16:17:50.061] SequentialFuture started (and completed)
[16:17:50.062] - Launch lazy future ... done
[16:17:50.062] run() for ‘SequentialFuture’ ... done
[16:17:50.062] Created future:
[16:17:50.062] SequentialFuture:
[16:17:50.062] Label: ‘future_eapply-1’
[16:17:50.062] Expression:
[16:17:50.062] {
[16:17:50.062]     do.call(function(...) {
[16:17:50.062]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.062]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:50.062]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.062]             on.exit(options(oopts), add = TRUE)
[16:17:50.062]         }
[16:17:50.062]         {
[16:17:50.062]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:50.062]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.062]                 ...future.FUN(...future.X_jj, ...)
[16:17:50.062]             })
[16:17:50.062]         }
[16:17:50.062]     }, args = future.call.arguments)
[16:17:50.062] }
[16:17:50.062] Lazy evaluation: FALSE
[16:17:50.062] Asynchronous evaluation: FALSE
[16:17:50.062] Local evaluation: TRUE
[16:17:50.062] Environment: R_GlobalEnv
[16:17:50.062] Capture standard output: TRUE
[16:17:50.062] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:50.062] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:50.062] Packages: 1 packages (‘stats’)
[16:17:50.062] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:50.062] Resolved: TRUE
[16:17:50.062] Value: 1.71 KiB of class ‘list’
[16:17:50.062] Early signaling: FALSE
[16:17:50.062] Owner process: 95d59565-e757-824f-7f5c-7f754384cffc
[16:17:50.062] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:50.063] Chunk #1 of 1 ... DONE
[16:17:50.063] Launching 1 futures (chunks) ... DONE
[16:17:50.063] Resolving 1 futures (chunks) ...
[16:17:50.063] resolve() on list ...
[16:17:50.063]  recursive: 0
[16:17:50.063]  length: 1
[16:17:50.063] 
[16:17:50.063] resolved() for ‘SequentialFuture’ ...
[16:17:50.063] - state: ‘finished’
[16:17:50.064] - run: TRUE
[16:17:50.064] - result: ‘FutureResult’
[16:17:50.064] resolved() for ‘SequentialFuture’ ... done
[16:17:50.064] Future #1
[16:17:50.064] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:50.064] - nx: 1
[16:17:50.064] - relay: TRUE
[16:17:50.064] - stdout: TRUE
[16:17:50.064] - signal: TRUE
[16:17:50.064] - resignal: FALSE
[16:17:50.064] - force: TRUE
[16:17:50.065] - relayed: [n=1] FALSE
[16:17:50.065] - queued futures: [n=1] FALSE
[16:17:50.065]  - until=1
[16:17:50.065]  - relaying element #1
[16:17:50.065] - relayed: [n=1] TRUE
[16:17:50.065] - queued futures: [n=1] TRUE
[16:17:50.065] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:50.065]  length: 0 (resolved future 1)
[16:17:50.065] Relaying remaining futures
[16:17:50.065] signalConditionsASAP(NULL, pos=0) ...
[16:17:50.066] - nx: 1
[16:17:50.066] - relay: TRUE
[16:17:50.066] - stdout: TRUE
[16:17:50.066] - signal: TRUE
[16:17:50.066] - resignal: FALSE
[16:17:50.066] - force: TRUE
[16:17:50.066] - relayed: [n=1] TRUE
[16:17:50.066] - queued futures: [n=1] TRUE
 - flush all
[16:17:50.066] - relayed: [n=1] TRUE
[16:17:50.066] - queued futures: [n=1] TRUE
[16:17:50.066] signalConditionsASAP(NULL, pos=0) ... done
[16:17:50.067] resolve() on list ... DONE
[16:17:50.067]  - Number of value chunks collected: 1
[16:17:50.067] Resolving 1 futures (chunks) ... DONE
[16:17:50.067] Reducing values from 1 chunks ...
[16:17:50.067]  - Number of values collected after concatenation: 3
[16:17:50.067]  - Number of values expected: 3
[16:17:50.067] Reducing values from 1 chunks ... DONE
[16:17:50.067] future_lapply() ... DONE
[16:17:50.067] future_lapply() ...
[16:17:50.068] Number of chunks: 1
[16:17:50.068] getGlobalsAndPackagesXApply() ...
[16:17:50.068]  - future.globals: TRUE
[16:17:50.068] getGlobalsAndPackages() ...
[16:17:50.068] Searching for globals...
[16:17:50.069] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:50.069] Searching for globals ... DONE
[16:17:50.069] Resolving globals: FALSE
[16:17:50.070] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:17:50.070] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:17:50.070] - globals: [1] ‘FUN’
[16:17:50.070] - packages: [1] ‘stats’
[16:17:50.070] getGlobalsAndPackages() ... DONE
[16:17:50.070]  - globals found/used: [n=1] ‘FUN’
[16:17:50.071]  - needed namespaces: [n=1] ‘stats’
[16:17:50.071] Finding globals ... DONE
[16:17:50.071]  - use_args: TRUE
[16:17:50.071]  - Getting '...' globals ...
[16:17:50.071] resolve() on list ...
[16:17:50.071]  recursive: 0
[16:17:50.071]  length: 1
[16:17:50.071]  elements: ‘...’
[16:17:50.071]  length: 0 (resolved future 1)
[16:17:50.072] resolve() on list ... DONE
[16:17:50.072]    - '...' content: [n=0] 
[16:17:50.072] List of 1
[16:17:50.072]  $ ...: list()
[16:17:50.072]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:50.072]  - attr(*, "where")=List of 1
[16:17:50.072]   ..$ ...:<environment: 0x556da4e3d280> 
[16:17:50.072]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:50.072]  - attr(*, "resolved")= logi TRUE
[16:17:50.072]  - attr(*, "total_size")= num NA
[16:17:50.074]  - Getting '...' globals ... DONE
[16:17:50.075] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:50.075] List of 2
[16:17:50.075]  $ ...future.FUN:function (x, ...)  
[16:17:50.075]  $ ...          : list()
[16:17:50.075]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:50.075]  - attr(*, "where")=List of 2
[16:17:50.075]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:50.075]   ..$ ...          :<environment: 0x556da4e3d280> 
[16:17:50.075]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:50.075]  - attr(*, "resolved")= logi FALSE
[16:17:50.075]  - attr(*, "total_size")= num 1248
[16:17:50.078] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:50.078] getGlobalsAndPackagesXApply() ... DONE
[16:17:50.078] Number of futures (= number of chunks): 1
[16:17:50.078] Launching 1 futures (chunks) ...
[16:17:50.078] Chunk #1 of 1 ...
[16:17:50.078]  - Finding globals in 'X' for chunk #1 ...
[16:17:50.078] getGlobalsAndPackages() ...
[16:17:50.079] Searching for globals...
[16:17:50.079] 
[16:17:50.079] Searching for globals ... DONE
[16:17:50.079] - globals: [0] <none>
[16:17:50.079] getGlobalsAndPackages() ... DONE
[16:17:50.079]    + additional globals found: [n=0] 
[16:17:50.079]    + additional namespaces needed: [n=0] 
[16:17:50.079]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:50.079]  - seeds: <none>
[16:17:50.079]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.080] getGlobalsAndPackages() ...
[16:17:50.080] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.080] Resolving globals: FALSE
[16:17:50.080] Tweak future expression to call with '...' arguments ...
[16:17:50.080] {
[16:17:50.080]     do.call(function(...) {
[16:17:50.080]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.080]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:50.080]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.080]             on.exit(options(oopts), add = TRUE)
[16:17:50.080]         }
[16:17:50.080]         {
[16:17:50.080]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:50.080]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.080]                 ...future.FUN(...future.X_jj, ...)
[16:17:50.080]             })
[16:17:50.080]         }
[16:17:50.080]     }, args = future.call.arguments)
[16:17:50.080] }
[16:17:50.080] Tweak future expression to call with '...' arguments ... DONE
[16:17:50.081] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.081] - packages: [1] ‘stats’
[16:17:50.081] getGlobalsAndPackages() ... DONE
[16:17:50.081] run() for ‘Future’ ...
[16:17:50.081] - state: ‘created’
[16:17:50.081] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:17:50.082] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:50.082] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:17:50.082]   - Field: ‘label’
[16:17:50.082]   - Field: ‘local’
[16:17:50.082]   - Field: ‘owner’
[16:17:50.082]   - Field: ‘envir’
[16:17:50.082]   - Field: ‘packages’
[16:17:50.082]   - Field: ‘gc’
[16:17:50.082]   - Field: ‘conditions’
[16:17:50.082]   - Field: ‘expr’
[16:17:50.082]   - Field: ‘uuid’
[16:17:50.083]   - Field: ‘seed’
[16:17:50.083]   - Field: ‘version’
[16:17:50.083]   - Field: ‘result’
[16:17:50.083]   - Field: ‘asynchronous’
[16:17:50.083]   - Field: ‘calls’
[16:17:50.083]   - Field: ‘globals’
[16:17:50.083]   - Field: ‘stdout’
[16:17:50.083]   - Field: ‘earlySignal’
[16:17:50.083]   - Field: ‘lazy’
[16:17:50.083]   - Field: ‘state’
[16:17:50.083] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:17:50.083] - Launch lazy future ...
[16:17:50.084] Packages needed by the future expression (n = 1): ‘stats’
[16:17:50.084] Packages needed by future strategies (n = 0): <none>
[16:17:50.084] {
[16:17:50.084]     {
[16:17:50.084]         {
[16:17:50.084]             ...future.startTime <- base::Sys.time()
[16:17:50.084]             {
[16:17:50.084]                 {
[16:17:50.084]                   {
[16:17:50.084]                     {
[16:17:50.084]                       base::local({
[16:17:50.084]                         has_future <- base::requireNamespace("future", 
[16:17:50.084]                           quietly = TRUE)
[16:17:50.084]                         if (has_future) {
[16:17:50.084]                           ns <- base::getNamespace("future")
[16:17:50.084]                           version <- ns[[".package"]][["version"]]
[16:17:50.084]                           if (is.null(version)) 
[16:17:50.084]                             version <- utils::packageVersion("future")
[16:17:50.084]                         }
[16:17:50.084]                         else {
[16:17:50.084]                           version <- NULL
[16:17:50.084]                         }
[16:17:50.084]                         if (!has_future || version < "1.8.0") {
[16:17:50.084]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:50.084]                             "", base::R.version$version.string), 
[16:17:50.084]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:50.084]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:50.084]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:50.084]                               "release", "version")], collapse = " "), 
[16:17:50.084]                             hostname = base::Sys.info()[["nodename"]])
[16:17:50.084]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:50.084]                             info)
[16:17:50.084]                           info <- base::paste(info, collapse = "; ")
[16:17:50.084]                           if (!has_future) {
[16:17:50.084]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:50.084]                               info)
[16:17:50.084]                           }
[16:17:50.084]                           else {
[16:17:50.084]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:50.084]                               info, version)
[16:17:50.084]                           }
[16:17:50.084]                           base::stop(msg)
[16:17:50.084]                         }
[16:17:50.084]                       })
[16:17:50.084]                     }
[16:17:50.084]                     base::local({
[16:17:50.084]                       for (pkg in "stats") {
[16:17:50.084]                         base::loadNamespace(pkg)
[16:17:50.084]                         base::library(pkg, character.only = TRUE)
[16:17:50.084]                       }
[16:17:50.084]                     })
[16:17:50.084]                   }
[16:17:50.084]                   ...future.strategy.old <- future::plan("list")
[16:17:50.084]                   options(future.plan = NULL)
[16:17:50.084]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:50.084]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:50.084]                 }
[16:17:50.084]                 ...future.workdir <- getwd()
[16:17:50.084]             }
[16:17:50.084]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:50.084]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:50.084]         }
[16:17:50.084]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:50.084]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:50.084]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:50.084]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:50.084]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:50.084]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:50.084]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:50.084]             base::names(...future.oldOptions))
[16:17:50.084]     }
[16:17:50.084]     if (FALSE) {
[16:17:50.084]     }
[16:17:50.084]     else {
[16:17:50.084]         if (TRUE) {
[16:17:50.084]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:50.084]                 open = "w")
[16:17:50.084]         }
[16:17:50.084]         else {
[16:17:50.084]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:50.084]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:50.084]         }
[16:17:50.084]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:50.084]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:50.084]             base::sink(type = "output", split = FALSE)
[16:17:50.084]             base::close(...future.stdout)
[16:17:50.084]         }, add = TRUE)
[16:17:50.084]     }
[16:17:50.084]     ...future.frame <- base::sys.nframe()
[16:17:50.084]     ...future.conditions <- base::list()
[16:17:50.084]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:50.084]     if (FALSE) {
[16:17:50.084]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:50.084]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:50.084]     }
[16:17:50.084]     ...future.result <- base::tryCatch({
[16:17:50.084]         base::withCallingHandlers({
[16:17:50.084]             ...future.value <- base::withVisible(base::local({
[16:17:50.084]                 do.call(function(...) {
[16:17:50.084]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.084]                   if (!identical(...future.globals.maxSize.org, 
[16:17:50.084]                     ...future.globals.maxSize)) {
[16:17:50.084]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.084]                     on.exit(options(oopts), add = TRUE)
[16:17:50.084]                   }
[16:17:50.084]                   {
[16:17:50.084]                     lapply(seq_along(...future.elements_ii), 
[16:17:50.084]                       FUN = function(jj) {
[16:17:50.084]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.084]                         ...future.FUN(...future.X_jj, ...)
[16:17:50.084]                       })
[16:17:50.084]                   }
[16:17:50.084]                 }, args = future.call.arguments)
[16:17:50.084]             }))
[16:17:50.084]             future::FutureResult(value = ...future.value$value, 
[16:17:50.084]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:50.084]                   ...future.rng), globalenv = if (FALSE) 
[16:17:50.084]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:50.084]                     ...future.globalenv.names))
[16:17:50.084]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:50.084]         }, condition = base::local({
[16:17:50.084]             c <- base::c
[16:17:50.084]             inherits <- base::inherits
[16:17:50.084]             invokeRestart <- base::invokeRestart
[16:17:50.084]             length <- base::length
[16:17:50.084]             list <- base::list
[16:17:50.084]             seq.int <- base::seq.int
[16:17:50.084]             signalCondition <- base::signalCondition
[16:17:50.084]             sys.calls <- base::sys.calls
[16:17:50.084]             `[[` <- base::`[[`
[16:17:50.084]             `+` <- base::`+`
[16:17:50.084]             `<<-` <- base::`<<-`
[16:17:50.084]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:50.084]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:50.084]                   3L)]
[16:17:50.084]             }
[16:17:50.084]             function(cond) {
[16:17:50.084]                 is_error <- inherits(cond, "error")
[16:17:50.084]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:50.084]                   NULL)
[16:17:50.084]                 if (is_error) {
[16:17:50.084]                   sessionInformation <- function() {
[16:17:50.084]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:50.084]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:50.084]                       search = base::search(), system = base::Sys.info())
[16:17:50.084]                   }
[16:17:50.084]                   ...future.conditions[[length(...future.conditions) + 
[16:17:50.084]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:50.084]                     cond$call), session = sessionInformation(), 
[16:17:50.084]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:50.084]                   signalCondition(cond)
[16:17:50.084]                 }
[16:17:50.084]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:50.084]                 "immediateCondition"))) {
[16:17:50.084]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:50.084]                   ...future.conditions[[length(...future.conditions) + 
[16:17:50.084]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:50.084]                   if (TRUE && !signal) {
[16:17:50.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.084]                     {
[16:17:50.084]                       inherits <- base::inherits
[16:17:50.084]                       invokeRestart <- base::invokeRestart
[16:17:50.084]                       is.null <- base::is.null
[16:17:50.084]                       muffled <- FALSE
[16:17:50.084]                       if (inherits(cond, "message")) {
[16:17:50.084]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:50.084]                         if (muffled) 
[16:17:50.084]                           invokeRestart("muffleMessage")
[16:17:50.084]                       }
[16:17:50.084]                       else if (inherits(cond, "warning")) {
[16:17:50.084]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:50.084]                         if (muffled) 
[16:17:50.084]                           invokeRestart("muffleWarning")
[16:17:50.084]                       }
[16:17:50.084]                       else if (inherits(cond, "condition")) {
[16:17:50.084]                         if (!is.null(pattern)) {
[16:17:50.084]                           computeRestarts <- base::computeRestarts
[16:17:50.084]                           grepl <- base::grepl
[16:17:50.084]                           restarts <- computeRestarts(cond)
[16:17:50.084]                           for (restart in restarts) {
[16:17:50.084]                             name <- restart$name
[16:17:50.084]                             if (is.null(name)) 
[16:17:50.084]                               next
[16:17:50.084]                             if (!grepl(pattern, name)) 
[16:17:50.084]                               next
[16:17:50.084]                             invokeRestart(restart)
[16:17:50.084]                             muffled <- TRUE
[16:17:50.084]                             break
[16:17:50.084]                           }
[16:17:50.084]                         }
[16:17:50.084]                       }
[16:17:50.084]                       invisible(muffled)
[16:17:50.084]                     }
[16:17:50.084]                     muffleCondition(cond, pattern = "^muffle")
[16:17:50.084]                   }
[16:17:50.084]                 }
[16:17:50.084]                 else {
[16:17:50.084]                   if (TRUE) {
[16:17:50.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.084]                     {
[16:17:50.084]                       inherits <- base::inherits
[16:17:50.084]                       invokeRestart <- base::invokeRestart
[16:17:50.084]                       is.null <- base::is.null
[16:17:50.084]                       muffled <- FALSE
[16:17:50.084]                       if (inherits(cond, "message")) {
[16:17:50.084]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:50.084]                         if (muffled) 
[16:17:50.084]                           invokeRestart("muffleMessage")
[16:17:50.084]                       }
[16:17:50.084]                       else if (inherits(cond, "warning")) {
[16:17:50.084]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:50.084]                         if (muffled) 
[16:17:50.084]                           invokeRestart("muffleWarning")
[16:17:50.084]                       }
[16:17:50.084]                       else if (inherits(cond, "condition")) {
[16:17:50.084]                         if (!is.null(pattern)) {
[16:17:50.084]                           computeRestarts <- base::computeRestarts
[16:17:50.084]                           grepl <- base::grepl
[16:17:50.084]                           restarts <- computeRestarts(cond)
[16:17:50.084]                           for (restart in restarts) {
[16:17:50.084]                             name <- restart$name
[16:17:50.084]                             if (is.null(name)) 
[16:17:50.084]                               next
[16:17:50.084]                             if (!grepl(pattern, name)) 
[16:17:50.084]                               next
[16:17:50.084]                             invokeRestart(restart)
[16:17:50.084]                             muffled <- TRUE
[16:17:50.084]                             break
[16:17:50.084]                           }
[16:17:50.084]                         }
[16:17:50.084]                       }
[16:17:50.084]                       invisible(muffled)
[16:17:50.084]                     }
[16:17:50.084]                     muffleCondition(cond, pattern = "^muffle")
[16:17:50.084]                   }
[16:17:50.084]                 }
[16:17:50.084]             }
[16:17:50.084]         }))
[16:17:50.084]     }, error = function(ex) {
[16:17:50.084]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:50.084]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:50.084]                 ...future.rng), started = ...future.startTime, 
[16:17:50.084]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:50.084]             version = "1.8"), class = "FutureResult")
[16:17:50.084]     }, finally = {
[16:17:50.084]         if (!identical(...future.workdir, getwd())) 
[16:17:50.084]             setwd(...future.workdir)
[16:17:50.084]         {
[16:17:50.084]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:50.084]                 ...future.oldOptions$nwarnings <- NULL
[16:17:50.084]             }
[16:17:50.084]             base::options(...future.oldOptions)
[16:17:50.084]             if (.Platform$OS.type == "windows") {
[16:17:50.084]                 old_names <- names(...future.oldEnvVars)
[16:17:50.084]                 envs <- base::Sys.getenv()
[16:17:50.084]                 names <- names(envs)
[16:17:50.084]                 common <- intersect(names, old_names)
[16:17:50.084]                 added <- setdiff(names, old_names)
[16:17:50.084]                 removed <- setdiff(old_names, names)
[16:17:50.084]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:50.084]                   envs[common]]
[16:17:50.084]                 NAMES <- toupper(changed)
[16:17:50.084]                 args <- list()
[16:17:50.084]                 for (kk in seq_along(NAMES)) {
[16:17:50.084]                   name <- changed[[kk]]
[16:17:50.084]                   NAME <- NAMES[[kk]]
[16:17:50.084]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.084]                     next
[16:17:50.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:50.084]                 }
[16:17:50.084]                 NAMES <- toupper(added)
[16:17:50.084]                 for (kk in seq_along(NAMES)) {
[16:17:50.084]                   name <- added[[kk]]
[16:17:50.084]                   NAME <- NAMES[[kk]]
[16:17:50.084]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.084]                     next
[16:17:50.084]                   args[[name]] <- ""
[16:17:50.084]                 }
[16:17:50.084]                 NAMES <- toupper(removed)
[16:17:50.084]                 for (kk in seq_along(NAMES)) {
[16:17:50.084]                   name <- removed[[kk]]
[16:17:50.084]                   NAME <- NAMES[[kk]]
[16:17:50.084]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.084]                     next
[16:17:50.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:50.084]                 }
[16:17:50.084]                 if (length(args) > 0) 
[16:17:50.084]                   base::do.call(base::Sys.setenv, args = args)
[16:17:50.084]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:50.084]             }
[16:17:50.084]             else {
[16:17:50.084]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:50.084]             }
[16:17:50.084]             {
[16:17:50.084]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:50.084]                   0L) {
[16:17:50.084]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:50.084]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:50.084]                   base::options(opts)
[16:17:50.084]                 }
[16:17:50.084]                 {
[16:17:50.084]                   {
[16:17:50.084]                     NULL
[16:17:50.084]                     RNGkind("Mersenne-Twister")
[16:17:50.084]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:17:50.084]                       inherits = FALSE)
[16:17:50.084]                   }
[16:17:50.084]                   options(future.plan = NULL)
[16:17:50.084]                   if (is.na(NA_character_)) 
[16:17:50.084]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:50.084]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:50.084]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:50.084]                     .init = FALSE)
[16:17:50.084]                 }
[16:17:50.084]             }
[16:17:50.084]         }
[16:17:50.084]     })
[16:17:50.084]     if (TRUE) {
[16:17:50.084]         base::sink(type = "output", split = FALSE)
[16:17:50.084]         if (TRUE) {
[16:17:50.084]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:50.084]         }
[16:17:50.084]         else {
[16:17:50.084]             ...future.result["stdout"] <- base::list(NULL)
[16:17:50.084]         }
[16:17:50.084]         base::close(...future.stdout)
[16:17:50.084]         ...future.stdout <- NULL
[16:17:50.084]     }
[16:17:50.084]     ...future.result$conditions <- ...future.conditions
[16:17:50.084]     ...future.result$finished <- base::Sys.time()
[16:17:50.084]     ...future.result
[16:17:50.084] }
[16:17:50.086] assign_globals() ...
[16:17:50.086] List of 5
[16:17:50.086]  $ ...future.FUN            :function (x, ...)  
[16:17:50.086]  $ future.call.arguments    : list()
[16:17:50.086]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:50.086]  $ ...future.elements_ii    :List of 3
[16:17:50.086]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:17:50.086]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:17:50.086]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:17:50.086]  $ ...future.seeds_ii       : NULL
[16:17:50.086]  $ ...future.globals.maxSize: NULL
[16:17:50.086]  - attr(*, "where")=List of 5
[16:17:50.086]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:50.086]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:50.086]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:50.086]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:50.086]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:50.086]  - attr(*, "resolved")= logi FALSE
[16:17:50.086]  - attr(*, "total_size")= num 1248
[16:17:50.086]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:50.086]  - attr(*, "already-done")= logi TRUE
[16:17:50.091] - copied ‘...future.FUN’ to environment
[16:17:50.091] - copied ‘future.call.arguments’ to environment
[16:17:50.091] - copied ‘...future.elements_ii’ to environment
[16:17:50.091] - copied ‘...future.seeds_ii’ to environment
[16:17:50.091] - copied ‘...future.globals.maxSize’ to environment
[16:17:50.091] assign_globals() ... done
[16:17:50.092] plan(): Setting new future strategy stack:
[16:17:50.092] List of future strategies:
[16:17:50.092] 1. sequential:
[16:17:50.092]    - args: function (..., envir = parent.frame())
[16:17:50.092]    - tweaked: FALSE
[16:17:50.092]    - call: NULL
[16:17:50.092] plan(): nbrOfWorkers() = 1
[16:17:50.093] plan(): Setting new future strategy stack:
[16:17:50.093] List of future strategies:
[16:17:50.093] 1. sequential:
[16:17:50.093]    - args: function (..., envir = parent.frame())
[16:17:50.093]    - tweaked: FALSE
[16:17:50.093]    - call: plan(strategy)
[16:17:50.094] plan(): nbrOfWorkers() = 1
[16:17:50.094] SequentialFuture started (and completed)
[16:17:50.094] - Launch lazy future ... done
[16:17:50.094] run() for ‘SequentialFuture’ ... done
[16:17:50.094] Created future:
[16:17:50.094] SequentialFuture:
[16:17:50.094] Label: ‘future_eapply-1’
[16:17:50.094] Expression:
[16:17:50.094] {
[16:17:50.094]     do.call(function(...) {
[16:17:50.094]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.094]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:50.094]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.094]             on.exit(options(oopts), add = TRUE)
[16:17:50.094]         }
[16:17:50.094]         {
[16:17:50.094]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:50.094]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.094]                 ...future.FUN(...future.X_jj, ...)
[16:17:50.094]             })
[16:17:50.094]         }
[16:17:50.094]     }, args = future.call.arguments)
[16:17:50.094] }
[16:17:50.094] Lazy evaluation: FALSE
[16:17:50.094] Asynchronous evaluation: FALSE
[16:17:50.094] Local evaluation: TRUE
[16:17:50.094] Environment: R_GlobalEnv
[16:17:50.094] Capture standard output: TRUE
[16:17:50.094] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:50.094] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:50.094] Packages: 1 packages (‘stats’)
[16:17:50.094] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:50.094] Resolved: TRUE
[16:17:50.094] Value: 1.71 KiB of class ‘list’
[16:17:50.094] Early signaling: FALSE
[16:17:50.094] Owner process: 95d59565-e757-824f-7f5c-7f754384cffc
[16:17:50.094] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:17:50.095] Chunk #1 of 1 ... DONE
[16:17:50.095] Launching 1 futures (chunks) ... DONE
[16:17:50.095] Resolving 1 futures (chunks) ...
[16:17:50.095] resolve() on list ...
[16:17:50.096]  recursive: 0
[16:17:50.096]  length: 1
[16:17:50.096] 
[16:17:50.096] resolved() for ‘SequentialFuture’ ...
[16:17:50.096] - state: ‘finished’
[16:17:50.096] - run: TRUE
[16:17:50.096] - result: ‘FutureResult’
[16:17:50.096] resolved() for ‘SequentialFuture’ ... done
[16:17:50.096] Future #1
[16:17:50.096] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:17:50.097] - nx: 1
[16:17:50.097] - relay: TRUE
[16:17:50.097] - stdout: TRUE
[16:17:50.097] - signal: TRUE
[16:17:50.097] - resignal: FALSE
[16:17:50.097] - force: TRUE
[16:17:50.098] - relayed: [n=1] FALSE
[16:17:50.098] - queued futures: [n=1] FALSE
[16:17:50.098]  - until=1
[16:17:50.098]  - relaying element #1
[16:17:50.098] - relayed: [n=1] TRUE
[16:17:50.099] - queued futures: [n=1] TRUE
[16:17:50.099] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:17:50.099]  length: 0 (resolved future 1)
[16:17:50.099] Relaying remaining futures
[16:17:50.099] signalConditionsASAP(NULL, pos=0) ...
[16:17:50.099] - nx: 1
[16:17:50.099] - relay: TRUE
[16:17:50.099] - stdout: TRUE
[16:17:50.099] - signal: TRUE
[16:17:50.099] - resignal: FALSE
[16:17:50.099] - force: TRUE
[16:17:50.100] - relayed: [n=1] TRUE
[16:17:50.100] - queued futures: [n=1] TRUE
 - flush all
[16:17:50.100] - relayed: [n=1] TRUE
[16:17:50.100] - queued futures: [n=1] TRUE
[16:17:50.100] signalConditionsASAP(NULL, pos=0) ... done
[16:17:50.100] resolve() on list ... DONE
[16:17:50.100]  - Number of value chunks collected: 1
[16:17:50.100] Resolving 1 futures (chunks) ... DONE
[16:17:50.100] Reducing values from 1 chunks ...
[16:17:50.100]  - Number of values collected after concatenation: 3
[16:17:50.101]  - Number of values expected: 3
[16:17:50.101] Reducing values from 1 chunks ... DONE
[16:17:50.101] future_lapply() ... DONE
[16:17:50.101] plan(): Setting new future strategy stack:
[16:17:50.101] List of future strategies:
[16:17:50.101] 1. sequential:
[16:17:50.101]    - args: function (..., envir = parent.frame())
[16:17:50.101]    - tweaked: FALSE
[16:17:50.101]    - call: plan(sequential)
[16:17:50.101] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[16:17:50.102] plan(): Setting new future strategy stack:
[16:17:50.102] List of future strategies:
[16:17:50.102] 1. multicore:
[16:17:50.102]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:50.102]    - tweaked: FALSE
[16:17:50.102]    - call: plan(strategy)
[16:17:50.106] plan(): nbrOfWorkers() = 2
[16:17:50.106] future_lapply() ...
[16:17:50.110] Number of chunks: 2
[16:17:50.110] getGlobalsAndPackagesXApply() ...
[16:17:50.110]  - future.globals: TRUE
[16:17:50.111] getGlobalsAndPackages() ...
[16:17:50.111] Searching for globals...
[16:17:50.112] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:50.112] Searching for globals ... DONE
[16:17:50.112] Resolving globals: FALSE
[16:17:50.112] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:50.112] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:50.113] - globals: [1] ‘FUN’
[16:17:50.113] 
[16:17:50.113] getGlobalsAndPackages() ... DONE
[16:17:50.113]  - globals found/used: [n=1] ‘FUN’
[16:17:50.113]  - needed namespaces: [n=0] 
[16:17:50.113] Finding globals ... DONE
[16:17:50.113]  - use_args: TRUE
[16:17:50.113]  - Getting '...' globals ...
[16:17:50.114] resolve() on list ...
[16:17:50.114]  recursive: 0
[16:17:50.114]  length: 1
[16:17:50.114]  elements: ‘...’
[16:17:50.114]  length: 0 (resolved future 1)
[16:17:50.114] resolve() on list ... DONE
[16:17:50.114]    - '...' content: [n=0] 
[16:17:50.114] List of 1
[16:17:50.114]  $ ...: list()
[16:17:50.114]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:50.114]  - attr(*, "where")=List of 1
[16:17:50.114]   ..$ ...:<environment: 0x556da2aca528> 
[16:17:50.114]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:50.114]  - attr(*, "resolved")= logi TRUE
[16:17:50.114]  - attr(*, "total_size")= num NA
[16:17:50.117]  - Getting '...' globals ... DONE
[16:17:50.117] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:50.117] List of 2
[16:17:50.117]  $ ...future.FUN:function (x, ...)  
[16:17:50.117]  $ ...          : list()
[16:17:50.117]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:50.117]  - attr(*, "where")=List of 2
[16:17:50.117]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:50.117]   ..$ ...          :<environment: 0x556da2aca528> 
[16:17:50.117]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:50.117]  - attr(*, "resolved")= logi FALSE
[16:17:50.117]  - attr(*, "total_size")= num 1240
[16:17:50.119] Packages to be attached in all futures: [n=0] 
[16:17:50.120] getGlobalsAndPackagesXApply() ... DONE
[16:17:50.120] Number of futures (= number of chunks): 2
[16:17:50.120] Launching 2 futures (chunks) ...
[16:17:50.120] Chunk #1 of 2 ...
[16:17:50.120]  - Finding globals in 'X' for chunk #1 ...
[16:17:50.120] getGlobalsAndPackages() ...
[16:17:50.120] Searching for globals...
[16:17:50.121] 
[16:17:50.121] Searching for globals ... DONE
[16:17:50.121] - globals: [0] <none>
[16:17:50.121] getGlobalsAndPackages() ... DONE
[16:17:50.121]    + additional globals found: [n=0] 
[16:17:50.121]    + additional namespaces needed: [n=0] 
[16:17:50.121]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:50.121]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:50.121]  - seeds: <none>
[16:17:50.121]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.121] getGlobalsAndPackages() ...
[16:17:50.122] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.122] Resolving globals: FALSE
[16:17:50.122] Tweak future expression to call with '...' arguments ...
[16:17:50.122] {
[16:17:50.122]     do.call(function(...) {
[16:17:50.122]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.122]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:50.122]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.122]             on.exit(options(oopts), add = TRUE)
[16:17:50.122]         }
[16:17:50.122]         {
[16:17:50.122]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:50.122]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.122]                 ...future.FUN(...future.X_jj, ...)
[16:17:50.122]             })
[16:17:50.122]         }
[16:17:50.122]     }, args = future.call.arguments)
[16:17:50.122] }
[16:17:50.122] Tweak future expression to call with '...' arguments ... DONE
[16:17:50.122] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.123] 
[16:17:50.123] getGlobalsAndPackages() ... DONE
[16:17:50.123] run() for ‘Future’ ...
[16:17:50.123] - state: ‘created’
[16:17:50.123] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:50.128] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:50.128] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:50.128]   - Field: ‘label’
[16:17:50.128]   - Field: ‘local’
[16:17:50.128]   - Field: ‘owner’
[16:17:50.128]   - Field: ‘envir’
[16:17:50.128]   - Field: ‘workers’
[16:17:50.128]   - Field: ‘packages’
[16:17:50.129]   - Field: ‘gc’
[16:17:50.129]   - Field: ‘job’
[16:17:50.129]   - Field: ‘conditions’
[16:17:50.129]   - Field: ‘expr’
[16:17:50.129]   - Field: ‘uuid’
[16:17:50.129]   - Field: ‘seed’
[16:17:50.129]   - Field: ‘version’
[16:17:50.129]   - Field: ‘result’
[16:17:50.129]   - Field: ‘asynchronous’
[16:17:50.129]   - Field: ‘calls’
[16:17:50.129]   - Field: ‘globals’
[16:17:50.130]   - Field: ‘stdout’
[16:17:50.130]   - Field: ‘earlySignal’
[16:17:50.130]   - Field: ‘lazy’
[16:17:50.130]   - Field: ‘state’
[16:17:50.130] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:50.130] - Launch lazy future ...
[16:17:50.131] Packages needed by the future expression (n = 0): <none>
[16:17:50.131] Packages needed by future strategies (n = 0): <none>
[16:17:50.132] {
[16:17:50.132]     {
[16:17:50.132]         {
[16:17:50.132]             ...future.startTime <- base::Sys.time()
[16:17:50.132]             {
[16:17:50.132]                 {
[16:17:50.132]                   {
[16:17:50.132]                     {
[16:17:50.132]                       base::local({
[16:17:50.132]                         has_future <- base::requireNamespace("future", 
[16:17:50.132]                           quietly = TRUE)
[16:17:50.132]                         if (has_future) {
[16:17:50.132]                           ns <- base::getNamespace("future")
[16:17:50.132]                           version <- ns[[".package"]][["version"]]
[16:17:50.132]                           if (is.null(version)) 
[16:17:50.132]                             version <- utils::packageVersion("future")
[16:17:50.132]                         }
[16:17:50.132]                         else {
[16:17:50.132]                           version <- NULL
[16:17:50.132]                         }
[16:17:50.132]                         if (!has_future || version < "1.8.0") {
[16:17:50.132]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:50.132]                             "", base::R.version$version.string), 
[16:17:50.132]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:50.132]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:50.132]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:50.132]                               "release", "version")], collapse = " "), 
[16:17:50.132]                             hostname = base::Sys.info()[["nodename"]])
[16:17:50.132]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:50.132]                             info)
[16:17:50.132]                           info <- base::paste(info, collapse = "; ")
[16:17:50.132]                           if (!has_future) {
[16:17:50.132]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:50.132]                               info)
[16:17:50.132]                           }
[16:17:50.132]                           else {
[16:17:50.132]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:50.132]                               info, version)
[16:17:50.132]                           }
[16:17:50.132]                           base::stop(msg)
[16:17:50.132]                         }
[16:17:50.132]                       })
[16:17:50.132]                     }
[16:17:50.132]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:50.132]                     base::options(mc.cores = 1L)
[16:17:50.132]                   }
[16:17:50.132]                   ...future.strategy.old <- future::plan("list")
[16:17:50.132]                   options(future.plan = NULL)
[16:17:50.132]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:50.132]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:50.132]                 }
[16:17:50.132]                 ...future.workdir <- getwd()
[16:17:50.132]             }
[16:17:50.132]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:50.132]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:50.132]         }
[16:17:50.132]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:50.132]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:50.132]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:50.132]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:50.132]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:50.132]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:50.132]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:50.132]             base::names(...future.oldOptions))
[16:17:50.132]     }
[16:17:50.132]     if (FALSE) {
[16:17:50.132]     }
[16:17:50.132]     else {
[16:17:50.132]         if (TRUE) {
[16:17:50.132]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:50.132]                 open = "w")
[16:17:50.132]         }
[16:17:50.132]         else {
[16:17:50.132]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:50.132]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:50.132]         }
[16:17:50.132]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:50.132]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:50.132]             base::sink(type = "output", split = FALSE)
[16:17:50.132]             base::close(...future.stdout)
[16:17:50.132]         }, add = TRUE)
[16:17:50.132]     }
[16:17:50.132]     ...future.frame <- base::sys.nframe()
[16:17:50.132]     ...future.conditions <- base::list()
[16:17:50.132]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:50.132]     if (FALSE) {
[16:17:50.132]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:50.132]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:50.132]     }
[16:17:50.132]     ...future.result <- base::tryCatch({
[16:17:50.132]         base::withCallingHandlers({
[16:17:50.132]             ...future.value <- base::withVisible(base::local({
[16:17:50.132]                 withCallingHandlers({
[16:17:50.132]                   {
[16:17:50.132]                     do.call(function(...) {
[16:17:50.132]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.132]                       if (!identical(...future.globals.maxSize.org, 
[16:17:50.132]                         ...future.globals.maxSize)) {
[16:17:50.132]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.132]                         on.exit(options(oopts), add = TRUE)
[16:17:50.132]                       }
[16:17:50.132]                       {
[16:17:50.132]                         lapply(seq_along(...future.elements_ii), 
[16:17:50.132]                           FUN = function(jj) {
[16:17:50.132]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.132]                             ...future.FUN(...future.X_jj, ...)
[16:17:50.132]                           })
[16:17:50.132]                       }
[16:17:50.132]                     }, args = future.call.arguments)
[16:17:50.132]                   }
[16:17:50.132]                 }, immediateCondition = function(cond) {
[16:17:50.132]                   save_rds <- function (object, pathname, ...) 
[16:17:50.132]                   {
[16:17:50.132]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:50.132]                     if (file_test("-f", pathname_tmp)) {
[16:17:50.132]                       fi_tmp <- file.info(pathname_tmp)
[16:17:50.132]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:50.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:50.132]                         fi_tmp[["mtime"]])
[16:17:50.132]                     }
[16:17:50.132]                     tryCatch({
[16:17:50.132]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:50.132]                     }, error = function(ex) {
[16:17:50.132]                       msg <- conditionMessage(ex)
[16:17:50.132]                       fi_tmp <- file.info(pathname_tmp)
[16:17:50.132]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:50.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:50.132]                         fi_tmp[["mtime"]], msg)
[16:17:50.132]                       ex$message <- msg
[16:17:50.132]                       stop(ex)
[16:17:50.132]                     })
[16:17:50.132]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:50.132]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:50.132]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:50.132]                       fi_tmp <- file.info(pathname_tmp)
[16:17:50.132]                       fi <- file.info(pathname)
[16:17:50.132]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:50.132]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:50.132]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:50.132]                         fi[["size"]], fi[["mtime"]])
[16:17:50.132]                       stop(msg)
[16:17:50.132]                     }
[16:17:50.132]                     invisible(pathname)
[16:17:50.132]                   }
[16:17:50.132]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:50.132]                     rootPath = tempdir()) 
[16:17:50.132]                   {
[16:17:50.132]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:50.132]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:50.132]                       tmpdir = path, fileext = ".rds")
[16:17:50.132]                     save_rds(obj, file)
[16:17:50.132]                   }
[16:17:50.132]                   saveImmediateCondition(cond, path = "/tmp/Rtmpstkvtd/.future/immediateConditions")
[16:17:50.132]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.132]                   {
[16:17:50.132]                     inherits <- base::inherits
[16:17:50.132]                     invokeRestart <- base::invokeRestart
[16:17:50.132]                     is.null <- base::is.null
[16:17:50.132]                     muffled <- FALSE
[16:17:50.132]                     if (inherits(cond, "message")) {
[16:17:50.132]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:50.132]                       if (muffled) 
[16:17:50.132]                         invokeRestart("muffleMessage")
[16:17:50.132]                     }
[16:17:50.132]                     else if (inherits(cond, "warning")) {
[16:17:50.132]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:50.132]                       if (muffled) 
[16:17:50.132]                         invokeRestart("muffleWarning")
[16:17:50.132]                     }
[16:17:50.132]                     else if (inherits(cond, "condition")) {
[16:17:50.132]                       if (!is.null(pattern)) {
[16:17:50.132]                         computeRestarts <- base::computeRestarts
[16:17:50.132]                         grepl <- base::grepl
[16:17:50.132]                         restarts <- computeRestarts(cond)
[16:17:50.132]                         for (restart in restarts) {
[16:17:50.132]                           name <- restart$name
[16:17:50.132]                           if (is.null(name)) 
[16:17:50.132]                             next
[16:17:50.132]                           if (!grepl(pattern, name)) 
[16:17:50.132]                             next
[16:17:50.132]                           invokeRestart(restart)
[16:17:50.132]                           muffled <- TRUE
[16:17:50.132]                           break
[16:17:50.132]                         }
[16:17:50.132]                       }
[16:17:50.132]                     }
[16:17:50.132]                     invisible(muffled)
[16:17:50.132]                   }
[16:17:50.132]                   muffleCondition(cond)
[16:17:50.132]                 })
[16:17:50.132]             }))
[16:17:50.132]             future::FutureResult(value = ...future.value$value, 
[16:17:50.132]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:50.132]                   ...future.rng), globalenv = if (FALSE) 
[16:17:50.132]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:50.132]                     ...future.globalenv.names))
[16:17:50.132]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:50.132]         }, condition = base::local({
[16:17:50.132]             c <- base::c
[16:17:50.132]             inherits <- base::inherits
[16:17:50.132]             invokeRestart <- base::invokeRestart
[16:17:50.132]             length <- base::length
[16:17:50.132]             list <- base::list
[16:17:50.132]             seq.int <- base::seq.int
[16:17:50.132]             signalCondition <- base::signalCondition
[16:17:50.132]             sys.calls <- base::sys.calls
[16:17:50.132]             `[[` <- base::`[[`
[16:17:50.132]             `+` <- base::`+`
[16:17:50.132]             `<<-` <- base::`<<-`
[16:17:50.132]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:50.132]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:50.132]                   3L)]
[16:17:50.132]             }
[16:17:50.132]             function(cond) {
[16:17:50.132]                 is_error <- inherits(cond, "error")
[16:17:50.132]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:50.132]                   NULL)
[16:17:50.132]                 if (is_error) {
[16:17:50.132]                   sessionInformation <- function() {
[16:17:50.132]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:50.132]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:50.132]                       search = base::search(), system = base::Sys.info())
[16:17:50.132]                   }
[16:17:50.132]                   ...future.conditions[[length(...future.conditions) + 
[16:17:50.132]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:50.132]                     cond$call), session = sessionInformation(), 
[16:17:50.132]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:50.132]                   signalCondition(cond)
[16:17:50.132]                 }
[16:17:50.132]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:50.132]                 "immediateCondition"))) {
[16:17:50.132]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:50.132]                   ...future.conditions[[length(...future.conditions) + 
[16:17:50.132]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:50.132]                   if (TRUE && !signal) {
[16:17:50.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.132]                     {
[16:17:50.132]                       inherits <- base::inherits
[16:17:50.132]                       invokeRestart <- base::invokeRestart
[16:17:50.132]                       is.null <- base::is.null
[16:17:50.132]                       muffled <- FALSE
[16:17:50.132]                       if (inherits(cond, "message")) {
[16:17:50.132]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:50.132]                         if (muffled) 
[16:17:50.132]                           invokeRestart("muffleMessage")
[16:17:50.132]                       }
[16:17:50.132]                       else if (inherits(cond, "warning")) {
[16:17:50.132]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:50.132]                         if (muffled) 
[16:17:50.132]                           invokeRestart("muffleWarning")
[16:17:50.132]                       }
[16:17:50.132]                       else if (inherits(cond, "condition")) {
[16:17:50.132]                         if (!is.null(pattern)) {
[16:17:50.132]                           computeRestarts <- base::computeRestarts
[16:17:50.132]                           grepl <- base::grepl
[16:17:50.132]                           restarts <- computeRestarts(cond)
[16:17:50.132]                           for (restart in restarts) {
[16:17:50.132]                             name <- restart$name
[16:17:50.132]                             if (is.null(name)) 
[16:17:50.132]                               next
[16:17:50.132]                             if (!grepl(pattern, name)) 
[16:17:50.132]                               next
[16:17:50.132]                             invokeRestart(restart)
[16:17:50.132]                             muffled <- TRUE
[16:17:50.132]                             break
[16:17:50.132]                           }
[16:17:50.132]                         }
[16:17:50.132]                       }
[16:17:50.132]                       invisible(muffled)
[16:17:50.132]                     }
[16:17:50.132]                     muffleCondition(cond, pattern = "^muffle")
[16:17:50.132]                   }
[16:17:50.132]                 }
[16:17:50.132]                 else {
[16:17:50.132]                   if (TRUE) {
[16:17:50.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.132]                     {
[16:17:50.132]                       inherits <- base::inherits
[16:17:50.132]                       invokeRestart <- base::invokeRestart
[16:17:50.132]                       is.null <- base::is.null
[16:17:50.132]                       muffled <- FALSE
[16:17:50.132]                       if (inherits(cond, "message")) {
[16:17:50.132]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:50.132]                         if (muffled) 
[16:17:50.132]                           invokeRestart("muffleMessage")
[16:17:50.132]                       }
[16:17:50.132]                       else if (inherits(cond, "warning")) {
[16:17:50.132]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:50.132]                         if (muffled) 
[16:17:50.132]                           invokeRestart("muffleWarning")
[16:17:50.132]                       }
[16:17:50.132]                       else if (inherits(cond, "condition")) {
[16:17:50.132]                         if (!is.null(pattern)) {
[16:17:50.132]                           computeRestarts <- base::computeRestarts
[16:17:50.132]                           grepl <- base::grepl
[16:17:50.132]                           restarts <- computeRestarts(cond)
[16:17:50.132]                           for (restart in restarts) {
[16:17:50.132]                             name <- restart$name
[16:17:50.132]                             if (is.null(name)) 
[16:17:50.132]                               next
[16:17:50.132]                             if (!grepl(pattern, name)) 
[16:17:50.132]                               next
[16:17:50.132]                             invokeRestart(restart)
[16:17:50.132]                             muffled <- TRUE
[16:17:50.132]                             break
[16:17:50.132]                           }
[16:17:50.132]                         }
[16:17:50.132]                       }
[16:17:50.132]                       invisible(muffled)
[16:17:50.132]                     }
[16:17:50.132]                     muffleCondition(cond, pattern = "^muffle")
[16:17:50.132]                   }
[16:17:50.132]                 }
[16:17:50.132]             }
[16:17:50.132]         }))
[16:17:50.132]     }, error = function(ex) {
[16:17:50.132]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:50.132]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:50.132]                 ...future.rng), started = ...future.startTime, 
[16:17:50.132]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:50.132]             version = "1.8"), class = "FutureResult")
[16:17:50.132]     }, finally = {
[16:17:50.132]         if (!identical(...future.workdir, getwd())) 
[16:17:50.132]             setwd(...future.workdir)
[16:17:50.132]         {
[16:17:50.132]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:50.132]                 ...future.oldOptions$nwarnings <- NULL
[16:17:50.132]             }
[16:17:50.132]             base::options(...future.oldOptions)
[16:17:50.132]             if (.Platform$OS.type == "windows") {
[16:17:50.132]                 old_names <- names(...future.oldEnvVars)
[16:17:50.132]                 envs <- base::Sys.getenv()
[16:17:50.132]                 names <- names(envs)
[16:17:50.132]                 common <- intersect(names, old_names)
[16:17:50.132]                 added <- setdiff(names, old_names)
[16:17:50.132]                 removed <- setdiff(old_names, names)
[16:17:50.132]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:50.132]                   envs[common]]
[16:17:50.132]                 NAMES <- toupper(changed)
[16:17:50.132]                 args <- list()
[16:17:50.132]                 for (kk in seq_along(NAMES)) {
[16:17:50.132]                   name <- changed[[kk]]
[16:17:50.132]                   NAME <- NAMES[[kk]]
[16:17:50.132]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.132]                     next
[16:17:50.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:50.132]                 }
[16:17:50.132]                 NAMES <- toupper(added)
[16:17:50.132]                 for (kk in seq_along(NAMES)) {
[16:17:50.132]                   name <- added[[kk]]
[16:17:50.132]                   NAME <- NAMES[[kk]]
[16:17:50.132]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.132]                     next
[16:17:50.132]                   args[[name]] <- ""
[16:17:50.132]                 }
[16:17:50.132]                 NAMES <- toupper(removed)
[16:17:50.132]                 for (kk in seq_along(NAMES)) {
[16:17:50.132]                   name <- removed[[kk]]
[16:17:50.132]                   NAME <- NAMES[[kk]]
[16:17:50.132]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.132]                     next
[16:17:50.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:50.132]                 }
[16:17:50.132]                 if (length(args) > 0) 
[16:17:50.132]                   base::do.call(base::Sys.setenv, args = args)
[16:17:50.132]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:50.132]             }
[16:17:50.132]             else {
[16:17:50.132]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:50.132]             }
[16:17:50.132]             {
[16:17:50.132]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:50.132]                   0L) {
[16:17:50.132]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:50.132]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:50.132]                   base::options(opts)
[16:17:50.132]                 }
[16:17:50.132]                 {
[16:17:50.132]                   {
[16:17:50.132]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:50.132]                     NULL
[16:17:50.132]                   }
[16:17:50.132]                   options(future.plan = NULL)
[16:17:50.132]                   if (is.na(NA_character_)) 
[16:17:50.132]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:50.132]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:50.132]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:50.132]                     .init = FALSE)
[16:17:50.132]                 }
[16:17:50.132]             }
[16:17:50.132]         }
[16:17:50.132]     })
[16:17:50.132]     if (TRUE) {
[16:17:50.132]         base::sink(type = "output", split = FALSE)
[16:17:50.132]         if (TRUE) {
[16:17:50.132]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:50.132]         }
[16:17:50.132]         else {
[16:17:50.132]             ...future.result["stdout"] <- base::list(NULL)
[16:17:50.132]         }
[16:17:50.132]         base::close(...future.stdout)
[16:17:50.132]         ...future.stdout <- NULL
[16:17:50.132]     }
[16:17:50.132]     ...future.result$conditions <- ...future.conditions
[16:17:50.132]     ...future.result$finished <- base::Sys.time()
[16:17:50.132]     ...future.result
[16:17:50.132] }
[16:17:50.134] assign_globals() ...
[16:17:50.134] List of 5
[16:17:50.134]  $ ...future.FUN            :function (x, ...)  
[16:17:50.134]  $ future.call.arguments    : list()
[16:17:50.134]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:50.134]  $ ...future.elements_ii    :List of 1
[16:17:50.134]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[16:17:50.134]  $ ...future.seeds_ii       : NULL
[16:17:50.134]  $ ...future.globals.maxSize: NULL
[16:17:50.134]  - attr(*, "where")=List of 5
[16:17:50.134]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:50.134]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:50.134]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:50.134]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:50.134]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:50.134]  - attr(*, "resolved")= logi FALSE
[16:17:50.134]  - attr(*, "total_size")= num 1240
[16:17:50.134]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:50.134]  - attr(*, "already-done")= logi TRUE
[16:17:50.138] - copied ‘...future.FUN’ to environment
[16:17:50.138] - copied ‘future.call.arguments’ to environment
[16:17:50.138] - copied ‘...future.elements_ii’ to environment
[16:17:50.139] - copied ‘...future.seeds_ii’ to environment
[16:17:50.139] - copied ‘...future.globals.maxSize’ to environment
[16:17:50.139] assign_globals() ... done
[16:17:50.139] requestCore(): workers = 2
[16:17:50.142] MulticoreFuture started
[16:17:50.142] - Launch lazy future ... done
[16:17:50.143] run() for ‘MulticoreFuture’ ... done
[16:17:50.143] plan(): Setting new future strategy stack:
[16:17:50.143] Created future:
[16:17:50.143] List of future strategies:
[16:17:50.143] 1. sequential:
[16:17:50.143]    - args: function (..., envir = parent.frame())
[16:17:50.143]    - tweaked: FALSE
[16:17:50.143]    - call: NULL
[16:17:50.144] plan(): nbrOfWorkers() = 1
[16:17:50.146] plan(): Setting new future strategy stack:
[16:17:50.146] List of future strategies:
[16:17:50.146] 1. multicore:
[16:17:50.146]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:50.146]    - tweaked: FALSE
[16:17:50.146]    - call: plan(strategy)
[16:17:50.151] plan(): nbrOfWorkers() = 2
[16:17:50.143] MulticoreFuture:
[16:17:50.143] Label: ‘future_eapply-1’
[16:17:50.143] Expression:
[16:17:50.143] {
[16:17:50.143]     do.call(function(...) {
[16:17:50.143]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.143]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:50.143]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.143]             on.exit(options(oopts), add = TRUE)
[16:17:50.143]         }
[16:17:50.143]         {
[16:17:50.143]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:50.143]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.143]                 ...future.FUN(...future.X_jj, ...)
[16:17:50.143]             })
[16:17:50.143]         }
[16:17:50.143]     }, args = future.call.arguments)
[16:17:50.143] }
[16:17:50.143] Lazy evaluation: FALSE
[16:17:50.143] Asynchronous evaluation: TRUE
[16:17:50.143] Local evaluation: TRUE
[16:17:50.143] Environment: R_GlobalEnv
[16:17:50.143] Capture standard output: TRUE
[16:17:50.143] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:50.143] Globals: 5 objects totaling 1.27 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:50.143] Packages: <none>
[16:17:50.143] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:50.143] Resolved: TRUE
[16:17:50.143] Value: <not collected>
[16:17:50.143] Conditions captured: <none>
[16:17:50.143] Early signaling: FALSE
[16:17:50.143] Owner process: 95d59565-e757-824f-7f5c-7f754384cffc
[16:17:50.143] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:50.152] Chunk #1 of 2 ... DONE
[16:17:50.152] Chunk #2 of 2 ...
[16:17:50.152]  - Finding globals in 'X' for chunk #2 ...
[16:17:50.152] getGlobalsAndPackages() ...
[16:17:50.152] Searching for globals...
[16:17:50.153] 
[16:17:50.153] Searching for globals ... DONE
[16:17:50.153] - globals: [0] <none>
[16:17:50.153] getGlobalsAndPackages() ... DONE
[16:17:50.153]    + additional globals found: [n=0] 
[16:17:50.153]    + additional namespaces needed: [n=0] 
[16:17:50.154]  - Finding globals in 'X' for chunk #2 ... DONE
[16:17:50.154]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:50.154]  - seeds: <none>
[16:17:50.154]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.154] getGlobalsAndPackages() ...
[16:17:50.154] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.155] Resolving globals: FALSE
[16:17:50.155] Tweak future expression to call with '...' arguments ...
[16:17:50.155] {
[16:17:50.155]     do.call(function(...) {
[16:17:50.155]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.155]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:50.155]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.155]             on.exit(options(oopts), add = TRUE)
[16:17:50.155]         }
[16:17:50.155]         {
[16:17:50.155]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:50.155]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.155]                 ...future.FUN(...future.X_jj, ...)
[16:17:50.155]             })
[16:17:50.155]         }
[16:17:50.155]     }, args = future.call.arguments)
[16:17:50.155] }
[16:17:50.155] Tweak future expression to call with '...' arguments ... DONE
[16:17:50.156] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.156] 
[16:17:50.156] getGlobalsAndPackages() ... DONE
[16:17:50.157] run() for ‘Future’ ...
[16:17:50.157] - state: ‘created’
[16:17:50.157] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:50.161] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:50.161] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:50.161]   - Field: ‘label’
[16:17:50.162]   - Field: ‘local’
[16:17:50.162]   - Field: ‘owner’
[16:17:50.162]   - Field: ‘envir’
[16:17:50.162]   - Field: ‘workers’
[16:17:50.162]   - Field: ‘packages’
[16:17:50.162]   - Field: ‘gc’
[16:17:50.162]   - Field: ‘job’
[16:17:50.163]   - Field: ‘conditions’
[16:17:50.163]   - Field: ‘expr’
[16:17:50.163]   - Field: ‘uuid’
[16:17:50.163]   - Field: ‘seed’
[16:17:50.163]   - Field: ‘version’
[16:17:50.163]   - Field: ‘result’
[16:17:50.163]   - Field: ‘asynchronous’
[16:17:50.163]   - Field: ‘calls’
[16:17:50.164]   - Field: ‘globals’
[16:17:50.164]   - Field: ‘stdout’
[16:17:50.164]   - Field: ‘earlySignal’
[16:17:50.164]   - Field: ‘lazy’
[16:17:50.164]   - Field: ‘state’
[16:17:50.164] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:50.164] - Launch lazy future ...
[16:17:50.165] Packages needed by the future expression (n = 0): <none>
[16:17:50.165] Packages needed by future strategies (n = 0): <none>
[16:17:50.166] {
[16:17:50.166]     {
[16:17:50.166]         {
[16:17:50.166]             ...future.startTime <- base::Sys.time()
[16:17:50.166]             {
[16:17:50.166]                 {
[16:17:50.166]                   {
[16:17:50.166]                     {
[16:17:50.166]                       base::local({
[16:17:50.166]                         has_future <- base::requireNamespace("future", 
[16:17:50.166]                           quietly = TRUE)
[16:17:50.166]                         if (has_future) {
[16:17:50.166]                           ns <- base::getNamespace("future")
[16:17:50.166]                           version <- ns[[".package"]][["version"]]
[16:17:50.166]                           if (is.null(version)) 
[16:17:50.166]                             version <- utils::packageVersion("future")
[16:17:50.166]                         }
[16:17:50.166]                         else {
[16:17:50.166]                           version <- NULL
[16:17:50.166]                         }
[16:17:50.166]                         if (!has_future || version < "1.8.0") {
[16:17:50.166]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:50.166]                             "", base::R.version$version.string), 
[16:17:50.166]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:50.166]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:50.166]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:50.166]                               "release", "version")], collapse = " "), 
[16:17:50.166]                             hostname = base::Sys.info()[["nodename"]])
[16:17:50.166]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:50.166]                             info)
[16:17:50.166]                           info <- base::paste(info, collapse = "; ")
[16:17:50.166]                           if (!has_future) {
[16:17:50.166]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:50.166]                               info)
[16:17:50.166]                           }
[16:17:50.166]                           else {
[16:17:50.166]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:50.166]                               info, version)
[16:17:50.166]                           }
[16:17:50.166]                           base::stop(msg)
[16:17:50.166]                         }
[16:17:50.166]                       })
[16:17:50.166]                     }
[16:17:50.166]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:50.166]                     base::options(mc.cores = 1L)
[16:17:50.166]                   }
[16:17:50.166]                   ...future.strategy.old <- future::plan("list")
[16:17:50.166]                   options(future.plan = NULL)
[16:17:50.166]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:50.166]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:50.166]                 }
[16:17:50.166]                 ...future.workdir <- getwd()
[16:17:50.166]             }
[16:17:50.166]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:50.166]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:50.166]         }
[16:17:50.166]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:50.166]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:50.166]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:50.166]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:50.166]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:50.166]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:50.166]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:50.166]             base::names(...future.oldOptions))
[16:17:50.166]     }
[16:17:50.166]     if (FALSE) {
[16:17:50.166]     }
[16:17:50.166]     else {
[16:17:50.166]         if (TRUE) {
[16:17:50.166]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:50.166]                 open = "w")
[16:17:50.166]         }
[16:17:50.166]         else {
[16:17:50.166]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:50.166]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:50.166]         }
[16:17:50.166]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:50.166]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:50.166]             base::sink(type = "output", split = FALSE)
[16:17:50.166]             base::close(...future.stdout)
[16:17:50.166]         }, add = TRUE)
[16:17:50.166]     }
[16:17:50.166]     ...future.frame <- base::sys.nframe()
[16:17:50.166]     ...future.conditions <- base::list()
[16:17:50.166]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:50.166]     if (FALSE) {
[16:17:50.166]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:50.166]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:50.166]     }
[16:17:50.166]     ...future.result <- base::tryCatch({
[16:17:50.166]         base::withCallingHandlers({
[16:17:50.166]             ...future.value <- base::withVisible(base::local({
[16:17:50.166]                 withCallingHandlers({
[16:17:50.166]                   {
[16:17:50.166]                     do.call(function(...) {
[16:17:50.166]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.166]                       if (!identical(...future.globals.maxSize.org, 
[16:17:50.166]                         ...future.globals.maxSize)) {
[16:17:50.166]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.166]                         on.exit(options(oopts), add = TRUE)
[16:17:50.166]                       }
[16:17:50.166]                       {
[16:17:50.166]                         lapply(seq_along(...future.elements_ii), 
[16:17:50.166]                           FUN = function(jj) {
[16:17:50.166]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.166]                             ...future.FUN(...future.X_jj, ...)
[16:17:50.166]                           })
[16:17:50.166]                       }
[16:17:50.166]                     }, args = future.call.arguments)
[16:17:50.166]                   }
[16:17:50.166]                 }, immediateCondition = function(cond) {
[16:17:50.166]                   save_rds <- function (object, pathname, ...) 
[16:17:50.166]                   {
[16:17:50.166]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:50.166]                     if (file_test("-f", pathname_tmp)) {
[16:17:50.166]                       fi_tmp <- file.info(pathname_tmp)
[16:17:50.166]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:50.166]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:50.166]                         fi_tmp[["mtime"]])
[16:17:50.166]                     }
[16:17:50.166]                     tryCatch({
[16:17:50.166]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:50.166]                     }, error = function(ex) {
[16:17:50.166]                       msg <- conditionMessage(ex)
[16:17:50.166]                       fi_tmp <- file.info(pathname_tmp)
[16:17:50.166]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:50.166]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:50.166]                         fi_tmp[["mtime"]], msg)
[16:17:50.166]                       ex$message <- msg
[16:17:50.166]                       stop(ex)
[16:17:50.166]                     })
[16:17:50.166]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:50.166]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:50.166]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:50.166]                       fi_tmp <- file.info(pathname_tmp)
[16:17:50.166]                       fi <- file.info(pathname)
[16:17:50.166]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:50.166]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:50.166]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:50.166]                         fi[["size"]], fi[["mtime"]])
[16:17:50.166]                       stop(msg)
[16:17:50.166]                     }
[16:17:50.166]                     invisible(pathname)
[16:17:50.166]                   }
[16:17:50.166]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:50.166]                     rootPath = tempdir()) 
[16:17:50.166]                   {
[16:17:50.166]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:50.166]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:50.166]                       tmpdir = path, fileext = ".rds")
[16:17:50.166]                     save_rds(obj, file)
[16:17:50.166]                   }
[16:17:50.166]                   saveImmediateCondition(cond, path = "/tmp/Rtmpstkvtd/.future/immediateConditions")
[16:17:50.166]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.166]                   {
[16:17:50.166]                     inherits <- base::inherits
[16:17:50.166]                     invokeRestart <- base::invokeRestart
[16:17:50.166]                     is.null <- base::is.null
[16:17:50.166]                     muffled <- FALSE
[16:17:50.166]                     if (inherits(cond, "message")) {
[16:17:50.166]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:50.166]                       if (muffled) 
[16:17:50.166]                         invokeRestart("muffleMessage")
[16:17:50.166]                     }
[16:17:50.166]                     else if (inherits(cond, "warning")) {
[16:17:50.166]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:50.166]                       if (muffled) 
[16:17:50.166]                         invokeRestart("muffleWarning")
[16:17:50.166]                     }
[16:17:50.166]                     else if (inherits(cond, "condition")) {
[16:17:50.166]                       if (!is.null(pattern)) {
[16:17:50.166]                         computeRestarts <- base::computeRestarts
[16:17:50.166]                         grepl <- base::grepl
[16:17:50.166]                         restarts <- computeRestarts(cond)
[16:17:50.166]                         for (restart in restarts) {
[16:17:50.166]                           name <- restart$name
[16:17:50.166]                           if (is.null(name)) 
[16:17:50.166]                             next
[16:17:50.166]                           if (!grepl(pattern, name)) 
[16:17:50.166]                             next
[16:17:50.166]                           invokeRestart(restart)
[16:17:50.166]                           muffled <- TRUE
[16:17:50.166]                           break
[16:17:50.166]                         }
[16:17:50.166]                       }
[16:17:50.166]                     }
[16:17:50.166]                     invisible(muffled)
[16:17:50.166]                   }
[16:17:50.166]                   muffleCondition(cond)
[16:17:50.166]                 })
[16:17:50.166]             }))
[16:17:50.166]             future::FutureResult(value = ...future.value$value, 
[16:17:50.166]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:50.166]                   ...future.rng), globalenv = if (FALSE) 
[16:17:50.166]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:50.166]                     ...future.globalenv.names))
[16:17:50.166]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:50.166]         }, condition = base::local({
[16:17:50.166]             c <- base::c
[16:17:50.166]             inherits <- base::inherits
[16:17:50.166]             invokeRestart <- base::invokeRestart
[16:17:50.166]             length <- base::length
[16:17:50.166]             list <- base::list
[16:17:50.166]             seq.int <- base::seq.int
[16:17:50.166]             signalCondition <- base::signalCondition
[16:17:50.166]             sys.calls <- base::sys.calls
[16:17:50.166]             `[[` <- base::`[[`
[16:17:50.166]             `+` <- base::`+`
[16:17:50.166]             `<<-` <- base::`<<-`
[16:17:50.166]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:50.166]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:50.166]                   3L)]
[16:17:50.166]             }
[16:17:50.166]             function(cond) {
[16:17:50.166]                 is_error <- inherits(cond, "error")
[16:17:50.166]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:50.166]                   NULL)
[16:17:50.166]                 if (is_error) {
[16:17:50.166]                   sessionInformation <- function() {
[16:17:50.166]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:50.166]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:50.166]                       search = base::search(), system = base::Sys.info())
[16:17:50.166]                   }
[16:17:50.166]                   ...future.conditions[[length(...future.conditions) + 
[16:17:50.166]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:50.166]                     cond$call), session = sessionInformation(), 
[16:17:50.166]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:50.166]                   signalCondition(cond)
[16:17:50.166]                 }
[16:17:50.166]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:50.166]                 "immediateCondition"))) {
[16:17:50.166]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:50.166]                   ...future.conditions[[length(...future.conditions) + 
[16:17:50.166]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:50.166]                   if (TRUE && !signal) {
[16:17:50.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.166]                     {
[16:17:50.166]                       inherits <- base::inherits
[16:17:50.166]                       invokeRestart <- base::invokeRestart
[16:17:50.166]                       is.null <- base::is.null
[16:17:50.166]                       muffled <- FALSE
[16:17:50.166]                       if (inherits(cond, "message")) {
[16:17:50.166]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:50.166]                         if (muffled) 
[16:17:50.166]                           invokeRestart("muffleMessage")
[16:17:50.166]                       }
[16:17:50.166]                       else if (inherits(cond, "warning")) {
[16:17:50.166]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:50.166]                         if (muffled) 
[16:17:50.166]                           invokeRestart("muffleWarning")
[16:17:50.166]                       }
[16:17:50.166]                       else if (inherits(cond, "condition")) {
[16:17:50.166]                         if (!is.null(pattern)) {
[16:17:50.166]                           computeRestarts <- base::computeRestarts
[16:17:50.166]                           grepl <- base::grepl
[16:17:50.166]                           restarts <- computeRestarts(cond)
[16:17:50.166]                           for (restart in restarts) {
[16:17:50.166]                             name <- restart$name
[16:17:50.166]                             if (is.null(name)) 
[16:17:50.166]                               next
[16:17:50.166]                             if (!grepl(pattern, name)) 
[16:17:50.166]                               next
[16:17:50.166]                             invokeRestart(restart)
[16:17:50.166]                             muffled <- TRUE
[16:17:50.166]                             break
[16:17:50.166]                           }
[16:17:50.166]                         }
[16:17:50.166]                       }
[16:17:50.166]                       invisible(muffled)
[16:17:50.166]                     }
[16:17:50.166]                     muffleCondition(cond, pattern = "^muffle")
[16:17:50.166]                   }
[16:17:50.166]                 }
[16:17:50.166]                 else {
[16:17:50.166]                   if (TRUE) {
[16:17:50.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.166]                     {
[16:17:50.166]                       inherits <- base::inherits
[16:17:50.166]                       invokeRestart <- base::invokeRestart
[16:17:50.166]                       is.null <- base::is.null
[16:17:50.166]                       muffled <- FALSE
[16:17:50.166]                       if (inherits(cond, "message")) {
[16:17:50.166]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:50.166]                         if (muffled) 
[16:17:50.166]                           invokeRestart("muffleMessage")
[16:17:50.166]                       }
[16:17:50.166]                       else if (inherits(cond, "warning")) {
[16:17:50.166]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:50.166]                         if (muffled) 
[16:17:50.166]                           invokeRestart("muffleWarning")
[16:17:50.166]                       }
[16:17:50.166]                       else if (inherits(cond, "condition")) {
[16:17:50.166]                         if (!is.null(pattern)) {
[16:17:50.166]                           computeRestarts <- base::computeRestarts
[16:17:50.166]                           grepl <- base::grepl
[16:17:50.166]                           restarts <- computeRestarts(cond)
[16:17:50.166]                           for (restart in restarts) {
[16:17:50.166]                             name <- restart$name
[16:17:50.166]                             if (is.null(name)) 
[16:17:50.166]                               next
[16:17:50.166]                             if (!grepl(pattern, name)) 
[16:17:50.166]                               next
[16:17:50.166]                             invokeRestart(restart)
[16:17:50.166]                             muffled <- TRUE
[16:17:50.166]                             break
[16:17:50.166]                           }
[16:17:50.166]                         }
[16:17:50.166]                       }
[16:17:50.166]                       invisible(muffled)
[16:17:50.166]                     }
[16:17:50.166]                     muffleCondition(cond, pattern = "^muffle")
[16:17:50.166]                   }
[16:17:50.166]                 }
[16:17:50.166]             }
[16:17:50.166]         }))
[16:17:50.166]     }, error = function(ex) {
[16:17:50.166]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:50.166]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:50.166]                 ...future.rng), started = ...future.startTime, 
[16:17:50.166]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:50.166]             version = "1.8"), class = "FutureResult")
[16:17:50.166]     }, finally = {
[16:17:50.166]         if (!identical(...future.workdir, getwd())) 
[16:17:50.166]             setwd(...future.workdir)
[16:17:50.166]         {
[16:17:50.166]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:50.166]                 ...future.oldOptions$nwarnings <- NULL
[16:17:50.166]             }
[16:17:50.166]             base::options(...future.oldOptions)
[16:17:50.166]             if (.Platform$OS.type == "windows") {
[16:17:50.166]                 old_names <- names(...future.oldEnvVars)
[16:17:50.166]                 envs <- base::Sys.getenv()
[16:17:50.166]                 names <- names(envs)
[16:17:50.166]                 common <- intersect(names, old_names)
[16:17:50.166]                 added <- setdiff(names, old_names)
[16:17:50.166]                 removed <- setdiff(old_names, names)
[16:17:50.166]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:50.166]                   envs[common]]
[16:17:50.166]                 NAMES <- toupper(changed)
[16:17:50.166]                 args <- list()
[16:17:50.166]                 for (kk in seq_along(NAMES)) {
[16:17:50.166]                   name <- changed[[kk]]
[16:17:50.166]                   NAME <- NAMES[[kk]]
[16:17:50.166]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.166]                     next
[16:17:50.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:50.166]                 }
[16:17:50.166]                 NAMES <- toupper(added)
[16:17:50.166]                 for (kk in seq_along(NAMES)) {
[16:17:50.166]                   name <- added[[kk]]
[16:17:50.166]                   NAME <- NAMES[[kk]]
[16:17:50.166]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.166]                     next
[16:17:50.166]                   args[[name]] <- ""
[16:17:50.166]                 }
[16:17:50.166]                 NAMES <- toupper(removed)
[16:17:50.166]                 for (kk in seq_along(NAMES)) {
[16:17:50.166]                   name <- removed[[kk]]
[16:17:50.166]                   NAME <- NAMES[[kk]]
[16:17:50.166]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.166]                     next
[16:17:50.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:50.166]                 }
[16:17:50.166]                 if (length(args) > 0) 
[16:17:50.166]                   base::do.call(base::Sys.setenv, args = args)
[16:17:50.166]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:50.166]             }
[16:17:50.166]             else {
[16:17:50.166]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:50.166]             }
[16:17:50.166]             {
[16:17:50.166]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:50.166]                   0L) {
[16:17:50.166]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:50.166]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:50.166]                   base::options(opts)
[16:17:50.166]                 }
[16:17:50.166]                 {
[16:17:50.166]                   {
[16:17:50.166]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:50.166]                     NULL
[16:17:50.166]                   }
[16:17:50.166]                   options(future.plan = NULL)
[16:17:50.166]                   if (is.na(NA_character_)) 
[16:17:50.166]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:50.166]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:50.166]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:50.166]                     .init = FALSE)
[16:17:50.166]                 }
[16:17:50.166]             }
[16:17:50.166]         }
[16:17:50.166]     })
[16:17:50.166]     if (TRUE) {
[16:17:50.166]         base::sink(type = "output", split = FALSE)
[16:17:50.166]         if (TRUE) {
[16:17:50.166]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:50.166]         }
[16:17:50.166]         else {
[16:17:50.166]             ...future.result["stdout"] <- base::list(NULL)
[16:17:50.166]         }
[16:17:50.166]         base::close(...future.stdout)
[16:17:50.166]         ...future.stdout <- NULL
[16:17:50.166]     }
[16:17:50.166]     ...future.result$conditions <- ...future.conditions
[16:17:50.166]     ...future.result$finished <- base::Sys.time()
[16:17:50.166]     ...future.result
[16:17:50.166] }
[16:17:50.169] assign_globals() ...
[16:17:50.169] List of 5
[16:17:50.169]  $ ...future.FUN            :function (x, ...)  
[16:17:50.169]  $ future.call.arguments    : list()
[16:17:50.169]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:50.169]  $ ...future.elements_ii    :List of 2
[16:17:50.169]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:17:50.169]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:17:50.169]  $ ...future.seeds_ii       : NULL
[16:17:50.169]  $ ...future.globals.maxSize: NULL
[16:17:50.169]  - attr(*, "where")=List of 5
[16:17:50.169]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:50.169]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:50.169]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:50.169]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:50.169]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:50.169]  - attr(*, "resolved")= logi FALSE
[16:17:50.169]  - attr(*, "total_size")= num 1240
[16:17:50.169]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:50.169]  - attr(*, "already-done")= logi TRUE
[16:17:50.181] - copied ‘...future.FUN’ to environment
[16:17:50.181] - copied ‘future.call.arguments’ to environment
[16:17:50.181] - copied ‘...future.elements_ii’ to environment
[16:17:50.182] - copied ‘...future.seeds_ii’ to environment
[16:17:50.182] - copied ‘...future.globals.maxSize’ to environment
[16:17:50.182] assign_globals() ... done
[16:17:50.182] requestCore(): workers = 2
[16:17:50.188] MulticoreFuture started
[16:17:50.189] - Launch lazy future ... done
[16:17:50.189] run() for ‘MulticoreFuture’ ... done
[16:17:50.189] Created future:
[16:17:50.189] plan(): Setting new future strategy stack:
[16:17:50.190] List of future strategies:
[16:17:50.190] 1. sequential:
[16:17:50.190]    - args: function (..., envir = parent.frame())
[16:17:50.190]    - tweaked: FALSE
[16:17:50.190]    - call: NULL
[16:17:50.191] plan(): nbrOfWorkers() = 1
[16:17:50.193] plan(): Setting new future strategy stack:
[16:17:50.193] List of future strategies:
[16:17:50.193] 1. multicore:
[16:17:50.193]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:50.193]    - tweaked: FALSE
[16:17:50.193]    - call: plan(strategy)
[16:17:50.198] plan(): nbrOfWorkers() = 2
[16:17:50.189] MulticoreFuture:
[16:17:50.189] Label: ‘future_eapply-2’
[16:17:50.189] Expression:
[16:17:50.189] {
[16:17:50.189]     do.call(function(...) {
[16:17:50.189]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.189]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:50.189]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.189]             on.exit(options(oopts), add = TRUE)
[16:17:50.189]         }
[16:17:50.189]         {
[16:17:50.189]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:50.189]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.189]                 ...future.FUN(...future.X_jj, ...)
[16:17:50.189]             })
[16:17:50.189]         }
[16:17:50.189]     }, args = future.call.arguments)
[16:17:50.189] }
[16:17:50.189] Lazy evaluation: FALSE
[16:17:50.189] Asynchronous evaluation: TRUE
[16:17:50.189] Local evaluation: TRUE
[16:17:50.189] Environment: R_GlobalEnv
[16:17:50.189] Capture standard output: TRUE
[16:17:50.189] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:50.189] Globals: 5 objects totaling 1.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:50.189] Packages: <none>
[16:17:50.189] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:50.189] Resolved: TRUE
[16:17:50.189] Value: <not collected>
[16:17:50.189] Conditions captured: <none>
[16:17:50.189] Early signaling: FALSE
[16:17:50.189] Owner process: 95d59565-e757-824f-7f5c-7f754384cffc
[16:17:50.189] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:50.199] Chunk #2 of 2 ... DONE
[16:17:50.199] Launching 2 futures (chunks) ... DONE
[16:17:50.199] Resolving 2 futures (chunks) ...
[16:17:50.199] resolve() on list ...
[16:17:50.199]  recursive: 0
[16:17:50.200]  length: 2
[16:17:50.200] 
[16:17:50.200] Future #1
[16:17:50.201] result() for MulticoreFuture ...
[16:17:50.202] result() for MulticoreFuture ...
[16:17:50.203] result() for MulticoreFuture ... done
[16:17:50.203] result() for MulticoreFuture ... done
[16:17:50.203] result() for MulticoreFuture ...
[16:17:50.203] result() for MulticoreFuture ... done
[16:17:50.203] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:17:50.203] - nx: 2
[16:17:50.204] - relay: TRUE
[16:17:50.204] - stdout: TRUE
[16:17:50.204] - signal: TRUE
[16:17:50.204] - resignal: FALSE
[16:17:50.204] - force: TRUE
[16:17:50.204] - relayed: [n=2] FALSE, FALSE
[16:17:50.204] - queued futures: [n=2] FALSE, FALSE
[16:17:50.204]  - until=1
[16:17:50.205]  - relaying element #1
[16:17:50.205] result() for MulticoreFuture ...
[16:17:50.205] result() for MulticoreFuture ... done
[16:17:50.205] result() for MulticoreFuture ...
[16:17:50.205] result() for MulticoreFuture ... done
[16:17:50.205] result() for MulticoreFuture ...
[16:17:50.206] result() for MulticoreFuture ... done
[16:17:50.206] result() for MulticoreFuture ...
[16:17:50.206] result() for MulticoreFuture ... done
[16:17:50.206] - relayed: [n=2] TRUE, FALSE
[16:17:50.206] - queued futures: [n=2] TRUE, FALSE
[16:17:50.206] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:17:50.206]  length: 1 (resolved future 1)
[16:17:50.207] Future #2
[16:17:50.207] result() for MulticoreFuture ...
[16:17:50.208] result() for MulticoreFuture ...
[16:17:50.208] result() for MulticoreFuture ... done
[16:17:50.208] result() for MulticoreFuture ... done
[16:17:50.208] result() for MulticoreFuture ...
[16:17:50.208] result() for MulticoreFuture ... done
[16:17:50.208] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:17:50.208] - nx: 2
[16:17:50.209] - relay: TRUE
[16:17:50.209] - stdout: TRUE
[16:17:50.209] - signal: TRUE
[16:17:50.209] - resignal: FALSE
[16:17:50.209] - force: TRUE
[16:17:50.209] - relayed: [n=2] TRUE, FALSE
[16:17:50.209] - queued futures: [n=2] TRUE, FALSE
[16:17:50.209]  - until=2
[16:17:50.210]  - relaying element #2
[16:17:50.210] result() for MulticoreFuture ...
[16:17:50.210] result() for MulticoreFuture ... done
[16:17:50.210] result() for MulticoreFuture ...
[16:17:50.210] result() for MulticoreFuture ... done
[16:17:50.210] result() for MulticoreFuture ...
[16:17:50.210] result() for MulticoreFuture ... done
[16:17:50.210] result() for MulticoreFuture ...
[16:17:50.210] result() for MulticoreFuture ... done
[16:17:50.211] - relayed: [n=2] TRUE, TRUE
[16:17:50.211] - queued futures: [n=2] TRUE, TRUE
[16:17:50.211] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:17:50.211]  length: 0 (resolved future 2)
[16:17:50.211] Relaying remaining futures
[16:17:50.211] signalConditionsASAP(NULL, pos=0) ...
[16:17:50.211] - nx: 2
[16:17:50.211] - relay: TRUE
[16:17:50.211] - stdout: TRUE
[16:17:50.212] - signal: TRUE
[16:17:50.212] - resignal: FALSE
[16:17:50.212] - force: TRUE
[16:17:50.212] - relayed: [n=2] TRUE, TRUE
[16:17:50.212] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:50.212] - relayed: [n=2] TRUE, TRUE
[16:17:50.212] - queued futures: [n=2] TRUE, TRUE
[16:17:50.212] signalConditionsASAP(NULL, pos=0) ... done
[16:17:50.212] resolve() on list ... DONE
[16:17:50.213] result() for MulticoreFuture ...
[16:17:50.213] result() for MulticoreFuture ... done
[16:17:50.213] result() for MulticoreFuture ...
[16:17:50.213] result() for MulticoreFuture ... done
[16:17:50.213] result() for MulticoreFuture ...
[16:17:50.213] result() for MulticoreFuture ... done
[16:17:50.213] result() for MulticoreFuture ...
[16:17:50.213] result() for MulticoreFuture ... done
[16:17:50.213]  - Number of value chunks collected: 2
[16:17:50.214] Resolving 2 futures (chunks) ... DONE
[16:17:50.214] Reducing values from 2 chunks ...
[16:17:50.214]  - Number of values collected after concatenation: 3
[16:17:50.214]  - Number of values expected: 3
[16:17:50.214] Reducing values from 2 chunks ... DONE
[16:17:50.214] future_lapply() ... DONE
[16:17:50.215] future_lapply() ...
[16:17:50.221] Number of chunks: 2
[16:17:50.222] getGlobalsAndPackagesXApply() ...
[16:17:50.222]  - future.globals: TRUE
[16:17:50.222] getGlobalsAndPackages() ...
[16:17:50.222] Searching for globals...
[16:17:50.224] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:50.224] Searching for globals ... DONE
[16:17:50.224] Resolving globals: FALSE
[16:17:50.225] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:17:50.225] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:17:50.225] - globals: [1] ‘FUN’
[16:17:50.225] - packages: [1] ‘stats’
[16:17:50.225] getGlobalsAndPackages() ... DONE
[16:17:50.226]  - globals found/used: [n=1] ‘FUN’
[16:17:50.226]  - needed namespaces: [n=1] ‘stats’
[16:17:50.226] Finding globals ... DONE
[16:17:50.226]  - use_args: TRUE
[16:17:50.226]  - Getting '...' globals ...
[16:17:50.226] resolve() on list ...
[16:17:50.227]  recursive: 0
[16:17:50.227]  length: 1
[16:17:50.227]  elements: ‘...’
[16:17:50.227]  length: 0 (resolved future 1)
[16:17:50.227] resolve() on list ... DONE
[16:17:50.227]    - '...' content: [n=1] ‘probs’
[16:17:50.227] List of 1
[16:17:50.227]  $ ...:List of 1
[16:17:50.227]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:17:50.227]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:50.227]  - attr(*, "where")=List of 1
[16:17:50.227]   ..$ ...:<environment: 0x556da5259fb0> 
[16:17:50.227]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:50.227]  - attr(*, "resolved")= logi TRUE
[16:17:50.227]  - attr(*, "total_size")= num NA
[16:17:50.231]  - Getting '...' globals ... DONE
[16:17:50.231] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:50.231] List of 2
[16:17:50.231]  $ ...future.FUN:function (x, ...)  
[16:17:50.231]  $ ...          :List of 1
[16:17:50.231]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:17:50.231]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:50.231]  - attr(*, "where")=List of 2
[16:17:50.231]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:50.231]   ..$ ...          :<environment: 0x556da5259fb0> 
[16:17:50.231]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:50.231]  - attr(*, "resolved")= logi FALSE
[16:17:50.231]  - attr(*, "total_size")= num 1328
[16:17:50.234] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:50.234] getGlobalsAndPackagesXApply() ... DONE
[16:17:50.235] Number of futures (= number of chunks): 2
[16:17:50.235] Launching 2 futures (chunks) ...
[16:17:50.235] Chunk #1 of 2 ...
[16:17:50.235]  - Finding globals in 'X' for chunk #1 ...
[16:17:50.235] getGlobalsAndPackages() ...
[16:17:50.235] Searching for globals...
[16:17:50.235] 
[16:17:50.235] Searching for globals ... DONE
[16:17:50.236] - globals: [0] <none>
[16:17:50.236] getGlobalsAndPackages() ... DONE
[16:17:50.236]    + additional globals found: [n=0] 
[16:17:50.236]    + additional namespaces needed: [n=0] 
[16:17:50.236]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:50.236]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:50.236]  - seeds: <none>
[16:17:50.236]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.236] getGlobalsAndPackages() ...
[16:17:50.236] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.237] Resolving globals: FALSE
[16:17:50.237] Tweak future expression to call with '...' arguments ...
[16:17:50.237] {
[16:17:50.237]     do.call(function(...) {
[16:17:50.237]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.237]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:50.237]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.237]             on.exit(options(oopts), add = TRUE)
[16:17:50.237]         }
[16:17:50.237]         {
[16:17:50.237]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:50.237]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.237]                 ...future.FUN(...future.X_jj, ...)
[16:17:50.237]             })
[16:17:50.237]         }
[16:17:50.237]     }, args = future.call.arguments)
[16:17:50.237] }
[16:17:50.237] Tweak future expression to call with '...' arguments ... DONE
[16:17:50.237] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.238] - packages: [1] ‘stats’
[16:17:50.238] getGlobalsAndPackages() ... DONE
[16:17:50.238] run() for ‘Future’ ...
[16:17:50.238] - state: ‘created’
[16:17:50.238] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:50.242] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:50.242] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:50.242]   - Field: ‘label’
[16:17:50.242]   - Field: ‘local’
[16:17:50.242]   - Field: ‘owner’
[16:17:50.242]   - Field: ‘envir’
[16:17:50.242]   - Field: ‘workers’
[16:17:50.242]   - Field: ‘packages’
[16:17:50.243]   - Field: ‘gc’
[16:17:50.243]   - Field: ‘job’
[16:17:50.243]   - Field: ‘conditions’
[16:17:50.243]   - Field: ‘expr’
[16:17:50.243]   - Field: ‘uuid’
[16:17:50.243]   - Field: ‘seed’
[16:17:50.243]   - Field: ‘version’
[16:17:50.243]   - Field: ‘result’
[16:17:50.243]   - Field: ‘asynchronous’
[16:17:50.243]   - Field: ‘calls’
[16:17:50.243]   - Field: ‘globals’
[16:17:50.244]   - Field: ‘stdout’
[16:17:50.244]   - Field: ‘earlySignal’
[16:17:50.244]   - Field: ‘lazy’
[16:17:50.244]   - Field: ‘state’
[16:17:50.244] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:50.244] - Launch lazy future ...
[16:17:50.244] Packages needed by the future expression (n = 1): ‘stats’
[16:17:50.244] Packages needed by future strategies (n = 0): <none>
[16:17:50.245] {
[16:17:50.245]     {
[16:17:50.245]         {
[16:17:50.245]             ...future.startTime <- base::Sys.time()
[16:17:50.245]             {
[16:17:50.245]                 {
[16:17:50.245]                   {
[16:17:50.245]                     {
[16:17:50.245]                       {
[16:17:50.245]                         base::local({
[16:17:50.245]                           has_future <- base::requireNamespace("future", 
[16:17:50.245]                             quietly = TRUE)
[16:17:50.245]                           if (has_future) {
[16:17:50.245]                             ns <- base::getNamespace("future")
[16:17:50.245]                             version <- ns[[".package"]][["version"]]
[16:17:50.245]                             if (is.null(version)) 
[16:17:50.245]                               version <- utils::packageVersion("future")
[16:17:50.245]                           }
[16:17:50.245]                           else {
[16:17:50.245]                             version <- NULL
[16:17:50.245]                           }
[16:17:50.245]                           if (!has_future || version < "1.8.0") {
[16:17:50.245]                             info <- base::c(r_version = base::gsub("R version ", 
[16:17:50.245]                               "", base::R.version$version.string), 
[16:17:50.245]                               platform = base::sprintf("%s (%s-bit)", 
[16:17:50.245]                                 base::R.version$platform, 8 * 
[16:17:50.245]                                   base::.Machine$sizeof.pointer), 
[16:17:50.245]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:50.245]                                 "release", "version")], collapse = " "), 
[16:17:50.245]                               hostname = base::Sys.info()[["nodename"]])
[16:17:50.245]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:17:50.245]                               info)
[16:17:50.245]                             info <- base::paste(info, collapse = "; ")
[16:17:50.245]                             if (!has_future) {
[16:17:50.245]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:50.245]                                 info)
[16:17:50.245]                             }
[16:17:50.245]                             else {
[16:17:50.245]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:50.245]                                 info, version)
[16:17:50.245]                             }
[16:17:50.245]                             base::stop(msg)
[16:17:50.245]                           }
[16:17:50.245]                         })
[16:17:50.245]                       }
[16:17:50.245]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:50.245]                       base::options(mc.cores = 1L)
[16:17:50.245]                     }
[16:17:50.245]                     base::local({
[16:17:50.245]                       for (pkg in "stats") {
[16:17:50.245]                         base::loadNamespace(pkg)
[16:17:50.245]                         base::library(pkg, character.only = TRUE)
[16:17:50.245]                       }
[16:17:50.245]                     })
[16:17:50.245]                   }
[16:17:50.245]                   ...future.strategy.old <- future::plan("list")
[16:17:50.245]                   options(future.plan = NULL)
[16:17:50.245]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:50.245]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:50.245]                 }
[16:17:50.245]                 ...future.workdir <- getwd()
[16:17:50.245]             }
[16:17:50.245]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:50.245]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:50.245]         }
[16:17:50.245]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:50.245]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:50.245]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:50.245]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:50.245]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:50.245]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:50.245]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:50.245]             base::names(...future.oldOptions))
[16:17:50.245]     }
[16:17:50.245]     if (FALSE) {
[16:17:50.245]     }
[16:17:50.245]     else {
[16:17:50.245]         if (TRUE) {
[16:17:50.245]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:50.245]                 open = "w")
[16:17:50.245]         }
[16:17:50.245]         else {
[16:17:50.245]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:50.245]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:50.245]         }
[16:17:50.245]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:50.245]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:50.245]             base::sink(type = "output", split = FALSE)
[16:17:50.245]             base::close(...future.stdout)
[16:17:50.245]         }, add = TRUE)
[16:17:50.245]     }
[16:17:50.245]     ...future.frame <- base::sys.nframe()
[16:17:50.245]     ...future.conditions <- base::list()
[16:17:50.245]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:50.245]     if (FALSE) {
[16:17:50.245]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:50.245]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:50.245]     }
[16:17:50.245]     ...future.result <- base::tryCatch({
[16:17:50.245]         base::withCallingHandlers({
[16:17:50.245]             ...future.value <- base::withVisible(base::local({
[16:17:50.245]                 withCallingHandlers({
[16:17:50.245]                   {
[16:17:50.245]                     do.call(function(...) {
[16:17:50.245]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.245]                       if (!identical(...future.globals.maxSize.org, 
[16:17:50.245]                         ...future.globals.maxSize)) {
[16:17:50.245]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.245]                         on.exit(options(oopts), add = TRUE)
[16:17:50.245]                       }
[16:17:50.245]                       {
[16:17:50.245]                         lapply(seq_along(...future.elements_ii), 
[16:17:50.245]                           FUN = function(jj) {
[16:17:50.245]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.245]                             ...future.FUN(...future.X_jj, ...)
[16:17:50.245]                           })
[16:17:50.245]                       }
[16:17:50.245]                     }, args = future.call.arguments)
[16:17:50.245]                   }
[16:17:50.245]                 }, immediateCondition = function(cond) {
[16:17:50.245]                   save_rds <- function (object, pathname, ...) 
[16:17:50.245]                   {
[16:17:50.245]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:50.245]                     if (file_test("-f", pathname_tmp)) {
[16:17:50.245]                       fi_tmp <- file.info(pathname_tmp)
[16:17:50.245]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:50.245]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:50.245]                         fi_tmp[["mtime"]])
[16:17:50.245]                     }
[16:17:50.245]                     tryCatch({
[16:17:50.245]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:50.245]                     }, error = function(ex) {
[16:17:50.245]                       msg <- conditionMessage(ex)
[16:17:50.245]                       fi_tmp <- file.info(pathname_tmp)
[16:17:50.245]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:50.245]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:50.245]                         fi_tmp[["mtime"]], msg)
[16:17:50.245]                       ex$message <- msg
[16:17:50.245]                       stop(ex)
[16:17:50.245]                     })
[16:17:50.245]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:50.245]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:50.245]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:50.245]                       fi_tmp <- file.info(pathname_tmp)
[16:17:50.245]                       fi <- file.info(pathname)
[16:17:50.245]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:50.245]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:50.245]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:50.245]                         fi[["size"]], fi[["mtime"]])
[16:17:50.245]                       stop(msg)
[16:17:50.245]                     }
[16:17:50.245]                     invisible(pathname)
[16:17:50.245]                   }
[16:17:50.245]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:50.245]                     rootPath = tempdir()) 
[16:17:50.245]                   {
[16:17:50.245]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:50.245]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:50.245]                       tmpdir = path, fileext = ".rds")
[16:17:50.245]                     save_rds(obj, file)
[16:17:50.245]                   }
[16:17:50.245]                   saveImmediateCondition(cond, path = "/tmp/Rtmpstkvtd/.future/immediateConditions")
[16:17:50.245]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.245]                   {
[16:17:50.245]                     inherits <- base::inherits
[16:17:50.245]                     invokeRestart <- base::invokeRestart
[16:17:50.245]                     is.null <- base::is.null
[16:17:50.245]                     muffled <- FALSE
[16:17:50.245]                     if (inherits(cond, "message")) {
[16:17:50.245]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:50.245]                       if (muffled) 
[16:17:50.245]                         invokeRestart("muffleMessage")
[16:17:50.245]                     }
[16:17:50.245]                     else if (inherits(cond, "warning")) {
[16:17:50.245]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:50.245]                       if (muffled) 
[16:17:50.245]                         invokeRestart("muffleWarning")
[16:17:50.245]                     }
[16:17:50.245]                     else if (inherits(cond, "condition")) {
[16:17:50.245]                       if (!is.null(pattern)) {
[16:17:50.245]                         computeRestarts <- base::computeRestarts
[16:17:50.245]                         grepl <- base::grepl
[16:17:50.245]                         restarts <- computeRestarts(cond)
[16:17:50.245]                         for (restart in restarts) {
[16:17:50.245]                           name <- restart$name
[16:17:50.245]                           if (is.null(name)) 
[16:17:50.245]                             next
[16:17:50.245]                           if (!grepl(pattern, name)) 
[16:17:50.245]                             next
[16:17:50.245]                           invokeRestart(restart)
[16:17:50.245]                           muffled <- TRUE
[16:17:50.245]                           break
[16:17:50.245]                         }
[16:17:50.245]                       }
[16:17:50.245]                     }
[16:17:50.245]                     invisible(muffled)
[16:17:50.245]                   }
[16:17:50.245]                   muffleCondition(cond)
[16:17:50.245]                 })
[16:17:50.245]             }))
[16:17:50.245]             future::FutureResult(value = ...future.value$value, 
[16:17:50.245]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:50.245]                   ...future.rng), globalenv = if (FALSE) 
[16:17:50.245]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:50.245]                     ...future.globalenv.names))
[16:17:50.245]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:50.245]         }, condition = base::local({
[16:17:50.245]             c <- base::c
[16:17:50.245]             inherits <- base::inherits
[16:17:50.245]             invokeRestart <- base::invokeRestart
[16:17:50.245]             length <- base::length
[16:17:50.245]             list <- base::list
[16:17:50.245]             seq.int <- base::seq.int
[16:17:50.245]             signalCondition <- base::signalCondition
[16:17:50.245]             sys.calls <- base::sys.calls
[16:17:50.245]             `[[` <- base::`[[`
[16:17:50.245]             `+` <- base::`+`
[16:17:50.245]             `<<-` <- base::`<<-`
[16:17:50.245]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:50.245]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:50.245]                   3L)]
[16:17:50.245]             }
[16:17:50.245]             function(cond) {
[16:17:50.245]                 is_error <- inherits(cond, "error")
[16:17:50.245]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:50.245]                   NULL)
[16:17:50.245]                 if (is_error) {
[16:17:50.245]                   sessionInformation <- function() {
[16:17:50.245]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:50.245]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:50.245]                       search = base::search(), system = base::Sys.info())
[16:17:50.245]                   }
[16:17:50.245]                   ...future.conditions[[length(...future.conditions) + 
[16:17:50.245]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:50.245]                     cond$call), session = sessionInformation(), 
[16:17:50.245]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:50.245]                   signalCondition(cond)
[16:17:50.245]                 }
[16:17:50.245]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:50.245]                 "immediateCondition"))) {
[16:17:50.245]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:50.245]                   ...future.conditions[[length(...future.conditions) + 
[16:17:50.245]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:50.245]                   if (TRUE && !signal) {
[16:17:50.245]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.245]                     {
[16:17:50.245]                       inherits <- base::inherits
[16:17:50.245]                       invokeRestart <- base::invokeRestart
[16:17:50.245]                       is.null <- base::is.null
[16:17:50.245]                       muffled <- FALSE
[16:17:50.245]                       if (inherits(cond, "message")) {
[16:17:50.245]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:50.245]                         if (muffled) 
[16:17:50.245]                           invokeRestart("muffleMessage")
[16:17:50.245]                       }
[16:17:50.245]                       else if (inherits(cond, "warning")) {
[16:17:50.245]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:50.245]                         if (muffled) 
[16:17:50.245]                           invokeRestart("muffleWarning")
[16:17:50.245]                       }
[16:17:50.245]                       else if (inherits(cond, "condition")) {
[16:17:50.245]                         if (!is.null(pattern)) {
[16:17:50.245]                           computeRestarts <- base::computeRestarts
[16:17:50.245]                           grepl <- base::grepl
[16:17:50.245]                           restarts <- computeRestarts(cond)
[16:17:50.245]                           for (restart in restarts) {
[16:17:50.245]                             name <- restart$name
[16:17:50.245]                             if (is.null(name)) 
[16:17:50.245]                               next
[16:17:50.245]                             if (!grepl(pattern, name)) 
[16:17:50.245]                               next
[16:17:50.245]                             invokeRestart(restart)
[16:17:50.245]                             muffled <- TRUE
[16:17:50.245]                             break
[16:17:50.245]                           }
[16:17:50.245]                         }
[16:17:50.245]                       }
[16:17:50.245]                       invisible(muffled)
[16:17:50.245]                     }
[16:17:50.245]                     muffleCondition(cond, pattern = "^muffle")
[16:17:50.245]                   }
[16:17:50.245]                 }
[16:17:50.245]                 else {
[16:17:50.245]                   if (TRUE) {
[16:17:50.245]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.245]                     {
[16:17:50.245]                       inherits <- base::inherits
[16:17:50.245]                       invokeRestart <- base::invokeRestart
[16:17:50.245]                       is.null <- base::is.null
[16:17:50.245]                       muffled <- FALSE
[16:17:50.245]                       if (inherits(cond, "message")) {
[16:17:50.245]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:50.245]                         if (muffled) 
[16:17:50.245]                           invokeRestart("muffleMessage")
[16:17:50.245]                       }
[16:17:50.245]                       else if (inherits(cond, "warning")) {
[16:17:50.245]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:50.245]                         if (muffled) 
[16:17:50.245]                           invokeRestart("muffleWarning")
[16:17:50.245]                       }
[16:17:50.245]                       else if (inherits(cond, "condition")) {
[16:17:50.245]                         if (!is.null(pattern)) {
[16:17:50.245]                           computeRestarts <- base::computeRestarts
[16:17:50.245]                           grepl <- base::grepl
[16:17:50.245]                           restarts <- computeRestarts(cond)
[16:17:50.245]                           for (restart in restarts) {
[16:17:50.245]                             name <- restart$name
[16:17:50.245]                             if (is.null(name)) 
[16:17:50.245]                               next
[16:17:50.245]                             if (!grepl(pattern, name)) 
[16:17:50.245]                               next
[16:17:50.245]                             invokeRestart(restart)
[16:17:50.245]                             muffled <- TRUE
[16:17:50.245]                             break
[16:17:50.245]                           }
[16:17:50.245]                         }
[16:17:50.245]                       }
[16:17:50.245]                       invisible(muffled)
[16:17:50.245]                     }
[16:17:50.245]                     muffleCondition(cond, pattern = "^muffle")
[16:17:50.245]                   }
[16:17:50.245]                 }
[16:17:50.245]             }
[16:17:50.245]         }))
[16:17:50.245]     }, error = function(ex) {
[16:17:50.245]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:50.245]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:50.245]                 ...future.rng), started = ...future.startTime, 
[16:17:50.245]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:50.245]             version = "1.8"), class = "FutureResult")
[16:17:50.245]     }, finally = {
[16:17:50.245]         if (!identical(...future.workdir, getwd())) 
[16:17:50.245]             setwd(...future.workdir)
[16:17:50.245]         {
[16:17:50.245]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:50.245]                 ...future.oldOptions$nwarnings <- NULL
[16:17:50.245]             }
[16:17:50.245]             base::options(...future.oldOptions)
[16:17:50.245]             if (.Platform$OS.type == "windows") {
[16:17:50.245]                 old_names <- names(...future.oldEnvVars)
[16:17:50.245]                 envs <- base::Sys.getenv()
[16:17:50.245]                 names <- names(envs)
[16:17:50.245]                 common <- intersect(names, old_names)
[16:17:50.245]                 added <- setdiff(names, old_names)
[16:17:50.245]                 removed <- setdiff(old_names, names)
[16:17:50.245]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:50.245]                   envs[common]]
[16:17:50.245]                 NAMES <- toupper(changed)
[16:17:50.245]                 args <- list()
[16:17:50.245]                 for (kk in seq_along(NAMES)) {
[16:17:50.245]                   name <- changed[[kk]]
[16:17:50.245]                   NAME <- NAMES[[kk]]
[16:17:50.245]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.245]                     next
[16:17:50.245]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:50.245]                 }
[16:17:50.245]                 NAMES <- toupper(added)
[16:17:50.245]                 for (kk in seq_along(NAMES)) {
[16:17:50.245]                   name <- added[[kk]]
[16:17:50.245]                   NAME <- NAMES[[kk]]
[16:17:50.245]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.245]                     next
[16:17:50.245]                   args[[name]] <- ""
[16:17:50.245]                 }
[16:17:50.245]                 NAMES <- toupper(removed)
[16:17:50.245]                 for (kk in seq_along(NAMES)) {
[16:17:50.245]                   name <- removed[[kk]]
[16:17:50.245]                   NAME <- NAMES[[kk]]
[16:17:50.245]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.245]                     next
[16:17:50.245]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:50.245]                 }
[16:17:50.245]                 if (length(args) > 0) 
[16:17:50.245]                   base::do.call(base::Sys.setenv, args = args)
[16:17:50.245]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:50.245]             }
[16:17:50.245]             else {
[16:17:50.245]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:50.245]             }
[16:17:50.245]             {
[16:17:50.245]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:50.245]                   0L) {
[16:17:50.245]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:50.245]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:50.245]                   base::options(opts)
[16:17:50.245]                 }
[16:17:50.245]                 {
[16:17:50.245]                   {
[16:17:50.245]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:50.245]                     NULL
[16:17:50.245]                   }
[16:17:50.245]                   options(future.plan = NULL)
[16:17:50.245]                   if (is.na(NA_character_)) 
[16:17:50.245]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:50.245]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:50.245]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:50.245]                     .init = FALSE)
[16:17:50.245]                 }
[16:17:50.245]             }
[16:17:50.245]         }
[16:17:50.245]     })
[16:17:50.245]     if (TRUE) {
[16:17:50.245]         base::sink(type = "output", split = FALSE)
[16:17:50.245]         if (TRUE) {
[16:17:50.245]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:50.245]         }
[16:17:50.245]         else {
[16:17:50.245]             ...future.result["stdout"] <- base::list(NULL)
[16:17:50.245]         }
[16:17:50.245]         base::close(...future.stdout)
[16:17:50.245]         ...future.stdout <- NULL
[16:17:50.245]     }
[16:17:50.245]     ...future.result$conditions <- ...future.conditions
[16:17:50.245]     ...future.result$finished <- base::Sys.time()
[16:17:50.245]     ...future.result
[16:17:50.245] }
[16:17:50.247] assign_globals() ...
[16:17:50.247] List of 5
[16:17:50.247]  $ ...future.FUN            :function (x, ...)  
[16:17:50.247]  $ future.call.arguments    :List of 1
[16:17:50.247]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:17:50.247]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:50.247]  $ ...future.elements_ii    :List of 1
[16:17:50.247]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:17:50.247]  $ ...future.seeds_ii       : NULL
[16:17:50.247]  $ ...future.globals.maxSize: NULL
[16:17:50.247]  - attr(*, "where")=List of 5
[16:17:50.247]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:50.247]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:50.247]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:50.247]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:50.247]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:50.247]  - attr(*, "resolved")= logi FALSE
[16:17:50.247]  - attr(*, "total_size")= num 1328
[16:17:50.247]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:50.247]  - attr(*, "already-done")= logi TRUE
[16:17:50.254] - copied ‘...future.FUN’ to environment
[16:17:50.254] - copied ‘future.call.arguments’ to environment
[16:17:50.254] - copied ‘...future.elements_ii’ to environment
[16:17:50.254] - copied ‘...future.seeds_ii’ to environment
[16:17:50.254] - copied ‘...future.globals.maxSize’ to environment
[16:17:50.254] assign_globals() ... done
[16:17:50.254] requestCore(): workers = 2
[16:17:50.256] MulticoreFuture started
[16:17:50.257] - Launch lazy future ... done
[16:17:50.257] run() for ‘MulticoreFuture’ ... done
[16:17:50.257] Created future:
[16:17:50.258] plan(): Setting new future strategy stack:
[16:17:50.258] List of future strategies:
[16:17:50.258] 1. sequential:
[16:17:50.258]    - args: function (..., envir = parent.frame())
[16:17:50.258]    - tweaked: FALSE
[16:17:50.258]    - call: NULL
[16:17:50.259] plan(): nbrOfWorkers() = 1
[16:17:50.261] plan(): Setting new future strategy stack:
[16:17:50.261] List of future strategies:
[16:17:50.261] 1. multicore:
[16:17:50.261]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:50.261]    - tweaked: FALSE
[16:17:50.261]    - call: plan(strategy)
[16:17:50.267] plan(): nbrOfWorkers() = 2
[16:17:50.257] MulticoreFuture:
[16:17:50.257] Label: ‘future_eapply-1’
[16:17:50.257] Expression:
[16:17:50.257] {
[16:17:50.257]     do.call(function(...) {
[16:17:50.257]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.257]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:50.257]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.257]             on.exit(options(oopts), add = TRUE)
[16:17:50.257]         }
[16:17:50.257]         {
[16:17:50.257]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:50.257]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.257]                 ...future.FUN(...future.X_jj, ...)
[16:17:50.257]             })
[16:17:50.257]         }
[16:17:50.257]     }, args = future.call.arguments)
[16:17:50.257] }
[16:17:50.257] Lazy evaluation: FALSE
[16:17:50.257] Asynchronous evaluation: TRUE
[16:17:50.257] Local evaluation: TRUE
[16:17:50.257] Environment: R_GlobalEnv
[16:17:50.257] Capture standard output: TRUE
[16:17:50.257] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:50.257] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:50.257] Packages: 1 packages (‘stats’)
[16:17:50.257] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:50.257] Resolved: TRUE
[16:17:50.257] Value: <not collected>
[16:17:50.257] Conditions captured: <none>
[16:17:50.257] Early signaling: FALSE
[16:17:50.257] Owner process: 95d59565-e757-824f-7f5c-7f754384cffc
[16:17:50.257] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:50.268] Chunk #1 of 2 ... DONE
[16:17:50.268] Chunk #2 of 2 ...
[16:17:50.268]  - Finding globals in 'X' for chunk #2 ...
[16:17:50.268] getGlobalsAndPackages() ...
[16:17:50.269] Searching for globals...
[16:17:50.269] 
[16:17:50.269] Searching for globals ... DONE
[16:17:50.269] - globals: [0] <none>
[16:17:50.269] getGlobalsAndPackages() ... DONE
[16:17:50.270]    + additional globals found: [n=0] 
[16:17:50.270]    + additional namespaces needed: [n=0] 
[16:17:50.270]  - Finding globals in 'X' for chunk #2 ... DONE
[16:17:50.270]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:50.270]  - seeds: <none>
[16:17:50.270]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.270] getGlobalsAndPackages() ...
[16:17:50.270] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.271] Resolving globals: FALSE
[16:17:50.271] Tweak future expression to call with '...' arguments ...
[16:17:50.271] {
[16:17:50.271]     do.call(function(...) {
[16:17:50.271]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.271]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:50.271]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.271]             on.exit(options(oopts), add = TRUE)
[16:17:50.271]         }
[16:17:50.271]         {
[16:17:50.271]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:50.271]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.271]                 ...future.FUN(...future.X_jj, ...)
[16:17:50.271]             })
[16:17:50.271]         }
[16:17:50.271]     }, args = future.call.arguments)
[16:17:50.271] }
[16:17:50.271] Tweak future expression to call with '...' arguments ... DONE
[16:17:50.272] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.272] - packages: [1] ‘stats’
[16:17:50.272] getGlobalsAndPackages() ... DONE
[16:17:50.273] run() for ‘Future’ ...
[16:17:50.273] - state: ‘created’
[16:17:50.273] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:50.277] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:50.278] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:50.278]   - Field: ‘label’
[16:17:50.278]   - Field: ‘local’
[16:17:50.278]   - Field: ‘owner’
[16:17:50.278]   - Field: ‘envir’
[16:17:50.278]   - Field: ‘workers’
[16:17:50.279]   - Field: ‘packages’
[16:17:50.279]   - Field: ‘gc’
[16:17:50.279]   - Field: ‘job’
[16:17:50.279]   - Field: ‘conditions’
[16:17:50.279]   - Field: ‘expr’
[16:17:50.279]   - Field: ‘uuid’
[16:17:50.279]   - Field: ‘seed’
[16:17:50.280]   - Field: ‘version’
[16:17:50.280]   - Field: ‘result’
[16:17:50.280]   - Field: ‘asynchronous’
[16:17:50.280]   - Field: ‘calls’
[16:17:50.280]   - Field: ‘globals’
[16:17:50.280]   - Field: ‘stdout’
[16:17:50.280]   - Field: ‘earlySignal’
[16:17:50.281]   - Field: ‘lazy’
[16:17:50.281]   - Field: ‘state’
[16:17:50.281] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:50.281] - Launch lazy future ...
[16:17:50.281] Packages needed by the future expression (n = 1): ‘stats’
[16:17:50.282] Packages needed by future strategies (n = 0): <none>
[16:17:50.282] {
[16:17:50.282]     {
[16:17:50.282]         {
[16:17:50.282]             ...future.startTime <- base::Sys.time()
[16:17:50.282]             {
[16:17:50.282]                 {
[16:17:50.282]                   {
[16:17:50.282]                     {
[16:17:50.282]                       {
[16:17:50.282]                         base::local({
[16:17:50.282]                           has_future <- base::requireNamespace("future", 
[16:17:50.282]                             quietly = TRUE)
[16:17:50.282]                           if (has_future) {
[16:17:50.282]                             ns <- base::getNamespace("future")
[16:17:50.282]                             version <- ns[[".package"]][["version"]]
[16:17:50.282]                             if (is.null(version)) 
[16:17:50.282]                               version <- utils::packageVersion("future")
[16:17:50.282]                           }
[16:17:50.282]                           else {
[16:17:50.282]                             version <- NULL
[16:17:50.282]                           }
[16:17:50.282]                           if (!has_future || version < "1.8.0") {
[16:17:50.282]                             info <- base::c(r_version = base::gsub("R version ", 
[16:17:50.282]                               "", base::R.version$version.string), 
[16:17:50.282]                               platform = base::sprintf("%s (%s-bit)", 
[16:17:50.282]                                 base::R.version$platform, 8 * 
[16:17:50.282]                                   base::.Machine$sizeof.pointer), 
[16:17:50.282]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:50.282]                                 "release", "version")], collapse = " "), 
[16:17:50.282]                               hostname = base::Sys.info()[["nodename"]])
[16:17:50.282]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:17:50.282]                               info)
[16:17:50.282]                             info <- base::paste(info, collapse = "; ")
[16:17:50.282]                             if (!has_future) {
[16:17:50.282]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:50.282]                                 info)
[16:17:50.282]                             }
[16:17:50.282]                             else {
[16:17:50.282]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:50.282]                                 info, version)
[16:17:50.282]                             }
[16:17:50.282]                             base::stop(msg)
[16:17:50.282]                           }
[16:17:50.282]                         })
[16:17:50.282]                       }
[16:17:50.282]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:50.282]                       base::options(mc.cores = 1L)
[16:17:50.282]                     }
[16:17:50.282]                     base::local({
[16:17:50.282]                       for (pkg in "stats") {
[16:17:50.282]                         base::loadNamespace(pkg)
[16:17:50.282]                         base::library(pkg, character.only = TRUE)
[16:17:50.282]                       }
[16:17:50.282]                     })
[16:17:50.282]                   }
[16:17:50.282]                   ...future.strategy.old <- future::plan("list")
[16:17:50.282]                   options(future.plan = NULL)
[16:17:50.282]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:50.282]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:50.282]                 }
[16:17:50.282]                 ...future.workdir <- getwd()
[16:17:50.282]             }
[16:17:50.282]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:50.282]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:50.282]         }
[16:17:50.282]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:50.282]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:50.282]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:50.282]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:50.282]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:50.282]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:50.282]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:50.282]             base::names(...future.oldOptions))
[16:17:50.282]     }
[16:17:50.282]     if (FALSE) {
[16:17:50.282]     }
[16:17:50.282]     else {
[16:17:50.282]         if (TRUE) {
[16:17:50.282]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:50.282]                 open = "w")
[16:17:50.282]         }
[16:17:50.282]         else {
[16:17:50.282]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:50.282]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:50.282]         }
[16:17:50.282]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:50.282]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:50.282]             base::sink(type = "output", split = FALSE)
[16:17:50.282]             base::close(...future.stdout)
[16:17:50.282]         }, add = TRUE)
[16:17:50.282]     }
[16:17:50.282]     ...future.frame <- base::sys.nframe()
[16:17:50.282]     ...future.conditions <- base::list()
[16:17:50.282]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:50.282]     if (FALSE) {
[16:17:50.282]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:50.282]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:50.282]     }
[16:17:50.282]     ...future.result <- base::tryCatch({
[16:17:50.282]         base::withCallingHandlers({
[16:17:50.282]             ...future.value <- base::withVisible(base::local({
[16:17:50.282]                 withCallingHandlers({
[16:17:50.282]                   {
[16:17:50.282]                     do.call(function(...) {
[16:17:50.282]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.282]                       if (!identical(...future.globals.maxSize.org, 
[16:17:50.282]                         ...future.globals.maxSize)) {
[16:17:50.282]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.282]                         on.exit(options(oopts), add = TRUE)
[16:17:50.282]                       }
[16:17:50.282]                       {
[16:17:50.282]                         lapply(seq_along(...future.elements_ii), 
[16:17:50.282]                           FUN = function(jj) {
[16:17:50.282]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.282]                             ...future.FUN(...future.X_jj, ...)
[16:17:50.282]                           })
[16:17:50.282]                       }
[16:17:50.282]                     }, args = future.call.arguments)
[16:17:50.282]                   }
[16:17:50.282]                 }, immediateCondition = function(cond) {
[16:17:50.282]                   save_rds <- function (object, pathname, ...) 
[16:17:50.282]                   {
[16:17:50.282]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:50.282]                     if (file_test("-f", pathname_tmp)) {
[16:17:50.282]                       fi_tmp <- file.info(pathname_tmp)
[16:17:50.282]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:50.282]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:50.282]                         fi_tmp[["mtime"]])
[16:17:50.282]                     }
[16:17:50.282]                     tryCatch({
[16:17:50.282]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:50.282]                     }, error = function(ex) {
[16:17:50.282]                       msg <- conditionMessage(ex)
[16:17:50.282]                       fi_tmp <- file.info(pathname_tmp)
[16:17:50.282]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:50.282]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:50.282]                         fi_tmp[["mtime"]], msg)
[16:17:50.282]                       ex$message <- msg
[16:17:50.282]                       stop(ex)
[16:17:50.282]                     })
[16:17:50.282]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:50.282]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:50.282]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:50.282]                       fi_tmp <- file.info(pathname_tmp)
[16:17:50.282]                       fi <- file.info(pathname)
[16:17:50.282]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:50.282]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:50.282]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:50.282]                         fi[["size"]], fi[["mtime"]])
[16:17:50.282]                       stop(msg)
[16:17:50.282]                     }
[16:17:50.282]                     invisible(pathname)
[16:17:50.282]                   }
[16:17:50.282]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:50.282]                     rootPath = tempdir()) 
[16:17:50.282]                   {
[16:17:50.282]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:50.282]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:50.282]                       tmpdir = path, fileext = ".rds")
[16:17:50.282]                     save_rds(obj, file)
[16:17:50.282]                   }
[16:17:50.282]                   saveImmediateCondition(cond, path = "/tmp/Rtmpstkvtd/.future/immediateConditions")
[16:17:50.282]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.282]                   {
[16:17:50.282]                     inherits <- base::inherits
[16:17:50.282]                     invokeRestart <- base::invokeRestart
[16:17:50.282]                     is.null <- base::is.null
[16:17:50.282]                     muffled <- FALSE
[16:17:50.282]                     if (inherits(cond, "message")) {
[16:17:50.282]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:50.282]                       if (muffled) 
[16:17:50.282]                         invokeRestart("muffleMessage")
[16:17:50.282]                     }
[16:17:50.282]                     else if (inherits(cond, "warning")) {
[16:17:50.282]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:50.282]                       if (muffled) 
[16:17:50.282]                         invokeRestart("muffleWarning")
[16:17:50.282]                     }
[16:17:50.282]                     else if (inherits(cond, "condition")) {
[16:17:50.282]                       if (!is.null(pattern)) {
[16:17:50.282]                         computeRestarts <- base::computeRestarts
[16:17:50.282]                         grepl <- base::grepl
[16:17:50.282]                         restarts <- computeRestarts(cond)
[16:17:50.282]                         for (restart in restarts) {
[16:17:50.282]                           name <- restart$name
[16:17:50.282]                           if (is.null(name)) 
[16:17:50.282]                             next
[16:17:50.282]                           if (!grepl(pattern, name)) 
[16:17:50.282]                             next
[16:17:50.282]                           invokeRestart(restart)
[16:17:50.282]                           muffled <- TRUE
[16:17:50.282]                           break
[16:17:50.282]                         }
[16:17:50.282]                       }
[16:17:50.282]                     }
[16:17:50.282]                     invisible(muffled)
[16:17:50.282]                   }
[16:17:50.282]                   muffleCondition(cond)
[16:17:50.282]                 })
[16:17:50.282]             }))
[16:17:50.282]             future::FutureResult(value = ...future.value$value, 
[16:17:50.282]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:50.282]                   ...future.rng), globalenv = if (FALSE) 
[16:17:50.282]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:50.282]                     ...future.globalenv.names))
[16:17:50.282]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:50.282]         }, condition = base::local({
[16:17:50.282]             c <- base::c
[16:17:50.282]             inherits <- base::inherits
[16:17:50.282]             invokeRestart <- base::invokeRestart
[16:17:50.282]             length <- base::length
[16:17:50.282]             list <- base::list
[16:17:50.282]             seq.int <- base::seq.int
[16:17:50.282]             signalCondition <- base::signalCondition
[16:17:50.282]             sys.calls <- base::sys.calls
[16:17:50.282]             `[[` <- base::`[[`
[16:17:50.282]             `+` <- base::`+`
[16:17:50.282]             `<<-` <- base::`<<-`
[16:17:50.282]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:50.282]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:50.282]                   3L)]
[16:17:50.282]             }
[16:17:50.282]             function(cond) {
[16:17:50.282]                 is_error <- inherits(cond, "error")
[16:17:50.282]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:50.282]                   NULL)
[16:17:50.282]                 if (is_error) {
[16:17:50.282]                   sessionInformation <- function() {
[16:17:50.282]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:50.282]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:50.282]                       search = base::search(), system = base::Sys.info())
[16:17:50.282]                   }
[16:17:50.282]                   ...future.conditions[[length(...future.conditions) + 
[16:17:50.282]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:50.282]                     cond$call), session = sessionInformation(), 
[16:17:50.282]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:50.282]                   signalCondition(cond)
[16:17:50.282]                 }
[16:17:50.282]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:50.282]                 "immediateCondition"))) {
[16:17:50.282]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:50.282]                   ...future.conditions[[length(...future.conditions) + 
[16:17:50.282]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:50.282]                   if (TRUE && !signal) {
[16:17:50.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.282]                     {
[16:17:50.282]                       inherits <- base::inherits
[16:17:50.282]                       invokeRestart <- base::invokeRestart
[16:17:50.282]                       is.null <- base::is.null
[16:17:50.282]                       muffled <- FALSE
[16:17:50.282]                       if (inherits(cond, "message")) {
[16:17:50.282]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:50.282]                         if (muffled) 
[16:17:50.282]                           invokeRestart("muffleMessage")
[16:17:50.282]                       }
[16:17:50.282]                       else if (inherits(cond, "warning")) {
[16:17:50.282]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:50.282]                         if (muffled) 
[16:17:50.282]                           invokeRestart("muffleWarning")
[16:17:50.282]                       }
[16:17:50.282]                       else if (inherits(cond, "condition")) {
[16:17:50.282]                         if (!is.null(pattern)) {
[16:17:50.282]                           computeRestarts <- base::computeRestarts
[16:17:50.282]                           grepl <- base::grepl
[16:17:50.282]                           restarts <- computeRestarts(cond)
[16:17:50.282]                           for (restart in restarts) {
[16:17:50.282]                             name <- restart$name
[16:17:50.282]                             if (is.null(name)) 
[16:17:50.282]                               next
[16:17:50.282]                             if (!grepl(pattern, name)) 
[16:17:50.282]                               next
[16:17:50.282]                             invokeRestart(restart)
[16:17:50.282]                             muffled <- TRUE
[16:17:50.282]                             break
[16:17:50.282]                           }
[16:17:50.282]                         }
[16:17:50.282]                       }
[16:17:50.282]                       invisible(muffled)
[16:17:50.282]                     }
[16:17:50.282]                     muffleCondition(cond, pattern = "^muffle")
[16:17:50.282]                   }
[16:17:50.282]                 }
[16:17:50.282]                 else {
[16:17:50.282]                   if (TRUE) {
[16:17:50.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.282]                     {
[16:17:50.282]                       inherits <- base::inherits
[16:17:50.282]                       invokeRestart <- base::invokeRestart
[16:17:50.282]                       is.null <- base::is.null
[16:17:50.282]                       muffled <- FALSE
[16:17:50.282]                       if (inherits(cond, "message")) {
[16:17:50.282]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:50.282]                         if (muffled) 
[16:17:50.282]                           invokeRestart("muffleMessage")
[16:17:50.282]                       }
[16:17:50.282]                       else if (inherits(cond, "warning")) {
[16:17:50.282]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:50.282]                         if (muffled) 
[16:17:50.282]                           invokeRestart("muffleWarning")
[16:17:50.282]                       }
[16:17:50.282]                       else if (inherits(cond, "condition")) {
[16:17:50.282]                         if (!is.null(pattern)) {
[16:17:50.282]                           computeRestarts <- base::computeRestarts
[16:17:50.282]                           grepl <- base::grepl
[16:17:50.282]                           restarts <- computeRestarts(cond)
[16:17:50.282]                           for (restart in restarts) {
[16:17:50.282]                             name <- restart$name
[16:17:50.282]                             if (is.null(name)) 
[16:17:50.282]                               next
[16:17:50.282]                             if (!grepl(pattern, name)) 
[16:17:50.282]                               next
[16:17:50.282]                             invokeRestart(restart)
[16:17:50.282]                             muffled <- TRUE
[16:17:50.282]                             break
[16:17:50.282]                           }
[16:17:50.282]                         }
[16:17:50.282]                       }
[16:17:50.282]                       invisible(muffled)
[16:17:50.282]                     }
[16:17:50.282]                     muffleCondition(cond, pattern = "^muffle")
[16:17:50.282]                   }
[16:17:50.282]                 }
[16:17:50.282]             }
[16:17:50.282]         }))
[16:17:50.282]     }, error = function(ex) {
[16:17:50.282]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:50.282]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:50.282]                 ...future.rng), started = ...future.startTime, 
[16:17:50.282]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:50.282]             version = "1.8"), class = "FutureResult")
[16:17:50.282]     }, finally = {
[16:17:50.282]         if (!identical(...future.workdir, getwd())) 
[16:17:50.282]             setwd(...future.workdir)
[16:17:50.282]         {
[16:17:50.282]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:50.282]                 ...future.oldOptions$nwarnings <- NULL
[16:17:50.282]             }
[16:17:50.282]             base::options(...future.oldOptions)
[16:17:50.282]             if (.Platform$OS.type == "windows") {
[16:17:50.282]                 old_names <- names(...future.oldEnvVars)
[16:17:50.282]                 envs <- base::Sys.getenv()
[16:17:50.282]                 names <- names(envs)
[16:17:50.282]                 common <- intersect(names, old_names)
[16:17:50.282]                 added <- setdiff(names, old_names)
[16:17:50.282]                 removed <- setdiff(old_names, names)
[16:17:50.282]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:50.282]                   envs[common]]
[16:17:50.282]                 NAMES <- toupper(changed)
[16:17:50.282]                 args <- list()
[16:17:50.282]                 for (kk in seq_along(NAMES)) {
[16:17:50.282]                   name <- changed[[kk]]
[16:17:50.282]                   NAME <- NAMES[[kk]]
[16:17:50.282]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.282]                     next
[16:17:50.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:50.282]                 }
[16:17:50.282]                 NAMES <- toupper(added)
[16:17:50.282]                 for (kk in seq_along(NAMES)) {
[16:17:50.282]                   name <- added[[kk]]
[16:17:50.282]                   NAME <- NAMES[[kk]]
[16:17:50.282]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.282]                     next
[16:17:50.282]                   args[[name]] <- ""
[16:17:50.282]                 }
[16:17:50.282]                 NAMES <- toupper(removed)
[16:17:50.282]                 for (kk in seq_along(NAMES)) {
[16:17:50.282]                   name <- removed[[kk]]
[16:17:50.282]                   NAME <- NAMES[[kk]]
[16:17:50.282]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.282]                     next
[16:17:50.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:50.282]                 }
[16:17:50.282]                 if (length(args) > 0) 
[16:17:50.282]                   base::do.call(base::Sys.setenv, args = args)
[16:17:50.282]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:50.282]             }
[16:17:50.282]             else {
[16:17:50.282]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:50.282]             }
[16:17:50.282]             {
[16:17:50.282]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:50.282]                   0L) {
[16:17:50.282]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:50.282]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:50.282]                   base::options(opts)
[16:17:50.282]                 }
[16:17:50.282]                 {
[16:17:50.282]                   {
[16:17:50.282]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:50.282]                     NULL
[16:17:50.282]                   }
[16:17:50.282]                   options(future.plan = NULL)
[16:17:50.282]                   if (is.na(NA_character_)) 
[16:17:50.282]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:50.282]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:50.282]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:50.282]                     .init = FALSE)
[16:17:50.282]                 }
[16:17:50.282]             }
[16:17:50.282]         }
[16:17:50.282]     })
[16:17:50.282]     if (TRUE) {
[16:17:50.282]         base::sink(type = "output", split = FALSE)
[16:17:50.282]         if (TRUE) {
[16:17:50.282]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:50.282]         }
[16:17:50.282]         else {
[16:17:50.282]             ...future.result["stdout"] <- base::list(NULL)
[16:17:50.282]         }
[16:17:50.282]         base::close(...future.stdout)
[16:17:50.282]         ...future.stdout <- NULL
[16:17:50.282]     }
[16:17:50.282]     ...future.result$conditions <- ...future.conditions
[16:17:50.282]     ...future.result$finished <- base::Sys.time()
[16:17:50.282]     ...future.result
[16:17:50.282] }
[16:17:50.286] assign_globals() ...
[16:17:50.286] List of 5
[16:17:50.286]  $ ...future.FUN            :function (x, ...)  
[16:17:50.286]  $ future.call.arguments    :List of 1
[16:17:50.286]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:17:50.286]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:50.286]  $ ...future.elements_ii    :List of 2
[16:17:50.286]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:17:50.286]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:17:50.286]  $ ...future.seeds_ii       : NULL
[16:17:50.286]  $ ...future.globals.maxSize: NULL
[16:17:50.286]  - attr(*, "where")=List of 5
[16:17:50.286]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:50.286]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:50.286]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:50.286]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:50.286]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:50.286]  - attr(*, "resolved")= logi FALSE
[16:17:50.286]  - attr(*, "total_size")= num 1328
[16:17:50.286]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:50.286]  - attr(*, "already-done")= logi TRUE
[16:17:50.297] - copied ‘...future.FUN’ to environment
[16:17:50.297] - copied ‘future.call.arguments’ to environment
[16:17:50.297] - copied ‘...future.elements_ii’ to environment
[16:17:50.298] - copied ‘...future.seeds_ii’ to environment
[16:17:50.298] - copied ‘...future.globals.maxSize’ to environment
[16:17:50.298] assign_globals() ... done
[16:17:50.298] requestCore(): workers = 2
[16:17:50.300] MulticoreFuture started
[16:17:50.301] - Launch lazy future ... done
[16:17:50.301] run() for ‘MulticoreFuture’ ... done
[16:17:50.301] Created future:
[16:17:50.302] plan(): Setting new future strategy stack:
[16:17:50.302] List of future strategies:
[16:17:50.302] 1. sequential:
[16:17:50.302]    - args: function (..., envir = parent.frame())
[16:17:50.302]    - tweaked: FALSE
[16:17:50.302]    - call: NULL
[16:17:50.303] plan(): nbrOfWorkers() = 1
[16:17:50.306] plan(): Setting new future strategy stack:
[16:17:50.306] List of future strategies:
[16:17:50.306] 1. multicore:
[16:17:50.306]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:50.306]    - tweaked: FALSE
[16:17:50.306]    - call: plan(strategy)
[16:17:50.311] plan(): nbrOfWorkers() = 2
[16:17:50.302] MulticoreFuture:
[16:17:50.302] Label: ‘future_eapply-2’
[16:17:50.302] Expression:
[16:17:50.302] {
[16:17:50.302]     do.call(function(...) {
[16:17:50.302]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.302]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:50.302]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.302]             on.exit(options(oopts), add = TRUE)
[16:17:50.302]         }
[16:17:50.302]         {
[16:17:50.302]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:50.302]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.302]                 ...future.FUN(...future.X_jj, ...)
[16:17:50.302]             })
[16:17:50.302]         }
[16:17:50.302]     }, args = future.call.arguments)
[16:17:50.302] }
[16:17:50.302] Lazy evaluation: FALSE
[16:17:50.302] Asynchronous evaluation: TRUE
[16:17:50.302] Local evaluation: TRUE
[16:17:50.302] Environment: R_GlobalEnv
[16:17:50.302] Capture standard output: TRUE
[16:17:50.302] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:50.302] Globals: 5 objects totaling 1.50 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:50.302] Packages: 1 packages (‘stats’)
[16:17:50.302] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:50.302] Resolved: TRUE
[16:17:50.302] Value: <not collected>
[16:17:50.302] Conditions captured: <none>
[16:17:50.302] Early signaling: FALSE
[16:17:50.302] Owner process: 95d59565-e757-824f-7f5c-7f754384cffc
[16:17:50.302] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:50.313] Chunk #2 of 2 ... DONE
[16:17:50.313] Launching 2 futures (chunks) ... DONE
[16:17:50.313] Resolving 2 futures (chunks) ...
[16:17:50.313] resolve() on list ...
[16:17:50.313]  recursive: 0
[16:17:50.314]  length: 2
[16:17:50.314] 
[16:17:50.314] Future #1
[16:17:50.314] result() for MulticoreFuture ...
[16:17:50.315] result() for MulticoreFuture ...
[16:17:50.315] result() for MulticoreFuture ... done
[16:17:50.315] result() for MulticoreFuture ... done
[16:17:50.316] result() for MulticoreFuture ...
[16:17:50.316] result() for MulticoreFuture ... done
[16:17:50.316] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:17:50.316] - nx: 2
[16:17:50.316] - relay: TRUE
[16:17:50.316] - stdout: TRUE
[16:17:50.317] - signal: TRUE
[16:17:50.317] - resignal: FALSE
[16:17:50.317] - force: TRUE
[16:17:50.317] - relayed: [n=2] FALSE, FALSE
[16:17:50.317] - queued futures: [n=2] FALSE, FALSE
[16:17:50.318]  - until=1
[16:17:50.318]  - relaying element #1
[16:17:50.318] result() for MulticoreFuture ...
[16:17:50.318] result() for MulticoreFuture ... done
[16:17:50.318] result() for MulticoreFuture ...
[16:17:50.318] result() for MulticoreFuture ... done
[16:17:50.319] result() for MulticoreFuture ...
[16:17:50.319] result() for MulticoreFuture ... done
[16:17:50.319] result() for MulticoreFuture ...
[16:17:50.319] result() for MulticoreFuture ... done
[16:17:50.319] - relayed: [n=2] TRUE, FALSE
[16:17:50.319] - queued futures: [n=2] TRUE, FALSE
[16:17:50.320] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:17:50.320]  length: 1 (resolved future 1)
[16:17:50.320] Future #2
[16:17:50.320] result() for MulticoreFuture ...
[16:17:50.321] result() for MulticoreFuture ...
[16:17:50.321] result() for MulticoreFuture ... done
[16:17:50.321] result() for MulticoreFuture ... done
[16:17:50.321] result() for MulticoreFuture ...
[16:17:50.322] result() for MulticoreFuture ... done
[16:17:50.322] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:17:50.322] - nx: 2
[16:17:50.322] - relay: TRUE
[16:17:50.322] - stdout: TRUE
[16:17:50.322] - signal: TRUE
[16:17:50.322] - resignal: FALSE
[16:17:50.322] - force: TRUE
[16:17:50.323] - relayed: [n=2] TRUE, FALSE
[16:17:50.323] - queued futures: [n=2] TRUE, FALSE
[16:17:50.323]  - until=2
[16:17:50.323]  - relaying element #2
[16:17:50.323] result() for MulticoreFuture ...
[16:17:50.323] result() for MulticoreFuture ... done
[16:17:50.323] result() for MulticoreFuture ...
[16:17:50.323] result() for MulticoreFuture ... done
[16:17:50.324] result() for MulticoreFuture ...
[16:17:50.324] result() for MulticoreFuture ... done
[16:17:50.324] result() for MulticoreFuture ...
[16:17:50.324] result() for MulticoreFuture ... done
[16:17:50.324] - relayed: [n=2] TRUE, TRUE
[16:17:50.324] - queued futures: [n=2] TRUE, TRUE
[16:17:50.324] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:17:50.324]  length: 0 (resolved future 2)
[16:17:50.325] Relaying remaining futures
[16:17:50.325] signalConditionsASAP(NULL, pos=0) ...
[16:17:50.325] - nx: 2
[16:17:50.325] - relay: TRUE
[16:17:50.325] - stdout: TRUE
[16:17:50.325] - signal: TRUE
[16:17:50.325] - resignal: FALSE
[16:17:50.325] - force: TRUE
[16:17:50.325] - relayed: [n=2] TRUE, TRUE
[16:17:50.326] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:50.326] - relayed: [n=2] TRUE, TRUE
[16:17:50.326] - queued futures: [n=2] TRUE, TRUE
[16:17:50.326] signalConditionsASAP(NULL, pos=0) ... done
[16:17:50.326] resolve() on list ... DONE
[16:17:50.326] result() for MulticoreFuture ...
[16:17:50.326] result() for MulticoreFuture ... done
[16:17:50.326] result() for MulticoreFuture ...
[16:17:50.327] result() for MulticoreFuture ... done
[16:17:50.327] result() for MulticoreFuture ...
[16:17:50.327] result() for MulticoreFuture ... done
[16:17:50.327] result() for MulticoreFuture ...
[16:17:50.327] result() for MulticoreFuture ... done
[16:17:50.327]  - Number of value chunks collected: 2
[16:17:50.327] Resolving 2 futures (chunks) ... DONE
[16:17:50.327] Reducing values from 2 chunks ...
[16:17:50.327]  - Number of values collected after concatenation: 3
[16:17:50.328]  - Number of values expected: 3
[16:17:50.328] Reducing values from 2 chunks ... DONE
[16:17:50.328] future_lapply() ... DONE
[16:17:50.329] future_lapply() ...
[16:17:50.333] Number of chunks: 2
[16:17:50.333] getGlobalsAndPackagesXApply() ...
[16:17:50.334]  - future.globals: TRUE
[16:17:50.334] getGlobalsAndPackages() ...
[16:17:50.334] Searching for globals...
[16:17:50.335] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:50.335] Searching for globals ... DONE
[16:17:50.335] Resolving globals: FALSE
[16:17:50.336] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:17:50.336] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:17:50.336] - globals: [1] ‘FUN’
[16:17:50.337] - packages: [1] ‘stats’
[16:17:50.337] getGlobalsAndPackages() ... DONE
[16:17:50.337]  - globals found/used: [n=1] ‘FUN’
[16:17:50.337]  - needed namespaces: [n=1] ‘stats’
[16:17:50.337] Finding globals ... DONE
[16:17:50.337]  - use_args: TRUE
[16:17:50.337]  - Getting '...' globals ...
[16:17:50.338] resolve() on list ...
[16:17:50.338]  recursive: 0
[16:17:50.338]  length: 1
[16:17:50.338]  elements: ‘...’
[16:17:50.338]  length: 0 (resolved future 1)
[16:17:50.338] resolve() on list ... DONE
[16:17:50.340]    - '...' content: [n=0] 
[16:17:50.340] List of 1
[16:17:50.340]  $ ...: list()
[16:17:50.340]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:50.340]  - attr(*, "where")=List of 1
[16:17:50.340]   ..$ ...:<environment: 0x556da4e85778> 
[16:17:50.340]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:50.340]  - attr(*, "resolved")= logi TRUE
[16:17:50.340]  - attr(*, "total_size")= num NA
[16:17:50.344]  - Getting '...' globals ... DONE
[16:17:50.344] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:50.344] List of 2
[16:17:50.344]  $ ...future.FUN:function (x, ...)  
[16:17:50.344]  $ ...          : list()
[16:17:50.344]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:50.344]  - attr(*, "where")=List of 2
[16:17:50.344]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:50.344]   ..$ ...          :<environment: 0x556da4e85778> 
[16:17:50.344]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:50.344]  - attr(*, "resolved")= logi FALSE
[16:17:50.344]  - attr(*, "total_size")= num 1248
[16:17:50.347] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:50.347] getGlobalsAndPackagesXApply() ... DONE
[16:17:50.347] Number of futures (= number of chunks): 2
[16:17:50.347] Launching 2 futures (chunks) ...
[16:17:50.347] Chunk #1 of 2 ...
[16:17:50.347]  - Finding globals in 'X' for chunk #1 ...
[16:17:50.348] getGlobalsAndPackages() ...
[16:17:50.348] Searching for globals...
[16:17:50.348] 
[16:17:50.348] Searching for globals ... DONE
[16:17:50.348] - globals: [0] <none>
[16:17:50.348] getGlobalsAndPackages() ... DONE
[16:17:50.348]    + additional globals found: [n=0] 
[16:17:50.348]    + additional namespaces needed: [n=0] 
[16:17:50.348]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:50.349]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:50.349]  - seeds: <none>
[16:17:50.349]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.349] getGlobalsAndPackages() ...
[16:17:50.349] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.349] Resolving globals: FALSE
[16:17:50.349] Tweak future expression to call with '...' arguments ...
[16:17:50.349] {
[16:17:50.349]     do.call(function(...) {
[16:17:50.349]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.349]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:50.349]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.349]             on.exit(options(oopts), add = TRUE)
[16:17:50.349]         }
[16:17:50.349]         {
[16:17:50.349]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:50.349]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.349]                 ...future.FUN(...future.X_jj, ...)
[16:17:50.349]             })
[16:17:50.349]         }
[16:17:50.349]     }, args = future.call.arguments)
[16:17:50.349] }
[16:17:50.350] Tweak future expression to call with '...' arguments ... DONE
[16:17:50.350] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.350] - packages: [1] ‘stats’
[16:17:50.350] getGlobalsAndPackages() ... DONE
[16:17:50.350] run() for ‘Future’ ...
[16:17:50.351] - state: ‘created’
[16:17:50.351] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:50.354] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:50.354] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:50.354]   - Field: ‘label’
[16:17:50.355]   - Field: ‘local’
[16:17:50.355]   - Field: ‘owner’
[16:17:50.355]   - Field: ‘envir’
[16:17:50.355]   - Field: ‘workers’
[16:17:50.355]   - Field: ‘packages’
[16:17:50.355]   - Field: ‘gc’
[16:17:50.355]   - Field: ‘job’
[16:17:50.355]   - Field: ‘conditions’
[16:17:50.355]   - Field: ‘expr’
[16:17:50.355]   - Field: ‘uuid’
[16:17:50.355]   - Field: ‘seed’
[16:17:50.356]   - Field: ‘version’
[16:17:50.356]   - Field: ‘result’
[16:17:50.356]   - Field: ‘asynchronous’
[16:17:50.356]   - Field: ‘calls’
[16:17:50.356]   - Field: ‘globals’
[16:17:50.356]   - Field: ‘stdout’
[16:17:50.356]   - Field: ‘earlySignal’
[16:17:50.356]   - Field: ‘lazy’
[16:17:50.356]   - Field: ‘state’
[16:17:50.356] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:50.357] - Launch lazy future ...
[16:17:50.357] Packages needed by the future expression (n = 1): ‘stats’
[16:17:50.357] Packages needed by future strategies (n = 0): <none>
[16:17:50.357] {
[16:17:50.357]     {
[16:17:50.357]         {
[16:17:50.357]             ...future.startTime <- base::Sys.time()
[16:17:50.357]             {
[16:17:50.357]                 {
[16:17:50.357]                   {
[16:17:50.357]                     {
[16:17:50.357]                       {
[16:17:50.357]                         base::local({
[16:17:50.357]                           has_future <- base::requireNamespace("future", 
[16:17:50.357]                             quietly = TRUE)
[16:17:50.357]                           if (has_future) {
[16:17:50.357]                             ns <- base::getNamespace("future")
[16:17:50.357]                             version <- ns[[".package"]][["version"]]
[16:17:50.357]                             if (is.null(version)) 
[16:17:50.357]                               version <- utils::packageVersion("future")
[16:17:50.357]                           }
[16:17:50.357]                           else {
[16:17:50.357]                             version <- NULL
[16:17:50.357]                           }
[16:17:50.357]                           if (!has_future || version < "1.8.0") {
[16:17:50.357]                             info <- base::c(r_version = base::gsub("R version ", 
[16:17:50.357]                               "", base::R.version$version.string), 
[16:17:50.357]                               platform = base::sprintf("%s (%s-bit)", 
[16:17:50.357]                                 base::R.version$platform, 8 * 
[16:17:50.357]                                   base::.Machine$sizeof.pointer), 
[16:17:50.357]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:50.357]                                 "release", "version")], collapse = " "), 
[16:17:50.357]                               hostname = base::Sys.info()[["nodename"]])
[16:17:50.357]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:17:50.357]                               info)
[16:17:50.357]                             info <- base::paste(info, collapse = "; ")
[16:17:50.357]                             if (!has_future) {
[16:17:50.357]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:50.357]                                 info)
[16:17:50.357]                             }
[16:17:50.357]                             else {
[16:17:50.357]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:50.357]                                 info, version)
[16:17:50.357]                             }
[16:17:50.357]                             base::stop(msg)
[16:17:50.357]                           }
[16:17:50.357]                         })
[16:17:50.357]                       }
[16:17:50.357]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:50.357]                       base::options(mc.cores = 1L)
[16:17:50.357]                     }
[16:17:50.357]                     base::local({
[16:17:50.357]                       for (pkg in "stats") {
[16:17:50.357]                         base::loadNamespace(pkg)
[16:17:50.357]                         base::library(pkg, character.only = TRUE)
[16:17:50.357]                       }
[16:17:50.357]                     })
[16:17:50.357]                   }
[16:17:50.357]                   ...future.strategy.old <- future::plan("list")
[16:17:50.357]                   options(future.plan = NULL)
[16:17:50.357]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:50.357]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:50.357]                 }
[16:17:50.357]                 ...future.workdir <- getwd()
[16:17:50.357]             }
[16:17:50.357]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:50.357]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:50.357]         }
[16:17:50.357]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:50.357]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:50.357]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:50.357]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:50.357]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:50.357]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:50.357]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:50.357]             base::names(...future.oldOptions))
[16:17:50.357]     }
[16:17:50.357]     if (FALSE) {
[16:17:50.357]     }
[16:17:50.357]     else {
[16:17:50.357]         if (TRUE) {
[16:17:50.357]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:50.357]                 open = "w")
[16:17:50.357]         }
[16:17:50.357]         else {
[16:17:50.357]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:50.357]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:50.357]         }
[16:17:50.357]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:50.357]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:50.357]             base::sink(type = "output", split = FALSE)
[16:17:50.357]             base::close(...future.stdout)
[16:17:50.357]         }, add = TRUE)
[16:17:50.357]     }
[16:17:50.357]     ...future.frame <- base::sys.nframe()
[16:17:50.357]     ...future.conditions <- base::list()
[16:17:50.357]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:50.357]     if (FALSE) {
[16:17:50.357]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:50.357]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:50.357]     }
[16:17:50.357]     ...future.result <- base::tryCatch({
[16:17:50.357]         base::withCallingHandlers({
[16:17:50.357]             ...future.value <- base::withVisible(base::local({
[16:17:50.357]                 withCallingHandlers({
[16:17:50.357]                   {
[16:17:50.357]                     do.call(function(...) {
[16:17:50.357]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.357]                       if (!identical(...future.globals.maxSize.org, 
[16:17:50.357]                         ...future.globals.maxSize)) {
[16:17:50.357]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.357]                         on.exit(options(oopts), add = TRUE)
[16:17:50.357]                       }
[16:17:50.357]                       {
[16:17:50.357]                         lapply(seq_along(...future.elements_ii), 
[16:17:50.357]                           FUN = function(jj) {
[16:17:50.357]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.357]                             ...future.FUN(...future.X_jj, ...)
[16:17:50.357]                           })
[16:17:50.357]                       }
[16:17:50.357]                     }, args = future.call.arguments)
[16:17:50.357]                   }
[16:17:50.357]                 }, immediateCondition = function(cond) {
[16:17:50.357]                   save_rds <- function (object, pathname, ...) 
[16:17:50.357]                   {
[16:17:50.357]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:50.357]                     if (file_test("-f", pathname_tmp)) {
[16:17:50.357]                       fi_tmp <- file.info(pathname_tmp)
[16:17:50.357]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:50.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:50.357]                         fi_tmp[["mtime"]])
[16:17:50.357]                     }
[16:17:50.357]                     tryCatch({
[16:17:50.357]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:50.357]                     }, error = function(ex) {
[16:17:50.357]                       msg <- conditionMessage(ex)
[16:17:50.357]                       fi_tmp <- file.info(pathname_tmp)
[16:17:50.357]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:50.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:50.357]                         fi_tmp[["mtime"]], msg)
[16:17:50.357]                       ex$message <- msg
[16:17:50.357]                       stop(ex)
[16:17:50.357]                     })
[16:17:50.357]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:50.357]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:50.357]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:50.357]                       fi_tmp <- file.info(pathname_tmp)
[16:17:50.357]                       fi <- file.info(pathname)
[16:17:50.357]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:50.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:50.357]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:50.357]                         fi[["size"]], fi[["mtime"]])
[16:17:50.357]                       stop(msg)
[16:17:50.357]                     }
[16:17:50.357]                     invisible(pathname)
[16:17:50.357]                   }
[16:17:50.357]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:50.357]                     rootPath = tempdir()) 
[16:17:50.357]                   {
[16:17:50.357]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:50.357]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:50.357]                       tmpdir = path, fileext = ".rds")
[16:17:50.357]                     save_rds(obj, file)
[16:17:50.357]                   }
[16:17:50.357]                   saveImmediateCondition(cond, path = "/tmp/Rtmpstkvtd/.future/immediateConditions")
[16:17:50.357]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.357]                   {
[16:17:50.357]                     inherits <- base::inherits
[16:17:50.357]                     invokeRestart <- base::invokeRestart
[16:17:50.357]                     is.null <- base::is.null
[16:17:50.357]                     muffled <- FALSE
[16:17:50.357]                     if (inherits(cond, "message")) {
[16:17:50.357]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:50.357]                       if (muffled) 
[16:17:50.357]                         invokeRestart("muffleMessage")
[16:17:50.357]                     }
[16:17:50.357]                     else if (inherits(cond, "warning")) {
[16:17:50.357]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:50.357]                       if (muffled) 
[16:17:50.357]                         invokeRestart("muffleWarning")
[16:17:50.357]                     }
[16:17:50.357]                     else if (inherits(cond, "condition")) {
[16:17:50.357]                       if (!is.null(pattern)) {
[16:17:50.357]                         computeRestarts <- base::computeRestarts
[16:17:50.357]                         grepl <- base::grepl
[16:17:50.357]                         restarts <- computeRestarts(cond)
[16:17:50.357]                         for (restart in restarts) {
[16:17:50.357]                           name <- restart$name
[16:17:50.357]                           if (is.null(name)) 
[16:17:50.357]                             next
[16:17:50.357]                           if (!grepl(pattern, name)) 
[16:17:50.357]                             next
[16:17:50.357]                           invokeRestart(restart)
[16:17:50.357]                           muffled <- TRUE
[16:17:50.357]                           break
[16:17:50.357]                         }
[16:17:50.357]                       }
[16:17:50.357]                     }
[16:17:50.357]                     invisible(muffled)
[16:17:50.357]                   }
[16:17:50.357]                   muffleCondition(cond)
[16:17:50.357]                 })
[16:17:50.357]             }))
[16:17:50.357]             future::FutureResult(value = ...future.value$value, 
[16:17:50.357]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:50.357]                   ...future.rng), globalenv = if (FALSE) 
[16:17:50.357]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:50.357]                     ...future.globalenv.names))
[16:17:50.357]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:50.357]         }, condition = base::local({
[16:17:50.357]             c <- base::c
[16:17:50.357]             inherits <- base::inherits
[16:17:50.357]             invokeRestart <- base::invokeRestart
[16:17:50.357]             length <- base::length
[16:17:50.357]             list <- base::list
[16:17:50.357]             seq.int <- base::seq.int
[16:17:50.357]             signalCondition <- base::signalCondition
[16:17:50.357]             sys.calls <- base::sys.calls
[16:17:50.357]             `[[` <- base::`[[`
[16:17:50.357]             `+` <- base::`+`
[16:17:50.357]             `<<-` <- base::`<<-`
[16:17:50.357]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:50.357]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:50.357]                   3L)]
[16:17:50.357]             }
[16:17:50.357]             function(cond) {
[16:17:50.357]                 is_error <- inherits(cond, "error")
[16:17:50.357]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:50.357]                   NULL)
[16:17:50.357]                 if (is_error) {
[16:17:50.357]                   sessionInformation <- function() {
[16:17:50.357]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:50.357]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:50.357]                       search = base::search(), system = base::Sys.info())
[16:17:50.357]                   }
[16:17:50.357]                   ...future.conditions[[length(...future.conditions) + 
[16:17:50.357]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:50.357]                     cond$call), session = sessionInformation(), 
[16:17:50.357]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:50.357]                   signalCondition(cond)
[16:17:50.357]                 }
[16:17:50.357]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:50.357]                 "immediateCondition"))) {
[16:17:50.357]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:50.357]                   ...future.conditions[[length(...future.conditions) + 
[16:17:50.357]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:50.357]                   if (TRUE && !signal) {
[16:17:50.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.357]                     {
[16:17:50.357]                       inherits <- base::inherits
[16:17:50.357]                       invokeRestart <- base::invokeRestart
[16:17:50.357]                       is.null <- base::is.null
[16:17:50.357]                       muffled <- FALSE
[16:17:50.357]                       if (inherits(cond, "message")) {
[16:17:50.357]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:50.357]                         if (muffled) 
[16:17:50.357]                           invokeRestart("muffleMessage")
[16:17:50.357]                       }
[16:17:50.357]                       else if (inherits(cond, "warning")) {
[16:17:50.357]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:50.357]                         if (muffled) 
[16:17:50.357]                           invokeRestart("muffleWarning")
[16:17:50.357]                       }
[16:17:50.357]                       else if (inherits(cond, "condition")) {
[16:17:50.357]                         if (!is.null(pattern)) {
[16:17:50.357]                           computeRestarts <- base::computeRestarts
[16:17:50.357]                           grepl <- base::grepl
[16:17:50.357]                           restarts <- computeRestarts(cond)
[16:17:50.357]                           for (restart in restarts) {
[16:17:50.357]                             name <- restart$name
[16:17:50.357]                             if (is.null(name)) 
[16:17:50.357]                               next
[16:17:50.357]                             if (!grepl(pattern, name)) 
[16:17:50.357]                               next
[16:17:50.357]                             invokeRestart(restart)
[16:17:50.357]                             muffled <- TRUE
[16:17:50.357]                             break
[16:17:50.357]                           }
[16:17:50.357]                         }
[16:17:50.357]                       }
[16:17:50.357]                       invisible(muffled)
[16:17:50.357]                     }
[16:17:50.357]                     muffleCondition(cond, pattern = "^muffle")
[16:17:50.357]                   }
[16:17:50.357]                 }
[16:17:50.357]                 else {
[16:17:50.357]                   if (TRUE) {
[16:17:50.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.357]                     {
[16:17:50.357]                       inherits <- base::inherits
[16:17:50.357]                       invokeRestart <- base::invokeRestart
[16:17:50.357]                       is.null <- base::is.null
[16:17:50.357]                       muffled <- FALSE
[16:17:50.357]                       if (inherits(cond, "message")) {
[16:17:50.357]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:50.357]                         if (muffled) 
[16:17:50.357]                           invokeRestart("muffleMessage")
[16:17:50.357]                       }
[16:17:50.357]                       else if (inherits(cond, "warning")) {
[16:17:50.357]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:50.357]                         if (muffled) 
[16:17:50.357]                           invokeRestart("muffleWarning")
[16:17:50.357]                       }
[16:17:50.357]                       else if (inherits(cond, "condition")) {
[16:17:50.357]                         if (!is.null(pattern)) {
[16:17:50.357]                           computeRestarts <- base::computeRestarts
[16:17:50.357]                           grepl <- base::grepl
[16:17:50.357]                           restarts <- computeRestarts(cond)
[16:17:50.357]                           for (restart in restarts) {
[16:17:50.357]                             name <- restart$name
[16:17:50.357]                             if (is.null(name)) 
[16:17:50.357]                               next
[16:17:50.357]                             if (!grepl(pattern, name)) 
[16:17:50.357]                               next
[16:17:50.357]                             invokeRestart(restart)
[16:17:50.357]                             muffled <- TRUE
[16:17:50.357]                             break
[16:17:50.357]                           }
[16:17:50.357]                         }
[16:17:50.357]                       }
[16:17:50.357]                       invisible(muffled)
[16:17:50.357]                     }
[16:17:50.357]                     muffleCondition(cond, pattern = "^muffle")
[16:17:50.357]                   }
[16:17:50.357]                 }
[16:17:50.357]             }
[16:17:50.357]         }))
[16:17:50.357]     }, error = function(ex) {
[16:17:50.357]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:50.357]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:50.357]                 ...future.rng), started = ...future.startTime, 
[16:17:50.357]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:50.357]             version = "1.8"), class = "FutureResult")
[16:17:50.357]     }, finally = {
[16:17:50.357]         if (!identical(...future.workdir, getwd())) 
[16:17:50.357]             setwd(...future.workdir)
[16:17:50.357]         {
[16:17:50.357]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:50.357]                 ...future.oldOptions$nwarnings <- NULL
[16:17:50.357]             }
[16:17:50.357]             base::options(...future.oldOptions)
[16:17:50.357]             if (.Platform$OS.type == "windows") {
[16:17:50.357]                 old_names <- names(...future.oldEnvVars)
[16:17:50.357]                 envs <- base::Sys.getenv()
[16:17:50.357]                 names <- names(envs)
[16:17:50.357]                 common <- intersect(names, old_names)
[16:17:50.357]                 added <- setdiff(names, old_names)
[16:17:50.357]                 removed <- setdiff(old_names, names)
[16:17:50.357]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:50.357]                   envs[common]]
[16:17:50.357]                 NAMES <- toupper(changed)
[16:17:50.357]                 args <- list()
[16:17:50.357]                 for (kk in seq_along(NAMES)) {
[16:17:50.357]                   name <- changed[[kk]]
[16:17:50.357]                   NAME <- NAMES[[kk]]
[16:17:50.357]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.357]                     next
[16:17:50.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:50.357]                 }
[16:17:50.357]                 NAMES <- toupper(added)
[16:17:50.357]                 for (kk in seq_along(NAMES)) {
[16:17:50.357]                   name <- added[[kk]]
[16:17:50.357]                   NAME <- NAMES[[kk]]
[16:17:50.357]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.357]                     next
[16:17:50.357]                   args[[name]] <- ""
[16:17:50.357]                 }
[16:17:50.357]                 NAMES <- toupper(removed)
[16:17:50.357]                 for (kk in seq_along(NAMES)) {
[16:17:50.357]                   name <- removed[[kk]]
[16:17:50.357]                   NAME <- NAMES[[kk]]
[16:17:50.357]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.357]                     next
[16:17:50.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:50.357]                 }
[16:17:50.357]                 if (length(args) > 0) 
[16:17:50.357]                   base::do.call(base::Sys.setenv, args = args)
[16:17:50.357]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:50.357]             }
[16:17:50.357]             else {
[16:17:50.357]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:50.357]             }
[16:17:50.357]             {
[16:17:50.357]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:50.357]                   0L) {
[16:17:50.357]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:50.357]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:50.357]                   base::options(opts)
[16:17:50.357]                 }
[16:17:50.357]                 {
[16:17:50.357]                   {
[16:17:50.357]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:50.357]                     NULL
[16:17:50.357]                   }
[16:17:50.357]                   options(future.plan = NULL)
[16:17:50.357]                   if (is.na(NA_character_)) 
[16:17:50.357]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:50.357]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:50.357]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:50.357]                     .init = FALSE)
[16:17:50.357]                 }
[16:17:50.357]             }
[16:17:50.357]         }
[16:17:50.357]     })
[16:17:50.357]     if (TRUE) {
[16:17:50.357]         base::sink(type = "output", split = FALSE)
[16:17:50.357]         if (TRUE) {
[16:17:50.357]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:50.357]         }
[16:17:50.357]         else {
[16:17:50.357]             ...future.result["stdout"] <- base::list(NULL)
[16:17:50.357]         }
[16:17:50.357]         base::close(...future.stdout)
[16:17:50.357]         ...future.stdout <- NULL
[16:17:50.357]     }
[16:17:50.357]     ...future.result$conditions <- ...future.conditions
[16:17:50.357]     ...future.result$finished <- base::Sys.time()
[16:17:50.357]     ...future.result
[16:17:50.357] }
[16:17:50.360] assign_globals() ...
[16:17:50.360] List of 5
[16:17:50.360]  $ ...future.FUN            :function (x, ...)  
[16:17:50.360]  $ future.call.arguments    : list()
[16:17:50.360]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:50.360]  $ ...future.elements_ii    :List of 1
[16:17:50.360]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:17:50.360]  $ ...future.seeds_ii       : NULL
[16:17:50.360]  $ ...future.globals.maxSize: NULL
[16:17:50.360]  - attr(*, "where")=List of 5
[16:17:50.360]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:50.360]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:50.360]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:50.360]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:50.360]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:50.360]  - attr(*, "resolved")= logi FALSE
[16:17:50.360]  - attr(*, "total_size")= num 1248
[16:17:50.360]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:50.360]  - attr(*, "already-done")= logi TRUE
[16:17:50.365] - copied ‘...future.FUN’ to environment
[16:17:50.366] - copied ‘future.call.arguments’ to environment
[16:17:50.366] - copied ‘...future.elements_ii’ to environment
[16:17:50.367] - copied ‘...future.seeds_ii’ to environment
[16:17:50.367] - copied ‘...future.globals.maxSize’ to environment
[16:17:50.367] assign_globals() ... done
[16:17:50.367] requestCore(): workers = 2
[16:17:50.369] MulticoreFuture started
[16:17:50.369] - Launch lazy future ... done
[16:17:50.370] run() for ‘MulticoreFuture’ ... done
[16:17:50.370] Created future:
[16:17:50.370] plan(): Setting new future strategy stack:
[16:17:50.371] List of future strategies:
[16:17:50.371] 1. sequential:
[16:17:50.371]    - args: function (..., envir = parent.frame())
[16:17:50.371]    - tweaked: FALSE
[16:17:50.371]    - call: NULL
[16:17:50.372] plan(): nbrOfWorkers() = 1
[16:17:50.374] plan(): Setting new future strategy stack:
[16:17:50.374] List of future strategies:
[16:17:50.374] 1. multicore:
[16:17:50.374]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:50.374]    - tweaked: FALSE
[16:17:50.374]    - call: plan(strategy)
[16:17:50.380] plan(): nbrOfWorkers() = 2
[16:17:50.370] MulticoreFuture:
[16:17:50.370] Label: ‘future_eapply-1’
[16:17:50.370] Expression:
[16:17:50.370] {
[16:17:50.370]     do.call(function(...) {
[16:17:50.370]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.370]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:50.370]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.370]             on.exit(options(oopts), add = TRUE)
[16:17:50.370]         }
[16:17:50.370]         {
[16:17:50.370]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:50.370]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.370]                 ...future.FUN(...future.X_jj, ...)
[16:17:50.370]             })
[16:17:50.370]         }
[16:17:50.370]     }, args = future.call.arguments)
[16:17:50.370] }
[16:17:50.370] Lazy evaluation: FALSE
[16:17:50.370] Asynchronous evaluation: TRUE
[16:17:50.370] Local evaluation: TRUE
[16:17:50.370] Environment: R_GlobalEnv
[16:17:50.370] Capture standard output: TRUE
[16:17:50.370] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:50.370] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:50.370] Packages: 1 packages (‘stats’)
[16:17:50.370] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:50.370] Resolved: TRUE
[16:17:50.370] Value: <not collected>
[16:17:50.370] Conditions captured: <none>
[16:17:50.370] Early signaling: FALSE
[16:17:50.370] Owner process: 95d59565-e757-824f-7f5c-7f754384cffc
[16:17:50.370] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:50.381] Chunk #1 of 2 ... DONE
[16:17:50.381] Chunk #2 of 2 ...
[16:17:50.381]  - Finding globals in 'X' for chunk #2 ...
[16:17:50.381] getGlobalsAndPackages() ...
[16:17:50.382] Searching for globals...
[16:17:50.382] 
[16:17:50.382] Searching for globals ... DONE
[16:17:50.382] - globals: [0] <none>
[16:17:50.382] getGlobalsAndPackages() ... DONE
[16:17:50.383]    + additional globals found: [n=0] 
[16:17:50.383]    + additional namespaces needed: [n=0] 
[16:17:50.383]  - Finding globals in 'X' for chunk #2 ... DONE
[16:17:50.383]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:50.383]  - seeds: <none>
[16:17:50.383]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.384] getGlobalsAndPackages() ...
[16:17:50.384] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.384] Resolving globals: FALSE
[16:17:50.384] Tweak future expression to call with '...' arguments ...
[16:17:50.384] {
[16:17:50.384]     do.call(function(...) {
[16:17:50.384]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.384]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:50.384]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.384]             on.exit(options(oopts), add = TRUE)
[16:17:50.384]         }
[16:17:50.384]         {
[16:17:50.384]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:50.384]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.384]                 ...future.FUN(...future.X_jj, ...)
[16:17:50.384]             })
[16:17:50.384]         }
[16:17:50.384]     }, args = future.call.arguments)
[16:17:50.384] }
[16:17:50.385] Tweak future expression to call with '...' arguments ... DONE
[16:17:50.385] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.386] - packages: [1] ‘stats’
[16:17:50.386] getGlobalsAndPackages() ... DONE
[16:17:50.386] run() for ‘Future’ ...
[16:17:50.386] - state: ‘created’
[16:17:50.387] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:50.391] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:50.391] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:50.392]   - Field: ‘label’
[16:17:50.392]   - Field: ‘local’
[16:17:50.392]   - Field: ‘owner’
[16:17:50.392]   - Field: ‘envir’
[16:17:50.392]   - Field: ‘workers’
[16:17:50.392]   - Field: ‘packages’
[16:17:50.393]   - Field: ‘gc’
[16:17:50.393]   - Field: ‘job’
[16:17:50.393]   - Field: ‘conditions’
[16:17:50.393]   - Field: ‘expr’
[16:17:50.393]   - Field: ‘uuid’
[16:17:50.393]   - Field: ‘seed’
[16:17:50.393]   - Field: ‘version’
[16:17:50.394]   - Field: ‘result’
[16:17:50.394]   - Field: ‘asynchronous’
[16:17:50.394]   - Field: ‘calls’
[16:17:50.394]   - Field: ‘globals’
[16:17:50.394]   - Field: ‘stdout’
[16:17:50.394]   - Field: ‘earlySignal’
[16:17:50.394]   - Field: ‘lazy’
[16:17:50.395]   - Field: ‘state’
[16:17:50.395] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:50.395] - Launch lazy future ...
[16:17:50.395] Packages needed by the future expression (n = 1): ‘stats’
[16:17:50.396] Packages needed by future strategies (n = 0): <none>
[16:17:50.396] {
[16:17:50.396]     {
[16:17:50.396]         {
[16:17:50.396]             ...future.startTime <- base::Sys.time()
[16:17:50.396]             {
[16:17:50.396]                 {
[16:17:50.396]                   {
[16:17:50.396]                     {
[16:17:50.396]                       {
[16:17:50.396]                         base::local({
[16:17:50.396]                           has_future <- base::requireNamespace("future", 
[16:17:50.396]                             quietly = TRUE)
[16:17:50.396]                           if (has_future) {
[16:17:50.396]                             ns <- base::getNamespace("future")
[16:17:50.396]                             version <- ns[[".package"]][["version"]]
[16:17:50.396]                             if (is.null(version)) 
[16:17:50.396]                               version <- utils::packageVersion("future")
[16:17:50.396]                           }
[16:17:50.396]                           else {
[16:17:50.396]                             version <- NULL
[16:17:50.396]                           }
[16:17:50.396]                           if (!has_future || version < "1.8.0") {
[16:17:50.396]                             info <- base::c(r_version = base::gsub("R version ", 
[16:17:50.396]                               "", base::R.version$version.string), 
[16:17:50.396]                               platform = base::sprintf("%s (%s-bit)", 
[16:17:50.396]                                 base::R.version$platform, 8 * 
[16:17:50.396]                                   base::.Machine$sizeof.pointer), 
[16:17:50.396]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:50.396]                                 "release", "version")], collapse = " "), 
[16:17:50.396]                               hostname = base::Sys.info()[["nodename"]])
[16:17:50.396]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:17:50.396]                               info)
[16:17:50.396]                             info <- base::paste(info, collapse = "; ")
[16:17:50.396]                             if (!has_future) {
[16:17:50.396]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:50.396]                                 info)
[16:17:50.396]                             }
[16:17:50.396]                             else {
[16:17:50.396]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:50.396]                                 info, version)
[16:17:50.396]                             }
[16:17:50.396]                             base::stop(msg)
[16:17:50.396]                           }
[16:17:50.396]                         })
[16:17:50.396]                       }
[16:17:50.396]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:50.396]                       base::options(mc.cores = 1L)
[16:17:50.396]                     }
[16:17:50.396]                     base::local({
[16:17:50.396]                       for (pkg in "stats") {
[16:17:50.396]                         base::loadNamespace(pkg)
[16:17:50.396]                         base::library(pkg, character.only = TRUE)
[16:17:50.396]                       }
[16:17:50.396]                     })
[16:17:50.396]                   }
[16:17:50.396]                   ...future.strategy.old <- future::plan("list")
[16:17:50.396]                   options(future.plan = NULL)
[16:17:50.396]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:50.396]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:50.396]                 }
[16:17:50.396]                 ...future.workdir <- getwd()
[16:17:50.396]             }
[16:17:50.396]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:50.396]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:50.396]         }
[16:17:50.396]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:50.396]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:50.396]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:50.396]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:50.396]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:50.396]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:50.396]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:50.396]             base::names(...future.oldOptions))
[16:17:50.396]     }
[16:17:50.396]     if (FALSE) {
[16:17:50.396]     }
[16:17:50.396]     else {
[16:17:50.396]         if (TRUE) {
[16:17:50.396]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:50.396]                 open = "w")
[16:17:50.396]         }
[16:17:50.396]         else {
[16:17:50.396]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:50.396]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:50.396]         }
[16:17:50.396]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:50.396]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:50.396]             base::sink(type = "output", split = FALSE)
[16:17:50.396]             base::close(...future.stdout)
[16:17:50.396]         }, add = TRUE)
[16:17:50.396]     }
[16:17:50.396]     ...future.frame <- base::sys.nframe()
[16:17:50.396]     ...future.conditions <- base::list()
[16:17:50.396]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:50.396]     if (FALSE) {
[16:17:50.396]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:50.396]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:50.396]     }
[16:17:50.396]     ...future.result <- base::tryCatch({
[16:17:50.396]         base::withCallingHandlers({
[16:17:50.396]             ...future.value <- base::withVisible(base::local({
[16:17:50.396]                 withCallingHandlers({
[16:17:50.396]                   {
[16:17:50.396]                     do.call(function(...) {
[16:17:50.396]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.396]                       if (!identical(...future.globals.maxSize.org, 
[16:17:50.396]                         ...future.globals.maxSize)) {
[16:17:50.396]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.396]                         on.exit(options(oopts), add = TRUE)
[16:17:50.396]                       }
[16:17:50.396]                       {
[16:17:50.396]                         lapply(seq_along(...future.elements_ii), 
[16:17:50.396]                           FUN = function(jj) {
[16:17:50.396]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.396]                             ...future.FUN(...future.X_jj, ...)
[16:17:50.396]                           })
[16:17:50.396]                       }
[16:17:50.396]                     }, args = future.call.arguments)
[16:17:50.396]                   }
[16:17:50.396]                 }, immediateCondition = function(cond) {
[16:17:50.396]                   save_rds <- function (object, pathname, ...) 
[16:17:50.396]                   {
[16:17:50.396]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:50.396]                     if (file_test("-f", pathname_tmp)) {
[16:17:50.396]                       fi_tmp <- file.info(pathname_tmp)
[16:17:50.396]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:50.396]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:50.396]                         fi_tmp[["mtime"]])
[16:17:50.396]                     }
[16:17:50.396]                     tryCatch({
[16:17:50.396]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:50.396]                     }, error = function(ex) {
[16:17:50.396]                       msg <- conditionMessage(ex)
[16:17:50.396]                       fi_tmp <- file.info(pathname_tmp)
[16:17:50.396]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:50.396]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:50.396]                         fi_tmp[["mtime"]], msg)
[16:17:50.396]                       ex$message <- msg
[16:17:50.396]                       stop(ex)
[16:17:50.396]                     })
[16:17:50.396]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:50.396]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:50.396]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:50.396]                       fi_tmp <- file.info(pathname_tmp)
[16:17:50.396]                       fi <- file.info(pathname)
[16:17:50.396]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:50.396]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:50.396]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:50.396]                         fi[["size"]], fi[["mtime"]])
[16:17:50.396]                       stop(msg)
[16:17:50.396]                     }
[16:17:50.396]                     invisible(pathname)
[16:17:50.396]                   }
[16:17:50.396]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:50.396]                     rootPath = tempdir()) 
[16:17:50.396]                   {
[16:17:50.396]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:50.396]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:50.396]                       tmpdir = path, fileext = ".rds")
[16:17:50.396]                     save_rds(obj, file)
[16:17:50.396]                   }
[16:17:50.396]                   saveImmediateCondition(cond, path = "/tmp/Rtmpstkvtd/.future/immediateConditions")
[16:17:50.396]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.396]                   {
[16:17:50.396]                     inherits <- base::inherits
[16:17:50.396]                     invokeRestart <- base::invokeRestart
[16:17:50.396]                     is.null <- base::is.null
[16:17:50.396]                     muffled <- FALSE
[16:17:50.396]                     if (inherits(cond, "message")) {
[16:17:50.396]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:50.396]                       if (muffled) 
[16:17:50.396]                         invokeRestart("muffleMessage")
[16:17:50.396]                     }
[16:17:50.396]                     else if (inherits(cond, "warning")) {
[16:17:50.396]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:50.396]                       if (muffled) 
[16:17:50.396]                         invokeRestart("muffleWarning")
[16:17:50.396]                     }
[16:17:50.396]                     else if (inherits(cond, "condition")) {
[16:17:50.396]                       if (!is.null(pattern)) {
[16:17:50.396]                         computeRestarts <- base::computeRestarts
[16:17:50.396]                         grepl <- base::grepl
[16:17:50.396]                         restarts <- computeRestarts(cond)
[16:17:50.396]                         for (restart in restarts) {
[16:17:50.396]                           name <- restart$name
[16:17:50.396]                           if (is.null(name)) 
[16:17:50.396]                             next
[16:17:50.396]                           if (!grepl(pattern, name)) 
[16:17:50.396]                             next
[16:17:50.396]                           invokeRestart(restart)
[16:17:50.396]                           muffled <- TRUE
[16:17:50.396]                           break
[16:17:50.396]                         }
[16:17:50.396]                       }
[16:17:50.396]                     }
[16:17:50.396]                     invisible(muffled)
[16:17:50.396]                   }
[16:17:50.396]                   muffleCondition(cond)
[16:17:50.396]                 })
[16:17:50.396]             }))
[16:17:50.396]             future::FutureResult(value = ...future.value$value, 
[16:17:50.396]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:50.396]                   ...future.rng), globalenv = if (FALSE) 
[16:17:50.396]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:50.396]                     ...future.globalenv.names))
[16:17:50.396]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:50.396]         }, condition = base::local({
[16:17:50.396]             c <- base::c
[16:17:50.396]             inherits <- base::inherits
[16:17:50.396]             invokeRestart <- base::invokeRestart
[16:17:50.396]             length <- base::length
[16:17:50.396]             list <- base::list
[16:17:50.396]             seq.int <- base::seq.int
[16:17:50.396]             signalCondition <- base::signalCondition
[16:17:50.396]             sys.calls <- base::sys.calls
[16:17:50.396]             `[[` <- base::`[[`
[16:17:50.396]             `+` <- base::`+`
[16:17:50.396]             `<<-` <- base::`<<-`
[16:17:50.396]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:50.396]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:50.396]                   3L)]
[16:17:50.396]             }
[16:17:50.396]             function(cond) {
[16:17:50.396]                 is_error <- inherits(cond, "error")
[16:17:50.396]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:50.396]                   NULL)
[16:17:50.396]                 if (is_error) {
[16:17:50.396]                   sessionInformation <- function() {
[16:17:50.396]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:50.396]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:50.396]                       search = base::search(), system = base::Sys.info())
[16:17:50.396]                   }
[16:17:50.396]                   ...future.conditions[[length(...future.conditions) + 
[16:17:50.396]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:50.396]                     cond$call), session = sessionInformation(), 
[16:17:50.396]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:50.396]                   signalCondition(cond)
[16:17:50.396]                 }
[16:17:50.396]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:50.396]                 "immediateCondition"))) {
[16:17:50.396]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:50.396]                   ...future.conditions[[length(...future.conditions) + 
[16:17:50.396]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:50.396]                   if (TRUE && !signal) {
[16:17:50.396]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.396]                     {
[16:17:50.396]                       inherits <- base::inherits
[16:17:50.396]                       invokeRestart <- base::invokeRestart
[16:17:50.396]                       is.null <- base::is.null
[16:17:50.396]                       muffled <- FALSE
[16:17:50.396]                       if (inherits(cond, "message")) {
[16:17:50.396]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:50.396]                         if (muffled) 
[16:17:50.396]                           invokeRestart("muffleMessage")
[16:17:50.396]                       }
[16:17:50.396]                       else if (inherits(cond, "warning")) {
[16:17:50.396]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:50.396]                         if (muffled) 
[16:17:50.396]                           invokeRestart("muffleWarning")
[16:17:50.396]                       }
[16:17:50.396]                       else if (inherits(cond, "condition")) {
[16:17:50.396]                         if (!is.null(pattern)) {
[16:17:50.396]                           computeRestarts <- base::computeRestarts
[16:17:50.396]                           grepl <- base::grepl
[16:17:50.396]                           restarts <- computeRestarts(cond)
[16:17:50.396]                           for (restart in restarts) {
[16:17:50.396]                             name <- restart$name
[16:17:50.396]                             if (is.null(name)) 
[16:17:50.396]                               next
[16:17:50.396]                             if (!grepl(pattern, name)) 
[16:17:50.396]                               next
[16:17:50.396]                             invokeRestart(restart)
[16:17:50.396]                             muffled <- TRUE
[16:17:50.396]                             break
[16:17:50.396]                           }
[16:17:50.396]                         }
[16:17:50.396]                       }
[16:17:50.396]                       invisible(muffled)
[16:17:50.396]                     }
[16:17:50.396]                     muffleCondition(cond, pattern = "^muffle")
[16:17:50.396]                   }
[16:17:50.396]                 }
[16:17:50.396]                 else {
[16:17:50.396]                   if (TRUE) {
[16:17:50.396]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.396]                     {
[16:17:50.396]                       inherits <- base::inherits
[16:17:50.396]                       invokeRestart <- base::invokeRestart
[16:17:50.396]                       is.null <- base::is.null
[16:17:50.396]                       muffled <- FALSE
[16:17:50.396]                       if (inherits(cond, "message")) {
[16:17:50.396]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:50.396]                         if (muffled) 
[16:17:50.396]                           invokeRestart("muffleMessage")
[16:17:50.396]                       }
[16:17:50.396]                       else if (inherits(cond, "warning")) {
[16:17:50.396]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:50.396]                         if (muffled) 
[16:17:50.396]                           invokeRestart("muffleWarning")
[16:17:50.396]                       }
[16:17:50.396]                       else if (inherits(cond, "condition")) {
[16:17:50.396]                         if (!is.null(pattern)) {
[16:17:50.396]                           computeRestarts <- base::computeRestarts
[16:17:50.396]                           grepl <- base::grepl
[16:17:50.396]                           restarts <- computeRestarts(cond)
[16:17:50.396]                           for (restart in restarts) {
[16:17:50.396]                             name <- restart$name
[16:17:50.396]                             if (is.null(name)) 
[16:17:50.396]                               next
[16:17:50.396]                             if (!grepl(pattern, name)) 
[16:17:50.396]                               next
[16:17:50.396]                             invokeRestart(restart)
[16:17:50.396]                             muffled <- TRUE
[16:17:50.396]                             break
[16:17:50.396]                           }
[16:17:50.396]                         }
[16:17:50.396]                       }
[16:17:50.396]                       invisible(muffled)
[16:17:50.396]                     }
[16:17:50.396]                     muffleCondition(cond, pattern = "^muffle")
[16:17:50.396]                   }
[16:17:50.396]                 }
[16:17:50.396]             }
[16:17:50.396]         }))
[16:17:50.396]     }, error = function(ex) {
[16:17:50.396]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:50.396]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:50.396]                 ...future.rng), started = ...future.startTime, 
[16:17:50.396]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:50.396]             version = "1.8"), class = "FutureResult")
[16:17:50.396]     }, finally = {
[16:17:50.396]         if (!identical(...future.workdir, getwd())) 
[16:17:50.396]             setwd(...future.workdir)
[16:17:50.396]         {
[16:17:50.396]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:50.396]                 ...future.oldOptions$nwarnings <- NULL
[16:17:50.396]             }
[16:17:50.396]             base::options(...future.oldOptions)
[16:17:50.396]             if (.Platform$OS.type == "windows") {
[16:17:50.396]                 old_names <- names(...future.oldEnvVars)
[16:17:50.396]                 envs <- base::Sys.getenv()
[16:17:50.396]                 names <- names(envs)
[16:17:50.396]                 common <- intersect(names, old_names)
[16:17:50.396]                 added <- setdiff(names, old_names)
[16:17:50.396]                 removed <- setdiff(old_names, names)
[16:17:50.396]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:50.396]                   envs[common]]
[16:17:50.396]                 NAMES <- toupper(changed)
[16:17:50.396]                 args <- list()
[16:17:50.396]                 for (kk in seq_along(NAMES)) {
[16:17:50.396]                   name <- changed[[kk]]
[16:17:50.396]                   NAME <- NAMES[[kk]]
[16:17:50.396]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.396]                     next
[16:17:50.396]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:50.396]                 }
[16:17:50.396]                 NAMES <- toupper(added)
[16:17:50.396]                 for (kk in seq_along(NAMES)) {
[16:17:50.396]                   name <- added[[kk]]
[16:17:50.396]                   NAME <- NAMES[[kk]]
[16:17:50.396]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.396]                     next
[16:17:50.396]                   args[[name]] <- ""
[16:17:50.396]                 }
[16:17:50.396]                 NAMES <- toupper(removed)
[16:17:50.396]                 for (kk in seq_along(NAMES)) {
[16:17:50.396]                   name <- removed[[kk]]
[16:17:50.396]                   NAME <- NAMES[[kk]]
[16:17:50.396]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.396]                     next
[16:17:50.396]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:50.396]                 }
[16:17:50.396]                 if (length(args) > 0) 
[16:17:50.396]                   base::do.call(base::Sys.setenv, args = args)
[16:17:50.396]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:50.396]             }
[16:17:50.396]             else {
[16:17:50.396]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:50.396]             }
[16:17:50.396]             {
[16:17:50.396]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:50.396]                   0L) {
[16:17:50.396]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:50.396]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:50.396]                   base::options(opts)
[16:17:50.396]                 }
[16:17:50.396]                 {
[16:17:50.396]                   {
[16:17:50.396]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:50.396]                     NULL
[16:17:50.396]                   }
[16:17:50.396]                   options(future.plan = NULL)
[16:17:50.396]                   if (is.na(NA_character_)) 
[16:17:50.396]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:50.396]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:50.396]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:50.396]                     .init = FALSE)
[16:17:50.396]                 }
[16:17:50.396]             }
[16:17:50.396]         }
[16:17:50.396]     })
[16:17:50.396]     if (TRUE) {
[16:17:50.396]         base::sink(type = "output", split = FALSE)
[16:17:50.396]         if (TRUE) {
[16:17:50.396]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:50.396]         }
[16:17:50.396]         else {
[16:17:50.396]             ...future.result["stdout"] <- base::list(NULL)
[16:17:50.396]         }
[16:17:50.396]         base::close(...future.stdout)
[16:17:50.396]         ...future.stdout <- NULL
[16:17:50.396]     }
[16:17:50.396]     ...future.result$conditions <- ...future.conditions
[16:17:50.396]     ...future.result$finished <- base::Sys.time()
[16:17:50.396]     ...future.result
[16:17:50.396] }
[16:17:50.400] assign_globals() ...
[16:17:50.400] List of 5
[16:17:50.400]  $ ...future.FUN            :function (x, ...)  
[16:17:50.400]  $ future.call.arguments    : list()
[16:17:50.400]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:50.400]  $ ...future.elements_ii    :List of 2
[16:17:50.400]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:17:50.400]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:17:50.400]  $ ...future.seeds_ii       : NULL
[16:17:50.400]  $ ...future.globals.maxSize: NULL
[16:17:50.400]  - attr(*, "where")=List of 5
[16:17:50.400]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:50.400]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:50.400]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:50.400]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:50.400]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:50.400]  - attr(*, "resolved")= logi FALSE
[16:17:50.400]  - attr(*, "total_size")= num 1248
[16:17:50.400]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:50.400]  - attr(*, "already-done")= logi TRUE
[16:17:50.408] - copied ‘...future.FUN’ to environment
[16:17:50.408] - copied ‘future.call.arguments’ to environment
[16:17:50.409] - copied ‘...future.elements_ii’ to environment
[16:17:50.409] - copied ‘...future.seeds_ii’ to environment
[16:17:50.409] - copied ‘...future.globals.maxSize’ to environment
[16:17:50.409] assign_globals() ... done
[16:17:50.409] requestCore(): workers = 2
[16:17:50.412] MulticoreFuture started
[16:17:50.412] - Launch lazy future ... done
[16:17:50.412] run() for ‘MulticoreFuture’ ... done
[16:17:50.413] Created future:
[16:17:50.413] plan(): Setting new future strategy stack:
[16:17:50.413] List of future strategies:
[16:17:50.413] 1. sequential:
[16:17:50.413]    - args: function (..., envir = parent.frame())
[16:17:50.413]    - tweaked: FALSE
[16:17:50.413]    - call: NULL
[16:17:50.414] plan(): nbrOfWorkers() = 1
[16:17:50.417] plan(): Setting new future strategy stack:
[16:17:50.417] List of future strategies:
[16:17:50.417] 1. multicore:
[16:17:50.417]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:50.417]    - tweaked: FALSE
[16:17:50.417]    - call: plan(strategy)
[16:17:50.413] MulticoreFuture:
[16:17:50.413] Label: ‘future_eapply-2’
[16:17:50.413] Expression:
[16:17:50.413] {
[16:17:50.413]     do.call(function(...) {
[16:17:50.413]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.413]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:50.413]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.413]             on.exit(options(oopts), add = TRUE)
[16:17:50.413]         }
[16:17:50.413]         {
[16:17:50.413]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:50.413]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.413]                 ...future.FUN(...future.X_jj, ...)
[16:17:50.413]             })
[16:17:50.413]         }
[16:17:50.413]     }, args = future.call.arguments)
[16:17:50.413] }
[16:17:50.413] Lazy evaluation: FALSE
[16:17:50.413] Asynchronous evaluation: TRUE
[16:17:50.413] Local evaluation: TRUE
[16:17:50.413] Environment: R_GlobalEnv
[16:17:50.413] Capture standard output: TRUE
[16:17:50.413] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:50.413] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:50.413] Packages: 1 packages (‘stats’)
[16:17:50.413] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:50.413] Resolved: FALSE
[16:17:50.413] Value: <not collected>
[16:17:50.413] Conditions captured: <none>
[16:17:50.413] Early signaling: FALSE
[16:17:50.413] Owner process: 95d59565-e757-824f-7f5c-7f754384cffc
[16:17:50.413] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:50.426] Chunk #2 of 2 ... DONE
[16:17:50.426] plan(): nbrOfWorkers() = 2
[16:17:50.426] Launching 2 futures (chunks) ... DONE
[16:17:50.427] Resolving 2 futures (chunks) ...
[16:17:50.427] resolve() on list ...
[16:17:50.427]  recursive: 0
[16:17:50.427]  length: 2
[16:17:50.427] 
[16:17:50.428] Future #1
[16:17:50.428] result() for MulticoreFuture ...
[16:17:50.429] result() for MulticoreFuture ...
[16:17:50.429] result() for MulticoreFuture ... done
[16:17:50.429] result() for MulticoreFuture ... done
[16:17:50.429] result() for MulticoreFuture ...
[16:17:50.429] result() for MulticoreFuture ... done
[16:17:50.432] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:17:50.432] - nx: 2
[16:17:50.432] - relay: TRUE
[16:17:50.432] - stdout: TRUE
[16:17:50.432] - signal: TRUE
[16:17:50.433] - resignal: FALSE
[16:17:50.433] - force: TRUE
[16:17:50.433] - relayed: [n=2] FALSE, FALSE
[16:17:50.433] - queued futures: [n=2] FALSE, FALSE
[16:17:50.433]  - until=1
[16:17:50.434]  - relaying element #1
[16:17:50.434] result() for MulticoreFuture ...
[16:17:50.434] result() for MulticoreFuture ... done
[16:17:50.434] result() for MulticoreFuture ...
[16:17:50.435] result() for MulticoreFuture ... done
[16:17:50.435] result() for MulticoreFuture ...
[16:17:50.435] result() for MulticoreFuture ... done
[16:17:50.435] result() for MulticoreFuture ...
[16:17:50.436] result() for MulticoreFuture ... done
[16:17:50.436] - relayed: [n=2] TRUE, FALSE
[16:17:50.436] - queued futures: [n=2] TRUE, FALSE
[16:17:50.436] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:17:50.436]  length: 1 (resolved future 1)
[16:17:50.437] Future #2
[16:17:50.437] result() for MulticoreFuture ...
[16:17:50.438] result() for MulticoreFuture ...
[16:17:50.438] result() for MulticoreFuture ... done
[16:17:50.438] result() for MulticoreFuture ... done
[16:17:50.438] result() for MulticoreFuture ...
[16:17:50.438] result() for MulticoreFuture ... done
[16:17:50.439] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:17:50.439] - nx: 2
[16:17:50.439] - relay: TRUE
[16:17:50.439] - stdout: TRUE
[16:17:50.439] - signal: TRUE
[16:17:50.439] - resignal: FALSE
[16:17:50.439] - force: TRUE
[16:17:50.439] - relayed: [n=2] TRUE, FALSE
[16:17:50.440] - queued futures: [n=2] TRUE, FALSE
[16:17:50.440]  - until=2
[16:17:50.440]  - relaying element #2
[16:17:50.440] result() for MulticoreFuture ...
[16:17:50.440] result() for MulticoreFuture ... done
[16:17:50.440] result() for MulticoreFuture ...
[16:17:50.440] result() for MulticoreFuture ... done
[16:17:50.441] result() for MulticoreFuture ...
[16:17:50.441] result() for MulticoreFuture ... done
[16:17:50.441] result() for MulticoreFuture ...
[16:17:50.441] result() for MulticoreFuture ... done
[16:17:50.441] - relayed: [n=2] TRUE, TRUE
[16:17:50.441] - queued futures: [n=2] TRUE, TRUE
[16:17:50.441] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:17:50.441]  length: 0 (resolved future 2)
[16:17:50.441] Relaying remaining futures
[16:17:50.442] signalConditionsASAP(NULL, pos=0) ...
[16:17:50.442] - nx: 2
[16:17:50.442] - relay: TRUE
[16:17:50.442] - stdout: TRUE
[16:17:50.442] - signal: TRUE
[16:17:50.442] - resignal: FALSE
[16:17:50.442] - force: TRUE
[16:17:50.442] - relayed: [n=2] TRUE, TRUE
[16:17:50.442] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:50.443] - relayed: [n=2] TRUE, TRUE
[16:17:50.443] - queued futures: [n=2] TRUE, TRUE
[16:17:50.443] signalConditionsASAP(NULL, pos=0) ... done
[16:17:50.443] resolve() on list ... DONE
[16:17:50.443] result() for MulticoreFuture ...
[16:17:50.443] result() for MulticoreFuture ... done
[16:17:50.443] result() for MulticoreFuture ...
[16:17:50.443] result() for MulticoreFuture ... done
[16:17:50.444] result() for MulticoreFuture ...
[16:17:50.444] result() for MulticoreFuture ... done
[16:17:50.444] result() for MulticoreFuture ...
[16:17:50.444] result() for MulticoreFuture ... done
[16:17:50.444]  - Number of value chunks collected: 2
[16:17:50.444] Resolving 2 futures (chunks) ... DONE
[16:17:50.444] Reducing values from 2 chunks ...
[16:17:50.444]  - Number of values collected after concatenation: 3
[16:17:50.445]  - Number of values expected: 3
[16:17:50.445] Reducing values from 2 chunks ... DONE
[16:17:50.445] future_lapply() ... DONE
[16:17:50.445] future_lapply() ...
[16:17:50.450] Number of chunks: 2
[16:17:50.450] getGlobalsAndPackagesXApply() ...
[16:17:50.450]  - future.globals: TRUE
[16:17:50.450] getGlobalsAndPackages() ...
[16:17:50.450] Searching for globals...
[16:17:50.451] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:50.452] Searching for globals ... DONE
[16:17:50.452] Resolving globals: FALSE
[16:17:50.452] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:17:50.452] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:17:50.453] - globals: [1] ‘FUN’
[16:17:50.453] - packages: [1] ‘stats’
[16:17:50.453] getGlobalsAndPackages() ... DONE
[16:17:50.453]  - globals found/used: [n=1] ‘FUN’
[16:17:50.453]  - needed namespaces: [n=1] ‘stats’
[16:17:50.453] Finding globals ... DONE
[16:17:50.453]  - use_args: TRUE
[16:17:50.453]  - Getting '...' globals ...
[16:17:50.454] resolve() on list ...
[16:17:50.454]  recursive: 0
[16:17:50.454]  length: 1
[16:17:50.454]  elements: ‘...’
[16:17:50.454]  length: 0 (resolved future 1)
[16:17:50.454] resolve() on list ... DONE
[16:17:50.455]    - '...' content: [n=0] 
[16:17:50.455] List of 1
[16:17:50.455]  $ ...: list()
[16:17:50.455]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:50.455]  - attr(*, "where")=List of 1
[16:17:50.455]   ..$ ...:<environment: 0x556da457ac90> 
[16:17:50.455]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:50.455]  - attr(*, "resolved")= logi TRUE
[16:17:50.455]  - attr(*, "total_size")= num NA
[16:17:50.458]  - Getting '...' globals ... DONE
[16:17:50.458] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:50.458] List of 2
[16:17:50.458]  $ ...future.FUN:function (x, ...)  
[16:17:50.458]  $ ...          : list()
[16:17:50.458]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:50.458]  - attr(*, "where")=List of 2
[16:17:50.458]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:50.458]   ..$ ...          :<environment: 0x556da457ac90> 
[16:17:50.458]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:50.458]  - attr(*, "resolved")= logi FALSE
[16:17:50.458]  - attr(*, "total_size")= num 1248
[16:17:50.462] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:50.462] getGlobalsAndPackagesXApply() ... DONE
[16:17:50.462] Number of futures (= number of chunks): 2
[16:17:50.463] Launching 2 futures (chunks) ...
[16:17:50.463] Chunk #1 of 2 ...
[16:17:50.463]  - Finding globals in 'X' for chunk #1 ...
[16:17:50.463] getGlobalsAndPackages() ...
[16:17:50.463] Searching for globals...
[16:17:50.463] 
[16:17:50.463] Searching for globals ... DONE
[16:17:50.463] - globals: [0] <none>
[16:17:50.463] getGlobalsAndPackages() ... DONE
[16:17:50.464]    + additional globals found: [n=0] 
[16:17:50.464]    + additional namespaces needed: [n=0] 
[16:17:50.464]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:50.464]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:50.464]  - seeds: <none>
[16:17:50.464]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.464] getGlobalsAndPackages() ...
[16:17:50.464] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.464] Resolving globals: FALSE
[16:17:50.465] Tweak future expression to call with '...' arguments ...
[16:17:50.465] {
[16:17:50.465]     do.call(function(...) {
[16:17:50.465]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.465]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:50.465]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.465]             on.exit(options(oopts), add = TRUE)
[16:17:50.465]         }
[16:17:50.465]         {
[16:17:50.465]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:50.465]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.465]                 ...future.FUN(...future.X_jj, ...)
[16:17:50.465]             })
[16:17:50.465]         }
[16:17:50.465]     }, args = future.call.arguments)
[16:17:50.465] }
[16:17:50.465] Tweak future expression to call with '...' arguments ... DONE
[16:17:50.465] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.465] - packages: [1] ‘stats’
[16:17:50.465] getGlobalsAndPackages() ... DONE
[16:17:50.466] run() for ‘Future’ ...
[16:17:50.466] - state: ‘created’
[16:17:50.466] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:50.469] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:50.470] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:50.470]   - Field: ‘label’
[16:17:50.470]   - Field: ‘local’
[16:17:50.470]   - Field: ‘owner’
[16:17:50.470]   - Field: ‘envir’
[16:17:50.470]   - Field: ‘workers’
[16:17:50.470]   - Field: ‘packages’
[16:17:50.470]   - Field: ‘gc’
[16:17:50.470]   - Field: ‘job’
[16:17:50.471]   - Field: ‘conditions’
[16:17:50.471]   - Field: ‘expr’
[16:17:50.471]   - Field: ‘uuid’
[16:17:50.471]   - Field: ‘seed’
[16:17:50.471]   - Field: ‘version’
[16:17:50.471]   - Field: ‘result’
[16:17:50.471]   - Field: ‘asynchronous’
[16:17:50.471]   - Field: ‘calls’
[16:17:50.471]   - Field: ‘globals’
[16:17:50.471]   - Field: ‘stdout’
[16:17:50.471]   - Field: ‘earlySignal’
[16:17:50.472]   - Field: ‘lazy’
[16:17:50.472]   - Field: ‘state’
[16:17:50.472] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:50.472] - Launch lazy future ...
[16:17:50.472] Packages needed by the future expression (n = 1): ‘stats’
[16:17:50.472] Packages needed by future strategies (n = 0): <none>
[16:17:50.473] {
[16:17:50.473]     {
[16:17:50.473]         {
[16:17:50.473]             ...future.startTime <- base::Sys.time()
[16:17:50.473]             {
[16:17:50.473]                 {
[16:17:50.473]                   {
[16:17:50.473]                     {
[16:17:50.473]                       {
[16:17:50.473]                         base::local({
[16:17:50.473]                           has_future <- base::requireNamespace("future", 
[16:17:50.473]                             quietly = TRUE)
[16:17:50.473]                           if (has_future) {
[16:17:50.473]                             ns <- base::getNamespace("future")
[16:17:50.473]                             version <- ns[[".package"]][["version"]]
[16:17:50.473]                             if (is.null(version)) 
[16:17:50.473]                               version <- utils::packageVersion("future")
[16:17:50.473]                           }
[16:17:50.473]                           else {
[16:17:50.473]                             version <- NULL
[16:17:50.473]                           }
[16:17:50.473]                           if (!has_future || version < "1.8.0") {
[16:17:50.473]                             info <- base::c(r_version = base::gsub("R version ", 
[16:17:50.473]                               "", base::R.version$version.string), 
[16:17:50.473]                               platform = base::sprintf("%s (%s-bit)", 
[16:17:50.473]                                 base::R.version$platform, 8 * 
[16:17:50.473]                                   base::.Machine$sizeof.pointer), 
[16:17:50.473]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:50.473]                                 "release", "version")], collapse = " "), 
[16:17:50.473]                               hostname = base::Sys.info()[["nodename"]])
[16:17:50.473]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:17:50.473]                               info)
[16:17:50.473]                             info <- base::paste(info, collapse = "; ")
[16:17:50.473]                             if (!has_future) {
[16:17:50.473]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:50.473]                                 info)
[16:17:50.473]                             }
[16:17:50.473]                             else {
[16:17:50.473]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:50.473]                                 info, version)
[16:17:50.473]                             }
[16:17:50.473]                             base::stop(msg)
[16:17:50.473]                           }
[16:17:50.473]                         })
[16:17:50.473]                       }
[16:17:50.473]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:50.473]                       base::options(mc.cores = 1L)
[16:17:50.473]                     }
[16:17:50.473]                     base::local({
[16:17:50.473]                       for (pkg in "stats") {
[16:17:50.473]                         base::loadNamespace(pkg)
[16:17:50.473]                         base::library(pkg, character.only = TRUE)
[16:17:50.473]                       }
[16:17:50.473]                     })
[16:17:50.473]                   }
[16:17:50.473]                   ...future.strategy.old <- future::plan("list")
[16:17:50.473]                   options(future.plan = NULL)
[16:17:50.473]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:50.473]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:50.473]                 }
[16:17:50.473]                 ...future.workdir <- getwd()
[16:17:50.473]             }
[16:17:50.473]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:50.473]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:50.473]         }
[16:17:50.473]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:50.473]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:50.473]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:50.473]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:50.473]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:50.473]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:50.473]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:50.473]             base::names(...future.oldOptions))
[16:17:50.473]     }
[16:17:50.473]     if (FALSE) {
[16:17:50.473]     }
[16:17:50.473]     else {
[16:17:50.473]         if (TRUE) {
[16:17:50.473]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:50.473]                 open = "w")
[16:17:50.473]         }
[16:17:50.473]         else {
[16:17:50.473]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:50.473]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:50.473]         }
[16:17:50.473]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:50.473]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:50.473]             base::sink(type = "output", split = FALSE)
[16:17:50.473]             base::close(...future.stdout)
[16:17:50.473]         }, add = TRUE)
[16:17:50.473]     }
[16:17:50.473]     ...future.frame <- base::sys.nframe()
[16:17:50.473]     ...future.conditions <- base::list()
[16:17:50.473]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:50.473]     if (FALSE) {
[16:17:50.473]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:50.473]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:50.473]     }
[16:17:50.473]     ...future.result <- base::tryCatch({
[16:17:50.473]         base::withCallingHandlers({
[16:17:50.473]             ...future.value <- base::withVisible(base::local({
[16:17:50.473]                 withCallingHandlers({
[16:17:50.473]                   {
[16:17:50.473]                     do.call(function(...) {
[16:17:50.473]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.473]                       if (!identical(...future.globals.maxSize.org, 
[16:17:50.473]                         ...future.globals.maxSize)) {
[16:17:50.473]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.473]                         on.exit(options(oopts), add = TRUE)
[16:17:50.473]                       }
[16:17:50.473]                       {
[16:17:50.473]                         lapply(seq_along(...future.elements_ii), 
[16:17:50.473]                           FUN = function(jj) {
[16:17:50.473]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.473]                             ...future.FUN(...future.X_jj, ...)
[16:17:50.473]                           })
[16:17:50.473]                       }
[16:17:50.473]                     }, args = future.call.arguments)
[16:17:50.473]                   }
[16:17:50.473]                 }, immediateCondition = function(cond) {
[16:17:50.473]                   save_rds <- function (object, pathname, ...) 
[16:17:50.473]                   {
[16:17:50.473]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:50.473]                     if (file_test("-f", pathname_tmp)) {
[16:17:50.473]                       fi_tmp <- file.info(pathname_tmp)
[16:17:50.473]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:50.473]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:50.473]                         fi_tmp[["mtime"]])
[16:17:50.473]                     }
[16:17:50.473]                     tryCatch({
[16:17:50.473]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:50.473]                     }, error = function(ex) {
[16:17:50.473]                       msg <- conditionMessage(ex)
[16:17:50.473]                       fi_tmp <- file.info(pathname_tmp)
[16:17:50.473]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:50.473]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:50.473]                         fi_tmp[["mtime"]], msg)
[16:17:50.473]                       ex$message <- msg
[16:17:50.473]                       stop(ex)
[16:17:50.473]                     })
[16:17:50.473]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:50.473]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:50.473]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:50.473]                       fi_tmp <- file.info(pathname_tmp)
[16:17:50.473]                       fi <- file.info(pathname)
[16:17:50.473]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:50.473]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:50.473]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:50.473]                         fi[["size"]], fi[["mtime"]])
[16:17:50.473]                       stop(msg)
[16:17:50.473]                     }
[16:17:50.473]                     invisible(pathname)
[16:17:50.473]                   }
[16:17:50.473]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:50.473]                     rootPath = tempdir()) 
[16:17:50.473]                   {
[16:17:50.473]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:50.473]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:50.473]                       tmpdir = path, fileext = ".rds")
[16:17:50.473]                     save_rds(obj, file)
[16:17:50.473]                   }
[16:17:50.473]                   saveImmediateCondition(cond, path = "/tmp/Rtmpstkvtd/.future/immediateConditions")
[16:17:50.473]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.473]                   {
[16:17:50.473]                     inherits <- base::inherits
[16:17:50.473]                     invokeRestart <- base::invokeRestart
[16:17:50.473]                     is.null <- base::is.null
[16:17:50.473]                     muffled <- FALSE
[16:17:50.473]                     if (inherits(cond, "message")) {
[16:17:50.473]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:50.473]                       if (muffled) 
[16:17:50.473]                         invokeRestart("muffleMessage")
[16:17:50.473]                     }
[16:17:50.473]                     else if (inherits(cond, "warning")) {
[16:17:50.473]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:50.473]                       if (muffled) 
[16:17:50.473]                         invokeRestart("muffleWarning")
[16:17:50.473]                     }
[16:17:50.473]                     else if (inherits(cond, "condition")) {
[16:17:50.473]                       if (!is.null(pattern)) {
[16:17:50.473]                         computeRestarts <- base::computeRestarts
[16:17:50.473]                         grepl <- base::grepl
[16:17:50.473]                         restarts <- computeRestarts(cond)
[16:17:50.473]                         for (restart in restarts) {
[16:17:50.473]                           name <- restart$name
[16:17:50.473]                           if (is.null(name)) 
[16:17:50.473]                             next
[16:17:50.473]                           if (!grepl(pattern, name)) 
[16:17:50.473]                             next
[16:17:50.473]                           invokeRestart(restart)
[16:17:50.473]                           muffled <- TRUE
[16:17:50.473]                           break
[16:17:50.473]                         }
[16:17:50.473]                       }
[16:17:50.473]                     }
[16:17:50.473]                     invisible(muffled)
[16:17:50.473]                   }
[16:17:50.473]                   muffleCondition(cond)
[16:17:50.473]                 })
[16:17:50.473]             }))
[16:17:50.473]             future::FutureResult(value = ...future.value$value, 
[16:17:50.473]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:50.473]                   ...future.rng), globalenv = if (FALSE) 
[16:17:50.473]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:50.473]                     ...future.globalenv.names))
[16:17:50.473]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:50.473]         }, condition = base::local({
[16:17:50.473]             c <- base::c
[16:17:50.473]             inherits <- base::inherits
[16:17:50.473]             invokeRestart <- base::invokeRestart
[16:17:50.473]             length <- base::length
[16:17:50.473]             list <- base::list
[16:17:50.473]             seq.int <- base::seq.int
[16:17:50.473]             signalCondition <- base::signalCondition
[16:17:50.473]             sys.calls <- base::sys.calls
[16:17:50.473]             `[[` <- base::`[[`
[16:17:50.473]             `+` <- base::`+`
[16:17:50.473]             `<<-` <- base::`<<-`
[16:17:50.473]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:50.473]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:50.473]                   3L)]
[16:17:50.473]             }
[16:17:50.473]             function(cond) {
[16:17:50.473]                 is_error <- inherits(cond, "error")
[16:17:50.473]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:50.473]                   NULL)
[16:17:50.473]                 if (is_error) {
[16:17:50.473]                   sessionInformation <- function() {
[16:17:50.473]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:50.473]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:50.473]                       search = base::search(), system = base::Sys.info())
[16:17:50.473]                   }
[16:17:50.473]                   ...future.conditions[[length(...future.conditions) + 
[16:17:50.473]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:50.473]                     cond$call), session = sessionInformation(), 
[16:17:50.473]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:50.473]                   signalCondition(cond)
[16:17:50.473]                 }
[16:17:50.473]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:50.473]                 "immediateCondition"))) {
[16:17:50.473]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:50.473]                   ...future.conditions[[length(...future.conditions) + 
[16:17:50.473]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:50.473]                   if (TRUE && !signal) {
[16:17:50.473]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.473]                     {
[16:17:50.473]                       inherits <- base::inherits
[16:17:50.473]                       invokeRestart <- base::invokeRestart
[16:17:50.473]                       is.null <- base::is.null
[16:17:50.473]                       muffled <- FALSE
[16:17:50.473]                       if (inherits(cond, "message")) {
[16:17:50.473]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:50.473]                         if (muffled) 
[16:17:50.473]                           invokeRestart("muffleMessage")
[16:17:50.473]                       }
[16:17:50.473]                       else if (inherits(cond, "warning")) {
[16:17:50.473]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:50.473]                         if (muffled) 
[16:17:50.473]                           invokeRestart("muffleWarning")
[16:17:50.473]                       }
[16:17:50.473]                       else if (inherits(cond, "condition")) {
[16:17:50.473]                         if (!is.null(pattern)) {
[16:17:50.473]                           computeRestarts <- base::computeRestarts
[16:17:50.473]                           grepl <- base::grepl
[16:17:50.473]                           restarts <- computeRestarts(cond)
[16:17:50.473]                           for (restart in restarts) {
[16:17:50.473]                             name <- restart$name
[16:17:50.473]                             if (is.null(name)) 
[16:17:50.473]                               next
[16:17:50.473]                             if (!grepl(pattern, name)) 
[16:17:50.473]                               next
[16:17:50.473]                             invokeRestart(restart)
[16:17:50.473]                             muffled <- TRUE
[16:17:50.473]                             break
[16:17:50.473]                           }
[16:17:50.473]                         }
[16:17:50.473]                       }
[16:17:50.473]                       invisible(muffled)
[16:17:50.473]                     }
[16:17:50.473]                     muffleCondition(cond, pattern = "^muffle")
[16:17:50.473]                   }
[16:17:50.473]                 }
[16:17:50.473]                 else {
[16:17:50.473]                   if (TRUE) {
[16:17:50.473]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.473]                     {
[16:17:50.473]                       inherits <- base::inherits
[16:17:50.473]                       invokeRestart <- base::invokeRestart
[16:17:50.473]                       is.null <- base::is.null
[16:17:50.473]                       muffled <- FALSE
[16:17:50.473]                       if (inherits(cond, "message")) {
[16:17:50.473]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:50.473]                         if (muffled) 
[16:17:50.473]                           invokeRestart("muffleMessage")
[16:17:50.473]                       }
[16:17:50.473]                       else if (inherits(cond, "warning")) {
[16:17:50.473]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:50.473]                         if (muffled) 
[16:17:50.473]                           invokeRestart("muffleWarning")
[16:17:50.473]                       }
[16:17:50.473]                       else if (inherits(cond, "condition")) {
[16:17:50.473]                         if (!is.null(pattern)) {
[16:17:50.473]                           computeRestarts <- base::computeRestarts
[16:17:50.473]                           grepl <- base::grepl
[16:17:50.473]                           restarts <- computeRestarts(cond)
[16:17:50.473]                           for (restart in restarts) {
[16:17:50.473]                             name <- restart$name
[16:17:50.473]                             if (is.null(name)) 
[16:17:50.473]                               next
[16:17:50.473]                             if (!grepl(pattern, name)) 
[16:17:50.473]                               next
[16:17:50.473]                             invokeRestart(restart)
[16:17:50.473]                             muffled <- TRUE
[16:17:50.473]                             break
[16:17:50.473]                           }
[16:17:50.473]                         }
[16:17:50.473]                       }
[16:17:50.473]                       invisible(muffled)
[16:17:50.473]                     }
[16:17:50.473]                     muffleCondition(cond, pattern = "^muffle")
[16:17:50.473]                   }
[16:17:50.473]                 }
[16:17:50.473]             }
[16:17:50.473]         }))
[16:17:50.473]     }, error = function(ex) {
[16:17:50.473]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:50.473]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:50.473]                 ...future.rng), started = ...future.startTime, 
[16:17:50.473]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:50.473]             version = "1.8"), class = "FutureResult")
[16:17:50.473]     }, finally = {
[16:17:50.473]         if (!identical(...future.workdir, getwd())) 
[16:17:50.473]             setwd(...future.workdir)
[16:17:50.473]         {
[16:17:50.473]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:50.473]                 ...future.oldOptions$nwarnings <- NULL
[16:17:50.473]             }
[16:17:50.473]             base::options(...future.oldOptions)
[16:17:50.473]             if (.Platform$OS.type == "windows") {
[16:17:50.473]                 old_names <- names(...future.oldEnvVars)
[16:17:50.473]                 envs <- base::Sys.getenv()
[16:17:50.473]                 names <- names(envs)
[16:17:50.473]                 common <- intersect(names, old_names)
[16:17:50.473]                 added <- setdiff(names, old_names)
[16:17:50.473]                 removed <- setdiff(old_names, names)
[16:17:50.473]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:50.473]                   envs[common]]
[16:17:50.473]                 NAMES <- toupper(changed)
[16:17:50.473]                 args <- list()
[16:17:50.473]                 for (kk in seq_along(NAMES)) {
[16:17:50.473]                   name <- changed[[kk]]
[16:17:50.473]                   NAME <- NAMES[[kk]]
[16:17:50.473]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.473]                     next
[16:17:50.473]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:50.473]                 }
[16:17:50.473]                 NAMES <- toupper(added)
[16:17:50.473]                 for (kk in seq_along(NAMES)) {
[16:17:50.473]                   name <- added[[kk]]
[16:17:50.473]                   NAME <- NAMES[[kk]]
[16:17:50.473]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.473]                     next
[16:17:50.473]                   args[[name]] <- ""
[16:17:50.473]                 }
[16:17:50.473]                 NAMES <- toupper(removed)
[16:17:50.473]                 for (kk in seq_along(NAMES)) {
[16:17:50.473]                   name <- removed[[kk]]
[16:17:50.473]                   NAME <- NAMES[[kk]]
[16:17:50.473]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.473]                     next
[16:17:50.473]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:50.473]                 }
[16:17:50.473]                 if (length(args) > 0) 
[16:17:50.473]                   base::do.call(base::Sys.setenv, args = args)
[16:17:50.473]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:50.473]             }
[16:17:50.473]             else {
[16:17:50.473]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:50.473]             }
[16:17:50.473]             {
[16:17:50.473]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:50.473]                   0L) {
[16:17:50.473]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:50.473]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:50.473]                   base::options(opts)
[16:17:50.473]                 }
[16:17:50.473]                 {
[16:17:50.473]                   {
[16:17:50.473]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:50.473]                     NULL
[16:17:50.473]                   }
[16:17:50.473]                   options(future.plan = NULL)
[16:17:50.473]                   if (is.na(NA_character_)) 
[16:17:50.473]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:50.473]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:50.473]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:50.473]                     .init = FALSE)
[16:17:50.473]                 }
[16:17:50.473]             }
[16:17:50.473]         }
[16:17:50.473]     })
[16:17:50.473]     if (TRUE) {
[16:17:50.473]         base::sink(type = "output", split = FALSE)
[16:17:50.473]         if (TRUE) {
[16:17:50.473]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:50.473]         }
[16:17:50.473]         else {
[16:17:50.473]             ...future.result["stdout"] <- base::list(NULL)
[16:17:50.473]         }
[16:17:50.473]         base::close(...future.stdout)
[16:17:50.473]         ...future.stdout <- NULL
[16:17:50.473]     }
[16:17:50.473]     ...future.result$conditions <- ...future.conditions
[16:17:50.473]     ...future.result$finished <- base::Sys.time()
[16:17:50.473]     ...future.result
[16:17:50.473] }
[16:17:50.475] assign_globals() ...
[16:17:50.475] List of 5
[16:17:50.475]  $ ...future.FUN            :function (x, ...)  
[16:17:50.475]  $ future.call.arguments    : list()
[16:17:50.475]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:50.475]  $ ...future.elements_ii    :List of 1
[16:17:50.475]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[16:17:50.475]  $ ...future.seeds_ii       : NULL
[16:17:50.475]  $ ...future.globals.maxSize: NULL
[16:17:50.475]  - attr(*, "where")=List of 5
[16:17:50.475]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:50.475]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:50.475]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:50.475]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:50.475]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:50.475]  - attr(*, "resolved")= logi FALSE
[16:17:50.475]  - attr(*, "total_size")= num 1248
[16:17:50.475]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:50.475]  - attr(*, "already-done")= logi TRUE
[16:17:50.480] - copied ‘...future.FUN’ to environment
[16:17:50.480] - copied ‘future.call.arguments’ to environment
[16:17:50.480] - copied ‘...future.elements_ii’ to environment
[16:17:50.480] - copied ‘...future.seeds_ii’ to environment
[16:17:50.480] - copied ‘...future.globals.maxSize’ to environment
[16:17:50.480] assign_globals() ... done
[16:17:50.480] requestCore(): workers = 2
[16:17:50.482] MulticoreFuture started
[16:17:50.482] - Launch lazy future ... done
[16:17:50.483] run() for ‘MulticoreFuture’ ... done
[16:17:50.483] Created future:
[16:17:50.483] plan(): Setting new future strategy stack:
[16:17:50.484] List of future strategies:
[16:17:50.484] 1. sequential:
[16:17:50.484]    - args: function (..., envir = parent.frame())
[16:17:50.484]    - tweaked: FALSE
[16:17:50.484]    - call: NULL
[16:17:50.484] plan(): nbrOfWorkers() = 1
[16:17:50.487] plan(): Setting new future strategy stack:
[16:17:50.487] List of future strategies:
[16:17:50.487] 1. multicore:
[16:17:50.487]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:50.487]    - tweaked: FALSE
[16:17:50.487]    - call: plan(strategy)
[16:17:50.492] plan(): nbrOfWorkers() = 2
[16:17:50.483] MulticoreFuture:
[16:17:50.483] Label: ‘future_eapply-1’
[16:17:50.483] Expression:
[16:17:50.483] {
[16:17:50.483]     do.call(function(...) {
[16:17:50.483]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.483]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:50.483]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.483]             on.exit(options(oopts), add = TRUE)
[16:17:50.483]         }
[16:17:50.483]         {
[16:17:50.483]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:50.483]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.483]                 ...future.FUN(...future.X_jj, ...)
[16:17:50.483]             })
[16:17:50.483]         }
[16:17:50.483]     }, args = future.call.arguments)
[16:17:50.483] }
[16:17:50.483] Lazy evaluation: FALSE
[16:17:50.483] Asynchronous evaluation: TRUE
[16:17:50.483] Local evaluation: TRUE
[16:17:50.483] Environment: R_GlobalEnv
[16:17:50.483] Capture standard output: TRUE
[16:17:50.483] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:50.483] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:50.483] Packages: 1 packages (‘stats’)
[16:17:50.483] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:50.483] Resolved: TRUE
[16:17:50.483] Value: <not collected>
[16:17:50.483] Conditions captured: <none>
[16:17:50.483] Early signaling: FALSE
[16:17:50.483] Owner process: 95d59565-e757-824f-7f5c-7f754384cffc
[16:17:50.483] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:50.493] Chunk #1 of 2 ... DONE
[16:17:50.493] Chunk #2 of 2 ...
[16:17:50.493]  - Finding globals in 'X' for chunk #2 ...
[16:17:50.493] getGlobalsAndPackages() ...
[16:17:50.493] Searching for globals...
[16:17:50.494] 
[16:17:50.494] Searching for globals ... DONE
[16:17:50.494] - globals: [0] <none>
[16:17:50.494] getGlobalsAndPackages() ... DONE
[16:17:50.494]    + additional globals found: [n=0] 
[16:17:50.494]    + additional namespaces needed: [n=0] 
[16:17:50.495]  - Finding globals in 'X' for chunk #2 ... DONE
[16:17:50.495]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:50.495]  - seeds: <none>
[16:17:50.495]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.495] getGlobalsAndPackages() ...
[16:17:50.495] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.495] Resolving globals: FALSE
[16:17:50.496] Tweak future expression to call with '...' arguments ...
[16:17:50.496] {
[16:17:50.496]     do.call(function(...) {
[16:17:50.496]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.496]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:50.496]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.496]             on.exit(options(oopts), add = TRUE)
[16:17:50.496]         }
[16:17:50.496]         {
[16:17:50.496]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:50.496]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.496]                 ...future.FUN(...future.X_jj, ...)
[16:17:50.496]             })
[16:17:50.496]         }
[16:17:50.496]     }, args = future.call.arguments)
[16:17:50.496] }
[16:17:50.496] Tweak future expression to call with '...' arguments ... DONE
[16:17:50.497] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:50.497] - packages: [1] ‘stats’
[16:17:50.497] getGlobalsAndPackages() ... DONE
[16:17:50.501] run() for ‘Future’ ...
[16:17:50.501] - state: ‘created’
[16:17:50.501] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:17:50.506] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:50.507] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:17:50.507]   - Field: ‘label’
[16:17:50.507]   - Field: ‘local’
[16:17:50.507]   - Field: ‘owner’
[16:17:50.507]   - Field: ‘envir’
[16:17:50.508]   - Field: ‘workers’
[16:17:50.508]   - Field: ‘packages’
[16:17:50.508]   - Field: ‘gc’
[16:17:50.508]   - Field: ‘job’
[16:17:50.509]   - Field: ‘conditions’
[16:17:50.509]   - Field: ‘expr’
[16:17:50.509]   - Field: ‘uuid’
[16:17:50.509]   - Field: ‘seed’
[16:17:50.509]   - Field: ‘version’
[16:17:50.509]   - Field: ‘result’
[16:17:50.510]   - Field: ‘asynchronous’
[16:17:50.510]   - Field: ‘calls’
[16:17:50.510]   - Field: ‘globals’
[16:17:50.510]   - Field: ‘stdout’
[16:17:50.510]   - Field: ‘earlySignal’
[16:17:50.510]   - Field: ‘lazy’
[16:17:50.511]   - Field: ‘state’
[16:17:50.511] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:17:50.511] - Launch lazy future ...
[16:17:50.511] Packages needed by the future expression (n = 1): ‘stats’
[16:17:50.512] Packages needed by future strategies (n = 0): <none>
[16:17:50.512] {
[16:17:50.512]     {
[16:17:50.512]         {
[16:17:50.512]             ...future.startTime <- base::Sys.time()
[16:17:50.512]             {
[16:17:50.512]                 {
[16:17:50.512]                   {
[16:17:50.512]                     {
[16:17:50.512]                       {
[16:17:50.512]                         base::local({
[16:17:50.512]                           has_future <- base::requireNamespace("future", 
[16:17:50.512]                             quietly = TRUE)
[16:17:50.512]                           if (has_future) {
[16:17:50.512]                             ns <- base::getNamespace("future")
[16:17:50.512]                             version <- ns[[".package"]][["version"]]
[16:17:50.512]                             if (is.null(version)) 
[16:17:50.512]                               version <- utils::packageVersion("future")
[16:17:50.512]                           }
[16:17:50.512]                           else {
[16:17:50.512]                             version <- NULL
[16:17:50.512]                           }
[16:17:50.512]                           if (!has_future || version < "1.8.0") {
[16:17:50.512]                             info <- base::c(r_version = base::gsub("R version ", 
[16:17:50.512]                               "", base::R.version$version.string), 
[16:17:50.512]                               platform = base::sprintf("%s (%s-bit)", 
[16:17:50.512]                                 base::R.version$platform, 8 * 
[16:17:50.512]                                   base::.Machine$sizeof.pointer), 
[16:17:50.512]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:50.512]                                 "release", "version")], collapse = " "), 
[16:17:50.512]                               hostname = base::Sys.info()[["nodename"]])
[16:17:50.512]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:17:50.512]                               info)
[16:17:50.512]                             info <- base::paste(info, collapse = "; ")
[16:17:50.512]                             if (!has_future) {
[16:17:50.512]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:50.512]                                 info)
[16:17:50.512]                             }
[16:17:50.512]                             else {
[16:17:50.512]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:50.512]                                 info, version)
[16:17:50.512]                             }
[16:17:50.512]                             base::stop(msg)
[16:17:50.512]                           }
[16:17:50.512]                         })
[16:17:50.512]                       }
[16:17:50.512]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:50.512]                       base::options(mc.cores = 1L)
[16:17:50.512]                     }
[16:17:50.512]                     base::local({
[16:17:50.512]                       for (pkg in "stats") {
[16:17:50.512]                         base::loadNamespace(pkg)
[16:17:50.512]                         base::library(pkg, character.only = TRUE)
[16:17:50.512]                       }
[16:17:50.512]                     })
[16:17:50.512]                   }
[16:17:50.512]                   ...future.strategy.old <- future::plan("list")
[16:17:50.512]                   options(future.plan = NULL)
[16:17:50.512]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:50.512]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:50.512]                 }
[16:17:50.512]                 ...future.workdir <- getwd()
[16:17:50.512]             }
[16:17:50.512]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:50.512]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:50.512]         }
[16:17:50.512]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:50.512]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:50.512]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:50.512]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:50.512]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:50.512]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:50.512]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:50.512]             base::names(...future.oldOptions))
[16:17:50.512]     }
[16:17:50.512]     if (FALSE) {
[16:17:50.512]     }
[16:17:50.512]     else {
[16:17:50.512]         if (TRUE) {
[16:17:50.512]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:50.512]                 open = "w")
[16:17:50.512]         }
[16:17:50.512]         else {
[16:17:50.512]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:50.512]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:50.512]         }
[16:17:50.512]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:50.512]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:50.512]             base::sink(type = "output", split = FALSE)
[16:17:50.512]             base::close(...future.stdout)
[16:17:50.512]         }, add = TRUE)
[16:17:50.512]     }
[16:17:50.512]     ...future.frame <- base::sys.nframe()
[16:17:50.512]     ...future.conditions <- base::list()
[16:17:50.512]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:50.512]     if (FALSE) {
[16:17:50.512]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:50.512]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:50.512]     }
[16:17:50.512]     ...future.result <- base::tryCatch({
[16:17:50.512]         base::withCallingHandlers({
[16:17:50.512]             ...future.value <- base::withVisible(base::local({
[16:17:50.512]                 withCallingHandlers({
[16:17:50.512]                   {
[16:17:50.512]                     do.call(function(...) {
[16:17:50.512]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.512]                       if (!identical(...future.globals.maxSize.org, 
[16:17:50.512]                         ...future.globals.maxSize)) {
[16:17:50.512]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.512]                         on.exit(options(oopts), add = TRUE)
[16:17:50.512]                       }
[16:17:50.512]                       {
[16:17:50.512]                         lapply(seq_along(...future.elements_ii), 
[16:17:50.512]                           FUN = function(jj) {
[16:17:50.512]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.512]                             ...future.FUN(...future.X_jj, ...)
[16:17:50.512]                           })
[16:17:50.512]                       }
[16:17:50.512]                     }, args = future.call.arguments)
[16:17:50.512]                   }
[16:17:50.512]                 }, immediateCondition = function(cond) {
[16:17:50.512]                   save_rds <- function (object, pathname, ...) 
[16:17:50.512]                   {
[16:17:50.512]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:17:50.512]                     if (file_test("-f", pathname_tmp)) {
[16:17:50.512]                       fi_tmp <- file.info(pathname_tmp)
[16:17:50.512]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:17:50.512]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:50.512]                         fi_tmp[["mtime"]])
[16:17:50.512]                     }
[16:17:50.512]                     tryCatch({
[16:17:50.512]                       saveRDS(object, file = pathname_tmp, ...)
[16:17:50.512]                     }, error = function(ex) {
[16:17:50.512]                       msg <- conditionMessage(ex)
[16:17:50.512]                       fi_tmp <- file.info(pathname_tmp)
[16:17:50.512]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:17:50.512]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:50.512]                         fi_tmp[["mtime"]], msg)
[16:17:50.512]                       ex$message <- msg
[16:17:50.512]                       stop(ex)
[16:17:50.512]                     })
[16:17:50.512]                     stopifnot(file_test("-f", pathname_tmp))
[16:17:50.512]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:17:50.512]                     if (!res || file_test("-f", pathname_tmp)) {
[16:17:50.512]                       fi_tmp <- file.info(pathname_tmp)
[16:17:50.512]                       fi <- file.info(pathname)
[16:17:50.512]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:17:50.512]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:17:50.512]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:17:50.512]                         fi[["size"]], fi[["mtime"]])
[16:17:50.512]                       stop(msg)
[16:17:50.512]                     }
[16:17:50.512]                     invisible(pathname)
[16:17:50.512]                   }
[16:17:50.512]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:17:50.512]                     rootPath = tempdir()) 
[16:17:50.512]                   {
[16:17:50.512]                     obj <- list(time = Sys.time(), condition = cond)
[16:17:50.512]                     file <- tempfile(pattern = class(cond)[1], 
[16:17:50.512]                       tmpdir = path, fileext = ".rds")
[16:17:50.512]                     save_rds(obj, file)
[16:17:50.512]                   }
[16:17:50.512]                   saveImmediateCondition(cond, path = "/tmp/Rtmpstkvtd/.future/immediateConditions")
[16:17:50.512]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.512]                   {
[16:17:50.512]                     inherits <- base::inherits
[16:17:50.512]                     invokeRestart <- base::invokeRestart
[16:17:50.512]                     is.null <- base::is.null
[16:17:50.512]                     muffled <- FALSE
[16:17:50.512]                     if (inherits(cond, "message")) {
[16:17:50.512]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:50.512]                       if (muffled) 
[16:17:50.512]                         invokeRestart("muffleMessage")
[16:17:50.512]                     }
[16:17:50.512]                     else if (inherits(cond, "warning")) {
[16:17:50.512]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:50.512]                       if (muffled) 
[16:17:50.512]                         invokeRestart("muffleWarning")
[16:17:50.512]                     }
[16:17:50.512]                     else if (inherits(cond, "condition")) {
[16:17:50.512]                       if (!is.null(pattern)) {
[16:17:50.512]                         computeRestarts <- base::computeRestarts
[16:17:50.512]                         grepl <- base::grepl
[16:17:50.512]                         restarts <- computeRestarts(cond)
[16:17:50.512]                         for (restart in restarts) {
[16:17:50.512]                           name <- restart$name
[16:17:50.512]                           if (is.null(name)) 
[16:17:50.512]                             next
[16:17:50.512]                           if (!grepl(pattern, name)) 
[16:17:50.512]                             next
[16:17:50.512]                           invokeRestart(restart)
[16:17:50.512]                           muffled <- TRUE
[16:17:50.512]                           break
[16:17:50.512]                         }
[16:17:50.512]                       }
[16:17:50.512]                     }
[16:17:50.512]                     invisible(muffled)
[16:17:50.512]                   }
[16:17:50.512]                   muffleCondition(cond)
[16:17:50.512]                 })
[16:17:50.512]             }))
[16:17:50.512]             future::FutureResult(value = ...future.value$value, 
[16:17:50.512]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:50.512]                   ...future.rng), globalenv = if (FALSE) 
[16:17:50.512]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:50.512]                     ...future.globalenv.names))
[16:17:50.512]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:50.512]         }, condition = base::local({
[16:17:50.512]             c <- base::c
[16:17:50.512]             inherits <- base::inherits
[16:17:50.512]             invokeRestart <- base::invokeRestart
[16:17:50.512]             length <- base::length
[16:17:50.512]             list <- base::list
[16:17:50.512]             seq.int <- base::seq.int
[16:17:50.512]             signalCondition <- base::signalCondition
[16:17:50.512]             sys.calls <- base::sys.calls
[16:17:50.512]             `[[` <- base::`[[`
[16:17:50.512]             `+` <- base::`+`
[16:17:50.512]             `<<-` <- base::`<<-`
[16:17:50.512]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:50.512]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:50.512]                   3L)]
[16:17:50.512]             }
[16:17:50.512]             function(cond) {
[16:17:50.512]                 is_error <- inherits(cond, "error")
[16:17:50.512]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:50.512]                   NULL)
[16:17:50.512]                 if (is_error) {
[16:17:50.512]                   sessionInformation <- function() {
[16:17:50.512]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:50.512]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:50.512]                       search = base::search(), system = base::Sys.info())
[16:17:50.512]                   }
[16:17:50.512]                   ...future.conditions[[length(...future.conditions) + 
[16:17:50.512]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:50.512]                     cond$call), session = sessionInformation(), 
[16:17:50.512]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:50.512]                   signalCondition(cond)
[16:17:50.512]                 }
[16:17:50.512]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:50.512]                 "immediateCondition"))) {
[16:17:50.512]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:50.512]                   ...future.conditions[[length(...future.conditions) + 
[16:17:50.512]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:50.512]                   if (TRUE && !signal) {
[16:17:50.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.512]                     {
[16:17:50.512]                       inherits <- base::inherits
[16:17:50.512]                       invokeRestart <- base::invokeRestart
[16:17:50.512]                       is.null <- base::is.null
[16:17:50.512]                       muffled <- FALSE
[16:17:50.512]                       if (inherits(cond, "message")) {
[16:17:50.512]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:50.512]                         if (muffled) 
[16:17:50.512]                           invokeRestart("muffleMessage")
[16:17:50.512]                       }
[16:17:50.512]                       else if (inherits(cond, "warning")) {
[16:17:50.512]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:50.512]                         if (muffled) 
[16:17:50.512]                           invokeRestart("muffleWarning")
[16:17:50.512]                       }
[16:17:50.512]                       else if (inherits(cond, "condition")) {
[16:17:50.512]                         if (!is.null(pattern)) {
[16:17:50.512]                           computeRestarts <- base::computeRestarts
[16:17:50.512]                           grepl <- base::grepl
[16:17:50.512]                           restarts <- computeRestarts(cond)
[16:17:50.512]                           for (restart in restarts) {
[16:17:50.512]                             name <- restart$name
[16:17:50.512]                             if (is.null(name)) 
[16:17:50.512]                               next
[16:17:50.512]                             if (!grepl(pattern, name)) 
[16:17:50.512]                               next
[16:17:50.512]                             invokeRestart(restart)
[16:17:50.512]                             muffled <- TRUE
[16:17:50.512]                             break
[16:17:50.512]                           }
[16:17:50.512]                         }
[16:17:50.512]                       }
[16:17:50.512]                       invisible(muffled)
[16:17:50.512]                     }
[16:17:50.512]                     muffleCondition(cond, pattern = "^muffle")
[16:17:50.512]                   }
[16:17:50.512]                 }
[16:17:50.512]                 else {
[16:17:50.512]                   if (TRUE) {
[16:17:50.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:50.512]                     {
[16:17:50.512]                       inherits <- base::inherits
[16:17:50.512]                       invokeRestart <- base::invokeRestart
[16:17:50.512]                       is.null <- base::is.null
[16:17:50.512]                       muffled <- FALSE
[16:17:50.512]                       if (inherits(cond, "message")) {
[16:17:50.512]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:50.512]                         if (muffled) 
[16:17:50.512]                           invokeRestart("muffleMessage")
[16:17:50.512]                       }
[16:17:50.512]                       else if (inherits(cond, "warning")) {
[16:17:50.512]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:50.512]                         if (muffled) 
[16:17:50.512]                           invokeRestart("muffleWarning")
[16:17:50.512]                       }
[16:17:50.512]                       else if (inherits(cond, "condition")) {
[16:17:50.512]                         if (!is.null(pattern)) {
[16:17:50.512]                           computeRestarts <- base::computeRestarts
[16:17:50.512]                           grepl <- base::grepl
[16:17:50.512]                           restarts <- computeRestarts(cond)
[16:17:50.512]                           for (restart in restarts) {
[16:17:50.512]                             name <- restart$name
[16:17:50.512]                             if (is.null(name)) 
[16:17:50.512]                               next
[16:17:50.512]                             if (!grepl(pattern, name)) 
[16:17:50.512]                               next
[16:17:50.512]                             invokeRestart(restart)
[16:17:50.512]                             muffled <- TRUE
[16:17:50.512]                             break
[16:17:50.512]                           }
[16:17:50.512]                         }
[16:17:50.512]                       }
[16:17:50.512]                       invisible(muffled)
[16:17:50.512]                     }
[16:17:50.512]                     muffleCondition(cond, pattern = "^muffle")
[16:17:50.512]                   }
[16:17:50.512]                 }
[16:17:50.512]             }
[16:17:50.512]         }))
[16:17:50.512]     }, error = function(ex) {
[16:17:50.512]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:50.512]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:50.512]                 ...future.rng), started = ...future.startTime, 
[16:17:50.512]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:50.512]             version = "1.8"), class = "FutureResult")
[16:17:50.512]     }, finally = {
[16:17:50.512]         if (!identical(...future.workdir, getwd())) 
[16:17:50.512]             setwd(...future.workdir)
[16:17:50.512]         {
[16:17:50.512]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:50.512]                 ...future.oldOptions$nwarnings <- NULL
[16:17:50.512]             }
[16:17:50.512]             base::options(...future.oldOptions)
[16:17:50.512]             if (.Platform$OS.type == "windows") {
[16:17:50.512]                 old_names <- names(...future.oldEnvVars)
[16:17:50.512]                 envs <- base::Sys.getenv()
[16:17:50.512]                 names <- names(envs)
[16:17:50.512]                 common <- intersect(names, old_names)
[16:17:50.512]                 added <- setdiff(names, old_names)
[16:17:50.512]                 removed <- setdiff(old_names, names)
[16:17:50.512]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:50.512]                   envs[common]]
[16:17:50.512]                 NAMES <- toupper(changed)
[16:17:50.512]                 args <- list()
[16:17:50.512]                 for (kk in seq_along(NAMES)) {
[16:17:50.512]                   name <- changed[[kk]]
[16:17:50.512]                   NAME <- NAMES[[kk]]
[16:17:50.512]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.512]                     next
[16:17:50.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:50.512]                 }
[16:17:50.512]                 NAMES <- toupper(added)
[16:17:50.512]                 for (kk in seq_along(NAMES)) {
[16:17:50.512]                   name <- added[[kk]]
[16:17:50.512]                   NAME <- NAMES[[kk]]
[16:17:50.512]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.512]                     next
[16:17:50.512]                   args[[name]] <- ""
[16:17:50.512]                 }
[16:17:50.512]                 NAMES <- toupper(removed)
[16:17:50.512]                 for (kk in seq_along(NAMES)) {
[16:17:50.512]                   name <- removed[[kk]]
[16:17:50.512]                   NAME <- NAMES[[kk]]
[16:17:50.512]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:50.512]                     next
[16:17:50.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:50.512]                 }
[16:17:50.512]                 if (length(args) > 0) 
[16:17:50.512]                   base::do.call(base::Sys.setenv, args = args)
[16:17:50.512]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:50.512]             }
[16:17:50.512]             else {
[16:17:50.512]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:50.512]             }
[16:17:50.512]             {
[16:17:50.512]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:50.512]                   0L) {
[16:17:50.512]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:50.512]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:50.512]                   base::options(opts)
[16:17:50.512]                 }
[16:17:50.512]                 {
[16:17:50.512]                   {
[16:17:50.512]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:50.512]                     NULL
[16:17:50.512]                   }
[16:17:50.512]                   options(future.plan = NULL)
[16:17:50.512]                   if (is.na(NA_character_)) 
[16:17:50.512]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:50.512]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:50.512]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:50.512]                     .init = FALSE)
[16:17:50.512]                 }
[16:17:50.512]             }
[16:17:50.512]         }
[16:17:50.512]     })
[16:17:50.512]     if (TRUE) {
[16:17:50.512]         base::sink(type = "output", split = FALSE)
[16:17:50.512]         if (TRUE) {
[16:17:50.512]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:50.512]         }
[16:17:50.512]         else {
[16:17:50.512]             ...future.result["stdout"] <- base::list(NULL)
[16:17:50.512]         }
[16:17:50.512]         base::close(...future.stdout)
[16:17:50.512]         ...future.stdout <- NULL
[16:17:50.512]     }
[16:17:50.512]     ...future.result$conditions <- ...future.conditions
[16:17:50.512]     ...future.result$finished <- base::Sys.time()
[16:17:50.512]     ...future.result
[16:17:50.512] }
[16:17:50.515] assign_globals() ...
[16:17:50.515] List of 5
[16:17:50.515]  $ ...future.FUN            :function (x, ...)  
[16:17:50.515]  $ future.call.arguments    : list()
[16:17:50.515]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:50.515]  $ ...future.elements_ii    :List of 2
[16:17:50.515]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[16:17:50.515]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[16:17:50.515]  $ ...future.seeds_ii       : NULL
[16:17:50.515]  $ ...future.globals.maxSize: NULL
[16:17:50.515]  - attr(*, "where")=List of 5
[16:17:50.515]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:17:50.515]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:17:50.515]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:17:50.515]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:17:50.515]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:17:50.515]  - attr(*, "resolved")= logi FALSE
[16:17:50.515]  - attr(*, "total_size")= num 1248
[16:17:50.515]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:50.515]  - attr(*, "already-done")= logi TRUE
[16:17:50.523] - copied ‘...future.FUN’ to environment
[16:17:50.523] - copied ‘future.call.arguments’ to environment
[16:17:50.523] - copied ‘...future.elements_ii’ to environment
[16:17:50.524] - copied ‘...future.seeds_ii’ to environment
[16:17:50.524] - copied ‘...future.globals.maxSize’ to environment
[16:17:50.524] assign_globals() ... done
[16:17:50.524] requestCore(): workers = 2
[16:17:50.526] MulticoreFuture started
[16:17:50.527] - Launch lazy future ... done
[16:17:50.527] run() for ‘MulticoreFuture’ ... done
[16:17:50.527] Created future:
[16:17:50.528] plan(): Setting new future strategy stack:
[16:17:50.528] List of future strategies:
[16:17:50.528] 1. sequential:
[16:17:50.528]    - args: function (..., envir = parent.frame())
[16:17:50.528]    - tweaked: FALSE
[16:17:50.528]    - call: NULL
[16:17:50.529] plan(): nbrOfWorkers() = 1
[16:17:50.532] plan(): Setting new future strategy stack:
[16:17:50.532] List of future strategies:
[16:17:50.532] 1. multicore:
[16:17:50.532]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:17:50.532]    - tweaked: FALSE
[16:17:50.532]    - call: plan(strategy)
[16:17:50.537] plan(): nbrOfWorkers() = 2
[16:17:50.527] MulticoreFuture:
[16:17:50.527] Label: ‘future_eapply-2’
[16:17:50.527] Expression:
[16:17:50.527] {
[16:17:50.527]     do.call(function(...) {
[16:17:50.527]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:50.527]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:50.527]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:50.527]             on.exit(options(oopts), add = TRUE)
[16:17:50.527]         }
[16:17:50.527]         {
[16:17:50.527]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:50.527]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:50.527]                 ...future.FUN(...future.X_jj, ...)
[16:17:50.527]             })
[16:17:50.527]         }
[16:17:50.527]     }, args = future.call.arguments)
[16:17:50.527] }
[16:17:50.527] Lazy evaluation: FALSE
[16:17:50.527] Asynchronous evaluation: TRUE
[16:17:50.527] Local evaluation: TRUE
[16:17:50.527] Environment: R_GlobalEnv
[16:17:50.527] Capture standard output: TRUE
[16:17:50.527] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:50.527] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:50.527] Packages: 1 packages (‘stats’)
[16:17:50.527] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:50.527] Resolved: TRUE
[16:17:50.527] Value: <not collected>
[16:17:50.527] Conditions captured: <none>
[16:17:50.527] Early signaling: FALSE
[16:17:50.527] Owner process: 95d59565-e757-824f-7f5c-7f754384cffc
[16:17:50.527] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:50.538] Chunk #2 of 2 ... DONE
[16:17:50.538] Launching 2 futures (chunks) ... DONE
[16:17:50.538] Resolving 2 futures (chunks) ...
[16:17:50.538] resolve() on list ...
[16:17:50.539]  recursive: 0
[16:17:50.539]  length: 2
[16:17:50.539] 
[16:17:50.539] Future #1
[16:17:50.540] result() for MulticoreFuture ...
[16:17:50.540] result() for MulticoreFuture ...
[16:17:50.541] result() for MulticoreFuture ... done
[16:17:50.541] result() for MulticoreFuture ... done
[16:17:50.541] result() for MulticoreFuture ...
[16:17:50.541] result() for MulticoreFuture ... done
[16:17:50.541] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:17:50.541] - nx: 2
[16:17:50.542] - relay: TRUE
[16:17:50.542] - stdout: TRUE
[16:17:50.542] - signal: TRUE
[16:17:50.542] - resignal: FALSE
[16:17:50.542] - force: TRUE
[16:17:50.542] - relayed: [n=2] FALSE, FALSE
[16:17:50.542] - queued futures: [n=2] FALSE, FALSE
[16:17:50.542]  - until=1
[16:17:50.543]  - relaying element #1
[16:17:50.543] result() for MulticoreFuture ...
[16:17:50.543] result() for MulticoreFuture ... done
[16:17:50.543] result() for MulticoreFuture ...
[16:17:50.543] result() for MulticoreFuture ... done
[16:17:50.543] result() for MulticoreFuture ...
[16:17:50.544] result() for MulticoreFuture ... done
[16:17:50.544] result() for MulticoreFuture ...
[16:17:50.544] result() for MulticoreFuture ... done
[16:17:50.544] - relayed: [n=2] TRUE, FALSE
[16:17:50.544] - queued futures: [n=2] TRUE, FALSE
[16:17:50.544] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:17:50.544]  length: 1 (resolved future 1)
[16:17:50.545] Future #2
[16:17:50.545] result() for MulticoreFuture ...
[16:17:50.546] result() for MulticoreFuture ...
[16:17:50.546] result() for MulticoreFuture ... done
[16:17:50.546] result() for MulticoreFuture ... done
[16:17:50.546] result() for MulticoreFuture ...
[16:17:50.546] result() for MulticoreFuture ... done
[16:17:50.546] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:17:50.546] - nx: 2
[16:17:50.546] - relay: TRUE
[16:17:50.547] - stdout: TRUE
[16:17:50.547] - signal: TRUE
[16:17:50.547] - resignal: FALSE
[16:17:50.547] - force: TRUE
[16:17:50.547] - relayed: [n=2] TRUE, FALSE
[16:17:50.547] - queued futures: [n=2] TRUE, FALSE
[16:17:50.547]  - until=2
[16:17:50.548]  - relaying element #2
[16:17:50.548] result() for MulticoreFuture ...
[16:17:50.548] result() for MulticoreFuture ... done
[16:17:50.548] result() for MulticoreFuture ...
[16:17:50.548] result() for MulticoreFuture ... done
[16:17:50.551] result() for MulticoreFuture ...
[16:17:50.551] result() for MulticoreFuture ... done
[16:17:50.551] result() for MulticoreFuture ...
[16:17:50.551] result() for MulticoreFuture ... done
[16:17:50.551] - relayed: [n=2] TRUE, TRUE
[16:17:50.551] - queued futures: [n=2] TRUE, TRUE
[16:17:50.552] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:17:50.552]  length: 0 (resolved future 2)
[16:17:50.552] Relaying remaining futures
[16:17:50.552] signalConditionsASAP(NULL, pos=0) ...
[16:17:50.552] - nx: 2
[16:17:50.552] - relay: TRUE
[16:17:50.553] - stdout: TRUE
[16:17:50.553] - signal: TRUE
[16:17:50.553] - resignal: FALSE
[16:17:50.553] - force: TRUE
[16:17:50.553] - relayed: [n=2] TRUE, TRUE
[16:17:50.553] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:50.553] - relayed: [n=2] TRUE, TRUE
[16:17:50.554] - queued futures: [n=2] TRUE, TRUE
[16:17:50.554] signalConditionsASAP(NULL, pos=0) ... done
[16:17:50.554] resolve() on list ... DONE
[16:17:50.554] result() for MulticoreFuture ...
[16:17:50.554] result() for MulticoreFuture ... done
[16:17:50.554] result() for MulticoreFuture ...
[16:17:50.554] result() for MulticoreFuture ... done
[16:17:50.554] result() for MulticoreFuture ...
[16:17:50.555] result() for MulticoreFuture ... done
[16:17:50.555] result() for MulticoreFuture ...
[16:17:50.555] result() for MulticoreFuture ... done
[16:17:50.555]  - Number of value chunks collected: 2
[16:17:50.555] Resolving 2 futures (chunks) ... DONE
[16:17:50.555] Reducing values from 2 chunks ...
[16:17:50.555]  - Number of values collected after concatenation: 3
[16:17:50.555]  - Number of values expected: 3
[16:17:50.556] Reducing values from 2 chunks ... DONE
[16:17:50.556] future_lapply() ... DONE
[16:17:50.556] plan(): Setting new future strategy stack:
[16:17:50.556] List of future strategies:
[16:17:50.556] 1. sequential:
[16:17:50.556]    - args: function (..., envir = parent.frame())
[16:17:50.556]    - tweaked: FALSE
[16:17:50.556]    - call: plan(sequential)
[16:17:50.557] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[16:17:50.557] plan(): Setting new future strategy stack:
[16:17:50.558] List of future strategies:
[16:17:50.558] 1. multisession:
[16:17:50.558]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:17:50.558]    - tweaked: FALSE
[16:17:50.558]    - call: plan(strategy)
[16:17:50.558] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:17:50.558] multisession:
[16:17:50.558] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:17:50.558] - tweaked: FALSE
[16:17:50.558] - call: plan(strategy)
[16:17:50.565] getGlobalsAndPackages() ...
[16:17:50.565] Not searching for globals
[16:17:50.565] - globals: [0] <none>
[16:17:50.565] getGlobalsAndPackages() ... DONE
[16:17:50.566] [local output] makeClusterPSOCK() ...
[16:17:50.609] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:17:50.611] [local output] Base port: 11802
[16:17:50.611] [local output] Getting setup options for 2 cluster nodes ...
[16:17:50.611] [local output]  - Node 1 of 2 ...
[16:17:50.611] [local output] localMachine=TRUE => revtunnel=FALSE

[16:17:50.612] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpstkvtd/worker.rank=1.parallelly.parent=68489.10b897290abb0.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmpstkvtd/worker.rank=1.parallelly.parent=68489.10b897290abb0.pid")'’
[16:17:50.800] - Possible to infer worker's PID: TRUE
[16:17:50.801] [local output] Rscript port: 11802

[16:17:50.801] [local output]  - Node 2 of 2 ...
[16:17:50.801] [local output] localMachine=TRUE => revtunnel=FALSE

[16:17:50.802] [local output] Rscript port: 11802

[16:17:50.802] [local output] Getting setup options for 2 cluster nodes ... done
[16:17:50.802] [local output]  - Parallel setup requested for some PSOCK nodes
[16:17:50.803] [local output] Setting up PSOCK nodes in parallel
[16:17:50.803] List of 36
[16:17:50.803]  $ worker          : chr "localhost"
[16:17:50.803]   ..- attr(*, "localhost")= logi TRUE
[16:17:50.803]  $ master          : chr "localhost"
[16:17:50.803]  $ port            : int 11802
[16:17:50.803]  $ connectTimeout  : num 120
[16:17:50.803]  $ timeout         : num 2592000
[16:17:50.803]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:17:50.803]  $ homogeneous     : logi TRUE
[16:17:50.803]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:17:50.803]  $ rscript_envs    : NULL
[16:17:50.803]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:17:50.803]  $ rscript_startup : NULL
[16:17:50.803]  $ rscript_sh      : chr "sh"
[16:17:50.803]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:17:50.803]  $ methods         : logi TRUE
[16:17:50.803]  $ socketOptions   : chr "no-delay"
[16:17:50.803]  $ useXDR          : logi FALSE
[16:17:50.803]  $ outfile         : chr "/dev/null"
[16:17:50.803]  $ renice          : int NA
[16:17:50.803]  $ rshcmd          : NULL
[16:17:50.803]  $ user            : chr(0) 
[16:17:50.803]  $ revtunnel       : logi FALSE
[16:17:50.803]  $ rshlogfile      : NULL
[16:17:50.803]  $ rshopts         : chr(0) 
[16:17:50.803]  $ rank            : int 1
[16:17:50.803]  $ manual          : logi FALSE
[16:17:50.803]  $ dryrun          : logi FALSE
[16:17:50.803]  $ quiet           : logi FALSE
[16:17:50.803]  $ setup_strategy  : chr "parallel"
[16:17:50.803]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:17:50.803]  $ pidfile         : chr "/tmp/Rtmpstkvtd/worker.rank=1.parallelly.parent=68489.10b897290abb0.pid"
[16:17:50.803]  $ rshcmd_label    : NULL
[16:17:50.803]  $ rsh_call        : NULL
[16:17:50.803]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:17:50.803]  $ localMachine    : logi TRUE
[16:17:50.803]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:17:50.803]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:17:50.803]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:17:50.803]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:17:50.803]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:17:50.803]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:17:50.803]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:17:50.803]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:17:50.803]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:17:50.803]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:17:50.803]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:17:50.803]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:17:50.803]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:17:50.803]  $ arguments       :List of 28
[16:17:50.803]   ..$ worker          : chr "localhost"
[16:17:50.803]   ..$ master          : NULL
[16:17:50.803]   ..$ port            : int 11802
[16:17:50.803]   ..$ connectTimeout  : num 120
[16:17:50.803]   ..$ timeout         : num 2592000
[16:17:50.803]   ..$ rscript         : NULL
[16:17:50.803]   ..$ homogeneous     : NULL
[16:17:50.803]   ..$ rscript_args    : NULL
[16:17:50.803]   ..$ rscript_envs    : NULL
[16:17:50.803]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:17:50.803]   ..$ rscript_startup : NULL
[16:17:50.803]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:17:50.803]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:17:50.803]   ..$ methods         : logi TRUE
[16:17:50.803]   ..$ socketOptions   : chr "no-delay"
[16:17:50.803]   ..$ useXDR          : logi FALSE
[16:17:50.803]   ..$ outfile         : chr "/dev/null"
[16:17:50.803]   ..$ renice          : int NA
[16:17:50.803]   ..$ rshcmd          : NULL
[16:17:50.803]   ..$ user            : NULL
[16:17:50.803]   ..$ revtunnel       : logi NA
[16:17:50.803]   ..$ rshlogfile      : NULL
[16:17:50.803]   ..$ rshopts         : NULL
[16:17:50.803]   ..$ rank            : int 1
[16:17:50.803]   ..$ manual          : logi FALSE
[16:17:50.803]   ..$ dryrun          : logi FALSE
[16:17:50.803]   ..$ quiet           : logi FALSE
[16:17:50.803]   ..$ setup_strategy  : chr "parallel"
[16:17:50.803]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:17:50.820] [local output] System call to launch all workers:
[16:17:50.820] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpstkvtd/worker.rank=1.parallelly.parent=68489.10b897290abb0.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11802 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:17:50.820] [local output] Starting PSOCK main server
[16:17:50.826] [local output] Workers launched
[16:17:50.826] [local output] Waiting for workers to connect back
[16:17:50.826]  - [local output] 0 workers out of 2 ready
[16:17:51.076]  - [local output] 0 workers out of 2 ready
[16:17:51.077]  - [local output] 1 workers out of 2 ready
[16:17:51.077]  - [local output] 2 workers out of 2 ready
[16:17:51.077] [local output] Launching of workers completed
[16:17:51.078] [local output] Collecting session information from workers
[16:17:51.078] [local output]  - Worker #1 of 2
[16:17:51.079] [local output]  - Worker #2 of 2
[16:17:51.079] [local output] makeClusterPSOCK() ... done
[16:17:51.091] Packages needed by the future expression (n = 0): <none>
[16:17:51.091] Packages needed by future strategies (n = 0): <none>
[16:17:51.091] {
[16:17:51.091]     {
[16:17:51.091]         {
[16:17:51.091]             ...future.startTime <- base::Sys.time()
[16:17:51.091]             {
[16:17:51.091]                 {
[16:17:51.091]                   {
[16:17:51.091]                     {
[16:17:51.091]                       base::local({
[16:17:51.091]                         has_future <- base::requireNamespace("future", 
[16:17:51.091]                           quietly = TRUE)
[16:17:51.091]                         if (has_future) {
[16:17:51.091]                           ns <- base::getNamespace("future")
[16:17:51.091]                           version <- ns[[".package"]][["version"]]
[16:17:51.091]                           if (is.null(version)) 
[16:17:51.091]                             version <- utils::packageVersion("future")
[16:17:51.091]                         }
[16:17:51.091]                         else {
[16:17:51.091]                           version <- NULL
[16:17:51.091]                         }
[16:17:51.091]                         if (!has_future || version < "1.8.0") {
[16:17:51.091]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:51.091]                             "", base::R.version$version.string), 
[16:17:51.091]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:51.091]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:51.091]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:51.091]                               "release", "version")], collapse = " "), 
[16:17:51.091]                             hostname = base::Sys.info()[["nodename"]])
[16:17:51.091]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:51.091]                             info)
[16:17:51.091]                           info <- base::paste(info, collapse = "; ")
[16:17:51.091]                           if (!has_future) {
[16:17:51.091]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:51.091]                               info)
[16:17:51.091]                           }
[16:17:51.091]                           else {
[16:17:51.091]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:51.091]                               info, version)
[16:17:51.091]                           }
[16:17:51.091]                           base::stop(msg)
[16:17:51.091]                         }
[16:17:51.091]                       })
[16:17:51.091]                     }
[16:17:51.091]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:51.091]                     base::options(mc.cores = 1L)
[16:17:51.091]                   }
[16:17:51.091]                   ...future.strategy.old <- future::plan("list")
[16:17:51.091]                   options(future.plan = NULL)
[16:17:51.091]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:51.091]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:51.091]                 }
[16:17:51.091]                 ...future.workdir <- getwd()
[16:17:51.091]             }
[16:17:51.091]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:51.091]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:51.091]         }
[16:17:51.091]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:51.091]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:17:51.091]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:51.091]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:51.091]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:51.091]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:51.091]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:51.091]             base::names(...future.oldOptions))
[16:17:51.091]     }
[16:17:51.091]     if (FALSE) {
[16:17:51.091]     }
[16:17:51.091]     else {
[16:17:51.091]         if (TRUE) {
[16:17:51.091]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:51.091]                 open = "w")
[16:17:51.091]         }
[16:17:51.091]         else {
[16:17:51.091]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:51.091]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:51.091]         }
[16:17:51.091]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:51.091]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:51.091]             base::sink(type = "output", split = FALSE)
[16:17:51.091]             base::close(...future.stdout)
[16:17:51.091]         }, add = TRUE)
[16:17:51.091]     }
[16:17:51.091]     ...future.frame <- base::sys.nframe()
[16:17:51.091]     ...future.conditions <- base::list()
[16:17:51.091]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:51.091]     if (FALSE) {
[16:17:51.091]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:51.091]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:51.091]     }
[16:17:51.091]     ...future.result <- base::tryCatch({
[16:17:51.091]         base::withCallingHandlers({
[16:17:51.091]             ...future.value <- base::withVisible(base::local({
[16:17:51.091]                 ...future.makeSendCondition <- base::local({
[16:17:51.091]                   sendCondition <- NULL
[16:17:51.091]                   function(frame = 1L) {
[16:17:51.091]                     if (is.function(sendCondition)) 
[16:17:51.091]                       return(sendCondition)
[16:17:51.091]                     ns <- getNamespace("parallel")
[16:17:51.091]                     if (exists("sendData", mode = "function", 
[16:17:51.091]                       envir = ns)) {
[16:17:51.091]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:51.091]                         envir = ns)
[16:17:51.091]                       envir <- sys.frame(frame)
[16:17:51.091]                       master <- NULL
[16:17:51.091]                       while (!identical(envir, .GlobalEnv) && 
[16:17:51.091]                         !identical(envir, emptyenv())) {
[16:17:51.091]                         if (exists("master", mode = "list", envir = envir, 
[16:17:51.091]                           inherits = FALSE)) {
[16:17:51.091]                           master <- get("master", mode = "list", 
[16:17:51.091]                             envir = envir, inherits = FALSE)
[16:17:51.091]                           if (inherits(master, c("SOCKnode", 
[16:17:51.091]                             "SOCK0node"))) {
[16:17:51.091]                             sendCondition <<- function(cond) {
[16:17:51.091]                               data <- list(type = "VALUE", value = cond, 
[16:17:51.091]                                 success = TRUE)
[16:17:51.091]                               parallel_sendData(master, data)
[16:17:51.091]                             }
[16:17:51.091]                             return(sendCondition)
[16:17:51.091]                           }
[16:17:51.091]                         }
[16:17:51.091]                         frame <- frame + 1L
[16:17:51.091]                         envir <- sys.frame(frame)
[16:17:51.091]                       }
[16:17:51.091]                     }
[16:17:51.091]                     sendCondition <<- function(cond) NULL
[16:17:51.091]                   }
[16:17:51.091]                 })
[16:17:51.091]                 withCallingHandlers({
[16:17:51.091]                   NA
[16:17:51.091]                 }, immediateCondition = function(cond) {
[16:17:51.091]                   sendCondition <- ...future.makeSendCondition()
[16:17:51.091]                   sendCondition(cond)
[16:17:51.091]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.091]                   {
[16:17:51.091]                     inherits <- base::inherits
[16:17:51.091]                     invokeRestart <- base::invokeRestart
[16:17:51.091]                     is.null <- base::is.null
[16:17:51.091]                     muffled <- FALSE
[16:17:51.091]                     if (inherits(cond, "message")) {
[16:17:51.091]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:51.091]                       if (muffled) 
[16:17:51.091]                         invokeRestart("muffleMessage")
[16:17:51.091]                     }
[16:17:51.091]                     else if (inherits(cond, "warning")) {
[16:17:51.091]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:51.091]                       if (muffled) 
[16:17:51.091]                         invokeRestart("muffleWarning")
[16:17:51.091]                     }
[16:17:51.091]                     else if (inherits(cond, "condition")) {
[16:17:51.091]                       if (!is.null(pattern)) {
[16:17:51.091]                         computeRestarts <- base::computeRestarts
[16:17:51.091]                         grepl <- base::grepl
[16:17:51.091]                         restarts <- computeRestarts(cond)
[16:17:51.091]                         for (restart in restarts) {
[16:17:51.091]                           name <- restart$name
[16:17:51.091]                           if (is.null(name)) 
[16:17:51.091]                             next
[16:17:51.091]                           if (!grepl(pattern, name)) 
[16:17:51.091]                             next
[16:17:51.091]                           invokeRestart(restart)
[16:17:51.091]                           muffled <- TRUE
[16:17:51.091]                           break
[16:17:51.091]                         }
[16:17:51.091]                       }
[16:17:51.091]                     }
[16:17:51.091]                     invisible(muffled)
[16:17:51.091]                   }
[16:17:51.091]                   muffleCondition(cond)
[16:17:51.091]                 })
[16:17:51.091]             }))
[16:17:51.091]             future::FutureResult(value = ...future.value$value, 
[16:17:51.091]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:51.091]                   ...future.rng), globalenv = if (FALSE) 
[16:17:51.091]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:51.091]                     ...future.globalenv.names))
[16:17:51.091]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:51.091]         }, condition = base::local({
[16:17:51.091]             c <- base::c
[16:17:51.091]             inherits <- base::inherits
[16:17:51.091]             invokeRestart <- base::invokeRestart
[16:17:51.091]             length <- base::length
[16:17:51.091]             list <- base::list
[16:17:51.091]             seq.int <- base::seq.int
[16:17:51.091]             signalCondition <- base::signalCondition
[16:17:51.091]             sys.calls <- base::sys.calls
[16:17:51.091]             `[[` <- base::`[[`
[16:17:51.091]             `+` <- base::`+`
[16:17:51.091]             `<<-` <- base::`<<-`
[16:17:51.091]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:51.091]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:51.091]                   3L)]
[16:17:51.091]             }
[16:17:51.091]             function(cond) {
[16:17:51.091]                 is_error <- inherits(cond, "error")
[16:17:51.091]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:51.091]                   NULL)
[16:17:51.091]                 if (is_error) {
[16:17:51.091]                   sessionInformation <- function() {
[16:17:51.091]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:51.091]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:51.091]                       search = base::search(), system = base::Sys.info())
[16:17:51.091]                   }
[16:17:51.091]                   ...future.conditions[[length(...future.conditions) + 
[16:17:51.091]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:51.091]                     cond$call), session = sessionInformation(), 
[16:17:51.091]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:51.091]                   signalCondition(cond)
[16:17:51.091]                 }
[16:17:51.091]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:51.091]                 "immediateCondition"))) {
[16:17:51.091]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:51.091]                   ...future.conditions[[length(...future.conditions) + 
[16:17:51.091]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:51.091]                   if (TRUE && !signal) {
[16:17:51.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.091]                     {
[16:17:51.091]                       inherits <- base::inherits
[16:17:51.091]                       invokeRestart <- base::invokeRestart
[16:17:51.091]                       is.null <- base::is.null
[16:17:51.091]                       muffled <- FALSE
[16:17:51.091]                       if (inherits(cond, "message")) {
[16:17:51.091]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:51.091]                         if (muffled) 
[16:17:51.091]                           invokeRestart("muffleMessage")
[16:17:51.091]                       }
[16:17:51.091]                       else if (inherits(cond, "warning")) {
[16:17:51.091]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:51.091]                         if (muffled) 
[16:17:51.091]                           invokeRestart("muffleWarning")
[16:17:51.091]                       }
[16:17:51.091]                       else if (inherits(cond, "condition")) {
[16:17:51.091]                         if (!is.null(pattern)) {
[16:17:51.091]                           computeRestarts <- base::computeRestarts
[16:17:51.091]                           grepl <- base::grepl
[16:17:51.091]                           restarts <- computeRestarts(cond)
[16:17:51.091]                           for (restart in restarts) {
[16:17:51.091]                             name <- restart$name
[16:17:51.091]                             if (is.null(name)) 
[16:17:51.091]                               next
[16:17:51.091]                             if (!grepl(pattern, name)) 
[16:17:51.091]                               next
[16:17:51.091]                             invokeRestart(restart)
[16:17:51.091]                             muffled <- TRUE
[16:17:51.091]                             break
[16:17:51.091]                           }
[16:17:51.091]                         }
[16:17:51.091]                       }
[16:17:51.091]                       invisible(muffled)
[16:17:51.091]                     }
[16:17:51.091]                     muffleCondition(cond, pattern = "^muffle")
[16:17:51.091]                   }
[16:17:51.091]                 }
[16:17:51.091]                 else {
[16:17:51.091]                   if (TRUE) {
[16:17:51.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.091]                     {
[16:17:51.091]                       inherits <- base::inherits
[16:17:51.091]                       invokeRestart <- base::invokeRestart
[16:17:51.091]                       is.null <- base::is.null
[16:17:51.091]                       muffled <- FALSE
[16:17:51.091]                       if (inherits(cond, "message")) {
[16:17:51.091]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:51.091]                         if (muffled) 
[16:17:51.091]                           invokeRestart("muffleMessage")
[16:17:51.091]                       }
[16:17:51.091]                       else if (inherits(cond, "warning")) {
[16:17:51.091]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:51.091]                         if (muffled) 
[16:17:51.091]                           invokeRestart("muffleWarning")
[16:17:51.091]                       }
[16:17:51.091]                       else if (inherits(cond, "condition")) {
[16:17:51.091]                         if (!is.null(pattern)) {
[16:17:51.091]                           computeRestarts <- base::computeRestarts
[16:17:51.091]                           grepl <- base::grepl
[16:17:51.091]                           restarts <- computeRestarts(cond)
[16:17:51.091]                           for (restart in restarts) {
[16:17:51.091]                             name <- restart$name
[16:17:51.091]                             if (is.null(name)) 
[16:17:51.091]                               next
[16:17:51.091]                             if (!grepl(pattern, name)) 
[16:17:51.091]                               next
[16:17:51.091]                             invokeRestart(restart)
[16:17:51.091]                             muffled <- TRUE
[16:17:51.091]                             break
[16:17:51.091]                           }
[16:17:51.091]                         }
[16:17:51.091]                       }
[16:17:51.091]                       invisible(muffled)
[16:17:51.091]                     }
[16:17:51.091]                     muffleCondition(cond, pattern = "^muffle")
[16:17:51.091]                   }
[16:17:51.091]                 }
[16:17:51.091]             }
[16:17:51.091]         }))
[16:17:51.091]     }, error = function(ex) {
[16:17:51.091]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:51.091]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:51.091]                 ...future.rng), started = ...future.startTime, 
[16:17:51.091]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:51.091]             version = "1.8"), class = "FutureResult")
[16:17:51.091]     }, finally = {
[16:17:51.091]         if (!identical(...future.workdir, getwd())) 
[16:17:51.091]             setwd(...future.workdir)
[16:17:51.091]         {
[16:17:51.091]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:51.091]                 ...future.oldOptions$nwarnings <- NULL
[16:17:51.091]             }
[16:17:51.091]             base::options(...future.oldOptions)
[16:17:51.091]             if (.Platform$OS.type == "windows") {
[16:17:51.091]                 old_names <- names(...future.oldEnvVars)
[16:17:51.091]                 envs <- base::Sys.getenv()
[16:17:51.091]                 names <- names(envs)
[16:17:51.091]                 common <- intersect(names, old_names)
[16:17:51.091]                 added <- setdiff(names, old_names)
[16:17:51.091]                 removed <- setdiff(old_names, names)
[16:17:51.091]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:51.091]                   envs[common]]
[16:17:51.091]                 NAMES <- toupper(changed)
[16:17:51.091]                 args <- list()
[16:17:51.091]                 for (kk in seq_along(NAMES)) {
[16:17:51.091]                   name <- changed[[kk]]
[16:17:51.091]                   NAME <- NAMES[[kk]]
[16:17:51.091]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.091]                     next
[16:17:51.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:51.091]                 }
[16:17:51.091]                 NAMES <- toupper(added)
[16:17:51.091]                 for (kk in seq_along(NAMES)) {
[16:17:51.091]                   name <- added[[kk]]
[16:17:51.091]                   NAME <- NAMES[[kk]]
[16:17:51.091]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.091]                     next
[16:17:51.091]                   args[[name]] <- ""
[16:17:51.091]                 }
[16:17:51.091]                 NAMES <- toupper(removed)
[16:17:51.091]                 for (kk in seq_along(NAMES)) {
[16:17:51.091]                   name <- removed[[kk]]
[16:17:51.091]                   NAME <- NAMES[[kk]]
[16:17:51.091]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.091]                     next
[16:17:51.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:51.091]                 }
[16:17:51.091]                 if (length(args) > 0) 
[16:17:51.091]                   base::do.call(base::Sys.setenv, args = args)
[16:17:51.091]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:51.091]             }
[16:17:51.091]             else {
[16:17:51.091]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:51.091]             }
[16:17:51.091]             {
[16:17:51.091]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:51.091]                   0L) {
[16:17:51.091]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:51.091]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:51.091]                   base::options(opts)
[16:17:51.091]                 }
[16:17:51.091]                 {
[16:17:51.091]                   {
[16:17:51.091]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:51.091]                     NULL
[16:17:51.091]                   }
[16:17:51.091]                   options(future.plan = NULL)
[16:17:51.091]                   if (is.na(NA_character_)) 
[16:17:51.091]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:51.091]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:51.091]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:51.091]                     .init = FALSE)
[16:17:51.091]                 }
[16:17:51.091]             }
[16:17:51.091]         }
[16:17:51.091]     })
[16:17:51.091]     if (TRUE) {
[16:17:51.091]         base::sink(type = "output", split = FALSE)
[16:17:51.091]         if (TRUE) {
[16:17:51.091]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:51.091]         }
[16:17:51.091]         else {
[16:17:51.091]             ...future.result["stdout"] <- base::list(NULL)
[16:17:51.091]         }
[16:17:51.091]         base::close(...future.stdout)
[16:17:51.091]         ...future.stdout <- NULL
[16:17:51.091]     }
[16:17:51.091]     ...future.result$conditions <- ...future.conditions
[16:17:51.091]     ...future.result$finished <- base::Sys.time()
[16:17:51.091]     ...future.result
[16:17:51.091] }
[16:17:51.146] MultisessionFuture started
[16:17:51.146] result() for ClusterFuture ...
[16:17:51.147] receiveMessageFromWorker() for ClusterFuture ...
[16:17:51.147] - Validating connection of MultisessionFuture
[16:17:51.179] - received message: FutureResult
[16:17:51.180] - Received FutureResult
[16:17:51.180] - Erased future from FutureRegistry
[16:17:51.180] result() for ClusterFuture ...
[16:17:51.180] - result already collected: FutureResult
[16:17:51.180] result() for ClusterFuture ... done
[16:17:51.180] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:51.181] result() for ClusterFuture ... done
[16:17:51.181] result() for ClusterFuture ...
[16:17:51.181] - result already collected: FutureResult
[16:17:51.181] result() for ClusterFuture ... done
[16:17:51.181] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:17:51.185] plan(): nbrOfWorkers() = 2
[16:17:51.185] future_lapply() ...
[16:17:51.190] Number of chunks: 2
[16:17:51.190] getGlobalsAndPackagesXApply() ...
[16:17:51.190]  - future.globals: TRUE
[16:17:51.190] getGlobalsAndPackages() ...
[16:17:51.190] Searching for globals...
[16:17:51.191] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:51.192] Searching for globals ... DONE
[16:17:51.192] Resolving globals: FALSE
[16:17:51.192] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:17:51.193] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:17:51.193] - globals: [1] ‘FUN’
[16:17:51.193] 
[16:17:51.193] getGlobalsAndPackages() ... DONE
[16:17:51.193]  - globals found/used: [n=1] ‘FUN’
[16:17:51.193]  - needed namespaces: [n=0] 
[16:17:51.193] Finding globals ... DONE
[16:17:51.194]  - use_args: TRUE
[16:17:51.194]  - Getting '...' globals ...
[16:17:51.194] resolve() on list ...
[16:17:51.194]  recursive: 0
[16:17:51.194]  length: 1
[16:17:51.194]  elements: ‘...’
[16:17:51.195]  length: 0 (resolved future 1)
[16:17:51.195] resolve() on list ... DONE
[16:17:51.195]    - '...' content: [n=0] 
[16:17:51.195] List of 1
[16:17:51.195]  $ ...: list()
[16:17:51.195]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:51.195]  - attr(*, "where")=List of 1
[16:17:51.195]   ..$ ...:<environment: 0x556da5e58ba0> 
[16:17:51.195]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:51.195]  - attr(*, "resolved")= logi TRUE
[16:17:51.195]  - attr(*, "total_size")= num NA
[16:17:51.198]  - Getting '...' globals ... DONE
[16:17:51.198] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:51.199] List of 2
[16:17:51.199]  $ ...future.FUN:function (x, ...)  
[16:17:51.199]  $ ...          : list()
[16:17:51.199]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:51.199]  - attr(*, "where")=List of 2
[16:17:51.199]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:51.199]   ..$ ...          :<environment: 0x556da5e58ba0> 
[16:17:51.199]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:51.199]  - attr(*, "resolved")= logi FALSE
[16:17:51.199]  - attr(*, "total_size")= num 1240
[16:17:51.202] Packages to be attached in all futures: [n=0] 
[16:17:51.202] getGlobalsAndPackagesXApply() ... DONE
[16:17:51.202] Number of futures (= number of chunks): 2
[16:17:51.202] Launching 2 futures (chunks) ...
[16:17:51.203] Chunk #1 of 2 ...
[16:17:51.203]  - Finding globals in 'X' for chunk #1 ...
[16:17:51.203] getGlobalsAndPackages() ...
[16:17:51.203] Searching for globals...
[16:17:51.203] 
[16:17:51.203] Searching for globals ... DONE
[16:17:51.203] - globals: [0] <none>
[16:17:51.204] getGlobalsAndPackages() ... DONE
[16:17:51.204]    + additional globals found: [n=0] 
[16:17:51.204]    + additional namespaces needed: [n=0] 
[16:17:51.204]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:51.204]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:51.204]  - seeds: <none>
[16:17:51.204]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:51.204] getGlobalsAndPackages() ...
[16:17:51.205] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:51.205] Resolving globals: FALSE
[16:17:51.205] Tweak future expression to call with '...' arguments ...
[16:17:51.205] {
[16:17:51.205]     do.call(function(...) {
[16:17:51.205]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:51.205]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:51.205]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:51.205]             on.exit(options(oopts), add = TRUE)
[16:17:51.205]         }
[16:17:51.205]         {
[16:17:51.205]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:51.205]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:51.205]                 ...future.FUN(...future.X_jj, ...)
[16:17:51.205]             })
[16:17:51.205]         }
[16:17:51.205]     }, args = future.call.arguments)
[16:17:51.205] }
[16:17:51.205] Tweak future expression to call with '...' arguments ... DONE
[16:17:51.206] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:51.206] 
[16:17:51.206] getGlobalsAndPackages() ... DONE
[16:17:51.206] run() for ‘Future’ ...
[16:17:51.206] - state: ‘created’
[16:17:51.207] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:51.221] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:51.221] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:51.221]   - Field: ‘node’
[16:17:51.221]   - Field: ‘label’
[16:17:51.221]   - Field: ‘local’
[16:17:51.222]   - Field: ‘owner’
[16:17:51.222]   - Field: ‘envir’
[16:17:51.222]   - Field: ‘workers’
[16:17:51.222]   - Field: ‘packages’
[16:17:51.222]   - Field: ‘gc’
[16:17:51.222]   - Field: ‘conditions’
[16:17:51.222]   - Field: ‘persistent’
[16:17:51.222]   - Field: ‘expr’
[16:17:51.222]   - Field: ‘uuid’
[16:17:51.223]   - Field: ‘seed’
[16:17:51.223]   - Field: ‘version’
[16:17:51.223]   - Field: ‘result’
[16:17:51.223]   - Field: ‘asynchronous’
[16:17:51.223]   - Field: ‘calls’
[16:17:51.223]   - Field: ‘globals’
[16:17:51.223]   - Field: ‘stdout’
[16:17:51.223]   - Field: ‘earlySignal’
[16:17:51.223]   - Field: ‘lazy’
[16:17:51.224]   - Field: ‘state’
[16:17:51.224] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:51.224] - Launch lazy future ...
[16:17:51.224] Packages needed by the future expression (n = 0): <none>
[16:17:51.224] Packages needed by future strategies (n = 0): <none>
[16:17:51.225] {
[16:17:51.225]     {
[16:17:51.225]         {
[16:17:51.225]             ...future.startTime <- base::Sys.time()
[16:17:51.225]             {
[16:17:51.225]                 {
[16:17:51.225]                   {
[16:17:51.225]                     {
[16:17:51.225]                       base::local({
[16:17:51.225]                         has_future <- base::requireNamespace("future", 
[16:17:51.225]                           quietly = TRUE)
[16:17:51.225]                         if (has_future) {
[16:17:51.225]                           ns <- base::getNamespace("future")
[16:17:51.225]                           version <- ns[[".package"]][["version"]]
[16:17:51.225]                           if (is.null(version)) 
[16:17:51.225]                             version <- utils::packageVersion("future")
[16:17:51.225]                         }
[16:17:51.225]                         else {
[16:17:51.225]                           version <- NULL
[16:17:51.225]                         }
[16:17:51.225]                         if (!has_future || version < "1.8.0") {
[16:17:51.225]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:51.225]                             "", base::R.version$version.string), 
[16:17:51.225]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:51.225]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:51.225]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:51.225]                               "release", "version")], collapse = " "), 
[16:17:51.225]                             hostname = base::Sys.info()[["nodename"]])
[16:17:51.225]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:51.225]                             info)
[16:17:51.225]                           info <- base::paste(info, collapse = "; ")
[16:17:51.225]                           if (!has_future) {
[16:17:51.225]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:51.225]                               info)
[16:17:51.225]                           }
[16:17:51.225]                           else {
[16:17:51.225]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:51.225]                               info, version)
[16:17:51.225]                           }
[16:17:51.225]                           base::stop(msg)
[16:17:51.225]                         }
[16:17:51.225]                       })
[16:17:51.225]                     }
[16:17:51.225]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:51.225]                     base::options(mc.cores = 1L)
[16:17:51.225]                   }
[16:17:51.225]                   ...future.strategy.old <- future::plan("list")
[16:17:51.225]                   options(future.plan = NULL)
[16:17:51.225]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:51.225]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:51.225]                 }
[16:17:51.225]                 ...future.workdir <- getwd()
[16:17:51.225]             }
[16:17:51.225]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:51.225]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:51.225]         }
[16:17:51.225]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:51.225]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:51.225]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:51.225]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:51.225]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:51.225]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:51.225]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:51.225]             base::names(...future.oldOptions))
[16:17:51.225]     }
[16:17:51.225]     if (FALSE) {
[16:17:51.225]     }
[16:17:51.225]     else {
[16:17:51.225]         if (TRUE) {
[16:17:51.225]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:51.225]                 open = "w")
[16:17:51.225]         }
[16:17:51.225]         else {
[16:17:51.225]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:51.225]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:51.225]         }
[16:17:51.225]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:51.225]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:51.225]             base::sink(type = "output", split = FALSE)
[16:17:51.225]             base::close(...future.stdout)
[16:17:51.225]         }, add = TRUE)
[16:17:51.225]     }
[16:17:51.225]     ...future.frame <- base::sys.nframe()
[16:17:51.225]     ...future.conditions <- base::list()
[16:17:51.225]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:51.225]     if (FALSE) {
[16:17:51.225]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:51.225]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:51.225]     }
[16:17:51.225]     ...future.result <- base::tryCatch({
[16:17:51.225]         base::withCallingHandlers({
[16:17:51.225]             ...future.value <- base::withVisible(base::local({
[16:17:51.225]                 ...future.makeSendCondition <- base::local({
[16:17:51.225]                   sendCondition <- NULL
[16:17:51.225]                   function(frame = 1L) {
[16:17:51.225]                     if (is.function(sendCondition)) 
[16:17:51.225]                       return(sendCondition)
[16:17:51.225]                     ns <- getNamespace("parallel")
[16:17:51.225]                     if (exists("sendData", mode = "function", 
[16:17:51.225]                       envir = ns)) {
[16:17:51.225]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:51.225]                         envir = ns)
[16:17:51.225]                       envir <- sys.frame(frame)
[16:17:51.225]                       master <- NULL
[16:17:51.225]                       while (!identical(envir, .GlobalEnv) && 
[16:17:51.225]                         !identical(envir, emptyenv())) {
[16:17:51.225]                         if (exists("master", mode = "list", envir = envir, 
[16:17:51.225]                           inherits = FALSE)) {
[16:17:51.225]                           master <- get("master", mode = "list", 
[16:17:51.225]                             envir = envir, inherits = FALSE)
[16:17:51.225]                           if (inherits(master, c("SOCKnode", 
[16:17:51.225]                             "SOCK0node"))) {
[16:17:51.225]                             sendCondition <<- function(cond) {
[16:17:51.225]                               data <- list(type = "VALUE", value = cond, 
[16:17:51.225]                                 success = TRUE)
[16:17:51.225]                               parallel_sendData(master, data)
[16:17:51.225]                             }
[16:17:51.225]                             return(sendCondition)
[16:17:51.225]                           }
[16:17:51.225]                         }
[16:17:51.225]                         frame <- frame + 1L
[16:17:51.225]                         envir <- sys.frame(frame)
[16:17:51.225]                       }
[16:17:51.225]                     }
[16:17:51.225]                     sendCondition <<- function(cond) NULL
[16:17:51.225]                   }
[16:17:51.225]                 })
[16:17:51.225]                 withCallingHandlers({
[16:17:51.225]                   {
[16:17:51.225]                     do.call(function(...) {
[16:17:51.225]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:51.225]                       if (!identical(...future.globals.maxSize.org, 
[16:17:51.225]                         ...future.globals.maxSize)) {
[16:17:51.225]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:51.225]                         on.exit(options(oopts), add = TRUE)
[16:17:51.225]                       }
[16:17:51.225]                       {
[16:17:51.225]                         lapply(seq_along(...future.elements_ii), 
[16:17:51.225]                           FUN = function(jj) {
[16:17:51.225]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:51.225]                             ...future.FUN(...future.X_jj, ...)
[16:17:51.225]                           })
[16:17:51.225]                       }
[16:17:51.225]                     }, args = future.call.arguments)
[16:17:51.225]                   }
[16:17:51.225]                 }, immediateCondition = function(cond) {
[16:17:51.225]                   sendCondition <- ...future.makeSendCondition()
[16:17:51.225]                   sendCondition(cond)
[16:17:51.225]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.225]                   {
[16:17:51.225]                     inherits <- base::inherits
[16:17:51.225]                     invokeRestart <- base::invokeRestart
[16:17:51.225]                     is.null <- base::is.null
[16:17:51.225]                     muffled <- FALSE
[16:17:51.225]                     if (inherits(cond, "message")) {
[16:17:51.225]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:51.225]                       if (muffled) 
[16:17:51.225]                         invokeRestart("muffleMessage")
[16:17:51.225]                     }
[16:17:51.225]                     else if (inherits(cond, "warning")) {
[16:17:51.225]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:51.225]                       if (muffled) 
[16:17:51.225]                         invokeRestart("muffleWarning")
[16:17:51.225]                     }
[16:17:51.225]                     else if (inherits(cond, "condition")) {
[16:17:51.225]                       if (!is.null(pattern)) {
[16:17:51.225]                         computeRestarts <- base::computeRestarts
[16:17:51.225]                         grepl <- base::grepl
[16:17:51.225]                         restarts <- computeRestarts(cond)
[16:17:51.225]                         for (restart in restarts) {
[16:17:51.225]                           name <- restart$name
[16:17:51.225]                           if (is.null(name)) 
[16:17:51.225]                             next
[16:17:51.225]                           if (!grepl(pattern, name)) 
[16:17:51.225]                             next
[16:17:51.225]                           invokeRestart(restart)
[16:17:51.225]                           muffled <- TRUE
[16:17:51.225]                           break
[16:17:51.225]                         }
[16:17:51.225]                       }
[16:17:51.225]                     }
[16:17:51.225]                     invisible(muffled)
[16:17:51.225]                   }
[16:17:51.225]                   muffleCondition(cond)
[16:17:51.225]                 })
[16:17:51.225]             }))
[16:17:51.225]             future::FutureResult(value = ...future.value$value, 
[16:17:51.225]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:51.225]                   ...future.rng), globalenv = if (FALSE) 
[16:17:51.225]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:51.225]                     ...future.globalenv.names))
[16:17:51.225]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:51.225]         }, condition = base::local({
[16:17:51.225]             c <- base::c
[16:17:51.225]             inherits <- base::inherits
[16:17:51.225]             invokeRestart <- base::invokeRestart
[16:17:51.225]             length <- base::length
[16:17:51.225]             list <- base::list
[16:17:51.225]             seq.int <- base::seq.int
[16:17:51.225]             signalCondition <- base::signalCondition
[16:17:51.225]             sys.calls <- base::sys.calls
[16:17:51.225]             `[[` <- base::`[[`
[16:17:51.225]             `+` <- base::`+`
[16:17:51.225]             `<<-` <- base::`<<-`
[16:17:51.225]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:51.225]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:51.225]                   3L)]
[16:17:51.225]             }
[16:17:51.225]             function(cond) {
[16:17:51.225]                 is_error <- inherits(cond, "error")
[16:17:51.225]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:51.225]                   NULL)
[16:17:51.225]                 if (is_error) {
[16:17:51.225]                   sessionInformation <- function() {
[16:17:51.225]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:51.225]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:51.225]                       search = base::search(), system = base::Sys.info())
[16:17:51.225]                   }
[16:17:51.225]                   ...future.conditions[[length(...future.conditions) + 
[16:17:51.225]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:51.225]                     cond$call), session = sessionInformation(), 
[16:17:51.225]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:51.225]                   signalCondition(cond)
[16:17:51.225]                 }
[16:17:51.225]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:51.225]                 "immediateCondition"))) {
[16:17:51.225]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:51.225]                   ...future.conditions[[length(...future.conditions) + 
[16:17:51.225]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:51.225]                   if (TRUE && !signal) {
[16:17:51.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.225]                     {
[16:17:51.225]                       inherits <- base::inherits
[16:17:51.225]                       invokeRestart <- base::invokeRestart
[16:17:51.225]                       is.null <- base::is.null
[16:17:51.225]                       muffled <- FALSE
[16:17:51.225]                       if (inherits(cond, "message")) {
[16:17:51.225]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:51.225]                         if (muffled) 
[16:17:51.225]                           invokeRestart("muffleMessage")
[16:17:51.225]                       }
[16:17:51.225]                       else if (inherits(cond, "warning")) {
[16:17:51.225]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:51.225]                         if (muffled) 
[16:17:51.225]                           invokeRestart("muffleWarning")
[16:17:51.225]                       }
[16:17:51.225]                       else if (inherits(cond, "condition")) {
[16:17:51.225]                         if (!is.null(pattern)) {
[16:17:51.225]                           computeRestarts <- base::computeRestarts
[16:17:51.225]                           grepl <- base::grepl
[16:17:51.225]                           restarts <- computeRestarts(cond)
[16:17:51.225]                           for (restart in restarts) {
[16:17:51.225]                             name <- restart$name
[16:17:51.225]                             if (is.null(name)) 
[16:17:51.225]                               next
[16:17:51.225]                             if (!grepl(pattern, name)) 
[16:17:51.225]                               next
[16:17:51.225]                             invokeRestart(restart)
[16:17:51.225]                             muffled <- TRUE
[16:17:51.225]                             break
[16:17:51.225]                           }
[16:17:51.225]                         }
[16:17:51.225]                       }
[16:17:51.225]                       invisible(muffled)
[16:17:51.225]                     }
[16:17:51.225]                     muffleCondition(cond, pattern = "^muffle")
[16:17:51.225]                   }
[16:17:51.225]                 }
[16:17:51.225]                 else {
[16:17:51.225]                   if (TRUE) {
[16:17:51.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.225]                     {
[16:17:51.225]                       inherits <- base::inherits
[16:17:51.225]                       invokeRestart <- base::invokeRestart
[16:17:51.225]                       is.null <- base::is.null
[16:17:51.225]                       muffled <- FALSE
[16:17:51.225]                       if (inherits(cond, "message")) {
[16:17:51.225]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:51.225]                         if (muffled) 
[16:17:51.225]                           invokeRestart("muffleMessage")
[16:17:51.225]                       }
[16:17:51.225]                       else if (inherits(cond, "warning")) {
[16:17:51.225]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:51.225]                         if (muffled) 
[16:17:51.225]                           invokeRestart("muffleWarning")
[16:17:51.225]                       }
[16:17:51.225]                       else if (inherits(cond, "condition")) {
[16:17:51.225]                         if (!is.null(pattern)) {
[16:17:51.225]                           computeRestarts <- base::computeRestarts
[16:17:51.225]                           grepl <- base::grepl
[16:17:51.225]                           restarts <- computeRestarts(cond)
[16:17:51.225]                           for (restart in restarts) {
[16:17:51.225]                             name <- restart$name
[16:17:51.225]                             if (is.null(name)) 
[16:17:51.225]                               next
[16:17:51.225]                             if (!grepl(pattern, name)) 
[16:17:51.225]                               next
[16:17:51.225]                             invokeRestart(restart)
[16:17:51.225]                             muffled <- TRUE
[16:17:51.225]                             break
[16:17:51.225]                           }
[16:17:51.225]                         }
[16:17:51.225]                       }
[16:17:51.225]                       invisible(muffled)
[16:17:51.225]                     }
[16:17:51.225]                     muffleCondition(cond, pattern = "^muffle")
[16:17:51.225]                   }
[16:17:51.225]                 }
[16:17:51.225]             }
[16:17:51.225]         }))
[16:17:51.225]     }, error = function(ex) {
[16:17:51.225]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:51.225]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:51.225]                 ...future.rng), started = ...future.startTime, 
[16:17:51.225]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:51.225]             version = "1.8"), class = "FutureResult")
[16:17:51.225]     }, finally = {
[16:17:51.225]         if (!identical(...future.workdir, getwd())) 
[16:17:51.225]             setwd(...future.workdir)
[16:17:51.225]         {
[16:17:51.225]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:51.225]                 ...future.oldOptions$nwarnings <- NULL
[16:17:51.225]             }
[16:17:51.225]             base::options(...future.oldOptions)
[16:17:51.225]             if (.Platform$OS.type == "windows") {
[16:17:51.225]                 old_names <- names(...future.oldEnvVars)
[16:17:51.225]                 envs <- base::Sys.getenv()
[16:17:51.225]                 names <- names(envs)
[16:17:51.225]                 common <- intersect(names, old_names)
[16:17:51.225]                 added <- setdiff(names, old_names)
[16:17:51.225]                 removed <- setdiff(old_names, names)
[16:17:51.225]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:51.225]                   envs[common]]
[16:17:51.225]                 NAMES <- toupper(changed)
[16:17:51.225]                 args <- list()
[16:17:51.225]                 for (kk in seq_along(NAMES)) {
[16:17:51.225]                   name <- changed[[kk]]
[16:17:51.225]                   NAME <- NAMES[[kk]]
[16:17:51.225]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.225]                     next
[16:17:51.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:51.225]                 }
[16:17:51.225]                 NAMES <- toupper(added)
[16:17:51.225]                 for (kk in seq_along(NAMES)) {
[16:17:51.225]                   name <- added[[kk]]
[16:17:51.225]                   NAME <- NAMES[[kk]]
[16:17:51.225]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.225]                     next
[16:17:51.225]                   args[[name]] <- ""
[16:17:51.225]                 }
[16:17:51.225]                 NAMES <- toupper(removed)
[16:17:51.225]                 for (kk in seq_along(NAMES)) {
[16:17:51.225]                   name <- removed[[kk]]
[16:17:51.225]                   NAME <- NAMES[[kk]]
[16:17:51.225]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.225]                     next
[16:17:51.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:51.225]                 }
[16:17:51.225]                 if (length(args) > 0) 
[16:17:51.225]                   base::do.call(base::Sys.setenv, args = args)
[16:17:51.225]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:51.225]             }
[16:17:51.225]             else {
[16:17:51.225]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:51.225]             }
[16:17:51.225]             {
[16:17:51.225]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:51.225]                   0L) {
[16:17:51.225]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:51.225]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:51.225]                   base::options(opts)
[16:17:51.225]                 }
[16:17:51.225]                 {
[16:17:51.225]                   {
[16:17:51.225]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:51.225]                     NULL
[16:17:51.225]                   }
[16:17:51.225]                   options(future.plan = NULL)
[16:17:51.225]                   if (is.na(NA_character_)) 
[16:17:51.225]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:51.225]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:51.225]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:51.225]                     .init = FALSE)
[16:17:51.225]                 }
[16:17:51.225]             }
[16:17:51.225]         }
[16:17:51.225]     })
[16:17:51.225]     if (TRUE) {
[16:17:51.225]         base::sink(type = "output", split = FALSE)
[16:17:51.225]         if (TRUE) {
[16:17:51.225]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:51.225]         }
[16:17:51.225]         else {
[16:17:51.225]             ...future.result["stdout"] <- base::list(NULL)
[16:17:51.225]         }
[16:17:51.225]         base::close(...future.stdout)
[16:17:51.225]         ...future.stdout <- NULL
[16:17:51.225]     }
[16:17:51.225]     ...future.result$conditions <- ...future.conditions
[16:17:51.225]     ...future.result$finished <- base::Sys.time()
[16:17:51.225]     ...future.result
[16:17:51.225] }
[16:17:51.228] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[16:17:51.228] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[16:17:51.229] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[16:17:51.229] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:17:51.229] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:17:51.230] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[16:17:51.230] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[16:17:51.230] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:17:51.230] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:17:51.231] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:17:51.231] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:17:51.231] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[16:17:51.232] MultisessionFuture started
[16:17:51.232] - Launch lazy future ... done
[16:17:51.232] run() for ‘MultisessionFuture’ ... done
[16:17:51.232] Created future:
[16:17:51.232] MultisessionFuture:
[16:17:51.232] Label: ‘future_eapply-1’
[16:17:51.232] Expression:
[16:17:51.232] {
[16:17:51.232]     do.call(function(...) {
[16:17:51.232]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:51.232]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:51.232]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:51.232]             on.exit(options(oopts), add = TRUE)
[16:17:51.232]         }
[16:17:51.232]         {
[16:17:51.232]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:51.232]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:51.232]                 ...future.FUN(...future.X_jj, ...)
[16:17:51.232]             })
[16:17:51.232]         }
[16:17:51.232]     }, args = future.call.arguments)
[16:17:51.232] }
[16:17:51.232] Lazy evaluation: FALSE
[16:17:51.232] Asynchronous evaluation: TRUE
[16:17:51.232] Local evaluation: TRUE
[16:17:51.232] Environment: R_GlobalEnv
[16:17:51.232] Capture standard output: TRUE
[16:17:51.232] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:51.232] Globals: 5 objects totaling 1.27 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:51.232] Packages: <none>
[16:17:51.232] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:51.232] Resolved: FALSE
[16:17:51.232] Value: <not collected>
[16:17:51.232] Conditions captured: <none>
[16:17:51.232] Early signaling: FALSE
[16:17:51.232] Owner process: 95d59565-e757-824f-7f5c-7f754384cffc
[16:17:51.232] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:51.244] Chunk #1 of 2 ... DONE
[16:17:51.244] Chunk #2 of 2 ...
[16:17:51.245]  - Finding globals in 'X' for chunk #2 ...
[16:17:51.245] getGlobalsAndPackages() ...
[16:17:51.245] Searching for globals...
[16:17:51.245] 
[16:17:51.245] Searching for globals ... DONE
[16:17:51.245] - globals: [0] <none>
[16:17:51.246] getGlobalsAndPackages() ... DONE
[16:17:51.246]    + additional globals found: [n=0] 
[16:17:51.246]    + additional namespaces needed: [n=0] 
[16:17:51.246]  - Finding globals in 'X' for chunk #2 ... DONE
[16:17:51.246]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:51.246]  - seeds: <none>
[16:17:51.246]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:51.246] getGlobalsAndPackages() ...
[16:17:51.247] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:51.247] Resolving globals: FALSE
[16:17:51.247] Tweak future expression to call with '...' arguments ...
[16:17:51.247] {
[16:17:51.247]     do.call(function(...) {
[16:17:51.247]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:51.247]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:51.247]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:51.247]             on.exit(options(oopts), add = TRUE)
[16:17:51.247]         }
[16:17:51.247]         {
[16:17:51.247]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:51.247]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:51.247]                 ...future.FUN(...future.X_jj, ...)
[16:17:51.247]             })
[16:17:51.247]         }
[16:17:51.247]     }, args = future.call.arguments)
[16:17:51.247] }
[16:17:51.247] Tweak future expression to call with '...' arguments ... DONE
[16:17:51.248] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:51.248] 
[16:17:51.248] getGlobalsAndPackages() ... DONE
[16:17:51.248] run() for ‘Future’ ...
[16:17:51.248] - state: ‘created’
[16:17:51.249] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:51.263] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:51.263] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:51.264]   - Field: ‘node’
[16:17:51.264]   - Field: ‘label’
[16:17:51.264]   - Field: ‘local’
[16:17:51.264]   - Field: ‘owner’
[16:17:51.264]   - Field: ‘envir’
[16:17:51.264]   - Field: ‘workers’
[16:17:51.264]   - Field: ‘packages’
[16:17:51.264]   - Field: ‘gc’
[16:17:51.264]   - Field: ‘conditions’
[16:17:51.264]   - Field: ‘persistent’
[16:17:51.265]   - Field: ‘expr’
[16:17:51.265]   - Field: ‘uuid’
[16:17:51.265]   - Field: ‘seed’
[16:17:51.265]   - Field: ‘version’
[16:17:51.265]   - Field: ‘result’
[16:17:51.265]   - Field: ‘asynchronous’
[16:17:51.265]   - Field: ‘calls’
[16:17:51.265]   - Field: ‘globals’
[16:17:51.266]   - Field: ‘stdout’
[16:17:51.266]   - Field: ‘earlySignal’
[16:17:51.266]   - Field: ‘lazy’
[16:17:51.266]   - Field: ‘state’
[16:17:51.266] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:51.266] - Launch lazy future ...
[16:17:51.267] Packages needed by the future expression (n = 0): <none>
[16:17:51.267] Packages needed by future strategies (n = 0): <none>
[16:17:51.267] {
[16:17:51.267]     {
[16:17:51.267]         {
[16:17:51.267]             ...future.startTime <- base::Sys.time()
[16:17:51.267]             {
[16:17:51.267]                 {
[16:17:51.267]                   {
[16:17:51.267]                     {
[16:17:51.267]                       base::local({
[16:17:51.267]                         has_future <- base::requireNamespace("future", 
[16:17:51.267]                           quietly = TRUE)
[16:17:51.267]                         if (has_future) {
[16:17:51.267]                           ns <- base::getNamespace("future")
[16:17:51.267]                           version <- ns[[".package"]][["version"]]
[16:17:51.267]                           if (is.null(version)) 
[16:17:51.267]                             version <- utils::packageVersion("future")
[16:17:51.267]                         }
[16:17:51.267]                         else {
[16:17:51.267]                           version <- NULL
[16:17:51.267]                         }
[16:17:51.267]                         if (!has_future || version < "1.8.0") {
[16:17:51.267]                           info <- base::c(r_version = base::gsub("R version ", 
[16:17:51.267]                             "", base::R.version$version.string), 
[16:17:51.267]                             platform = base::sprintf("%s (%s-bit)", 
[16:17:51.267]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:17:51.267]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:51.267]                               "release", "version")], collapse = " "), 
[16:17:51.267]                             hostname = base::Sys.info()[["nodename"]])
[16:17:51.267]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:17:51.267]                             info)
[16:17:51.267]                           info <- base::paste(info, collapse = "; ")
[16:17:51.267]                           if (!has_future) {
[16:17:51.267]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:51.267]                               info)
[16:17:51.267]                           }
[16:17:51.267]                           else {
[16:17:51.267]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:51.267]                               info, version)
[16:17:51.267]                           }
[16:17:51.267]                           base::stop(msg)
[16:17:51.267]                         }
[16:17:51.267]                       })
[16:17:51.267]                     }
[16:17:51.267]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:51.267]                     base::options(mc.cores = 1L)
[16:17:51.267]                   }
[16:17:51.267]                   ...future.strategy.old <- future::plan("list")
[16:17:51.267]                   options(future.plan = NULL)
[16:17:51.267]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:51.267]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:51.267]                 }
[16:17:51.267]                 ...future.workdir <- getwd()
[16:17:51.267]             }
[16:17:51.267]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:51.267]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:51.267]         }
[16:17:51.267]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:51.267]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:51.267]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:51.267]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:51.267]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:51.267]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:51.267]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:51.267]             base::names(...future.oldOptions))
[16:17:51.267]     }
[16:17:51.267]     if (FALSE) {
[16:17:51.267]     }
[16:17:51.267]     else {
[16:17:51.267]         if (TRUE) {
[16:17:51.267]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:51.267]                 open = "w")
[16:17:51.267]         }
[16:17:51.267]         else {
[16:17:51.267]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:51.267]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:51.267]         }
[16:17:51.267]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:51.267]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:51.267]             base::sink(type = "output", split = FALSE)
[16:17:51.267]             base::close(...future.stdout)
[16:17:51.267]         }, add = TRUE)
[16:17:51.267]     }
[16:17:51.267]     ...future.frame <- base::sys.nframe()
[16:17:51.267]     ...future.conditions <- base::list()
[16:17:51.267]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:51.267]     if (FALSE) {
[16:17:51.267]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:51.267]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:51.267]     }
[16:17:51.267]     ...future.result <- base::tryCatch({
[16:17:51.267]         base::withCallingHandlers({
[16:17:51.267]             ...future.value <- base::withVisible(base::local({
[16:17:51.267]                 ...future.makeSendCondition <- base::local({
[16:17:51.267]                   sendCondition <- NULL
[16:17:51.267]                   function(frame = 1L) {
[16:17:51.267]                     if (is.function(sendCondition)) 
[16:17:51.267]                       return(sendCondition)
[16:17:51.267]                     ns <- getNamespace("parallel")
[16:17:51.267]                     if (exists("sendData", mode = "function", 
[16:17:51.267]                       envir = ns)) {
[16:17:51.267]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:51.267]                         envir = ns)
[16:17:51.267]                       envir <- sys.frame(frame)
[16:17:51.267]                       master <- NULL
[16:17:51.267]                       while (!identical(envir, .GlobalEnv) && 
[16:17:51.267]                         !identical(envir, emptyenv())) {
[16:17:51.267]                         if (exists("master", mode = "list", envir = envir, 
[16:17:51.267]                           inherits = FALSE)) {
[16:17:51.267]                           master <- get("master", mode = "list", 
[16:17:51.267]                             envir = envir, inherits = FALSE)
[16:17:51.267]                           if (inherits(master, c("SOCKnode", 
[16:17:51.267]                             "SOCK0node"))) {
[16:17:51.267]                             sendCondition <<- function(cond) {
[16:17:51.267]                               data <- list(type = "VALUE", value = cond, 
[16:17:51.267]                                 success = TRUE)
[16:17:51.267]                               parallel_sendData(master, data)
[16:17:51.267]                             }
[16:17:51.267]                             return(sendCondition)
[16:17:51.267]                           }
[16:17:51.267]                         }
[16:17:51.267]                         frame <- frame + 1L
[16:17:51.267]                         envir <- sys.frame(frame)
[16:17:51.267]                       }
[16:17:51.267]                     }
[16:17:51.267]                     sendCondition <<- function(cond) NULL
[16:17:51.267]                   }
[16:17:51.267]                 })
[16:17:51.267]                 withCallingHandlers({
[16:17:51.267]                   {
[16:17:51.267]                     do.call(function(...) {
[16:17:51.267]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:51.267]                       if (!identical(...future.globals.maxSize.org, 
[16:17:51.267]                         ...future.globals.maxSize)) {
[16:17:51.267]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:51.267]                         on.exit(options(oopts), add = TRUE)
[16:17:51.267]                       }
[16:17:51.267]                       {
[16:17:51.267]                         lapply(seq_along(...future.elements_ii), 
[16:17:51.267]                           FUN = function(jj) {
[16:17:51.267]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:51.267]                             ...future.FUN(...future.X_jj, ...)
[16:17:51.267]                           })
[16:17:51.267]                       }
[16:17:51.267]                     }, args = future.call.arguments)
[16:17:51.267]                   }
[16:17:51.267]                 }, immediateCondition = function(cond) {
[16:17:51.267]                   sendCondition <- ...future.makeSendCondition()
[16:17:51.267]                   sendCondition(cond)
[16:17:51.267]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.267]                   {
[16:17:51.267]                     inherits <- base::inherits
[16:17:51.267]                     invokeRestart <- base::invokeRestart
[16:17:51.267]                     is.null <- base::is.null
[16:17:51.267]                     muffled <- FALSE
[16:17:51.267]                     if (inherits(cond, "message")) {
[16:17:51.267]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:51.267]                       if (muffled) 
[16:17:51.267]                         invokeRestart("muffleMessage")
[16:17:51.267]                     }
[16:17:51.267]                     else if (inherits(cond, "warning")) {
[16:17:51.267]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:51.267]                       if (muffled) 
[16:17:51.267]                         invokeRestart("muffleWarning")
[16:17:51.267]                     }
[16:17:51.267]                     else if (inherits(cond, "condition")) {
[16:17:51.267]                       if (!is.null(pattern)) {
[16:17:51.267]                         computeRestarts <- base::computeRestarts
[16:17:51.267]                         grepl <- base::grepl
[16:17:51.267]                         restarts <- computeRestarts(cond)
[16:17:51.267]                         for (restart in restarts) {
[16:17:51.267]                           name <- restart$name
[16:17:51.267]                           if (is.null(name)) 
[16:17:51.267]                             next
[16:17:51.267]                           if (!grepl(pattern, name)) 
[16:17:51.267]                             next
[16:17:51.267]                           invokeRestart(restart)
[16:17:51.267]                           muffled <- TRUE
[16:17:51.267]                           break
[16:17:51.267]                         }
[16:17:51.267]                       }
[16:17:51.267]                     }
[16:17:51.267]                     invisible(muffled)
[16:17:51.267]                   }
[16:17:51.267]                   muffleCondition(cond)
[16:17:51.267]                 })
[16:17:51.267]             }))
[16:17:51.267]             future::FutureResult(value = ...future.value$value, 
[16:17:51.267]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:51.267]                   ...future.rng), globalenv = if (FALSE) 
[16:17:51.267]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:51.267]                     ...future.globalenv.names))
[16:17:51.267]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:51.267]         }, condition = base::local({
[16:17:51.267]             c <- base::c
[16:17:51.267]             inherits <- base::inherits
[16:17:51.267]             invokeRestart <- base::invokeRestart
[16:17:51.267]             length <- base::length
[16:17:51.267]             list <- base::list
[16:17:51.267]             seq.int <- base::seq.int
[16:17:51.267]             signalCondition <- base::signalCondition
[16:17:51.267]             sys.calls <- base::sys.calls
[16:17:51.267]             `[[` <- base::`[[`
[16:17:51.267]             `+` <- base::`+`
[16:17:51.267]             `<<-` <- base::`<<-`
[16:17:51.267]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:51.267]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:51.267]                   3L)]
[16:17:51.267]             }
[16:17:51.267]             function(cond) {
[16:17:51.267]                 is_error <- inherits(cond, "error")
[16:17:51.267]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:51.267]                   NULL)
[16:17:51.267]                 if (is_error) {
[16:17:51.267]                   sessionInformation <- function() {
[16:17:51.267]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:51.267]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:51.267]                       search = base::search(), system = base::Sys.info())
[16:17:51.267]                   }
[16:17:51.267]                   ...future.conditions[[length(...future.conditions) + 
[16:17:51.267]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:51.267]                     cond$call), session = sessionInformation(), 
[16:17:51.267]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:51.267]                   signalCondition(cond)
[16:17:51.267]                 }
[16:17:51.267]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:51.267]                 "immediateCondition"))) {
[16:17:51.267]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:51.267]                   ...future.conditions[[length(...future.conditions) + 
[16:17:51.267]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:51.267]                   if (TRUE && !signal) {
[16:17:51.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.267]                     {
[16:17:51.267]                       inherits <- base::inherits
[16:17:51.267]                       invokeRestart <- base::invokeRestart
[16:17:51.267]                       is.null <- base::is.null
[16:17:51.267]                       muffled <- FALSE
[16:17:51.267]                       if (inherits(cond, "message")) {
[16:17:51.267]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:51.267]                         if (muffled) 
[16:17:51.267]                           invokeRestart("muffleMessage")
[16:17:51.267]                       }
[16:17:51.267]                       else if (inherits(cond, "warning")) {
[16:17:51.267]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:51.267]                         if (muffled) 
[16:17:51.267]                           invokeRestart("muffleWarning")
[16:17:51.267]                       }
[16:17:51.267]                       else if (inherits(cond, "condition")) {
[16:17:51.267]                         if (!is.null(pattern)) {
[16:17:51.267]                           computeRestarts <- base::computeRestarts
[16:17:51.267]                           grepl <- base::grepl
[16:17:51.267]                           restarts <- computeRestarts(cond)
[16:17:51.267]                           for (restart in restarts) {
[16:17:51.267]                             name <- restart$name
[16:17:51.267]                             if (is.null(name)) 
[16:17:51.267]                               next
[16:17:51.267]                             if (!grepl(pattern, name)) 
[16:17:51.267]                               next
[16:17:51.267]                             invokeRestart(restart)
[16:17:51.267]                             muffled <- TRUE
[16:17:51.267]                             break
[16:17:51.267]                           }
[16:17:51.267]                         }
[16:17:51.267]                       }
[16:17:51.267]                       invisible(muffled)
[16:17:51.267]                     }
[16:17:51.267]                     muffleCondition(cond, pattern = "^muffle")
[16:17:51.267]                   }
[16:17:51.267]                 }
[16:17:51.267]                 else {
[16:17:51.267]                   if (TRUE) {
[16:17:51.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.267]                     {
[16:17:51.267]                       inherits <- base::inherits
[16:17:51.267]                       invokeRestart <- base::invokeRestart
[16:17:51.267]                       is.null <- base::is.null
[16:17:51.267]                       muffled <- FALSE
[16:17:51.267]                       if (inherits(cond, "message")) {
[16:17:51.267]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:51.267]                         if (muffled) 
[16:17:51.267]                           invokeRestart("muffleMessage")
[16:17:51.267]                       }
[16:17:51.267]                       else if (inherits(cond, "warning")) {
[16:17:51.267]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:51.267]                         if (muffled) 
[16:17:51.267]                           invokeRestart("muffleWarning")
[16:17:51.267]                       }
[16:17:51.267]                       else if (inherits(cond, "condition")) {
[16:17:51.267]                         if (!is.null(pattern)) {
[16:17:51.267]                           computeRestarts <- base::computeRestarts
[16:17:51.267]                           grepl <- base::grepl
[16:17:51.267]                           restarts <- computeRestarts(cond)
[16:17:51.267]                           for (restart in restarts) {
[16:17:51.267]                             name <- restart$name
[16:17:51.267]                             if (is.null(name)) 
[16:17:51.267]                               next
[16:17:51.267]                             if (!grepl(pattern, name)) 
[16:17:51.267]                               next
[16:17:51.267]                             invokeRestart(restart)
[16:17:51.267]                             muffled <- TRUE
[16:17:51.267]                             break
[16:17:51.267]                           }
[16:17:51.267]                         }
[16:17:51.267]                       }
[16:17:51.267]                       invisible(muffled)
[16:17:51.267]                     }
[16:17:51.267]                     muffleCondition(cond, pattern = "^muffle")
[16:17:51.267]                   }
[16:17:51.267]                 }
[16:17:51.267]             }
[16:17:51.267]         }))
[16:17:51.267]     }, error = function(ex) {
[16:17:51.267]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:51.267]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:51.267]                 ...future.rng), started = ...future.startTime, 
[16:17:51.267]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:51.267]             version = "1.8"), class = "FutureResult")
[16:17:51.267]     }, finally = {
[16:17:51.267]         if (!identical(...future.workdir, getwd())) 
[16:17:51.267]             setwd(...future.workdir)
[16:17:51.267]         {
[16:17:51.267]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:51.267]                 ...future.oldOptions$nwarnings <- NULL
[16:17:51.267]             }
[16:17:51.267]             base::options(...future.oldOptions)
[16:17:51.267]             if (.Platform$OS.type == "windows") {
[16:17:51.267]                 old_names <- names(...future.oldEnvVars)
[16:17:51.267]                 envs <- base::Sys.getenv()
[16:17:51.267]                 names <- names(envs)
[16:17:51.267]                 common <- intersect(names, old_names)
[16:17:51.267]                 added <- setdiff(names, old_names)
[16:17:51.267]                 removed <- setdiff(old_names, names)
[16:17:51.267]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:51.267]                   envs[common]]
[16:17:51.267]                 NAMES <- toupper(changed)
[16:17:51.267]                 args <- list()
[16:17:51.267]                 for (kk in seq_along(NAMES)) {
[16:17:51.267]                   name <- changed[[kk]]
[16:17:51.267]                   NAME <- NAMES[[kk]]
[16:17:51.267]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.267]                     next
[16:17:51.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:51.267]                 }
[16:17:51.267]                 NAMES <- toupper(added)
[16:17:51.267]                 for (kk in seq_along(NAMES)) {
[16:17:51.267]                   name <- added[[kk]]
[16:17:51.267]                   NAME <- NAMES[[kk]]
[16:17:51.267]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.267]                     next
[16:17:51.267]                   args[[name]] <- ""
[16:17:51.267]                 }
[16:17:51.267]                 NAMES <- toupper(removed)
[16:17:51.267]                 for (kk in seq_along(NAMES)) {
[16:17:51.267]                   name <- removed[[kk]]
[16:17:51.267]                   NAME <- NAMES[[kk]]
[16:17:51.267]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.267]                     next
[16:17:51.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:51.267]                 }
[16:17:51.267]                 if (length(args) > 0) 
[16:17:51.267]                   base::do.call(base::Sys.setenv, args = args)
[16:17:51.267]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:51.267]             }
[16:17:51.267]             else {
[16:17:51.267]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:51.267]             }
[16:17:51.267]             {
[16:17:51.267]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:51.267]                   0L) {
[16:17:51.267]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:51.267]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:51.267]                   base::options(opts)
[16:17:51.267]                 }
[16:17:51.267]                 {
[16:17:51.267]                   {
[16:17:51.267]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:51.267]                     NULL
[16:17:51.267]                   }
[16:17:51.267]                   options(future.plan = NULL)
[16:17:51.267]                   if (is.na(NA_character_)) 
[16:17:51.267]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:51.267]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:51.267]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:51.267]                     .init = FALSE)
[16:17:51.267]                 }
[16:17:51.267]             }
[16:17:51.267]         }
[16:17:51.267]     })
[16:17:51.267]     if (TRUE) {
[16:17:51.267]         base::sink(type = "output", split = FALSE)
[16:17:51.267]         if (TRUE) {
[16:17:51.267]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:51.267]         }
[16:17:51.267]         else {
[16:17:51.267]             ...future.result["stdout"] <- base::list(NULL)
[16:17:51.267]         }
[16:17:51.267]         base::close(...future.stdout)
[16:17:51.267]         ...future.stdout <- NULL
[16:17:51.267]     }
[16:17:51.267]     ...future.result$conditions <- ...future.conditions
[16:17:51.267]     ...future.result$finished <- base::Sys.time()
[16:17:51.267]     ...future.result
[16:17:51.267] }
[16:17:51.321] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[16:17:51.321] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[16:17:51.322] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[16:17:51.322] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:17:51.322] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:17:51.323] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[16:17:51.323] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[16:17:51.323] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:17:51.324] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:17:51.324] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:17:51.324] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:17:51.324] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[16:17:51.325] MultisessionFuture started
[16:17:51.325] - Launch lazy future ... done
[16:17:51.325] run() for ‘MultisessionFuture’ ... done
[16:17:51.326] Created future:
[16:17:51.326] MultisessionFuture:
[16:17:51.326] Label: ‘future_eapply-2’
[16:17:51.326] Expression:
[16:17:51.326] {
[16:17:51.326]     do.call(function(...) {
[16:17:51.326]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:51.326]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:51.326]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:51.326]             on.exit(options(oopts), add = TRUE)
[16:17:51.326]         }
[16:17:51.326]         {
[16:17:51.326]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:51.326]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:51.326]                 ...future.FUN(...future.X_jj, ...)
[16:17:51.326]             })
[16:17:51.326]         }
[16:17:51.326]     }, args = future.call.arguments)
[16:17:51.326] }
[16:17:51.326] Lazy evaluation: FALSE
[16:17:51.326] Asynchronous evaluation: TRUE
[16:17:51.326] Local evaluation: TRUE
[16:17:51.326] Environment: R_GlobalEnv
[16:17:51.326] Capture standard output: TRUE
[16:17:51.326] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:51.326] Globals: 5 objects totaling 1.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:51.326] Packages: <none>
[16:17:51.326] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:51.326] Resolved: FALSE
[16:17:51.326] Value: <not collected>
[16:17:51.326] Conditions captured: <none>
[16:17:51.326] Early signaling: FALSE
[16:17:51.326] Owner process: 95d59565-e757-824f-7f5c-7f754384cffc
[16:17:51.326] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:51.338] Chunk #2 of 2 ... DONE
[16:17:51.338] Launching 2 futures (chunks) ... DONE
[16:17:51.338] Resolving 2 futures (chunks) ...
[16:17:51.338] resolve() on list ...
[16:17:51.338]  recursive: 0
[16:17:51.338]  length: 2
[16:17:51.338] 
[16:17:51.339] receiveMessageFromWorker() for ClusterFuture ...
[16:17:51.339] - Validating connection of MultisessionFuture
[16:17:51.339] - received message: FutureResult
[16:17:51.339] - Received FutureResult
[16:17:51.339] - Erased future from FutureRegistry
[16:17:51.340] result() for ClusterFuture ...
[16:17:51.340] - result already collected: FutureResult
[16:17:51.340] result() for ClusterFuture ... done
[16:17:51.340] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:51.340] Future #1
[16:17:51.340] result() for ClusterFuture ...
[16:17:51.340] - result already collected: FutureResult
[16:17:51.345] result() for ClusterFuture ... done
[16:17:51.345] result() for ClusterFuture ...
[16:17:51.345] - result already collected: FutureResult
[16:17:51.345] result() for ClusterFuture ... done
[16:17:51.345] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:17:51.345] - nx: 2
[16:17:51.345] - relay: TRUE
[16:17:51.345] - stdout: TRUE
[16:17:51.346] - signal: TRUE
[16:17:51.346] - resignal: FALSE
[16:17:51.346] - force: TRUE
[16:17:51.346] - relayed: [n=2] FALSE, FALSE
[16:17:51.346] - queued futures: [n=2] FALSE, FALSE
[16:17:51.346]  - until=1
[16:17:51.346]  - relaying element #1
[16:17:51.346] result() for ClusterFuture ...
[16:17:51.346] - result already collected: FutureResult
[16:17:51.346] result() for ClusterFuture ... done
[16:17:51.346] result() for ClusterFuture ...
[16:17:51.346] - result already collected: FutureResult
[16:17:51.347] result() for ClusterFuture ... done
[16:17:51.347] result() for ClusterFuture ...
[16:17:51.347] - result already collected: FutureResult
[16:17:51.347] result() for ClusterFuture ... done
[16:17:51.347] result() for ClusterFuture ...
[16:17:51.347] - result already collected: FutureResult
[16:17:51.347] result() for ClusterFuture ... done
[16:17:51.347] - relayed: [n=2] TRUE, FALSE
[16:17:51.347] - queued futures: [n=2] TRUE, FALSE
[16:17:51.347] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:17:51.347]  length: 1 (resolved future 1)
[16:17:51.410] receiveMessageFromWorker() for ClusterFuture ...
[16:17:51.410] - Validating connection of MultisessionFuture
[16:17:51.411] - received message: FutureResult
[16:17:51.411] - Received FutureResult
[16:17:51.411] - Erased future from FutureRegistry
[16:17:51.411] result() for ClusterFuture ...
[16:17:51.411] - result already collected: FutureResult
[16:17:51.411] result() for ClusterFuture ... done
[16:17:51.411] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:51.411] Future #2
[16:17:51.412] result() for ClusterFuture ...
[16:17:51.412] - result already collected: FutureResult
[16:17:51.412] result() for ClusterFuture ... done
[16:17:51.412] result() for ClusterFuture ...
[16:17:51.412] - result already collected: FutureResult
[16:17:51.412] result() for ClusterFuture ... done
[16:17:51.412] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:17:51.412] - nx: 2
[16:17:51.412] - relay: TRUE
[16:17:51.412] - stdout: TRUE
[16:17:51.412] - signal: TRUE
[16:17:51.413] - resignal: FALSE
[16:17:51.413] - force: TRUE
[16:17:51.413] - relayed: [n=2] TRUE, FALSE
[16:17:51.413] - queued futures: [n=2] TRUE, FALSE
[16:17:51.413]  - until=2
[16:17:51.413]  - relaying element #2
[16:17:51.413] result() for ClusterFuture ...
[16:17:51.413] - result already collected: FutureResult
[16:17:51.413] result() for ClusterFuture ... done
[16:17:51.413] result() for ClusterFuture ...
[16:17:51.413] - result already collected: FutureResult
[16:17:51.414] result() for ClusterFuture ... done
[16:17:51.414] result() for ClusterFuture ...
[16:17:51.414] - result already collected: FutureResult
[16:17:51.414] result() for ClusterFuture ... done
[16:17:51.414] result() for ClusterFuture ...
[16:17:51.414] - result already collected: FutureResult
[16:17:51.414] result() for ClusterFuture ... done
[16:17:51.414] - relayed: [n=2] TRUE, TRUE
[16:17:51.414] - queued futures: [n=2] TRUE, TRUE
[16:17:51.414] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:17:51.414]  length: 0 (resolved future 2)
[16:17:51.415] Relaying remaining futures
[16:17:51.415] signalConditionsASAP(NULL, pos=0) ...
[16:17:51.415] - nx: 2
[16:17:51.415] - relay: TRUE
[16:17:51.415] - stdout: TRUE
[16:17:51.415] - signal: TRUE
[16:17:51.415] - resignal: FALSE
[16:17:51.415] - force: TRUE
[16:17:51.415] - relayed: [n=2] TRUE, TRUE
[16:17:51.415] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:51.415] - relayed: [n=2] TRUE, TRUE
[16:17:51.416] - queued futures: [n=2] TRUE, TRUE
[16:17:51.416] signalConditionsASAP(NULL, pos=0) ... done
[16:17:51.416] resolve() on list ... DONE
[16:17:51.416] result() for ClusterFuture ...
[16:17:51.416] - result already collected: FutureResult
[16:17:51.416] result() for ClusterFuture ... done
[16:17:51.416] result() for ClusterFuture ...
[16:17:51.416] - result already collected: FutureResult
[16:17:51.416] result() for ClusterFuture ... done
[16:17:51.416] result() for ClusterFuture ...
[16:17:51.416] - result already collected: FutureResult
[16:17:51.417] result() for ClusterFuture ... done
[16:17:51.417] result() for ClusterFuture ...
[16:17:51.417] - result already collected: FutureResult
[16:17:51.417] result() for ClusterFuture ... done
[16:17:51.417]  - Number of value chunks collected: 2
[16:17:51.417] Resolving 2 futures (chunks) ... DONE
[16:17:51.417] Reducing values from 2 chunks ...
[16:17:51.417]  - Number of values collected after concatenation: 3
[16:17:51.417]  - Number of values expected: 3
[16:17:51.417] Reducing values from 2 chunks ... DONE
[16:17:51.418] future_lapply() ... DONE
[16:17:51.418] future_lapply() ...
[16:17:51.422] Number of chunks: 2
[16:17:51.422] getGlobalsAndPackagesXApply() ...
[16:17:51.423]  - future.globals: TRUE
[16:17:51.423] getGlobalsAndPackages() ...
[16:17:51.423] Searching for globals...
[16:17:51.424] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:51.424] Searching for globals ... DONE
[16:17:51.424] Resolving globals: FALSE
[16:17:51.424] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:17:51.425] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:17:51.425] - globals: [1] ‘FUN’
[16:17:51.425] - packages: [1] ‘stats’
[16:17:51.425] getGlobalsAndPackages() ... DONE
[16:17:51.425]  - globals found/used: [n=1] ‘FUN’
[16:17:51.425]  - needed namespaces: [n=1] ‘stats’
[16:17:51.425] Finding globals ... DONE
[16:17:51.426]  - use_args: TRUE
[16:17:51.426]  - Getting '...' globals ...
[16:17:51.426] resolve() on list ...
[16:17:51.426]  recursive: 0
[16:17:51.426]  length: 1
[16:17:51.426]  elements: ‘...’
[16:17:51.426]  length: 0 (resolved future 1)
[16:17:51.427] resolve() on list ... DONE
[16:17:51.427]    - '...' content: [n=1] ‘probs’
[16:17:51.427] List of 1
[16:17:51.427]  $ ...:List of 1
[16:17:51.427]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:17:51.427]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:51.427]  - attr(*, "where")=List of 1
[16:17:51.427]   ..$ ...:<environment: 0x556da4d9f018> 
[16:17:51.427]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:51.427]  - attr(*, "resolved")= logi TRUE
[16:17:51.427]  - attr(*, "total_size")= num NA
[16:17:51.430]  - Getting '...' globals ... DONE
[16:17:51.430] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:51.430] List of 2
[16:17:51.430]  $ ...future.FUN:function (x, ...)  
[16:17:51.430]  $ ...          :List of 1
[16:17:51.430]   ..$ probs: num [1:3] 0.25 0.5 0.75
[16:17:51.430]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:51.430]  - attr(*, "where")=List of 2
[16:17:51.430]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:51.430]   ..$ ...          :<environment: 0x556da4d9f018> 
[16:17:51.430]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:51.430]  - attr(*, "resolved")= logi FALSE
[16:17:51.430]  - attr(*, "total_size")= num 1328
[16:17:51.433] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:51.433] getGlobalsAndPackagesXApply() ... DONE
[16:17:51.433] Number of futures (= number of chunks): 2
[16:17:51.434] Launching 2 futures (chunks) ...
[16:17:51.434] Chunk #1 of 2 ...
[16:17:51.434]  - Finding globals in 'X' for chunk #1 ...
[16:17:51.434] getGlobalsAndPackages() ...
[16:17:51.434] Searching for globals...
[16:17:51.434] 
[16:17:51.434] Searching for globals ... DONE
[16:17:51.434] - globals: [0] <none>
[16:17:51.435] getGlobalsAndPackages() ... DONE
[16:17:51.435]    + additional globals found: [n=0] 
[16:17:51.435]    + additional namespaces needed: [n=0] 
[16:17:51.435]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:51.435]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:51.435]  - seeds: <none>
[16:17:51.435]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:51.435] getGlobalsAndPackages() ...
[16:17:51.435] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:51.435] Resolving globals: FALSE
[16:17:51.436] Tweak future expression to call with '...' arguments ...
[16:17:51.436] {
[16:17:51.436]     do.call(function(...) {
[16:17:51.436]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:51.436]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:51.436]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:51.436]             on.exit(options(oopts), add = TRUE)
[16:17:51.436]         }
[16:17:51.436]         {
[16:17:51.436]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:51.436]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:51.436]                 ...future.FUN(...future.X_jj, ...)
[16:17:51.436]             })
[16:17:51.436]         }
[16:17:51.436]     }, args = future.call.arguments)
[16:17:51.436] }
[16:17:51.436] Tweak future expression to call with '...' arguments ... DONE
[16:17:51.436] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:51.436] - packages: [1] ‘stats’
[16:17:51.437] getGlobalsAndPackages() ... DONE
[16:17:51.437] run() for ‘Future’ ...
[16:17:51.437] - state: ‘created’
[16:17:51.437] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:51.451] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:51.451] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:51.451]   - Field: ‘node’
[16:17:51.451]   - Field: ‘label’
[16:17:51.451]   - Field: ‘local’
[16:17:51.452]   - Field: ‘owner’
[16:17:51.452]   - Field: ‘envir’
[16:17:51.452]   - Field: ‘workers’
[16:17:51.452]   - Field: ‘packages’
[16:17:51.452]   - Field: ‘gc’
[16:17:51.452]   - Field: ‘conditions’
[16:17:51.452]   - Field: ‘persistent’
[16:17:51.452]   - Field: ‘expr’
[16:17:51.452]   - Field: ‘uuid’
[16:17:51.453]   - Field: ‘seed’
[16:17:51.453]   - Field: ‘version’
[16:17:51.453]   - Field: ‘result’
[16:17:51.453]   - Field: ‘asynchronous’
[16:17:51.453]   - Field: ‘calls’
[16:17:51.453]   - Field: ‘globals’
[16:17:51.453]   - Field: ‘stdout’
[16:17:51.453]   - Field: ‘earlySignal’
[16:17:51.453]   - Field: ‘lazy’
[16:17:51.453]   - Field: ‘state’
[16:17:51.453] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:51.454] - Launch lazy future ...
[16:17:51.454] Packages needed by the future expression (n = 1): ‘stats’
[16:17:51.454] Packages needed by future strategies (n = 0): <none>
[16:17:51.455] {
[16:17:51.455]     {
[16:17:51.455]         {
[16:17:51.455]             ...future.startTime <- base::Sys.time()
[16:17:51.455]             {
[16:17:51.455]                 {
[16:17:51.455]                   {
[16:17:51.455]                     {
[16:17:51.455]                       {
[16:17:51.455]                         base::local({
[16:17:51.455]                           has_future <- base::requireNamespace("future", 
[16:17:51.455]                             quietly = TRUE)
[16:17:51.455]                           if (has_future) {
[16:17:51.455]                             ns <- base::getNamespace("future")
[16:17:51.455]                             version <- ns[[".package"]][["version"]]
[16:17:51.455]                             if (is.null(version)) 
[16:17:51.455]                               version <- utils::packageVersion("future")
[16:17:51.455]                           }
[16:17:51.455]                           else {
[16:17:51.455]                             version <- NULL
[16:17:51.455]                           }
[16:17:51.455]                           if (!has_future || version < "1.8.0") {
[16:17:51.455]                             info <- base::c(r_version = base::gsub("R version ", 
[16:17:51.455]                               "", base::R.version$version.string), 
[16:17:51.455]                               platform = base::sprintf("%s (%s-bit)", 
[16:17:51.455]                                 base::R.version$platform, 8 * 
[16:17:51.455]                                   base::.Machine$sizeof.pointer), 
[16:17:51.455]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:51.455]                                 "release", "version")], collapse = " "), 
[16:17:51.455]                               hostname = base::Sys.info()[["nodename"]])
[16:17:51.455]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:17:51.455]                               info)
[16:17:51.455]                             info <- base::paste(info, collapse = "; ")
[16:17:51.455]                             if (!has_future) {
[16:17:51.455]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:51.455]                                 info)
[16:17:51.455]                             }
[16:17:51.455]                             else {
[16:17:51.455]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:51.455]                                 info, version)
[16:17:51.455]                             }
[16:17:51.455]                             base::stop(msg)
[16:17:51.455]                           }
[16:17:51.455]                         })
[16:17:51.455]                       }
[16:17:51.455]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:51.455]                       base::options(mc.cores = 1L)
[16:17:51.455]                     }
[16:17:51.455]                     base::local({
[16:17:51.455]                       for (pkg in "stats") {
[16:17:51.455]                         base::loadNamespace(pkg)
[16:17:51.455]                         base::library(pkg, character.only = TRUE)
[16:17:51.455]                       }
[16:17:51.455]                     })
[16:17:51.455]                   }
[16:17:51.455]                   ...future.strategy.old <- future::plan("list")
[16:17:51.455]                   options(future.plan = NULL)
[16:17:51.455]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:51.455]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:51.455]                 }
[16:17:51.455]                 ...future.workdir <- getwd()
[16:17:51.455]             }
[16:17:51.455]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:51.455]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:51.455]         }
[16:17:51.455]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:51.455]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:51.455]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:51.455]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:51.455]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:51.455]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:51.455]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:51.455]             base::names(...future.oldOptions))
[16:17:51.455]     }
[16:17:51.455]     if (FALSE) {
[16:17:51.455]     }
[16:17:51.455]     else {
[16:17:51.455]         if (TRUE) {
[16:17:51.455]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:51.455]                 open = "w")
[16:17:51.455]         }
[16:17:51.455]         else {
[16:17:51.455]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:51.455]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:51.455]         }
[16:17:51.455]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:51.455]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:51.455]             base::sink(type = "output", split = FALSE)
[16:17:51.455]             base::close(...future.stdout)
[16:17:51.455]         }, add = TRUE)
[16:17:51.455]     }
[16:17:51.455]     ...future.frame <- base::sys.nframe()
[16:17:51.455]     ...future.conditions <- base::list()
[16:17:51.455]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:51.455]     if (FALSE) {
[16:17:51.455]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:51.455]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:51.455]     }
[16:17:51.455]     ...future.result <- base::tryCatch({
[16:17:51.455]         base::withCallingHandlers({
[16:17:51.455]             ...future.value <- base::withVisible(base::local({
[16:17:51.455]                 ...future.makeSendCondition <- base::local({
[16:17:51.455]                   sendCondition <- NULL
[16:17:51.455]                   function(frame = 1L) {
[16:17:51.455]                     if (is.function(sendCondition)) 
[16:17:51.455]                       return(sendCondition)
[16:17:51.455]                     ns <- getNamespace("parallel")
[16:17:51.455]                     if (exists("sendData", mode = "function", 
[16:17:51.455]                       envir = ns)) {
[16:17:51.455]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:51.455]                         envir = ns)
[16:17:51.455]                       envir <- sys.frame(frame)
[16:17:51.455]                       master <- NULL
[16:17:51.455]                       while (!identical(envir, .GlobalEnv) && 
[16:17:51.455]                         !identical(envir, emptyenv())) {
[16:17:51.455]                         if (exists("master", mode = "list", envir = envir, 
[16:17:51.455]                           inherits = FALSE)) {
[16:17:51.455]                           master <- get("master", mode = "list", 
[16:17:51.455]                             envir = envir, inherits = FALSE)
[16:17:51.455]                           if (inherits(master, c("SOCKnode", 
[16:17:51.455]                             "SOCK0node"))) {
[16:17:51.455]                             sendCondition <<- function(cond) {
[16:17:51.455]                               data <- list(type = "VALUE", value = cond, 
[16:17:51.455]                                 success = TRUE)
[16:17:51.455]                               parallel_sendData(master, data)
[16:17:51.455]                             }
[16:17:51.455]                             return(sendCondition)
[16:17:51.455]                           }
[16:17:51.455]                         }
[16:17:51.455]                         frame <- frame + 1L
[16:17:51.455]                         envir <- sys.frame(frame)
[16:17:51.455]                       }
[16:17:51.455]                     }
[16:17:51.455]                     sendCondition <<- function(cond) NULL
[16:17:51.455]                   }
[16:17:51.455]                 })
[16:17:51.455]                 withCallingHandlers({
[16:17:51.455]                   {
[16:17:51.455]                     do.call(function(...) {
[16:17:51.455]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:51.455]                       if (!identical(...future.globals.maxSize.org, 
[16:17:51.455]                         ...future.globals.maxSize)) {
[16:17:51.455]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:51.455]                         on.exit(options(oopts), add = TRUE)
[16:17:51.455]                       }
[16:17:51.455]                       {
[16:17:51.455]                         lapply(seq_along(...future.elements_ii), 
[16:17:51.455]                           FUN = function(jj) {
[16:17:51.455]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:51.455]                             ...future.FUN(...future.X_jj, ...)
[16:17:51.455]                           })
[16:17:51.455]                       }
[16:17:51.455]                     }, args = future.call.arguments)
[16:17:51.455]                   }
[16:17:51.455]                 }, immediateCondition = function(cond) {
[16:17:51.455]                   sendCondition <- ...future.makeSendCondition()
[16:17:51.455]                   sendCondition(cond)
[16:17:51.455]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.455]                   {
[16:17:51.455]                     inherits <- base::inherits
[16:17:51.455]                     invokeRestart <- base::invokeRestart
[16:17:51.455]                     is.null <- base::is.null
[16:17:51.455]                     muffled <- FALSE
[16:17:51.455]                     if (inherits(cond, "message")) {
[16:17:51.455]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:51.455]                       if (muffled) 
[16:17:51.455]                         invokeRestart("muffleMessage")
[16:17:51.455]                     }
[16:17:51.455]                     else if (inherits(cond, "warning")) {
[16:17:51.455]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:51.455]                       if (muffled) 
[16:17:51.455]                         invokeRestart("muffleWarning")
[16:17:51.455]                     }
[16:17:51.455]                     else if (inherits(cond, "condition")) {
[16:17:51.455]                       if (!is.null(pattern)) {
[16:17:51.455]                         computeRestarts <- base::computeRestarts
[16:17:51.455]                         grepl <- base::grepl
[16:17:51.455]                         restarts <- computeRestarts(cond)
[16:17:51.455]                         for (restart in restarts) {
[16:17:51.455]                           name <- restart$name
[16:17:51.455]                           if (is.null(name)) 
[16:17:51.455]                             next
[16:17:51.455]                           if (!grepl(pattern, name)) 
[16:17:51.455]                             next
[16:17:51.455]                           invokeRestart(restart)
[16:17:51.455]                           muffled <- TRUE
[16:17:51.455]                           break
[16:17:51.455]                         }
[16:17:51.455]                       }
[16:17:51.455]                     }
[16:17:51.455]                     invisible(muffled)
[16:17:51.455]                   }
[16:17:51.455]                   muffleCondition(cond)
[16:17:51.455]                 })
[16:17:51.455]             }))
[16:17:51.455]             future::FutureResult(value = ...future.value$value, 
[16:17:51.455]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:51.455]                   ...future.rng), globalenv = if (FALSE) 
[16:17:51.455]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:51.455]                     ...future.globalenv.names))
[16:17:51.455]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:51.455]         }, condition = base::local({
[16:17:51.455]             c <- base::c
[16:17:51.455]             inherits <- base::inherits
[16:17:51.455]             invokeRestart <- base::invokeRestart
[16:17:51.455]             length <- base::length
[16:17:51.455]             list <- base::list
[16:17:51.455]             seq.int <- base::seq.int
[16:17:51.455]             signalCondition <- base::signalCondition
[16:17:51.455]             sys.calls <- base::sys.calls
[16:17:51.455]             `[[` <- base::`[[`
[16:17:51.455]             `+` <- base::`+`
[16:17:51.455]             `<<-` <- base::`<<-`
[16:17:51.455]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:51.455]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:51.455]                   3L)]
[16:17:51.455]             }
[16:17:51.455]             function(cond) {
[16:17:51.455]                 is_error <- inherits(cond, "error")
[16:17:51.455]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:51.455]                   NULL)
[16:17:51.455]                 if (is_error) {
[16:17:51.455]                   sessionInformation <- function() {
[16:17:51.455]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:51.455]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:51.455]                       search = base::search(), system = base::Sys.info())
[16:17:51.455]                   }
[16:17:51.455]                   ...future.conditions[[length(...future.conditions) + 
[16:17:51.455]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:51.455]                     cond$call), session = sessionInformation(), 
[16:17:51.455]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:51.455]                   signalCondition(cond)
[16:17:51.455]                 }
[16:17:51.455]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:51.455]                 "immediateCondition"))) {
[16:17:51.455]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:51.455]                   ...future.conditions[[length(...future.conditions) + 
[16:17:51.455]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:51.455]                   if (TRUE && !signal) {
[16:17:51.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.455]                     {
[16:17:51.455]                       inherits <- base::inherits
[16:17:51.455]                       invokeRestart <- base::invokeRestart
[16:17:51.455]                       is.null <- base::is.null
[16:17:51.455]                       muffled <- FALSE
[16:17:51.455]                       if (inherits(cond, "message")) {
[16:17:51.455]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:51.455]                         if (muffled) 
[16:17:51.455]                           invokeRestart("muffleMessage")
[16:17:51.455]                       }
[16:17:51.455]                       else if (inherits(cond, "warning")) {
[16:17:51.455]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:51.455]                         if (muffled) 
[16:17:51.455]                           invokeRestart("muffleWarning")
[16:17:51.455]                       }
[16:17:51.455]                       else if (inherits(cond, "condition")) {
[16:17:51.455]                         if (!is.null(pattern)) {
[16:17:51.455]                           computeRestarts <- base::computeRestarts
[16:17:51.455]                           grepl <- base::grepl
[16:17:51.455]                           restarts <- computeRestarts(cond)
[16:17:51.455]                           for (restart in restarts) {
[16:17:51.455]                             name <- restart$name
[16:17:51.455]                             if (is.null(name)) 
[16:17:51.455]                               next
[16:17:51.455]                             if (!grepl(pattern, name)) 
[16:17:51.455]                               next
[16:17:51.455]                             invokeRestart(restart)
[16:17:51.455]                             muffled <- TRUE
[16:17:51.455]                             break
[16:17:51.455]                           }
[16:17:51.455]                         }
[16:17:51.455]                       }
[16:17:51.455]                       invisible(muffled)
[16:17:51.455]                     }
[16:17:51.455]                     muffleCondition(cond, pattern = "^muffle")
[16:17:51.455]                   }
[16:17:51.455]                 }
[16:17:51.455]                 else {
[16:17:51.455]                   if (TRUE) {
[16:17:51.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.455]                     {
[16:17:51.455]                       inherits <- base::inherits
[16:17:51.455]                       invokeRestart <- base::invokeRestart
[16:17:51.455]                       is.null <- base::is.null
[16:17:51.455]                       muffled <- FALSE
[16:17:51.455]                       if (inherits(cond, "message")) {
[16:17:51.455]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:51.455]                         if (muffled) 
[16:17:51.455]                           invokeRestart("muffleMessage")
[16:17:51.455]                       }
[16:17:51.455]                       else if (inherits(cond, "warning")) {
[16:17:51.455]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:51.455]                         if (muffled) 
[16:17:51.455]                           invokeRestart("muffleWarning")
[16:17:51.455]                       }
[16:17:51.455]                       else if (inherits(cond, "condition")) {
[16:17:51.455]                         if (!is.null(pattern)) {
[16:17:51.455]                           computeRestarts <- base::computeRestarts
[16:17:51.455]                           grepl <- base::grepl
[16:17:51.455]                           restarts <- computeRestarts(cond)
[16:17:51.455]                           for (restart in restarts) {
[16:17:51.455]                             name <- restart$name
[16:17:51.455]                             if (is.null(name)) 
[16:17:51.455]                               next
[16:17:51.455]                             if (!grepl(pattern, name)) 
[16:17:51.455]                               next
[16:17:51.455]                             invokeRestart(restart)
[16:17:51.455]                             muffled <- TRUE
[16:17:51.455]                             break
[16:17:51.455]                           }
[16:17:51.455]                         }
[16:17:51.455]                       }
[16:17:51.455]                       invisible(muffled)
[16:17:51.455]                     }
[16:17:51.455]                     muffleCondition(cond, pattern = "^muffle")
[16:17:51.455]                   }
[16:17:51.455]                 }
[16:17:51.455]             }
[16:17:51.455]         }))
[16:17:51.455]     }, error = function(ex) {
[16:17:51.455]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:51.455]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:51.455]                 ...future.rng), started = ...future.startTime, 
[16:17:51.455]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:51.455]             version = "1.8"), class = "FutureResult")
[16:17:51.455]     }, finally = {
[16:17:51.455]         if (!identical(...future.workdir, getwd())) 
[16:17:51.455]             setwd(...future.workdir)
[16:17:51.455]         {
[16:17:51.455]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:51.455]                 ...future.oldOptions$nwarnings <- NULL
[16:17:51.455]             }
[16:17:51.455]             base::options(...future.oldOptions)
[16:17:51.455]             if (.Platform$OS.type == "windows") {
[16:17:51.455]                 old_names <- names(...future.oldEnvVars)
[16:17:51.455]                 envs <- base::Sys.getenv()
[16:17:51.455]                 names <- names(envs)
[16:17:51.455]                 common <- intersect(names, old_names)
[16:17:51.455]                 added <- setdiff(names, old_names)
[16:17:51.455]                 removed <- setdiff(old_names, names)
[16:17:51.455]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:51.455]                   envs[common]]
[16:17:51.455]                 NAMES <- toupper(changed)
[16:17:51.455]                 args <- list()
[16:17:51.455]                 for (kk in seq_along(NAMES)) {
[16:17:51.455]                   name <- changed[[kk]]
[16:17:51.455]                   NAME <- NAMES[[kk]]
[16:17:51.455]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.455]                     next
[16:17:51.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:51.455]                 }
[16:17:51.455]                 NAMES <- toupper(added)
[16:17:51.455]                 for (kk in seq_along(NAMES)) {
[16:17:51.455]                   name <- added[[kk]]
[16:17:51.455]                   NAME <- NAMES[[kk]]
[16:17:51.455]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.455]                     next
[16:17:51.455]                   args[[name]] <- ""
[16:17:51.455]                 }
[16:17:51.455]                 NAMES <- toupper(removed)
[16:17:51.455]                 for (kk in seq_along(NAMES)) {
[16:17:51.455]                   name <- removed[[kk]]
[16:17:51.455]                   NAME <- NAMES[[kk]]
[16:17:51.455]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.455]                     next
[16:17:51.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:51.455]                 }
[16:17:51.455]                 if (length(args) > 0) 
[16:17:51.455]                   base::do.call(base::Sys.setenv, args = args)
[16:17:51.455]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:51.455]             }
[16:17:51.455]             else {
[16:17:51.455]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:51.455]             }
[16:17:51.455]             {
[16:17:51.455]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:51.455]                   0L) {
[16:17:51.455]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:51.455]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:51.455]                   base::options(opts)
[16:17:51.455]                 }
[16:17:51.455]                 {
[16:17:51.455]                   {
[16:17:51.455]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:51.455]                     NULL
[16:17:51.455]                   }
[16:17:51.455]                   options(future.plan = NULL)
[16:17:51.455]                   if (is.na(NA_character_)) 
[16:17:51.455]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:51.455]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:51.455]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:51.455]                     .init = FALSE)
[16:17:51.455]                 }
[16:17:51.455]             }
[16:17:51.455]         }
[16:17:51.455]     })
[16:17:51.455]     if (TRUE) {
[16:17:51.455]         base::sink(type = "output", split = FALSE)
[16:17:51.455]         if (TRUE) {
[16:17:51.455]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:51.455]         }
[16:17:51.455]         else {
[16:17:51.455]             ...future.result["stdout"] <- base::list(NULL)
[16:17:51.455]         }
[16:17:51.455]         base::close(...future.stdout)
[16:17:51.455]         ...future.stdout <- NULL
[16:17:51.455]     }
[16:17:51.455]     ...future.result$conditions <- ...future.conditions
[16:17:51.455]     ...future.result$finished <- base::Sys.time()
[16:17:51.455]     ...future.result
[16:17:51.455] }
[16:17:51.457] Exporting 5 global objects (1.30 KiB) to cluster node #1 ...
[16:17:51.457] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[16:17:51.458] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[16:17:51.458] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #1 ...
[16:17:51.458] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #1 ... DONE
[16:17:51.458] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[16:17:51.459] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[16:17:51.459] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:17:51.459] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:17:51.459] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:17:51.460] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:17:51.460] Exporting 5 global objects (1.30 KiB) to cluster node #1 ... DONE
[16:17:51.460] MultisessionFuture started
[16:17:51.460] - Launch lazy future ... done
[16:17:51.460] run() for ‘MultisessionFuture’ ... done
[16:17:51.461] Created future:
[16:17:51.461] MultisessionFuture:
[16:17:51.461] Label: ‘future_eapply-1’
[16:17:51.461] Expression:
[16:17:51.461] {
[16:17:51.461]     do.call(function(...) {
[16:17:51.461]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:51.461]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:51.461]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:51.461]             on.exit(options(oopts), add = TRUE)
[16:17:51.461]         }
[16:17:51.461]         {
[16:17:51.461]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:51.461]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:51.461]                 ...future.FUN(...future.X_jj, ...)
[16:17:51.461]             })
[16:17:51.461]         }
[16:17:51.461]     }, args = future.call.arguments)
[16:17:51.461] }
[16:17:51.461] Lazy evaluation: FALSE
[16:17:51.461] Asynchronous evaluation: TRUE
[16:17:51.461] Local evaluation: TRUE
[16:17:51.461] Environment: R_GlobalEnv
[16:17:51.461] Capture standard output: TRUE
[16:17:51.461] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:51.461] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:51.461] Packages: 1 packages (‘stats’)
[16:17:51.461] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:51.461] Resolved: FALSE
[16:17:51.461] Value: <not collected>
[16:17:51.461] Conditions captured: <none>
[16:17:51.461] Early signaling: FALSE
[16:17:51.461] Owner process: 95d59565-e757-824f-7f5c-7f754384cffc
[16:17:51.461] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:51.472] Chunk #1 of 2 ... DONE
[16:17:51.472] Chunk #2 of 2 ...
[16:17:51.473]  - Finding globals in 'X' for chunk #2 ...
[16:17:51.473] getGlobalsAndPackages() ...
[16:17:51.473] Searching for globals...
[16:17:51.473] 
[16:17:51.473] Searching for globals ... DONE
[16:17:51.473] - globals: [0] <none>
[16:17:51.473] getGlobalsAndPackages() ... DONE
[16:17:51.473]    + additional globals found: [n=0] 
[16:17:51.474]    + additional namespaces needed: [n=0] 
[16:17:51.474]  - Finding globals in 'X' for chunk #2 ... DONE
[16:17:51.474]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:51.474]  - seeds: <none>
[16:17:51.474]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:51.474] getGlobalsAndPackages() ...
[16:17:51.474] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:51.474] Resolving globals: FALSE
[16:17:51.474] Tweak future expression to call with '...' arguments ...
[16:17:51.474] {
[16:17:51.474]     do.call(function(...) {
[16:17:51.474]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:51.474]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:51.474]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:51.474]             on.exit(options(oopts), add = TRUE)
[16:17:51.474]         }
[16:17:51.474]         {
[16:17:51.474]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:51.474]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:51.474]                 ...future.FUN(...future.X_jj, ...)
[16:17:51.474]             })
[16:17:51.474]         }
[16:17:51.474]     }, args = future.call.arguments)
[16:17:51.474] }
[16:17:51.475] Tweak future expression to call with '...' arguments ... DONE
[16:17:51.475] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:51.475] - packages: [1] ‘stats’
[16:17:51.475] getGlobalsAndPackages() ... DONE
[16:17:51.476] run() for ‘Future’ ...
[16:17:51.476] - state: ‘created’
[16:17:51.476] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:51.490] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:51.490] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:51.491]   - Field: ‘node’
[16:17:51.491]   - Field: ‘label’
[16:17:51.491]   - Field: ‘local’
[16:17:51.491]   - Field: ‘owner’
[16:17:51.491]   - Field: ‘envir’
[16:17:51.491]   - Field: ‘workers’
[16:17:51.491]   - Field: ‘packages’
[16:17:51.492]   - Field: ‘gc’
[16:17:51.492]   - Field: ‘conditions’
[16:17:51.492]   - Field: ‘persistent’
[16:17:51.492]   - Field: ‘expr’
[16:17:51.492]   - Field: ‘uuid’
[16:17:51.492]   - Field: ‘seed’
[16:17:51.492]   - Field: ‘version’
[16:17:51.493]   - Field: ‘result’
[16:17:51.493]   - Field: ‘asynchronous’
[16:17:51.493]   - Field: ‘calls’
[16:17:51.493]   - Field: ‘globals’
[16:17:51.493]   - Field: ‘stdout’
[16:17:51.493]   - Field: ‘earlySignal’
[16:17:51.493]   - Field: ‘lazy’
[16:17:51.494]   - Field: ‘state’
[16:17:51.494] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:51.494] - Launch lazy future ...
[16:17:51.494] Packages needed by the future expression (n = 1): ‘stats’
[16:17:51.494] Packages needed by future strategies (n = 0): <none>
[16:17:51.495] {
[16:17:51.495]     {
[16:17:51.495]         {
[16:17:51.495]             ...future.startTime <- base::Sys.time()
[16:17:51.495]             {
[16:17:51.495]                 {
[16:17:51.495]                   {
[16:17:51.495]                     {
[16:17:51.495]                       {
[16:17:51.495]                         base::local({
[16:17:51.495]                           has_future <- base::requireNamespace("future", 
[16:17:51.495]                             quietly = TRUE)
[16:17:51.495]                           if (has_future) {
[16:17:51.495]                             ns <- base::getNamespace("future")
[16:17:51.495]                             version <- ns[[".package"]][["version"]]
[16:17:51.495]                             if (is.null(version)) 
[16:17:51.495]                               version <- utils::packageVersion("future")
[16:17:51.495]                           }
[16:17:51.495]                           else {
[16:17:51.495]                             version <- NULL
[16:17:51.495]                           }
[16:17:51.495]                           if (!has_future || version < "1.8.0") {
[16:17:51.495]                             info <- base::c(r_version = base::gsub("R version ", 
[16:17:51.495]                               "", base::R.version$version.string), 
[16:17:51.495]                               platform = base::sprintf("%s (%s-bit)", 
[16:17:51.495]                                 base::R.version$platform, 8 * 
[16:17:51.495]                                   base::.Machine$sizeof.pointer), 
[16:17:51.495]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:51.495]                                 "release", "version")], collapse = " "), 
[16:17:51.495]                               hostname = base::Sys.info()[["nodename"]])
[16:17:51.495]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:17:51.495]                               info)
[16:17:51.495]                             info <- base::paste(info, collapse = "; ")
[16:17:51.495]                             if (!has_future) {
[16:17:51.495]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:51.495]                                 info)
[16:17:51.495]                             }
[16:17:51.495]                             else {
[16:17:51.495]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:51.495]                                 info, version)
[16:17:51.495]                             }
[16:17:51.495]                             base::stop(msg)
[16:17:51.495]                           }
[16:17:51.495]                         })
[16:17:51.495]                       }
[16:17:51.495]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:51.495]                       base::options(mc.cores = 1L)
[16:17:51.495]                     }
[16:17:51.495]                     base::local({
[16:17:51.495]                       for (pkg in "stats") {
[16:17:51.495]                         base::loadNamespace(pkg)
[16:17:51.495]                         base::library(pkg, character.only = TRUE)
[16:17:51.495]                       }
[16:17:51.495]                     })
[16:17:51.495]                   }
[16:17:51.495]                   ...future.strategy.old <- future::plan("list")
[16:17:51.495]                   options(future.plan = NULL)
[16:17:51.495]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:51.495]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:51.495]                 }
[16:17:51.495]                 ...future.workdir <- getwd()
[16:17:51.495]             }
[16:17:51.495]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:51.495]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:51.495]         }
[16:17:51.495]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:51.495]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:51.495]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:51.495]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:51.495]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:51.495]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:51.495]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:51.495]             base::names(...future.oldOptions))
[16:17:51.495]     }
[16:17:51.495]     if (FALSE) {
[16:17:51.495]     }
[16:17:51.495]     else {
[16:17:51.495]         if (TRUE) {
[16:17:51.495]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:51.495]                 open = "w")
[16:17:51.495]         }
[16:17:51.495]         else {
[16:17:51.495]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:51.495]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:51.495]         }
[16:17:51.495]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:51.495]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:51.495]             base::sink(type = "output", split = FALSE)
[16:17:51.495]             base::close(...future.stdout)
[16:17:51.495]         }, add = TRUE)
[16:17:51.495]     }
[16:17:51.495]     ...future.frame <- base::sys.nframe()
[16:17:51.495]     ...future.conditions <- base::list()
[16:17:51.495]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:51.495]     if (FALSE) {
[16:17:51.495]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:51.495]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:51.495]     }
[16:17:51.495]     ...future.result <- base::tryCatch({
[16:17:51.495]         base::withCallingHandlers({
[16:17:51.495]             ...future.value <- base::withVisible(base::local({
[16:17:51.495]                 ...future.makeSendCondition <- base::local({
[16:17:51.495]                   sendCondition <- NULL
[16:17:51.495]                   function(frame = 1L) {
[16:17:51.495]                     if (is.function(sendCondition)) 
[16:17:51.495]                       return(sendCondition)
[16:17:51.495]                     ns <- getNamespace("parallel")
[16:17:51.495]                     if (exists("sendData", mode = "function", 
[16:17:51.495]                       envir = ns)) {
[16:17:51.495]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:51.495]                         envir = ns)
[16:17:51.495]                       envir <- sys.frame(frame)
[16:17:51.495]                       master <- NULL
[16:17:51.495]                       while (!identical(envir, .GlobalEnv) && 
[16:17:51.495]                         !identical(envir, emptyenv())) {
[16:17:51.495]                         if (exists("master", mode = "list", envir = envir, 
[16:17:51.495]                           inherits = FALSE)) {
[16:17:51.495]                           master <- get("master", mode = "list", 
[16:17:51.495]                             envir = envir, inherits = FALSE)
[16:17:51.495]                           if (inherits(master, c("SOCKnode", 
[16:17:51.495]                             "SOCK0node"))) {
[16:17:51.495]                             sendCondition <<- function(cond) {
[16:17:51.495]                               data <- list(type = "VALUE", value = cond, 
[16:17:51.495]                                 success = TRUE)
[16:17:51.495]                               parallel_sendData(master, data)
[16:17:51.495]                             }
[16:17:51.495]                             return(sendCondition)
[16:17:51.495]                           }
[16:17:51.495]                         }
[16:17:51.495]                         frame <- frame + 1L
[16:17:51.495]                         envir <- sys.frame(frame)
[16:17:51.495]                       }
[16:17:51.495]                     }
[16:17:51.495]                     sendCondition <<- function(cond) NULL
[16:17:51.495]                   }
[16:17:51.495]                 })
[16:17:51.495]                 withCallingHandlers({
[16:17:51.495]                   {
[16:17:51.495]                     do.call(function(...) {
[16:17:51.495]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:51.495]                       if (!identical(...future.globals.maxSize.org, 
[16:17:51.495]                         ...future.globals.maxSize)) {
[16:17:51.495]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:51.495]                         on.exit(options(oopts), add = TRUE)
[16:17:51.495]                       }
[16:17:51.495]                       {
[16:17:51.495]                         lapply(seq_along(...future.elements_ii), 
[16:17:51.495]                           FUN = function(jj) {
[16:17:51.495]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:51.495]                             ...future.FUN(...future.X_jj, ...)
[16:17:51.495]                           })
[16:17:51.495]                       }
[16:17:51.495]                     }, args = future.call.arguments)
[16:17:51.495]                   }
[16:17:51.495]                 }, immediateCondition = function(cond) {
[16:17:51.495]                   sendCondition <- ...future.makeSendCondition()
[16:17:51.495]                   sendCondition(cond)
[16:17:51.495]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.495]                   {
[16:17:51.495]                     inherits <- base::inherits
[16:17:51.495]                     invokeRestart <- base::invokeRestart
[16:17:51.495]                     is.null <- base::is.null
[16:17:51.495]                     muffled <- FALSE
[16:17:51.495]                     if (inherits(cond, "message")) {
[16:17:51.495]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:51.495]                       if (muffled) 
[16:17:51.495]                         invokeRestart("muffleMessage")
[16:17:51.495]                     }
[16:17:51.495]                     else if (inherits(cond, "warning")) {
[16:17:51.495]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:51.495]                       if (muffled) 
[16:17:51.495]                         invokeRestart("muffleWarning")
[16:17:51.495]                     }
[16:17:51.495]                     else if (inherits(cond, "condition")) {
[16:17:51.495]                       if (!is.null(pattern)) {
[16:17:51.495]                         computeRestarts <- base::computeRestarts
[16:17:51.495]                         grepl <- base::grepl
[16:17:51.495]                         restarts <- computeRestarts(cond)
[16:17:51.495]                         for (restart in restarts) {
[16:17:51.495]                           name <- restart$name
[16:17:51.495]                           if (is.null(name)) 
[16:17:51.495]                             next
[16:17:51.495]                           if (!grepl(pattern, name)) 
[16:17:51.495]                             next
[16:17:51.495]                           invokeRestart(restart)
[16:17:51.495]                           muffled <- TRUE
[16:17:51.495]                           break
[16:17:51.495]                         }
[16:17:51.495]                       }
[16:17:51.495]                     }
[16:17:51.495]                     invisible(muffled)
[16:17:51.495]                   }
[16:17:51.495]                   muffleCondition(cond)
[16:17:51.495]                 })
[16:17:51.495]             }))
[16:17:51.495]             future::FutureResult(value = ...future.value$value, 
[16:17:51.495]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:51.495]                   ...future.rng), globalenv = if (FALSE) 
[16:17:51.495]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:51.495]                     ...future.globalenv.names))
[16:17:51.495]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:51.495]         }, condition = base::local({
[16:17:51.495]             c <- base::c
[16:17:51.495]             inherits <- base::inherits
[16:17:51.495]             invokeRestart <- base::invokeRestart
[16:17:51.495]             length <- base::length
[16:17:51.495]             list <- base::list
[16:17:51.495]             seq.int <- base::seq.int
[16:17:51.495]             signalCondition <- base::signalCondition
[16:17:51.495]             sys.calls <- base::sys.calls
[16:17:51.495]             `[[` <- base::`[[`
[16:17:51.495]             `+` <- base::`+`
[16:17:51.495]             `<<-` <- base::`<<-`
[16:17:51.495]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:51.495]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:51.495]                   3L)]
[16:17:51.495]             }
[16:17:51.495]             function(cond) {
[16:17:51.495]                 is_error <- inherits(cond, "error")
[16:17:51.495]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:51.495]                   NULL)
[16:17:51.495]                 if (is_error) {
[16:17:51.495]                   sessionInformation <- function() {
[16:17:51.495]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:51.495]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:51.495]                       search = base::search(), system = base::Sys.info())
[16:17:51.495]                   }
[16:17:51.495]                   ...future.conditions[[length(...future.conditions) + 
[16:17:51.495]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:51.495]                     cond$call), session = sessionInformation(), 
[16:17:51.495]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:51.495]                   signalCondition(cond)
[16:17:51.495]                 }
[16:17:51.495]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:51.495]                 "immediateCondition"))) {
[16:17:51.495]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:51.495]                   ...future.conditions[[length(...future.conditions) + 
[16:17:51.495]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:51.495]                   if (TRUE && !signal) {
[16:17:51.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.495]                     {
[16:17:51.495]                       inherits <- base::inherits
[16:17:51.495]                       invokeRestart <- base::invokeRestart
[16:17:51.495]                       is.null <- base::is.null
[16:17:51.495]                       muffled <- FALSE
[16:17:51.495]                       if (inherits(cond, "message")) {
[16:17:51.495]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:51.495]                         if (muffled) 
[16:17:51.495]                           invokeRestart("muffleMessage")
[16:17:51.495]                       }
[16:17:51.495]                       else if (inherits(cond, "warning")) {
[16:17:51.495]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:51.495]                         if (muffled) 
[16:17:51.495]                           invokeRestart("muffleWarning")
[16:17:51.495]                       }
[16:17:51.495]                       else if (inherits(cond, "condition")) {
[16:17:51.495]                         if (!is.null(pattern)) {
[16:17:51.495]                           computeRestarts <- base::computeRestarts
[16:17:51.495]                           grepl <- base::grepl
[16:17:51.495]                           restarts <- computeRestarts(cond)
[16:17:51.495]                           for (restart in restarts) {
[16:17:51.495]                             name <- restart$name
[16:17:51.495]                             if (is.null(name)) 
[16:17:51.495]                               next
[16:17:51.495]                             if (!grepl(pattern, name)) 
[16:17:51.495]                               next
[16:17:51.495]                             invokeRestart(restart)
[16:17:51.495]                             muffled <- TRUE
[16:17:51.495]                             break
[16:17:51.495]                           }
[16:17:51.495]                         }
[16:17:51.495]                       }
[16:17:51.495]                       invisible(muffled)
[16:17:51.495]                     }
[16:17:51.495]                     muffleCondition(cond, pattern = "^muffle")
[16:17:51.495]                   }
[16:17:51.495]                 }
[16:17:51.495]                 else {
[16:17:51.495]                   if (TRUE) {
[16:17:51.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.495]                     {
[16:17:51.495]                       inherits <- base::inherits
[16:17:51.495]                       invokeRestart <- base::invokeRestart
[16:17:51.495]                       is.null <- base::is.null
[16:17:51.495]                       muffled <- FALSE
[16:17:51.495]                       if (inherits(cond, "message")) {
[16:17:51.495]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:51.495]                         if (muffled) 
[16:17:51.495]                           invokeRestart("muffleMessage")
[16:17:51.495]                       }
[16:17:51.495]                       else if (inherits(cond, "warning")) {
[16:17:51.495]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:51.495]                         if (muffled) 
[16:17:51.495]                           invokeRestart("muffleWarning")
[16:17:51.495]                       }
[16:17:51.495]                       else if (inherits(cond, "condition")) {
[16:17:51.495]                         if (!is.null(pattern)) {
[16:17:51.495]                           computeRestarts <- base::computeRestarts
[16:17:51.495]                           grepl <- base::grepl
[16:17:51.495]                           restarts <- computeRestarts(cond)
[16:17:51.495]                           for (restart in restarts) {
[16:17:51.495]                             name <- restart$name
[16:17:51.495]                             if (is.null(name)) 
[16:17:51.495]                               next
[16:17:51.495]                             if (!grepl(pattern, name)) 
[16:17:51.495]                               next
[16:17:51.495]                             invokeRestart(restart)
[16:17:51.495]                             muffled <- TRUE
[16:17:51.495]                             break
[16:17:51.495]                           }
[16:17:51.495]                         }
[16:17:51.495]                       }
[16:17:51.495]                       invisible(muffled)
[16:17:51.495]                     }
[16:17:51.495]                     muffleCondition(cond, pattern = "^muffle")
[16:17:51.495]                   }
[16:17:51.495]                 }
[16:17:51.495]             }
[16:17:51.495]         }))
[16:17:51.495]     }, error = function(ex) {
[16:17:51.495]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:51.495]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:51.495]                 ...future.rng), started = ...future.startTime, 
[16:17:51.495]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:51.495]             version = "1.8"), class = "FutureResult")
[16:17:51.495]     }, finally = {
[16:17:51.495]         if (!identical(...future.workdir, getwd())) 
[16:17:51.495]             setwd(...future.workdir)
[16:17:51.495]         {
[16:17:51.495]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:51.495]                 ...future.oldOptions$nwarnings <- NULL
[16:17:51.495]             }
[16:17:51.495]             base::options(...future.oldOptions)
[16:17:51.495]             if (.Platform$OS.type == "windows") {
[16:17:51.495]                 old_names <- names(...future.oldEnvVars)
[16:17:51.495]                 envs <- base::Sys.getenv()
[16:17:51.495]                 names <- names(envs)
[16:17:51.495]                 common <- intersect(names, old_names)
[16:17:51.495]                 added <- setdiff(names, old_names)
[16:17:51.495]                 removed <- setdiff(old_names, names)
[16:17:51.495]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:51.495]                   envs[common]]
[16:17:51.495]                 NAMES <- toupper(changed)
[16:17:51.495]                 args <- list()
[16:17:51.495]                 for (kk in seq_along(NAMES)) {
[16:17:51.495]                   name <- changed[[kk]]
[16:17:51.495]                   NAME <- NAMES[[kk]]
[16:17:51.495]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.495]                     next
[16:17:51.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:51.495]                 }
[16:17:51.495]                 NAMES <- toupper(added)
[16:17:51.495]                 for (kk in seq_along(NAMES)) {
[16:17:51.495]                   name <- added[[kk]]
[16:17:51.495]                   NAME <- NAMES[[kk]]
[16:17:51.495]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.495]                     next
[16:17:51.495]                   args[[name]] <- ""
[16:17:51.495]                 }
[16:17:51.495]                 NAMES <- toupper(removed)
[16:17:51.495]                 for (kk in seq_along(NAMES)) {
[16:17:51.495]                   name <- removed[[kk]]
[16:17:51.495]                   NAME <- NAMES[[kk]]
[16:17:51.495]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.495]                     next
[16:17:51.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:51.495]                 }
[16:17:51.495]                 if (length(args) > 0) 
[16:17:51.495]                   base::do.call(base::Sys.setenv, args = args)
[16:17:51.495]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:51.495]             }
[16:17:51.495]             else {
[16:17:51.495]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:51.495]             }
[16:17:51.495]             {
[16:17:51.495]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:51.495]                   0L) {
[16:17:51.495]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:51.495]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:51.495]                   base::options(opts)
[16:17:51.495]                 }
[16:17:51.495]                 {
[16:17:51.495]                   {
[16:17:51.495]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:51.495]                     NULL
[16:17:51.495]                   }
[16:17:51.495]                   options(future.plan = NULL)
[16:17:51.495]                   if (is.na(NA_character_)) 
[16:17:51.495]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:51.495]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:51.495]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:51.495]                     .init = FALSE)
[16:17:51.495]                 }
[16:17:51.495]             }
[16:17:51.495]         }
[16:17:51.495]     })
[16:17:51.495]     if (TRUE) {
[16:17:51.495]         base::sink(type = "output", split = FALSE)
[16:17:51.495]         if (TRUE) {
[16:17:51.495]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:51.495]         }
[16:17:51.495]         else {
[16:17:51.495]             ...future.result["stdout"] <- base::list(NULL)
[16:17:51.495]         }
[16:17:51.495]         base::close(...future.stdout)
[16:17:51.495]         ...future.stdout <- NULL
[16:17:51.495]     }
[16:17:51.495]     ...future.result$conditions <- ...future.conditions
[16:17:51.495]     ...future.result$finished <- base::Sys.time()
[16:17:51.495]     ...future.result
[16:17:51.495] }
[16:17:51.499] Exporting 5 global objects (1.30 KiB) to cluster node #2 ...
[16:17:51.499] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[16:17:51.499] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[16:17:51.500] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #2 ...
[16:17:51.500] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #2 ... DONE
[16:17:51.500] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[16:17:51.501] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[16:17:51.501] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:17:51.501] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:17:51.502] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:17:51.506] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:17:51.506] Exporting 5 global objects (1.30 KiB) to cluster node #2 ... DONE
[16:17:51.507] MultisessionFuture started
[16:17:51.507] - Launch lazy future ... done
[16:17:51.507] run() for ‘MultisessionFuture’ ... done
[16:17:51.507] Created future:
[16:17:51.508] MultisessionFuture:
[16:17:51.508] Label: ‘future_eapply-2’
[16:17:51.508] Expression:
[16:17:51.508] {
[16:17:51.508]     do.call(function(...) {
[16:17:51.508]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:51.508]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:51.508]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:51.508]             on.exit(options(oopts), add = TRUE)
[16:17:51.508]         }
[16:17:51.508]         {
[16:17:51.508]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:51.508]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:51.508]                 ...future.FUN(...future.X_jj, ...)
[16:17:51.508]             })
[16:17:51.508]         }
[16:17:51.508]     }, args = future.call.arguments)
[16:17:51.508] }
[16:17:51.508] Lazy evaluation: FALSE
[16:17:51.508] Asynchronous evaluation: TRUE
[16:17:51.508] Local evaluation: TRUE
[16:17:51.508] Environment: R_GlobalEnv
[16:17:51.508] Capture standard output: TRUE
[16:17:51.508] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:51.508] Globals: 5 objects totaling 1.50 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:51.508] Packages: 1 packages (‘stats’)
[16:17:51.508] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:51.508] Resolved: FALSE
[16:17:51.508] Value: <not collected>
[16:17:51.508] Conditions captured: <none>
[16:17:51.508] Early signaling: FALSE
[16:17:51.508] Owner process: 95d59565-e757-824f-7f5c-7f754384cffc
[16:17:51.508] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:51.520] Chunk #2 of 2 ... DONE
[16:17:51.520] Launching 2 futures (chunks) ... DONE
[16:17:51.520] Resolving 2 futures (chunks) ...
[16:17:51.520] resolve() on list ...
[16:17:51.521]  recursive: 0
[16:17:51.521]  length: 2
[16:17:51.521] 
[16:17:51.521] receiveMessageFromWorker() for ClusterFuture ...
[16:17:51.521] - Validating connection of MultisessionFuture
[16:17:51.522] - received message: FutureResult
[16:17:51.522] - Received FutureResult
[16:17:51.522] - Erased future from FutureRegistry
[16:17:51.522] result() for ClusterFuture ...
[16:17:51.522] - result already collected: FutureResult
[16:17:51.522] result() for ClusterFuture ... done
[16:17:51.522] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:51.522] Future #1
[16:17:51.522] result() for ClusterFuture ...
[16:17:51.522] - result already collected: FutureResult
[16:17:51.523] result() for ClusterFuture ... done
[16:17:51.523] result() for ClusterFuture ...
[16:17:51.523] - result already collected: FutureResult
[16:17:51.523] result() for ClusterFuture ... done
[16:17:51.523] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:17:51.523] - nx: 2
[16:17:51.523] - relay: TRUE
[16:17:51.523] - stdout: TRUE
[16:17:51.523] - signal: TRUE
[16:17:51.523] - resignal: FALSE
[16:17:51.524] - force: TRUE
[16:17:51.524] - relayed: [n=2] FALSE, FALSE
[16:17:51.524] - queued futures: [n=2] FALSE, FALSE
[16:17:51.524]  - until=1
[16:17:51.524]  - relaying element #1
[16:17:51.524] result() for ClusterFuture ...
[16:17:51.524] - result already collected: FutureResult
[16:17:51.524] result() for ClusterFuture ... done
[16:17:51.524] result() for ClusterFuture ...
[16:17:51.524] - result already collected: FutureResult
[16:17:51.524] result() for ClusterFuture ... done
[16:17:51.525] result() for ClusterFuture ...
[16:17:51.525] - result already collected: FutureResult
[16:17:51.525] result() for ClusterFuture ... done
[16:17:51.525] result() for ClusterFuture ...
[16:17:51.525] - result already collected: FutureResult
[16:17:51.525] result() for ClusterFuture ... done
[16:17:51.525] - relayed: [n=2] TRUE, FALSE
[16:17:51.525] - queued futures: [n=2] TRUE, FALSE
[16:17:51.525] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:17:51.525]  length: 1 (resolved future 1)
[16:17:51.556] receiveMessageFromWorker() for ClusterFuture ...
[16:17:51.556] - Validating connection of MultisessionFuture
[16:17:51.556] - received message: FutureResult
[16:17:51.556] - Received FutureResult
[16:17:51.556] - Erased future from FutureRegistry
[16:17:51.557] result() for ClusterFuture ...
[16:17:51.557] - result already collected: FutureResult
[16:17:51.557] result() for ClusterFuture ... done
[16:17:51.557] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:51.557] Future #2
[16:17:51.557] result() for ClusterFuture ...
[16:17:51.557] - result already collected: FutureResult
[16:17:51.557] result() for ClusterFuture ... done
[16:17:51.557] result() for ClusterFuture ...
[16:17:51.557] - result already collected: FutureResult
[16:17:51.557] result() for ClusterFuture ... done
[16:17:51.558] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:17:51.558] - nx: 2
[16:17:51.558] - relay: TRUE
[16:17:51.558] - stdout: TRUE
[16:17:51.558] - signal: TRUE
[16:17:51.558] - resignal: FALSE
[16:17:51.558] - force: TRUE
[16:17:51.558] - relayed: [n=2] TRUE, FALSE
[16:17:51.558] - queued futures: [n=2] TRUE, FALSE
[16:17:51.558]  - until=2
[16:17:51.558]  - relaying element #2
[16:17:51.559] result() for ClusterFuture ...
[16:17:51.559] - result already collected: FutureResult
[16:17:51.559] result() for ClusterFuture ... done
[16:17:51.559] result() for ClusterFuture ...
[16:17:51.559] - result already collected: FutureResult
[16:17:51.559] result() for ClusterFuture ... done
[16:17:51.559] result() for ClusterFuture ...
[16:17:51.559] - result already collected: FutureResult
[16:17:51.559] result() for ClusterFuture ... done
[16:17:51.559] result() for ClusterFuture ...
[16:17:51.559] - result already collected: FutureResult
[16:17:51.560] result() for ClusterFuture ... done
[16:17:51.560] - relayed: [n=2] TRUE, TRUE
[16:17:51.560] - queued futures: [n=2] TRUE, TRUE
[16:17:51.560] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:17:51.560]  length: 0 (resolved future 2)
[16:17:51.560] Relaying remaining futures
[16:17:51.560] signalConditionsASAP(NULL, pos=0) ...
[16:17:51.560] - nx: 2
[16:17:51.560] - relay: TRUE
[16:17:51.560] - stdout: TRUE
[16:17:51.560] - signal: TRUE
[16:17:51.561] - resignal: FALSE
[16:17:51.561] - force: TRUE
[16:17:51.561] - relayed: [n=2] TRUE, TRUE
[16:17:51.561] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:51.561] - relayed: [n=2] TRUE, TRUE
[16:17:51.561] - queued futures: [n=2] TRUE, TRUE
[16:17:51.561] signalConditionsASAP(NULL, pos=0) ... done
[16:17:51.561] resolve() on list ... DONE
[16:17:51.561] result() for ClusterFuture ...
[16:17:51.561] - result already collected: FutureResult
[16:17:51.561] result() for ClusterFuture ... done
[16:17:51.562] result() for ClusterFuture ...
[16:17:51.562] - result already collected: FutureResult
[16:17:51.562] result() for ClusterFuture ... done
[16:17:51.562] result() for ClusterFuture ...
[16:17:51.562] - result already collected: FutureResult
[16:17:51.562] result() for ClusterFuture ... done
[16:17:51.562] result() for ClusterFuture ...
[16:17:51.562] - result already collected: FutureResult
[16:17:51.562] result() for ClusterFuture ... done
[16:17:51.562]  - Number of value chunks collected: 2
[16:17:51.563] Resolving 2 futures (chunks) ... DONE
[16:17:51.563] Reducing values from 2 chunks ...
[16:17:51.563]  - Number of values collected after concatenation: 3
[16:17:51.563]  - Number of values expected: 3
[16:17:51.563] Reducing values from 2 chunks ... DONE
[16:17:51.563] future_lapply() ... DONE
[16:17:51.564] future_lapply() ...
[16:17:51.568] Number of chunks: 2
[16:17:51.568] getGlobalsAndPackagesXApply() ...
[16:17:51.569]  - future.globals: TRUE
[16:17:51.569] getGlobalsAndPackages() ...
[16:17:51.569] Searching for globals...
[16:17:51.570] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:51.570] Searching for globals ... DONE
[16:17:51.570] Resolving globals: FALSE
[16:17:51.571] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:17:51.571] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:17:51.571] - globals: [1] ‘FUN’
[16:17:51.571] - packages: [1] ‘stats’
[16:17:51.571] getGlobalsAndPackages() ... DONE
[16:17:51.571]  - globals found/used: [n=1] ‘FUN’
[16:17:51.572]  - needed namespaces: [n=1] ‘stats’
[16:17:51.572] Finding globals ... DONE
[16:17:51.572]  - use_args: TRUE
[16:17:51.572]  - Getting '...' globals ...
[16:17:51.572] resolve() on list ...
[16:17:51.572]  recursive: 0
[16:17:51.572]  length: 1
[16:17:51.573]  elements: ‘...’
[16:17:51.573]  length: 0 (resolved future 1)
[16:17:51.573] resolve() on list ... DONE
[16:17:51.573]    - '...' content: [n=0] 
[16:17:51.573] List of 1
[16:17:51.573]  $ ...: list()
[16:17:51.573]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:51.573]  - attr(*, "where")=List of 1
[16:17:51.573]   ..$ ...:<environment: 0x556da5b21428> 
[16:17:51.573]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:51.573]  - attr(*, "resolved")= logi TRUE
[16:17:51.573]  - attr(*, "total_size")= num NA
[16:17:51.578]  - Getting '...' globals ... DONE
[16:17:51.578] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:51.578] List of 2
[16:17:51.578]  $ ...future.FUN:function (x, ...)  
[16:17:51.578]  $ ...          : list()
[16:17:51.578]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:51.578]  - attr(*, "where")=List of 2
[16:17:51.578]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:51.578]   ..$ ...          :<environment: 0x556da5b21428> 
[16:17:51.578]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:51.578]  - attr(*, "resolved")= logi FALSE
[16:17:51.578]  - attr(*, "total_size")= num 1248
[16:17:51.580] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:51.581] getGlobalsAndPackagesXApply() ... DONE
[16:17:51.581] Number of futures (= number of chunks): 2
[16:17:51.581] Launching 2 futures (chunks) ...
[16:17:51.581] Chunk #1 of 2 ...
[16:17:51.581]  - Finding globals in 'X' for chunk #1 ...
[16:17:51.581] getGlobalsAndPackages() ...
[16:17:51.581] Searching for globals...
[16:17:51.582] 
[16:17:51.582] Searching for globals ... DONE
[16:17:51.582] - globals: [0] <none>
[16:17:51.582] getGlobalsAndPackages() ... DONE
[16:17:51.582]    + additional globals found: [n=0] 
[16:17:51.582]    + additional namespaces needed: [n=0] 
[16:17:51.582]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:51.582]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:51.582]  - seeds: <none>
[16:17:51.582]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:51.582] getGlobalsAndPackages() ...
[16:17:51.583] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:51.583] Resolving globals: FALSE
[16:17:51.583] Tweak future expression to call with '...' arguments ...
[16:17:51.583] {
[16:17:51.583]     do.call(function(...) {
[16:17:51.583]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:51.583]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:51.583]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:51.583]             on.exit(options(oopts), add = TRUE)
[16:17:51.583]         }
[16:17:51.583]         {
[16:17:51.583]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:51.583]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:51.583]                 ...future.FUN(...future.X_jj, ...)
[16:17:51.583]             })
[16:17:51.583]         }
[16:17:51.583]     }, args = future.call.arguments)
[16:17:51.583] }
[16:17:51.583] Tweak future expression to call with '...' arguments ... DONE
[16:17:51.583] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:51.584] - packages: [1] ‘stats’
[16:17:51.584] getGlobalsAndPackages() ... DONE
[16:17:51.584] run() for ‘Future’ ...
[16:17:51.584] - state: ‘created’
[16:17:51.584] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:51.598] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:51.598] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:51.598]   - Field: ‘node’
[16:17:51.598]   - Field: ‘label’
[16:17:51.598]   - Field: ‘local’
[16:17:51.598]   - Field: ‘owner’
[16:17:51.598]   - Field: ‘envir’
[16:17:51.598]   - Field: ‘workers’
[16:17:51.598]   - Field: ‘packages’
[16:17:51.598]   - Field: ‘gc’
[16:17:51.599]   - Field: ‘conditions’
[16:17:51.599]   - Field: ‘persistent’
[16:17:51.599]   - Field: ‘expr’
[16:17:51.599]   - Field: ‘uuid’
[16:17:51.599]   - Field: ‘seed’
[16:17:51.599]   - Field: ‘version’
[16:17:51.599]   - Field: ‘result’
[16:17:51.599]   - Field: ‘asynchronous’
[16:17:51.599]   - Field: ‘calls’
[16:17:51.599]   - Field: ‘globals’
[16:17:51.599]   - Field: ‘stdout’
[16:17:51.600]   - Field: ‘earlySignal’
[16:17:51.600]   - Field: ‘lazy’
[16:17:51.600]   - Field: ‘state’
[16:17:51.600] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:51.600] - Launch lazy future ...
[16:17:51.600] Packages needed by the future expression (n = 1): ‘stats’
[16:17:51.600] Packages needed by future strategies (n = 0): <none>
[16:17:51.601] {
[16:17:51.601]     {
[16:17:51.601]         {
[16:17:51.601]             ...future.startTime <- base::Sys.time()
[16:17:51.601]             {
[16:17:51.601]                 {
[16:17:51.601]                   {
[16:17:51.601]                     {
[16:17:51.601]                       {
[16:17:51.601]                         base::local({
[16:17:51.601]                           has_future <- base::requireNamespace("future", 
[16:17:51.601]                             quietly = TRUE)
[16:17:51.601]                           if (has_future) {
[16:17:51.601]                             ns <- base::getNamespace("future")
[16:17:51.601]                             version <- ns[[".package"]][["version"]]
[16:17:51.601]                             if (is.null(version)) 
[16:17:51.601]                               version <- utils::packageVersion("future")
[16:17:51.601]                           }
[16:17:51.601]                           else {
[16:17:51.601]                             version <- NULL
[16:17:51.601]                           }
[16:17:51.601]                           if (!has_future || version < "1.8.0") {
[16:17:51.601]                             info <- base::c(r_version = base::gsub("R version ", 
[16:17:51.601]                               "", base::R.version$version.string), 
[16:17:51.601]                               platform = base::sprintf("%s (%s-bit)", 
[16:17:51.601]                                 base::R.version$platform, 8 * 
[16:17:51.601]                                   base::.Machine$sizeof.pointer), 
[16:17:51.601]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:51.601]                                 "release", "version")], collapse = " "), 
[16:17:51.601]                               hostname = base::Sys.info()[["nodename"]])
[16:17:51.601]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:17:51.601]                               info)
[16:17:51.601]                             info <- base::paste(info, collapse = "; ")
[16:17:51.601]                             if (!has_future) {
[16:17:51.601]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:51.601]                                 info)
[16:17:51.601]                             }
[16:17:51.601]                             else {
[16:17:51.601]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:51.601]                                 info, version)
[16:17:51.601]                             }
[16:17:51.601]                             base::stop(msg)
[16:17:51.601]                           }
[16:17:51.601]                         })
[16:17:51.601]                       }
[16:17:51.601]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:51.601]                       base::options(mc.cores = 1L)
[16:17:51.601]                     }
[16:17:51.601]                     base::local({
[16:17:51.601]                       for (pkg in "stats") {
[16:17:51.601]                         base::loadNamespace(pkg)
[16:17:51.601]                         base::library(pkg, character.only = TRUE)
[16:17:51.601]                       }
[16:17:51.601]                     })
[16:17:51.601]                   }
[16:17:51.601]                   ...future.strategy.old <- future::plan("list")
[16:17:51.601]                   options(future.plan = NULL)
[16:17:51.601]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:51.601]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:51.601]                 }
[16:17:51.601]                 ...future.workdir <- getwd()
[16:17:51.601]             }
[16:17:51.601]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:51.601]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:51.601]         }
[16:17:51.601]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:51.601]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:51.601]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:51.601]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:51.601]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:51.601]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:51.601]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:51.601]             base::names(...future.oldOptions))
[16:17:51.601]     }
[16:17:51.601]     if (FALSE) {
[16:17:51.601]     }
[16:17:51.601]     else {
[16:17:51.601]         if (TRUE) {
[16:17:51.601]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:51.601]                 open = "w")
[16:17:51.601]         }
[16:17:51.601]         else {
[16:17:51.601]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:51.601]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:51.601]         }
[16:17:51.601]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:51.601]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:51.601]             base::sink(type = "output", split = FALSE)
[16:17:51.601]             base::close(...future.stdout)
[16:17:51.601]         }, add = TRUE)
[16:17:51.601]     }
[16:17:51.601]     ...future.frame <- base::sys.nframe()
[16:17:51.601]     ...future.conditions <- base::list()
[16:17:51.601]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:51.601]     if (FALSE) {
[16:17:51.601]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:51.601]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:51.601]     }
[16:17:51.601]     ...future.result <- base::tryCatch({
[16:17:51.601]         base::withCallingHandlers({
[16:17:51.601]             ...future.value <- base::withVisible(base::local({
[16:17:51.601]                 ...future.makeSendCondition <- base::local({
[16:17:51.601]                   sendCondition <- NULL
[16:17:51.601]                   function(frame = 1L) {
[16:17:51.601]                     if (is.function(sendCondition)) 
[16:17:51.601]                       return(sendCondition)
[16:17:51.601]                     ns <- getNamespace("parallel")
[16:17:51.601]                     if (exists("sendData", mode = "function", 
[16:17:51.601]                       envir = ns)) {
[16:17:51.601]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:51.601]                         envir = ns)
[16:17:51.601]                       envir <- sys.frame(frame)
[16:17:51.601]                       master <- NULL
[16:17:51.601]                       while (!identical(envir, .GlobalEnv) && 
[16:17:51.601]                         !identical(envir, emptyenv())) {
[16:17:51.601]                         if (exists("master", mode = "list", envir = envir, 
[16:17:51.601]                           inherits = FALSE)) {
[16:17:51.601]                           master <- get("master", mode = "list", 
[16:17:51.601]                             envir = envir, inherits = FALSE)
[16:17:51.601]                           if (inherits(master, c("SOCKnode", 
[16:17:51.601]                             "SOCK0node"))) {
[16:17:51.601]                             sendCondition <<- function(cond) {
[16:17:51.601]                               data <- list(type = "VALUE", value = cond, 
[16:17:51.601]                                 success = TRUE)
[16:17:51.601]                               parallel_sendData(master, data)
[16:17:51.601]                             }
[16:17:51.601]                             return(sendCondition)
[16:17:51.601]                           }
[16:17:51.601]                         }
[16:17:51.601]                         frame <- frame + 1L
[16:17:51.601]                         envir <- sys.frame(frame)
[16:17:51.601]                       }
[16:17:51.601]                     }
[16:17:51.601]                     sendCondition <<- function(cond) NULL
[16:17:51.601]                   }
[16:17:51.601]                 })
[16:17:51.601]                 withCallingHandlers({
[16:17:51.601]                   {
[16:17:51.601]                     do.call(function(...) {
[16:17:51.601]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:51.601]                       if (!identical(...future.globals.maxSize.org, 
[16:17:51.601]                         ...future.globals.maxSize)) {
[16:17:51.601]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:51.601]                         on.exit(options(oopts), add = TRUE)
[16:17:51.601]                       }
[16:17:51.601]                       {
[16:17:51.601]                         lapply(seq_along(...future.elements_ii), 
[16:17:51.601]                           FUN = function(jj) {
[16:17:51.601]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:51.601]                             ...future.FUN(...future.X_jj, ...)
[16:17:51.601]                           })
[16:17:51.601]                       }
[16:17:51.601]                     }, args = future.call.arguments)
[16:17:51.601]                   }
[16:17:51.601]                 }, immediateCondition = function(cond) {
[16:17:51.601]                   sendCondition <- ...future.makeSendCondition()
[16:17:51.601]                   sendCondition(cond)
[16:17:51.601]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.601]                   {
[16:17:51.601]                     inherits <- base::inherits
[16:17:51.601]                     invokeRestart <- base::invokeRestart
[16:17:51.601]                     is.null <- base::is.null
[16:17:51.601]                     muffled <- FALSE
[16:17:51.601]                     if (inherits(cond, "message")) {
[16:17:51.601]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:51.601]                       if (muffled) 
[16:17:51.601]                         invokeRestart("muffleMessage")
[16:17:51.601]                     }
[16:17:51.601]                     else if (inherits(cond, "warning")) {
[16:17:51.601]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:51.601]                       if (muffled) 
[16:17:51.601]                         invokeRestart("muffleWarning")
[16:17:51.601]                     }
[16:17:51.601]                     else if (inherits(cond, "condition")) {
[16:17:51.601]                       if (!is.null(pattern)) {
[16:17:51.601]                         computeRestarts <- base::computeRestarts
[16:17:51.601]                         grepl <- base::grepl
[16:17:51.601]                         restarts <- computeRestarts(cond)
[16:17:51.601]                         for (restart in restarts) {
[16:17:51.601]                           name <- restart$name
[16:17:51.601]                           if (is.null(name)) 
[16:17:51.601]                             next
[16:17:51.601]                           if (!grepl(pattern, name)) 
[16:17:51.601]                             next
[16:17:51.601]                           invokeRestart(restart)
[16:17:51.601]                           muffled <- TRUE
[16:17:51.601]                           break
[16:17:51.601]                         }
[16:17:51.601]                       }
[16:17:51.601]                     }
[16:17:51.601]                     invisible(muffled)
[16:17:51.601]                   }
[16:17:51.601]                   muffleCondition(cond)
[16:17:51.601]                 })
[16:17:51.601]             }))
[16:17:51.601]             future::FutureResult(value = ...future.value$value, 
[16:17:51.601]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:51.601]                   ...future.rng), globalenv = if (FALSE) 
[16:17:51.601]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:51.601]                     ...future.globalenv.names))
[16:17:51.601]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:51.601]         }, condition = base::local({
[16:17:51.601]             c <- base::c
[16:17:51.601]             inherits <- base::inherits
[16:17:51.601]             invokeRestart <- base::invokeRestart
[16:17:51.601]             length <- base::length
[16:17:51.601]             list <- base::list
[16:17:51.601]             seq.int <- base::seq.int
[16:17:51.601]             signalCondition <- base::signalCondition
[16:17:51.601]             sys.calls <- base::sys.calls
[16:17:51.601]             `[[` <- base::`[[`
[16:17:51.601]             `+` <- base::`+`
[16:17:51.601]             `<<-` <- base::`<<-`
[16:17:51.601]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:51.601]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:51.601]                   3L)]
[16:17:51.601]             }
[16:17:51.601]             function(cond) {
[16:17:51.601]                 is_error <- inherits(cond, "error")
[16:17:51.601]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:51.601]                   NULL)
[16:17:51.601]                 if (is_error) {
[16:17:51.601]                   sessionInformation <- function() {
[16:17:51.601]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:51.601]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:51.601]                       search = base::search(), system = base::Sys.info())
[16:17:51.601]                   }
[16:17:51.601]                   ...future.conditions[[length(...future.conditions) + 
[16:17:51.601]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:51.601]                     cond$call), session = sessionInformation(), 
[16:17:51.601]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:51.601]                   signalCondition(cond)
[16:17:51.601]                 }
[16:17:51.601]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:51.601]                 "immediateCondition"))) {
[16:17:51.601]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:51.601]                   ...future.conditions[[length(...future.conditions) + 
[16:17:51.601]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:51.601]                   if (TRUE && !signal) {
[16:17:51.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.601]                     {
[16:17:51.601]                       inherits <- base::inherits
[16:17:51.601]                       invokeRestart <- base::invokeRestart
[16:17:51.601]                       is.null <- base::is.null
[16:17:51.601]                       muffled <- FALSE
[16:17:51.601]                       if (inherits(cond, "message")) {
[16:17:51.601]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:51.601]                         if (muffled) 
[16:17:51.601]                           invokeRestart("muffleMessage")
[16:17:51.601]                       }
[16:17:51.601]                       else if (inherits(cond, "warning")) {
[16:17:51.601]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:51.601]                         if (muffled) 
[16:17:51.601]                           invokeRestart("muffleWarning")
[16:17:51.601]                       }
[16:17:51.601]                       else if (inherits(cond, "condition")) {
[16:17:51.601]                         if (!is.null(pattern)) {
[16:17:51.601]                           computeRestarts <- base::computeRestarts
[16:17:51.601]                           grepl <- base::grepl
[16:17:51.601]                           restarts <- computeRestarts(cond)
[16:17:51.601]                           for (restart in restarts) {
[16:17:51.601]                             name <- restart$name
[16:17:51.601]                             if (is.null(name)) 
[16:17:51.601]                               next
[16:17:51.601]                             if (!grepl(pattern, name)) 
[16:17:51.601]                               next
[16:17:51.601]                             invokeRestart(restart)
[16:17:51.601]                             muffled <- TRUE
[16:17:51.601]                             break
[16:17:51.601]                           }
[16:17:51.601]                         }
[16:17:51.601]                       }
[16:17:51.601]                       invisible(muffled)
[16:17:51.601]                     }
[16:17:51.601]                     muffleCondition(cond, pattern = "^muffle")
[16:17:51.601]                   }
[16:17:51.601]                 }
[16:17:51.601]                 else {
[16:17:51.601]                   if (TRUE) {
[16:17:51.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.601]                     {
[16:17:51.601]                       inherits <- base::inherits
[16:17:51.601]                       invokeRestart <- base::invokeRestart
[16:17:51.601]                       is.null <- base::is.null
[16:17:51.601]                       muffled <- FALSE
[16:17:51.601]                       if (inherits(cond, "message")) {
[16:17:51.601]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:51.601]                         if (muffled) 
[16:17:51.601]                           invokeRestart("muffleMessage")
[16:17:51.601]                       }
[16:17:51.601]                       else if (inherits(cond, "warning")) {
[16:17:51.601]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:51.601]                         if (muffled) 
[16:17:51.601]                           invokeRestart("muffleWarning")
[16:17:51.601]                       }
[16:17:51.601]                       else if (inherits(cond, "condition")) {
[16:17:51.601]                         if (!is.null(pattern)) {
[16:17:51.601]                           computeRestarts <- base::computeRestarts
[16:17:51.601]                           grepl <- base::grepl
[16:17:51.601]                           restarts <- computeRestarts(cond)
[16:17:51.601]                           for (restart in restarts) {
[16:17:51.601]                             name <- restart$name
[16:17:51.601]                             if (is.null(name)) 
[16:17:51.601]                               next
[16:17:51.601]                             if (!grepl(pattern, name)) 
[16:17:51.601]                               next
[16:17:51.601]                             invokeRestart(restart)
[16:17:51.601]                             muffled <- TRUE
[16:17:51.601]                             break
[16:17:51.601]                           }
[16:17:51.601]                         }
[16:17:51.601]                       }
[16:17:51.601]                       invisible(muffled)
[16:17:51.601]                     }
[16:17:51.601]                     muffleCondition(cond, pattern = "^muffle")
[16:17:51.601]                   }
[16:17:51.601]                 }
[16:17:51.601]             }
[16:17:51.601]         }))
[16:17:51.601]     }, error = function(ex) {
[16:17:51.601]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:51.601]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:51.601]                 ...future.rng), started = ...future.startTime, 
[16:17:51.601]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:51.601]             version = "1.8"), class = "FutureResult")
[16:17:51.601]     }, finally = {
[16:17:51.601]         if (!identical(...future.workdir, getwd())) 
[16:17:51.601]             setwd(...future.workdir)
[16:17:51.601]         {
[16:17:51.601]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:51.601]                 ...future.oldOptions$nwarnings <- NULL
[16:17:51.601]             }
[16:17:51.601]             base::options(...future.oldOptions)
[16:17:51.601]             if (.Platform$OS.type == "windows") {
[16:17:51.601]                 old_names <- names(...future.oldEnvVars)
[16:17:51.601]                 envs <- base::Sys.getenv()
[16:17:51.601]                 names <- names(envs)
[16:17:51.601]                 common <- intersect(names, old_names)
[16:17:51.601]                 added <- setdiff(names, old_names)
[16:17:51.601]                 removed <- setdiff(old_names, names)
[16:17:51.601]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:51.601]                   envs[common]]
[16:17:51.601]                 NAMES <- toupper(changed)
[16:17:51.601]                 args <- list()
[16:17:51.601]                 for (kk in seq_along(NAMES)) {
[16:17:51.601]                   name <- changed[[kk]]
[16:17:51.601]                   NAME <- NAMES[[kk]]
[16:17:51.601]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.601]                     next
[16:17:51.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:51.601]                 }
[16:17:51.601]                 NAMES <- toupper(added)
[16:17:51.601]                 for (kk in seq_along(NAMES)) {
[16:17:51.601]                   name <- added[[kk]]
[16:17:51.601]                   NAME <- NAMES[[kk]]
[16:17:51.601]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.601]                     next
[16:17:51.601]                   args[[name]] <- ""
[16:17:51.601]                 }
[16:17:51.601]                 NAMES <- toupper(removed)
[16:17:51.601]                 for (kk in seq_along(NAMES)) {
[16:17:51.601]                   name <- removed[[kk]]
[16:17:51.601]                   NAME <- NAMES[[kk]]
[16:17:51.601]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.601]                     next
[16:17:51.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:51.601]                 }
[16:17:51.601]                 if (length(args) > 0) 
[16:17:51.601]                   base::do.call(base::Sys.setenv, args = args)
[16:17:51.601]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:51.601]             }
[16:17:51.601]             else {
[16:17:51.601]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:51.601]             }
[16:17:51.601]             {
[16:17:51.601]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:51.601]                   0L) {
[16:17:51.601]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:51.601]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:51.601]                   base::options(opts)
[16:17:51.601]                 }
[16:17:51.601]                 {
[16:17:51.601]                   {
[16:17:51.601]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:51.601]                     NULL
[16:17:51.601]                   }
[16:17:51.601]                   options(future.plan = NULL)
[16:17:51.601]                   if (is.na(NA_character_)) 
[16:17:51.601]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:51.601]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:51.601]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:51.601]                     .init = FALSE)
[16:17:51.601]                 }
[16:17:51.601]             }
[16:17:51.601]         }
[16:17:51.601]     })
[16:17:51.601]     if (TRUE) {
[16:17:51.601]         base::sink(type = "output", split = FALSE)
[16:17:51.601]         if (TRUE) {
[16:17:51.601]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:51.601]         }
[16:17:51.601]         else {
[16:17:51.601]             ...future.result["stdout"] <- base::list(NULL)
[16:17:51.601]         }
[16:17:51.601]         base::close(...future.stdout)
[16:17:51.601]         ...future.stdout <- NULL
[16:17:51.601]     }
[16:17:51.601]     ...future.result$conditions <- ...future.conditions
[16:17:51.601]     ...future.result$finished <- base::Sys.time()
[16:17:51.601]     ...future.result
[16:17:51.601] }
[16:17:51.604] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[16:17:51.604] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[16:17:51.604] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[16:17:51.604] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:17:51.605] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:17:51.605] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[16:17:51.605] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[16:17:51.605] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:17:51.606] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:17:51.606] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:17:51.606] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:17:51.606] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[16:17:51.607] MultisessionFuture started
[16:17:51.607] - Launch lazy future ... done
[16:17:51.607] run() for ‘MultisessionFuture’ ... done
[16:17:51.607] Created future:
[16:17:51.607] MultisessionFuture:
[16:17:51.607] Label: ‘future_eapply-1’
[16:17:51.607] Expression:
[16:17:51.607] {
[16:17:51.607]     do.call(function(...) {
[16:17:51.607]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:51.607]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:51.607]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:51.607]             on.exit(options(oopts), add = TRUE)
[16:17:51.607]         }
[16:17:51.607]         {
[16:17:51.607]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:51.607]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:51.607]                 ...future.FUN(...future.X_jj, ...)
[16:17:51.607]             })
[16:17:51.607]         }
[16:17:51.607]     }, args = future.call.arguments)
[16:17:51.607] }
[16:17:51.607] Lazy evaluation: FALSE
[16:17:51.607] Asynchronous evaluation: TRUE
[16:17:51.607] Local evaluation: TRUE
[16:17:51.607] Environment: R_GlobalEnv
[16:17:51.607] Capture standard output: TRUE
[16:17:51.607] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:51.607] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:51.607] Packages: 1 packages (‘stats’)
[16:17:51.607] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:51.607] Resolved: FALSE
[16:17:51.607] Value: <not collected>
[16:17:51.607] Conditions captured: <none>
[16:17:51.607] Early signaling: FALSE
[16:17:51.607] Owner process: 95d59565-e757-824f-7f5c-7f754384cffc
[16:17:51.607] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:51.618] Chunk #1 of 2 ... DONE
[16:17:51.619] Chunk #2 of 2 ...
[16:17:51.619]  - Finding globals in 'X' for chunk #2 ...
[16:17:51.619] getGlobalsAndPackages() ...
[16:17:51.619] Searching for globals...
[16:17:51.619] 
[16:17:51.619] Searching for globals ... DONE
[16:17:51.619] - globals: [0] <none>
[16:17:51.620] getGlobalsAndPackages() ... DONE
[16:17:51.620]    + additional globals found: [n=0] 
[16:17:51.620]    + additional namespaces needed: [n=0] 
[16:17:51.620]  - Finding globals in 'X' for chunk #2 ... DONE
[16:17:51.620]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:51.620]  - seeds: <none>
[16:17:51.620]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:51.620] getGlobalsAndPackages() ...
[16:17:51.620] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:51.620] Resolving globals: FALSE
[16:17:51.621] Tweak future expression to call with '...' arguments ...
[16:17:51.621] {
[16:17:51.621]     do.call(function(...) {
[16:17:51.621]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:51.621]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:51.621]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:51.621]             on.exit(options(oopts), add = TRUE)
[16:17:51.621]         }
[16:17:51.621]         {
[16:17:51.621]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:51.621]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:51.621]                 ...future.FUN(...future.X_jj, ...)
[16:17:51.621]             })
[16:17:51.621]         }
[16:17:51.621]     }, args = future.call.arguments)
[16:17:51.621] }
[16:17:51.621] Tweak future expression to call with '...' arguments ... DONE
[16:17:51.621] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:51.621] - packages: [1] ‘stats’
[16:17:51.622] getGlobalsAndPackages() ... DONE
[16:17:51.622] run() for ‘Future’ ...
[16:17:51.622] - state: ‘created’
[16:17:51.622] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:51.636] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:51.636] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:51.636]   - Field: ‘node’
[16:17:51.636]   - Field: ‘label’
[16:17:51.637]   - Field: ‘local’
[16:17:51.637]   - Field: ‘owner’
[16:17:51.637]   - Field: ‘envir’
[16:17:51.637]   - Field: ‘workers’
[16:17:51.637]   - Field: ‘packages’
[16:17:51.637]   - Field: ‘gc’
[16:17:51.637]   - Field: ‘conditions’
[16:17:51.637]   - Field: ‘persistent’
[16:17:51.637]   - Field: ‘expr’
[16:17:51.637]   - Field: ‘uuid’
[16:17:51.637]   - Field: ‘seed’
[16:17:51.638]   - Field: ‘version’
[16:17:51.638]   - Field: ‘result’
[16:17:51.638]   - Field: ‘asynchronous’
[16:17:51.638]   - Field: ‘calls’
[16:17:51.638]   - Field: ‘globals’
[16:17:51.638]   - Field: ‘stdout’
[16:17:51.638]   - Field: ‘earlySignal’
[16:17:51.638]   - Field: ‘lazy’
[16:17:51.638]   - Field: ‘state’
[16:17:51.638] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:51.639] - Launch lazy future ...
[16:17:51.639] Packages needed by the future expression (n = 1): ‘stats’
[16:17:51.639] Packages needed by future strategies (n = 0): <none>
[16:17:51.639] {
[16:17:51.639]     {
[16:17:51.639]         {
[16:17:51.639]             ...future.startTime <- base::Sys.time()
[16:17:51.639]             {
[16:17:51.639]                 {
[16:17:51.639]                   {
[16:17:51.639]                     {
[16:17:51.639]                       {
[16:17:51.639]                         base::local({
[16:17:51.639]                           has_future <- base::requireNamespace("future", 
[16:17:51.639]                             quietly = TRUE)
[16:17:51.639]                           if (has_future) {
[16:17:51.639]                             ns <- base::getNamespace("future")
[16:17:51.639]                             version <- ns[[".package"]][["version"]]
[16:17:51.639]                             if (is.null(version)) 
[16:17:51.639]                               version <- utils::packageVersion("future")
[16:17:51.639]                           }
[16:17:51.639]                           else {
[16:17:51.639]                             version <- NULL
[16:17:51.639]                           }
[16:17:51.639]                           if (!has_future || version < "1.8.0") {
[16:17:51.639]                             info <- base::c(r_version = base::gsub("R version ", 
[16:17:51.639]                               "", base::R.version$version.string), 
[16:17:51.639]                               platform = base::sprintf("%s (%s-bit)", 
[16:17:51.639]                                 base::R.version$platform, 8 * 
[16:17:51.639]                                   base::.Machine$sizeof.pointer), 
[16:17:51.639]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:51.639]                                 "release", "version")], collapse = " "), 
[16:17:51.639]                               hostname = base::Sys.info()[["nodename"]])
[16:17:51.639]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:17:51.639]                               info)
[16:17:51.639]                             info <- base::paste(info, collapse = "; ")
[16:17:51.639]                             if (!has_future) {
[16:17:51.639]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:51.639]                                 info)
[16:17:51.639]                             }
[16:17:51.639]                             else {
[16:17:51.639]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:51.639]                                 info, version)
[16:17:51.639]                             }
[16:17:51.639]                             base::stop(msg)
[16:17:51.639]                           }
[16:17:51.639]                         })
[16:17:51.639]                       }
[16:17:51.639]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:51.639]                       base::options(mc.cores = 1L)
[16:17:51.639]                     }
[16:17:51.639]                     base::local({
[16:17:51.639]                       for (pkg in "stats") {
[16:17:51.639]                         base::loadNamespace(pkg)
[16:17:51.639]                         base::library(pkg, character.only = TRUE)
[16:17:51.639]                       }
[16:17:51.639]                     })
[16:17:51.639]                   }
[16:17:51.639]                   ...future.strategy.old <- future::plan("list")
[16:17:51.639]                   options(future.plan = NULL)
[16:17:51.639]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:51.639]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:51.639]                 }
[16:17:51.639]                 ...future.workdir <- getwd()
[16:17:51.639]             }
[16:17:51.639]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:51.639]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:51.639]         }
[16:17:51.639]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:51.639]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:51.639]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:51.639]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:51.639]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:51.639]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:51.639]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:51.639]             base::names(...future.oldOptions))
[16:17:51.639]     }
[16:17:51.639]     if (FALSE) {
[16:17:51.639]     }
[16:17:51.639]     else {
[16:17:51.639]         if (TRUE) {
[16:17:51.639]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:51.639]                 open = "w")
[16:17:51.639]         }
[16:17:51.639]         else {
[16:17:51.639]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:51.639]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:51.639]         }
[16:17:51.639]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:51.639]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:51.639]             base::sink(type = "output", split = FALSE)
[16:17:51.639]             base::close(...future.stdout)
[16:17:51.639]         }, add = TRUE)
[16:17:51.639]     }
[16:17:51.639]     ...future.frame <- base::sys.nframe()
[16:17:51.639]     ...future.conditions <- base::list()
[16:17:51.639]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:51.639]     if (FALSE) {
[16:17:51.639]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:51.639]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:51.639]     }
[16:17:51.639]     ...future.result <- base::tryCatch({
[16:17:51.639]         base::withCallingHandlers({
[16:17:51.639]             ...future.value <- base::withVisible(base::local({
[16:17:51.639]                 ...future.makeSendCondition <- base::local({
[16:17:51.639]                   sendCondition <- NULL
[16:17:51.639]                   function(frame = 1L) {
[16:17:51.639]                     if (is.function(sendCondition)) 
[16:17:51.639]                       return(sendCondition)
[16:17:51.639]                     ns <- getNamespace("parallel")
[16:17:51.639]                     if (exists("sendData", mode = "function", 
[16:17:51.639]                       envir = ns)) {
[16:17:51.639]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:51.639]                         envir = ns)
[16:17:51.639]                       envir <- sys.frame(frame)
[16:17:51.639]                       master <- NULL
[16:17:51.639]                       while (!identical(envir, .GlobalEnv) && 
[16:17:51.639]                         !identical(envir, emptyenv())) {
[16:17:51.639]                         if (exists("master", mode = "list", envir = envir, 
[16:17:51.639]                           inherits = FALSE)) {
[16:17:51.639]                           master <- get("master", mode = "list", 
[16:17:51.639]                             envir = envir, inherits = FALSE)
[16:17:51.639]                           if (inherits(master, c("SOCKnode", 
[16:17:51.639]                             "SOCK0node"))) {
[16:17:51.639]                             sendCondition <<- function(cond) {
[16:17:51.639]                               data <- list(type = "VALUE", value = cond, 
[16:17:51.639]                                 success = TRUE)
[16:17:51.639]                               parallel_sendData(master, data)
[16:17:51.639]                             }
[16:17:51.639]                             return(sendCondition)
[16:17:51.639]                           }
[16:17:51.639]                         }
[16:17:51.639]                         frame <- frame + 1L
[16:17:51.639]                         envir <- sys.frame(frame)
[16:17:51.639]                       }
[16:17:51.639]                     }
[16:17:51.639]                     sendCondition <<- function(cond) NULL
[16:17:51.639]                   }
[16:17:51.639]                 })
[16:17:51.639]                 withCallingHandlers({
[16:17:51.639]                   {
[16:17:51.639]                     do.call(function(...) {
[16:17:51.639]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:51.639]                       if (!identical(...future.globals.maxSize.org, 
[16:17:51.639]                         ...future.globals.maxSize)) {
[16:17:51.639]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:51.639]                         on.exit(options(oopts), add = TRUE)
[16:17:51.639]                       }
[16:17:51.639]                       {
[16:17:51.639]                         lapply(seq_along(...future.elements_ii), 
[16:17:51.639]                           FUN = function(jj) {
[16:17:51.639]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:51.639]                             ...future.FUN(...future.X_jj, ...)
[16:17:51.639]                           })
[16:17:51.639]                       }
[16:17:51.639]                     }, args = future.call.arguments)
[16:17:51.639]                   }
[16:17:51.639]                 }, immediateCondition = function(cond) {
[16:17:51.639]                   sendCondition <- ...future.makeSendCondition()
[16:17:51.639]                   sendCondition(cond)
[16:17:51.639]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.639]                   {
[16:17:51.639]                     inherits <- base::inherits
[16:17:51.639]                     invokeRestart <- base::invokeRestart
[16:17:51.639]                     is.null <- base::is.null
[16:17:51.639]                     muffled <- FALSE
[16:17:51.639]                     if (inherits(cond, "message")) {
[16:17:51.639]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:51.639]                       if (muffled) 
[16:17:51.639]                         invokeRestart("muffleMessage")
[16:17:51.639]                     }
[16:17:51.639]                     else if (inherits(cond, "warning")) {
[16:17:51.639]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:51.639]                       if (muffled) 
[16:17:51.639]                         invokeRestart("muffleWarning")
[16:17:51.639]                     }
[16:17:51.639]                     else if (inherits(cond, "condition")) {
[16:17:51.639]                       if (!is.null(pattern)) {
[16:17:51.639]                         computeRestarts <- base::computeRestarts
[16:17:51.639]                         grepl <- base::grepl
[16:17:51.639]                         restarts <- computeRestarts(cond)
[16:17:51.639]                         for (restart in restarts) {
[16:17:51.639]                           name <- restart$name
[16:17:51.639]                           if (is.null(name)) 
[16:17:51.639]                             next
[16:17:51.639]                           if (!grepl(pattern, name)) 
[16:17:51.639]                             next
[16:17:51.639]                           invokeRestart(restart)
[16:17:51.639]                           muffled <- TRUE
[16:17:51.639]                           break
[16:17:51.639]                         }
[16:17:51.639]                       }
[16:17:51.639]                     }
[16:17:51.639]                     invisible(muffled)
[16:17:51.639]                   }
[16:17:51.639]                   muffleCondition(cond)
[16:17:51.639]                 })
[16:17:51.639]             }))
[16:17:51.639]             future::FutureResult(value = ...future.value$value, 
[16:17:51.639]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:51.639]                   ...future.rng), globalenv = if (FALSE) 
[16:17:51.639]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:51.639]                     ...future.globalenv.names))
[16:17:51.639]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:51.639]         }, condition = base::local({
[16:17:51.639]             c <- base::c
[16:17:51.639]             inherits <- base::inherits
[16:17:51.639]             invokeRestart <- base::invokeRestart
[16:17:51.639]             length <- base::length
[16:17:51.639]             list <- base::list
[16:17:51.639]             seq.int <- base::seq.int
[16:17:51.639]             signalCondition <- base::signalCondition
[16:17:51.639]             sys.calls <- base::sys.calls
[16:17:51.639]             `[[` <- base::`[[`
[16:17:51.639]             `+` <- base::`+`
[16:17:51.639]             `<<-` <- base::`<<-`
[16:17:51.639]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:51.639]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:51.639]                   3L)]
[16:17:51.639]             }
[16:17:51.639]             function(cond) {
[16:17:51.639]                 is_error <- inherits(cond, "error")
[16:17:51.639]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:51.639]                   NULL)
[16:17:51.639]                 if (is_error) {
[16:17:51.639]                   sessionInformation <- function() {
[16:17:51.639]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:51.639]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:51.639]                       search = base::search(), system = base::Sys.info())
[16:17:51.639]                   }
[16:17:51.639]                   ...future.conditions[[length(...future.conditions) + 
[16:17:51.639]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:51.639]                     cond$call), session = sessionInformation(), 
[16:17:51.639]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:51.639]                   signalCondition(cond)
[16:17:51.639]                 }
[16:17:51.639]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:51.639]                 "immediateCondition"))) {
[16:17:51.639]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:51.639]                   ...future.conditions[[length(...future.conditions) + 
[16:17:51.639]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:51.639]                   if (TRUE && !signal) {
[16:17:51.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.639]                     {
[16:17:51.639]                       inherits <- base::inherits
[16:17:51.639]                       invokeRestart <- base::invokeRestart
[16:17:51.639]                       is.null <- base::is.null
[16:17:51.639]                       muffled <- FALSE
[16:17:51.639]                       if (inherits(cond, "message")) {
[16:17:51.639]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:51.639]                         if (muffled) 
[16:17:51.639]                           invokeRestart("muffleMessage")
[16:17:51.639]                       }
[16:17:51.639]                       else if (inherits(cond, "warning")) {
[16:17:51.639]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:51.639]                         if (muffled) 
[16:17:51.639]                           invokeRestart("muffleWarning")
[16:17:51.639]                       }
[16:17:51.639]                       else if (inherits(cond, "condition")) {
[16:17:51.639]                         if (!is.null(pattern)) {
[16:17:51.639]                           computeRestarts <- base::computeRestarts
[16:17:51.639]                           grepl <- base::grepl
[16:17:51.639]                           restarts <- computeRestarts(cond)
[16:17:51.639]                           for (restart in restarts) {
[16:17:51.639]                             name <- restart$name
[16:17:51.639]                             if (is.null(name)) 
[16:17:51.639]                               next
[16:17:51.639]                             if (!grepl(pattern, name)) 
[16:17:51.639]                               next
[16:17:51.639]                             invokeRestart(restart)
[16:17:51.639]                             muffled <- TRUE
[16:17:51.639]                             break
[16:17:51.639]                           }
[16:17:51.639]                         }
[16:17:51.639]                       }
[16:17:51.639]                       invisible(muffled)
[16:17:51.639]                     }
[16:17:51.639]                     muffleCondition(cond, pattern = "^muffle")
[16:17:51.639]                   }
[16:17:51.639]                 }
[16:17:51.639]                 else {
[16:17:51.639]                   if (TRUE) {
[16:17:51.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.639]                     {
[16:17:51.639]                       inherits <- base::inherits
[16:17:51.639]                       invokeRestart <- base::invokeRestart
[16:17:51.639]                       is.null <- base::is.null
[16:17:51.639]                       muffled <- FALSE
[16:17:51.639]                       if (inherits(cond, "message")) {
[16:17:51.639]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:51.639]                         if (muffled) 
[16:17:51.639]                           invokeRestart("muffleMessage")
[16:17:51.639]                       }
[16:17:51.639]                       else if (inherits(cond, "warning")) {
[16:17:51.639]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:51.639]                         if (muffled) 
[16:17:51.639]                           invokeRestart("muffleWarning")
[16:17:51.639]                       }
[16:17:51.639]                       else if (inherits(cond, "condition")) {
[16:17:51.639]                         if (!is.null(pattern)) {
[16:17:51.639]                           computeRestarts <- base::computeRestarts
[16:17:51.639]                           grepl <- base::grepl
[16:17:51.639]                           restarts <- computeRestarts(cond)
[16:17:51.639]                           for (restart in restarts) {
[16:17:51.639]                             name <- restart$name
[16:17:51.639]                             if (is.null(name)) 
[16:17:51.639]                               next
[16:17:51.639]                             if (!grepl(pattern, name)) 
[16:17:51.639]                               next
[16:17:51.639]                             invokeRestart(restart)
[16:17:51.639]                             muffled <- TRUE
[16:17:51.639]                             break
[16:17:51.639]                           }
[16:17:51.639]                         }
[16:17:51.639]                       }
[16:17:51.639]                       invisible(muffled)
[16:17:51.639]                     }
[16:17:51.639]                     muffleCondition(cond, pattern = "^muffle")
[16:17:51.639]                   }
[16:17:51.639]                 }
[16:17:51.639]             }
[16:17:51.639]         }))
[16:17:51.639]     }, error = function(ex) {
[16:17:51.639]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:51.639]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:51.639]                 ...future.rng), started = ...future.startTime, 
[16:17:51.639]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:51.639]             version = "1.8"), class = "FutureResult")
[16:17:51.639]     }, finally = {
[16:17:51.639]         if (!identical(...future.workdir, getwd())) 
[16:17:51.639]             setwd(...future.workdir)
[16:17:51.639]         {
[16:17:51.639]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:51.639]                 ...future.oldOptions$nwarnings <- NULL
[16:17:51.639]             }
[16:17:51.639]             base::options(...future.oldOptions)
[16:17:51.639]             if (.Platform$OS.type == "windows") {
[16:17:51.639]                 old_names <- names(...future.oldEnvVars)
[16:17:51.639]                 envs <- base::Sys.getenv()
[16:17:51.639]                 names <- names(envs)
[16:17:51.639]                 common <- intersect(names, old_names)
[16:17:51.639]                 added <- setdiff(names, old_names)
[16:17:51.639]                 removed <- setdiff(old_names, names)
[16:17:51.639]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:51.639]                   envs[common]]
[16:17:51.639]                 NAMES <- toupper(changed)
[16:17:51.639]                 args <- list()
[16:17:51.639]                 for (kk in seq_along(NAMES)) {
[16:17:51.639]                   name <- changed[[kk]]
[16:17:51.639]                   NAME <- NAMES[[kk]]
[16:17:51.639]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.639]                     next
[16:17:51.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:51.639]                 }
[16:17:51.639]                 NAMES <- toupper(added)
[16:17:51.639]                 for (kk in seq_along(NAMES)) {
[16:17:51.639]                   name <- added[[kk]]
[16:17:51.639]                   NAME <- NAMES[[kk]]
[16:17:51.639]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.639]                     next
[16:17:51.639]                   args[[name]] <- ""
[16:17:51.639]                 }
[16:17:51.639]                 NAMES <- toupper(removed)
[16:17:51.639]                 for (kk in seq_along(NAMES)) {
[16:17:51.639]                   name <- removed[[kk]]
[16:17:51.639]                   NAME <- NAMES[[kk]]
[16:17:51.639]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.639]                     next
[16:17:51.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:51.639]                 }
[16:17:51.639]                 if (length(args) > 0) 
[16:17:51.639]                   base::do.call(base::Sys.setenv, args = args)
[16:17:51.639]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:51.639]             }
[16:17:51.639]             else {
[16:17:51.639]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:51.639]             }
[16:17:51.639]             {
[16:17:51.639]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:51.639]                   0L) {
[16:17:51.639]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:51.639]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:51.639]                   base::options(opts)
[16:17:51.639]                 }
[16:17:51.639]                 {
[16:17:51.639]                   {
[16:17:51.639]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:51.639]                     NULL
[16:17:51.639]                   }
[16:17:51.639]                   options(future.plan = NULL)
[16:17:51.639]                   if (is.na(NA_character_)) 
[16:17:51.639]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:51.639]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:51.639]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:51.639]                     .init = FALSE)
[16:17:51.639]                 }
[16:17:51.639]             }
[16:17:51.639]         }
[16:17:51.639]     })
[16:17:51.639]     if (TRUE) {
[16:17:51.639]         base::sink(type = "output", split = FALSE)
[16:17:51.639]         if (TRUE) {
[16:17:51.639]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:51.639]         }
[16:17:51.639]         else {
[16:17:51.639]             ...future.result["stdout"] <- base::list(NULL)
[16:17:51.639]         }
[16:17:51.639]         base::close(...future.stdout)
[16:17:51.639]         ...future.stdout <- NULL
[16:17:51.639]     }
[16:17:51.639]     ...future.result$conditions <- ...future.conditions
[16:17:51.639]     ...future.result$finished <- base::Sys.time()
[16:17:51.639]     ...future.result
[16:17:51.639] }
[16:17:51.642] Exporting 5 global objects (1.22 KiB) to cluster node #2 ...
[16:17:51.642] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[16:17:51.643] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[16:17:51.643] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:17:51.643] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:17:51.643] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[16:17:51.644] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[16:17:51.644] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:17:51.644] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:17:51.645] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:17:51.645] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:17:51.645] Exporting 5 global objects (1.22 KiB) to cluster node #2 ... DONE
[16:17:51.646] MultisessionFuture started
[16:17:51.646] - Launch lazy future ... done
[16:17:51.646] run() for ‘MultisessionFuture’ ... done
[16:17:51.646] Created future:
[16:17:51.646] MultisessionFuture:
[16:17:51.646] Label: ‘future_eapply-2’
[16:17:51.646] Expression:
[16:17:51.646] {
[16:17:51.646]     do.call(function(...) {
[16:17:51.646]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:51.646]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:51.646]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:51.646]             on.exit(options(oopts), add = TRUE)
[16:17:51.646]         }
[16:17:51.646]         {
[16:17:51.646]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:51.646]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:51.646]                 ...future.FUN(...future.X_jj, ...)
[16:17:51.646]             })
[16:17:51.646]         }
[16:17:51.646]     }, args = future.call.arguments)
[16:17:51.646] }
[16:17:51.646] Lazy evaluation: FALSE
[16:17:51.646] Asynchronous evaluation: TRUE
[16:17:51.646] Local evaluation: TRUE
[16:17:51.646] Environment: R_GlobalEnv
[16:17:51.646] Capture standard output: TRUE
[16:17:51.646] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:51.646] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:51.646] Packages: 1 packages (‘stats’)
[16:17:51.646] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:51.646] Resolved: FALSE
[16:17:51.646] Value: <not collected>
[16:17:51.646] Conditions captured: <none>
[16:17:51.646] Early signaling: FALSE
[16:17:51.646] Owner process: 95d59565-e757-824f-7f5c-7f754384cffc
[16:17:51.646] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:51.658] Chunk #2 of 2 ... DONE
[16:17:51.658] Launching 2 futures (chunks) ... DONE
[16:17:51.658] Resolving 2 futures (chunks) ...
[16:17:51.658] resolve() on list ...
[16:17:51.658]  recursive: 0
[16:17:51.658]  length: 2
[16:17:51.658] 
[16:17:51.659] receiveMessageFromWorker() for ClusterFuture ...
[16:17:51.659] - Validating connection of MultisessionFuture
[16:17:51.659] - received message: FutureResult
[16:17:51.659] - Received FutureResult
[16:17:51.659] - Erased future from FutureRegistry
[16:17:51.659] result() for ClusterFuture ...
[16:17:51.659] - result already collected: FutureResult
[16:17:51.659] result() for ClusterFuture ... done
[16:17:51.660] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:51.660] Future #1
[16:17:51.660] result() for ClusterFuture ...
[16:17:51.660] - result already collected: FutureResult
[16:17:51.660] result() for ClusterFuture ... done
[16:17:51.660] result() for ClusterFuture ...
[16:17:51.660] - result already collected: FutureResult
[16:17:51.660] result() for ClusterFuture ... done
[16:17:51.660] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:17:51.660] - nx: 2
[16:17:51.660] - relay: TRUE
[16:17:51.661] - stdout: TRUE
[16:17:51.661] - signal: TRUE
[16:17:51.661] - resignal: FALSE
[16:17:51.661] - force: TRUE
[16:17:51.661] - relayed: [n=2] FALSE, FALSE
[16:17:51.661] - queued futures: [n=2] FALSE, FALSE
[16:17:51.661]  - until=1
[16:17:51.661]  - relaying element #1
[16:17:51.661] result() for ClusterFuture ...
[16:17:51.661] - result already collected: FutureResult
[16:17:51.661] result() for ClusterFuture ... done
[16:17:51.662] result() for ClusterFuture ...
[16:17:51.662] - result already collected: FutureResult
[16:17:51.662] result() for ClusterFuture ... done
[16:17:51.662] result() for ClusterFuture ...
[16:17:51.662] - result already collected: FutureResult
[16:17:51.662] result() for ClusterFuture ... done
[16:17:51.662] result() for ClusterFuture ...
[16:17:51.662] - result already collected: FutureResult
[16:17:51.662] result() for ClusterFuture ... done
[16:17:51.662] - relayed: [n=2] TRUE, FALSE
[16:17:51.662] - queued futures: [n=2] TRUE, FALSE
[16:17:51.663] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:17:51.663]  length: 1 (resolved future 1)
[16:17:51.691] receiveMessageFromWorker() for ClusterFuture ...
[16:17:51.691] - Validating connection of MultisessionFuture
[16:17:51.691] - received message: FutureResult
[16:17:51.691] - Received FutureResult
[16:17:51.691] - Erased future from FutureRegistry
[16:17:51.692] result() for ClusterFuture ...
[16:17:51.692] - result already collected: FutureResult
[16:17:51.692] result() for ClusterFuture ... done
[16:17:51.692] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:51.692] Future #2
[16:17:51.692] result() for ClusterFuture ...
[16:17:51.692] - result already collected: FutureResult
[16:17:51.692] result() for ClusterFuture ... done
[16:17:51.692] result() for ClusterFuture ...
[16:17:51.692] - result already collected: FutureResult
[16:17:51.693] result() for ClusterFuture ... done
[16:17:51.693] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:17:51.693] - nx: 2
[16:17:51.693] - relay: TRUE
[16:17:51.693] - stdout: TRUE
[16:17:51.693] - signal: TRUE
[16:17:51.693] - resignal: FALSE
[16:17:51.693] - force: TRUE
[16:17:51.693] - relayed: [n=2] TRUE, FALSE
[16:17:51.693] - queued futures: [n=2] TRUE, FALSE
[16:17:51.693]  - until=2
[16:17:51.694]  - relaying element #2
[16:17:51.694] result() for ClusterFuture ...
[16:17:51.694] - result already collected: FutureResult
[16:17:51.694] result() for ClusterFuture ... done
[16:17:51.694] result() for ClusterFuture ...
[16:17:51.694] - result already collected: FutureResult
[16:17:51.694] result() for ClusterFuture ... done
[16:17:51.694] result() for ClusterFuture ...
[16:17:51.694] - result already collected: FutureResult
[16:17:51.694] result() for ClusterFuture ... done
[16:17:51.694] result() for ClusterFuture ...
[16:17:51.695] - result already collected: FutureResult
[16:17:51.695] result() for ClusterFuture ... done
[16:17:51.695] - relayed: [n=2] TRUE, TRUE
[16:17:51.695] - queued futures: [n=2] TRUE, TRUE
[16:17:51.695] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:17:51.695]  length: 0 (resolved future 2)
[16:17:51.695] Relaying remaining futures
[16:17:51.695] signalConditionsASAP(NULL, pos=0) ...
[16:17:51.695] - nx: 2
[16:17:51.695] - relay: TRUE
[16:17:51.695] - stdout: TRUE
[16:17:51.696] - signal: TRUE
[16:17:51.696] - resignal: FALSE
[16:17:51.696] - force: TRUE
[16:17:51.696] - relayed: [n=2] TRUE, TRUE
[16:17:51.696] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:51.696] - relayed: [n=2] TRUE, TRUE
[16:17:51.696] - queued futures: [n=2] TRUE, TRUE
[16:17:51.696] signalConditionsASAP(NULL, pos=0) ... done
[16:17:51.696] resolve() on list ... DONE
[16:17:51.696] result() for ClusterFuture ...
[16:17:51.697] - result already collected: FutureResult
[16:17:51.697] result() for ClusterFuture ... done
[16:17:51.697] result() for ClusterFuture ...
[16:17:51.697] - result already collected: FutureResult
[16:17:51.697] result() for ClusterFuture ... done
[16:17:51.697] result() for ClusterFuture ...
[16:17:51.697] - result already collected: FutureResult
[16:17:51.697] result() for ClusterFuture ... done
[16:17:51.697] result() for ClusterFuture ...
[16:17:51.697] - result already collected: FutureResult
[16:17:51.697] result() for ClusterFuture ... done
[16:17:51.698]  - Number of value chunks collected: 2
[16:17:51.698] Resolving 2 futures (chunks) ... DONE
[16:17:51.698] Reducing values from 2 chunks ...
[16:17:51.698]  - Number of values collected after concatenation: 3
[16:17:51.698]  - Number of values expected: 3
[16:17:51.698] Reducing values from 2 chunks ... DONE
[16:17:51.698] future_lapply() ... DONE
[16:17:51.698] future_lapply() ...
[16:17:51.703] Number of chunks: 2
[16:17:51.703] getGlobalsAndPackagesXApply() ...
[16:17:51.703]  - future.globals: TRUE
[16:17:51.703] getGlobalsAndPackages() ...
[16:17:51.703] Searching for globals...
[16:17:51.705] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:17:51.705] Searching for globals ... DONE
[16:17:51.705] Resolving globals: FALSE
[16:17:51.705] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:17:51.706] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:17:51.706] - globals: [1] ‘FUN’
[16:17:51.706] - packages: [1] ‘stats’
[16:17:51.706] getGlobalsAndPackages() ... DONE
[16:17:51.706]  - globals found/used: [n=1] ‘FUN’
[16:17:51.706]  - needed namespaces: [n=1] ‘stats’
[16:17:51.706] Finding globals ... DONE
[16:17:51.706]  - use_args: TRUE
[16:17:51.706]  - Getting '...' globals ...
[16:17:51.707] resolve() on list ...
[16:17:51.707]  recursive: 0
[16:17:51.707]  length: 1
[16:17:51.707]  elements: ‘...’
[16:17:51.707]  length: 0 (resolved future 1)
[16:17:51.707] resolve() on list ... DONE
[16:17:51.707]    - '...' content: [n=0] 
[16:17:51.707] List of 1
[16:17:51.707]  $ ...: list()
[16:17:51.707]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:51.707]  - attr(*, "where")=List of 1
[16:17:51.707]   ..$ ...:<environment: 0x556da603afe0> 
[16:17:51.707]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:51.707]  - attr(*, "resolved")= logi TRUE
[16:17:51.707]  - attr(*, "total_size")= num NA
[16:17:51.710]  - Getting '...' globals ... DONE
[16:17:51.710] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:17:51.710] List of 2
[16:17:51.710]  $ ...future.FUN:function (x, ...)  
[16:17:51.710]  $ ...          : list()
[16:17:51.710]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:17:51.710]  - attr(*, "where")=List of 2
[16:17:51.710]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:17:51.710]   ..$ ...          :<environment: 0x556da603afe0> 
[16:17:51.710]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:17:51.710]  - attr(*, "resolved")= logi FALSE
[16:17:51.710]  - attr(*, "total_size")= num 1248
[16:17:51.713] Packages to be attached in all futures: [n=1] ‘stats’
[16:17:51.713] getGlobalsAndPackagesXApply() ... DONE
[16:17:51.713] Number of futures (= number of chunks): 2
[16:17:51.713] Launching 2 futures (chunks) ...
[16:17:51.714] Chunk #1 of 2 ...
[16:17:51.714]  - Finding globals in 'X' for chunk #1 ...
[16:17:51.714] getGlobalsAndPackages() ...
[16:17:51.714] Searching for globals...
[16:17:51.714] 
[16:17:51.714] Searching for globals ... DONE
[16:17:51.714] - globals: [0] <none>
[16:17:51.714] getGlobalsAndPackages() ... DONE
[16:17:51.714]    + additional globals found: [n=0] 
[16:17:51.715]    + additional namespaces needed: [n=0] 
[16:17:51.715]  - Finding globals in 'X' for chunk #1 ... DONE
[16:17:51.715]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:51.715]  - seeds: <none>
[16:17:51.715]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:51.715] getGlobalsAndPackages() ...
[16:17:51.715] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:51.715] Resolving globals: FALSE
[16:17:51.715] Tweak future expression to call with '...' arguments ...
[16:17:51.716] {
[16:17:51.716]     do.call(function(...) {
[16:17:51.716]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:51.716]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:51.716]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:51.716]             on.exit(options(oopts), add = TRUE)
[16:17:51.716]         }
[16:17:51.716]         {
[16:17:51.716]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:51.716]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:51.716]                 ...future.FUN(...future.X_jj, ...)
[16:17:51.716]             })
[16:17:51.716]         }
[16:17:51.716]     }, args = future.call.arguments)
[16:17:51.716] }
[16:17:51.716] Tweak future expression to call with '...' arguments ... DONE
[16:17:51.716] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:51.716] - packages: [1] ‘stats’
[16:17:51.716] getGlobalsAndPackages() ... DONE
[16:17:51.717] run() for ‘Future’ ...
[16:17:51.717] - state: ‘created’
[16:17:51.717] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:51.730] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:51.730] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:51.731]   - Field: ‘node’
[16:17:51.731]   - Field: ‘label’
[16:17:51.731]   - Field: ‘local’
[16:17:51.731]   - Field: ‘owner’
[16:17:51.731]   - Field: ‘envir’
[16:17:51.731]   - Field: ‘workers’
[16:17:51.731]   - Field: ‘packages’
[16:17:51.731]   - Field: ‘gc’
[16:17:51.731]   - Field: ‘conditions’
[16:17:51.731]   - Field: ‘persistent’
[16:17:51.731]   - Field: ‘expr’
[16:17:51.732]   - Field: ‘uuid’
[16:17:51.732]   - Field: ‘seed’
[16:17:51.732]   - Field: ‘version’
[16:17:51.732]   - Field: ‘result’
[16:17:51.732]   - Field: ‘asynchronous’
[16:17:51.732]   - Field: ‘calls’
[16:17:51.732]   - Field: ‘globals’
[16:17:51.732]   - Field: ‘stdout’
[16:17:51.732]   - Field: ‘earlySignal’
[16:17:51.732]   - Field: ‘lazy’
[16:17:51.733]   - Field: ‘state’
[16:17:51.733] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:51.733] - Launch lazy future ...
[16:17:51.733] Packages needed by the future expression (n = 1): ‘stats’
[16:17:51.733] Packages needed by future strategies (n = 0): <none>
[16:17:51.734] {
[16:17:51.734]     {
[16:17:51.734]         {
[16:17:51.734]             ...future.startTime <- base::Sys.time()
[16:17:51.734]             {
[16:17:51.734]                 {
[16:17:51.734]                   {
[16:17:51.734]                     {
[16:17:51.734]                       {
[16:17:51.734]                         base::local({
[16:17:51.734]                           has_future <- base::requireNamespace("future", 
[16:17:51.734]                             quietly = TRUE)
[16:17:51.734]                           if (has_future) {
[16:17:51.734]                             ns <- base::getNamespace("future")
[16:17:51.734]                             version <- ns[[".package"]][["version"]]
[16:17:51.734]                             if (is.null(version)) 
[16:17:51.734]                               version <- utils::packageVersion("future")
[16:17:51.734]                           }
[16:17:51.734]                           else {
[16:17:51.734]                             version <- NULL
[16:17:51.734]                           }
[16:17:51.734]                           if (!has_future || version < "1.8.0") {
[16:17:51.734]                             info <- base::c(r_version = base::gsub("R version ", 
[16:17:51.734]                               "", base::R.version$version.string), 
[16:17:51.734]                               platform = base::sprintf("%s (%s-bit)", 
[16:17:51.734]                                 base::R.version$platform, 8 * 
[16:17:51.734]                                   base::.Machine$sizeof.pointer), 
[16:17:51.734]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:51.734]                                 "release", "version")], collapse = " "), 
[16:17:51.734]                               hostname = base::Sys.info()[["nodename"]])
[16:17:51.734]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:17:51.734]                               info)
[16:17:51.734]                             info <- base::paste(info, collapse = "; ")
[16:17:51.734]                             if (!has_future) {
[16:17:51.734]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:51.734]                                 info)
[16:17:51.734]                             }
[16:17:51.734]                             else {
[16:17:51.734]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:51.734]                                 info, version)
[16:17:51.734]                             }
[16:17:51.734]                             base::stop(msg)
[16:17:51.734]                           }
[16:17:51.734]                         })
[16:17:51.734]                       }
[16:17:51.734]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:51.734]                       base::options(mc.cores = 1L)
[16:17:51.734]                     }
[16:17:51.734]                     base::local({
[16:17:51.734]                       for (pkg in "stats") {
[16:17:51.734]                         base::loadNamespace(pkg)
[16:17:51.734]                         base::library(pkg, character.only = TRUE)
[16:17:51.734]                       }
[16:17:51.734]                     })
[16:17:51.734]                   }
[16:17:51.734]                   ...future.strategy.old <- future::plan("list")
[16:17:51.734]                   options(future.plan = NULL)
[16:17:51.734]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:51.734]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:51.734]                 }
[16:17:51.734]                 ...future.workdir <- getwd()
[16:17:51.734]             }
[16:17:51.734]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:51.734]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:51.734]         }
[16:17:51.734]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:51.734]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:51.734]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:51.734]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:51.734]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:51.734]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:51.734]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:51.734]             base::names(...future.oldOptions))
[16:17:51.734]     }
[16:17:51.734]     if (FALSE) {
[16:17:51.734]     }
[16:17:51.734]     else {
[16:17:51.734]         if (TRUE) {
[16:17:51.734]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:51.734]                 open = "w")
[16:17:51.734]         }
[16:17:51.734]         else {
[16:17:51.734]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:51.734]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:51.734]         }
[16:17:51.734]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:51.734]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:51.734]             base::sink(type = "output", split = FALSE)
[16:17:51.734]             base::close(...future.stdout)
[16:17:51.734]         }, add = TRUE)
[16:17:51.734]     }
[16:17:51.734]     ...future.frame <- base::sys.nframe()
[16:17:51.734]     ...future.conditions <- base::list()
[16:17:51.734]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:51.734]     if (FALSE) {
[16:17:51.734]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:51.734]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:51.734]     }
[16:17:51.734]     ...future.result <- base::tryCatch({
[16:17:51.734]         base::withCallingHandlers({
[16:17:51.734]             ...future.value <- base::withVisible(base::local({
[16:17:51.734]                 ...future.makeSendCondition <- base::local({
[16:17:51.734]                   sendCondition <- NULL
[16:17:51.734]                   function(frame = 1L) {
[16:17:51.734]                     if (is.function(sendCondition)) 
[16:17:51.734]                       return(sendCondition)
[16:17:51.734]                     ns <- getNamespace("parallel")
[16:17:51.734]                     if (exists("sendData", mode = "function", 
[16:17:51.734]                       envir = ns)) {
[16:17:51.734]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:51.734]                         envir = ns)
[16:17:51.734]                       envir <- sys.frame(frame)
[16:17:51.734]                       master <- NULL
[16:17:51.734]                       while (!identical(envir, .GlobalEnv) && 
[16:17:51.734]                         !identical(envir, emptyenv())) {
[16:17:51.734]                         if (exists("master", mode = "list", envir = envir, 
[16:17:51.734]                           inherits = FALSE)) {
[16:17:51.734]                           master <- get("master", mode = "list", 
[16:17:51.734]                             envir = envir, inherits = FALSE)
[16:17:51.734]                           if (inherits(master, c("SOCKnode", 
[16:17:51.734]                             "SOCK0node"))) {
[16:17:51.734]                             sendCondition <<- function(cond) {
[16:17:51.734]                               data <- list(type = "VALUE", value = cond, 
[16:17:51.734]                                 success = TRUE)
[16:17:51.734]                               parallel_sendData(master, data)
[16:17:51.734]                             }
[16:17:51.734]                             return(sendCondition)
[16:17:51.734]                           }
[16:17:51.734]                         }
[16:17:51.734]                         frame <- frame + 1L
[16:17:51.734]                         envir <- sys.frame(frame)
[16:17:51.734]                       }
[16:17:51.734]                     }
[16:17:51.734]                     sendCondition <<- function(cond) NULL
[16:17:51.734]                   }
[16:17:51.734]                 })
[16:17:51.734]                 withCallingHandlers({
[16:17:51.734]                   {
[16:17:51.734]                     do.call(function(...) {
[16:17:51.734]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:51.734]                       if (!identical(...future.globals.maxSize.org, 
[16:17:51.734]                         ...future.globals.maxSize)) {
[16:17:51.734]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:51.734]                         on.exit(options(oopts), add = TRUE)
[16:17:51.734]                       }
[16:17:51.734]                       {
[16:17:51.734]                         lapply(seq_along(...future.elements_ii), 
[16:17:51.734]                           FUN = function(jj) {
[16:17:51.734]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:51.734]                             ...future.FUN(...future.X_jj, ...)
[16:17:51.734]                           })
[16:17:51.734]                       }
[16:17:51.734]                     }, args = future.call.arguments)
[16:17:51.734]                   }
[16:17:51.734]                 }, immediateCondition = function(cond) {
[16:17:51.734]                   sendCondition <- ...future.makeSendCondition()
[16:17:51.734]                   sendCondition(cond)
[16:17:51.734]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.734]                   {
[16:17:51.734]                     inherits <- base::inherits
[16:17:51.734]                     invokeRestart <- base::invokeRestart
[16:17:51.734]                     is.null <- base::is.null
[16:17:51.734]                     muffled <- FALSE
[16:17:51.734]                     if (inherits(cond, "message")) {
[16:17:51.734]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:51.734]                       if (muffled) 
[16:17:51.734]                         invokeRestart("muffleMessage")
[16:17:51.734]                     }
[16:17:51.734]                     else if (inherits(cond, "warning")) {
[16:17:51.734]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:51.734]                       if (muffled) 
[16:17:51.734]                         invokeRestart("muffleWarning")
[16:17:51.734]                     }
[16:17:51.734]                     else if (inherits(cond, "condition")) {
[16:17:51.734]                       if (!is.null(pattern)) {
[16:17:51.734]                         computeRestarts <- base::computeRestarts
[16:17:51.734]                         grepl <- base::grepl
[16:17:51.734]                         restarts <- computeRestarts(cond)
[16:17:51.734]                         for (restart in restarts) {
[16:17:51.734]                           name <- restart$name
[16:17:51.734]                           if (is.null(name)) 
[16:17:51.734]                             next
[16:17:51.734]                           if (!grepl(pattern, name)) 
[16:17:51.734]                             next
[16:17:51.734]                           invokeRestart(restart)
[16:17:51.734]                           muffled <- TRUE
[16:17:51.734]                           break
[16:17:51.734]                         }
[16:17:51.734]                       }
[16:17:51.734]                     }
[16:17:51.734]                     invisible(muffled)
[16:17:51.734]                   }
[16:17:51.734]                   muffleCondition(cond)
[16:17:51.734]                 })
[16:17:51.734]             }))
[16:17:51.734]             future::FutureResult(value = ...future.value$value, 
[16:17:51.734]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:51.734]                   ...future.rng), globalenv = if (FALSE) 
[16:17:51.734]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:51.734]                     ...future.globalenv.names))
[16:17:51.734]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:51.734]         }, condition = base::local({
[16:17:51.734]             c <- base::c
[16:17:51.734]             inherits <- base::inherits
[16:17:51.734]             invokeRestart <- base::invokeRestart
[16:17:51.734]             length <- base::length
[16:17:51.734]             list <- base::list
[16:17:51.734]             seq.int <- base::seq.int
[16:17:51.734]             signalCondition <- base::signalCondition
[16:17:51.734]             sys.calls <- base::sys.calls
[16:17:51.734]             `[[` <- base::`[[`
[16:17:51.734]             `+` <- base::`+`
[16:17:51.734]             `<<-` <- base::`<<-`
[16:17:51.734]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:51.734]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:51.734]                   3L)]
[16:17:51.734]             }
[16:17:51.734]             function(cond) {
[16:17:51.734]                 is_error <- inherits(cond, "error")
[16:17:51.734]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:51.734]                   NULL)
[16:17:51.734]                 if (is_error) {
[16:17:51.734]                   sessionInformation <- function() {
[16:17:51.734]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:51.734]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:51.734]                       search = base::search(), system = base::Sys.info())
[16:17:51.734]                   }
[16:17:51.734]                   ...future.conditions[[length(...future.conditions) + 
[16:17:51.734]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:51.734]                     cond$call), session = sessionInformation(), 
[16:17:51.734]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:51.734]                   signalCondition(cond)
[16:17:51.734]                 }
[16:17:51.734]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:51.734]                 "immediateCondition"))) {
[16:17:51.734]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:51.734]                   ...future.conditions[[length(...future.conditions) + 
[16:17:51.734]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:51.734]                   if (TRUE && !signal) {
[16:17:51.734]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.734]                     {
[16:17:51.734]                       inherits <- base::inherits
[16:17:51.734]                       invokeRestart <- base::invokeRestart
[16:17:51.734]                       is.null <- base::is.null
[16:17:51.734]                       muffled <- FALSE
[16:17:51.734]                       if (inherits(cond, "message")) {
[16:17:51.734]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:51.734]                         if (muffled) 
[16:17:51.734]                           invokeRestart("muffleMessage")
[16:17:51.734]                       }
[16:17:51.734]                       else if (inherits(cond, "warning")) {
[16:17:51.734]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:51.734]                         if (muffled) 
[16:17:51.734]                           invokeRestart("muffleWarning")
[16:17:51.734]                       }
[16:17:51.734]                       else if (inherits(cond, "condition")) {
[16:17:51.734]                         if (!is.null(pattern)) {
[16:17:51.734]                           computeRestarts <- base::computeRestarts
[16:17:51.734]                           grepl <- base::grepl
[16:17:51.734]                           restarts <- computeRestarts(cond)
[16:17:51.734]                           for (restart in restarts) {
[16:17:51.734]                             name <- restart$name
[16:17:51.734]                             if (is.null(name)) 
[16:17:51.734]                               next
[16:17:51.734]                             if (!grepl(pattern, name)) 
[16:17:51.734]                               next
[16:17:51.734]                             invokeRestart(restart)
[16:17:51.734]                             muffled <- TRUE
[16:17:51.734]                             break
[16:17:51.734]                           }
[16:17:51.734]                         }
[16:17:51.734]                       }
[16:17:51.734]                       invisible(muffled)
[16:17:51.734]                     }
[16:17:51.734]                     muffleCondition(cond, pattern = "^muffle")
[16:17:51.734]                   }
[16:17:51.734]                 }
[16:17:51.734]                 else {
[16:17:51.734]                   if (TRUE) {
[16:17:51.734]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.734]                     {
[16:17:51.734]                       inherits <- base::inherits
[16:17:51.734]                       invokeRestart <- base::invokeRestart
[16:17:51.734]                       is.null <- base::is.null
[16:17:51.734]                       muffled <- FALSE
[16:17:51.734]                       if (inherits(cond, "message")) {
[16:17:51.734]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:51.734]                         if (muffled) 
[16:17:51.734]                           invokeRestart("muffleMessage")
[16:17:51.734]                       }
[16:17:51.734]                       else if (inherits(cond, "warning")) {
[16:17:51.734]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:51.734]                         if (muffled) 
[16:17:51.734]                           invokeRestart("muffleWarning")
[16:17:51.734]                       }
[16:17:51.734]                       else if (inherits(cond, "condition")) {
[16:17:51.734]                         if (!is.null(pattern)) {
[16:17:51.734]                           computeRestarts <- base::computeRestarts
[16:17:51.734]                           grepl <- base::grepl
[16:17:51.734]                           restarts <- computeRestarts(cond)
[16:17:51.734]                           for (restart in restarts) {
[16:17:51.734]                             name <- restart$name
[16:17:51.734]                             if (is.null(name)) 
[16:17:51.734]                               next
[16:17:51.734]                             if (!grepl(pattern, name)) 
[16:17:51.734]                               next
[16:17:51.734]                             invokeRestart(restart)
[16:17:51.734]                             muffled <- TRUE
[16:17:51.734]                             break
[16:17:51.734]                           }
[16:17:51.734]                         }
[16:17:51.734]                       }
[16:17:51.734]                       invisible(muffled)
[16:17:51.734]                     }
[16:17:51.734]                     muffleCondition(cond, pattern = "^muffle")
[16:17:51.734]                   }
[16:17:51.734]                 }
[16:17:51.734]             }
[16:17:51.734]         }))
[16:17:51.734]     }, error = function(ex) {
[16:17:51.734]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:51.734]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:51.734]                 ...future.rng), started = ...future.startTime, 
[16:17:51.734]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:51.734]             version = "1.8"), class = "FutureResult")
[16:17:51.734]     }, finally = {
[16:17:51.734]         if (!identical(...future.workdir, getwd())) 
[16:17:51.734]             setwd(...future.workdir)
[16:17:51.734]         {
[16:17:51.734]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:51.734]                 ...future.oldOptions$nwarnings <- NULL
[16:17:51.734]             }
[16:17:51.734]             base::options(...future.oldOptions)
[16:17:51.734]             if (.Platform$OS.type == "windows") {
[16:17:51.734]                 old_names <- names(...future.oldEnvVars)
[16:17:51.734]                 envs <- base::Sys.getenv()
[16:17:51.734]                 names <- names(envs)
[16:17:51.734]                 common <- intersect(names, old_names)
[16:17:51.734]                 added <- setdiff(names, old_names)
[16:17:51.734]                 removed <- setdiff(old_names, names)
[16:17:51.734]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:51.734]                   envs[common]]
[16:17:51.734]                 NAMES <- toupper(changed)
[16:17:51.734]                 args <- list()
[16:17:51.734]                 for (kk in seq_along(NAMES)) {
[16:17:51.734]                   name <- changed[[kk]]
[16:17:51.734]                   NAME <- NAMES[[kk]]
[16:17:51.734]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.734]                     next
[16:17:51.734]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:51.734]                 }
[16:17:51.734]                 NAMES <- toupper(added)
[16:17:51.734]                 for (kk in seq_along(NAMES)) {
[16:17:51.734]                   name <- added[[kk]]
[16:17:51.734]                   NAME <- NAMES[[kk]]
[16:17:51.734]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.734]                     next
[16:17:51.734]                   args[[name]] <- ""
[16:17:51.734]                 }
[16:17:51.734]                 NAMES <- toupper(removed)
[16:17:51.734]                 for (kk in seq_along(NAMES)) {
[16:17:51.734]                   name <- removed[[kk]]
[16:17:51.734]                   NAME <- NAMES[[kk]]
[16:17:51.734]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.734]                     next
[16:17:51.734]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:51.734]                 }
[16:17:51.734]                 if (length(args) > 0) 
[16:17:51.734]                   base::do.call(base::Sys.setenv, args = args)
[16:17:51.734]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:51.734]             }
[16:17:51.734]             else {
[16:17:51.734]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:51.734]             }
[16:17:51.734]             {
[16:17:51.734]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:51.734]                   0L) {
[16:17:51.734]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:51.734]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:51.734]                   base::options(opts)
[16:17:51.734]                 }
[16:17:51.734]                 {
[16:17:51.734]                   {
[16:17:51.734]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:51.734]                     NULL
[16:17:51.734]                   }
[16:17:51.734]                   options(future.plan = NULL)
[16:17:51.734]                   if (is.na(NA_character_)) 
[16:17:51.734]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:51.734]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:51.734]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:51.734]                     .init = FALSE)
[16:17:51.734]                 }
[16:17:51.734]             }
[16:17:51.734]         }
[16:17:51.734]     })
[16:17:51.734]     if (TRUE) {
[16:17:51.734]         base::sink(type = "output", split = FALSE)
[16:17:51.734]         if (TRUE) {
[16:17:51.734]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:51.734]         }
[16:17:51.734]         else {
[16:17:51.734]             ...future.result["stdout"] <- base::list(NULL)
[16:17:51.734]         }
[16:17:51.734]         base::close(...future.stdout)
[16:17:51.734]         ...future.stdout <- NULL
[16:17:51.734]     }
[16:17:51.734]     ...future.result$conditions <- ...future.conditions
[16:17:51.734]     ...future.result$finished <- base::Sys.time()
[16:17:51.734]     ...future.result
[16:17:51.734] }
[16:17:51.736] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[16:17:51.737] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[16:17:51.737] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[16:17:51.737] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:17:51.738] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:17:51.738] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[16:17:51.738] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[16:17:51.738] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:17:51.739] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:17:51.739] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:17:51.739] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:17:51.739] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[16:17:51.740] MultisessionFuture started
[16:17:51.740] - Launch lazy future ... done
[16:17:51.740] run() for ‘MultisessionFuture’ ... done
[16:17:51.740] Created future:
[16:17:51.740] MultisessionFuture:
[16:17:51.740] Label: ‘future_eapply-1’
[16:17:51.740] Expression:
[16:17:51.740] {
[16:17:51.740]     do.call(function(...) {
[16:17:51.740]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:51.740]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:51.740]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:51.740]             on.exit(options(oopts), add = TRUE)
[16:17:51.740]         }
[16:17:51.740]         {
[16:17:51.740]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:51.740]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:51.740]                 ...future.FUN(...future.X_jj, ...)
[16:17:51.740]             })
[16:17:51.740]         }
[16:17:51.740]     }, args = future.call.arguments)
[16:17:51.740] }
[16:17:51.740] Lazy evaluation: FALSE
[16:17:51.740] Asynchronous evaluation: TRUE
[16:17:51.740] Local evaluation: TRUE
[16:17:51.740] Environment: R_GlobalEnv
[16:17:51.740] Capture standard output: TRUE
[16:17:51.740] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:51.740] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:51.740] Packages: 1 packages (‘stats’)
[16:17:51.740] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:51.740] Resolved: FALSE
[16:17:51.740] Value: <not collected>
[16:17:51.740] Conditions captured: <none>
[16:17:51.740] Early signaling: FALSE
[16:17:51.740] Owner process: 95d59565-e757-824f-7f5c-7f754384cffc
[16:17:51.740] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:51.752] Chunk #1 of 2 ... DONE
[16:17:51.752] Chunk #2 of 2 ...
[16:17:51.752]  - Finding globals in 'X' for chunk #2 ...
[16:17:51.752] getGlobalsAndPackages() ...
[16:17:51.752] Searching for globals...
[16:17:51.753] 
[16:17:51.753] Searching for globals ... DONE
[16:17:51.753] - globals: [0] <none>
[16:17:51.753] getGlobalsAndPackages() ... DONE
[16:17:51.753]    + additional globals found: [n=0] 
[16:17:51.753]    + additional namespaces needed: [n=0] 
[16:17:51.753]  - Finding globals in 'X' for chunk #2 ... DONE
[16:17:51.753]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:17:51.753]  - seeds: <none>
[16:17:51.753]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:51.754] getGlobalsAndPackages() ...
[16:17:51.754] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:51.754] Resolving globals: FALSE
[16:17:51.754] Tweak future expression to call with '...' arguments ...
[16:17:51.754] {
[16:17:51.754]     do.call(function(...) {
[16:17:51.754]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:51.754]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:51.754]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:51.754]             on.exit(options(oopts), add = TRUE)
[16:17:51.754]         }
[16:17:51.754]         {
[16:17:51.754]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:51.754]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:51.754]                 ...future.FUN(...future.X_jj, ...)
[16:17:51.754]             })
[16:17:51.754]         }
[16:17:51.754]     }, args = future.call.arguments)
[16:17:51.754] }
[16:17:51.754] Tweak future expression to call with '...' arguments ... DONE
[16:17:51.755] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:17:51.755] - packages: [1] ‘stats’
[16:17:51.755] getGlobalsAndPackages() ... DONE
[16:17:51.755] run() for ‘Future’ ...
[16:17:51.757] - state: ‘created’
[16:17:51.757] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:17:51.771] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:51.771] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:17:51.771]   - Field: ‘node’
[16:17:51.771]   - Field: ‘label’
[16:17:51.771]   - Field: ‘local’
[16:17:51.772]   - Field: ‘owner’
[16:17:51.772]   - Field: ‘envir’
[16:17:51.772]   - Field: ‘workers’
[16:17:51.772]   - Field: ‘packages’
[16:17:51.772]   - Field: ‘gc’
[16:17:51.772]   - Field: ‘conditions’
[16:17:51.772]   - Field: ‘persistent’
[16:17:51.772]   - Field: ‘expr’
[16:17:51.772]   - Field: ‘uuid’
[16:17:51.772]   - Field: ‘seed’
[16:17:51.772]   - Field: ‘version’
[16:17:51.773]   - Field: ‘result’
[16:17:51.773]   - Field: ‘asynchronous’
[16:17:51.773]   - Field: ‘calls’
[16:17:51.773]   - Field: ‘globals’
[16:17:51.773]   - Field: ‘stdout’
[16:17:51.773]   - Field: ‘earlySignal’
[16:17:51.773]   - Field: ‘lazy’
[16:17:51.773]   - Field: ‘state’
[16:17:51.773] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:17:51.773] - Launch lazy future ...
[16:17:51.774] Packages needed by the future expression (n = 1): ‘stats’
[16:17:51.774] Packages needed by future strategies (n = 0): <none>
[16:17:51.774] {
[16:17:51.774]     {
[16:17:51.774]         {
[16:17:51.774]             ...future.startTime <- base::Sys.time()
[16:17:51.774]             {
[16:17:51.774]                 {
[16:17:51.774]                   {
[16:17:51.774]                     {
[16:17:51.774]                       {
[16:17:51.774]                         base::local({
[16:17:51.774]                           has_future <- base::requireNamespace("future", 
[16:17:51.774]                             quietly = TRUE)
[16:17:51.774]                           if (has_future) {
[16:17:51.774]                             ns <- base::getNamespace("future")
[16:17:51.774]                             version <- ns[[".package"]][["version"]]
[16:17:51.774]                             if (is.null(version)) 
[16:17:51.774]                               version <- utils::packageVersion("future")
[16:17:51.774]                           }
[16:17:51.774]                           else {
[16:17:51.774]                             version <- NULL
[16:17:51.774]                           }
[16:17:51.774]                           if (!has_future || version < "1.8.0") {
[16:17:51.774]                             info <- base::c(r_version = base::gsub("R version ", 
[16:17:51.774]                               "", base::R.version$version.string), 
[16:17:51.774]                               platform = base::sprintf("%s (%s-bit)", 
[16:17:51.774]                                 base::R.version$platform, 8 * 
[16:17:51.774]                                   base::.Machine$sizeof.pointer), 
[16:17:51.774]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:17:51.774]                                 "release", "version")], collapse = " "), 
[16:17:51.774]                               hostname = base::Sys.info()[["nodename"]])
[16:17:51.774]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:17:51.774]                               info)
[16:17:51.774]                             info <- base::paste(info, collapse = "; ")
[16:17:51.774]                             if (!has_future) {
[16:17:51.774]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:17:51.774]                                 info)
[16:17:51.774]                             }
[16:17:51.774]                             else {
[16:17:51.774]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:17:51.774]                                 info, version)
[16:17:51.774]                             }
[16:17:51.774]                             base::stop(msg)
[16:17:51.774]                           }
[16:17:51.774]                         })
[16:17:51.774]                       }
[16:17:51.774]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:17:51.774]                       base::options(mc.cores = 1L)
[16:17:51.774]                     }
[16:17:51.774]                     base::local({
[16:17:51.774]                       for (pkg in "stats") {
[16:17:51.774]                         base::loadNamespace(pkg)
[16:17:51.774]                         base::library(pkg, character.only = TRUE)
[16:17:51.774]                       }
[16:17:51.774]                     })
[16:17:51.774]                   }
[16:17:51.774]                   ...future.strategy.old <- future::plan("list")
[16:17:51.774]                   options(future.plan = NULL)
[16:17:51.774]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:17:51.774]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:17:51.774]                 }
[16:17:51.774]                 ...future.workdir <- getwd()
[16:17:51.774]             }
[16:17:51.774]             ...future.oldOptions <- base::as.list(base::.Options)
[16:17:51.774]             ...future.oldEnvVars <- base::Sys.getenv()
[16:17:51.774]         }
[16:17:51.774]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:17:51.774]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:17:51.774]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:17:51.774]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:17:51.774]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:17:51.774]             future.stdout.windows.reencode = NULL, width = 80L)
[16:17:51.774]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:17:51.774]             base::names(...future.oldOptions))
[16:17:51.774]     }
[16:17:51.774]     if (FALSE) {
[16:17:51.774]     }
[16:17:51.774]     else {
[16:17:51.774]         if (TRUE) {
[16:17:51.774]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:17:51.774]                 open = "w")
[16:17:51.774]         }
[16:17:51.774]         else {
[16:17:51.774]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:17:51.774]                 windows = "NUL", "/dev/null"), open = "w")
[16:17:51.774]         }
[16:17:51.774]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:17:51.774]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:17:51.774]             base::sink(type = "output", split = FALSE)
[16:17:51.774]             base::close(...future.stdout)
[16:17:51.774]         }, add = TRUE)
[16:17:51.774]     }
[16:17:51.774]     ...future.frame <- base::sys.nframe()
[16:17:51.774]     ...future.conditions <- base::list()
[16:17:51.774]     ...future.rng <- base::globalenv()$.Random.seed
[16:17:51.774]     if (FALSE) {
[16:17:51.774]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:17:51.774]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:17:51.774]     }
[16:17:51.774]     ...future.result <- base::tryCatch({
[16:17:51.774]         base::withCallingHandlers({
[16:17:51.774]             ...future.value <- base::withVisible(base::local({
[16:17:51.774]                 ...future.makeSendCondition <- base::local({
[16:17:51.774]                   sendCondition <- NULL
[16:17:51.774]                   function(frame = 1L) {
[16:17:51.774]                     if (is.function(sendCondition)) 
[16:17:51.774]                       return(sendCondition)
[16:17:51.774]                     ns <- getNamespace("parallel")
[16:17:51.774]                     if (exists("sendData", mode = "function", 
[16:17:51.774]                       envir = ns)) {
[16:17:51.774]                       parallel_sendData <- get("sendData", mode = "function", 
[16:17:51.774]                         envir = ns)
[16:17:51.774]                       envir <- sys.frame(frame)
[16:17:51.774]                       master <- NULL
[16:17:51.774]                       while (!identical(envir, .GlobalEnv) && 
[16:17:51.774]                         !identical(envir, emptyenv())) {
[16:17:51.774]                         if (exists("master", mode = "list", envir = envir, 
[16:17:51.774]                           inherits = FALSE)) {
[16:17:51.774]                           master <- get("master", mode = "list", 
[16:17:51.774]                             envir = envir, inherits = FALSE)
[16:17:51.774]                           if (inherits(master, c("SOCKnode", 
[16:17:51.774]                             "SOCK0node"))) {
[16:17:51.774]                             sendCondition <<- function(cond) {
[16:17:51.774]                               data <- list(type = "VALUE", value = cond, 
[16:17:51.774]                                 success = TRUE)
[16:17:51.774]                               parallel_sendData(master, data)
[16:17:51.774]                             }
[16:17:51.774]                             return(sendCondition)
[16:17:51.774]                           }
[16:17:51.774]                         }
[16:17:51.774]                         frame <- frame + 1L
[16:17:51.774]                         envir <- sys.frame(frame)
[16:17:51.774]                       }
[16:17:51.774]                     }
[16:17:51.774]                     sendCondition <<- function(cond) NULL
[16:17:51.774]                   }
[16:17:51.774]                 })
[16:17:51.774]                 withCallingHandlers({
[16:17:51.774]                   {
[16:17:51.774]                     do.call(function(...) {
[16:17:51.774]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:51.774]                       if (!identical(...future.globals.maxSize.org, 
[16:17:51.774]                         ...future.globals.maxSize)) {
[16:17:51.774]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:51.774]                         on.exit(options(oopts), add = TRUE)
[16:17:51.774]                       }
[16:17:51.774]                       {
[16:17:51.774]                         lapply(seq_along(...future.elements_ii), 
[16:17:51.774]                           FUN = function(jj) {
[16:17:51.774]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:51.774]                             ...future.FUN(...future.X_jj, ...)
[16:17:51.774]                           })
[16:17:51.774]                       }
[16:17:51.774]                     }, args = future.call.arguments)
[16:17:51.774]                   }
[16:17:51.774]                 }, immediateCondition = function(cond) {
[16:17:51.774]                   sendCondition <- ...future.makeSendCondition()
[16:17:51.774]                   sendCondition(cond)
[16:17:51.774]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.774]                   {
[16:17:51.774]                     inherits <- base::inherits
[16:17:51.774]                     invokeRestart <- base::invokeRestart
[16:17:51.774]                     is.null <- base::is.null
[16:17:51.774]                     muffled <- FALSE
[16:17:51.774]                     if (inherits(cond, "message")) {
[16:17:51.774]                       muffled <- grepl(pattern, "muffleMessage")
[16:17:51.774]                       if (muffled) 
[16:17:51.774]                         invokeRestart("muffleMessage")
[16:17:51.774]                     }
[16:17:51.774]                     else if (inherits(cond, "warning")) {
[16:17:51.774]                       muffled <- grepl(pattern, "muffleWarning")
[16:17:51.774]                       if (muffled) 
[16:17:51.774]                         invokeRestart("muffleWarning")
[16:17:51.774]                     }
[16:17:51.774]                     else if (inherits(cond, "condition")) {
[16:17:51.774]                       if (!is.null(pattern)) {
[16:17:51.774]                         computeRestarts <- base::computeRestarts
[16:17:51.774]                         grepl <- base::grepl
[16:17:51.774]                         restarts <- computeRestarts(cond)
[16:17:51.774]                         for (restart in restarts) {
[16:17:51.774]                           name <- restart$name
[16:17:51.774]                           if (is.null(name)) 
[16:17:51.774]                             next
[16:17:51.774]                           if (!grepl(pattern, name)) 
[16:17:51.774]                             next
[16:17:51.774]                           invokeRestart(restart)
[16:17:51.774]                           muffled <- TRUE
[16:17:51.774]                           break
[16:17:51.774]                         }
[16:17:51.774]                       }
[16:17:51.774]                     }
[16:17:51.774]                     invisible(muffled)
[16:17:51.774]                   }
[16:17:51.774]                   muffleCondition(cond)
[16:17:51.774]                 })
[16:17:51.774]             }))
[16:17:51.774]             future::FutureResult(value = ...future.value$value, 
[16:17:51.774]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:51.774]                   ...future.rng), globalenv = if (FALSE) 
[16:17:51.774]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:17:51.774]                     ...future.globalenv.names))
[16:17:51.774]                 else NULL, started = ...future.startTime, version = "1.8")
[16:17:51.774]         }, condition = base::local({
[16:17:51.774]             c <- base::c
[16:17:51.774]             inherits <- base::inherits
[16:17:51.774]             invokeRestart <- base::invokeRestart
[16:17:51.774]             length <- base::length
[16:17:51.774]             list <- base::list
[16:17:51.774]             seq.int <- base::seq.int
[16:17:51.774]             signalCondition <- base::signalCondition
[16:17:51.774]             sys.calls <- base::sys.calls
[16:17:51.774]             `[[` <- base::`[[`
[16:17:51.774]             `+` <- base::`+`
[16:17:51.774]             `<<-` <- base::`<<-`
[16:17:51.774]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:17:51.774]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:17:51.774]                   3L)]
[16:17:51.774]             }
[16:17:51.774]             function(cond) {
[16:17:51.774]                 is_error <- inherits(cond, "error")
[16:17:51.774]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:17:51.774]                   NULL)
[16:17:51.774]                 if (is_error) {
[16:17:51.774]                   sessionInformation <- function() {
[16:17:51.774]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:17:51.774]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:17:51.774]                       search = base::search(), system = base::Sys.info())
[16:17:51.774]                   }
[16:17:51.774]                   ...future.conditions[[length(...future.conditions) + 
[16:17:51.774]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:17:51.774]                     cond$call), session = sessionInformation(), 
[16:17:51.774]                     timestamp = base::Sys.time(), signaled = 0L)
[16:17:51.774]                   signalCondition(cond)
[16:17:51.774]                 }
[16:17:51.774]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:17:51.774]                 "immediateCondition"))) {
[16:17:51.774]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:17:51.774]                   ...future.conditions[[length(...future.conditions) + 
[16:17:51.774]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:17:51.774]                   if (TRUE && !signal) {
[16:17:51.774]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.774]                     {
[16:17:51.774]                       inherits <- base::inherits
[16:17:51.774]                       invokeRestart <- base::invokeRestart
[16:17:51.774]                       is.null <- base::is.null
[16:17:51.774]                       muffled <- FALSE
[16:17:51.774]                       if (inherits(cond, "message")) {
[16:17:51.774]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:51.774]                         if (muffled) 
[16:17:51.774]                           invokeRestart("muffleMessage")
[16:17:51.774]                       }
[16:17:51.774]                       else if (inherits(cond, "warning")) {
[16:17:51.774]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:51.774]                         if (muffled) 
[16:17:51.774]                           invokeRestart("muffleWarning")
[16:17:51.774]                       }
[16:17:51.774]                       else if (inherits(cond, "condition")) {
[16:17:51.774]                         if (!is.null(pattern)) {
[16:17:51.774]                           computeRestarts <- base::computeRestarts
[16:17:51.774]                           grepl <- base::grepl
[16:17:51.774]                           restarts <- computeRestarts(cond)
[16:17:51.774]                           for (restart in restarts) {
[16:17:51.774]                             name <- restart$name
[16:17:51.774]                             if (is.null(name)) 
[16:17:51.774]                               next
[16:17:51.774]                             if (!grepl(pattern, name)) 
[16:17:51.774]                               next
[16:17:51.774]                             invokeRestart(restart)
[16:17:51.774]                             muffled <- TRUE
[16:17:51.774]                             break
[16:17:51.774]                           }
[16:17:51.774]                         }
[16:17:51.774]                       }
[16:17:51.774]                       invisible(muffled)
[16:17:51.774]                     }
[16:17:51.774]                     muffleCondition(cond, pattern = "^muffle")
[16:17:51.774]                   }
[16:17:51.774]                 }
[16:17:51.774]                 else {
[16:17:51.774]                   if (TRUE) {
[16:17:51.774]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:17:51.774]                     {
[16:17:51.774]                       inherits <- base::inherits
[16:17:51.774]                       invokeRestart <- base::invokeRestart
[16:17:51.774]                       is.null <- base::is.null
[16:17:51.774]                       muffled <- FALSE
[16:17:51.774]                       if (inherits(cond, "message")) {
[16:17:51.774]                         muffled <- grepl(pattern, "muffleMessage")
[16:17:51.774]                         if (muffled) 
[16:17:51.774]                           invokeRestart("muffleMessage")
[16:17:51.774]                       }
[16:17:51.774]                       else if (inherits(cond, "warning")) {
[16:17:51.774]                         muffled <- grepl(pattern, "muffleWarning")
[16:17:51.774]                         if (muffled) 
[16:17:51.774]                           invokeRestart("muffleWarning")
[16:17:51.774]                       }
[16:17:51.774]                       else if (inherits(cond, "condition")) {
[16:17:51.774]                         if (!is.null(pattern)) {
[16:17:51.774]                           computeRestarts <- base::computeRestarts
[16:17:51.774]                           grepl <- base::grepl
[16:17:51.774]                           restarts <- computeRestarts(cond)
[16:17:51.774]                           for (restart in restarts) {
[16:17:51.774]                             name <- restart$name
[16:17:51.774]                             if (is.null(name)) 
[16:17:51.774]                               next
[16:17:51.774]                             if (!grepl(pattern, name)) 
[16:17:51.774]                               next
[16:17:51.774]                             invokeRestart(restart)
[16:17:51.774]                             muffled <- TRUE
[16:17:51.774]                             break
[16:17:51.774]                           }
[16:17:51.774]                         }
[16:17:51.774]                       }
[16:17:51.774]                       invisible(muffled)
[16:17:51.774]                     }
[16:17:51.774]                     muffleCondition(cond, pattern = "^muffle")
[16:17:51.774]                   }
[16:17:51.774]                 }
[16:17:51.774]             }
[16:17:51.774]         }))
[16:17:51.774]     }, error = function(ex) {
[16:17:51.774]         base::structure(base::list(value = NULL, visible = NULL, 
[16:17:51.774]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:17:51.774]                 ...future.rng), started = ...future.startTime, 
[16:17:51.774]             finished = Sys.time(), session_uuid = NA_character_, 
[16:17:51.774]             version = "1.8"), class = "FutureResult")
[16:17:51.774]     }, finally = {
[16:17:51.774]         if (!identical(...future.workdir, getwd())) 
[16:17:51.774]             setwd(...future.workdir)
[16:17:51.774]         {
[16:17:51.774]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:17:51.774]                 ...future.oldOptions$nwarnings <- NULL
[16:17:51.774]             }
[16:17:51.774]             base::options(...future.oldOptions)
[16:17:51.774]             if (.Platform$OS.type == "windows") {
[16:17:51.774]                 old_names <- names(...future.oldEnvVars)
[16:17:51.774]                 envs <- base::Sys.getenv()
[16:17:51.774]                 names <- names(envs)
[16:17:51.774]                 common <- intersect(names, old_names)
[16:17:51.774]                 added <- setdiff(names, old_names)
[16:17:51.774]                 removed <- setdiff(old_names, names)
[16:17:51.774]                 changed <- common[...future.oldEnvVars[common] != 
[16:17:51.774]                   envs[common]]
[16:17:51.774]                 NAMES <- toupper(changed)
[16:17:51.774]                 args <- list()
[16:17:51.774]                 for (kk in seq_along(NAMES)) {
[16:17:51.774]                   name <- changed[[kk]]
[16:17:51.774]                   NAME <- NAMES[[kk]]
[16:17:51.774]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.774]                     next
[16:17:51.774]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:51.774]                 }
[16:17:51.774]                 NAMES <- toupper(added)
[16:17:51.774]                 for (kk in seq_along(NAMES)) {
[16:17:51.774]                   name <- added[[kk]]
[16:17:51.774]                   NAME <- NAMES[[kk]]
[16:17:51.774]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.774]                     next
[16:17:51.774]                   args[[name]] <- ""
[16:17:51.774]                 }
[16:17:51.774]                 NAMES <- toupper(removed)
[16:17:51.774]                 for (kk in seq_along(NAMES)) {
[16:17:51.774]                   name <- removed[[kk]]
[16:17:51.774]                   NAME <- NAMES[[kk]]
[16:17:51.774]                   if (name != NAME && is.element(NAME, old_names)) 
[16:17:51.774]                     next
[16:17:51.774]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:17:51.774]                 }
[16:17:51.774]                 if (length(args) > 0) 
[16:17:51.774]                   base::do.call(base::Sys.setenv, args = args)
[16:17:51.774]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:17:51.774]             }
[16:17:51.774]             else {
[16:17:51.774]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:17:51.774]             }
[16:17:51.774]             {
[16:17:51.774]                 if (base::length(...future.futureOptionsAdded) > 
[16:17:51.774]                   0L) {
[16:17:51.774]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:17:51.774]                   base::names(opts) <- ...future.futureOptionsAdded
[16:17:51.774]                   base::options(opts)
[16:17:51.774]                 }
[16:17:51.774]                 {
[16:17:51.774]                   {
[16:17:51.774]                     base::options(mc.cores = ...future.mc.cores.old)
[16:17:51.774]                     NULL
[16:17:51.774]                   }
[16:17:51.774]                   options(future.plan = NULL)
[16:17:51.774]                   if (is.na(NA_character_)) 
[16:17:51.774]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:17:51.774]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:17:51.774]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:17:51.774]                     .init = FALSE)
[16:17:51.774]                 }
[16:17:51.774]             }
[16:17:51.774]         }
[16:17:51.774]     })
[16:17:51.774]     if (TRUE) {
[16:17:51.774]         base::sink(type = "output", split = FALSE)
[16:17:51.774]         if (TRUE) {
[16:17:51.774]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:17:51.774]         }
[16:17:51.774]         else {
[16:17:51.774]             ...future.result["stdout"] <- base::list(NULL)
[16:17:51.774]         }
[16:17:51.774]         base::close(...future.stdout)
[16:17:51.774]         ...future.stdout <- NULL
[16:17:51.774]     }
[16:17:51.774]     ...future.result$conditions <- ...future.conditions
[16:17:51.774]     ...future.result$finished <- base::Sys.time()
[16:17:51.774]     ...future.result
[16:17:51.774] }
[16:17:51.777] Exporting 5 global objects (1.22 KiB) to cluster node #2 ...
[16:17:51.777] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[16:17:51.777] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[16:17:51.778] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:17:51.778] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:17:51.778] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[16:17:51.779] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[16:17:51.779] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:17:51.779] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:17:51.779] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:17:51.780] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:17:51.780] Exporting 5 global objects (1.22 KiB) to cluster node #2 ... DONE
[16:17:51.780] MultisessionFuture started
[16:17:51.780] - Launch lazy future ... done
[16:17:51.781] run() for ‘MultisessionFuture’ ... done
[16:17:51.781] Created future:
[16:17:51.781] MultisessionFuture:
[16:17:51.781] Label: ‘future_eapply-2’
[16:17:51.781] Expression:
[16:17:51.781] {
[16:17:51.781]     do.call(function(...) {
[16:17:51.781]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:17:51.781]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:17:51.781]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:17:51.781]             on.exit(options(oopts), add = TRUE)
[16:17:51.781]         }
[16:17:51.781]         {
[16:17:51.781]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:17:51.781]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:17:51.781]                 ...future.FUN(...future.X_jj, ...)
[16:17:51.781]             })
[16:17:51.781]         }
[16:17:51.781]     }, args = future.call.arguments)
[16:17:51.781] }
[16:17:51.781] Lazy evaluation: FALSE
[16:17:51.781] Asynchronous evaluation: TRUE
[16:17:51.781] Local evaluation: TRUE
[16:17:51.781] Environment: R_GlobalEnv
[16:17:51.781] Capture standard output: TRUE
[16:17:51.781] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:17:51.781] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:17:51.781] Packages: 1 packages (‘stats’)
[16:17:51.781] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:17:51.781] Resolved: FALSE
[16:17:51.781] Value: <not collected>
[16:17:51.781] Conditions captured: <none>
[16:17:51.781] Early signaling: FALSE
[16:17:51.781] Owner process: 95d59565-e757-824f-7f5c-7f754384cffc
[16:17:51.781] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:17:51.792] Chunk #2 of 2 ... DONE
[16:17:51.792] Launching 2 futures (chunks) ... DONE
[16:17:51.793] Resolving 2 futures (chunks) ...
[16:17:51.793] resolve() on list ...
[16:17:51.793]  recursive: 0
[16:17:51.793]  length: 2
[16:17:51.793] 
[16:17:51.793] receiveMessageFromWorker() for ClusterFuture ...
[16:17:51.794] - Validating connection of MultisessionFuture
[16:17:51.794] - received message: FutureResult
[16:17:51.794] - Received FutureResult
[16:17:51.794] - Erased future from FutureRegistry
[16:17:51.794] result() for ClusterFuture ...
[16:17:51.794] - result already collected: FutureResult
[16:17:51.794] result() for ClusterFuture ... done
[16:17:51.794] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:51.794] Future #1
[16:17:51.794] result() for ClusterFuture ...
[16:17:51.795] - result already collected: FutureResult
[16:17:51.795] result() for ClusterFuture ... done
[16:17:51.795] result() for ClusterFuture ...
[16:17:51.795] - result already collected: FutureResult
[16:17:51.795] result() for ClusterFuture ... done
[16:17:51.795] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:17:51.795] - nx: 2
[16:17:51.795] - relay: TRUE
[16:17:51.795] - stdout: TRUE
[16:17:51.795] - signal: TRUE
[16:17:51.795] - resignal: FALSE
[16:17:51.796] - force: TRUE
[16:17:51.796] - relayed: [n=2] FALSE, FALSE
[16:17:51.796] - queued futures: [n=2] FALSE, FALSE
[16:17:51.796]  - until=1
[16:17:51.796]  - relaying element #1
[16:17:51.796] result() for ClusterFuture ...
[16:17:51.796] - result already collected: FutureResult
[16:17:51.796] result() for ClusterFuture ... done
[16:17:51.796] result() for ClusterFuture ...
[16:17:51.796] - result already collected: FutureResult
[16:17:51.796] result() for ClusterFuture ... done
[16:17:51.797] result() for ClusterFuture ...
[16:17:51.797] - result already collected: FutureResult
[16:17:51.797] result() for ClusterFuture ... done
[16:17:51.797] result() for ClusterFuture ...
[16:17:51.797] - result already collected: FutureResult
[16:17:51.797] result() for ClusterFuture ... done
[16:17:51.797] - relayed: [n=2] TRUE, FALSE
[16:17:51.797] - queued futures: [n=2] TRUE, FALSE
[16:17:51.797] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:17:51.797]  length: 1 (resolved future 1)
[16:17:51.822] receiveMessageFromWorker() for ClusterFuture ...
[16:17:51.822] - Validating connection of MultisessionFuture
[16:17:51.823] - received message: FutureResult
[16:17:51.823] - Received FutureResult
[16:17:51.823] - Erased future from FutureRegistry
[16:17:51.823] result() for ClusterFuture ...
[16:17:51.823] - result already collected: FutureResult
[16:17:51.823] result() for ClusterFuture ... done
[16:17:51.823] receiveMessageFromWorker() for ClusterFuture ... done
[16:17:51.823] Future #2
[16:17:51.824] result() for ClusterFuture ...
[16:17:51.824] - result already collected: FutureResult
[16:17:51.824] result() for ClusterFuture ... done
[16:17:51.824] result() for ClusterFuture ...
[16:17:51.824] - result already collected: FutureResult
[16:17:51.824] result() for ClusterFuture ... done
[16:17:51.824] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:17:51.824] - nx: 2
[16:17:51.824] - relay: TRUE
[16:17:51.824] - stdout: TRUE
[16:17:51.824] - signal: TRUE
[16:17:51.825] - resignal: FALSE
[16:17:51.825] - force: TRUE
[16:17:51.825] - relayed: [n=2] TRUE, FALSE
[16:17:51.825] - queued futures: [n=2] TRUE, FALSE
[16:17:51.825]  - until=2
[16:17:51.825]  - relaying element #2
[16:17:51.825] result() for ClusterFuture ...
[16:17:51.825] - result already collected: FutureResult
[16:17:51.825] result() for ClusterFuture ... done
[16:17:51.825] result() for ClusterFuture ...
[16:17:51.825] - result already collected: FutureResult
[16:17:51.826] result() for ClusterFuture ... done
[16:17:51.826] result() for ClusterFuture ...
[16:17:51.826] - result already collected: FutureResult
[16:17:51.826] result() for ClusterFuture ... done
[16:17:51.826] result() for ClusterFuture ...
[16:17:51.826] - result already collected: FutureResult
[16:17:51.826] result() for ClusterFuture ... done
[16:17:51.826] - relayed: [n=2] TRUE, TRUE
[16:17:51.826] - queued futures: [n=2] TRUE, TRUE
[16:17:51.826] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:17:51.827]  length: 0 (resolved future 2)
[16:17:51.827] Relaying remaining futures
[16:17:51.827] signalConditionsASAP(NULL, pos=0) ...
[16:17:51.827] - nx: 2
[16:17:51.827] - relay: TRUE
[16:17:51.827] - stdout: TRUE
[16:17:51.827] - signal: TRUE
[16:17:51.827] - resignal: FALSE
[16:17:51.827] - force: TRUE
[16:17:51.827] - relayed: [n=2] TRUE, TRUE
[16:17:51.827] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:17:51.828] - relayed: [n=2] TRUE, TRUE
[16:17:51.828] - queued futures: [n=2] TRUE, TRUE
[16:17:51.828] signalConditionsASAP(NULL, pos=0) ... done
[16:17:51.828] resolve() on list ... DONE
[16:17:51.828] result() for ClusterFuture ...
[16:17:51.828] - result already collected: FutureResult
[16:17:51.828] result() for ClusterFuture ... done
[16:17:51.828] result() for ClusterFuture ...
[16:17:51.828] - result already collected: FutureResult
[16:17:51.828] result() for ClusterFuture ... done
[16:17:51.828] result() for ClusterFuture ...
[16:17:51.829] - result already collected: FutureResult
[16:17:51.829] result() for ClusterFuture ... done
[16:17:51.829] result() for ClusterFuture ...
[16:17:51.829] - result already collected: FutureResult
[16:17:51.829] result() for ClusterFuture ... done
[16:17:51.829]  - Number of value chunks collected: 2
[16:17:51.829] Resolving 2 futures (chunks) ... DONE
[16:17:51.829] Reducing values from 2 chunks ...
[16:17:51.829]  - Number of values collected after concatenation: 3
[16:17:51.829]  - Number of values expected: 3
[16:17:51.829] Reducing values from 2 chunks ... DONE
[16:17:51.830] future_lapply() ... DONE
[16:17:51.830] plan(): Setting new future strategy stack:
[16:17:51.830] List of future strategies:
[16:17:51.830] 1. sequential:
[16:17:51.830]    - args: function (..., envir = parent.frame())
[16:17:51.830]    - tweaked: FALSE
[16:17:51.830]    - call: plan(sequential)
[16:17:51.831] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> message("*** future_eapply() ... DONE")
*** future_eapply() ... DONE
> 
> source("incl/end.R")
[16:17:51.832] plan(): Setting new future strategy stack:
[16:17:51.832] List of future strategies:
[16:17:51.832] 1. FutureStrategy:
[16:17:51.832]    - args: function (..., envir = parent.frame())
[16:17:51.832]    - tweaked: FALSE
[16:17:51.832]    - call: future::plan(oplan)
[16:17:51.832] plan(): nbrOfWorkers() = 1
> 
