
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[10:29:56.948] plan(): Setting new future strategy stack:
[10:29:56.948] List of future strategies:
[10:29:56.948] 1. sequential:
[10:29:56.948]    - args: function (..., envir = parent.frame())
[10:29:56.948]    - tweaked: FALSE
[10:29:56.948]    - call: future::plan("sequential")
[10:29:56.963] plan(): nbrOfWorkers() = 1
> 
> message("*** future_eapply() ...")
*** future_eapply() ...
> 
> message("- From example(eapply) ...")
- From example(eapply) ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   env <- new.env(hash = FALSE)
+   env$a <- 1:10
+   env$beta <- exp(-3:3)
+   env$logic <- c(TRUE, FALSE, FALSE, TRUE)
+   
+   y0 <- unlist(eapply(env, mean, USE.NAMES = FALSE))
+   y1 <- unlist(future_eapply(env, mean, USE.NAMES = FALSE))
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile, probs = 1:3/4)
+   y1 <- future_eapply(env, quantile, probs = 1:3/4)
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile)
+   y1 <- future_eapply(env, quantile)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_eapply(env, "quantile")
+   stopifnot(all.equal(y2, y0))
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[10:29:56.985] plan(): Setting new future strategy stack:
[10:29:56.986] List of future strategies:
[10:29:56.986] 1. sequential:
[10:29:56.986]    - args: function (..., envir = parent.frame())
[10:29:56.986]    - tweaked: FALSE
[10:29:56.986]    - call: plan(strategy)
[10:29:56.999] plan(): nbrOfWorkers() = 1
[10:29:56.999] future_lapply() ...
[10:29:57.003] Number of chunks: 1
[10:29:57.004] getGlobalsAndPackagesXApply() ...
[10:29:57.004]  - future.globals: TRUE
[10:29:57.005] getGlobalsAndPackages() ...
[10:29:57.005] Searching for globals...
[10:29:57.007] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:57.007] Searching for globals ... DONE
[10:29:57.007] Resolving globals: FALSE
[10:29:57.008] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:57.009] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:57.009] - globals: [1] ‘FUN’
[10:29:57.009] 
[10:29:57.009] getGlobalsAndPackages() ... DONE
[10:29:57.009]  - globals found/used: [n=1] ‘FUN’
[10:29:57.009]  - needed namespaces: [n=0] 
[10:29:57.010] Finding globals ... DONE
[10:29:57.010]  - use_args: TRUE
[10:29:57.010]  - Getting '...' globals ...
[10:29:57.011] resolve() on list ...
[10:29:57.011]  recursive: 0
[10:29:57.011]  length: 1
[10:29:57.011]  elements: ‘...’
[10:29:57.011]  length: 0 (resolved future 1)
[10:29:57.011] resolve() on list ... DONE
[10:29:57.011]    - '...' content: [n=0] 
[10:29:57.012] List of 1
[10:29:57.012]  $ ...: list()
[10:29:57.012]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.012]  - attr(*, "where")=List of 1
[10:29:57.012]   ..$ ...:<environment: 0x559749695fb0> 
[10:29:57.012]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.012]  - attr(*, "resolved")= logi TRUE
[10:29:57.012]  - attr(*, "total_size")= num NA
[10:29:57.016]  - Getting '...' globals ... DONE
[10:29:57.017] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:57.017] List of 2
[10:29:57.017]  $ ...future.FUN:function (x, ...)  
[10:29:57.017]  $ ...          : list()
[10:29:57.017]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.017]  - attr(*, "where")=List of 2
[10:29:57.017]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:57.017]   ..$ ...          :<environment: 0x559749695fb0> 
[10:29:57.017]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.017]  - attr(*, "resolved")= logi FALSE
[10:29:57.017]  - attr(*, "total_size")= num 1240
[10:29:57.020] Packages to be attached in all futures: [n=0] 
[10:29:57.020] getGlobalsAndPackagesXApply() ... DONE
[10:29:57.020] Number of futures (= number of chunks): 1
[10:29:57.020] Launching 1 futures (chunks) ...
[10:29:57.020] Chunk #1 of 1 ...
[10:29:57.020]  - Finding globals in 'X' for chunk #1 ...
[10:29:57.021] getGlobalsAndPackages() ...
[10:29:57.021] Searching for globals...
[10:29:57.021] 
[10:29:57.021] Searching for globals ... DONE
[10:29:57.021] - globals: [0] <none>
[10:29:57.021] getGlobalsAndPackages() ... DONE
[10:29:57.021]    + additional globals found: [n=0] 
[10:29:57.021]    + additional namespaces needed: [n=0] 
[10:29:57.022]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:57.022]  - seeds: <none>
[10:29:57.022]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.022] getGlobalsAndPackages() ...
[10:29:57.022] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.022] Resolving globals: FALSE
[10:29:57.022] Tweak future expression to call with '...' arguments ...
[10:29:57.022] {
[10:29:57.022]     do.call(function(...) {
[10:29:57.022]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.022]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:57.022]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.022]             on.exit(options(oopts), add = TRUE)
[10:29:57.022]         }
[10:29:57.022]         {
[10:29:57.022]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:57.022]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.022]                 ...future.FUN(...future.X_jj, ...)
[10:29:57.022]             })
[10:29:57.022]         }
[10:29:57.022]     }, args = future.call.arguments)
[10:29:57.022] }
[10:29:57.023] Tweak future expression to call with '...' arguments ... DONE
[10:29:57.023] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.023] 
[10:29:57.023] getGlobalsAndPackages() ... DONE
[10:29:57.024] run() for ‘Future’ ...
[10:29:57.024] - state: ‘created’
[10:29:57.024] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:29:57.025] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:57.025] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:57.025]   - Field: ‘label’
[10:29:57.025]   - Field: ‘local’
[10:29:57.025]   - Field: ‘owner’
[10:29:57.025]   - Field: ‘envir’
[10:29:57.025]   - Field: ‘packages’
[10:29:57.025]   - Field: ‘gc’
[10:29:57.025]   - Field: ‘conditions’
[10:29:57.026]   - Field: ‘expr’
[10:29:57.026]   - Field: ‘uuid’
[10:29:57.026]   - Field: ‘seed’
[10:29:57.026]   - Field: ‘version’
[10:29:57.026]   - Field: ‘result’
[10:29:57.026]   - Field: ‘asynchronous’
[10:29:57.026]   - Field: ‘calls’
[10:29:57.026]   - Field: ‘globals’
[10:29:57.026]   - Field: ‘stdout’
[10:29:57.026]   - Field: ‘earlySignal’
[10:29:57.026]   - Field: ‘lazy’
[10:29:57.026]   - Field: ‘state’
[10:29:57.027] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:57.027] - Launch lazy future ...
[10:29:57.027] Packages needed by the future expression (n = 0): <none>
[10:29:57.028] Packages needed by future strategies (n = 0): <none>
[10:29:57.031] {
[10:29:57.031]     {
[10:29:57.031]         {
[10:29:57.031]             ...future.startTime <- base::Sys.time()
[10:29:57.031]             {
[10:29:57.031]                 {
[10:29:57.031]                   {
[10:29:57.031]                     base::local({
[10:29:57.031]                       has_future <- base::requireNamespace("future", 
[10:29:57.031]                         quietly = TRUE)
[10:29:57.031]                       if (has_future) {
[10:29:57.031]                         ns <- base::getNamespace("future")
[10:29:57.031]                         version <- ns[[".package"]][["version"]]
[10:29:57.031]                         if (is.null(version)) 
[10:29:57.031]                           version <- utils::packageVersion("future")
[10:29:57.031]                       }
[10:29:57.031]                       else {
[10:29:57.031]                         version <- NULL
[10:29:57.031]                       }
[10:29:57.031]                       if (!has_future || version < "1.8.0") {
[10:29:57.031]                         info <- base::c(r_version = base::gsub("R version ", 
[10:29:57.031]                           "", base::R.version$version.string), 
[10:29:57.031]                           platform = base::sprintf("%s (%s-bit)", 
[10:29:57.031]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:57.031]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:57.031]                             "release", "version")], collapse = " "), 
[10:29:57.031]                           hostname = base::Sys.info()[["nodename"]])
[10:29:57.031]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:29:57.031]                           info)
[10:29:57.031]                         info <- base::paste(info, collapse = "; ")
[10:29:57.031]                         if (!has_future) {
[10:29:57.031]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:57.031]                             info)
[10:29:57.031]                         }
[10:29:57.031]                         else {
[10:29:57.031]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:57.031]                             info, version)
[10:29:57.031]                         }
[10:29:57.031]                         base::stop(msg)
[10:29:57.031]                       }
[10:29:57.031]                     })
[10:29:57.031]                   }
[10:29:57.031]                   ...future.strategy.old <- future::plan("list")
[10:29:57.031]                   options(future.plan = NULL)
[10:29:57.031]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:57.031]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:57.031]                 }
[10:29:57.031]                 ...future.workdir <- getwd()
[10:29:57.031]             }
[10:29:57.031]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:57.031]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:57.031]         }
[10:29:57.031]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:57.031]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:57.031]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:57.031]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:57.031]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:57.031]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:57.031]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:57.031]             base::names(...future.oldOptions))
[10:29:57.031]     }
[10:29:57.031]     if (FALSE) {
[10:29:57.031]     }
[10:29:57.031]     else {
[10:29:57.031]         if (TRUE) {
[10:29:57.031]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:57.031]                 open = "w")
[10:29:57.031]         }
[10:29:57.031]         else {
[10:29:57.031]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:57.031]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:57.031]         }
[10:29:57.031]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:57.031]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:57.031]             base::sink(type = "output", split = FALSE)
[10:29:57.031]             base::close(...future.stdout)
[10:29:57.031]         }, add = TRUE)
[10:29:57.031]     }
[10:29:57.031]     ...future.frame <- base::sys.nframe()
[10:29:57.031]     ...future.conditions <- base::list()
[10:29:57.031]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:57.031]     if (FALSE) {
[10:29:57.031]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:57.031]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:57.031]     }
[10:29:57.031]     ...future.result <- base::tryCatch({
[10:29:57.031]         base::withCallingHandlers({
[10:29:57.031]             ...future.value <- base::withVisible(base::local({
[10:29:57.031]                 do.call(function(...) {
[10:29:57.031]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.031]                   if (!identical(...future.globals.maxSize.org, 
[10:29:57.031]                     ...future.globals.maxSize)) {
[10:29:57.031]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.031]                     on.exit(options(oopts), add = TRUE)
[10:29:57.031]                   }
[10:29:57.031]                   {
[10:29:57.031]                     lapply(seq_along(...future.elements_ii), 
[10:29:57.031]                       FUN = function(jj) {
[10:29:57.031]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.031]                         ...future.FUN(...future.X_jj, ...)
[10:29:57.031]                       })
[10:29:57.031]                   }
[10:29:57.031]                 }, args = future.call.arguments)
[10:29:57.031]             }))
[10:29:57.031]             future::FutureResult(value = ...future.value$value, 
[10:29:57.031]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:57.031]                   ...future.rng), globalenv = if (FALSE) 
[10:29:57.031]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:57.031]                     ...future.globalenv.names))
[10:29:57.031]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:57.031]         }, condition = base::local({
[10:29:57.031]             c <- base::c
[10:29:57.031]             inherits <- base::inherits
[10:29:57.031]             invokeRestart <- base::invokeRestart
[10:29:57.031]             length <- base::length
[10:29:57.031]             list <- base::list
[10:29:57.031]             seq.int <- base::seq.int
[10:29:57.031]             signalCondition <- base::signalCondition
[10:29:57.031]             sys.calls <- base::sys.calls
[10:29:57.031]             `[[` <- base::`[[`
[10:29:57.031]             `+` <- base::`+`
[10:29:57.031]             `<<-` <- base::`<<-`
[10:29:57.031]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:57.031]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:57.031]                   3L)]
[10:29:57.031]             }
[10:29:57.031]             function(cond) {
[10:29:57.031]                 is_error <- inherits(cond, "error")
[10:29:57.031]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:57.031]                   NULL)
[10:29:57.031]                 if (is_error) {
[10:29:57.031]                   sessionInformation <- function() {
[10:29:57.031]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:57.031]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:57.031]                       search = base::search(), system = base::Sys.info())
[10:29:57.031]                   }
[10:29:57.031]                   ...future.conditions[[length(...future.conditions) + 
[10:29:57.031]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:57.031]                     cond$call), session = sessionInformation(), 
[10:29:57.031]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:57.031]                   signalCondition(cond)
[10:29:57.031]                 }
[10:29:57.031]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:57.031]                 "immediateCondition"))) {
[10:29:57.031]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:57.031]                   ...future.conditions[[length(...future.conditions) + 
[10:29:57.031]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:57.031]                   if (TRUE && !signal) {
[10:29:57.031]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.031]                     {
[10:29:57.031]                       inherits <- base::inherits
[10:29:57.031]                       invokeRestart <- base::invokeRestart
[10:29:57.031]                       is.null <- base::is.null
[10:29:57.031]                       muffled <- FALSE
[10:29:57.031]                       if (inherits(cond, "message")) {
[10:29:57.031]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:57.031]                         if (muffled) 
[10:29:57.031]                           invokeRestart("muffleMessage")
[10:29:57.031]                       }
[10:29:57.031]                       else if (inherits(cond, "warning")) {
[10:29:57.031]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:57.031]                         if (muffled) 
[10:29:57.031]                           invokeRestart("muffleWarning")
[10:29:57.031]                       }
[10:29:57.031]                       else if (inherits(cond, "condition")) {
[10:29:57.031]                         if (!is.null(pattern)) {
[10:29:57.031]                           computeRestarts <- base::computeRestarts
[10:29:57.031]                           grepl <- base::grepl
[10:29:57.031]                           restarts <- computeRestarts(cond)
[10:29:57.031]                           for (restart in restarts) {
[10:29:57.031]                             name <- restart$name
[10:29:57.031]                             if (is.null(name)) 
[10:29:57.031]                               next
[10:29:57.031]                             if (!grepl(pattern, name)) 
[10:29:57.031]                               next
[10:29:57.031]                             invokeRestart(restart)
[10:29:57.031]                             muffled <- TRUE
[10:29:57.031]                             break
[10:29:57.031]                           }
[10:29:57.031]                         }
[10:29:57.031]                       }
[10:29:57.031]                       invisible(muffled)
[10:29:57.031]                     }
[10:29:57.031]                     muffleCondition(cond, pattern = "^muffle")
[10:29:57.031]                   }
[10:29:57.031]                 }
[10:29:57.031]                 else {
[10:29:57.031]                   if (TRUE) {
[10:29:57.031]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.031]                     {
[10:29:57.031]                       inherits <- base::inherits
[10:29:57.031]                       invokeRestart <- base::invokeRestart
[10:29:57.031]                       is.null <- base::is.null
[10:29:57.031]                       muffled <- FALSE
[10:29:57.031]                       if (inherits(cond, "message")) {
[10:29:57.031]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:57.031]                         if (muffled) 
[10:29:57.031]                           invokeRestart("muffleMessage")
[10:29:57.031]                       }
[10:29:57.031]                       else if (inherits(cond, "warning")) {
[10:29:57.031]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:57.031]                         if (muffled) 
[10:29:57.031]                           invokeRestart("muffleWarning")
[10:29:57.031]                       }
[10:29:57.031]                       else if (inherits(cond, "condition")) {
[10:29:57.031]                         if (!is.null(pattern)) {
[10:29:57.031]                           computeRestarts <- base::computeRestarts
[10:29:57.031]                           grepl <- base::grepl
[10:29:57.031]                           restarts <- computeRestarts(cond)
[10:29:57.031]                           for (restart in restarts) {
[10:29:57.031]                             name <- restart$name
[10:29:57.031]                             if (is.null(name)) 
[10:29:57.031]                               next
[10:29:57.031]                             if (!grepl(pattern, name)) 
[10:29:57.031]                               next
[10:29:57.031]                             invokeRestart(restart)
[10:29:57.031]                             muffled <- TRUE
[10:29:57.031]                             break
[10:29:57.031]                           }
[10:29:57.031]                         }
[10:29:57.031]                       }
[10:29:57.031]                       invisible(muffled)
[10:29:57.031]                     }
[10:29:57.031]                     muffleCondition(cond, pattern = "^muffle")
[10:29:57.031]                   }
[10:29:57.031]                 }
[10:29:57.031]             }
[10:29:57.031]         }))
[10:29:57.031]     }, error = function(ex) {
[10:29:57.031]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:57.031]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:57.031]                 ...future.rng), started = ...future.startTime, 
[10:29:57.031]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:57.031]             version = "1.8"), class = "FutureResult")
[10:29:57.031]     }, finally = {
[10:29:57.031]         if (!identical(...future.workdir, getwd())) 
[10:29:57.031]             setwd(...future.workdir)
[10:29:57.031]         {
[10:29:57.031]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:57.031]                 ...future.oldOptions$nwarnings <- NULL
[10:29:57.031]             }
[10:29:57.031]             base::options(...future.oldOptions)
[10:29:57.031]             if (.Platform$OS.type == "windows") {
[10:29:57.031]                 old_names <- names(...future.oldEnvVars)
[10:29:57.031]                 envs <- base::Sys.getenv()
[10:29:57.031]                 names <- names(envs)
[10:29:57.031]                 common <- intersect(names, old_names)
[10:29:57.031]                 added <- setdiff(names, old_names)
[10:29:57.031]                 removed <- setdiff(old_names, names)
[10:29:57.031]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:57.031]                   envs[common]]
[10:29:57.031]                 NAMES <- toupper(changed)
[10:29:57.031]                 args <- list()
[10:29:57.031]                 for (kk in seq_along(NAMES)) {
[10:29:57.031]                   name <- changed[[kk]]
[10:29:57.031]                   NAME <- NAMES[[kk]]
[10:29:57.031]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.031]                     next
[10:29:57.031]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:57.031]                 }
[10:29:57.031]                 NAMES <- toupper(added)
[10:29:57.031]                 for (kk in seq_along(NAMES)) {
[10:29:57.031]                   name <- added[[kk]]
[10:29:57.031]                   NAME <- NAMES[[kk]]
[10:29:57.031]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.031]                     next
[10:29:57.031]                   args[[name]] <- ""
[10:29:57.031]                 }
[10:29:57.031]                 NAMES <- toupper(removed)
[10:29:57.031]                 for (kk in seq_along(NAMES)) {
[10:29:57.031]                   name <- removed[[kk]]
[10:29:57.031]                   NAME <- NAMES[[kk]]
[10:29:57.031]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.031]                     next
[10:29:57.031]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:57.031]                 }
[10:29:57.031]                 if (length(args) > 0) 
[10:29:57.031]                   base::do.call(base::Sys.setenv, args = args)
[10:29:57.031]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:57.031]             }
[10:29:57.031]             else {
[10:29:57.031]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:57.031]             }
[10:29:57.031]             {
[10:29:57.031]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:57.031]                   0L) {
[10:29:57.031]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:57.031]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:57.031]                   base::options(opts)
[10:29:57.031]                 }
[10:29:57.031]                 {
[10:29:57.031]                   {
[10:29:57.031]                     NULL
[10:29:57.031]                     RNGkind("Mersenne-Twister")
[10:29:57.031]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:57.031]                       inherits = FALSE)
[10:29:57.031]                   }
[10:29:57.031]                   options(future.plan = NULL)
[10:29:57.031]                   if (is.na(NA_character_)) 
[10:29:57.031]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:57.031]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:57.031]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:57.031]                     .init = FALSE)
[10:29:57.031]                 }
[10:29:57.031]             }
[10:29:57.031]         }
[10:29:57.031]     })
[10:29:57.031]     if (TRUE) {
[10:29:57.031]         base::sink(type = "output", split = FALSE)
[10:29:57.031]         if (TRUE) {
[10:29:57.031]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:57.031]         }
[10:29:57.031]         else {
[10:29:57.031]             ...future.result["stdout"] <- base::list(NULL)
[10:29:57.031]         }
[10:29:57.031]         base::close(...future.stdout)
[10:29:57.031]         ...future.stdout <- NULL
[10:29:57.031]     }
[10:29:57.031]     ...future.result$conditions <- ...future.conditions
[10:29:57.031]     ...future.result$finished <- base::Sys.time()
[10:29:57.031]     ...future.result
[10:29:57.031] }
[10:29:57.033] assign_globals() ...
[10:29:57.033] List of 5
[10:29:57.033]  $ ...future.FUN            :function (x, ...)  
[10:29:57.033]  $ future.call.arguments    : list()
[10:29:57.033]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.033]  $ ...future.elements_ii    :List of 3
[10:29:57.033]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[10:29:57.033]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:29:57.033]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:29:57.033]  $ ...future.seeds_ii       : NULL
[10:29:57.033]  $ ...future.globals.maxSize: NULL
[10:29:57.033]  - attr(*, "where")=List of 5
[10:29:57.033]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:57.033]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:57.033]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:57.033]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:57.033]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:57.033]  - attr(*, "resolved")= logi FALSE
[10:29:57.033]  - attr(*, "total_size")= num 1240
[10:29:57.033]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.033]  - attr(*, "already-done")= logi TRUE
[10:29:57.038] - copied ‘...future.FUN’ to environment
[10:29:57.038] - copied ‘future.call.arguments’ to environment
[10:29:57.039] - copied ‘...future.elements_ii’ to environment
[10:29:57.039] - copied ‘...future.seeds_ii’ to environment
[10:29:57.039] - copied ‘...future.globals.maxSize’ to environment
[10:29:57.039] assign_globals() ... done
[10:29:57.039] plan(): Setting new future strategy stack:
[10:29:57.039] List of future strategies:
[10:29:57.039] 1. sequential:
[10:29:57.039]    - args: function (..., envir = parent.frame())
[10:29:57.039]    - tweaked: FALSE
[10:29:57.039]    - call: NULL
[10:29:57.040] plan(): nbrOfWorkers() = 1
[10:29:57.041] plan(): Setting new future strategy stack:
[10:29:57.041] List of future strategies:
[10:29:57.041] 1. sequential:
[10:29:57.041]    - args: function (..., envir = parent.frame())
[10:29:57.041]    - tweaked: FALSE
[10:29:57.041]    - call: plan(strategy)
[10:29:57.041] plan(): nbrOfWorkers() = 1
[10:29:57.041] SequentialFuture started (and completed)
[10:29:57.042] - Launch lazy future ... done
[10:29:57.042] run() for ‘SequentialFuture’ ... done
[10:29:57.042] Created future:
[10:29:57.042] SequentialFuture:
[10:29:57.042] Label: ‘future_eapply-1’
[10:29:57.042] Expression:
[10:29:57.042] {
[10:29:57.042]     do.call(function(...) {
[10:29:57.042]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.042]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:57.042]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.042]             on.exit(options(oopts), add = TRUE)
[10:29:57.042]         }
[10:29:57.042]         {
[10:29:57.042]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:57.042]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.042]                 ...future.FUN(...future.X_jj, ...)
[10:29:57.042]             })
[10:29:57.042]         }
[10:29:57.042]     }, args = future.call.arguments)
[10:29:57.042] }
[10:29:57.042] Lazy evaluation: FALSE
[10:29:57.042] Asynchronous evaluation: FALSE
[10:29:57.042] Local evaluation: TRUE
[10:29:57.042] Environment: R_GlobalEnv
[10:29:57.042] Capture standard output: TRUE
[10:29:57.042] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:57.042] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:57.042] Packages: <none>
[10:29:57.042] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:57.042] Resolved: TRUE
[10:29:57.042] Value: 168 bytes of class ‘list’
[10:29:57.042] Early signaling: FALSE
[10:29:57.042] Owner process: db6eb61b-64f1-ae95-7e8b-287fbc43411a
[10:29:57.042] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:57.044] Chunk #1 of 1 ... DONE
[10:29:57.044] Launching 1 futures (chunks) ... DONE
[10:29:57.044] Resolving 1 futures (chunks) ...
[10:29:57.044] resolve() on list ...
[10:29:57.044]  recursive: 0
[10:29:57.044]  length: 1
[10:29:57.044] 
[10:29:57.045] resolved() for ‘SequentialFuture’ ...
[10:29:57.045] - state: ‘finished’
[10:29:57.045] - run: TRUE
[10:29:57.045] - result: ‘FutureResult’
[10:29:57.045] resolved() for ‘SequentialFuture’ ... done
[10:29:57.045] Future #1
[10:29:57.045] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:57.046] - nx: 1
[10:29:57.046] - relay: TRUE
[10:29:57.046] - stdout: TRUE
[10:29:57.046] - signal: TRUE
[10:29:57.046] - resignal: FALSE
[10:29:57.046] - force: TRUE
[10:29:57.046] - relayed: [n=1] FALSE
[10:29:57.046] - queued futures: [n=1] FALSE
[10:29:57.046]  - until=1
[10:29:57.046]  - relaying element #1
[10:29:57.046] - relayed: [n=1] TRUE
[10:29:57.047] - queued futures: [n=1] TRUE
[10:29:57.047] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:57.047]  length: 0 (resolved future 1)
[10:29:57.047] Relaying remaining futures
[10:29:57.047] signalConditionsASAP(NULL, pos=0) ...
[10:29:57.047] - nx: 1
[10:29:57.047] - relay: TRUE
[10:29:57.047] - stdout: TRUE
[10:29:57.047] - signal: TRUE
[10:29:57.047] - resignal: FALSE
[10:29:57.048] - force: TRUE
[10:29:57.048] - relayed: [n=1] TRUE
[10:29:57.048] - queued futures: [n=1] TRUE
 - flush all
[10:29:57.048] - relayed: [n=1] TRUE
[10:29:57.048] - queued futures: [n=1] TRUE
[10:29:57.048] signalConditionsASAP(NULL, pos=0) ... done
[10:29:57.048] resolve() on list ... DONE
[10:29:57.048]  - Number of value chunks collected: 1
[10:29:57.048] Resolving 1 futures (chunks) ... DONE
[10:29:57.048] Reducing values from 1 chunks ...
[10:29:57.049]  - Number of values collected after concatenation: 3
[10:29:57.049]  - Number of values expected: 3
[10:29:57.049] Reducing values from 1 chunks ... DONE
[10:29:57.049] future_lapply() ... DONE
[10:29:57.051] future_lapply() ...
[10:29:57.051] Number of chunks: 1
[10:29:57.052] getGlobalsAndPackagesXApply() ...
[10:29:57.052]  - future.globals: TRUE
[10:29:57.052] getGlobalsAndPackages() ...
[10:29:57.052] Searching for globals...
[10:29:57.053] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:57.053] Searching for globals ... DONE
[10:29:57.053] Resolving globals: FALSE
[10:29:57.053] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[10:29:57.054] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[10:29:57.054] - globals: [1] ‘FUN’
[10:29:57.054] - packages: [1] ‘stats’
[10:29:57.054] getGlobalsAndPackages() ... DONE
[10:29:57.054]  - globals found/used: [n=1] ‘FUN’
[10:29:57.054]  - needed namespaces: [n=1] ‘stats’
[10:29:57.054] Finding globals ... DONE
[10:29:57.055]  - use_args: TRUE
[10:29:57.055]  - Getting '...' globals ...
[10:29:57.055] resolve() on list ...
[10:29:57.055]  recursive: 0
[10:29:57.055]  length: 1
[10:29:57.055]  elements: ‘...’
[10:29:57.055]  length: 0 (resolved future 1)
[10:29:57.055] resolve() on list ... DONE
[10:29:57.055]    - '...' content: [n=1] ‘probs’
[10:29:57.056] List of 1
[10:29:57.056]  $ ...:List of 1
[10:29:57.056]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:29:57.056]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.056]  - attr(*, "where")=List of 1
[10:29:57.056]   ..$ ...:<environment: 0x55974b6ff4b8> 
[10:29:57.056]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.056]  - attr(*, "resolved")= logi TRUE
[10:29:57.056]  - attr(*, "total_size")= num NA
[10:29:57.060]  - Getting '...' globals ... DONE
[10:29:57.060] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:57.061] List of 2
[10:29:57.061]  $ ...future.FUN:function (x, ...)  
[10:29:57.061]  $ ...          :List of 1
[10:29:57.061]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:29:57.061]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.061]  - attr(*, "where")=List of 2
[10:29:57.061]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:57.061]   ..$ ...          :<environment: 0x55974b6ff4b8> 
[10:29:57.061]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.061]  - attr(*, "resolved")= logi FALSE
[10:29:57.061]  - attr(*, "total_size")= num 1328
[10:29:57.064] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:57.064] getGlobalsAndPackagesXApply() ... DONE
[10:29:57.064] Number of futures (= number of chunks): 1
[10:29:57.064] Launching 1 futures (chunks) ...
[10:29:57.064] Chunk #1 of 1 ...
[10:29:57.064]  - Finding globals in 'X' for chunk #1 ...
[10:29:57.065] getGlobalsAndPackages() ...
[10:29:57.065] Searching for globals...
[10:29:57.065] 
[10:29:57.065] Searching for globals ... DONE
[10:29:57.065] - globals: [0] <none>
[10:29:57.065] getGlobalsAndPackages() ... DONE
[10:29:57.065]    + additional globals found: [n=0] 
[10:29:57.065]    + additional namespaces needed: [n=0] 
[10:29:57.065]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:57.066]  - seeds: <none>
[10:29:57.066]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.066] getGlobalsAndPackages() ...
[10:29:57.066] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.066] Resolving globals: FALSE
[10:29:57.066] Tweak future expression to call with '...' arguments ...
[10:29:57.066] {
[10:29:57.066]     do.call(function(...) {
[10:29:57.066]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.066]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:57.066]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.066]             on.exit(options(oopts), add = TRUE)
[10:29:57.066]         }
[10:29:57.066]         {
[10:29:57.066]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:57.066]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.066]                 ...future.FUN(...future.X_jj, ...)
[10:29:57.066]             })
[10:29:57.066]         }
[10:29:57.066]     }, args = future.call.arguments)
[10:29:57.066] }
[10:29:57.066] Tweak future expression to call with '...' arguments ... DONE
[10:29:57.067] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.067] - packages: [1] ‘stats’
[10:29:57.067] getGlobalsAndPackages() ... DONE
[10:29:57.067] run() for ‘Future’ ...
[10:29:57.067] - state: ‘created’
[10:29:57.067] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:29:57.068] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:57.068] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:57.068]   - Field: ‘label’
[10:29:57.068]   - Field: ‘local’
[10:29:57.068]   - Field: ‘owner’
[10:29:57.068]   - Field: ‘envir’
[10:29:57.068]   - Field: ‘packages’
[10:29:57.068]   - Field: ‘gc’
[10:29:57.069]   - Field: ‘conditions’
[10:29:57.069]   - Field: ‘expr’
[10:29:57.069]   - Field: ‘uuid’
[10:29:57.069]   - Field: ‘seed’
[10:29:57.069]   - Field: ‘version’
[10:29:57.069]   - Field: ‘result’
[10:29:57.069]   - Field: ‘asynchronous’
[10:29:57.069]   - Field: ‘calls’
[10:29:57.069]   - Field: ‘globals’
[10:29:57.069]   - Field: ‘stdout’
[10:29:57.070]   - Field: ‘earlySignal’
[10:29:57.070]   - Field: ‘lazy’
[10:29:57.070]   - Field: ‘state’
[10:29:57.070] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:57.070] - Launch lazy future ...
[10:29:57.070] Packages needed by the future expression (n = 1): ‘stats’
[10:29:57.070] Packages needed by future strategies (n = 0): <none>
[10:29:57.071] {
[10:29:57.071]     {
[10:29:57.071]         {
[10:29:57.071]             ...future.startTime <- base::Sys.time()
[10:29:57.071]             {
[10:29:57.071]                 {
[10:29:57.071]                   {
[10:29:57.071]                     {
[10:29:57.071]                       base::local({
[10:29:57.071]                         has_future <- base::requireNamespace("future", 
[10:29:57.071]                           quietly = TRUE)
[10:29:57.071]                         if (has_future) {
[10:29:57.071]                           ns <- base::getNamespace("future")
[10:29:57.071]                           version <- ns[[".package"]][["version"]]
[10:29:57.071]                           if (is.null(version)) 
[10:29:57.071]                             version <- utils::packageVersion("future")
[10:29:57.071]                         }
[10:29:57.071]                         else {
[10:29:57.071]                           version <- NULL
[10:29:57.071]                         }
[10:29:57.071]                         if (!has_future || version < "1.8.0") {
[10:29:57.071]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:57.071]                             "", base::R.version$version.string), 
[10:29:57.071]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:57.071]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:57.071]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:57.071]                               "release", "version")], collapse = " "), 
[10:29:57.071]                             hostname = base::Sys.info()[["nodename"]])
[10:29:57.071]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:57.071]                             info)
[10:29:57.071]                           info <- base::paste(info, collapse = "; ")
[10:29:57.071]                           if (!has_future) {
[10:29:57.071]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:57.071]                               info)
[10:29:57.071]                           }
[10:29:57.071]                           else {
[10:29:57.071]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:57.071]                               info, version)
[10:29:57.071]                           }
[10:29:57.071]                           base::stop(msg)
[10:29:57.071]                         }
[10:29:57.071]                       })
[10:29:57.071]                     }
[10:29:57.071]                     base::local({
[10:29:57.071]                       for (pkg in "stats") {
[10:29:57.071]                         base::loadNamespace(pkg)
[10:29:57.071]                         base::library(pkg, character.only = TRUE)
[10:29:57.071]                       }
[10:29:57.071]                     })
[10:29:57.071]                   }
[10:29:57.071]                   ...future.strategy.old <- future::plan("list")
[10:29:57.071]                   options(future.plan = NULL)
[10:29:57.071]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:57.071]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:57.071]                 }
[10:29:57.071]                 ...future.workdir <- getwd()
[10:29:57.071]             }
[10:29:57.071]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:57.071]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:57.071]         }
[10:29:57.071]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:57.071]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:57.071]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:57.071]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:57.071]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:57.071]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:57.071]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:57.071]             base::names(...future.oldOptions))
[10:29:57.071]     }
[10:29:57.071]     if (FALSE) {
[10:29:57.071]     }
[10:29:57.071]     else {
[10:29:57.071]         if (TRUE) {
[10:29:57.071]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:57.071]                 open = "w")
[10:29:57.071]         }
[10:29:57.071]         else {
[10:29:57.071]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:57.071]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:57.071]         }
[10:29:57.071]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:57.071]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:57.071]             base::sink(type = "output", split = FALSE)
[10:29:57.071]             base::close(...future.stdout)
[10:29:57.071]         }, add = TRUE)
[10:29:57.071]     }
[10:29:57.071]     ...future.frame <- base::sys.nframe()
[10:29:57.071]     ...future.conditions <- base::list()
[10:29:57.071]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:57.071]     if (FALSE) {
[10:29:57.071]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:57.071]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:57.071]     }
[10:29:57.071]     ...future.result <- base::tryCatch({
[10:29:57.071]         base::withCallingHandlers({
[10:29:57.071]             ...future.value <- base::withVisible(base::local({
[10:29:57.071]                 do.call(function(...) {
[10:29:57.071]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.071]                   if (!identical(...future.globals.maxSize.org, 
[10:29:57.071]                     ...future.globals.maxSize)) {
[10:29:57.071]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.071]                     on.exit(options(oopts), add = TRUE)
[10:29:57.071]                   }
[10:29:57.071]                   {
[10:29:57.071]                     lapply(seq_along(...future.elements_ii), 
[10:29:57.071]                       FUN = function(jj) {
[10:29:57.071]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.071]                         ...future.FUN(...future.X_jj, ...)
[10:29:57.071]                       })
[10:29:57.071]                   }
[10:29:57.071]                 }, args = future.call.arguments)
[10:29:57.071]             }))
[10:29:57.071]             future::FutureResult(value = ...future.value$value, 
[10:29:57.071]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:57.071]                   ...future.rng), globalenv = if (FALSE) 
[10:29:57.071]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:57.071]                     ...future.globalenv.names))
[10:29:57.071]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:57.071]         }, condition = base::local({
[10:29:57.071]             c <- base::c
[10:29:57.071]             inherits <- base::inherits
[10:29:57.071]             invokeRestart <- base::invokeRestart
[10:29:57.071]             length <- base::length
[10:29:57.071]             list <- base::list
[10:29:57.071]             seq.int <- base::seq.int
[10:29:57.071]             signalCondition <- base::signalCondition
[10:29:57.071]             sys.calls <- base::sys.calls
[10:29:57.071]             `[[` <- base::`[[`
[10:29:57.071]             `+` <- base::`+`
[10:29:57.071]             `<<-` <- base::`<<-`
[10:29:57.071]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:57.071]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:57.071]                   3L)]
[10:29:57.071]             }
[10:29:57.071]             function(cond) {
[10:29:57.071]                 is_error <- inherits(cond, "error")
[10:29:57.071]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:57.071]                   NULL)
[10:29:57.071]                 if (is_error) {
[10:29:57.071]                   sessionInformation <- function() {
[10:29:57.071]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:57.071]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:57.071]                       search = base::search(), system = base::Sys.info())
[10:29:57.071]                   }
[10:29:57.071]                   ...future.conditions[[length(...future.conditions) + 
[10:29:57.071]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:57.071]                     cond$call), session = sessionInformation(), 
[10:29:57.071]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:57.071]                   signalCondition(cond)
[10:29:57.071]                 }
[10:29:57.071]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:57.071]                 "immediateCondition"))) {
[10:29:57.071]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:57.071]                   ...future.conditions[[length(...future.conditions) + 
[10:29:57.071]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:57.071]                   if (TRUE && !signal) {
[10:29:57.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.071]                     {
[10:29:57.071]                       inherits <- base::inherits
[10:29:57.071]                       invokeRestart <- base::invokeRestart
[10:29:57.071]                       is.null <- base::is.null
[10:29:57.071]                       muffled <- FALSE
[10:29:57.071]                       if (inherits(cond, "message")) {
[10:29:57.071]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:57.071]                         if (muffled) 
[10:29:57.071]                           invokeRestart("muffleMessage")
[10:29:57.071]                       }
[10:29:57.071]                       else if (inherits(cond, "warning")) {
[10:29:57.071]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:57.071]                         if (muffled) 
[10:29:57.071]                           invokeRestart("muffleWarning")
[10:29:57.071]                       }
[10:29:57.071]                       else if (inherits(cond, "condition")) {
[10:29:57.071]                         if (!is.null(pattern)) {
[10:29:57.071]                           computeRestarts <- base::computeRestarts
[10:29:57.071]                           grepl <- base::grepl
[10:29:57.071]                           restarts <- computeRestarts(cond)
[10:29:57.071]                           for (restart in restarts) {
[10:29:57.071]                             name <- restart$name
[10:29:57.071]                             if (is.null(name)) 
[10:29:57.071]                               next
[10:29:57.071]                             if (!grepl(pattern, name)) 
[10:29:57.071]                               next
[10:29:57.071]                             invokeRestart(restart)
[10:29:57.071]                             muffled <- TRUE
[10:29:57.071]                             break
[10:29:57.071]                           }
[10:29:57.071]                         }
[10:29:57.071]                       }
[10:29:57.071]                       invisible(muffled)
[10:29:57.071]                     }
[10:29:57.071]                     muffleCondition(cond, pattern = "^muffle")
[10:29:57.071]                   }
[10:29:57.071]                 }
[10:29:57.071]                 else {
[10:29:57.071]                   if (TRUE) {
[10:29:57.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.071]                     {
[10:29:57.071]                       inherits <- base::inherits
[10:29:57.071]                       invokeRestart <- base::invokeRestart
[10:29:57.071]                       is.null <- base::is.null
[10:29:57.071]                       muffled <- FALSE
[10:29:57.071]                       if (inherits(cond, "message")) {
[10:29:57.071]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:57.071]                         if (muffled) 
[10:29:57.071]                           invokeRestart("muffleMessage")
[10:29:57.071]                       }
[10:29:57.071]                       else if (inherits(cond, "warning")) {
[10:29:57.071]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:57.071]                         if (muffled) 
[10:29:57.071]                           invokeRestart("muffleWarning")
[10:29:57.071]                       }
[10:29:57.071]                       else if (inherits(cond, "condition")) {
[10:29:57.071]                         if (!is.null(pattern)) {
[10:29:57.071]                           computeRestarts <- base::computeRestarts
[10:29:57.071]                           grepl <- base::grepl
[10:29:57.071]                           restarts <- computeRestarts(cond)
[10:29:57.071]                           for (restart in restarts) {
[10:29:57.071]                             name <- restart$name
[10:29:57.071]                             if (is.null(name)) 
[10:29:57.071]                               next
[10:29:57.071]                             if (!grepl(pattern, name)) 
[10:29:57.071]                               next
[10:29:57.071]                             invokeRestart(restart)
[10:29:57.071]                             muffled <- TRUE
[10:29:57.071]                             break
[10:29:57.071]                           }
[10:29:57.071]                         }
[10:29:57.071]                       }
[10:29:57.071]                       invisible(muffled)
[10:29:57.071]                     }
[10:29:57.071]                     muffleCondition(cond, pattern = "^muffle")
[10:29:57.071]                   }
[10:29:57.071]                 }
[10:29:57.071]             }
[10:29:57.071]         }))
[10:29:57.071]     }, error = function(ex) {
[10:29:57.071]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:57.071]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:57.071]                 ...future.rng), started = ...future.startTime, 
[10:29:57.071]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:57.071]             version = "1.8"), class = "FutureResult")
[10:29:57.071]     }, finally = {
[10:29:57.071]         if (!identical(...future.workdir, getwd())) 
[10:29:57.071]             setwd(...future.workdir)
[10:29:57.071]         {
[10:29:57.071]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:57.071]                 ...future.oldOptions$nwarnings <- NULL
[10:29:57.071]             }
[10:29:57.071]             base::options(...future.oldOptions)
[10:29:57.071]             if (.Platform$OS.type == "windows") {
[10:29:57.071]                 old_names <- names(...future.oldEnvVars)
[10:29:57.071]                 envs <- base::Sys.getenv()
[10:29:57.071]                 names <- names(envs)
[10:29:57.071]                 common <- intersect(names, old_names)
[10:29:57.071]                 added <- setdiff(names, old_names)
[10:29:57.071]                 removed <- setdiff(old_names, names)
[10:29:57.071]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:57.071]                   envs[common]]
[10:29:57.071]                 NAMES <- toupper(changed)
[10:29:57.071]                 args <- list()
[10:29:57.071]                 for (kk in seq_along(NAMES)) {
[10:29:57.071]                   name <- changed[[kk]]
[10:29:57.071]                   NAME <- NAMES[[kk]]
[10:29:57.071]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.071]                     next
[10:29:57.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:57.071]                 }
[10:29:57.071]                 NAMES <- toupper(added)
[10:29:57.071]                 for (kk in seq_along(NAMES)) {
[10:29:57.071]                   name <- added[[kk]]
[10:29:57.071]                   NAME <- NAMES[[kk]]
[10:29:57.071]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.071]                     next
[10:29:57.071]                   args[[name]] <- ""
[10:29:57.071]                 }
[10:29:57.071]                 NAMES <- toupper(removed)
[10:29:57.071]                 for (kk in seq_along(NAMES)) {
[10:29:57.071]                   name <- removed[[kk]]
[10:29:57.071]                   NAME <- NAMES[[kk]]
[10:29:57.071]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.071]                     next
[10:29:57.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:57.071]                 }
[10:29:57.071]                 if (length(args) > 0) 
[10:29:57.071]                   base::do.call(base::Sys.setenv, args = args)
[10:29:57.071]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:57.071]             }
[10:29:57.071]             else {
[10:29:57.071]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:57.071]             }
[10:29:57.071]             {
[10:29:57.071]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:57.071]                   0L) {
[10:29:57.071]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:57.071]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:57.071]                   base::options(opts)
[10:29:57.071]                 }
[10:29:57.071]                 {
[10:29:57.071]                   {
[10:29:57.071]                     NULL
[10:29:57.071]                     RNGkind("Mersenne-Twister")
[10:29:57.071]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:57.071]                       inherits = FALSE)
[10:29:57.071]                   }
[10:29:57.071]                   options(future.plan = NULL)
[10:29:57.071]                   if (is.na(NA_character_)) 
[10:29:57.071]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:57.071]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:57.071]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:57.071]                     .init = FALSE)
[10:29:57.071]                 }
[10:29:57.071]             }
[10:29:57.071]         }
[10:29:57.071]     })
[10:29:57.071]     if (TRUE) {
[10:29:57.071]         base::sink(type = "output", split = FALSE)
[10:29:57.071]         if (TRUE) {
[10:29:57.071]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:57.071]         }
[10:29:57.071]         else {
[10:29:57.071]             ...future.result["stdout"] <- base::list(NULL)
[10:29:57.071]         }
[10:29:57.071]         base::close(...future.stdout)
[10:29:57.071]         ...future.stdout <- NULL
[10:29:57.071]     }
[10:29:57.071]     ...future.result$conditions <- ...future.conditions
[10:29:57.071]     ...future.result$finished <- base::Sys.time()
[10:29:57.071]     ...future.result
[10:29:57.071] }
[10:29:57.072] assign_globals() ...
[10:29:57.072] List of 5
[10:29:57.072]  $ ...future.FUN            :function (x, ...)  
[10:29:57.072]  $ future.call.arguments    :List of 1
[10:29:57.072]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:29:57.072]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.072]  $ ...future.elements_ii    :List of 3
[10:29:57.072]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[10:29:57.072]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:29:57.072]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:29:57.072]  $ ...future.seeds_ii       : NULL
[10:29:57.072]  $ ...future.globals.maxSize: NULL
[10:29:57.072]  - attr(*, "where")=List of 5
[10:29:57.072]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:57.072]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:57.072]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:57.072]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:57.072]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:57.072]  - attr(*, "resolved")= logi FALSE
[10:29:57.072]  - attr(*, "total_size")= num 1328
[10:29:57.072]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.072]  - attr(*, "already-done")= logi TRUE
[10:29:57.078] - copied ‘...future.FUN’ to environment
[10:29:57.078] - copied ‘future.call.arguments’ to environment
[10:29:57.078] - copied ‘...future.elements_ii’ to environment
[10:29:57.078] - copied ‘...future.seeds_ii’ to environment
[10:29:57.078] - copied ‘...future.globals.maxSize’ to environment
[10:29:57.079] assign_globals() ... done
[10:29:57.079] plan(): Setting new future strategy stack:
[10:29:57.079] List of future strategies:
[10:29:57.079] 1. sequential:
[10:29:57.079]    - args: function (..., envir = parent.frame())
[10:29:57.079]    - tweaked: FALSE
[10:29:57.079]    - call: NULL
[10:29:57.079] plan(): nbrOfWorkers() = 1
[10:29:57.081] plan(): Setting new future strategy stack:
[10:29:57.081] List of future strategies:
[10:29:57.081] 1. sequential:
[10:29:57.081]    - args: function (..., envir = parent.frame())
[10:29:57.081]    - tweaked: FALSE
[10:29:57.081]    - call: plan(strategy)
[10:29:57.081] plan(): nbrOfWorkers() = 1
[10:29:57.081] SequentialFuture started (and completed)
[10:29:57.081] - Launch lazy future ... done
[10:29:57.081] run() for ‘SequentialFuture’ ... done
[10:29:57.082] Created future:
[10:29:57.082] SequentialFuture:
[10:29:57.082] Label: ‘future_eapply-1’
[10:29:57.082] Expression:
[10:29:57.082] {
[10:29:57.082]     do.call(function(...) {
[10:29:57.082]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.082]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:57.082]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.082]             on.exit(options(oopts), add = TRUE)
[10:29:57.082]         }
[10:29:57.082]         {
[10:29:57.082]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:57.082]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.082]                 ...future.FUN(...future.X_jj, ...)
[10:29:57.082]             })
[10:29:57.082]         }
[10:29:57.082]     }, args = future.call.arguments)
[10:29:57.082] }
[10:29:57.082] Lazy evaluation: FALSE
[10:29:57.082] Asynchronous evaluation: FALSE
[10:29:57.082] Local evaluation: TRUE
[10:29:57.082] Environment: R_GlobalEnv
[10:29:57.082] Capture standard output: TRUE
[10:29:57.082] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:57.082] Globals: 5 objects totaling 1.56 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:57.082] Packages: 1 packages (‘stats’)
[10:29:57.082] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:57.082] Resolved: TRUE
[10:29:57.082] Value: 1.29 KiB of class ‘list’
[10:29:57.082] Early signaling: FALSE
[10:29:57.082] Owner process: db6eb61b-64f1-ae95-7e8b-287fbc43411a
[10:29:57.082] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:57.083] Chunk #1 of 1 ... DONE
[10:29:57.083] Launching 1 futures (chunks) ... DONE
[10:29:57.083] Resolving 1 futures (chunks) ...
[10:29:57.083] resolve() on list ...
[10:29:57.083]  recursive: 0
[10:29:57.083]  length: 1
[10:29:57.083] 
[10:29:57.083] resolved() for ‘SequentialFuture’ ...
[10:29:57.083] - state: ‘finished’
[10:29:57.083] - run: TRUE
[10:29:57.084] - result: ‘FutureResult’
[10:29:57.084] resolved() for ‘SequentialFuture’ ... done
[10:29:57.084] Future #1
[10:29:57.086] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:57.086] - nx: 1
[10:29:57.086] - relay: TRUE
[10:29:57.086] - stdout: TRUE
[10:29:57.086] - signal: TRUE
[10:29:57.086] - resignal: FALSE
[10:29:57.086] - force: TRUE
[10:29:57.086] - relayed: [n=1] FALSE
[10:29:57.086] - queued futures: [n=1] FALSE
[10:29:57.086]  - until=1
[10:29:57.086]  - relaying element #1
[10:29:57.087] - relayed: [n=1] TRUE
[10:29:57.087] - queued futures: [n=1] TRUE
[10:29:57.087] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:57.087]  length: 0 (resolved future 1)
[10:29:57.087] Relaying remaining futures
[10:29:57.087] signalConditionsASAP(NULL, pos=0) ...
[10:29:57.087] - nx: 1
[10:29:57.087] - relay: TRUE
[10:29:57.087] - stdout: TRUE
[10:29:57.087] - signal: TRUE
[10:29:57.087] - resignal: FALSE
[10:29:57.088] - force: TRUE
[10:29:57.088] - relayed: [n=1] TRUE
[10:29:57.088] - queued futures: [n=1] TRUE
 - flush all
[10:29:57.088] - relayed: [n=1] TRUE
[10:29:57.088] - queued futures: [n=1] TRUE
[10:29:57.088] signalConditionsASAP(NULL, pos=0) ... done
[10:29:57.088] resolve() on list ... DONE
[10:29:57.088]  - Number of value chunks collected: 1
[10:29:57.088] Resolving 1 futures (chunks) ... DONE
[10:29:57.088] Reducing values from 1 chunks ...
[10:29:57.089]  - Number of values collected after concatenation: 3
[10:29:57.089]  - Number of values expected: 3
[10:29:57.089] Reducing values from 1 chunks ... DONE
[10:29:57.089] future_lapply() ... DONE
[10:29:57.090] future_lapply() ...
[10:29:57.091] Number of chunks: 1
[10:29:57.091] getGlobalsAndPackagesXApply() ...
[10:29:57.091]  - future.globals: TRUE
[10:29:57.091] getGlobalsAndPackages() ...
[10:29:57.091] Searching for globals...
[10:29:57.092] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:57.092] Searching for globals ... DONE
[10:29:57.092] Resolving globals: FALSE
[10:29:57.093] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[10:29:57.093] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[10:29:57.093] - globals: [1] ‘FUN’
[10:29:57.093] - packages: [1] ‘stats’
[10:29:57.093] getGlobalsAndPackages() ... DONE
[10:29:57.094]  - globals found/used: [n=1] ‘FUN’
[10:29:57.094]  - needed namespaces: [n=1] ‘stats’
[10:29:57.094] Finding globals ... DONE
[10:29:57.094]  - use_args: TRUE
[10:29:57.094]  - Getting '...' globals ...
[10:29:57.094] resolve() on list ...
[10:29:57.094]  recursive: 0
[10:29:57.094]  length: 1
[10:29:57.094]  elements: ‘...’
[10:29:57.095]  length: 0 (resolved future 1)
[10:29:57.095] resolve() on list ... DONE
[10:29:57.095]    - '...' content: [n=0] 
[10:29:57.095] List of 1
[10:29:57.095]  $ ...: list()
[10:29:57.095]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.095]  - attr(*, "where")=List of 1
[10:29:57.095]   ..$ ...:<environment: 0x5597496c05a0> 
[10:29:57.095]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.095]  - attr(*, "resolved")= logi TRUE
[10:29:57.095]  - attr(*, "total_size")= num NA
[10:29:57.097]  - Getting '...' globals ... DONE
[10:29:57.098] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:57.098] List of 2
[10:29:57.098]  $ ...future.FUN:function (x, ...)  
[10:29:57.098]  $ ...          : list()
[10:29:57.098]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.098]  - attr(*, "where")=List of 2
[10:29:57.098]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:57.098]   ..$ ...          :<environment: 0x5597496c05a0> 
[10:29:57.098]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.098]  - attr(*, "resolved")= logi FALSE
[10:29:57.098]  - attr(*, "total_size")= num 1248
[10:29:57.100] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:57.100] getGlobalsAndPackagesXApply() ... DONE
[10:29:57.100] Number of futures (= number of chunks): 1
[10:29:57.101] Launching 1 futures (chunks) ...
[10:29:57.101] Chunk #1 of 1 ...
[10:29:57.101]  - Finding globals in 'X' for chunk #1 ...
[10:29:57.101] getGlobalsAndPackages() ...
[10:29:57.101] Searching for globals...
[10:29:57.101] 
[10:29:57.101] Searching for globals ... DONE
[10:29:57.101] - globals: [0] <none>
[10:29:57.102] getGlobalsAndPackages() ... DONE
[10:29:57.102]    + additional globals found: [n=0] 
[10:29:57.102]    + additional namespaces needed: [n=0] 
[10:29:57.102]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:57.102]  - seeds: <none>
[10:29:57.102]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.102] getGlobalsAndPackages() ...
[10:29:57.102] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.102] Resolving globals: FALSE
[10:29:57.102] Tweak future expression to call with '...' arguments ...
[10:29:57.103] {
[10:29:57.103]     do.call(function(...) {
[10:29:57.103]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.103]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:57.103]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.103]             on.exit(options(oopts), add = TRUE)
[10:29:57.103]         }
[10:29:57.103]         {
[10:29:57.103]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:57.103]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.103]                 ...future.FUN(...future.X_jj, ...)
[10:29:57.103]             })
[10:29:57.103]         }
[10:29:57.103]     }, args = future.call.arguments)
[10:29:57.103] }
[10:29:57.103] Tweak future expression to call with '...' arguments ... DONE
[10:29:57.103] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.103] - packages: [1] ‘stats’
[10:29:57.103] getGlobalsAndPackages() ... DONE
[10:29:57.104] run() for ‘Future’ ...
[10:29:57.104] - state: ‘created’
[10:29:57.104] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:29:57.104] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:57.104] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:57.104]   - Field: ‘label’
[10:29:57.104]   - Field: ‘local’
[10:29:57.105]   - Field: ‘owner’
[10:29:57.105]   - Field: ‘envir’
[10:29:57.105]   - Field: ‘packages’
[10:29:57.105]   - Field: ‘gc’
[10:29:57.105]   - Field: ‘conditions’
[10:29:57.105]   - Field: ‘expr’
[10:29:57.105]   - Field: ‘uuid’
[10:29:57.105]   - Field: ‘seed’
[10:29:57.105]   - Field: ‘version’
[10:29:57.105]   - Field: ‘result’
[10:29:57.105]   - Field: ‘asynchronous’
[10:29:57.106]   - Field: ‘calls’
[10:29:57.106]   - Field: ‘globals’
[10:29:57.106]   - Field: ‘stdout’
[10:29:57.106]   - Field: ‘earlySignal’
[10:29:57.106]   - Field: ‘lazy’
[10:29:57.106]   - Field: ‘state’
[10:29:57.106] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:57.106] - Launch lazy future ...
[10:29:57.106] Packages needed by the future expression (n = 1): ‘stats’
[10:29:57.106] Packages needed by future strategies (n = 0): <none>
[10:29:57.107] {
[10:29:57.107]     {
[10:29:57.107]         {
[10:29:57.107]             ...future.startTime <- base::Sys.time()
[10:29:57.107]             {
[10:29:57.107]                 {
[10:29:57.107]                   {
[10:29:57.107]                     {
[10:29:57.107]                       base::local({
[10:29:57.107]                         has_future <- base::requireNamespace("future", 
[10:29:57.107]                           quietly = TRUE)
[10:29:57.107]                         if (has_future) {
[10:29:57.107]                           ns <- base::getNamespace("future")
[10:29:57.107]                           version <- ns[[".package"]][["version"]]
[10:29:57.107]                           if (is.null(version)) 
[10:29:57.107]                             version <- utils::packageVersion("future")
[10:29:57.107]                         }
[10:29:57.107]                         else {
[10:29:57.107]                           version <- NULL
[10:29:57.107]                         }
[10:29:57.107]                         if (!has_future || version < "1.8.0") {
[10:29:57.107]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:57.107]                             "", base::R.version$version.string), 
[10:29:57.107]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:57.107]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:57.107]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:57.107]                               "release", "version")], collapse = " "), 
[10:29:57.107]                             hostname = base::Sys.info()[["nodename"]])
[10:29:57.107]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:57.107]                             info)
[10:29:57.107]                           info <- base::paste(info, collapse = "; ")
[10:29:57.107]                           if (!has_future) {
[10:29:57.107]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:57.107]                               info)
[10:29:57.107]                           }
[10:29:57.107]                           else {
[10:29:57.107]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:57.107]                               info, version)
[10:29:57.107]                           }
[10:29:57.107]                           base::stop(msg)
[10:29:57.107]                         }
[10:29:57.107]                       })
[10:29:57.107]                     }
[10:29:57.107]                     base::local({
[10:29:57.107]                       for (pkg in "stats") {
[10:29:57.107]                         base::loadNamespace(pkg)
[10:29:57.107]                         base::library(pkg, character.only = TRUE)
[10:29:57.107]                       }
[10:29:57.107]                     })
[10:29:57.107]                   }
[10:29:57.107]                   ...future.strategy.old <- future::plan("list")
[10:29:57.107]                   options(future.plan = NULL)
[10:29:57.107]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:57.107]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:57.107]                 }
[10:29:57.107]                 ...future.workdir <- getwd()
[10:29:57.107]             }
[10:29:57.107]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:57.107]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:57.107]         }
[10:29:57.107]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:57.107]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:57.107]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:57.107]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:57.107]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:57.107]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:57.107]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:57.107]             base::names(...future.oldOptions))
[10:29:57.107]     }
[10:29:57.107]     if (FALSE) {
[10:29:57.107]     }
[10:29:57.107]     else {
[10:29:57.107]         if (TRUE) {
[10:29:57.107]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:57.107]                 open = "w")
[10:29:57.107]         }
[10:29:57.107]         else {
[10:29:57.107]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:57.107]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:57.107]         }
[10:29:57.107]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:57.107]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:57.107]             base::sink(type = "output", split = FALSE)
[10:29:57.107]             base::close(...future.stdout)
[10:29:57.107]         }, add = TRUE)
[10:29:57.107]     }
[10:29:57.107]     ...future.frame <- base::sys.nframe()
[10:29:57.107]     ...future.conditions <- base::list()
[10:29:57.107]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:57.107]     if (FALSE) {
[10:29:57.107]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:57.107]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:57.107]     }
[10:29:57.107]     ...future.result <- base::tryCatch({
[10:29:57.107]         base::withCallingHandlers({
[10:29:57.107]             ...future.value <- base::withVisible(base::local({
[10:29:57.107]                 do.call(function(...) {
[10:29:57.107]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.107]                   if (!identical(...future.globals.maxSize.org, 
[10:29:57.107]                     ...future.globals.maxSize)) {
[10:29:57.107]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.107]                     on.exit(options(oopts), add = TRUE)
[10:29:57.107]                   }
[10:29:57.107]                   {
[10:29:57.107]                     lapply(seq_along(...future.elements_ii), 
[10:29:57.107]                       FUN = function(jj) {
[10:29:57.107]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.107]                         ...future.FUN(...future.X_jj, ...)
[10:29:57.107]                       })
[10:29:57.107]                   }
[10:29:57.107]                 }, args = future.call.arguments)
[10:29:57.107]             }))
[10:29:57.107]             future::FutureResult(value = ...future.value$value, 
[10:29:57.107]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:57.107]                   ...future.rng), globalenv = if (FALSE) 
[10:29:57.107]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:57.107]                     ...future.globalenv.names))
[10:29:57.107]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:57.107]         }, condition = base::local({
[10:29:57.107]             c <- base::c
[10:29:57.107]             inherits <- base::inherits
[10:29:57.107]             invokeRestart <- base::invokeRestart
[10:29:57.107]             length <- base::length
[10:29:57.107]             list <- base::list
[10:29:57.107]             seq.int <- base::seq.int
[10:29:57.107]             signalCondition <- base::signalCondition
[10:29:57.107]             sys.calls <- base::sys.calls
[10:29:57.107]             `[[` <- base::`[[`
[10:29:57.107]             `+` <- base::`+`
[10:29:57.107]             `<<-` <- base::`<<-`
[10:29:57.107]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:57.107]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:57.107]                   3L)]
[10:29:57.107]             }
[10:29:57.107]             function(cond) {
[10:29:57.107]                 is_error <- inherits(cond, "error")
[10:29:57.107]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:57.107]                   NULL)
[10:29:57.107]                 if (is_error) {
[10:29:57.107]                   sessionInformation <- function() {
[10:29:57.107]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:57.107]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:57.107]                       search = base::search(), system = base::Sys.info())
[10:29:57.107]                   }
[10:29:57.107]                   ...future.conditions[[length(...future.conditions) + 
[10:29:57.107]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:57.107]                     cond$call), session = sessionInformation(), 
[10:29:57.107]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:57.107]                   signalCondition(cond)
[10:29:57.107]                 }
[10:29:57.107]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:57.107]                 "immediateCondition"))) {
[10:29:57.107]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:57.107]                   ...future.conditions[[length(...future.conditions) + 
[10:29:57.107]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:57.107]                   if (TRUE && !signal) {
[10:29:57.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.107]                     {
[10:29:57.107]                       inherits <- base::inherits
[10:29:57.107]                       invokeRestart <- base::invokeRestart
[10:29:57.107]                       is.null <- base::is.null
[10:29:57.107]                       muffled <- FALSE
[10:29:57.107]                       if (inherits(cond, "message")) {
[10:29:57.107]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:57.107]                         if (muffled) 
[10:29:57.107]                           invokeRestart("muffleMessage")
[10:29:57.107]                       }
[10:29:57.107]                       else if (inherits(cond, "warning")) {
[10:29:57.107]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:57.107]                         if (muffled) 
[10:29:57.107]                           invokeRestart("muffleWarning")
[10:29:57.107]                       }
[10:29:57.107]                       else if (inherits(cond, "condition")) {
[10:29:57.107]                         if (!is.null(pattern)) {
[10:29:57.107]                           computeRestarts <- base::computeRestarts
[10:29:57.107]                           grepl <- base::grepl
[10:29:57.107]                           restarts <- computeRestarts(cond)
[10:29:57.107]                           for (restart in restarts) {
[10:29:57.107]                             name <- restart$name
[10:29:57.107]                             if (is.null(name)) 
[10:29:57.107]                               next
[10:29:57.107]                             if (!grepl(pattern, name)) 
[10:29:57.107]                               next
[10:29:57.107]                             invokeRestart(restart)
[10:29:57.107]                             muffled <- TRUE
[10:29:57.107]                             break
[10:29:57.107]                           }
[10:29:57.107]                         }
[10:29:57.107]                       }
[10:29:57.107]                       invisible(muffled)
[10:29:57.107]                     }
[10:29:57.107]                     muffleCondition(cond, pattern = "^muffle")
[10:29:57.107]                   }
[10:29:57.107]                 }
[10:29:57.107]                 else {
[10:29:57.107]                   if (TRUE) {
[10:29:57.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.107]                     {
[10:29:57.107]                       inherits <- base::inherits
[10:29:57.107]                       invokeRestart <- base::invokeRestart
[10:29:57.107]                       is.null <- base::is.null
[10:29:57.107]                       muffled <- FALSE
[10:29:57.107]                       if (inherits(cond, "message")) {
[10:29:57.107]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:57.107]                         if (muffled) 
[10:29:57.107]                           invokeRestart("muffleMessage")
[10:29:57.107]                       }
[10:29:57.107]                       else if (inherits(cond, "warning")) {
[10:29:57.107]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:57.107]                         if (muffled) 
[10:29:57.107]                           invokeRestart("muffleWarning")
[10:29:57.107]                       }
[10:29:57.107]                       else if (inherits(cond, "condition")) {
[10:29:57.107]                         if (!is.null(pattern)) {
[10:29:57.107]                           computeRestarts <- base::computeRestarts
[10:29:57.107]                           grepl <- base::grepl
[10:29:57.107]                           restarts <- computeRestarts(cond)
[10:29:57.107]                           for (restart in restarts) {
[10:29:57.107]                             name <- restart$name
[10:29:57.107]                             if (is.null(name)) 
[10:29:57.107]                               next
[10:29:57.107]                             if (!grepl(pattern, name)) 
[10:29:57.107]                               next
[10:29:57.107]                             invokeRestart(restart)
[10:29:57.107]                             muffled <- TRUE
[10:29:57.107]                             break
[10:29:57.107]                           }
[10:29:57.107]                         }
[10:29:57.107]                       }
[10:29:57.107]                       invisible(muffled)
[10:29:57.107]                     }
[10:29:57.107]                     muffleCondition(cond, pattern = "^muffle")
[10:29:57.107]                   }
[10:29:57.107]                 }
[10:29:57.107]             }
[10:29:57.107]         }))
[10:29:57.107]     }, error = function(ex) {
[10:29:57.107]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:57.107]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:57.107]                 ...future.rng), started = ...future.startTime, 
[10:29:57.107]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:57.107]             version = "1.8"), class = "FutureResult")
[10:29:57.107]     }, finally = {
[10:29:57.107]         if (!identical(...future.workdir, getwd())) 
[10:29:57.107]             setwd(...future.workdir)
[10:29:57.107]         {
[10:29:57.107]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:57.107]                 ...future.oldOptions$nwarnings <- NULL
[10:29:57.107]             }
[10:29:57.107]             base::options(...future.oldOptions)
[10:29:57.107]             if (.Platform$OS.type == "windows") {
[10:29:57.107]                 old_names <- names(...future.oldEnvVars)
[10:29:57.107]                 envs <- base::Sys.getenv()
[10:29:57.107]                 names <- names(envs)
[10:29:57.107]                 common <- intersect(names, old_names)
[10:29:57.107]                 added <- setdiff(names, old_names)
[10:29:57.107]                 removed <- setdiff(old_names, names)
[10:29:57.107]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:57.107]                   envs[common]]
[10:29:57.107]                 NAMES <- toupper(changed)
[10:29:57.107]                 args <- list()
[10:29:57.107]                 for (kk in seq_along(NAMES)) {
[10:29:57.107]                   name <- changed[[kk]]
[10:29:57.107]                   NAME <- NAMES[[kk]]
[10:29:57.107]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.107]                     next
[10:29:57.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:57.107]                 }
[10:29:57.107]                 NAMES <- toupper(added)
[10:29:57.107]                 for (kk in seq_along(NAMES)) {
[10:29:57.107]                   name <- added[[kk]]
[10:29:57.107]                   NAME <- NAMES[[kk]]
[10:29:57.107]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.107]                     next
[10:29:57.107]                   args[[name]] <- ""
[10:29:57.107]                 }
[10:29:57.107]                 NAMES <- toupper(removed)
[10:29:57.107]                 for (kk in seq_along(NAMES)) {
[10:29:57.107]                   name <- removed[[kk]]
[10:29:57.107]                   NAME <- NAMES[[kk]]
[10:29:57.107]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.107]                     next
[10:29:57.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:57.107]                 }
[10:29:57.107]                 if (length(args) > 0) 
[10:29:57.107]                   base::do.call(base::Sys.setenv, args = args)
[10:29:57.107]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:57.107]             }
[10:29:57.107]             else {
[10:29:57.107]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:57.107]             }
[10:29:57.107]             {
[10:29:57.107]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:57.107]                   0L) {
[10:29:57.107]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:57.107]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:57.107]                   base::options(opts)
[10:29:57.107]                 }
[10:29:57.107]                 {
[10:29:57.107]                   {
[10:29:57.107]                     NULL
[10:29:57.107]                     RNGkind("Mersenne-Twister")
[10:29:57.107]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:57.107]                       inherits = FALSE)
[10:29:57.107]                   }
[10:29:57.107]                   options(future.plan = NULL)
[10:29:57.107]                   if (is.na(NA_character_)) 
[10:29:57.107]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:57.107]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:57.107]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:57.107]                     .init = FALSE)
[10:29:57.107]                 }
[10:29:57.107]             }
[10:29:57.107]         }
[10:29:57.107]     })
[10:29:57.107]     if (TRUE) {
[10:29:57.107]         base::sink(type = "output", split = FALSE)
[10:29:57.107]         if (TRUE) {
[10:29:57.107]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:57.107]         }
[10:29:57.107]         else {
[10:29:57.107]             ...future.result["stdout"] <- base::list(NULL)
[10:29:57.107]         }
[10:29:57.107]         base::close(...future.stdout)
[10:29:57.107]         ...future.stdout <- NULL
[10:29:57.107]     }
[10:29:57.107]     ...future.result$conditions <- ...future.conditions
[10:29:57.107]     ...future.result$finished <- base::Sys.time()
[10:29:57.107]     ...future.result
[10:29:57.107] }
[10:29:57.109] assign_globals() ...
[10:29:57.109] List of 5
[10:29:57.109]  $ ...future.FUN            :function (x, ...)  
[10:29:57.109]  $ future.call.arguments    : list()
[10:29:57.109]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.109]  $ ...future.elements_ii    :List of 3
[10:29:57.109]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[10:29:57.109]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:29:57.109]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:29:57.109]  $ ...future.seeds_ii       : NULL
[10:29:57.109]  $ ...future.globals.maxSize: NULL
[10:29:57.109]  - attr(*, "where")=List of 5
[10:29:57.109]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:57.109]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:57.109]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:57.109]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:57.109]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:57.109]  - attr(*, "resolved")= logi FALSE
[10:29:57.109]  - attr(*, "total_size")= num 1248
[10:29:57.109]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.109]  - attr(*, "already-done")= logi TRUE
[10:29:57.118] - copied ‘...future.FUN’ to environment
[10:29:57.118] - copied ‘future.call.arguments’ to environment
[10:29:57.118] - copied ‘...future.elements_ii’ to environment
[10:29:57.118] - copied ‘...future.seeds_ii’ to environment
[10:29:57.118] - copied ‘...future.globals.maxSize’ to environment
[10:29:57.119] assign_globals() ... done
[10:29:57.119] plan(): Setting new future strategy stack:
[10:29:57.119] List of future strategies:
[10:29:57.119] 1. sequential:
[10:29:57.119]    - args: function (..., envir = parent.frame())
[10:29:57.119]    - tweaked: FALSE
[10:29:57.119]    - call: NULL
[10:29:57.120] plan(): nbrOfWorkers() = 1
[10:29:57.121] plan(): Setting new future strategy stack:
[10:29:57.122] List of future strategies:
[10:29:57.122] 1. sequential:
[10:29:57.122]    - args: function (..., envir = parent.frame())
[10:29:57.122]    - tweaked: FALSE
[10:29:57.122]    - call: plan(strategy)
[10:29:57.122] plan(): nbrOfWorkers() = 1
[10:29:57.122] SequentialFuture started (and completed)
[10:29:57.123] - Launch lazy future ... done
[10:29:57.123] run() for ‘SequentialFuture’ ... done
[10:29:57.123] Created future:
[10:29:57.123] SequentialFuture:
[10:29:57.123] Label: ‘future_eapply-1’
[10:29:57.123] Expression:
[10:29:57.123] {
[10:29:57.123]     do.call(function(...) {
[10:29:57.123]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.123]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:57.123]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.123]             on.exit(options(oopts), add = TRUE)
[10:29:57.123]         }
[10:29:57.123]         {
[10:29:57.123]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:57.123]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.123]                 ...future.FUN(...future.X_jj, ...)
[10:29:57.123]             })
[10:29:57.123]         }
[10:29:57.123]     }, args = future.call.arguments)
[10:29:57.123] }
[10:29:57.123] Lazy evaluation: FALSE
[10:29:57.123] Asynchronous evaluation: FALSE
[10:29:57.123] Local evaluation: TRUE
[10:29:57.123] Environment: R_GlobalEnv
[10:29:57.123] Capture standard output: TRUE
[10:29:57.123] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:57.123] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:57.123] Packages: 1 packages (‘stats’)
[10:29:57.123] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:57.123] Resolved: TRUE
[10:29:57.123] Value: 1.71 KiB of class ‘list’
[10:29:57.123] Early signaling: FALSE
[10:29:57.123] Owner process: db6eb61b-64f1-ae95-7e8b-287fbc43411a
[10:29:57.123] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:57.124] Chunk #1 of 1 ... DONE
[10:29:57.124] Launching 1 futures (chunks) ... DONE
[10:29:57.124] Resolving 1 futures (chunks) ...
[10:29:57.124] resolve() on list ...
[10:29:57.125]  recursive: 0
[10:29:57.125]  length: 1
[10:29:57.125] 
[10:29:57.125] resolved() for ‘SequentialFuture’ ...
[10:29:57.125] - state: ‘finished’
[10:29:57.125] - run: TRUE
[10:29:57.125] - result: ‘FutureResult’
[10:29:57.125] resolved() for ‘SequentialFuture’ ... done
[10:29:57.125] Future #1
[10:29:57.126] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:57.126] - nx: 1
[10:29:57.126] - relay: TRUE
[10:29:57.126] - stdout: TRUE
[10:29:57.126] - signal: TRUE
[10:29:57.126] - resignal: FALSE
[10:29:57.126] - force: TRUE
[10:29:57.126] - relayed: [n=1] FALSE
[10:29:57.126] - queued futures: [n=1] FALSE
[10:29:57.126]  - until=1
[10:29:57.126]  - relaying element #1
[10:29:57.127] - relayed: [n=1] TRUE
[10:29:57.127] - queued futures: [n=1] TRUE
[10:29:57.127] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:57.127]  length: 0 (resolved future 1)
[10:29:57.127] Relaying remaining futures
[10:29:57.127] signalConditionsASAP(NULL, pos=0) ...
[10:29:57.127] - nx: 1
[10:29:57.127] - relay: TRUE
[10:29:57.127] - stdout: TRUE
[10:29:57.127] - signal: TRUE
[10:29:57.127] - resignal: FALSE
[10:29:57.127] - force: TRUE
[10:29:57.128] - relayed: [n=1] TRUE
[10:29:57.128] - queued futures: [n=1] TRUE
 - flush all
[10:29:57.128] - relayed: [n=1] TRUE
[10:29:57.128] - queued futures: [n=1] TRUE
[10:29:57.128] signalConditionsASAP(NULL, pos=0) ... done
[10:29:57.128] resolve() on list ... DONE
[10:29:57.128]  - Number of value chunks collected: 1
[10:29:57.128] Resolving 1 futures (chunks) ... DONE
[10:29:57.128] Reducing values from 1 chunks ...
[10:29:57.128]  - Number of values collected after concatenation: 3
[10:29:57.129]  - Number of values expected: 3
[10:29:57.129] Reducing values from 1 chunks ... DONE
[10:29:57.129] future_lapply() ... DONE
[10:29:57.129] future_lapply() ...
[10:29:57.130] Number of chunks: 1
[10:29:57.130] getGlobalsAndPackagesXApply() ...
[10:29:57.130]  - future.globals: TRUE
[10:29:57.130] getGlobalsAndPackages() ...
[10:29:57.130] Searching for globals...
[10:29:57.131] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:57.131] Searching for globals ... DONE
[10:29:57.131] Resolving globals: FALSE
[10:29:57.131] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[10:29:57.132] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[10:29:57.132] - globals: [1] ‘FUN’
[10:29:57.132] - packages: [1] ‘stats’
[10:29:57.132] getGlobalsAndPackages() ... DONE
[10:29:57.132]  - globals found/used: [n=1] ‘FUN’
[10:29:57.132]  - needed namespaces: [n=1] ‘stats’
[10:29:57.132] Finding globals ... DONE
[10:29:57.133]  - use_args: TRUE
[10:29:57.133]  - Getting '...' globals ...
[10:29:57.133] resolve() on list ...
[10:29:57.133]  recursive: 0
[10:29:57.133]  length: 1
[10:29:57.133]  elements: ‘...’
[10:29:57.133]  length: 0 (resolved future 1)
[10:29:57.133] resolve() on list ... DONE
[10:29:57.134]    - '...' content: [n=0] 
[10:29:57.134] List of 1
[10:29:57.134]  $ ...: list()
[10:29:57.134]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.134]  - attr(*, "where")=List of 1
[10:29:57.134]   ..$ ...:<environment: 0x55974b6cbad8> 
[10:29:57.134]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.134]  - attr(*, "resolved")= logi TRUE
[10:29:57.134]  - attr(*, "total_size")= num NA
[10:29:57.136]  - Getting '...' globals ... DONE
[10:29:57.138] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:57.138] List of 2
[10:29:57.138]  $ ...future.FUN:function (x, ...)  
[10:29:57.138]  $ ...          : list()
[10:29:57.138]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.138]  - attr(*, "where")=List of 2
[10:29:57.138]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:57.138]   ..$ ...          :<environment: 0x55974b6cbad8> 
[10:29:57.138]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.138]  - attr(*, "resolved")= logi FALSE
[10:29:57.138]  - attr(*, "total_size")= num 1248
[10:29:57.141] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:57.141] getGlobalsAndPackagesXApply() ... DONE
[10:29:57.141] Number of futures (= number of chunks): 1
[10:29:57.141] Launching 1 futures (chunks) ...
[10:29:57.141] Chunk #1 of 1 ...
[10:29:57.141]  - Finding globals in 'X' for chunk #1 ...
[10:29:57.141] getGlobalsAndPackages() ...
[10:29:57.141] Searching for globals...
[10:29:57.142] 
[10:29:57.142] Searching for globals ... DONE
[10:29:57.142] - globals: [0] <none>
[10:29:57.142] getGlobalsAndPackages() ... DONE
[10:29:57.142]    + additional globals found: [n=0] 
[10:29:57.142]    + additional namespaces needed: [n=0] 
[10:29:57.142]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:57.142]  - seeds: <none>
[10:29:57.142]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.142] getGlobalsAndPackages() ...
[10:29:57.143] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.143] Resolving globals: FALSE
[10:29:57.143] Tweak future expression to call with '...' arguments ...
[10:29:57.143] {
[10:29:57.143]     do.call(function(...) {
[10:29:57.143]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.143]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:57.143]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.143]             on.exit(options(oopts), add = TRUE)
[10:29:57.143]         }
[10:29:57.143]         {
[10:29:57.143]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:57.143]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.143]                 ...future.FUN(...future.X_jj, ...)
[10:29:57.143]             })
[10:29:57.143]         }
[10:29:57.143]     }, args = future.call.arguments)
[10:29:57.143] }
[10:29:57.143] Tweak future expression to call with '...' arguments ... DONE
[10:29:57.143] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.144] - packages: [1] ‘stats’
[10:29:57.144] getGlobalsAndPackages() ... DONE
[10:29:57.144] run() for ‘Future’ ...
[10:29:57.144] - state: ‘created’
[10:29:57.144] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:29:57.144] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:57.145] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:29:57.145]   - Field: ‘label’
[10:29:57.145]   - Field: ‘local’
[10:29:57.145]   - Field: ‘owner’
[10:29:57.145]   - Field: ‘envir’
[10:29:57.145]   - Field: ‘packages’
[10:29:57.145]   - Field: ‘gc’
[10:29:57.145]   - Field: ‘conditions’
[10:29:57.145]   - Field: ‘expr’
[10:29:57.145]   - Field: ‘uuid’
[10:29:57.146]   - Field: ‘seed’
[10:29:57.146]   - Field: ‘version’
[10:29:57.146]   - Field: ‘result’
[10:29:57.146]   - Field: ‘asynchronous’
[10:29:57.146]   - Field: ‘calls’
[10:29:57.146]   - Field: ‘globals’
[10:29:57.146]   - Field: ‘stdout’
[10:29:57.146]   - Field: ‘earlySignal’
[10:29:57.146]   - Field: ‘lazy’
[10:29:57.146]   - Field: ‘state’
[10:29:57.147] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:29:57.147] - Launch lazy future ...
[10:29:57.147] Packages needed by the future expression (n = 1): ‘stats’
[10:29:57.147] Packages needed by future strategies (n = 0): <none>
[10:29:57.147] {
[10:29:57.147]     {
[10:29:57.147]         {
[10:29:57.147]             ...future.startTime <- base::Sys.time()
[10:29:57.147]             {
[10:29:57.147]                 {
[10:29:57.147]                   {
[10:29:57.147]                     {
[10:29:57.147]                       base::local({
[10:29:57.147]                         has_future <- base::requireNamespace("future", 
[10:29:57.147]                           quietly = TRUE)
[10:29:57.147]                         if (has_future) {
[10:29:57.147]                           ns <- base::getNamespace("future")
[10:29:57.147]                           version <- ns[[".package"]][["version"]]
[10:29:57.147]                           if (is.null(version)) 
[10:29:57.147]                             version <- utils::packageVersion("future")
[10:29:57.147]                         }
[10:29:57.147]                         else {
[10:29:57.147]                           version <- NULL
[10:29:57.147]                         }
[10:29:57.147]                         if (!has_future || version < "1.8.0") {
[10:29:57.147]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:57.147]                             "", base::R.version$version.string), 
[10:29:57.147]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:57.147]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:57.147]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:57.147]                               "release", "version")], collapse = " "), 
[10:29:57.147]                             hostname = base::Sys.info()[["nodename"]])
[10:29:57.147]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:57.147]                             info)
[10:29:57.147]                           info <- base::paste(info, collapse = "; ")
[10:29:57.147]                           if (!has_future) {
[10:29:57.147]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:57.147]                               info)
[10:29:57.147]                           }
[10:29:57.147]                           else {
[10:29:57.147]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:57.147]                               info, version)
[10:29:57.147]                           }
[10:29:57.147]                           base::stop(msg)
[10:29:57.147]                         }
[10:29:57.147]                       })
[10:29:57.147]                     }
[10:29:57.147]                     base::local({
[10:29:57.147]                       for (pkg in "stats") {
[10:29:57.147]                         base::loadNamespace(pkg)
[10:29:57.147]                         base::library(pkg, character.only = TRUE)
[10:29:57.147]                       }
[10:29:57.147]                     })
[10:29:57.147]                   }
[10:29:57.147]                   ...future.strategy.old <- future::plan("list")
[10:29:57.147]                   options(future.plan = NULL)
[10:29:57.147]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:57.147]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:57.147]                 }
[10:29:57.147]                 ...future.workdir <- getwd()
[10:29:57.147]             }
[10:29:57.147]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:57.147]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:57.147]         }
[10:29:57.147]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:57.147]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:57.147]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:57.147]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:57.147]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:57.147]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:57.147]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:57.147]             base::names(...future.oldOptions))
[10:29:57.147]     }
[10:29:57.147]     if (FALSE) {
[10:29:57.147]     }
[10:29:57.147]     else {
[10:29:57.147]         if (TRUE) {
[10:29:57.147]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:57.147]                 open = "w")
[10:29:57.147]         }
[10:29:57.147]         else {
[10:29:57.147]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:57.147]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:57.147]         }
[10:29:57.147]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:57.147]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:57.147]             base::sink(type = "output", split = FALSE)
[10:29:57.147]             base::close(...future.stdout)
[10:29:57.147]         }, add = TRUE)
[10:29:57.147]     }
[10:29:57.147]     ...future.frame <- base::sys.nframe()
[10:29:57.147]     ...future.conditions <- base::list()
[10:29:57.147]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:57.147]     if (FALSE) {
[10:29:57.147]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:57.147]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:57.147]     }
[10:29:57.147]     ...future.result <- base::tryCatch({
[10:29:57.147]         base::withCallingHandlers({
[10:29:57.147]             ...future.value <- base::withVisible(base::local({
[10:29:57.147]                 do.call(function(...) {
[10:29:57.147]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.147]                   if (!identical(...future.globals.maxSize.org, 
[10:29:57.147]                     ...future.globals.maxSize)) {
[10:29:57.147]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.147]                     on.exit(options(oopts), add = TRUE)
[10:29:57.147]                   }
[10:29:57.147]                   {
[10:29:57.147]                     lapply(seq_along(...future.elements_ii), 
[10:29:57.147]                       FUN = function(jj) {
[10:29:57.147]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.147]                         ...future.FUN(...future.X_jj, ...)
[10:29:57.147]                       })
[10:29:57.147]                   }
[10:29:57.147]                 }, args = future.call.arguments)
[10:29:57.147]             }))
[10:29:57.147]             future::FutureResult(value = ...future.value$value, 
[10:29:57.147]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:57.147]                   ...future.rng), globalenv = if (FALSE) 
[10:29:57.147]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:57.147]                     ...future.globalenv.names))
[10:29:57.147]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:57.147]         }, condition = base::local({
[10:29:57.147]             c <- base::c
[10:29:57.147]             inherits <- base::inherits
[10:29:57.147]             invokeRestart <- base::invokeRestart
[10:29:57.147]             length <- base::length
[10:29:57.147]             list <- base::list
[10:29:57.147]             seq.int <- base::seq.int
[10:29:57.147]             signalCondition <- base::signalCondition
[10:29:57.147]             sys.calls <- base::sys.calls
[10:29:57.147]             `[[` <- base::`[[`
[10:29:57.147]             `+` <- base::`+`
[10:29:57.147]             `<<-` <- base::`<<-`
[10:29:57.147]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:57.147]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:57.147]                   3L)]
[10:29:57.147]             }
[10:29:57.147]             function(cond) {
[10:29:57.147]                 is_error <- inherits(cond, "error")
[10:29:57.147]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:57.147]                   NULL)
[10:29:57.147]                 if (is_error) {
[10:29:57.147]                   sessionInformation <- function() {
[10:29:57.147]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:57.147]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:57.147]                       search = base::search(), system = base::Sys.info())
[10:29:57.147]                   }
[10:29:57.147]                   ...future.conditions[[length(...future.conditions) + 
[10:29:57.147]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:57.147]                     cond$call), session = sessionInformation(), 
[10:29:57.147]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:57.147]                   signalCondition(cond)
[10:29:57.147]                 }
[10:29:57.147]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:57.147]                 "immediateCondition"))) {
[10:29:57.147]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:57.147]                   ...future.conditions[[length(...future.conditions) + 
[10:29:57.147]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:57.147]                   if (TRUE && !signal) {
[10:29:57.147]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.147]                     {
[10:29:57.147]                       inherits <- base::inherits
[10:29:57.147]                       invokeRestart <- base::invokeRestart
[10:29:57.147]                       is.null <- base::is.null
[10:29:57.147]                       muffled <- FALSE
[10:29:57.147]                       if (inherits(cond, "message")) {
[10:29:57.147]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:57.147]                         if (muffled) 
[10:29:57.147]                           invokeRestart("muffleMessage")
[10:29:57.147]                       }
[10:29:57.147]                       else if (inherits(cond, "warning")) {
[10:29:57.147]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:57.147]                         if (muffled) 
[10:29:57.147]                           invokeRestart("muffleWarning")
[10:29:57.147]                       }
[10:29:57.147]                       else if (inherits(cond, "condition")) {
[10:29:57.147]                         if (!is.null(pattern)) {
[10:29:57.147]                           computeRestarts <- base::computeRestarts
[10:29:57.147]                           grepl <- base::grepl
[10:29:57.147]                           restarts <- computeRestarts(cond)
[10:29:57.147]                           for (restart in restarts) {
[10:29:57.147]                             name <- restart$name
[10:29:57.147]                             if (is.null(name)) 
[10:29:57.147]                               next
[10:29:57.147]                             if (!grepl(pattern, name)) 
[10:29:57.147]                               next
[10:29:57.147]                             invokeRestart(restart)
[10:29:57.147]                             muffled <- TRUE
[10:29:57.147]                             break
[10:29:57.147]                           }
[10:29:57.147]                         }
[10:29:57.147]                       }
[10:29:57.147]                       invisible(muffled)
[10:29:57.147]                     }
[10:29:57.147]                     muffleCondition(cond, pattern = "^muffle")
[10:29:57.147]                   }
[10:29:57.147]                 }
[10:29:57.147]                 else {
[10:29:57.147]                   if (TRUE) {
[10:29:57.147]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.147]                     {
[10:29:57.147]                       inherits <- base::inherits
[10:29:57.147]                       invokeRestart <- base::invokeRestart
[10:29:57.147]                       is.null <- base::is.null
[10:29:57.147]                       muffled <- FALSE
[10:29:57.147]                       if (inherits(cond, "message")) {
[10:29:57.147]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:57.147]                         if (muffled) 
[10:29:57.147]                           invokeRestart("muffleMessage")
[10:29:57.147]                       }
[10:29:57.147]                       else if (inherits(cond, "warning")) {
[10:29:57.147]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:57.147]                         if (muffled) 
[10:29:57.147]                           invokeRestart("muffleWarning")
[10:29:57.147]                       }
[10:29:57.147]                       else if (inherits(cond, "condition")) {
[10:29:57.147]                         if (!is.null(pattern)) {
[10:29:57.147]                           computeRestarts <- base::computeRestarts
[10:29:57.147]                           grepl <- base::grepl
[10:29:57.147]                           restarts <- computeRestarts(cond)
[10:29:57.147]                           for (restart in restarts) {
[10:29:57.147]                             name <- restart$name
[10:29:57.147]                             if (is.null(name)) 
[10:29:57.147]                               next
[10:29:57.147]                             if (!grepl(pattern, name)) 
[10:29:57.147]                               next
[10:29:57.147]                             invokeRestart(restart)
[10:29:57.147]                             muffled <- TRUE
[10:29:57.147]                             break
[10:29:57.147]                           }
[10:29:57.147]                         }
[10:29:57.147]                       }
[10:29:57.147]                       invisible(muffled)
[10:29:57.147]                     }
[10:29:57.147]                     muffleCondition(cond, pattern = "^muffle")
[10:29:57.147]                   }
[10:29:57.147]                 }
[10:29:57.147]             }
[10:29:57.147]         }))
[10:29:57.147]     }, error = function(ex) {
[10:29:57.147]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:57.147]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:57.147]                 ...future.rng), started = ...future.startTime, 
[10:29:57.147]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:57.147]             version = "1.8"), class = "FutureResult")
[10:29:57.147]     }, finally = {
[10:29:57.147]         if (!identical(...future.workdir, getwd())) 
[10:29:57.147]             setwd(...future.workdir)
[10:29:57.147]         {
[10:29:57.147]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:57.147]                 ...future.oldOptions$nwarnings <- NULL
[10:29:57.147]             }
[10:29:57.147]             base::options(...future.oldOptions)
[10:29:57.147]             if (.Platform$OS.type == "windows") {
[10:29:57.147]                 old_names <- names(...future.oldEnvVars)
[10:29:57.147]                 envs <- base::Sys.getenv()
[10:29:57.147]                 names <- names(envs)
[10:29:57.147]                 common <- intersect(names, old_names)
[10:29:57.147]                 added <- setdiff(names, old_names)
[10:29:57.147]                 removed <- setdiff(old_names, names)
[10:29:57.147]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:57.147]                   envs[common]]
[10:29:57.147]                 NAMES <- toupper(changed)
[10:29:57.147]                 args <- list()
[10:29:57.147]                 for (kk in seq_along(NAMES)) {
[10:29:57.147]                   name <- changed[[kk]]
[10:29:57.147]                   NAME <- NAMES[[kk]]
[10:29:57.147]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.147]                     next
[10:29:57.147]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:57.147]                 }
[10:29:57.147]                 NAMES <- toupper(added)
[10:29:57.147]                 for (kk in seq_along(NAMES)) {
[10:29:57.147]                   name <- added[[kk]]
[10:29:57.147]                   NAME <- NAMES[[kk]]
[10:29:57.147]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.147]                     next
[10:29:57.147]                   args[[name]] <- ""
[10:29:57.147]                 }
[10:29:57.147]                 NAMES <- toupper(removed)
[10:29:57.147]                 for (kk in seq_along(NAMES)) {
[10:29:57.147]                   name <- removed[[kk]]
[10:29:57.147]                   NAME <- NAMES[[kk]]
[10:29:57.147]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.147]                     next
[10:29:57.147]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:57.147]                 }
[10:29:57.147]                 if (length(args) > 0) 
[10:29:57.147]                   base::do.call(base::Sys.setenv, args = args)
[10:29:57.147]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:57.147]             }
[10:29:57.147]             else {
[10:29:57.147]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:57.147]             }
[10:29:57.147]             {
[10:29:57.147]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:57.147]                   0L) {
[10:29:57.147]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:57.147]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:57.147]                   base::options(opts)
[10:29:57.147]                 }
[10:29:57.147]                 {
[10:29:57.147]                   {
[10:29:57.147]                     NULL
[10:29:57.147]                     RNGkind("Mersenne-Twister")
[10:29:57.147]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:29:57.147]                       inherits = FALSE)
[10:29:57.147]                   }
[10:29:57.147]                   options(future.plan = NULL)
[10:29:57.147]                   if (is.na(NA_character_)) 
[10:29:57.147]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:57.147]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:57.147]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:57.147]                     .init = FALSE)
[10:29:57.147]                 }
[10:29:57.147]             }
[10:29:57.147]         }
[10:29:57.147]     })
[10:29:57.147]     if (TRUE) {
[10:29:57.147]         base::sink(type = "output", split = FALSE)
[10:29:57.147]         if (TRUE) {
[10:29:57.147]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:57.147]         }
[10:29:57.147]         else {
[10:29:57.147]             ...future.result["stdout"] <- base::list(NULL)
[10:29:57.147]         }
[10:29:57.147]         base::close(...future.stdout)
[10:29:57.147]         ...future.stdout <- NULL
[10:29:57.147]     }
[10:29:57.147]     ...future.result$conditions <- ...future.conditions
[10:29:57.147]     ...future.result$finished <- base::Sys.time()
[10:29:57.147]     ...future.result
[10:29:57.147] }
[10:29:57.149] assign_globals() ...
[10:29:57.149] List of 5
[10:29:57.149]  $ ...future.FUN            :function (x, ...)  
[10:29:57.149]  $ future.call.arguments    : list()
[10:29:57.149]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.149]  $ ...future.elements_ii    :List of 3
[10:29:57.149]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[10:29:57.149]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:29:57.149]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:29:57.149]  $ ...future.seeds_ii       : NULL
[10:29:57.149]  $ ...future.globals.maxSize: NULL
[10:29:57.149]  - attr(*, "where")=List of 5
[10:29:57.149]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:57.149]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:57.149]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:57.149]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:57.149]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:57.149]  - attr(*, "resolved")= logi FALSE
[10:29:57.149]  - attr(*, "total_size")= num 1248
[10:29:57.149]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.149]  - attr(*, "already-done")= logi TRUE
[10:29:57.154] - copied ‘...future.FUN’ to environment
[10:29:57.154] - copied ‘future.call.arguments’ to environment
[10:29:57.155] - copied ‘...future.elements_ii’ to environment
[10:29:57.155] - copied ‘...future.seeds_ii’ to environment
[10:29:57.155] - copied ‘...future.globals.maxSize’ to environment
[10:29:57.155] assign_globals() ... done
[10:29:57.155] plan(): Setting new future strategy stack:
[10:29:57.155] List of future strategies:
[10:29:57.155] 1. sequential:
[10:29:57.155]    - args: function (..., envir = parent.frame())
[10:29:57.155]    - tweaked: FALSE
[10:29:57.155]    - call: NULL
[10:29:57.156] plan(): nbrOfWorkers() = 1
[10:29:57.157] plan(): Setting new future strategy stack:
[10:29:57.157] List of future strategies:
[10:29:57.157] 1. sequential:
[10:29:57.157]    - args: function (..., envir = parent.frame())
[10:29:57.157]    - tweaked: FALSE
[10:29:57.157]    - call: plan(strategy)
[10:29:57.157] plan(): nbrOfWorkers() = 1
[10:29:57.158] SequentialFuture started (and completed)
[10:29:57.158] - Launch lazy future ... done
[10:29:57.158] run() for ‘SequentialFuture’ ... done
[10:29:57.158] Created future:
[10:29:57.158] SequentialFuture:
[10:29:57.158] Label: ‘future_eapply-1’
[10:29:57.158] Expression:
[10:29:57.158] {
[10:29:57.158]     do.call(function(...) {
[10:29:57.158]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.158]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:57.158]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.158]             on.exit(options(oopts), add = TRUE)
[10:29:57.158]         }
[10:29:57.158]         {
[10:29:57.158]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:57.158]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.158]                 ...future.FUN(...future.X_jj, ...)
[10:29:57.158]             })
[10:29:57.158]         }
[10:29:57.158]     }, args = future.call.arguments)
[10:29:57.158] }
[10:29:57.158] Lazy evaluation: FALSE
[10:29:57.158] Asynchronous evaluation: FALSE
[10:29:57.158] Local evaluation: TRUE
[10:29:57.158] Environment: R_GlobalEnv
[10:29:57.158] Capture standard output: TRUE
[10:29:57.158] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:57.158] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:57.158] Packages: 1 packages (‘stats’)
[10:29:57.158] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:57.158] Resolved: TRUE
[10:29:57.158] Value: 1.71 KiB of class ‘list’
[10:29:57.158] Early signaling: FALSE
[10:29:57.158] Owner process: db6eb61b-64f1-ae95-7e8b-287fbc43411a
[10:29:57.158] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:29:57.159] Chunk #1 of 1 ... DONE
[10:29:57.159] Launching 1 futures (chunks) ... DONE
[10:29:57.159] Resolving 1 futures (chunks) ...
[10:29:57.159] resolve() on list ...
[10:29:57.159]  recursive: 0
[10:29:57.159]  length: 1
[10:29:57.159] 
[10:29:57.160] resolved() for ‘SequentialFuture’ ...
[10:29:57.160] - state: ‘finished’
[10:29:57.160] - run: TRUE
[10:29:57.160] - result: ‘FutureResult’
[10:29:57.160] resolved() for ‘SequentialFuture’ ... done
[10:29:57.160] Future #1
[10:29:57.160] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:29:57.160] - nx: 1
[10:29:57.160] - relay: TRUE
[10:29:57.160] - stdout: TRUE
[10:29:57.160] - signal: TRUE
[10:29:57.161] - resignal: FALSE
[10:29:57.162] - force: TRUE
[10:29:57.162] - relayed: [n=1] FALSE
[10:29:57.162] - queued futures: [n=1] FALSE
[10:29:57.162]  - until=1
[10:29:57.162]  - relaying element #1
[10:29:57.163] - relayed: [n=1] TRUE
[10:29:57.163] - queued futures: [n=1] TRUE
[10:29:57.163] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:29:57.163]  length: 0 (resolved future 1)
[10:29:57.163] Relaying remaining futures
[10:29:57.163] signalConditionsASAP(NULL, pos=0) ...
[10:29:57.163] - nx: 1
[10:29:57.163] - relay: TRUE
[10:29:57.163] - stdout: TRUE
[10:29:57.163] - signal: TRUE
[10:29:57.164] - resignal: FALSE
[10:29:57.164] - force: TRUE
[10:29:57.164] - relayed: [n=1] TRUE
[10:29:57.164] - queued futures: [n=1] TRUE
 - flush all
[10:29:57.164] - relayed: [n=1] TRUE
[10:29:57.164] - queued futures: [n=1] TRUE
[10:29:57.164] signalConditionsASAP(NULL, pos=0) ... done
[10:29:57.164] resolve() on list ... DONE
[10:29:57.164]  - Number of value chunks collected: 1
[10:29:57.164] Resolving 1 futures (chunks) ... DONE
[10:29:57.165] Reducing values from 1 chunks ...
[10:29:57.165]  - Number of values collected after concatenation: 3
[10:29:57.165]  - Number of values expected: 3
[10:29:57.165] Reducing values from 1 chunks ... DONE
[10:29:57.165] future_lapply() ... DONE
[10:29:57.165] plan(): Setting new future strategy stack:
[10:29:57.165] List of future strategies:
[10:29:57.165] 1. sequential:
[10:29:57.165]    - args: function (..., envir = parent.frame())
[10:29:57.165]    - tweaked: FALSE
[10:29:57.165]    - call: plan(sequential)
[10:29:57.166] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[10:29:57.166] plan(): Setting new future strategy stack:
[10:29:57.166] List of future strategies:
[10:29:57.166] 1. multicore:
[10:29:57.166]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:57.166]    - tweaked: FALSE
[10:29:57.166]    - call: plan(strategy)
[10:29:57.170] plan(): nbrOfWorkers() = 2
[10:29:57.170] future_lapply() ...
[10:29:57.175] Number of chunks: 2
[10:29:57.175] getGlobalsAndPackagesXApply() ...
[10:29:57.175]  - future.globals: TRUE
[10:29:57.175] getGlobalsAndPackages() ...
[10:29:57.175] Searching for globals...
[10:29:57.176] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:57.176] Searching for globals ... DONE
[10:29:57.176] Resolving globals: FALSE
[10:29:57.177] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:57.177] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:57.177] - globals: [1] ‘FUN’
[10:29:57.177] 
[10:29:57.177] getGlobalsAndPackages() ... DONE
[10:29:57.177]  - globals found/used: [n=1] ‘FUN’
[10:29:57.177]  - needed namespaces: [n=0] 
[10:29:57.178] Finding globals ... DONE
[10:29:57.178]  - use_args: TRUE
[10:29:57.178]  - Getting '...' globals ...
[10:29:57.178] resolve() on list ...
[10:29:57.178]  recursive: 0
[10:29:57.178]  length: 1
[10:29:57.178]  elements: ‘...’
[10:29:57.178]  length: 0 (resolved future 1)
[10:29:57.178] resolve() on list ... DONE
[10:29:57.179]    - '...' content: [n=0] 
[10:29:57.179] List of 1
[10:29:57.179]  $ ...: list()
[10:29:57.179]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.179]  - attr(*, "where")=List of 1
[10:29:57.179]   ..$ ...:<environment: 0x559749343d40> 
[10:29:57.179]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.179]  - attr(*, "resolved")= logi TRUE
[10:29:57.179]  - attr(*, "total_size")= num NA
[10:29:57.181]  - Getting '...' globals ... DONE
[10:29:57.181] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:57.181] List of 2
[10:29:57.181]  $ ...future.FUN:function (x, ...)  
[10:29:57.181]  $ ...          : list()
[10:29:57.181]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.181]  - attr(*, "where")=List of 2
[10:29:57.181]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:57.181]   ..$ ...          :<environment: 0x559749343d40> 
[10:29:57.181]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.181]  - attr(*, "resolved")= logi FALSE
[10:29:57.181]  - attr(*, "total_size")= num 1240
[10:29:57.184] Packages to be attached in all futures: [n=0] 
[10:29:57.184] getGlobalsAndPackagesXApply() ... DONE
[10:29:57.184] Number of futures (= number of chunks): 2
[10:29:57.184] Launching 2 futures (chunks) ...
[10:29:57.184] Chunk #1 of 2 ...
[10:29:57.185]  - Finding globals in 'X' for chunk #1 ...
[10:29:57.185] getGlobalsAndPackages() ...
[10:29:57.185] Searching for globals...
[10:29:57.185] 
[10:29:57.185] Searching for globals ... DONE
[10:29:57.185] - globals: [0] <none>
[10:29:57.185] getGlobalsAndPackages() ... DONE
[10:29:57.185]    + additional globals found: [n=0] 
[10:29:57.186]    + additional namespaces needed: [n=0] 
[10:29:57.186]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:57.186]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:57.186]  - seeds: <none>
[10:29:57.186]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.186] getGlobalsAndPackages() ...
[10:29:57.186] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.186] Resolving globals: FALSE
[10:29:57.186] Tweak future expression to call with '...' arguments ...
[10:29:57.186] {
[10:29:57.186]     do.call(function(...) {
[10:29:57.186]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.186]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:57.186]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.186]             on.exit(options(oopts), add = TRUE)
[10:29:57.186]         }
[10:29:57.186]         {
[10:29:57.186]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:57.186]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.186]                 ...future.FUN(...future.X_jj, ...)
[10:29:57.186]             })
[10:29:57.186]         }
[10:29:57.186]     }, args = future.call.arguments)
[10:29:57.186] }
[10:29:57.187] Tweak future expression to call with '...' arguments ... DONE
[10:29:57.187] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.187] 
[10:29:57.187] getGlobalsAndPackages() ... DONE
[10:29:57.187] run() for ‘Future’ ...
[10:29:57.188] - state: ‘created’
[10:29:57.188] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:57.193] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:57.193] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:57.194]   - Field: ‘label’
[10:29:57.194]   - Field: ‘local’
[10:29:57.194]   - Field: ‘owner’
[10:29:57.194]   - Field: ‘envir’
[10:29:57.194]   - Field: ‘workers’
[10:29:57.194]   - Field: ‘packages’
[10:29:57.194]   - Field: ‘gc’
[10:29:57.194]   - Field: ‘job’
[10:29:57.194]   - Field: ‘conditions’
[10:29:57.194]   - Field: ‘expr’
[10:29:57.195]   - Field: ‘uuid’
[10:29:57.195]   - Field: ‘seed’
[10:29:57.195]   - Field: ‘version’
[10:29:57.195]   - Field: ‘result’
[10:29:57.195]   - Field: ‘asynchronous’
[10:29:57.195]   - Field: ‘calls’
[10:29:57.195]   - Field: ‘globals’
[10:29:57.195]   - Field: ‘stdout’
[10:29:57.195]   - Field: ‘earlySignal’
[10:29:57.195]   - Field: ‘lazy’
[10:29:57.195]   - Field: ‘state’
[10:29:57.196] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:57.196] - Launch lazy future ...
[10:29:57.197] Packages needed by the future expression (n = 0): <none>
[10:29:57.197] Packages needed by future strategies (n = 0): <none>
[10:29:57.197] {
[10:29:57.197]     {
[10:29:57.197]         {
[10:29:57.197]             ...future.startTime <- base::Sys.time()
[10:29:57.197]             {
[10:29:57.197]                 {
[10:29:57.197]                   {
[10:29:57.197]                     {
[10:29:57.197]                       base::local({
[10:29:57.197]                         has_future <- base::requireNamespace("future", 
[10:29:57.197]                           quietly = TRUE)
[10:29:57.197]                         if (has_future) {
[10:29:57.197]                           ns <- base::getNamespace("future")
[10:29:57.197]                           version <- ns[[".package"]][["version"]]
[10:29:57.197]                           if (is.null(version)) 
[10:29:57.197]                             version <- utils::packageVersion("future")
[10:29:57.197]                         }
[10:29:57.197]                         else {
[10:29:57.197]                           version <- NULL
[10:29:57.197]                         }
[10:29:57.197]                         if (!has_future || version < "1.8.0") {
[10:29:57.197]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:57.197]                             "", base::R.version$version.string), 
[10:29:57.197]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:57.197]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:57.197]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:57.197]                               "release", "version")], collapse = " "), 
[10:29:57.197]                             hostname = base::Sys.info()[["nodename"]])
[10:29:57.197]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:57.197]                             info)
[10:29:57.197]                           info <- base::paste(info, collapse = "; ")
[10:29:57.197]                           if (!has_future) {
[10:29:57.197]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:57.197]                               info)
[10:29:57.197]                           }
[10:29:57.197]                           else {
[10:29:57.197]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:57.197]                               info, version)
[10:29:57.197]                           }
[10:29:57.197]                           base::stop(msg)
[10:29:57.197]                         }
[10:29:57.197]                       })
[10:29:57.197]                     }
[10:29:57.197]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:57.197]                     base::options(mc.cores = 1L)
[10:29:57.197]                   }
[10:29:57.197]                   ...future.strategy.old <- future::plan("list")
[10:29:57.197]                   options(future.plan = NULL)
[10:29:57.197]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:57.197]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:57.197]                 }
[10:29:57.197]                 ...future.workdir <- getwd()
[10:29:57.197]             }
[10:29:57.197]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:57.197]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:57.197]         }
[10:29:57.197]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:57.197]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:57.197]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:57.197]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:57.197]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:57.197]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:57.197]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:57.197]             base::names(...future.oldOptions))
[10:29:57.197]     }
[10:29:57.197]     if (FALSE) {
[10:29:57.197]     }
[10:29:57.197]     else {
[10:29:57.197]         if (TRUE) {
[10:29:57.197]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:57.197]                 open = "w")
[10:29:57.197]         }
[10:29:57.197]         else {
[10:29:57.197]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:57.197]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:57.197]         }
[10:29:57.197]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:57.197]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:57.197]             base::sink(type = "output", split = FALSE)
[10:29:57.197]             base::close(...future.stdout)
[10:29:57.197]         }, add = TRUE)
[10:29:57.197]     }
[10:29:57.197]     ...future.frame <- base::sys.nframe()
[10:29:57.197]     ...future.conditions <- base::list()
[10:29:57.197]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:57.197]     if (FALSE) {
[10:29:57.197]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:57.197]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:57.197]     }
[10:29:57.197]     ...future.result <- base::tryCatch({
[10:29:57.197]         base::withCallingHandlers({
[10:29:57.197]             ...future.value <- base::withVisible(base::local({
[10:29:57.197]                 withCallingHandlers({
[10:29:57.197]                   {
[10:29:57.197]                     do.call(function(...) {
[10:29:57.197]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.197]                       if (!identical(...future.globals.maxSize.org, 
[10:29:57.197]                         ...future.globals.maxSize)) {
[10:29:57.197]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.197]                         on.exit(options(oopts), add = TRUE)
[10:29:57.197]                       }
[10:29:57.197]                       {
[10:29:57.197]                         lapply(seq_along(...future.elements_ii), 
[10:29:57.197]                           FUN = function(jj) {
[10:29:57.197]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.197]                             ...future.FUN(...future.X_jj, ...)
[10:29:57.197]                           })
[10:29:57.197]                       }
[10:29:57.197]                     }, args = future.call.arguments)
[10:29:57.197]                   }
[10:29:57.197]                 }, immediateCondition = function(cond) {
[10:29:57.197]                   save_rds <- function (object, pathname, ...) 
[10:29:57.197]                   {
[10:29:57.197]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:57.197]                     if (file_test("-f", pathname_tmp)) {
[10:29:57.197]                       fi_tmp <- file.info(pathname_tmp)
[10:29:57.197]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:57.197]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:57.197]                         fi_tmp[["mtime"]])
[10:29:57.197]                     }
[10:29:57.197]                     tryCatch({
[10:29:57.197]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:57.197]                     }, error = function(ex) {
[10:29:57.197]                       msg <- conditionMessage(ex)
[10:29:57.197]                       fi_tmp <- file.info(pathname_tmp)
[10:29:57.197]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:57.197]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:57.197]                         fi_tmp[["mtime"]], msg)
[10:29:57.197]                       ex$message <- msg
[10:29:57.197]                       stop(ex)
[10:29:57.197]                     })
[10:29:57.197]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:57.197]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:57.197]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:57.197]                       fi_tmp <- file.info(pathname_tmp)
[10:29:57.197]                       fi <- file.info(pathname)
[10:29:57.197]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:57.197]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:57.197]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:57.197]                         fi[["size"]], fi[["mtime"]])
[10:29:57.197]                       stop(msg)
[10:29:57.197]                     }
[10:29:57.197]                     invisible(pathname)
[10:29:57.197]                   }
[10:29:57.197]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:57.197]                     rootPath = tempdir()) 
[10:29:57.197]                   {
[10:29:57.197]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:57.197]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:57.197]                       tmpdir = path, fileext = ".rds")
[10:29:57.197]                     save_rds(obj, file)
[10:29:57.197]                   }
[10:29:57.197]                   saveImmediateCondition(cond, path = "/tmp/RtmpoCSmtD/.future/immediateConditions")
[10:29:57.197]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.197]                   {
[10:29:57.197]                     inherits <- base::inherits
[10:29:57.197]                     invokeRestart <- base::invokeRestart
[10:29:57.197]                     is.null <- base::is.null
[10:29:57.197]                     muffled <- FALSE
[10:29:57.197]                     if (inherits(cond, "message")) {
[10:29:57.197]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:57.197]                       if (muffled) 
[10:29:57.197]                         invokeRestart("muffleMessage")
[10:29:57.197]                     }
[10:29:57.197]                     else if (inherits(cond, "warning")) {
[10:29:57.197]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:57.197]                       if (muffled) 
[10:29:57.197]                         invokeRestart("muffleWarning")
[10:29:57.197]                     }
[10:29:57.197]                     else if (inherits(cond, "condition")) {
[10:29:57.197]                       if (!is.null(pattern)) {
[10:29:57.197]                         computeRestarts <- base::computeRestarts
[10:29:57.197]                         grepl <- base::grepl
[10:29:57.197]                         restarts <- computeRestarts(cond)
[10:29:57.197]                         for (restart in restarts) {
[10:29:57.197]                           name <- restart$name
[10:29:57.197]                           if (is.null(name)) 
[10:29:57.197]                             next
[10:29:57.197]                           if (!grepl(pattern, name)) 
[10:29:57.197]                             next
[10:29:57.197]                           invokeRestart(restart)
[10:29:57.197]                           muffled <- TRUE
[10:29:57.197]                           break
[10:29:57.197]                         }
[10:29:57.197]                       }
[10:29:57.197]                     }
[10:29:57.197]                     invisible(muffled)
[10:29:57.197]                   }
[10:29:57.197]                   muffleCondition(cond)
[10:29:57.197]                 })
[10:29:57.197]             }))
[10:29:57.197]             future::FutureResult(value = ...future.value$value, 
[10:29:57.197]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:57.197]                   ...future.rng), globalenv = if (FALSE) 
[10:29:57.197]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:57.197]                     ...future.globalenv.names))
[10:29:57.197]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:57.197]         }, condition = base::local({
[10:29:57.197]             c <- base::c
[10:29:57.197]             inherits <- base::inherits
[10:29:57.197]             invokeRestart <- base::invokeRestart
[10:29:57.197]             length <- base::length
[10:29:57.197]             list <- base::list
[10:29:57.197]             seq.int <- base::seq.int
[10:29:57.197]             signalCondition <- base::signalCondition
[10:29:57.197]             sys.calls <- base::sys.calls
[10:29:57.197]             `[[` <- base::`[[`
[10:29:57.197]             `+` <- base::`+`
[10:29:57.197]             `<<-` <- base::`<<-`
[10:29:57.197]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:57.197]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:57.197]                   3L)]
[10:29:57.197]             }
[10:29:57.197]             function(cond) {
[10:29:57.197]                 is_error <- inherits(cond, "error")
[10:29:57.197]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:57.197]                   NULL)
[10:29:57.197]                 if (is_error) {
[10:29:57.197]                   sessionInformation <- function() {
[10:29:57.197]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:57.197]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:57.197]                       search = base::search(), system = base::Sys.info())
[10:29:57.197]                   }
[10:29:57.197]                   ...future.conditions[[length(...future.conditions) + 
[10:29:57.197]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:57.197]                     cond$call), session = sessionInformation(), 
[10:29:57.197]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:57.197]                   signalCondition(cond)
[10:29:57.197]                 }
[10:29:57.197]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:57.197]                 "immediateCondition"))) {
[10:29:57.197]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:57.197]                   ...future.conditions[[length(...future.conditions) + 
[10:29:57.197]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:57.197]                   if (TRUE && !signal) {
[10:29:57.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.197]                     {
[10:29:57.197]                       inherits <- base::inherits
[10:29:57.197]                       invokeRestart <- base::invokeRestart
[10:29:57.197]                       is.null <- base::is.null
[10:29:57.197]                       muffled <- FALSE
[10:29:57.197]                       if (inherits(cond, "message")) {
[10:29:57.197]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:57.197]                         if (muffled) 
[10:29:57.197]                           invokeRestart("muffleMessage")
[10:29:57.197]                       }
[10:29:57.197]                       else if (inherits(cond, "warning")) {
[10:29:57.197]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:57.197]                         if (muffled) 
[10:29:57.197]                           invokeRestart("muffleWarning")
[10:29:57.197]                       }
[10:29:57.197]                       else if (inherits(cond, "condition")) {
[10:29:57.197]                         if (!is.null(pattern)) {
[10:29:57.197]                           computeRestarts <- base::computeRestarts
[10:29:57.197]                           grepl <- base::grepl
[10:29:57.197]                           restarts <- computeRestarts(cond)
[10:29:57.197]                           for (restart in restarts) {
[10:29:57.197]                             name <- restart$name
[10:29:57.197]                             if (is.null(name)) 
[10:29:57.197]                               next
[10:29:57.197]                             if (!grepl(pattern, name)) 
[10:29:57.197]                               next
[10:29:57.197]                             invokeRestart(restart)
[10:29:57.197]                             muffled <- TRUE
[10:29:57.197]                             break
[10:29:57.197]                           }
[10:29:57.197]                         }
[10:29:57.197]                       }
[10:29:57.197]                       invisible(muffled)
[10:29:57.197]                     }
[10:29:57.197]                     muffleCondition(cond, pattern = "^muffle")
[10:29:57.197]                   }
[10:29:57.197]                 }
[10:29:57.197]                 else {
[10:29:57.197]                   if (TRUE) {
[10:29:57.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.197]                     {
[10:29:57.197]                       inherits <- base::inherits
[10:29:57.197]                       invokeRestart <- base::invokeRestart
[10:29:57.197]                       is.null <- base::is.null
[10:29:57.197]                       muffled <- FALSE
[10:29:57.197]                       if (inherits(cond, "message")) {
[10:29:57.197]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:57.197]                         if (muffled) 
[10:29:57.197]                           invokeRestart("muffleMessage")
[10:29:57.197]                       }
[10:29:57.197]                       else if (inherits(cond, "warning")) {
[10:29:57.197]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:57.197]                         if (muffled) 
[10:29:57.197]                           invokeRestart("muffleWarning")
[10:29:57.197]                       }
[10:29:57.197]                       else if (inherits(cond, "condition")) {
[10:29:57.197]                         if (!is.null(pattern)) {
[10:29:57.197]                           computeRestarts <- base::computeRestarts
[10:29:57.197]                           grepl <- base::grepl
[10:29:57.197]                           restarts <- computeRestarts(cond)
[10:29:57.197]                           for (restart in restarts) {
[10:29:57.197]                             name <- restart$name
[10:29:57.197]                             if (is.null(name)) 
[10:29:57.197]                               next
[10:29:57.197]                             if (!grepl(pattern, name)) 
[10:29:57.197]                               next
[10:29:57.197]                             invokeRestart(restart)
[10:29:57.197]                             muffled <- TRUE
[10:29:57.197]                             break
[10:29:57.197]                           }
[10:29:57.197]                         }
[10:29:57.197]                       }
[10:29:57.197]                       invisible(muffled)
[10:29:57.197]                     }
[10:29:57.197]                     muffleCondition(cond, pattern = "^muffle")
[10:29:57.197]                   }
[10:29:57.197]                 }
[10:29:57.197]             }
[10:29:57.197]         }))
[10:29:57.197]     }, error = function(ex) {
[10:29:57.197]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:57.197]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:57.197]                 ...future.rng), started = ...future.startTime, 
[10:29:57.197]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:57.197]             version = "1.8"), class = "FutureResult")
[10:29:57.197]     }, finally = {
[10:29:57.197]         if (!identical(...future.workdir, getwd())) 
[10:29:57.197]             setwd(...future.workdir)
[10:29:57.197]         {
[10:29:57.197]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:57.197]                 ...future.oldOptions$nwarnings <- NULL
[10:29:57.197]             }
[10:29:57.197]             base::options(...future.oldOptions)
[10:29:57.197]             if (.Platform$OS.type == "windows") {
[10:29:57.197]                 old_names <- names(...future.oldEnvVars)
[10:29:57.197]                 envs <- base::Sys.getenv()
[10:29:57.197]                 names <- names(envs)
[10:29:57.197]                 common <- intersect(names, old_names)
[10:29:57.197]                 added <- setdiff(names, old_names)
[10:29:57.197]                 removed <- setdiff(old_names, names)
[10:29:57.197]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:57.197]                   envs[common]]
[10:29:57.197]                 NAMES <- toupper(changed)
[10:29:57.197]                 args <- list()
[10:29:57.197]                 for (kk in seq_along(NAMES)) {
[10:29:57.197]                   name <- changed[[kk]]
[10:29:57.197]                   NAME <- NAMES[[kk]]
[10:29:57.197]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.197]                     next
[10:29:57.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:57.197]                 }
[10:29:57.197]                 NAMES <- toupper(added)
[10:29:57.197]                 for (kk in seq_along(NAMES)) {
[10:29:57.197]                   name <- added[[kk]]
[10:29:57.197]                   NAME <- NAMES[[kk]]
[10:29:57.197]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.197]                     next
[10:29:57.197]                   args[[name]] <- ""
[10:29:57.197]                 }
[10:29:57.197]                 NAMES <- toupper(removed)
[10:29:57.197]                 for (kk in seq_along(NAMES)) {
[10:29:57.197]                   name <- removed[[kk]]
[10:29:57.197]                   NAME <- NAMES[[kk]]
[10:29:57.197]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.197]                     next
[10:29:57.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:57.197]                 }
[10:29:57.197]                 if (length(args) > 0) 
[10:29:57.197]                   base::do.call(base::Sys.setenv, args = args)
[10:29:57.197]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:57.197]             }
[10:29:57.197]             else {
[10:29:57.197]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:57.197]             }
[10:29:57.197]             {
[10:29:57.197]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:57.197]                   0L) {
[10:29:57.197]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:57.197]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:57.197]                   base::options(opts)
[10:29:57.197]                 }
[10:29:57.197]                 {
[10:29:57.197]                   {
[10:29:57.197]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:57.197]                     NULL
[10:29:57.197]                   }
[10:29:57.197]                   options(future.plan = NULL)
[10:29:57.197]                   if (is.na(NA_character_)) 
[10:29:57.197]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:57.197]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:57.197]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:57.197]                     .init = FALSE)
[10:29:57.197]                 }
[10:29:57.197]             }
[10:29:57.197]         }
[10:29:57.197]     })
[10:29:57.197]     if (TRUE) {
[10:29:57.197]         base::sink(type = "output", split = FALSE)
[10:29:57.197]         if (TRUE) {
[10:29:57.197]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:57.197]         }
[10:29:57.197]         else {
[10:29:57.197]             ...future.result["stdout"] <- base::list(NULL)
[10:29:57.197]         }
[10:29:57.197]         base::close(...future.stdout)
[10:29:57.197]         ...future.stdout <- NULL
[10:29:57.197]     }
[10:29:57.197]     ...future.result$conditions <- ...future.conditions
[10:29:57.197]     ...future.result$finished <- base::Sys.time()
[10:29:57.197]     ...future.result
[10:29:57.197] }
[10:29:57.200] assign_globals() ...
[10:29:57.200] List of 5
[10:29:57.200]  $ ...future.FUN            :function (x, ...)  
[10:29:57.200]  $ future.call.arguments    : list()
[10:29:57.200]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.200]  $ ...future.elements_ii    :List of 1
[10:29:57.200]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[10:29:57.200]  $ ...future.seeds_ii       : NULL
[10:29:57.200]  $ ...future.globals.maxSize: NULL
[10:29:57.200]  - attr(*, "where")=List of 5
[10:29:57.200]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:57.200]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:57.200]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:57.200]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:57.200]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:57.200]  - attr(*, "resolved")= logi FALSE
[10:29:57.200]  - attr(*, "total_size")= num 1240
[10:29:57.200]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.200]  - attr(*, "already-done")= logi TRUE
[10:29:57.205] - copied ‘...future.FUN’ to environment
[10:29:57.205] - copied ‘future.call.arguments’ to environment
[10:29:57.205] - copied ‘...future.elements_ii’ to environment
[10:29:57.205] - copied ‘...future.seeds_ii’ to environment
[10:29:57.205] - copied ‘...future.globals.maxSize’ to environment
[10:29:57.205] assign_globals() ... done
[10:29:57.205] requestCore(): workers = 2
[10:29:57.208] MulticoreFuture started
[10:29:57.209] - Launch lazy future ... done
[10:29:57.209] run() for ‘MulticoreFuture’ ... done
[10:29:57.209] plan(): Setting new future strategy stack:
[10:29:57.209] Created future:
[10:29:57.209] List of future strategies:
[10:29:57.209] 1. sequential:
[10:29:57.209]    - args: function (..., envir = parent.frame())
[10:29:57.209]    - tweaked: FALSE
[10:29:57.209]    - call: NULL
[10:29:57.210] plan(): nbrOfWorkers() = 1
[10:29:57.212] plan(): Setting new future strategy stack:
[10:29:57.212] List of future strategies:
[10:29:57.212] 1. multicore:
[10:29:57.212]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:57.212]    - tweaked: FALSE
[10:29:57.212]    - call: plan(strategy)
[10:29:57.218] plan(): nbrOfWorkers() = 2
[10:29:57.210] MulticoreFuture:
[10:29:57.210] Label: ‘future_eapply-1’
[10:29:57.210] Expression:
[10:29:57.210] {
[10:29:57.210]     do.call(function(...) {
[10:29:57.210]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.210]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:57.210]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.210]             on.exit(options(oopts), add = TRUE)
[10:29:57.210]         }
[10:29:57.210]         {
[10:29:57.210]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:57.210]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.210]                 ...future.FUN(...future.X_jj, ...)
[10:29:57.210]             })
[10:29:57.210]         }
[10:29:57.210]     }, args = future.call.arguments)
[10:29:57.210] }
[10:29:57.210] Lazy evaluation: FALSE
[10:29:57.210] Asynchronous evaluation: TRUE
[10:29:57.210] Local evaluation: TRUE
[10:29:57.210] Environment: R_GlobalEnv
[10:29:57.210] Capture standard output: TRUE
[10:29:57.210] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:57.210] Globals: 5 objects totaling 1.27 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:57.210] Packages: <none>
[10:29:57.210] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:57.210] Resolved: TRUE
[10:29:57.210] Value: <not collected>
[10:29:57.210] Conditions captured: <none>
[10:29:57.210] Early signaling: FALSE
[10:29:57.210] Owner process: db6eb61b-64f1-ae95-7e8b-287fbc43411a
[10:29:57.210] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:57.219] Chunk #1 of 2 ... DONE
[10:29:57.219] Chunk #2 of 2 ...
[10:29:57.219]  - Finding globals in 'X' for chunk #2 ...
[10:29:57.219] getGlobalsAndPackages() ...
[10:29:57.219] Searching for globals...
[10:29:57.220] 
[10:29:57.220] Searching for globals ... DONE
[10:29:57.220] - globals: [0] <none>
[10:29:57.220] getGlobalsAndPackages() ... DONE
[10:29:57.220]    + additional globals found: [n=0] 
[10:29:57.221]    + additional namespaces needed: [n=0] 
[10:29:57.221]  - Finding globals in 'X' for chunk #2 ... DONE
[10:29:57.221]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:57.221]  - seeds: <none>
[10:29:57.221]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.221] getGlobalsAndPackages() ...
[10:29:57.222] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.222] Resolving globals: FALSE
[10:29:57.222] Tweak future expression to call with '...' arguments ...
[10:29:57.222] {
[10:29:57.222]     do.call(function(...) {
[10:29:57.222]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.222]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:57.222]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.222]             on.exit(options(oopts), add = TRUE)
[10:29:57.222]         }
[10:29:57.222]         {
[10:29:57.222]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:57.222]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.222]                 ...future.FUN(...future.X_jj, ...)
[10:29:57.222]             })
[10:29:57.222]         }
[10:29:57.222]     }, args = future.call.arguments)
[10:29:57.222] }
[10:29:57.222] Tweak future expression to call with '...' arguments ... DONE
[10:29:57.223] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.223] 
[10:29:57.223] getGlobalsAndPackages() ... DONE
[10:29:57.224] run() for ‘Future’ ...
[10:29:57.224] - state: ‘created’
[10:29:57.224] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:57.228] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:57.229] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:57.229]   - Field: ‘label’
[10:29:57.229]   - Field: ‘local’
[10:29:57.229]   - Field: ‘owner’
[10:29:57.229]   - Field: ‘envir’
[10:29:57.229]   - Field: ‘workers’
[10:29:57.230]   - Field: ‘packages’
[10:29:57.230]   - Field: ‘gc’
[10:29:57.230]   - Field: ‘job’
[10:29:57.230]   - Field: ‘conditions’
[10:29:57.230]   - Field: ‘expr’
[10:29:57.230]   - Field: ‘uuid’
[10:29:57.230]   - Field: ‘seed’
[10:29:57.230]   - Field: ‘version’
[10:29:57.231]   - Field: ‘result’
[10:29:57.231]   - Field: ‘asynchronous’
[10:29:57.231]   - Field: ‘calls’
[10:29:57.231]   - Field: ‘globals’
[10:29:57.231]   - Field: ‘stdout’
[10:29:57.231]   - Field: ‘earlySignal’
[10:29:57.231]   - Field: ‘lazy’
[10:29:57.231]   - Field: ‘state’
[10:29:57.232] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:57.232] - Launch lazy future ...
[10:29:57.232] Packages needed by the future expression (n = 0): <none>
[10:29:57.232] Packages needed by future strategies (n = 0): <none>
[10:29:57.233] {
[10:29:57.233]     {
[10:29:57.233]         {
[10:29:57.233]             ...future.startTime <- base::Sys.time()
[10:29:57.233]             {
[10:29:57.233]                 {
[10:29:57.233]                   {
[10:29:57.233]                     {
[10:29:57.233]                       base::local({
[10:29:57.233]                         has_future <- base::requireNamespace("future", 
[10:29:57.233]                           quietly = TRUE)
[10:29:57.233]                         if (has_future) {
[10:29:57.233]                           ns <- base::getNamespace("future")
[10:29:57.233]                           version <- ns[[".package"]][["version"]]
[10:29:57.233]                           if (is.null(version)) 
[10:29:57.233]                             version <- utils::packageVersion("future")
[10:29:57.233]                         }
[10:29:57.233]                         else {
[10:29:57.233]                           version <- NULL
[10:29:57.233]                         }
[10:29:57.233]                         if (!has_future || version < "1.8.0") {
[10:29:57.233]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:57.233]                             "", base::R.version$version.string), 
[10:29:57.233]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:57.233]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:57.233]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:57.233]                               "release", "version")], collapse = " "), 
[10:29:57.233]                             hostname = base::Sys.info()[["nodename"]])
[10:29:57.233]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:57.233]                             info)
[10:29:57.233]                           info <- base::paste(info, collapse = "; ")
[10:29:57.233]                           if (!has_future) {
[10:29:57.233]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:57.233]                               info)
[10:29:57.233]                           }
[10:29:57.233]                           else {
[10:29:57.233]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:57.233]                               info, version)
[10:29:57.233]                           }
[10:29:57.233]                           base::stop(msg)
[10:29:57.233]                         }
[10:29:57.233]                       })
[10:29:57.233]                     }
[10:29:57.233]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:57.233]                     base::options(mc.cores = 1L)
[10:29:57.233]                   }
[10:29:57.233]                   ...future.strategy.old <- future::plan("list")
[10:29:57.233]                   options(future.plan = NULL)
[10:29:57.233]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:57.233]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:57.233]                 }
[10:29:57.233]                 ...future.workdir <- getwd()
[10:29:57.233]             }
[10:29:57.233]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:57.233]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:57.233]         }
[10:29:57.233]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:57.233]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:57.233]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:57.233]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:57.233]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:57.233]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:57.233]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:57.233]             base::names(...future.oldOptions))
[10:29:57.233]     }
[10:29:57.233]     if (FALSE) {
[10:29:57.233]     }
[10:29:57.233]     else {
[10:29:57.233]         if (TRUE) {
[10:29:57.233]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:57.233]                 open = "w")
[10:29:57.233]         }
[10:29:57.233]         else {
[10:29:57.233]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:57.233]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:57.233]         }
[10:29:57.233]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:57.233]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:57.233]             base::sink(type = "output", split = FALSE)
[10:29:57.233]             base::close(...future.stdout)
[10:29:57.233]         }, add = TRUE)
[10:29:57.233]     }
[10:29:57.233]     ...future.frame <- base::sys.nframe()
[10:29:57.233]     ...future.conditions <- base::list()
[10:29:57.233]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:57.233]     if (FALSE) {
[10:29:57.233]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:57.233]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:57.233]     }
[10:29:57.233]     ...future.result <- base::tryCatch({
[10:29:57.233]         base::withCallingHandlers({
[10:29:57.233]             ...future.value <- base::withVisible(base::local({
[10:29:57.233]                 withCallingHandlers({
[10:29:57.233]                   {
[10:29:57.233]                     do.call(function(...) {
[10:29:57.233]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.233]                       if (!identical(...future.globals.maxSize.org, 
[10:29:57.233]                         ...future.globals.maxSize)) {
[10:29:57.233]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.233]                         on.exit(options(oopts), add = TRUE)
[10:29:57.233]                       }
[10:29:57.233]                       {
[10:29:57.233]                         lapply(seq_along(...future.elements_ii), 
[10:29:57.233]                           FUN = function(jj) {
[10:29:57.233]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.233]                             ...future.FUN(...future.X_jj, ...)
[10:29:57.233]                           })
[10:29:57.233]                       }
[10:29:57.233]                     }, args = future.call.arguments)
[10:29:57.233]                   }
[10:29:57.233]                 }, immediateCondition = function(cond) {
[10:29:57.233]                   save_rds <- function (object, pathname, ...) 
[10:29:57.233]                   {
[10:29:57.233]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:57.233]                     if (file_test("-f", pathname_tmp)) {
[10:29:57.233]                       fi_tmp <- file.info(pathname_tmp)
[10:29:57.233]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:57.233]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:57.233]                         fi_tmp[["mtime"]])
[10:29:57.233]                     }
[10:29:57.233]                     tryCatch({
[10:29:57.233]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:57.233]                     }, error = function(ex) {
[10:29:57.233]                       msg <- conditionMessage(ex)
[10:29:57.233]                       fi_tmp <- file.info(pathname_tmp)
[10:29:57.233]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:57.233]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:57.233]                         fi_tmp[["mtime"]], msg)
[10:29:57.233]                       ex$message <- msg
[10:29:57.233]                       stop(ex)
[10:29:57.233]                     })
[10:29:57.233]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:57.233]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:57.233]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:57.233]                       fi_tmp <- file.info(pathname_tmp)
[10:29:57.233]                       fi <- file.info(pathname)
[10:29:57.233]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:57.233]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:57.233]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:57.233]                         fi[["size"]], fi[["mtime"]])
[10:29:57.233]                       stop(msg)
[10:29:57.233]                     }
[10:29:57.233]                     invisible(pathname)
[10:29:57.233]                   }
[10:29:57.233]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:57.233]                     rootPath = tempdir()) 
[10:29:57.233]                   {
[10:29:57.233]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:57.233]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:57.233]                       tmpdir = path, fileext = ".rds")
[10:29:57.233]                     save_rds(obj, file)
[10:29:57.233]                   }
[10:29:57.233]                   saveImmediateCondition(cond, path = "/tmp/RtmpoCSmtD/.future/immediateConditions")
[10:29:57.233]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.233]                   {
[10:29:57.233]                     inherits <- base::inherits
[10:29:57.233]                     invokeRestart <- base::invokeRestart
[10:29:57.233]                     is.null <- base::is.null
[10:29:57.233]                     muffled <- FALSE
[10:29:57.233]                     if (inherits(cond, "message")) {
[10:29:57.233]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:57.233]                       if (muffled) 
[10:29:57.233]                         invokeRestart("muffleMessage")
[10:29:57.233]                     }
[10:29:57.233]                     else if (inherits(cond, "warning")) {
[10:29:57.233]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:57.233]                       if (muffled) 
[10:29:57.233]                         invokeRestart("muffleWarning")
[10:29:57.233]                     }
[10:29:57.233]                     else if (inherits(cond, "condition")) {
[10:29:57.233]                       if (!is.null(pattern)) {
[10:29:57.233]                         computeRestarts <- base::computeRestarts
[10:29:57.233]                         grepl <- base::grepl
[10:29:57.233]                         restarts <- computeRestarts(cond)
[10:29:57.233]                         for (restart in restarts) {
[10:29:57.233]                           name <- restart$name
[10:29:57.233]                           if (is.null(name)) 
[10:29:57.233]                             next
[10:29:57.233]                           if (!grepl(pattern, name)) 
[10:29:57.233]                             next
[10:29:57.233]                           invokeRestart(restart)
[10:29:57.233]                           muffled <- TRUE
[10:29:57.233]                           break
[10:29:57.233]                         }
[10:29:57.233]                       }
[10:29:57.233]                     }
[10:29:57.233]                     invisible(muffled)
[10:29:57.233]                   }
[10:29:57.233]                   muffleCondition(cond)
[10:29:57.233]                 })
[10:29:57.233]             }))
[10:29:57.233]             future::FutureResult(value = ...future.value$value, 
[10:29:57.233]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:57.233]                   ...future.rng), globalenv = if (FALSE) 
[10:29:57.233]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:57.233]                     ...future.globalenv.names))
[10:29:57.233]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:57.233]         }, condition = base::local({
[10:29:57.233]             c <- base::c
[10:29:57.233]             inherits <- base::inherits
[10:29:57.233]             invokeRestart <- base::invokeRestart
[10:29:57.233]             length <- base::length
[10:29:57.233]             list <- base::list
[10:29:57.233]             seq.int <- base::seq.int
[10:29:57.233]             signalCondition <- base::signalCondition
[10:29:57.233]             sys.calls <- base::sys.calls
[10:29:57.233]             `[[` <- base::`[[`
[10:29:57.233]             `+` <- base::`+`
[10:29:57.233]             `<<-` <- base::`<<-`
[10:29:57.233]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:57.233]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:57.233]                   3L)]
[10:29:57.233]             }
[10:29:57.233]             function(cond) {
[10:29:57.233]                 is_error <- inherits(cond, "error")
[10:29:57.233]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:57.233]                   NULL)
[10:29:57.233]                 if (is_error) {
[10:29:57.233]                   sessionInformation <- function() {
[10:29:57.233]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:57.233]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:57.233]                       search = base::search(), system = base::Sys.info())
[10:29:57.233]                   }
[10:29:57.233]                   ...future.conditions[[length(...future.conditions) + 
[10:29:57.233]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:57.233]                     cond$call), session = sessionInformation(), 
[10:29:57.233]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:57.233]                   signalCondition(cond)
[10:29:57.233]                 }
[10:29:57.233]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:57.233]                 "immediateCondition"))) {
[10:29:57.233]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:57.233]                   ...future.conditions[[length(...future.conditions) + 
[10:29:57.233]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:57.233]                   if (TRUE && !signal) {
[10:29:57.233]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.233]                     {
[10:29:57.233]                       inherits <- base::inherits
[10:29:57.233]                       invokeRestart <- base::invokeRestart
[10:29:57.233]                       is.null <- base::is.null
[10:29:57.233]                       muffled <- FALSE
[10:29:57.233]                       if (inherits(cond, "message")) {
[10:29:57.233]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:57.233]                         if (muffled) 
[10:29:57.233]                           invokeRestart("muffleMessage")
[10:29:57.233]                       }
[10:29:57.233]                       else if (inherits(cond, "warning")) {
[10:29:57.233]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:57.233]                         if (muffled) 
[10:29:57.233]                           invokeRestart("muffleWarning")
[10:29:57.233]                       }
[10:29:57.233]                       else if (inherits(cond, "condition")) {
[10:29:57.233]                         if (!is.null(pattern)) {
[10:29:57.233]                           computeRestarts <- base::computeRestarts
[10:29:57.233]                           grepl <- base::grepl
[10:29:57.233]                           restarts <- computeRestarts(cond)
[10:29:57.233]                           for (restart in restarts) {
[10:29:57.233]                             name <- restart$name
[10:29:57.233]                             if (is.null(name)) 
[10:29:57.233]                               next
[10:29:57.233]                             if (!grepl(pattern, name)) 
[10:29:57.233]                               next
[10:29:57.233]                             invokeRestart(restart)
[10:29:57.233]                             muffled <- TRUE
[10:29:57.233]                             break
[10:29:57.233]                           }
[10:29:57.233]                         }
[10:29:57.233]                       }
[10:29:57.233]                       invisible(muffled)
[10:29:57.233]                     }
[10:29:57.233]                     muffleCondition(cond, pattern = "^muffle")
[10:29:57.233]                   }
[10:29:57.233]                 }
[10:29:57.233]                 else {
[10:29:57.233]                   if (TRUE) {
[10:29:57.233]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.233]                     {
[10:29:57.233]                       inherits <- base::inherits
[10:29:57.233]                       invokeRestart <- base::invokeRestart
[10:29:57.233]                       is.null <- base::is.null
[10:29:57.233]                       muffled <- FALSE
[10:29:57.233]                       if (inherits(cond, "message")) {
[10:29:57.233]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:57.233]                         if (muffled) 
[10:29:57.233]                           invokeRestart("muffleMessage")
[10:29:57.233]                       }
[10:29:57.233]                       else if (inherits(cond, "warning")) {
[10:29:57.233]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:57.233]                         if (muffled) 
[10:29:57.233]                           invokeRestart("muffleWarning")
[10:29:57.233]                       }
[10:29:57.233]                       else if (inherits(cond, "condition")) {
[10:29:57.233]                         if (!is.null(pattern)) {
[10:29:57.233]                           computeRestarts <- base::computeRestarts
[10:29:57.233]                           grepl <- base::grepl
[10:29:57.233]                           restarts <- computeRestarts(cond)
[10:29:57.233]                           for (restart in restarts) {
[10:29:57.233]                             name <- restart$name
[10:29:57.233]                             if (is.null(name)) 
[10:29:57.233]                               next
[10:29:57.233]                             if (!grepl(pattern, name)) 
[10:29:57.233]                               next
[10:29:57.233]                             invokeRestart(restart)
[10:29:57.233]                             muffled <- TRUE
[10:29:57.233]                             break
[10:29:57.233]                           }
[10:29:57.233]                         }
[10:29:57.233]                       }
[10:29:57.233]                       invisible(muffled)
[10:29:57.233]                     }
[10:29:57.233]                     muffleCondition(cond, pattern = "^muffle")
[10:29:57.233]                   }
[10:29:57.233]                 }
[10:29:57.233]             }
[10:29:57.233]         }))
[10:29:57.233]     }, error = function(ex) {
[10:29:57.233]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:57.233]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:57.233]                 ...future.rng), started = ...future.startTime, 
[10:29:57.233]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:57.233]             version = "1.8"), class = "FutureResult")
[10:29:57.233]     }, finally = {
[10:29:57.233]         if (!identical(...future.workdir, getwd())) 
[10:29:57.233]             setwd(...future.workdir)
[10:29:57.233]         {
[10:29:57.233]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:57.233]                 ...future.oldOptions$nwarnings <- NULL
[10:29:57.233]             }
[10:29:57.233]             base::options(...future.oldOptions)
[10:29:57.233]             if (.Platform$OS.type == "windows") {
[10:29:57.233]                 old_names <- names(...future.oldEnvVars)
[10:29:57.233]                 envs <- base::Sys.getenv()
[10:29:57.233]                 names <- names(envs)
[10:29:57.233]                 common <- intersect(names, old_names)
[10:29:57.233]                 added <- setdiff(names, old_names)
[10:29:57.233]                 removed <- setdiff(old_names, names)
[10:29:57.233]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:57.233]                   envs[common]]
[10:29:57.233]                 NAMES <- toupper(changed)
[10:29:57.233]                 args <- list()
[10:29:57.233]                 for (kk in seq_along(NAMES)) {
[10:29:57.233]                   name <- changed[[kk]]
[10:29:57.233]                   NAME <- NAMES[[kk]]
[10:29:57.233]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.233]                     next
[10:29:57.233]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:57.233]                 }
[10:29:57.233]                 NAMES <- toupper(added)
[10:29:57.233]                 for (kk in seq_along(NAMES)) {
[10:29:57.233]                   name <- added[[kk]]
[10:29:57.233]                   NAME <- NAMES[[kk]]
[10:29:57.233]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.233]                     next
[10:29:57.233]                   args[[name]] <- ""
[10:29:57.233]                 }
[10:29:57.233]                 NAMES <- toupper(removed)
[10:29:57.233]                 for (kk in seq_along(NAMES)) {
[10:29:57.233]                   name <- removed[[kk]]
[10:29:57.233]                   NAME <- NAMES[[kk]]
[10:29:57.233]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.233]                     next
[10:29:57.233]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:57.233]                 }
[10:29:57.233]                 if (length(args) > 0) 
[10:29:57.233]                   base::do.call(base::Sys.setenv, args = args)
[10:29:57.233]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:57.233]             }
[10:29:57.233]             else {
[10:29:57.233]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:57.233]             }
[10:29:57.233]             {
[10:29:57.233]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:57.233]                   0L) {
[10:29:57.233]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:57.233]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:57.233]                   base::options(opts)
[10:29:57.233]                 }
[10:29:57.233]                 {
[10:29:57.233]                   {
[10:29:57.233]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:57.233]                     NULL
[10:29:57.233]                   }
[10:29:57.233]                   options(future.plan = NULL)
[10:29:57.233]                   if (is.na(NA_character_)) 
[10:29:57.233]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:57.233]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:57.233]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:57.233]                     .init = FALSE)
[10:29:57.233]                 }
[10:29:57.233]             }
[10:29:57.233]         }
[10:29:57.233]     })
[10:29:57.233]     if (TRUE) {
[10:29:57.233]         base::sink(type = "output", split = FALSE)
[10:29:57.233]         if (TRUE) {
[10:29:57.233]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:57.233]         }
[10:29:57.233]         else {
[10:29:57.233]             ...future.result["stdout"] <- base::list(NULL)
[10:29:57.233]         }
[10:29:57.233]         base::close(...future.stdout)
[10:29:57.233]         ...future.stdout <- NULL
[10:29:57.233]     }
[10:29:57.233]     ...future.result$conditions <- ...future.conditions
[10:29:57.233]     ...future.result$finished <- base::Sys.time()
[10:29:57.233]     ...future.result
[10:29:57.233] }
[10:29:57.236] assign_globals() ...
[10:29:57.236] List of 5
[10:29:57.236]  $ ...future.FUN            :function (x, ...)  
[10:29:57.236]  $ future.call.arguments    : list()
[10:29:57.236]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.236]  $ ...future.elements_ii    :List of 2
[10:29:57.236]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:29:57.236]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:29:57.236]  $ ...future.seeds_ii       : NULL
[10:29:57.236]  $ ...future.globals.maxSize: NULL
[10:29:57.236]  - attr(*, "where")=List of 5
[10:29:57.236]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:57.236]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:57.236]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:57.236]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:57.236]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:57.236]  - attr(*, "resolved")= logi FALSE
[10:29:57.236]  - attr(*, "total_size")= num 1240
[10:29:57.236]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.236]  - attr(*, "already-done")= logi TRUE
[10:29:57.249] - copied ‘...future.FUN’ to environment
[10:29:57.249] - copied ‘future.call.arguments’ to environment
[10:29:57.249] - copied ‘...future.elements_ii’ to environment
[10:29:57.250] - copied ‘...future.seeds_ii’ to environment
[10:29:57.250] - copied ‘...future.globals.maxSize’ to environment
[10:29:57.250] assign_globals() ... done
[10:29:57.250] requestCore(): workers = 2
[10:29:57.256] MulticoreFuture started
[10:29:57.257] - Launch lazy future ... done
[10:29:57.257] run() for ‘MulticoreFuture’ ... done
[10:29:57.257] Created future:
[10:29:57.257] plan(): Setting new future strategy stack:
[10:29:57.258] List of future strategies:
[10:29:57.258] 1. sequential:
[10:29:57.258]    - args: function (..., envir = parent.frame())
[10:29:57.258]    - tweaked: FALSE
[10:29:57.258]    - call: NULL
[10:29:57.259] plan(): nbrOfWorkers() = 1
[10:29:57.261] plan(): Setting new future strategy stack:
[10:29:57.261] List of future strategies:
[10:29:57.261] 1. multicore:
[10:29:57.261]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:57.261]    - tweaked: FALSE
[10:29:57.261]    - call: plan(strategy)
[10:29:57.266] plan(): nbrOfWorkers() = 2
[10:29:57.257] MulticoreFuture:
[10:29:57.257] Label: ‘future_eapply-2’
[10:29:57.257] Expression:
[10:29:57.257] {
[10:29:57.257]     do.call(function(...) {
[10:29:57.257]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.257]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:57.257]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.257]             on.exit(options(oopts), add = TRUE)
[10:29:57.257]         }
[10:29:57.257]         {
[10:29:57.257]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:57.257]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.257]                 ...future.FUN(...future.X_jj, ...)
[10:29:57.257]             })
[10:29:57.257]         }
[10:29:57.257]     }, args = future.call.arguments)
[10:29:57.257] }
[10:29:57.257] Lazy evaluation: FALSE
[10:29:57.257] Asynchronous evaluation: TRUE
[10:29:57.257] Local evaluation: TRUE
[10:29:57.257] Environment: R_GlobalEnv
[10:29:57.257] Capture standard output: TRUE
[10:29:57.257] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:57.257] Globals: 5 objects totaling 1.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:57.257] Packages: <none>
[10:29:57.257] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:57.257] Resolved: TRUE
[10:29:57.257] Value: <not collected>
[10:29:57.257] Conditions captured: <none>
[10:29:57.257] Early signaling: FALSE
[10:29:57.257] Owner process: db6eb61b-64f1-ae95-7e8b-287fbc43411a
[10:29:57.257] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:57.267] Chunk #2 of 2 ... DONE
[10:29:57.267] Launching 2 futures (chunks) ... DONE
[10:29:57.267] Resolving 2 futures (chunks) ...
[10:29:57.268] resolve() on list ...
[10:29:57.268]  recursive: 0
[10:29:57.268]  length: 2
[10:29:57.268] 
[10:29:57.268] Future #1
[10:29:57.269] result() for MulticoreFuture ...
[10:29:57.271] result() for MulticoreFuture ...
[10:29:57.271] result() for MulticoreFuture ... done
[10:29:57.271] result() for MulticoreFuture ... done
[10:29:57.271] result() for MulticoreFuture ...
[10:29:57.272] result() for MulticoreFuture ... done
[10:29:57.272] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:29:57.272] - nx: 2
[10:29:57.272] - relay: TRUE
[10:29:57.272] - stdout: TRUE
[10:29:57.272] - signal: TRUE
[10:29:57.272] - resignal: FALSE
[10:29:57.272] - force: TRUE
[10:29:57.273] - relayed: [n=2] FALSE, FALSE
[10:29:57.273] - queued futures: [n=2] FALSE, FALSE
[10:29:57.273]  - until=1
[10:29:57.273]  - relaying element #1
[10:29:57.273] result() for MulticoreFuture ...
[10:29:57.273] result() for MulticoreFuture ... done
[10:29:57.274] result() for MulticoreFuture ...
[10:29:57.274] result() for MulticoreFuture ... done
[10:29:57.274] result() for MulticoreFuture ...
[10:29:57.274] result() for MulticoreFuture ... done
[10:29:57.274] result() for MulticoreFuture ...
[10:29:57.274] result() for MulticoreFuture ... done
[10:29:57.274] - relayed: [n=2] TRUE, FALSE
[10:29:57.275] - queued futures: [n=2] TRUE, FALSE
[10:29:57.275] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:29:57.275]  length: 1 (resolved future 1)
[10:29:57.275] Future #2
[10:29:57.275] result() for MulticoreFuture ...
[10:29:57.276] result() for MulticoreFuture ...
[10:29:57.276] result() for MulticoreFuture ... done
[10:29:57.276] result() for MulticoreFuture ... done
[10:29:57.276] result() for MulticoreFuture ...
[10:29:57.277] result() for MulticoreFuture ... done
[10:29:57.277] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:29:57.277] - nx: 2
[10:29:57.277] - relay: TRUE
[10:29:57.277] - stdout: TRUE
[10:29:57.277] - signal: TRUE
[10:29:57.277] - resignal: FALSE
[10:29:57.278] - force: TRUE
[10:29:57.278] - relayed: [n=2] TRUE, FALSE
[10:29:57.278] - queued futures: [n=2] TRUE, FALSE
[10:29:57.278]  - until=2
[10:29:57.278]  - relaying element #2
[10:29:57.278] result() for MulticoreFuture ...
[10:29:57.278] result() for MulticoreFuture ... done
[10:29:57.278] result() for MulticoreFuture ...
[10:29:57.279] result() for MulticoreFuture ... done
[10:29:57.279] result() for MulticoreFuture ...
[10:29:57.279] result() for MulticoreFuture ... done
[10:29:57.279] result() for MulticoreFuture ...
[10:29:57.279] result() for MulticoreFuture ... done
[10:29:57.279] - relayed: [n=2] TRUE, TRUE
[10:29:57.279] - queued futures: [n=2] TRUE, TRUE
[10:29:57.279] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:29:57.279]  length: 0 (resolved future 2)
[10:29:57.280] Relaying remaining futures
[10:29:57.280] signalConditionsASAP(NULL, pos=0) ...
[10:29:57.280] - nx: 2
[10:29:57.280] - relay: TRUE
[10:29:57.280] - stdout: TRUE
[10:29:57.280] - signal: TRUE
[10:29:57.280] - resignal: FALSE
[10:29:57.280] - force: TRUE
[10:29:57.280] - relayed: [n=2] TRUE, TRUE
[10:29:57.280] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:57.281] - relayed: [n=2] TRUE, TRUE
[10:29:57.281] - queued futures: [n=2] TRUE, TRUE
[10:29:57.281] signalConditionsASAP(NULL, pos=0) ... done
[10:29:57.281] resolve() on list ... DONE
[10:29:57.281] result() for MulticoreFuture ...
[10:29:57.281] result() for MulticoreFuture ... done
[10:29:57.281] result() for MulticoreFuture ...
[10:29:57.281] result() for MulticoreFuture ... done
[10:29:57.282] result() for MulticoreFuture ...
[10:29:57.282] result() for MulticoreFuture ... done
[10:29:57.282] result() for MulticoreFuture ...
[10:29:57.282] result() for MulticoreFuture ... done
[10:29:57.282]  - Number of value chunks collected: 2
[10:29:57.282] Resolving 2 futures (chunks) ... DONE
[10:29:57.282] Reducing values from 2 chunks ...
[10:29:57.282]  - Number of values collected after concatenation: 3
[10:29:57.282]  - Number of values expected: 3
[10:29:57.283] Reducing values from 2 chunks ... DONE
[10:29:57.283] future_lapply() ... DONE
[10:29:57.283] future_lapply() ...
[10:29:57.290] Number of chunks: 2
[10:29:57.290] getGlobalsAndPackagesXApply() ...
[10:29:57.291]  - future.globals: TRUE
[10:29:57.291] getGlobalsAndPackages() ...
[10:29:57.291] Searching for globals...
[10:29:57.293] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:57.293] Searching for globals ... DONE
[10:29:57.293] Resolving globals: FALSE
[10:29:57.293] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[10:29:57.294] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[10:29:57.294] - globals: [1] ‘FUN’
[10:29:57.294] - packages: [1] ‘stats’
[10:29:57.294] getGlobalsAndPackages() ... DONE
[10:29:57.294]  - globals found/used: [n=1] ‘FUN’
[10:29:57.295]  - needed namespaces: [n=1] ‘stats’
[10:29:57.295] Finding globals ... DONE
[10:29:57.295]  - use_args: TRUE
[10:29:57.295]  - Getting '...' globals ...
[10:29:57.295] resolve() on list ...
[10:29:57.295]  recursive: 0
[10:29:57.296]  length: 1
[10:29:57.296]  elements: ‘...’
[10:29:57.296]  length: 0 (resolved future 1)
[10:29:57.296] resolve() on list ... DONE
[10:29:57.296]    - '...' content: [n=1] ‘probs’
[10:29:57.296] List of 1
[10:29:57.296]  $ ...:List of 1
[10:29:57.296]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:29:57.296]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.296]  - attr(*, "where")=List of 1
[10:29:57.296]   ..$ ...:<environment: 0x55974baf7250> 
[10:29:57.296]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.296]  - attr(*, "resolved")= logi TRUE
[10:29:57.296]  - attr(*, "total_size")= num NA
[10:29:57.300]  - Getting '...' globals ... DONE
[10:29:57.300] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:57.300] List of 2
[10:29:57.300]  $ ...future.FUN:function (x, ...)  
[10:29:57.300]  $ ...          :List of 1
[10:29:57.300]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:29:57.300]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.300]  - attr(*, "where")=List of 2
[10:29:57.300]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:57.300]   ..$ ...          :<environment: 0x55974baf7250> 
[10:29:57.300]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.300]  - attr(*, "resolved")= logi FALSE
[10:29:57.300]  - attr(*, "total_size")= num 1328
[10:29:57.303] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:57.303] getGlobalsAndPackagesXApply() ... DONE
[10:29:57.304] Number of futures (= number of chunks): 2
[10:29:57.304] Launching 2 futures (chunks) ...
[10:29:57.304] Chunk #1 of 2 ...
[10:29:57.304]  - Finding globals in 'X' for chunk #1 ...
[10:29:57.304] getGlobalsAndPackages() ...
[10:29:57.304] Searching for globals...
[10:29:57.304] 
[10:29:57.304] Searching for globals ... DONE
[10:29:57.305] - globals: [0] <none>
[10:29:57.305] getGlobalsAndPackages() ... DONE
[10:29:57.305]    + additional globals found: [n=0] 
[10:29:57.305]    + additional namespaces needed: [n=0] 
[10:29:57.305]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:57.305]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:57.305]  - seeds: <none>
[10:29:57.305]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.305] getGlobalsAndPackages() ...
[10:29:57.305] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.306] Resolving globals: FALSE
[10:29:57.306] Tweak future expression to call with '...' arguments ...
[10:29:57.306] {
[10:29:57.306]     do.call(function(...) {
[10:29:57.306]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.306]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:57.306]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.306]             on.exit(options(oopts), add = TRUE)
[10:29:57.306]         }
[10:29:57.306]         {
[10:29:57.306]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:57.306]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.306]                 ...future.FUN(...future.X_jj, ...)
[10:29:57.306]             })
[10:29:57.306]         }
[10:29:57.306]     }, args = future.call.arguments)
[10:29:57.306] }
[10:29:57.306] Tweak future expression to call with '...' arguments ... DONE
[10:29:57.306] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.307] - packages: [1] ‘stats’
[10:29:57.307] getGlobalsAndPackages() ... DONE
[10:29:57.307] run() for ‘Future’ ...
[10:29:57.307] - state: ‘created’
[10:29:57.307] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:57.311] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:57.311] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:57.311]   - Field: ‘label’
[10:29:57.311]   - Field: ‘local’
[10:29:57.311]   - Field: ‘owner’
[10:29:57.312]   - Field: ‘envir’
[10:29:57.312]   - Field: ‘workers’
[10:29:57.312]   - Field: ‘packages’
[10:29:57.312]   - Field: ‘gc’
[10:29:57.312]   - Field: ‘job’
[10:29:57.312]   - Field: ‘conditions’
[10:29:57.312]   - Field: ‘expr’
[10:29:57.312]   - Field: ‘uuid’
[10:29:57.312]   - Field: ‘seed’
[10:29:57.312]   - Field: ‘version’
[10:29:57.312]   - Field: ‘result’
[10:29:57.313]   - Field: ‘asynchronous’
[10:29:57.313]   - Field: ‘calls’
[10:29:57.313]   - Field: ‘globals’
[10:29:57.313]   - Field: ‘stdout’
[10:29:57.313]   - Field: ‘earlySignal’
[10:29:57.313]   - Field: ‘lazy’
[10:29:57.313]   - Field: ‘state’
[10:29:57.313] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:57.313] - Launch lazy future ...
[10:29:57.314] Packages needed by the future expression (n = 1): ‘stats’
[10:29:57.314] Packages needed by future strategies (n = 0): <none>
[10:29:57.314] {
[10:29:57.314]     {
[10:29:57.314]         {
[10:29:57.314]             ...future.startTime <- base::Sys.time()
[10:29:57.314]             {
[10:29:57.314]                 {
[10:29:57.314]                   {
[10:29:57.314]                     {
[10:29:57.314]                       {
[10:29:57.314]                         base::local({
[10:29:57.314]                           has_future <- base::requireNamespace("future", 
[10:29:57.314]                             quietly = TRUE)
[10:29:57.314]                           if (has_future) {
[10:29:57.314]                             ns <- base::getNamespace("future")
[10:29:57.314]                             version <- ns[[".package"]][["version"]]
[10:29:57.314]                             if (is.null(version)) 
[10:29:57.314]                               version <- utils::packageVersion("future")
[10:29:57.314]                           }
[10:29:57.314]                           else {
[10:29:57.314]                             version <- NULL
[10:29:57.314]                           }
[10:29:57.314]                           if (!has_future || version < "1.8.0") {
[10:29:57.314]                             info <- base::c(r_version = base::gsub("R version ", 
[10:29:57.314]                               "", base::R.version$version.string), 
[10:29:57.314]                               platform = base::sprintf("%s (%s-bit)", 
[10:29:57.314]                                 base::R.version$platform, 8 * 
[10:29:57.314]                                   base::.Machine$sizeof.pointer), 
[10:29:57.314]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:57.314]                                 "release", "version")], collapse = " "), 
[10:29:57.314]                               hostname = base::Sys.info()[["nodename"]])
[10:29:57.314]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:29:57.314]                               info)
[10:29:57.314]                             info <- base::paste(info, collapse = "; ")
[10:29:57.314]                             if (!has_future) {
[10:29:57.314]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:57.314]                                 info)
[10:29:57.314]                             }
[10:29:57.314]                             else {
[10:29:57.314]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:57.314]                                 info, version)
[10:29:57.314]                             }
[10:29:57.314]                             base::stop(msg)
[10:29:57.314]                           }
[10:29:57.314]                         })
[10:29:57.314]                       }
[10:29:57.314]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:57.314]                       base::options(mc.cores = 1L)
[10:29:57.314]                     }
[10:29:57.314]                     base::local({
[10:29:57.314]                       for (pkg in "stats") {
[10:29:57.314]                         base::loadNamespace(pkg)
[10:29:57.314]                         base::library(pkg, character.only = TRUE)
[10:29:57.314]                       }
[10:29:57.314]                     })
[10:29:57.314]                   }
[10:29:57.314]                   ...future.strategy.old <- future::plan("list")
[10:29:57.314]                   options(future.plan = NULL)
[10:29:57.314]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:57.314]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:57.314]                 }
[10:29:57.314]                 ...future.workdir <- getwd()
[10:29:57.314]             }
[10:29:57.314]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:57.314]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:57.314]         }
[10:29:57.314]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:57.314]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:57.314]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:57.314]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:57.314]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:57.314]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:57.314]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:57.314]             base::names(...future.oldOptions))
[10:29:57.314]     }
[10:29:57.314]     if (FALSE) {
[10:29:57.314]     }
[10:29:57.314]     else {
[10:29:57.314]         if (TRUE) {
[10:29:57.314]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:57.314]                 open = "w")
[10:29:57.314]         }
[10:29:57.314]         else {
[10:29:57.314]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:57.314]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:57.314]         }
[10:29:57.314]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:57.314]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:57.314]             base::sink(type = "output", split = FALSE)
[10:29:57.314]             base::close(...future.stdout)
[10:29:57.314]         }, add = TRUE)
[10:29:57.314]     }
[10:29:57.314]     ...future.frame <- base::sys.nframe()
[10:29:57.314]     ...future.conditions <- base::list()
[10:29:57.314]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:57.314]     if (FALSE) {
[10:29:57.314]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:57.314]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:57.314]     }
[10:29:57.314]     ...future.result <- base::tryCatch({
[10:29:57.314]         base::withCallingHandlers({
[10:29:57.314]             ...future.value <- base::withVisible(base::local({
[10:29:57.314]                 withCallingHandlers({
[10:29:57.314]                   {
[10:29:57.314]                     do.call(function(...) {
[10:29:57.314]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.314]                       if (!identical(...future.globals.maxSize.org, 
[10:29:57.314]                         ...future.globals.maxSize)) {
[10:29:57.314]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.314]                         on.exit(options(oopts), add = TRUE)
[10:29:57.314]                       }
[10:29:57.314]                       {
[10:29:57.314]                         lapply(seq_along(...future.elements_ii), 
[10:29:57.314]                           FUN = function(jj) {
[10:29:57.314]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.314]                             ...future.FUN(...future.X_jj, ...)
[10:29:57.314]                           })
[10:29:57.314]                       }
[10:29:57.314]                     }, args = future.call.arguments)
[10:29:57.314]                   }
[10:29:57.314]                 }, immediateCondition = function(cond) {
[10:29:57.314]                   save_rds <- function (object, pathname, ...) 
[10:29:57.314]                   {
[10:29:57.314]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:57.314]                     if (file_test("-f", pathname_tmp)) {
[10:29:57.314]                       fi_tmp <- file.info(pathname_tmp)
[10:29:57.314]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:57.314]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:57.314]                         fi_tmp[["mtime"]])
[10:29:57.314]                     }
[10:29:57.314]                     tryCatch({
[10:29:57.314]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:57.314]                     }, error = function(ex) {
[10:29:57.314]                       msg <- conditionMessage(ex)
[10:29:57.314]                       fi_tmp <- file.info(pathname_tmp)
[10:29:57.314]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:57.314]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:57.314]                         fi_tmp[["mtime"]], msg)
[10:29:57.314]                       ex$message <- msg
[10:29:57.314]                       stop(ex)
[10:29:57.314]                     })
[10:29:57.314]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:57.314]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:57.314]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:57.314]                       fi_tmp <- file.info(pathname_tmp)
[10:29:57.314]                       fi <- file.info(pathname)
[10:29:57.314]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:57.314]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:57.314]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:57.314]                         fi[["size"]], fi[["mtime"]])
[10:29:57.314]                       stop(msg)
[10:29:57.314]                     }
[10:29:57.314]                     invisible(pathname)
[10:29:57.314]                   }
[10:29:57.314]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:57.314]                     rootPath = tempdir()) 
[10:29:57.314]                   {
[10:29:57.314]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:57.314]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:57.314]                       tmpdir = path, fileext = ".rds")
[10:29:57.314]                     save_rds(obj, file)
[10:29:57.314]                   }
[10:29:57.314]                   saveImmediateCondition(cond, path = "/tmp/RtmpoCSmtD/.future/immediateConditions")
[10:29:57.314]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.314]                   {
[10:29:57.314]                     inherits <- base::inherits
[10:29:57.314]                     invokeRestart <- base::invokeRestart
[10:29:57.314]                     is.null <- base::is.null
[10:29:57.314]                     muffled <- FALSE
[10:29:57.314]                     if (inherits(cond, "message")) {
[10:29:57.314]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:57.314]                       if (muffled) 
[10:29:57.314]                         invokeRestart("muffleMessage")
[10:29:57.314]                     }
[10:29:57.314]                     else if (inherits(cond, "warning")) {
[10:29:57.314]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:57.314]                       if (muffled) 
[10:29:57.314]                         invokeRestart("muffleWarning")
[10:29:57.314]                     }
[10:29:57.314]                     else if (inherits(cond, "condition")) {
[10:29:57.314]                       if (!is.null(pattern)) {
[10:29:57.314]                         computeRestarts <- base::computeRestarts
[10:29:57.314]                         grepl <- base::grepl
[10:29:57.314]                         restarts <- computeRestarts(cond)
[10:29:57.314]                         for (restart in restarts) {
[10:29:57.314]                           name <- restart$name
[10:29:57.314]                           if (is.null(name)) 
[10:29:57.314]                             next
[10:29:57.314]                           if (!grepl(pattern, name)) 
[10:29:57.314]                             next
[10:29:57.314]                           invokeRestart(restart)
[10:29:57.314]                           muffled <- TRUE
[10:29:57.314]                           break
[10:29:57.314]                         }
[10:29:57.314]                       }
[10:29:57.314]                     }
[10:29:57.314]                     invisible(muffled)
[10:29:57.314]                   }
[10:29:57.314]                   muffleCondition(cond)
[10:29:57.314]                 })
[10:29:57.314]             }))
[10:29:57.314]             future::FutureResult(value = ...future.value$value, 
[10:29:57.314]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:57.314]                   ...future.rng), globalenv = if (FALSE) 
[10:29:57.314]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:57.314]                     ...future.globalenv.names))
[10:29:57.314]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:57.314]         }, condition = base::local({
[10:29:57.314]             c <- base::c
[10:29:57.314]             inherits <- base::inherits
[10:29:57.314]             invokeRestart <- base::invokeRestart
[10:29:57.314]             length <- base::length
[10:29:57.314]             list <- base::list
[10:29:57.314]             seq.int <- base::seq.int
[10:29:57.314]             signalCondition <- base::signalCondition
[10:29:57.314]             sys.calls <- base::sys.calls
[10:29:57.314]             `[[` <- base::`[[`
[10:29:57.314]             `+` <- base::`+`
[10:29:57.314]             `<<-` <- base::`<<-`
[10:29:57.314]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:57.314]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:57.314]                   3L)]
[10:29:57.314]             }
[10:29:57.314]             function(cond) {
[10:29:57.314]                 is_error <- inherits(cond, "error")
[10:29:57.314]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:57.314]                   NULL)
[10:29:57.314]                 if (is_error) {
[10:29:57.314]                   sessionInformation <- function() {
[10:29:57.314]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:57.314]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:57.314]                       search = base::search(), system = base::Sys.info())
[10:29:57.314]                   }
[10:29:57.314]                   ...future.conditions[[length(...future.conditions) + 
[10:29:57.314]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:57.314]                     cond$call), session = sessionInformation(), 
[10:29:57.314]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:57.314]                   signalCondition(cond)
[10:29:57.314]                 }
[10:29:57.314]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:57.314]                 "immediateCondition"))) {
[10:29:57.314]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:57.314]                   ...future.conditions[[length(...future.conditions) + 
[10:29:57.314]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:57.314]                   if (TRUE && !signal) {
[10:29:57.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.314]                     {
[10:29:57.314]                       inherits <- base::inherits
[10:29:57.314]                       invokeRestart <- base::invokeRestart
[10:29:57.314]                       is.null <- base::is.null
[10:29:57.314]                       muffled <- FALSE
[10:29:57.314]                       if (inherits(cond, "message")) {
[10:29:57.314]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:57.314]                         if (muffled) 
[10:29:57.314]                           invokeRestart("muffleMessage")
[10:29:57.314]                       }
[10:29:57.314]                       else if (inherits(cond, "warning")) {
[10:29:57.314]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:57.314]                         if (muffled) 
[10:29:57.314]                           invokeRestart("muffleWarning")
[10:29:57.314]                       }
[10:29:57.314]                       else if (inherits(cond, "condition")) {
[10:29:57.314]                         if (!is.null(pattern)) {
[10:29:57.314]                           computeRestarts <- base::computeRestarts
[10:29:57.314]                           grepl <- base::grepl
[10:29:57.314]                           restarts <- computeRestarts(cond)
[10:29:57.314]                           for (restart in restarts) {
[10:29:57.314]                             name <- restart$name
[10:29:57.314]                             if (is.null(name)) 
[10:29:57.314]                               next
[10:29:57.314]                             if (!grepl(pattern, name)) 
[10:29:57.314]                               next
[10:29:57.314]                             invokeRestart(restart)
[10:29:57.314]                             muffled <- TRUE
[10:29:57.314]                             break
[10:29:57.314]                           }
[10:29:57.314]                         }
[10:29:57.314]                       }
[10:29:57.314]                       invisible(muffled)
[10:29:57.314]                     }
[10:29:57.314]                     muffleCondition(cond, pattern = "^muffle")
[10:29:57.314]                   }
[10:29:57.314]                 }
[10:29:57.314]                 else {
[10:29:57.314]                   if (TRUE) {
[10:29:57.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.314]                     {
[10:29:57.314]                       inherits <- base::inherits
[10:29:57.314]                       invokeRestart <- base::invokeRestart
[10:29:57.314]                       is.null <- base::is.null
[10:29:57.314]                       muffled <- FALSE
[10:29:57.314]                       if (inherits(cond, "message")) {
[10:29:57.314]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:57.314]                         if (muffled) 
[10:29:57.314]                           invokeRestart("muffleMessage")
[10:29:57.314]                       }
[10:29:57.314]                       else if (inherits(cond, "warning")) {
[10:29:57.314]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:57.314]                         if (muffled) 
[10:29:57.314]                           invokeRestart("muffleWarning")
[10:29:57.314]                       }
[10:29:57.314]                       else if (inherits(cond, "condition")) {
[10:29:57.314]                         if (!is.null(pattern)) {
[10:29:57.314]                           computeRestarts <- base::computeRestarts
[10:29:57.314]                           grepl <- base::grepl
[10:29:57.314]                           restarts <- computeRestarts(cond)
[10:29:57.314]                           for (restart in restarts) {
[10:29:57.314]                             name <- restart$name
[10:29:57.314]                             if (is.null(name)) 
[10:29:57.314]                               next
[10:29:57.314]                             if (!grepl(pattern, name)) 
[10:29:57.314]                               next
[10:29:57.314]                             invokeRestart(restart)
[10:29:57.314]                             muffled <- TRUE
[10:29:57.314]                             break
[10:29:57.314]                           }
[10:29:57.314]                         }
[10:29:57.314]                       }
[10:29:57.314]                       invisible(muffled)
[10:29:57.314]                     }
[10:29:57.314]                     muffleCondition(cond, pattern = "^muffle")
[10:29:57.314]                   }
[10:29:57.314]                 }
[10:29:57.314]             }
[10:29:57.314]         }))
[10:29:57.314]     }, error = function(ex) {
[10:29:57.314]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:57.314]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:57.314]                 ...future.rng), started = ...future.startTime, 
[10:29:57.314]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:57.314]             version = "1.8"), class = "FutureResult")
[10:29:57.314]     }, finally = {
[10:29:57.314]         if (!identical(...future.workdir, getwd())) 
[10:29:57.314]             setwd(...future.workdir)
[10:29:57.314]         {
[10:29:57.314]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:57.314]                 ...future.oldOptions$nwarnings <- NULL
[10:29:57.314]             }
[10:29:57.314]             base::options(...future.oldOptions)
[10:29:57.314]             if (.Platform$OS.type == "windows") {
[10:29:57.314]                 old_names <- names(...future.oldEnvVars)
[10:29:57.314]                 envs <- base::Sys.getenv()
[10:29:57.314]                 names <- names(envs)
[10:29:57.314]                 common <- intersect(names, old_names)
[10:29:57.314]                 added <- setdiff(names, old_names)
[10:29:57.314]                 removed <- setdiff(old_names, names)
[10:29:57.314]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:57.314]                   envs[common]]
[10:29:57.314]                 NAMES <- toupper(changed)
[10:29:57.314]                 args <- list()
[10:29:57.314]                 for (kk in seq_along(NAMES)) {
[10:29:57.314]                   name <- changed[[kk]]
[10:29:57.314]                   NAME <- NAMES[[kk]]
[10:29:57.314]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.314]                     next
[10:29:57.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:57.314]                 }
[10:29:57.314]                 NAMES <- toupper(added)
[10:29:57.314]                 for (kk in seq_along(NAMES)) {
[10:29:57.314]                   name <- added[[kk]]
[10:29:57.314]                   NAME <- NAMES[[kk]]
[10:29:57.314]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.314]                     next
[10:29:57.314]                   args[[name]] <- ""
[10:29:57.314]                 }
[10:29:57.314]                 NAMES <- toupper(removed)
[10:29:57.314]                 for (kk in seq_along(NAMES)) {
[10:29:57.314]                   name <- removed[[kk]]
[10:29:57.314]                   NAME <- NAMES[[kk]]
[10:29:57.314]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.314]                     next
[10:29:57.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:57.314]                 }
[10:29:57.314]                 if (length(args) > 0) 
[10:29:57.314]                   base::do.call(base::Sys.setenv, args = args)
[10:29:57.314]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:57.314]             }
[10:29:57.314]             else {
[10:29:57.314]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:57.314]             }
[10:29:57.314]             {
[10:29:57.314]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:57.314]                   0L) {
[10:29:57.314]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:57.314]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:57.314]                   base::options(opts)
[10:29:57.314]                 }
[10:29:57.314]                 {
[10:29:57.314]                   {
[10:29:57.314]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:57.314]                     NULL
[10:29:57.314]                   }
[10:29:57.314]                   options(future.plan = NULL)
[10:29:57.314]                   if (is.na(NA_character_)) 
[10:29:57.314]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:57.314]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:57.314]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:57.314]                     .init = FALSE)
[10:29:57.314]                 }
[10:29:57.314]             }
[10:29:57.314]         }
[10:29:57.314]     })
[10:29:57.314]     if (TRUE) {
[10:29:57.314]         base::sink(type = "output", split = FALSE)
[10:29:57.314]         if (TRUE) {
[10:29:57.314]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:57.314]         }
[10:29:57.314]         else {
[10:29:57.314]             ...future.result["stdout"] <- base::list(NULL)
[10:29:57.314]         }
[10:29:57.314]         base::close(...future.stdout)
[10:29:57.314]         ...future.stdout <- NULL
[10:29:57.314]     }
[10:29:57.314]     ...future.result$conditions <- ...future.conditions
[10:29:57.314]     ...future.result$finished <- base::Sys.time()
[10:29:57.314]     ...future.result
[10:29:57.314] }
[10:29:57.317] assign_globals() ...
[10:29:57.317] List of 5
[10:29:57.317]  $ ...future.FUN            :function (x, ...)  
[10:29:57.317]  $ future.call.arguments    :List of 1
[10:29:57.317]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:29:57.317]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.317]  $ ...future.elements_ii    :List of 1
[10:29:57.317]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[10:29:57.317]  $ ...future.seeds_ii       : NULL
[10:29:57.317]  $ ...future.globals.maxSize: NULL
[10:29:57.317]  - attr(*, "where")=List of 5
[10:29:57.317]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:57.317]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:57.317]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:57.317]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:57.317]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:57.317]  - attr(*, "resolved")= logi FALSE
[10:29:57.317]  - attr(*, "total_size")= num 1328
[10:29:57.317]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.317]  - attr(*, "already-done")= logi TRUE
[10:29:57.324] - copied ‘...future.FUN’ to environment
[10:29:57.324] - copied ‘future.call.arguments’ to environment
[10:29:57.324] - copied ‘...future.elements_ii’ to environment
[10:29:57.324] - copied ‘...future.seeds_ii’ to environment
[10:29:57.325] - copied ‘...future.globals.maxSize’ to environment
[10:29:57.325] assign_globals() ... done
[10:29:57.325] requestCore(): workers = 2
[10:29:57.327] MulticoreFuture started
[10:29:57.327] - Launch lazy future ... done
[10:29:57.328] run() for ‘MulticoreFuture’ ... done
[10:29:57.328] Created future:
[10:29:57.329] plan(): Setting new future strategy stack:
[10:29:57.329] List of future strategies:
[10:29:57.329] 1. sequential:
[10:29:57.329]    - args: function (..., envir = parent.frame())
[10:29:57.329]    - tweaked: FALSE
[10:29:57.329]    - call: NULL
[10:29:57.330] plan(): nbrOfWorkers() = 1
[10:29:57.332] plan(): Setting new future strategy stack:
[10:29:57.332] List of future strategies:
[10:29:57.332] 1. multicore:
[10:29:57.332]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:57.332]    - tweaked: FALSE
[10:29:57.332]    - call: plan(strategy)
[10:29:57.338] plan(): nbrOfWorkers() = 2
[10:29:57.328] MulticoreFuture:
[10:29:57.328] Label: ‘future_eapply-1’
[10:29:57.328] Expression:
[10:29:57.328] {
[10:29:57.328]     do.call(function(...) {
[10:29:57.328]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.328]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:57.328]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.328]             on.exit(options(oopts), add = TRUE)
[10:29:57.328]         }
[10:29:57.328]         {
[10:29:57.328]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:57.328]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.328]                 ...future.FUN(...future.X_jj, ...)
[10:29:57.328]             })
[10:29:57.328]         }
[10:29:57.328]     }, args = future.call.arguments)
[10:29:57.328] }
[10:29:57.328] Lazy evaluation: FALSE
[10:29:57.328] Asynchronous evaluation: TRUE
[10:29:57.328] Local evaluation: TRUE
[10:29:57.328] Environment: R_GlobalEnv
[10:29:57.328] Capture standard output: TRUE
[10:29:57.328] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:57.328] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:57.328] Packages: 1 packages (‘stats’)
[10:29:57.328] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:57.328] Resolved: TRUE
[10:29:57.328] Value: <not collected>
[10:29:57.328] Conditions captured: <none>
[10:29:57.328] Early signaling: FALSE
[10:29:57.328] Owner process: db6eb61b-64f1-ae95-7e8b-287fbc43411a
[10:29:57.328] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:57.339] Chunk #1 of 2 ... DONE
[10:29:57.339] Chunk #2 of 2 ...
[10:29:57.340]  - Finding globals in 'X' for chunk #2 ...
[10:29:57.340] getGlobalsAndPackages() ...
[10:29:57.340] Searching for globals...
[10:29:57.340] 
[10:29:57.340] Searching for globals ... DONE
[10:29:57.341] - globals: [0] <none>
[10:29:57.341] getGlobalsAndPackages() ... DONE
[10:29:57.341]    + additional globals found: [n=0] 
[10:29:57.341]    + additional namespaces needed: [n=0] 
[10:29:57.341]  - Finding globals in 'X' for chunk #2 ... DONE
[10:29:57.341]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:57.341]  - seeds: <none>
[10:29:57.342]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.342] getGlobalsAndPackages() ...
[10:29:57.342] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.342] Resolving globals: FALSE
[10:29:57.342] Tweak future expression to call with '...' arguments ...
[10:29:57.342] {
[10:29:57.342]     do.call(function(...) {
[10:29:57.342]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.342]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:57.342]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.342]             on.exit(options(oopts), add = TRUE)
[10:29:57.342]         }
[10:29:57.342]         {
[10:29:57.342]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:57.342]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.342]                 ...future.FUN(...future.X_jj, ...)
[10:29:57.342]             })
[10:29:57.342]         }
[10:29:57.342]     }, args = future.call.arguments)
[10:29:57.342] }
[10:29:57.343] Tweak future expression to call with '...' arguments ... DONE
[10:29:57.344] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.344] - packages: [1] ‘stats’
[10:29:57.344] getGlobalsAndPackages() ... DONE
[10:29:57.344] run() for ‘Future’ ...
[10:29:57.345] - state: ‘created’
[10:29:57.345] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:57.349] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:57.350] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:57.350]   - Field: ‘label’
[10:29:57.350]   - Field: ‘local’
[10:29:57.350]   - Field: ‘owner’
[10:29:57.350]   - Field: ‘envir’
[10:29:57.350]   - Field: ‘workers’
[10:29:57.350]   - Field: ‘packages’
[10:29:57.351]   - Field: ‘gc’
[10:29:57.351]   - Field: ‘job’
[10:29:57.351]   - Field: ‘conditions’
[10:29:57.351]   - Field: ‘expr’
[10:29:57.351]   - Field: ‘uuid’
[10:29:57.351]   - Field: ‘seed’
[10:29:57.351]   - Field: ‘version’
[10:29:57.352]   - Field: ‘result’
[10:29:57.352]   - Field: ‘asynchronous’
[10:29:57.352]   - Field: ‘calls’
[10:29:57.352]   - Field: ‘globals’
[10:29:57.352]   - Field: ‘stdout’
[10:29:57.352]   - Field: ‘earlySignal’
[10:29:57.352]   - Field: ‘lazy’
[10:29:57.353]   - Field: ‘state’
[10:29:57.353] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:57.353] - Launch lazy future ...
[10:29:57.353] Packages needed by the future expression (n = 1): ‘stats’
[10:29:57.354] Packages needed by future strategies (n = 0): <none>
[10:29:57.354] {
[10:29:57.354]     {
[10:29:57.354]         {
[10:29:57.354]             ...future.startTime <- base::Sys.time()
[10:29:57.354]             {
[10:29:57.354]                 {
[10:29:57.354]                   {
[10:29:57.354]                     {
[10:29:57.354]                       {
[10:29:57.354]                         base::local({
[10:29:57.354]                           has_future <- base::requireNamespace("future", 
[10:29:57.354]                             quietly = TRUE)
[10:29:57.354]                           if (has_future) {
[10:29:57.354]                             ns <- base::getNamespace("future")
[10:29:57.354]                             version <- ns[[".package"]][["version"]]
[10:29:57.354]                             if (is.null(version)) 
[10:29:57.354]                               version <- utils::packageVersion("future")
[10:29:57.354]                           }
[10:29:57.354]                           else {
[10:29:57.354]                             version <- NULL
[10:29:57.354]                           }
[10:29:57.354]                           if (!has_future || version < "1.8.0") {
[10:29:57.354]                             info <- base::c(r_version = base::gsub("R version ", 
[10:29:57.354]                               "", base::R.version$version.string), 
[10:29:57.354]                               platform = base::sprintf("%s (%s-bit)", 
[10:29:57.354]                                 base::R.version$platform, 8 * 
[10:29:57.354]                                   base::.Machine$sizeof.pointer), 
[10:29:57.354]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:57.354]                                 "release", "version")], collapse = " "), 
[10:29:57.354]                               hostname = base::Sys.info()[["nodename"]])
[10:29:57.354]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:29:57.354]                               info)
[10:29:57.354]                             info <- base::paste(info, collapse = "; ")
[10:29:57.354]                             if (!has_future) {
[10:29:57.354]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:57.354]                                 info)
[10:29:57.354]                             }
[10:29:57.354]                             else {
[10:29:57.354]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:57.354]                                 info, version)
[10:29:57.354]                             }
[10:29:57.354]                             base::stop(msg)
[10:29:57.354]                           }
[10:29:57.354]                         })
[10:29:57.354]                       }
[10:29:57.354]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:57.354]                       base::options(mc.cores = 1L)
[10:29:57.354]                     }
[10:29:57.354]                     base::local({
[10:29:57.354]                       for (pkg in "stats") {
[10:29:57.354]                         base::loadNamespace(pkg)
[10:29:57.354]                         base::library(pkg, character.only = TRUE)
[10:29:57.354]                       }
[10:29:57.354]                     })
[10:29:57.354]                   }
[10:29:57.354]                   ...future.strategy.old <- future::plan("list")
[10:29:57.354]                   options(future.plan = NULL)
[10:29:57.354]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:57.354]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:57.354]                 }
[10:29:57.354]                 ...future.workdir <- getwd()
[10:29:57.354]             }
[10:29:57.354]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:57.354]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:57.354]         }
[10:29:57.354]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:57.354]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:57.354]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:57.354]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:57.354]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:57.354]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:57.354]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:57.354]             base::names(...future.oldOptions))
[10:29:57.354]     }
[10:29:57.354]     if (FALSE) {
[10:29:57.354]     }
[10:29:57.354]     else {
[10:29:57.354]         if (TRUE) {
[10:29:57.354]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:57.354]                 open = "w")
[10:29:57.354]         }
[10:29:57.354]         else {
[10:29:57.354]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:57.354]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:57.354]         }
[10:29:57.354]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:57.354]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:57.354]             base::sink(type = "output", split = FALSE)
[10:29:57.354]             base::close(...future.stdout)
[10:29:57.354]         }, add = TRUE)
[10:29:57.354]     }
[10:29:57.354]     ...future.frame <- base::sys.nframe()
[10:29:57.354]     ...future.conditions <- base::list()
[10:29:57.354]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:57.354]     if (FALSE) {
[10:29:57.354]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:57.354]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:57.354]     }
[10:29:57.354]     ...future.result <- base::tryCatch({
[10:29:57.354]         base::withCallingHandlers({
[10:29:57.354]             ...future.value <- base::withVisible(base::local({
[10:29:57.354]                 withCallingHandlers({
[10:29:57.354]                   {
[10:29:57.354]                     do.call(function(...) {
[10:29:57.354]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.354]                       if (!identical(...future.globals.maxSize.org, 
[10:29:57.354]                         ...future.globals.maxSize)) {
[10:29:57.354]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.354]                         on.exit(options(oopts), add = TRUE)
[10:29:57.354]                       }
[10:29:57.354]                       {
[10:29:57.354]                         lapply(seq_along(...future.elements_ii), 
[10:29:57.354]                           FUN = function(jj) {
[10:29:57.354]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.354]                             ...future.FUN(...future.X_jj, ...)
[10:29:57.354]                           })
[10:29:57.354]                       }
[10:29:57.354]                     }, args = future.call.arguments)
[10:29:57.354]                   }
[10:29:57.354]                 }, immediateCondition = function(cond) {
[10:29:57.354]                   save_rds <- function (object, pathname, ...) 
[10:29:57.354]                   {
[10:29:57.354]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:57.354]                     if (file_test("-f", pathname_tmp)) {
[10:29:57.354]                       fi_tmp <- file.info(pathname_tmp)
[10:29:57.354]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:57.354]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:57.354]                         fi_tmp[["mtime"]])
[10:29:57.354]                     }
[10:29:57.354]                     tryCatch({
[10:29:57.354]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:57.354]                     }, error = function(ex) {
[10:29:57.354]                       msg <- conditionMessage(ex)
[10:29:57.354]                       fi_tmp <- file.info(pathname_tmp)
[10:29:57.354]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:57.354]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:57.354]                         fi_tmp[["mtime"]], msg)
[10:29:57.354]                       ex$message <- msg
[10:29:57.354]                       stop(ex)
[10:29:57.354]                     })
[10:29:57.354]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:57.354]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:57.354]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:57.354]                       fi_tmp <- file.info(pathname_tmp)
[10:29:57.354]                       fi <- file.info(pathname)
[10:29:57.354]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:57.354]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:57.354]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:57.354]                         fi[["size"]], fi[["mtime"]])
[10:29:57.354]                       stop(msg)
[10:29:57.354]                     }
[10:29:57.354]                     invisible(pathname)
[10:29:57.354]                   }
[10:29:57.354]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:57.354]                     rootPath = tempdir()) 
[10:29:57.354]                   {
[10:29:57.354]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:57.354]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:57.354]                       tmpdir = path, fileext = ".rds")
[10:29:57.354]                     save_rds(obj, file)
[10:29:57.354]                   }
[10:29:57.354]                   saveImmediateCondition(cond, path = "/tmp/RtmpoCSmtD/.future/immediateConditions")
[10:29:57.354]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.354]                   {
[10:29:57.354]                     inherits <- base::inherits
[10:29:57.354]                     invokeRestart <- base::invokeRestart
[10:29:57.354]                     is.null <- base::is.null
[10:29:57.354]                     muffled <- FALSE
[10:29:57.354]                     if (inherits(cond, "message")) {
[10:29:57.354]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:57.354]                       if (muffled) 
[10:29:57.354]                         invokeRestart("muffleMessage")
[10:29:57.354]                     }
[10:29:57.354]                     else if (inherits(cond, "warning")) {
[10:29:57.354]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:57.354]                       if (muffled) 
[10:29:57.354]                         invokeRestart("muffleWarning")
[10:29:57.354]                     }
[10:29:57.354]                     else if (inherits(cond, "condition")) {
[10:29:57.354]                       if (!is.null(pattern)) {
[10:29:57.354]                         computeRestarts <- base::computeRestarts
[10:29:57.354]                         grepl <- base::grepl
[10:29:57.354]                         restarts <- computeRestarts(cond)
[10:29:57.354]                         for (restart in restarts) {
[10:29:57.354]                           name <- restart$name
[10:29:57.354]                           if (is.null(name)) 
[10:29:57.354]                             next
[10:29:57.354]                           if (!grepl(pattern, name)) 
[10:29:57.354]                             next
[10:29:57.354]                           invokeRestart(restart)
[10:29:57.354]                           muffled <- TRUE
[10:29:57.354]                           break
[10:29:57.354]                         }
[10:29:57.354]                       }
[10:29:57.354]                     }
[10:29:57.354]                     invisible(muffled)
[10:29:57.354]                   }
[10:29:57.354]                   muffleCondition(cond)
[10:29:57.354]                 })
[10:29:57.354]             }))
[10:29:57.354]             future::FutureResult(value = ...future.value$value, 
[10:29:57.354]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:57.354]                   ...future.rng), globalenv = if (FALSE) 
[10:29:57.354]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:57.354]                     ...future.globalenv.names))
[10:29:57.354]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:57.354]         }, condition = base::local({
[10:29:57.354]             c <- base::c
[10:29:57.354]             inherits <- base::inherits
[10:29:57.354]             invokeRestart <- base::invokeRestart
[10:29:57.354]             length <- base::length
[10:29:57.354]             list <- base::list
[10:29:57.354]             seq.int <- base::seq.int
[10:29:57.354]             signalCondition <- base::signalCondition
[10:29:57.354]             sys.calls <- base::sys.calls
[10:29:57.354]             `[[` <- base::`[[`
[10:29:57.354]             `+` <- base::`+`
[10:29:57.354]             `<<-` <- base::`<<-`
[10:29:57.354]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:57.354]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:57.354]                   3L)]
[10:29:57.354]             }
[10:29:57.354]             function(cond) {
[10:29:57.354]                 is_error <- inherits(cond, "error")
[10:29:57.354]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:57.354]                   NULL)
[10:29:57.354]                 if (is_error) {
[10:29:57.354]                   sessionInformation <- function() {
[10:29:57.354]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:57.354]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:57.354]                       search = base::search(), system = base::Sys.info())
[10:29:57.354]                   }
[10:29:57.354]                   ...future.conditions[[length(...future.conditions) + 
[10:29:57.354]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:57.354]                     cond$call), session = sessionInformation(), 
[10:29:57.354]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:57.354]                   signalCondition(cond)
[10:29:57.354]                 }
[10:29:57.354]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:57.354]                 "immediateCondition"))) {
[10:29:57.354]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:57.354]                   ...future.conditions[[length(...future.conditions) + 
[10:29:57.354]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:57.354]                   if (TRUE && !signal) {
[10:29:57.354]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.354]                     {
[10:29:57.354]                       inherits <- base::inherits
[10:29:57.354]                       invokeRestart <- base::invokeRestart
[10:29:57.354]                       is.null <- base::is.null
[10:29:57.354]                       muffled <- FALSE
[10:29:57.354]                       if (inherits(cond, "message")) {
[10:29:57.354]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:57.354]                         if (muffled) 
[10:29:57.354]                           invokeRestart("muffleMessage")
[10:29:57.354]                       }
[10:29:57.354]                       else if (inherits(cond, "warning")) {
[10:29:57.354]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:57.354]                         if (muffled) 
[10:29:57.354]                           invokeRestart("muffleWarning")
[10:29:57.354]                       }
[10:29:57.354]                       else if (inherits(cond, "condition")) {
[10:29:57.354]                         if (!is.null(pattern)) {
[10:29:57.354]                           computeRestarts <- base::computeRestarts
[10:29:57.354]                           grepl <- base::grepl
[10:29:57.354]                           restarts <- computeRestarts(cond)
[10:29:57.354]                           for (restart in restarts) {
[10:29:57.354]                             name <- restart$name
[10:29:57.354]                             if (is.null(name)) 
[10:29:57.354]                               next
[10:29:57.354]                             if (!grepl(pattern, name)) 
[10:29:57.354]                               next
[10:29:57.354]                             invokeRestart(restart)
[10:29:57.354]                             muffled <- TRUE
[10:29:57.354]                             break
[10:29:57.354]                           }
[10:29:57.354]                         }
[10:29:57.354]                       }
[10:29:57.354]                       invisible(muffled)
[10:29:57.354]                     }
[10:29:57.354]                     muffleCondition(cond, pattern = "^muffle")
[10:29:57.354]                   }
[10:29:57.354]                 }
[10:29:57.354]                 else {
[10:29:57.354]                   if (TRUE) {
[10:29:57.354]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.354]                     {
[10:29:57.354]                       inherits <- base::inherits
[10:29:57.354]                       invokeRestart <- base::invokeRestart
[10:29:57.354]                       is.null <- base::is.null
[10:29:57.354]                       muffled <- FALSE
[10:29:57.354]                       if (inherits(cond, "message")) {
[10:29:57.354]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:57.354]                         if (muffled) 
[10:29:57.354]                           invokeRestart("muffleMessage")
[10:29:57.354]                       }
[10:29:57.354]                       else if (inherits(cond, "warning")) {
[10:29:57.354]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:57.354]                         if (muffled) 
[10:29:57.354]                           invokeRestart("muffleWarning")
[10:29:57.354]                       }
[10:29:57.354]                       else if (inherits(cond, "condition")) {
[10:29:57.354]                         if (!is.null(pattern)) {
[10:29:57.354]                           computeRestarts <- base::computeRestarts
[10:29:57.354]                           grepl <- base::grepl
[10:29:57.354]                           restarts <- computeRestarts(cond)
[10:29:57.354]                           for (restart in restarts) {
[10:29:57.354]                             name <- restart$name
[10:29:57.354]                             if (is.null(name)) 
[10:29:57.354]                               next
[10:29:57.354]                             if (!grepl(pattern, name)) 
[10:29:57.354]                               next
[10:29:57.354]                             invokeRestart(restart)
[10:29:57.354]                             muffled <- TRUE
[10:29:57.354]                             break
[10:29:57.354]                           }
[10:29:57.354]                         }
[10:29:57.354]                       }
[10:29:57.354]                       invisible(muffled)
[10:29:57.354]                     }
[10:29:57.354]                     muffleCondition(cond, pattern = "^muffle")
[10:29:57.354]                   }
[10:29:57.354]                 }
[10:29:57.354]             }
[10:29:57.354]         }))
[10:29:57.354]     }, error = function(ex) {
[10:29:57.354]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:57.354]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:57.354]                 ...future.rng), started = ...future.startTime, 
[10:29:57.354]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:57.354]             version = "1.8"), class = "FutureResult")
[10:29:57.354]     }, finally = {
[10:29:57.354]         if (!identical(...future.workdir, getwd())) 
[10:29:57.354]             setwd(...future.workdir)
[10:29:57.354]         {
[10:29:57.354]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:57.354]                 ...future.oldOptions$nwarnings <- NULL
[10:29:57.354]             }
[10:29:57.354]             base::options(...future.oldOptions)
[10:29:57.354]             if (.Platform$OS.type == "windows") {
[10:29:57.354]                 old_names <- names(...future.oldEnvVars)
[10:29:57.354]                 envs <- base::Sys.getenv()
[10:29:57.354]                 names <- names(envs)
[10:29:57.354]                 common <- intersect(names, old_names)
[10:29:57.354]                 added <- setdiff(names, old_names)
[10:29:57.354]                 removed <- setdiff(old_names, names)
[10:29:57.354]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:57.354]                   envs[common]]
[10:29:57.354]                 NAMES <- toupper(changed)
[10:29:57.354]                 args <- list()
[10:29:57.354]                 for (kk in seq_along(NAMES)) {
[10:29:57.354]                   name <- changed[[kk]]
[10:29:57.354]                   NAME <- NAMES[[kk]]
[10:29:57.354]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.354]                     next
[10:29:57.354]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:57.354]                 }
[10:29:57.354]                 NAMES <- toupper(added)
[10:29:57.354]                 for (kk in seq_along(NAMES)) {
[10:29:57.354]                   name <- added[[kk]]
[10:29:57.354]                   NAME <- NAMES[[kk]]
[10:29:57.354]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.354]                     next
[10:29:57.354]                   args[[name]] <- ""
[10:29:57.354]                 }
[10:29:57.354]                 NAMES <- toupper(removed)
[10:29:57.354]                 for (kk in seq_along(NAMES)) {
[10:29:57.354]                   name <- removed[[kk]]
[10:29:57.354]                   NAME <- NAMES[[kk]]
[10:29:57.354]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.354]                     next
[10:29:57.354]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:57.354]                 }
[10:29:57.354]                 if (length(args) > 0) 
[10:29:57.354]                   base::do.call(base::Sys.setenv, args = args)
[10:29:57.354]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:57.354]             }
[10:29:57.354]             else {
[10:29:57.354]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:57.354]             }
[10:29:57.354]             {
[10:29:57.354]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:57.354]                   0L) {
[10:29:57.354]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:57.354]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:57.354]                   base::options(opts)
[10:29:57.354]                 }
[10:29:57.354]                 {
[10:29:57.354]                   {
[10:29:57.354]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:57.354]                     NULL
[10:29:57.354]                   }
[10:29:57.354]                   options(future.plan = NULL)
[10:29:57.354]                   if (is.na(NA_character_)) 
[10:29:57.354]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:57.354]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:57.354]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:57.354]                     .init = FALSE)
[10:29:57.354]                 }
[10:29:57.354]             }
[10:29:57.354]         }
[10:29:57.354]     })
[10:29:57.354]     if (TRUE) {
[10:29:57.354]         base::sink(type = "output", split = FALSE)
[10:29:57.354]         if (TRUE) {
[10:29:57.354]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:57.354]         }
[10:29:57.354]         else {
[10:29:57.354]             ...future.result["stdout"] <- base::list(NULL)
[10:29:57.354]         }
[10:29:57.354]         base::close(...future.stdout)
[10:29:57.354]         ...future.stdout <- NULL
[10:29:57.354]     }
[10:29:57.354]     ...future.result$conditions <- ...future.conditions
[10:29:57.354]     ...future.result$finished <- base::Sys.time()
[10:29:57.354]     ...future.result
[10:29:57.354] }
[10:29:57.358] assign_globals() ...
[10:29:57.358] List of 5
[10:29:57.358]  $ ...future.FUN            :function (x, ...)  
[10:29:57.358]  $ future.call.arguments    :List of 1
[10:29:57.358]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:29:57.358]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.358]  $ ...future.elements_ii    :List of 2
[10:29:57.358]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:29:57.358]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:29:57.358]  $ ...future.seeds_ii       : NULL
[10:29:57.358]  $ ...future.globals.maxSize: NULL
[10:29:57.358]  - attr(*, "where")=List of 5
[10:29:57.358]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:57.358]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:57.358]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:57.358]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:57.358]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:57.358]  - attr(*, "resolved")= logi FALSE
[10:29:57.358]  - attr(*, "total_size")= num 1328
[10:29:57.358]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.358]  - attr(*, "already-done")= logi TRUE
[10:29:57.369] - copied ‘...future.FUN’ to environment
[10:29:57.370] - copied ‘future.call.arguments’ to environment
[10:29:57.370] - copied ‘...future.elements_ii’ to environment
[10:29:57.370] - copied ‘...future.seeds_ii’ to environment
[10:29:57.370] - copied ‘...future.globals.maxSize’ to environment
[10:29:57.371] assign_globals() ... done
[10:29:57.371] requestCore(): workers = 2
[10:29:57.373] MulticoreFuture started
[10:29:57.373] - Launch lazy future ... done
[10:29:57.374] run() for ‘MulticoreFuture’ ... done
[10:29:57.374] Created future:
[10:29:57.375] plan(): Setting new future strategy stack:
[10:29:57.375] List of future strategies:
[10:29:57.375] 1. sequential:
[10:29:57.375]    - args: function (..., envir = parent.frame())
[10:29:57.375]    - tweaked: FALSE
[10:29:57.375]    - call: NULL
[10:29:57.376] plan(): nbrOfWorkers() = 1
[10:29:57.379] plan(): Setting new future strategy stack:
[10:29:57.379] List of future strategies:
[10:29:57.379] 1. multicore:
[10:29:57.379]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:57.379]    - tweaked: FALSE
[10:29:57.379]    - call: plan(strategy)
[10:29:57.385] plan(): nbrOfWorkers() = 2
[10:29:57.374] MulticoreFuture:
[10:29:57.374] Label: ‘future_eapply-2’
[10:29:57.374] Expression:
[10:29:57.374] {
[10:29:57.374]     do.call(function(...) {
[10:29:57.374]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.374]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:57.374]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.374]             on.exit(options(oopts), add = TRUE)
[10:29:57.374]         }
[10:29:57.374]         {
[10:29:57.374]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:57.374]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.374]                 ...future.FUN(...future.X_jj, ...)
[10:29:57.374]             })
[10:29:57.374]         }
[10:29:57.374]     }, args = future.call.arguments)
[10:29:57.374] }
[10:29:57.374] Lazy evaluation: FALSE
[10:29:57.374] Asynchronous evaluation: TRUE
[10:29:57.374] Local evaluation: TRUE
[10:29:57.374] Environment: R_GlobalEnv
[10:29:57.374] Capture standard output: TRUE
[10:29:57.374] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:57.374] Globals: 5 objects totaling 1.50 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:57.374] Packages: 1 packages (‘stats’)
[10:29:57.374] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:57.374] Resolved: TRUE
[10:29:57.374] Value: <not collected>
[10:29:57.374] Conditions captured: <none>
[10:29:57.374] Early signaling: FALSE
[10:29:57.374] Owner process: db6eb61b-64f1-ae95-7e8b-287fbc43411a
[10:29:57.374] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:57.386] Chunk #2 of 2 ... DONE
[10:29:57.386] Launching 2 futures (chunks) ... DONE
[10:29:57.386] Resolving 2 futures (chunks) ...
[10:29:57.387] resolve() on list ...
[10:29:57.387]  recursive: 0
[10:29:57.387]  length: 2
[10:29:57.387] 
[10:29:57.388] Future #1
[10:29:57.388] result() for MulticoreFuture ...
[10:29:57.389] result() for MulticoreFuture ...
[10:29:57.389] result() for MulticoreFuture ... done
[10:29:57.389] result() for MulticoreFuture ... done
[10:29:57.389] result() for MulticoreFuture ...
[10:29:57.389] result() for MulticoreFuture ... done
[10:29:57.390] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:29:57.390] - nx: 2
[10:29:57.390] - relay: TRUE
[10:29:57.390] - stdout: TRUE
[10:29:57.390] - signal: TRUE
[10:29:57.390] - resignal: FALSE
[10:29:57.390] - force: TRUE
[10:29:57.391] - relayed: [n=2] FALSE, FALSE
[10:29:57.391] - queued futures: [n=2] FALSE, FALSE
[10:29:57.391]  - until=1
[10:29:57.391]  - relaying element #1
[10:29:57.391] result() for MulticoreFuture ...
[10:29:57.391] result() for MulticoreFuture ... done
[10:29:57.392] result() for MulticoreFuture ...
[10:29:57.392] result() for MulticoreFuture ... done
[10:29:57.392] result() for MulticoreFuture ...
[10:29:57.392] result() for MulticoreFuture ... done
[10:29:57.392] result() for MulticoreFuture ...
[10:29:57.392] result() for MulticoreFuture ... done
[10:29:57.393] - relayed: [n=2] TRUE, FALSE
[10:29:57.393] - queued futures: [n=2] TRUE, FALSE
[10:29:57.393] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:29:57.393]  length: 1 (resolved future 1)
[10:29:57.394] Future #2
[10:29:57.394] result() for MulticoreFuture ...
[10:29:57.394] result() for MulticoreFuture ...
[10:29:57.395] result() for MulticoreFuture ... done
[10:29:57.395] result() for MulticoreFuture ... done
[10:29:57.395] result() for MulticoreFuture ...
[10:29:57.395] result() for MulticoreFuture ... done
[10:29:57.395] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:29:57.395] - nx: 2
[10:29:57.395] - relay: TRUE
[10:29:57.396] - stdout: TRUE
[10:29:57.396] - signal: TRUE
[10:29:57.396] - resignal: FALSE
[10:29:57.396] - force: TRUE
[10:29:57.396] - relayed: [n=2] TRUE, FALSE
[10:29:57.396] - queued futures: [n=2] TRUE, FALSE
[10:29:57.396]  - until=2
[10:29:57.396]  - relaying element #2
[10:29:57.396] result() for MulticoreFuture ...
[10:29:57.397] result() for MulticoreFuture ... done
[10:29:57.397] result() for MulticoreFuture ...
[10:29:57.397] result() for MulticoreFuture ... done
[10:29:57.397] result() for MulticoreFuture ...
[10:29:57.397] result() for MulticoreFuture ... done
[10:29:57.397] result() for MulticoreFuture ...
[10:29:57.397] result() for MulticoreFuture ... done
[10:29:57.398] - relayed: [n=2] TRUE, TRUE
[10:29:57.398] - queued futures: [n=2] TRUE, TRUE
[10:29:57.398] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:29:57.398]  length: 0 (resolved future 2)
[10:29:57.398] Relaying remaining futures
[10:29:57.398] signalConditionsASAP(NULL, pos=0) ...
[10:29:57.398] - nx: 2
[10:29:57.398] - relay: TRUE
[10:29:57.398] - stdout: TRUE
[10:29:57.399] - signal: TRUE
[10:29:57.399] - resignal: FALSE
[10:29:57.399] - force: TRUE
[10:29:57.399] - relayed: [n=2] TRUE, TRUE
[10:29:57.399] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:57.399] - relayed: [n=2] TRUE, TRUE
[10:29:57.399] - queued futures: [n=2] TRUE, TRUE
[10:29:57.399] signalConditionsASAP(NULL, pos=0) ... done
[10:29:57.399] resolve() on list ... DONE
[10:29:57.400] result() for MulticoreFuture ...
[10:29:57.400] result() for MulticoreFuture ... done
[10:29:57.400] result() for MulticoreFuture ...
[10:29:57.400] result() for MulticoreFuture ... done
[10:29:57.400] result() for MulticoreFuture ...
[10:29:57.400] result() for MulticoreFuture ... done
[10:29:57.400] result() for MulticoreFuture ...
[10:29:57.400] result() for MulticoreFuture ... done
[10:29:57.400]  - Number of value chunks collected: 2
[10:29:57.401] Resolving 2 futures (chunks) ... DONE
[10:29:57.401] Reducing values from 2 chunks ...
[10:29:57.401]  - Number of values collected after concatenation: 3
[10:29:57.401]  - Number of values expected: 3
[10:29:57.401] Reducing values from 2 chunks ... DONE
[10:29:57.401] future_lapply() ... DONE
[10:29:57.402] future_lapply() ...
[10:29:57.407] Number of chunks: 2
[10:29:57.407] getGlobalsAndPackagesXApply() ...
[10:29:57.407]  - future.globals: TRUE
[10:29:57.407] getGlobalsAndPackages() ...
[10:29:57.407] Searching for globals...
[10:29:57.409] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:57.409] Searching for globals ... DONE
[10:29:57.409] Resolving globals: FALSE
[10:29:57.409] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[10:29:57.410] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[10:29:57.410] - globals: [1] ‘FUN’
[10:29:57.410] - packages: [1] ‘stats’
[10:29:57.410] getGlobalsAndPackages() ... DONE
[10:29:57.410]  - globals found/used: [n=1] ‘FUN’
[10:29:57.410]  - needed namespaces: [n=1] ‘stats’
[10:29:57.411] Finding globals ... DONE
[10:29:57.411]  - use_args: TRUE
[10:29:57.411]  - Getting '...' globals ...
[10:29:57.411] resolve() on list ...
[10:29:57.411]  recursive: 0
[10:29:57.411]  length: 1
[10:29:57.412]  elements: ‘...’
[10:29:57.412]  length: 0 (resolved future 1)
[10:29:57.414] resolve() on list ... DONE
[10:29:57.414]    - '...' content: [n=0] 
[10:29:57.414] List of 1
[10:29:57.414]  $ ...: list()
[10:29:57.414]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.414]  - attr(*, "where")=List of 1
[10:29:57.414]   ..$ ...:<environment: 0x55974b731138> 
[10:29:57.414]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.414]  - attr(*, "resolved")= logi TRUE
[10:29:57.414]  - attr(*, "total_size")= num NA
[10:29:57.418]  - Getting '...' globals ... DONE
[10:29:57.418] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:57.418] List of 2
[10:29:57.418]  $ ...future.FUN:function (x, ...)  
[10:29:57.418]  $ ...          : list()
[10:29:57.418]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.418]  - attr(*, "where")=List of 2
[10:29:57.418]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:57.418]   ..$ ...          :<environment: 0x55974b731138> 
[10:29:57.418]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.418]  - attr(*, "resolved")= logi FALSE
[10:29:57.418]  - attr(*, "total_size")= num 1248
[10:29:57.421] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:57.421] getGlobalsAndPackagesXApply() ... DONE
[10:29:57.421] Number of futures (= number of chunks): 2
[10:29:57.421] Launching 2 futures (chunks) ...
[10:29:57.421] Chunk #1 of 2 ...
[10:29:57.422]  - Finding globals in 'X' for chunk #1 ...
[10:29:57.422] getGlobalsAndPackages() ...
[10:29:57.422] Searching for globals...
[10:29:57.422] 
[10:29:57.422] Searching for globals ... DONE
[10:29:57.422] - globals: [0] <none>
[10:29:57.422] getGlobalsAndPackages() ... DONE
[10:29:57.423]    + additional globals found: [n=0] 
[10:29:57.423]    + additional namespaces needed: [n=0] 
[10:29:57.423]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:57.423]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:57.423]  - seeds: <none>
[10:29:57.423]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.423] getGlobalsAndPackages() ...
[10:29:57.423] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.423] Resolving globals: FALSE
[10:29:57.423] Tweak future expression to call with '...' arguments ...
[10:29:57.424] {
[10:29:57.424]     do.call(function(...) {
[10:29:57.424]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.424]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:57.424]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.424]             on.exit(options(oopts), add = TRUE)
[10:29:57.424]         }
[10:29:57.424]         {
[10:29:57.424]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:57.424]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.424]                 ...future.FUN(...future.X_jj, ...)
[10:29:57.424]             })
[10:29:57.424]         }
[10:29:57.424]     }, args = future.call.arguments)
[10:29:57.424] }
[10:29:57.424] Tweak future expression to call with '...' arguments ... DONE
[10:29:57.424] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.424] - packages: [1] ‘stats’
[10:29:57.424] getGlobalsAndPackages() ... DONE
[10:29:57.425] run() for ‘Future’ ...
[10:29:57.425] - state: ‘created’
[10:29:57.425] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:57.429] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:57.429] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:57.429]   - Field: ‘label’
[10:29:57.429]   - Field: ‘local’
[10:29:57.429]   - Field: ‘owner’
[10:29:57.429]   - Field: ‘envir’
[10:29:57.429]   - Field: ‘workers’
[10:29:57.430]   - Field: ‘packages’
[10:29:57.430]   - Field: ‘gc’
[10:29:57.430]   - Field: ‘job’
[10:29:57.430]   - Field: ‘conditions’
[10:29:57.430]   - Field: ‘expr’
[10:29:57.430]   - Field: ‘uuid’
[10:29:57.430]   - Field: ‘seed’
[10:29:57.430]   - Field: ‘version’
[10:29:57.430]   - Field: ‘result’
[10:29:57.430]   - Field: ‘asynchronous’
[10:29:57.430]   - Field: ‘calls’
[10:29:57.431]   - Field: ‘globals’
[10:29:57.431]   - Field: ‘stdout’
[10:29:57.431]   - Field: ‘earlySignal’
[10:29:57.431]   - Field: ‘lazy’
[10:29:57.431]   - Field: ‘state’
[10:29:57.431] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:57.431] - Launch lazy future ...
[10:29:57.431] Packages needed by the future expression (n = 1): ‘stats’
[10:29:57.432] Packages needed by future strategies (n = 0): <none>
[10:29:57.432] {
[10:29:57.432]     {
[10:29:57.432]         {
[10:29:57.432]             ...future.startTime <- base::Sys.time()
[10:29:57.432]             {
[10:29:57.432]                 {
[10:29:57.432]                   {
[10:29:57.432]                     {
[10:29:57.432]                       {
[10:29:57.432]                         base::local({
[10:29:57.432]                           has_future <- base::requireNamespace("future", 
[10:29:57.432]                             quietly = TRUE)
[10:29:57.432]                           if (has_future) {
[10:29:57.432]                             ns <- base::getNamespace("future")
[10:29:57.432]                             version <- ns[[".package"]][["version"]]
[10:29:57.432]                             if (is.null(version)) 
[10:29:57.432]                               version <- utils::packageVersion("future")
[10:29:57.432]                           }
[10:29:57.432]                           else {
[10:29:57.432]                             version <- NULL
[10:29:57.432]                           }
[10:29:57.432]                           if (!has_future || version < "1.8.0") {
[10:29:57.432]                             info <- base::c(r_version = base::gsub("R version ", 
[10:29:57.432]                               "", base::R.version$version.string), 
[10:29:57.432]                               platform = base::sprintf("%s (%s-bit)", 
[10:29:57.432]                                 base::R.version$platform, 8 * 
[10:29:57.432]                                   base::.Machine$sizeof.pointer), 
[10:29:57.432]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:57.432]                                 "release", "version")], collapse = " "), 
[10:29:57.432]                               hostname = base::Sys.info()[["nodename"]])
[10:29:57.432]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:29:57.432]                               info)
[10:29:57.432]                             info <- base::paste(info, collapse = "; ")
[10:29:57.432]                             if (!has_future) {
[10:29:57.432]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:57.432]                                 info)
[10:29:57.432]                             }
[10:29:57.432]                             else {
[10:29:57.432]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:57.432]                                 info, version)
[10:29:57.432]                             }
[10:29:57.432]                             base::stop(msg)
[10:29:57.432]                           }
[10:29:57.432]                         })
[10:29:57.432]                       }
[10:29:57.432]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:57.432]                       base::options(mc.cores = 1L)
[10:29:57.432]                     }
[10:29:57.432]                     base::local({
[10:29:57.432]                       for (pkg in "stats") {
[10:29:57.432]                         base::loadNamespace(pkg)
[10:29:57.432]                         base::library(pkg, character.only = TRUE)
[10:29:57.432]                       }
[10:29:57.432]                     })
[10:29:57.432]                   }
[10:29:57.432]                   ...future.strategy.old <- future::plan("list")
[10:29:57.432]                   options(future.plan = NULL)
[10:29:57.432]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:57.432]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:57.432]                 }
[10:29:57.432]                 ...future.workdir <- getwd()
[10:29:57.432]             }
[10:29:57.432]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:57.432]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:57.432]         }
[10:29:57.432]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:57.432]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:57.432]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:57.432]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:57.432]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:57.432]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:57.432]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:57.432]             base::names(...future.oldOptions))
[10:29:57.432]     }
[10:29:57.432]     if (FALSE) {
[10:29:57.432]     }
[10:29:57.432]     else {
[10:29:57.432]         if (TRUE) {
[10:29:57.432]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:57.432]                 open = "w")
[10:29:57.432]         }
[10:29:57.432]         else {
[10:29:57.432]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:57.432]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:57.432]         }
[10:29:57.432]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:57.432]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:57.432]             base::sink(type = "output", split = FALSE)
[10:29:57.432]             base::close(...future.stdout)
[10:29:57.432]         }, add = TRUE)
[10:29:57.432]     }
[10:29:57.432]     ...future.frame <- base::sys.nframe()
[10:29:57.432]     ...future.conditions <- base::list()
[10:29:57.432]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:57.432]     if (FALSE) {
[10:29:57.432]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:57.432]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:57.432]     }
[10:29:57.432]     ...future.result <- base::tryCatch({
[10:29:57.432]         base::withCallingHandlers({
[10:29:57.432]             ...future.value <- base::withVisible(base::local({
[10:29:57.432]                 withCallingHandlers({
[10:29:57.432]                   {
[10:29:57.432]                     do.call(function(...) {
[10:29:57.432]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.432]                       if (!identical(...future.globals.maxSize.org, 
[10:29:57.432]                         ...future.globals.maxSize)) {
[10:29:57.432]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.432]                         on.exit(options(oopts), add = TRUE)
[10:29:57.432]                       }
[10:29:57.432]                       {
[10:29:57.432]                         lapply(seq_along(...future.elements_ii), 
[10:29:57.432]                           FUN = function(jj) {
[10:29:57.432]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.432]                             ...future.FUN(...future.X_jj, ...)
[10:29:57.432]                           })
[10:29:57.432]                       }
[10:29:57.432]                     }, args = future.call.arguments)
[10:29:57.432]                   }
[10:29:57.432]                 }, immediateCondition = function(cond) {
[10:29:57.432]                   save_rds <- function (object, pathname, ...) 
[10:29:57.432]                   {
[10:29:57.432]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:57.432]                     if (file_test("-f", pathname_tmp)) {
[10:29:57.432]                       fi_tmp <- file.info(pathname_tmp)
[10:29:57.432]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:57.432]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:57.432]                         fi_tmp[["mtime"]])
[10:29:57.432]                     }
[10:29:57.432]                     tryCatch({
[10:29:57.432]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:57.432]                     }, error = function(ex) {
[10:29:57.432]                       msg <- conditionMessage(ex)
[10:29:57.432]                       fi_tmp <- file.info(pathname_tmp)
[10:29:57.432]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:57.432]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:57.432]                         fi_tmp[["mtime"]], msg)
[10:29:57.432]                       ex$message <- msg
[10:29:57.432]                       stop(ex)
[10:29:57.432]                     })
[10:29:57.432]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:57.432]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:57.432]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:57.432]                       fi_tmp <- file.info(pathname_tmp)
[10:29:57.432]                       fi <- file.info(pathname)
[10:29:57.432]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:57.432]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:57.432]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:57.432]                         fi[["size"]], fi[["mtime"]])
[10:29:57.432]                       stop(msg)
[10:29:57.432]                     }
[10:29:57.432]                     invisible(pathname)
[10:29:57.432]                   }
[10:29:57.432]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:57.432]                     rootPath = tempdir()) 
[10:29:57.432]                   {
[10:29:57.432]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:57.432]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:57.432]                       tmpdir = path, fileext = ".rds")
[10:29:57.432]                     save_rds(obj, file)
[10:29:57.432]                   }
[10:29:57.432]                   saveImmediateCondition(cond, path = "/tmp/RtmpoCSmtD/.future/immediateConditions")
[10:29:57.432]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.432]                   {
[10:29:57.432]                     inherits <- base::inherits
[10:29:57.432]                     invokeRestart <- base::invokeRestart
[10:29:57.432]                     is.null <- base::is.null
[10:29:57.432]                     muffled <- FALSE
[10:29:57.432]                     if (inherits(cond, "message")) {
[10:29:57.432]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:57.432]                       if (muffled) 
[10:29:57.432]                         invokeRestart("muffleMessage")
[10:29:57.432]                     }
[10:29:57.432]                     else if (inherits(cond, "warning")) {
[10:29:57.432]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:57.432]                       if (muffled) 
[10:29:57.432]                         invokeRestart("muffleWarning")
[10:29:57.432]                     }
[10:29:57.432]                     else if (inherits(cond, "condition")) {
[10:29:57.432]                       if (!is.null(pattern)) {
[10:29:57.432]                         computeRestarts <- base::computeRestarts
[10:29:57.432]                         grepl <- base::grepl
[10:29:57.432]                         restarts <- computeRestarts(cond)
[10:29:57.432]                         for (restart in restarts) {
[10:29:57.432]                           name <- restart$name
[10:29:57.432]                           if (is.null(name)) 
[10:29:57.432]                             next
[10:29:57.432]                           if (!grepl(pattern, name)) 
[10:29:57.432]                             next
[10:29:57.432]                           invokeRestart(restart)
[10:29:57.432]                           muffled <- TRUE
[10:29:57.432]                           break
[10:29:57.432]                         }
[10:29:57.432]                       }
[10:29:57.432]                     }
[10:29:57.432]                     invisible(muffled)
[10:29:57.432]                   }
[10:29:57.432]                   muffleCondition(cond)
[10:29:57.432]                 })
[10:29:57.432]             }))
[10:29:57.432]             future::FutureResult(value = ...future.value$value, 
[10:29:57.432]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:57.432]                   ...future.rng), globalenv = if (FALSE) 
[10:29:57.432]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:57.432]                     ...future.globalenv.names))
[10:29:57.432]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:57.432]         }, condition = base::local({
[10:29:57.432]             c <- base::c
[10:29:57.432]             inherits <- base::inherits
[10:29:57.432]             invokeRestart <- base::invokeRestart
[10:29:57.432]             length <- base::length
[10:29:57.432]             list <- base::list
[10:29:57.432]             seq.int <- base::seq.int
[10:29:57.432]             signalCondition <- base::signalCondition
[10:29:57.432]             sys.calls <- base::sys.calls
[10:29:57.432]             `[[` <- base::`[[`
[10:29:57.432]             `+` <- base::`+`
[10:29:57.432]             `<<-` <- base::`<<-`
[10:29:57.432]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:57.432]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:57.432]                   3L)]
[10:29:57.432]             }
[10:29:57.432]             function(cond) {
[10:29:57.432]                 is_error <- inherits(cond, "error")
[10:29:57.432]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:57.432]                   NULL)
[10:29:57.432]                 if (is_error) {
[10:29:57.432]                   sessionInformation <- function() {
[10:29:57.432]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:57.432]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:57.432]                       search = base::search(), system = base::Sys.info())
[10:29:57.432]                   }
[10:29:57.432]                   ...future.conditions[[length(...future.conditions) + 
[10:29:57.432]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:57.432]                     cond$call), session = sessionInformation(), 
[10:29:57.432]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:57.432]                   signalCondition(cond)
[10:29:57.432]                 }
[10:29:57.432]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:57.432]                 "immediateCondition"))) {
[10:29:57.432]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:57.432]                   ...future.conditions[[length(...future.conditions) + 
[10:29:57.432]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:57.432]                   if (TRUE && !signal) {
[10:29:57.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.432]                     {
[10:29:57.432]                       inherits <- base::inherits
[10:29:57.432]                       invokeRestart <- base::invokeRestart
[10:29:57.432]                       is.null <- base::is.null
[10:29:57.432]                       muffled <- FALSE
[10:29:57.432]                       if (inherits(cond, "message")) {
[10:29:57.432]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:57.432]                         if (muffled) 
[10:29:57.432]                           invokeRestart("muffleMessage")
[10:29:57.432]                       }
[10:29:57.432]                       else if (inherits(cond, "warning")) {
[10:29:57.432]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:57.432]                         if (muffled) 
[10:29:57.432]                           invokeRestart("muffleWarning")
[10:29:57.432]                       }
[10:29:57.432]                       else if (inherits(cond, "condition")) {
[10:29:57.432]                         if (!is.null(pattern)) {
[10:29:57.432]                           computeRestarts <- base::computeRestarts
[10:29:57.432]                           grepl <- base::grepl
[10:29:57.432]                           restarts <- computeRestarts(cond)
[10:29:57.432]                           for (restart in restarts) {
[10:29:57.432]                             name <- restart$name
[10:29:57.432]                             if (is.null(name)) 
[10:29:57.432]                               next
[10:29:57.432]                             if (!grepl(pattern, name)) 
[10:29:57.432]                               next
[10:29:57.432]                             invokeRestart(restart)
[10:29:57.432]                             muffled <- TRUE
[10:29:57.432]                             break
[10:29:57.432]                           }
[10:29:57.432]                         }
[10:29:57.432]                       }
[10:29:57.432]                       invisible(muffled)
[10:29:57.432]                     }
[10:29:57.432]                     muffleCondition(cond, pattern = "^muffle")
[10:29:57.432]                   }
[10:29:57.432]                 }
[10:29:57.432]                 else {
[10:29:57.432]                   if (TRUE) {
[10:29:57.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.432]                     {
[10:29:57.432]                       inherits <- base::inherits
[10:29:57.432]                       invokeRestart <- base::invokeRestart
[10:29:57.432]                       is.null <- base::is.null
[10:29:57.432]                       muffled <- FALSE
[10:29:57.432]                       if (inherits(cond, "message")) {
[10:29:57.432]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:57.432]                         if (muffled) 
[10:29:57.432]                           invokeRestart("muffleMessage")
[10:29:57.432]                       }
[10:29:57.432]                       else if (inherits(cond, "warning")) {
[10:29:57.432]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:57.432]                         if (muffled) 
[10:29:57.432]                           invokeRestart("muffleWarning")
[10:29:57.432]                       }
[10:29:57.432]                       else if (inherits(cond, "condition")) {
[10:29:57.432]                         if (!is.null(pattern)) {
[10:29:57.432]                           computeRestarts <- base::computeRestarts
[10:29:57.432]                           grepl <- base::grepl
[10:29:57.432]                           restarts <- computeRestarts(cond)
[10:29:57.432]                           for (restart in restarts) {
[10:29:57.432]                             name <- restart$name
[10:29:57.432]                             if (is.null(name)) 
[10:29:57.432]                               next
[10:29:57.432]                             if (!grepl(pattern, name)) 
[10:29:57.432]                               next
[10:29:57.432]                             invokeRestart(restart)
[10:29:57.432]                             muffled <- TRUE
[10:29:57.432]                             break
[10:29:57.432]                           }
[10:29:57.432]                         }
[10:29:57.432]                       }
[10:29:57.432]                       invisible(muffled)
[10:29:57.432]                     }
[10:29:57.432]                     muffleCondition(cond, pattern = "^muffle")
[10:29:57.432]                   }
[10:29:57.432]                 }
[10:29:57.432]             }
[10:29:57.432]         }))
[10:29:57.432]     }, error = function(ex) {
[10:29:57.432]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:57.432]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:57.432]                 ...future.rng), started = ...future.startTime, 
[10:29:57.432]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:57.432]             version = "1.8"), class = "FutureResult")
[10:29:57.432]     }, finally = {
[10:29:57.432]         if (!identical(...future.workdir, getwd())) 
[10:29:57.432]             setwd(...future.workdir)
[10:29:57.432]         {
[10:29:57.432]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:57.432]                 ...future.oldOptions$nwarnings <- NULL
[10:29:57.432]             }
[10:29:57.432]             base::options(...future.oldOptions)
[10:29:57.432]             if (.Platform$OS.type == "windows") {
[10:29:57.432]                 old_names <- names(...future.oldEnvVars)
[10:29:57.432]                 envs <- base::Sys.getenv()
[10:29:57.432]                 names <- names(envs)
[10:29:57.432]                 common <- intersect(names, old_names)
[10:29:57.432]                 added <- setdiff(names, old_names)
[10:29:57.432]                 removed <- setdiff(old_names, names)
[10:29:57.432]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:57.432]                   envs[common]]
[10:29:57.432]                 NAMES <- toupper(changed)
[10:29:57.432]                 args <- list()
[10:29:57.432]                 for (kk in seq_along(NAMES)) {
[10:29:57.432]                   name <- changed[[kk]]
[10:29:57.432]                   NAME <- NAMES[[kk]]
[10:29:57.432]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.432]                     next
[10:29:57.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:57.432]                 }
[10:29:57.432]                 NAMES <- toupper(added)
[10:29:57.432]                 for (kk in seq_along(NAMES)) {
[10:29:57.432]                   name <- added[[kk]]
[10:29:57.432]                   NAME <- NAMES[[kk]]
[10:29:57.432]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.432]                     next
[10:29:57.432]                   args[[name]] <- ""
[10:29:57.432]                 }
[10:29:57.432]                 NAMES <- toupper(removed)
[10:29:57.432]                 for (kk in seq_along(NAMES)) {
[10:29:57.432]                   name <- removed[[kk]]
[10:29:57.432]                   NAME <- NAMES[[kk]]
[10:29:57.432]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.432]                     next
[10:29:57.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:57.432]                 }
[10:29:57.432]                 if (length(args) > 0) 
[10:29:57.432]                   base::do.call(base::Sys.setenv, args = args)
[10:29:57.432]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:57.432]             }
[10:29:57.432]             else {
[10:29:57.432]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:57.432]             }
[10:29:57.432]             {
[10:29:57.432]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:57.432]                   0L) {
[10:29:57.432]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:57.432]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:57.432]                   base::options(opts)
[10:29:57.432]                 }
[10:29:57.432]                 {
[10:29:57.432]                   {
[10:29:57.432]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:57.432]                     NULL
[10:29:57.432]                   }
[10:29:57.432]                   options(future.plan = NULL)
[10:29:57.432]                   if (is.na(NA_character_)) 
[10:29:57.432]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:57.432]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:57.432]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:57.432]                     .init = FALSE)
[10:29:57.432]                 }
[10:29:57.432]             }
[10:29:57.432]         }
[10:29:57.432]     })
[10:29:57.432]     if (TRUE) {
[10:29:57.432]         base::sink(type = "output", split = FALSE)
[10:29:57.432]         if (TRUE) {
[10:29:57.432]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:57.432]         }
[10:29:57.432]         else {
[10:29:57.432]             ...future.result["stdout"] <- base::list(NULL)
[10:29:57.432]         }
[10:29:57.432]         base::close(...future.stdout)
[10:29:57.432]         ...future.stdout <- NULL
[10:29:57.432]     }
[10:29:57.432]     ...future.result$conditions <- ...future.conditions
[10:29:57.432]     ...future.result$finished <- base::Sys.time()
[10:29:57.432]     ...future.result
[10:29:57.432] }
[10:29:57.435] assign_globals() ...
[10:29:57.435] List of 5
[10:29:57.435]  $ ...future.FUN            :function (x, ...)  
[10:29:57.435]  $ future.call.arguments    : list()
[10:29:57.435]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.435]  $ ...future.elements_ii    :List of 1
[10:29:57.435]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[10:29:57.435]  $ ...future.seeds_ii       : NULL
[10:29:57.435]  $ ...future.globals.maxSize: NULL
[10:29:57.435]  - attr(*, "where")=List of 5
[10:29:57.435]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:57.435]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:57.435]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:57.435]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:57.435]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:57.435]  - attr(*, "resolved")= logi FALSE
[10:29:57.435]  - attr(*, "total_size")= num 1248
[10:29:57.435]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.435]  - attr(*, "already-done")= logi TRUE
[10:29:57.442] - copied ‘...future.FUN’ to environment
[10:29:57.442] - copied ‘future.call.arguments’ to environment
[10:29:57.442] - copied ‘...future.elements_ii’ to environment
[10:29:57.442] - copied ‘...future.seeds_ii’ to environment
[10:29:57.442] - copied ‘...future.globals.maxSize’ to environment
[10:29:57.442] assign_globals() ... done
[10:29:57.442] requestCore(): workers = 2
[10:29:57.445] MulticoreFuture started
[10:29:57.445] - Launch lazy future ... done
[10:29:57.445] run() for ‘MulticoreFuture’ ... done
[10:29:57.446] Created future:
[10:29:57.446] plan(): Setting new future strategy stack:
[10:29:57.447] List of future strategies:
[10:29:57.447] 1. sequential:
[10:29:57.447]    - args: function (..., envir = parent.frame())
[10:29:57.447]    - tweaked: FALSE
[10:29:57.447]    - call: NULL
[10:29:57.448] plan(): nbrOfWorkers() = 1
[10:29:57.450] plan(): Setting new future strategy stack:
[10:29:57.451] List of future strategies:
[10:29:57.451] 1. multicore:
[10:29:57.451]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:57.451]    - tweaked: FALSE
[10:29:57.451]    - call: plan(strategy)
[10:29:57.456] plan(): nbrOfWorkers() = 2
[10:29:57.446] MulticoreFuture:
[10:29:57.446] Label: ‘future_eapply-1’
[10:29:57.446] Expression:
[10:29:57.446] {
[10:29:57.446]     do.call(function(...) {
[10:29:57.446]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.446]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:57.446]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.446]             on.exit(options(oopts), add = TRUE)
[10:29:57.446]         }
[10:29:57.446]         {
[10:29:57.446]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:57.446]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.446]                 ...future.FUN(...future.X_jj, ...)
[10:29:57.446]             })
[10:29:57.446]         }
[10:29:57.446]     }, args = future.call.arguments)
[10:29:57.446] }
[10:29:57.446] Lazy evaluation: FALSE
[10:29:57.446] Asynchronous evaluation: TRUE
[10:29:57.446] Local evaluation: TRUE
[10:29:57.446] Environment: R_GlobalEnv
[10:29:57.446] Capture standard output: TRUE
[10:29:57.446] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:57.446] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:57.446] Packages: 1 packages (‘stats’)
[10:29:57.446] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:57.446] Resolved: TRUE
[10:29:57.446] Value: <not collected>
[10:29:57.446] Conditions captured: <none>
[10:29:57.446] Early signaling: FALSE
[10:29:57.446] Owner process: db6eb61b-64f1-ae95-7e8b-287fbc43411a
[10:29:57.446] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:57.457] Chunk #1 of 2 ... DONE
[10:29:57.458] Chunk #2 of 2 ...
[10:29:57.458]  - Finding globals in 'X' for chunk #2 ...
[10:29:57.458] getGlobalsAndPackages() ...
[10:29:57.458] Searching for globals...
[10:29:57.459] 
[10:29:57.459] Searching for globals ... DONE
[10:29:57.459] - globals: [0] <none>
[10:29:57.459] getGlobalsAndPackages() ... DONE
[10:29:57.459]    + additional globals found: [n=0] 
[10:29:57.459]    + additional namespaces needed: [n=0] 
[10:29:57.460]  - Finding globals in 'X' for chunk #2 ... DONE
[10:29:57.460]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:57.460]  - seeds: <none>
[10:29:57.460]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.460] getGlobalsAndPackages() ...
[10:29:57.460] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.461] Resolving globals: FALSE
[10:29:57.461] Tweak future expression to call with '...' arguments ...
[10:29:57.461] {
[10:29:57.461]     do.call(function(...) {
[10:29:57.461]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.461]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:57.461]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.461]             on.exit(options(oopts), add = TRUE)
[10:29:57.461]         }
[10:29:57.461]         {
[10:29:57.461]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:57.461]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.461]                 ...future.FUN(...future.X_jj, ...)
[10:29:57.461]             })
[10:29:57.461]         }
[10:29:57.461]     }, args = future.call.arguments)
[10:29:57.461] }
[10:29:57.461] Tweak future expression to call with '...' arguments ... DONE
[10:29:57.462] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.462] - packages: [1] ‘stats’
[10:29:57.462] getGlobalsAndPackages() ... DONE
[10:29:57.463] run() for ‘Future’ ...
[10:29:57.463] - state: ‘created’
[10:29:57.463] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:57.468] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:57.468] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:57.468]   - Field: ‘label’
[10:29:57.469]   - Field: ‘local’
[10:29:57.469]   - Field: ‘owner’
[10:29:57.469]   - Field: ‘envir’
[10:29:57.469]   - Field: ‘workers’
[10:29:57.469]   - Field: ‘packages’
[10:29:57.469]   - Field: ‘gc’
[10:29:57.470]   - Field: ‘job’
[10:29:57.470]   - Field: ‘conditions’
[10:29:57.470]   - Field: ‘expr’
[10:29:57.470]   - Field: ‘uuid’
[10:29:57.470]   - Field: ‘seed’
[10:29:57.470]   - Field: ‘version’
[10:29:57.471]   - Field: ‘result’
[10:29:57.471]   - Field: ‘asynchronous’
[10:29:57.471]   - Field: ‘calls’
[10:29:57.471]   - Field: ‘globals’
[10:29:57.471]   - Field: ‘stdout’
[10:29:57.471]   - Field: ‘earlySignal’
[10:29:57.471]   - Field: ‘lazy’
[10:29:57.472]   - Field: ‘state’
[10:29:57.472] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:57.472] - Launch lazy future ...
[10:29:57.472] Packages needed by the future expression (n = 1): ‘stats’
[10:29:57.472] Packages needed by future strategies (n = 0): <none>
[10:29:57.473] {
[10:29:57.473]     {
[10:29:57.473]         {
[10:29:57.473]             ...future.startTime <- base::Sys.time()
[10:29:57.473]             {
[10:29:57.473]                 {
[10:29:57.473]                   {
[10:29:57.473]                     {
[10:29:57.473]                       {
[10:29:57.473]                         base::local({
[10:29:57.473]                           has_future <- base::requireNamespace("future", 
[10:29:57.473]                             quietly = TRUE)
[10:29:57.473]                           if (has_future) {
[10:29:57.473]                             ns <- base::getNamespace("future")
[10:29:57.473]                             version <- ns[[".package"]][["version"]]
[10:29:57.473]                             if (is.null(version)) 
[10:29:57.473]                               version <- utils::packageVersion("future")
[10:29:57.473]                           }
[10:29:57.473]                           else {
[10:29:57.473]                             version <- NULL
[10:29:57.473]                           }
[10:29:57.473]                           if (!has_future || version < "1.8.0") {
[10:29:57.473]                             info <- base::c(r_version = base::gsub("R version ", 
[10:29:57.473]                               "", base::R.version$version.string), 
[10:29:57.473]                               platform = base::sprintf("%s (%s-bit)", 
[10:29:57.473]                                 base::R.version$platform, 8 * 
[10:29:57.473]                                   base::.Machine$sizeof.pointer), 
[10:29:57.473]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:57.473]                                 "release", "version")], collapse = " "), 
[10:29:57.473]                               hostname = base::Sys.info()[["nodename"]])
[10:29:57.473]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:29:57.473]                               info)
[10:29:57.473]                             info <- base::paste(info, collapse = "; ")
[10:29:57.473]                             if (!has_future) {
[10:29:57.473]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:57.473]                                 info)
[10:29:57.473]                             }
[10:29:57.473]                             else {
[10:29:57.473]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:57.473]                                 info, version)
[10:29:57.473]                             }
[10:29:57.473]                             base::stop(msg)
[10:29:57.473]                           }
[10:29:57.473]                         })
[10:29:57.473]                       }
[10:29:57.473]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:57.473]                       base::options(mc.cores = 1L)
[10:29:57.473]                     }
[10:29:57.473]                     base::local({
[10:29:57.473]                       for (pkg in "stats") {
[10:29:57.473]                         base::loadNamespace(pkg)
[10:29:57.473]                         base::library(pkg, character.only = TRUE)
[10:29:57.473]                       }
[10:29:57.473]                     })
[10:29:57.473]                   }
[10:29:57.473]                   ...future.strategy.old <- future::plan("list")
[10:29:57.473]                   options(future.plan = NULL)
[10:29:57.473]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:57.473]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:57.473]                 }
[10:29:57.473]                 ...future.workdir <- getwd()
[10:29:57.473]             }
[10:29:57.473]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:57.473]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:57.473]         }
[10:29:57.473]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:57.473]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:57.473]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:57.473]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:57.473]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:57.473]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:57.473]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:57.473]             base::names(...future.oldOptions))
[10:29:57.473]     }
[10:29:57.473]     if (FALSE) {
[10:29:57.473]     }
[10:29:57.473]     else {
[10:29:57.473]         if (TRUE) {
[10:29:57.473]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:57.473]                 open = "w")
[10:29:57.473]         }
[10:29:57.473]         else {
[10:29:57.473]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:57.473]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:57.473]         }
[10:29:57.473]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:57.473]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:57.473]             base::sink(type = "output", split = FALSE)
[10:29:57.473]             base::close(...future.stdout)
[10:29:57.473]         }, add = TRUE)
[10:29:57.473]     }
[10:29:57.473]     ...future.frame <- base::sys.nframe()
[10:29:57.473]     ...future.conditions <- base::list()
[10:29:57.473]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:57.473]     if (FALSE) {
[10:29:57.473]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:57.473]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:57.473]     }
[10:29:57.473]     ...future.result <- base::tryCatch({
[10:29:57.473]         base::withCallingHandlers({
[10:29:57.473]             ...future.value <- base::withVisible(base::local({
[10:29:57.473]                 withCallingHandlers({
[10:29:57.473]                   {
[10:29:57.473]                     do.call(function(...) {
[10:29:57.473]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.473]                       if (!identical(...future.globals.maxSize.org, 
[10:29:57.473]                         ...future.globals.maxSize)) {
[10:29:57.473]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.473]                         on.exit(options(oopts), add = TRUE)
[10:29:57.473]                       }
[10:29:57.473]                       {
[10:29:57.473]                         lapply(seq_along(...future.elements_ii), 
[10:29:57.473]                           FUN = function(jj) {
[10:29:57.473]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.473]                             ...future.FUN(...future.X_jj, ...)
[10:29:57.473]                           })
[10:29:57.473]                       }
[10:29:57.473]                     }, args = future.call.arguments)
[10:29:57.473]                   }
[10:29:57.473]                 }, immediateCondition = function(cond) {
[10:29:57.473]                   save_rds <- function (object, pathname, ...) 
[10:29:57.473]                   {
[10:29:57.473]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:57.473]                     if (file_test("-f", pathname_tmp)) {
[10:29:57.473]                       fi_tmp <- file.info(pathname_tmp)
[10:29:57.473]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:57.473]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:57.473]                         fi_tmp[["mtime"]])
[10:29:57.473]                     }
[10:29:57.473]                     tryCatch({
[10:29:57.473]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:57.473]                     }, error = function(ex) {
[10:29:57.473]                       msg <- conditionMessage(ex)
[10:29:57.473]                       fi_tmp <- file.info(pathname_tmp)
[10:29:57.473]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:57.473]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:57.473]                         fi_tmp[["mtime"]], msg)
[10:29:57.473]                       ex$message <- msg
[10:29:57.473]                       stop(ex)
[10:29:57.473]                     })
[10:29:57.473]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:57.473]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:57.473]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:57.473]                       fi_tmp <- file.info(pathname_tmp)
[10:29:57.473]                       fi <- file.info(pathname)
[10:29:57.473]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:57.473]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:57.473]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:57.473]                         fi[["size"]], fi[["mtime"]])
[10:29:57.473]                       stop(msg)
[10:29:57.473]                     }
[10:29:57.473]                     invisible(pathname)
[10:29:57.473]                   }
[10:29:57.473]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:57.473]                     rootPath = tempdir()) 
[10:29:57.473]                   {
[10:29:57.473]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:57.473]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:57.473]                       tmpdir = path, fileext = ".rds")
[10:29:57.473]                     save_rds(obj, file)
[10:29:57.473]                   }
[10:29:57.473]                   saveImmediateCondition(cond, path = "/tmp/RtmpoCSmtD/.future/immediateConditions")
[10:29:57.473]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.473]                   {
[10:29:57.473]                     inherits <- base::inherits
[10:29:57.473]                     invokeRestart <- base::invokeRestart
[10:29:57.473]                     is.null <- base::is.null
[10:29:57.473]                     muffled <- FALSE
[10:29:57.473]                     if (inherits(cond, "message")) {
[10:29:57.473]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:57.473]                       if (muffled) 
[10:29:57.473]                         invokeRestart("muffleMessage")
[10:29:57.473]                     }
[10:29:57.473]                     else if (inherits(cond, "warning")) {
[10:29:57.473]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:57.473]                       if (muffled) 
[10:29:57.473]                         invokeRestart("muffleWarning")
[10:29:57.473]                     }
[10:29:57.473]                     else if (inherits(cond, "condition")) {
[10:29:57.473]                       if (!is.null(pattern)) {
[10:29:57.473]                         computeRestarts <- base::computeRestarts
[10:29:57.473]                         grepl <- base::grepl
[10:29:57.473]                         restarts <- computeRestarts(cond)
[10:29:57.473]                         for (restart in restarts) {
[10:29:57.473]                           name <- restart$name
[10:29:57.473]                           if (is.null(name)) 
[10:29:57.473]                             next
[10:29:57.473]                           if (!grepl(pattern, name)) 
[10:29:57.473]                             next
[10:29:57.473]                           invokeRestart(restart)
[10:29:57.473]                           muffled <- TRUE
[10:29:57.473]                           break
[10:29:57.473]                         }
[10:29:57.473]                       }
[10:29:57.473]                     }
[10:29:57.473]                     invisible(muffled)
[10:29:57.473]                   }
[10:29:57.473]                   muffleCondition(cond)
[10:29:57.473]                 })
[10:29:57.473]             }))
[10:29:57.473]             future::FutureResult(value = ...future.value$value, 
[10:29:57.473]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:57.473]                   ...future.rng), globalenv = if (FALSE) 
[10:29:57.473]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:57.473]                     ...future.globalenv.names))
[10:29:57.473]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:57.473]         }, condition = base::local({
[10:29:57.473]             c <- base::c
[10:29:57.473]             inherits <- base::inherits
[10:29:57.473]             invokeRestart <- base::invokeRestart
[10:29:57.473]             length <- base::length
[10:29:57.473]             list <- base::list
[10:29:57.473]             seq.int <- base::seq.int
[10:29:57.473]             signalCondition <- base::signalCondition
[10:29:57.473]             sys.calls <- base::sys.calls
[10:29:57.473]             `[[` <- base::`[[`
[10:29:57.473]             `+` <- base::`+`
[10:29:57.473]             `<<-` <- base::`<<-`
[10:29:57.473]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:57.473]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:57.473]                   3L)]
[10:29:57.473]             }
[10:29:57.473]             function(cond) {
[10:29:57.473]                 is_error <- inherits(cond, "error")
[10:29:57.473]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:57.473]                   NULL)
[10:29:57.473]                 if (is_error) {
[10:29:57.473]                   sessionInformation <- function() {
[10:29:57.473]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:57.473]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:57.473]                       search = base::search(), system = base::Sys.info())
[10:29:57.473]                   }
[10:29:57.473]                   ...future.conditions[[length(...future.conditions) + 
[10:29:57.473]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:57.473]                     cond$call), session = sessionInformation(), 
[10:29:57.473]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:57.473]                   signalCondition(cond)
[10:29:57.473]                 }
[10:29:57.473]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:57.473]                 "immediateCondition"))) {
[10:29:57.473]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:57.473]                   ...future.conditions[[length(...future.conditions) + 
[10:29:57.473]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:57.473]                   if (TRUE && !signal) {
[10:29:57.473]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.473]                     {
[10:29:57.473]                       inherits <- base::inherits
[10:29:57.473]                       invokeRestart <- base::invokeRestart
[10:29:57.473]                       is.null <- base::is.null
[10:29:57.473]                       muffled <- FALSE
[10:29:57.473]                       if (inherits(cond, "message")) {
[10:29:57.473]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:57.473]                         if (muffled) 
[10:29:57.473]                           invokeRestart("muffleMessage")
[10:29:57.473]                       }
[10:29:57.473]                       else if (inherits(cond, "warning")) {
[10:29:57.473]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:57.473]                         if (muffled) 
[10:29:57.473]                           invokeRestart("muffleWarning")
[10:29:57.473]                       }
[10:29:57.473]                       else if (inherits(cond, "condition")) {
[10:29:57.473]                         if (!is.null(pattern)) {
[10:29:57.473]                           computeRestarts <- base::computeRestarts
[10:29:57.473]                           grepl <- base::grepl
[10:29:57.473]                           restarts <- computeRestarts(cond)
[10:29:57.473]                           for (restart in restarts) {
[10:29:57.473]                             name <- restart$name
[10:29:57.473]                             if (is.null(name)) 
[10:29:57.473]                               next
[10:29:57.473]                             if (!grepl(pattern, name)) 
[10:29:57.473]                               next
[10:29:57.473]                             invokeRestart(restart)
[10:29:57.473]                             muffled <- TRUE
[10:29:57.473]                             break
[10:29:57.473]                           }
[10:29:57.473]                         }
[10:29:57.473]                       }
[10:29:57.473]                       invisible(muffled)
[10:29:57.473]                     }
[10:29:57.473]                     muffleCondition(cond, pattern = "^muffle")
[10:29:57.473]                   }
[10:29:57.473]                 }
[10:29:57.473]                 else {
[10:29:57.473]                   if (TRUE) {
[10:29:57.473]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.473]                     {
[10:29:57.473]                       inherits <- base::inherits
[10:29:57.473]                       invokeRestart <- base::invokeRestart
[10:29:57.473]                       is.null <- base::is.null
[10:29:57.473]                       muffled <- FALSE
[10:29:57.473]                       if (inherits(cond, "message")) {
[10:29:57.473]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:57.473]                         if (muffled) 
[10:29:57.473]                           invokeRestart("muffleMessage")
[10:29:57.473]                       }
[10:29:57.473]                       else if (inherits(cond, "warning")) {
[10:29:57.473]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:57.473]                         if (muffled) 
[10:29:57.473]                           invokeRestart("muffleWarning")
[10:29:57.473]                       }
[10:29:57.473]                       else if (inherits(cond, "condition")) {
[10:29:57.473]                         if (!is.null(pattern)) {
[10:29:57.473]                           computeRestarts <- base::computeRestarts
[10:29:57.473]                           grepl <- base::grepl
[10:29:57.473]                           restarts <- computeRestarts(cond)
[10:29:57.473]                           for (restart in restarts) {
[10:29:57.473]                             name <- restart$name
[10:29:57.473]                             if (is.null(name)) 
[10:29:57.473]                               next
[10:29:57.473]                             if (!grepl(pattern, name)) 
[10:29:57.473]                               next
[10:29:57.473]                             invokeRestart(restart)
[10:29:57.473]                             muffled <- TRUE
[10:29:57.473]                             break
[10:29:57.473]                           }
[10:29:57.473]                         }
[10:29:57.473]                       }
[10:29:57.473]                       invisible(muffled)
[10:29:57.473]                     }
[10:29:57.473]                     muffleCondition(cond, pattern = "^muffle")
[10:29:57.473]                   }
[10:29:57.473]                 }
[10:29:57.473]             }
[10:29:57.473]         }))
[10:29:57.473]     }, error = function(ex) {
[10:29:57.473]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:57.473]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:57.473]                 ...future.rng), started = ...future.startTime, 
[10:29:57.473]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:57.473]             version = "1.8"), class = "FutureResult")
[10:29:57.473]     }, finally = {
[10:29:57.473]         if (!identical(...future.workdir, getwd())) 
[10:29:57.473]             setwd(...future.workdir)
[10:29:57.473]         {
[10:29:57.473]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:57.473]                 ...future.oldOptions$nwarnings <- NULL
[10:29:57.473]             }
[10:29:57.473]             base::options(...future.oldOptions)
[10:29:57.473]             if (.Platform$OS.type == "windows") {
[10:29:57.473]                 old_names <- names(...future.oldEnvVars)
[10:29:57.473]                 envs <- base::Sys.getenv()
[10:29:57.473]                 names <- names(envs)
[10:29:57.473]                 common <- intersect(names, old_names)
[10:29:57.473]                 added <- setdiff(names, old_names)
[10:29:57.473]                 removed <- setdiff(old_names, names)
[10:29:57.473]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:57.473]                   envs[common]]
[10:29:57.473]                 NAMES <- toupper(changed)
[10:29:57.473]                 args <- list()
[10:29:57.473]                 for (kk in seq_along(NAMES)) {
[10:29:57.473]                   name <- changed[[kk]]
[10:29:57.473]                   NAME <- NAMES[[kk]]
[10:29:57.473]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.473]                     next
[10:29:57.473]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:57.473]                 }
[10:29:57.473]                 NAMES <- toupper(added)
[10:29:57.473]                 for (kk in seq_along(NAMES)) {
[10:29:57.473]                   name <- added[[kk]]
[10:29:57.473]                   NAME <- NAMES[[kk]]
[10:29:57.473]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.473]                     next
[10:29:57.473]                   args[[name]] <- ""
[10:29:57.473]                 }
[10:29:57.473]                 NAMES <- toupper(removed)
[10:29:57.473]                 for (kk in seq_along(NAMES)) {
[10:29:57.473]                   name <- removed[[kk]]
[10:29:57.473]                   NAME <- NAMES[[kk]]
[10:29:57.473]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.473]                     next
[10:29:57.473]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:57.473]                 }
[10:29:57.473]                 if (length(args) > 0) 
[10:29:57.473]                   base::do.call(base::Sys.setenv, args = args)
[10:29:57.473]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:57.473]             }
[10:29:57.473]             else {
[10:29:57.473]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:57.473]             }
[10:29:57.473]             {
[10:29:57.473]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:57.473]                   0L) {
[10:29:57.473]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:57.473]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:57.473]                   base::options(opts)
[10:29:57.473]                 }
[10:29:57.473]                 {
[10:29:57.473]                   {
[10:29:57.473]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:57.473]                     NULL
[10:29:57.473]                   }
[10:29:57.473]                   options(future.plan = NULL)
[10:29:57.473]                   if (is.na(NA_character_)) 
[10:29:57.473]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:57.473]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:57.473]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:57.473]                     .init = FALSE)
[10:29:57.473]                 }
[10:29:57.473]             }
[10:29:57.473]         }
[10:29:57.473]     })
[10:29:57.473]     if (TRUE) {
[10:29:57.473]         base::sink(type = "output", split = FALSE)
[10:29:57.473]         if (TRUE) {
[10:29:57.473]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:57.473]         }
[10:29:57.473]         else {
[10:29:57.473]             ...future.result["stdout"] <- base::list(NULL)
[10:29:57.473]         }
[10:29:57.473]         base::close(...future.stdout)
[10:29:57.473]         ...future.stdout <- NULL
[10:29:57.473]     }
[10:29:57.473]     ...future.result$conditions <- ...future.conditions
[10:29:57.473]     ...future.result$finished <- base::Sys.time()
[10:29:57.473]     ...future.result
[10:29:57.473] }
[10:29:57.477] assign_globals() ...
[10:29:57.477] List of 5
[10:29:57.477]  $ ...future.FUN            :function (x, ...)  
[10:29:57.477]  $ future.call.arguments    : list()
[10:29:57.477]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.477]  $ ...future.elements_ii    :List of 2
[10:29:57.477]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:29:57.477]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:29:57.477]  $ ...future.seeds_ii       : NULL
[10:29:57.477]  $ ...future.globals.maxSize: NULL
[10:29:57.477]  - attr(*, "where")=List of 5
[10:29:57.477]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:57.477]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:57.477]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:57.477]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:57.477]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:57.477]  - attr(*, "resolved")= logi FALSE
[10:29:57.477]  - attr(*, "total_size")= num 1248
[10:29:57.477]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.477]  - attr(*, "already-done")= logi TRUE
[10:29:57.484] - copied ‘...future.FUN’ to environment
[10:29:57.485] - copied ‘future.call.arguments’ to environment
[10:29:57.485] - copied ‘...future.elements_ii’ to environment
[10:29:57.485] - copied ‘...future.seeds_ii’ to environment
[10:29:57.485] - copied ‘...future.globals.maxSize’ to environment
[10:29:57.485] assign_globals() ... done
[10:29:57.485] requestCore(): workers = 2
[10:29:57.488] MulticoreFuture started
[10:29:57.488] - Launch lazy future ... done
[10:29:57.488] run() for ‘MulticoreFuture’ ... done
[10:29:57.488] Created future:
[10:29:57.489] plan(): Setting new future strategy stack:
[10:29:57.490] List of future strategies:
[10:29:57.490] 1. sequential:
[10:29:57.490]    - args: function (..., envir = parent.frame())
[10:29:57.490]    - tweaked: FALSE
[10:29:57.490]    - call: NULL
[10:29:57.490] plan(): nbrOfWorkers() = 1
[10:29:57.493] plan(): Setting new future strategy stack:
[10:29:57.493] List of future strategies:
[10:29:57.493] 1. multicore:
[10:29:57.493]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:57.493]    - tweaked: FALSE
[10:29:57.493]    - call: plan(strategy)
[10:29:57.489] MulticoreFuture:
[10:29:57.489] Label: ‘future_eapply-2’
[10:29:57.489] Expression:
[10:29:57.489] {
[10:29:57.489]     do.call(function(...) {
[10:29:57.489]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.489]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:57.489]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.489]             on.exit(options(oopts), add = TRUE)
[10:29:57.489]         }
[10:29:57.489]         {
[10:29:57.489]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:57.489]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.489]                 ...future.FUN(...future.X_jj, ...)
[10:29:57.489]             })
[10:29:57.489]         }
[10:29:57.489]     }, args = future.call.arguments)
[10:29:57.489] }
[10:29:57.489] Lazy evaluation: FALSE
[10:29:57.489] Asynchronous evaluation: TRUE
[10:29:57.489] Local evaluation: TRUE
[10:29:57.489] Environment: R_GlobalEnv
[10:29:57.489] Capture standard output: TRUE
[10:29:57.489] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:57.489] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:57.489] Packages: 1 packages (‘stats’)
[10:29:57.489] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:57.489] Resolved: FALSE
[10:29:57.489] Value: <not collected>
[10:29:57.489] Conditions captured: <none>
[10:29:57.489] Early signaling: FALSE
[10:29:57.489] Owner process: db6eb61b-64f1-ae95-7e8b-287fbc43411a
[10:29:57.489] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:57.502] Chunk #2 of 2 ... DONE
[10:29:57.502] Launching 2 futures (chunks) ... DONE
[10:29:57.502] Resolving 2 futures (chunks) ...
[10:29:57.502] resolve() on list ...
[10:29:57.502]  recursive: 0
[10:29:57.498] plan(): nbrOfWorkers() = 2
[10:29:57.502]  length: 2
[10:29:57.503] 
[10:29:57.503] Future #1
[10:29:57.503] result() for MulticoreFuture ...
[10:29:57.504] result() for MulticoreFuture ...
[10:29:57.504] result() for MulticoreFuture ... done
[10:29:57.504] result() for MulticoreFuture ... done
[10:29:57.505] result() for MulticoreFuture ...
[10:29:57.505] result() for MulticoreFuture ... done
[10:29:57.507] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:29:57.508] - nx: 2
[10:29:57.508] - relay: TRUE
[10:29:57.508] - stdout: TRUE
[10:29:57.508] - signal: TRUE
[10:29:57.508] - resignal: FALSE
[10:29:57.508] - force: TRUE
[10:29:57.509] - relayed: [n=2] FALSE, FALSE
[10:29:57.509] - queued futures: [n=2] FALSE, FALSE
[10:29:57.509]  - until=1
[10:29:57.509]  - relaying element #1
[10:29:57.510] result() for MulticoreFuture ...
[10:29:57.510] result() for MulticoreFuture ... done
[10:29:57.510] result() for MulticoreFuture ...
[10:29:57.510] result() for MulticoreFuture ... done
[10:29:57.511] result() for MulticoreFuture ...
[10:29:57.511] result() for MulticoreFuture ... done
[10:29:57.511] result() for MulticoreFuture ...
[10:29:57.511] result() for MulticoreFuture ... done
[10:29:57.511] - relayed: [n=2] TRUE, FALSE
[10:29:57.512] - queued futures: [n=2] TRUE, FALSE
[10:29:57.512] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:29:57.512]  length: 1 (resolved future 1)
[10:29:57.512] Future #2
[10:29:57.513] result() for MulticoreFuture ...
[10:29:57.513] result() for MulticoreFuture ...
[10:29:57.514] result() for MulticoreFuture ... done
[10:29:57.514] result() for MulticoreFuture ... done
[10:29:57.514] result() for MulticoreFuture ...
[10:29:57.514] result() for MulticoreFuture ... done
[10:29:57.514] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:29:57.514] - nx: 2
[10:29:57.515] - relay: TRUE
[10:29:57.515] - stdout: TRUE
[10:29:57.515] - signal: TRUE
[10:29:57.515] - resignal: FALSE
[10:29:57.515] - force: TRUE
[10:29:57.515] - relayed: [n=2] TRUE, FALSE
[10:29:57.515] - queued futures: [n=2] TRUE, FALSE
[10:29:57.515]  - until=2
[10:29:57.515]  - relaying element #2
[10:29:57.516] result() for MulticoreFuture ...
[10:29:57.516] result() for MulticoreFuture ... done
[10:29:57.516] result() for MulticoreFuture ...
[10:29:57.516] result() for MulticoreFuture ... done
[10:29:57.516] result() for MulticoreFuture ...
[10:29:57.516] result() for MulticoreFuture ... done
[10:29:57.516] result() for MulticoreFuture ...
[10:29:57.517] result() for MulticoreFuture ... done
[10:29:57.517] - relayed: [n=2] TRUE, TRUE
[10:29:57.517] - queued futures: [n=2] TRUE, TRUE
[10:29:57.517] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:29:57.517]  length: 0 (resolved future 2)
[10:29:57.517] Relaying remaining futures
[10:29:57.517] signalConditionsASAP(NULL, pos=0) ...
[10:29:57.517] - nx: 2
[10:29:57.517] - relay: TRUE
[10:29:57.518] - stdout: TRUE
[10:29:57.518] - signal: TRUE
[10:29:57.518] - resignal: FALSE
[10:29:57.518] - force: TRUE
[10:29:57.518] - relayed: [n=2] TRUE, TRUE
[10:29:57.518] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:57.518] - relayed: [n=2] TRUE, TRUE
[10:29:57.518] - queued futures: [n=2] TRUE, TRUE
[10:29:57.519] signalConditionsASAP(NULL, pos=0) ... done
[10:29:57.519] resolve() on list ... DONE
[10:29:57.519] result() for MulticoreFuture ...
[10:29:57.519] result() for MulticoreFuture ... done
[10:29:57.519] result() for MulticoreFuture ...
[10:29:57.519] result() for MulticoreFuture ... done
[10:29:57.519] result() for MulticoreFuture ...
[10:29:57.519] result() for MulticoreFuture ... done
[10:29:57.520] result() for MulticoreFuture ...
[10:29:57.520] result() for MulticoreFuture ... done
[10:29:57.520]  - Number of value chunks collected: 2
[10:29:57.520] Resolving 2 futures (chunks) ... DONE
[10:29:57.520] Reducing values from 2 chunks ...
[10:29:57.520]  - Number of values collected after concatenation: 3
[10:29:57.520]  - Number of values expected: 3
[10:29:57.520] Reducing values from 2 chunks ... DONE
[10:29:57.520] future_lapply() ... DONE
[10:29:57.521] future_lapply() ...
[10:29:57.526] Number of chunks: 2
[10:29:57.526] getGlobalsAndPackagesXApply() ...
[10:29:57.526]  - future.globals: TRUE
[10:29:57.526] getGlobalsAndPackages() ...
[10:29:57.526] Searching for globals...
[10:29:57.528] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:57.528] Searching for globals ... DONE
[10:29:57.528] Resolving globals: FALSE
[10:29:57.529] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[10:29:57.529] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[10:29:57.529] - globals: [1] ‘FUN’
[10:29:57.529] - packages: [1] ‘stats’
[10:29:57.529] getGlobalsAndPackages() ... DONE
[10:29:57.530]  - globals found/used: [n=1] ‘FUN’
[10:29:57.530]  - needed namespaces: [n=1] ‘stats’
[10:29:57.530] Finding globals ... DONE
[10:29:57.530]  - use_args: TRUE
[10:29:57.530]  - Getting '...' globals ...
[10:29:57.530] resolve() on list ...
[10:29:57.530]  recursive: 0
[10:29:57.531]  length: 1
[10:29:57.531]  elements: ‘...’
[10:29:57.531]  length: 0 (resolved future 1)
[10:29:57.531] resolve() on list ... DONE
[10:29:57.531]    - '...' content: [n=0] 
[10:29:57.531] List of 1
[10:29:57.531]  $ ...: list()
[10:29:57.531]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.531]  - attr(*, "where")=List of 1
[10:29:57.531]   ..$ ...:<environment: 0x55974ae08898> 
[10:29:57.531]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.531]  - attr(*, "resolved")= logi TRUE
[10:29:57.531]  - attr(*, "total_size")= num NA
[10:29:57.534]  - Getting '...' globals ... DONE
[10:29:57.534] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:57.534] List of 2
[10:29:57.534]  $ ...future.FUN:function (x, ...)  
[10:29:57.534]  $ ...          : list()
[10:29:57.534]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.534]  - attr(*, "where")=List of 2
[10:29:57.534]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:57.534]   ..$ ...          :<environment: 0x55974ae08898> 
[10:29:57.534]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.534]  - attr(*, "resolved")= logi FALSE
[10:29:57.534]  - attr(*, "total_size")= num 1248
[10:29:57.539] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:57.539] getGlobalsAndPackagesXApply() ... DONE
[10:29:57.540] Number of futures (= number of chunks): 2
[10:29:57.540] Launching 2 futures (chunks) ...
[10:29:57.540] Chunk #1 of 2 ...
[10:29:57.540]  - Finding globals in 'X' for chunk #1 ...
[10:29:57.540] getGlobalsAndPackages() ...
[10:29:57.540] Searching for globals...
[10:29:57.540] 
[10:29:57.540] Searching for globals ... DONE
[10:29:57.541] - globals: [0] <none>
[10:29:57.541] getGlobalsAndPackages() ... DONE
[10:29:57.541]    + additional globals found: [n=0] 
[10:29:57.541]    + additional namespaces needed: [n=0] 
[10:29:57.541]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:57.541]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:57.541]  - seeds: <none>
[10:29:57.541]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.541] getGlobalsAndPackages() ...
[10:29:57.541] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.542] Resolving globals: FALSE
[10:29:57.542] Tweak future expression to call with '...' arguments ...
[10:29:57.542] {
[10:29:57.542]     do.call(function(...) {
[10:29:57.542]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.542]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:57.542]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.542]             on.exit(options(oopts), add = TRUE)
[10:29:57.542]         }
[10:29:57.542]         {
[10:29:57.542]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:57.542]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.542]                 ...future.FUN(...future.X_jj, ...)
[10:29:57.542]             })
[10:29:57.542]         }
[10:29:57.542]     }, args = future.call.arguments)
[10:29:57.542] }
[10:29:57.542] Tweak future expression to call with '...' arguments ... DONE
[10:29:57.542] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.543] - packages: [1] ‘stats’
[10:29:57.543] getGlobalsAndPackages() ... DONE
[10:29:57.543] run() for ‘Future’ ...
[10:29:57.543] - state: ‘created’
[10:29:57.543] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:57.547] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:57.547] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:57.547]   - Field: ‘label’
[10:29:57.547]   - Field: ‘local’
[10:29:57.547]   - Field: ‘owner’
[10:29:57.548]   - Field: ‘envir’
[10:29:57.548]   - Field: ‘workers’
[10:29:57.548]   - Field: ‘packages’
[10:29:57.548]   - Field: ‘gc’
[10:29:57.548]   - Field: ‘job’
[10:29:57.548]   - Field: ‘conditions’
[10:29:57.548]   - Field: ‘expr’
[10:29:57.548]   - Field: ‘uuid’
[10:29:57.548]   - Field: ‘seed’
[10:29:57.548]   - Field: ‘version’
[10:29:57.548]   - Field: ‘result’
[10:29:57.549]   - Field: ‘asynchronous’
[10:29:57.549]   - Field: ‘calls’
[10:29:57.549]   - Field: ‘globals’
[10:29:57.549]   - Field: ‘stdout’
[10:29:57.549]   - Field: ‘earlySignal’
[10:29:57.549]   - Field: ‘lazy’
[10:29:57.549]   - Field: ‘state’
[10:29:57.549] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:57.549] - Launch lazy future ...
[10:29:57.550] Packages needed by the future expression (n = 1): ‘stats’
[10:29:57.550] Packages needed by future strategies (n = 0): <none>
[10:29:57.550] {
[10:29:57.550]     {
[10:29:57.550]         {
[10:29:57.550]             ...future.startTime <- base::Sys.time()
[10:29:57.550]             {
[10:29:57.550]                 {
[10:29:57.550]                   {
[10:29:57.550]                     {
[10:29:57.550]                       {
[10:29:57.550]                         base::local({
[10:29:57.550]                           has_future <- base::requireNamespace("future", 
[10:29:57.550]                             quietly = TRUE)
[10:29:57.550]                           if (has_future) {
[10:29:57.550]                             ns <- base::getNamespace("future")
[10:29:57.550]                             version <- ns[[".package"]][["version"]]
[10:29:57.550]                             if (is.null(version)) 
[10:29:57.550]                               version <- utils::packageVersion("future")
[10:29:57.550]                           }
[10:29:57.550]                           else {
[10:29:57.550]                             version <- NULL
[10:29:57.550]                           }
[10:29:57.550]                           if (!has_future || version < "1.8.0") {
[10:29:57.550]                             info <- base::c(r_version = base::gsub("R version ", 
[10:29:57.550]                               "", base::R.version$version.string), 
[10:29:57.550]                               platform = base::sprintf("%s (%s-bit)", 
[10:29:57.550]                                 base::R.version$platform, 8 * 
[10:29:57.550]                                   base::.Machine$sizeof.pointer), 
[10:29:57.550]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:57.550]                                 "release", "version")], collapse = " "), 
[10:29:57.550]                               hostname = base::Sys.info()[["nodename"]])
[10:29:57.550]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:29:57.550]                               info)
[10:29:57.550]                             info <- base::paste(info, collapse = "; ")
[10:29:57.550]                             if (!has_future) {
[10:29:57.550]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:57.550]                                 info)
[10:29:57.550]                             }
[10:29:57.550]                             else {
[10:29:57.550]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:57.550]                                 info, version)
[10:29:57.550]                             }
[10:29:57.550]                             base::stop(msg)
[10:29:57.550]                           }
[10:29:57.550]                         })
[10:29:57.550]                       }
[10:29:57.550]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:57.550]                       base::options(mc.cores = 1L)
[10:29:57.550]                     }
[10:29:57.550]                     base::local({
[10:29:57.550]                       for (pkg in "stats") {
[10:29:57.550]                         base::loadNamespace(pkg)
[10:29:57.550]                         base::library(pkg, character.only = TRUE)
[10:29:57.550]                       }
[10:29:57.550]                     })
[10:29:57.550]                   }
[10:29:57.550]                   ...future.strategy.old <- future::plan("list")
[10:29:57.550]                   options(future.plan = NULL)
[10:29:57.550]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:57.550]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:57.550]                 }
[10:29:57.550]                 ...future.workdir <- getwd()
[10:29:57.550]             }
[10:29:57.550]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:57.550]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:57.550]         }
[10:29:57.550]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:57.550]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:57.550]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:57.550]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:57.550]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:57.550]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:57.550]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:57.550]             base::names(...future.oldOptions))
[10:29:57.550]     }
[10:29:57.550]     if (FALSE) {
[10:29:57.550]     }
[10:29:57.550]     else {
[10:29:57.550]         if (TRUE) {
[10:29:57.550]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:57.550]                 open = "w")
[10:29:57.550]         }
[10:29:57.550]         else {
[10:29:57.550]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:57.550]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:57.550]         }
[10:29:57.550]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:57.550]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:57.550]             base::sink(type = "output", split = FALSE)
[10:29:57.550]             base::close(...future.stdout)
[10:29:57.550]         }, add = TRUE)
[10:29:57.550]     }
[10:29:57.550]     ...future.frame <- base::sys.nframe()
[10:29:57.550]     ...future.conditions <- base::list()
[10:29:57.550]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:57.550]     if (FALSE) {
[10:29:57.550]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:57.550]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:57.550]     }
[10:29:57.550]     ...future.result <- base::tryCatch({
[10:29:57.550]         base::withCallingHandlers({
[10:29:57.550]             ...future.value <- base::withVisible(base::local({
[10:29:57.550]                 withCallingHandlers({
[10:29:57.550]                   {
[10:29:57.550]                     do.call(function(...) {
[10:29:57.550]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.550]                       if (!identical(...future.globals.maxSize.org, 
[10:29:57.550]                         ...future.globals.maxSize)) {
[10:29:57.550]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.550]                         on.exit(options(oopts), add = TRUE)
[10:29:57.550]                       }
[10:29:57.550]                       {
[10:29:57.550]                         lapply(seq_along(...future.elements_ii), 
[10:29:57.550]                           FUN = function(jj) {
[10:29:57.550]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.550]                             ...future.FUN(...future.X_jj, ...)
[10:29:57.550]                           })
[10:29:57.550]                       }
[10:29:57.550]                     }, args = future.call.arguments)
[10:29:57.550]                   }
[10:29:57.550]                 }, immediateCondition = function(cond) {
[10:29:57.550]                   save_rds <- function (object, pathname, ...) 
[10:29:57.550]                   {
[10:29:57.550]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:57.550]                     if (file_test("-f", pathname_tmp)) {
[10:29:57.550]                       fi_tmp <- file.info(pathname_tmp)
[10:29:57.550]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:57.550]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:57.550]                         fi_tmp[["mtime"]])
[10:29:57.550]                     }
[10:29:57.550]                     tryCatch({
[10:29:57.550]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:57.550]                     }, error = function(ex) {
[10:29:57.550]                       msg <- conditionMessage(ex)
[10:29:57.550]                       fi_tmp <- file.info(pathname_tmp)
[10:29:57.550]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:57.550]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:57.550]                         fi_tmp[["mtime"]], msg)
[10:29:57.550]                       ex$message <- msg
[10:29:57.550]                       stop(ex)
[10:29:57.550]                     })
[10:29:57.550]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:57.550]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:57.550]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:57.550]                       fi_tmp <- file.info(pathname_tmp)
[10:29:57.550]                       fi <- file.info(pathname)
[10:29:57.550]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:57.550]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:57.550]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:57.550]                         fi[["size"]], fi[["mtime"]])
[10:29:57.550]                       stop(msg)
[10:29:57.550]                     }
[10:29:57.550]                     invisible(pathname)
[10:29:57.550]                   }
[10:29:57.550]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:57.550]                     rootPath = tempdir()) 
[10:29:57.550]                   {
[10:29:57.550]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:57.550]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:57.550]                       tmpdir = path, fileext = ".rds")
[10:29:57.550]                     save_rds(obj, file)
[10:29:57.550]                   }
[10:29:57.550]                   saveImmediateCondition(cond, path = "/tmp/RtmpoCSmtD/.future/immediateConditions")
[10:29:57.550]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.550]                   {
[10:29:57.550]                     inherits <- base::inherits
[10:29:57.550]                     invokeRestart <- base::invokeRestart
[10:29:57.550]                     is.null <- base::is.null
[10:29:57.550]                     muffled <- FALSE
[10:29:57.550]                     if (inherits(cond, "message")) {
[10:29:57.550]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:57.550]                       if (muffled) 
[10:29:57.550]                         invokeRestart("muffleMessage")
[10:29:57.550]                     }
[10:29:57.550]                     else if (inherits(cond, "warning")) {
[10:29:57.550]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:57.550]                       if (muffled) 
[10:29:57.550]                         invokeRestart("muffleWarning")
[10:29:57.550]                     }
[10:29:57.550]                     else if (inherits(cond, "condition")) {
[10:29:57.550]                       if (!is.null(pattern)) {
[10:29:57.550]                         computeRestarts <- base::computeRestarts
[10:29:57.550]                         grepl <- base::grepl
[10:29:57.550]                         restarts <- computeRestarts(cond)
[10:29:57.550]                         for (restart in restarts) {
[10:29:57.550]                           name <- restart$name
[10:29:57.550]                           if (is.null(name)) 
[10:29:57.550]                             next
[10:29:57.550]                           if (!grepl(pattern, name)) 
[10:29:57.550]                             next
[10:29:57.550]                           invokeRestart(restart)
[10:29:57.550]                           muffled <- TRUE
[10:29:57.550]                           break
[10:29:57.550]                         }
[10:29:57.550]                       }
[10:29:57.550]                     }
[10:29:57.550]                     invisible(muffled)
[10:29:57.550]                   }
[10:29:57.550]                   muffleCondition(cond)
[10:29:57.550]                 })
[10:29:57.550]             }))
[10:29:57.550]             future::FutureResult(value = ...future.value$value, 
[10:29:57.550]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:57.550]                   ...future.rng), globalenv = if (FALSE) 
[10:29:57.550]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:57.550]                     ...future.globalenv.names))
[10:29:57.550]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:57.550]         }, condition = base::local({
[10:29:57.550]             c <- base::c
[10:29:57.550]             inherits <- base::inherits
[10:29:57.550]             invokeRestart <- base::invokeRestart
[10:29:57.550]             length <- base::length
[10:29:57.550]             list <- base::list
[10:29:57.550]             seq.int <- base::seq.int
[10:29:57.550]             signalCondition <- base::signalCondition
[10:29:57.550]             sys.calls <- base::sys.calls
[10:29:57.550]             `[[` <- base::`[[`
[10:29:57.550]             `+` <- base::`+`
[10:29:57.550]             `<<-` <- base::`<<-`
[10:29:57.550]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:57.550]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:57.550]                   3L)]
[10:29:57.550]             }
[10:29:57.550]             function(cond) {
[10:29:57.550]                 is_error <- inherits(cond, "error")
[10:29:57.550]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:57.550]                   NULL)
[10:29:57.550]                 if (is_error) {
[10:29:57.550]                   sessionInformation <- function() {
[10:29:57.550]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:57.550]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:57.550]                       search = base::search(), system = base::Sys.info())
[10:29:57.550]                   }
[10:29:57.550]                   ...future.conditions[[length(...future.conditions) + 
[10:29:57.550]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:57.550]                     cond$call), session = sessionInformation(), 
[10:29:57.550]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:57.550]                   signalCondition(cond)
[10:29:57.550]                 }
[10:29:57.550]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:57.550]                 "immediateCondition"))) {
[10:29:57.550]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:57.550]                   ...future.conditions[[length(...future.conditions) + 
[10:29:57.550]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:57.550]                   if (TRUE && !signal) {
[10:29:57.550]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.550]                     {
[10:29:57.550]                       inherits <- base::inherits
[10:29:57.550]                       invokeRestart <- base::invokeRestart
[10:29:57.550]                       is.null <- base::is.null
[10:29:57.550]                       muffled <- FALSE
[10:29:57.550]                       if (inherits(cond, "message")) {
[10:29:57.550]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:57.550]                         if (muffled) 
[10:29:57.550]                           invokeRestart("muffleMessage")
[10:29:57.550]                       }
[10:29:57.550]                       else if (inherits(cond, "warning")) {
[10:29:57.550]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:57.550]                         if (muffled) 
[10:29:57.550]                           invokeRestart("muffleWarning")
[10:29:57.550]                       }
[10:29:57.550]                       else if (inherits(cond, "condition")) {
[10:29:57.550]                         if (!is.null(pattern)) {
[10:29:57.550]                           computeRestarts <- base::computeRestarts
[10:29:57.550]                           grepl <- base::grepl
[10:29:57.550]                           restarts <- computeRestarts(cond)
[10:29:57.550]                           for (restart in restarts) {
[10:29:57.550]                             name <- restart$name
[10:29:57.550]                             if (is.null(name)) 
[10:29:57.550]                               next
[10:29:57.550]                             if (!grepl(pattern, name)) 
[10:29:57.550]                               next
[10:29:57.550]                             invokeRestart(restart)
[10:29:57.550]                             muffled <- TRUE
[10:29:57.550]                             break
[10:29:57.550]                           }
[10:29:57.550]                         }
[10:29:57.550]                       }
[10:29:57.550]                       invisible(muffled)
[10:29:57.550]                     }
[10:29:57.550]                     muffleCondition(cond, pattern = "^muffle")
[10:29:57.550]                   }
[10:29:57.550]                 }
[10:29:57.550]                 else {
[10:29:57.550]                   if (TRUE) {
[10:29:57.550]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.550]                     {
[10:29:57.550]                       inherits <- base::inherits
[10:29:57.550]                       invokeRestart <- base::invokeRestart
[10:29:57.550]                       is.null <- base::is.null
[10:29:57.550]                       muffled <- FALSE
[10:29:57.550]                       if (inherits(cond, "message")) {
[10:29:57.550]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:57.550]                         if (muffled) 
[10:29:57.550]                           invokeRestart("muffleMessage")
[10:29:57.550]                       }
[10:29:57.550]                       else if (inherits(cond, "warning")) {
[10:29:57.550]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:57.550]                         if (muffled) 
[10:29:57.550]                           invokeRestart("muffleWarning")
[10:29:57.550]                       }
[10:29:57.550]                       else if (inherits(cond, "condition")) {
[10:29:57.550]                         if (!is.null(pattern)) {
[10:29:57.550]                           computeRestarts <- base::computeRestarts
[10:29:57.550]                           grepl <- base::grepl
[10:29:57.550]                           restarts <- computeRestarts(cond)
[10:29:57.550]                           for (restart in restarts) {
[10:29:57.550]                             name <- restart$name
[10:29:57.550]                             if (is.null(name)) 
[10:29:57.550]                               next
[10:29:57.550]                             if (!grepl(pattern, name)) 
[10:29:57.550]                               next
[10:29:57.550]                             invokeRestart(restart)
[10:29:57.550]                             muffled <- TRUE
[10:29:57.550]                             break
[10:29:57.550]                           }
[10:29:57.550]                         }
[10:29:57.550]                       }
[10:29:57.550]                       invisible(muffled)
[10:29:57.550]                     }
[10:29:57.550]                     muffleCondition(cond, pattern = "^muffle")
[10:29:57.550]                   }
[10:29:57.550]                 }
[10:29:57.550]             }
[10:29:57.550]         }))
[10:29:57.550]     }, error = function(ex) {
[10:29:57.550]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:57.550]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:57.550]                 ...future.rng), started = ...future.startTime, 
[10:29:57.550]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:57.550]             version = "1.8"), class = "FutureResult")
[10:29:57.550]     }, finally = {
[10:29:57.550]         if (!identical(...future.workdir, getwd())) 
[10:29:57.550]             setwd(...future.workdir)
[10:29:57.550]         {
[10:29:57.550]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:57.550]                 ...future.oldOptions$nwarnings <- NULL
[10:29:57.550]             }
[10:29:57.550]             base::options(...future.oldOptions)
[10:29:57.550]             if (.Platform$OS.type == "windows") {
[10:29:57.550]                 old_names <- names(...future.oldEnvVars)
[10:29:57.550]                 envs <- base::Sys.getenv()
[10:29:57.550]                 names <- names(envs)
[10:29:57.550]                 common <- intersect(names, old_names)
[10:29:57.550]                 added <- setdiff(names, old_names)
[10:29:57.550]                 removed <- setdiff(old_names, names)
[10:29:57.550]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:57.550]                   envs[common]]
[10:29:57.550]                 NAMES <- toupper(changed)
[10:29:57.550]                 args <- list()
[10:29:57.550]                 for (kk in seq_along(NAMES)) {
[10:29:57.550]                   name <- changed[[kk]]
[10:29:57.550]                   NAME <- NAMES[[kk]]
[10:29:57.550]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.550]                     next
[10:29:57.550]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:57.550]                 }
[10:29:57.550]                 NAMES <- toupper(added)
[10:29:57.550]                 for (kk in seq_along(NAMES)) {
[10:29:57.550]                   name <- added[[kk]]
[10:29:57.550]                   NAME <- NAMES[[kk]]
[10:29:57.550]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.550]                     next
[10:29:57.550]                   args[[name]] <- ""
[10:29:57.550]                 }
[10:29:57.550]                 NAMES <- toupper(removed)
[10:29:57.550]                 for (kk in seq_along(NAMES)) {
[10:29:57.550]                   name <- removed[[kk]]
[10:29:57.550]                   NAME <- NAMES[[kk]]
[10:29:57.550]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.550]                     next
[10:29:57.550]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:57.550]                 }
[10:29:57.550]                 if (length(args) > 0) 
[10:29:57.550]                   base::do.call(base::Sys.setenv, args = args)
[10:29:57.550]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:57.550]             }
[10:29:57.550]             else {
[10:29:57.550]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:57.550]             }
[10:29:57.550]             {
[10:29:57.550]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:57.550]                   0L) {
[10:29:57.550]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:57.550]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:57.550]                   base::options(opts)
[10:29:57.550]                 }
[10:29:57.550]                 {
[10:29:57.550]                   {
[10:29:57.550]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:57.550]                     NULL
[10:29:57.550]                   }
[10:29:57.550]                   options(future.plan = NULL)
[10:29:57.550]                   if (is.na(NA_character_)) 
[10:29:57.550]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:57.550]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:57.550]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:57.550]                     .init = FALSE)
[10:29:57.550]                 }
[10:29:57.550]             }
[10:29:57.550]         }
[10:29:57.550]     })
[10:29:57.550]     if (TRUE) {
[10:29:57.550]         base::sink(type = "output", split = FALSE)
[10:29:57.550]         if (TRUE) {
[10:29:57.550]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:57.550]         }
[10:29:57.550]         else {
[10:29:57.550]             ...future.result["stdout"] <- base::list(NULL)
[10:29:57.550]         }
[10:29:57.550]         base::close(...future.stdout)
[10:29:57.550]         ...future.stdout <- NULL
[10:29:57.550]     }
[10:29:57.550]     ...future.result$conditions <- ...future.conditions
[10:29:57.550]     ...future.result$finished <- base::Sys.time()
[10:29:57.550]     ...future.result
[10:29:57.550] }
[10:29:57.553] assign_globals() ...
[10:29:57.553] List of 5
[10:29:57.553]  $ ...future.FUN            :function (x, ...)  
[10:29:57.553]  $ future.call.arguments    : list()
[10:29:57.553]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.553]  $ ...future.elements_ii    :List of 1
[10:29:57.553]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[10:29:57.553]  $ ...future.seeds_ii       : NULL
[10:29:57.553]  $ ...future.globals.maxSize: NULL
[10:29:57.553]  - attr(*, "where")=List of 5
[10:29:57.553]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:57.553]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:57.553]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:57.553]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:57.553]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:57.553]  - attr(*, "resolved")= logi FALSE
[10:29:57.553]  - attr(*, "total_size")= num 1248
[10:29:57.553]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.553]  - attr(*, "already-done")= logi TRUE
[10:29:57.558] - copied ‘...future.FUN’ to environment
[10:29:57.558] - copied ‘future.call.arguments’ to environment
[10:29:57.558] - copied ‘...future.elements_ii’ to environment
[10:29:57.558] - copied ‘...future.seeds_ii’ to environment
[10:29:57.558] - copied ‘...future.globals.maxSize’ to environment
[10:29:57.558] assign_globals() ... done
[10:29:57.558] requestCore(): workers = 2
[10:29:57.560] MulticoreFuture started
[10:29:57.561] - Launch lazy future ... done
[10:29:57.561] run() for ‘MulticoreFuture’ ... done
[10:29:57.561] Created future:
[10:29:57.562] plan(): Setting new future strategy stack:
[10:29:57.562] List of future strategies:
[10:29:57.562] 1. sequential:
[10:29:57.562]    - args: function (..., envir = parent.frame())
[10:29:57.562]    - tweaked: FALSE
[10:29:57.562]    - call: NULL
[10:29:57.563] plan(): nbrOfWorkers() = 1
[10:29:57.565] plan(): Setting new future strategy stack:
[10:29:57.565] List of future strategies:
[10:29:57.565] 1. multicore:
[10:29:57.565]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:57.565]    - tweaked: FALSE
[10:29:57.565]    - call: plan(strategy)
[10:29:57.570] plan(): nbrOfWorkers() = 2
[10:29:57.561] MulticoreFuture:
[10:29:57.561] Label: ‘future_eapply-1’
[10:29:57.561] Expression:
[10:29:57.561] {
[10:29:57.561]     do.call(function(...) {
[10:29:57.561]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.561]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:57.561]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.561]             on.exit(options(oopts), add = TRUE)
[10:29:57.561]         }
[10:29:57.561]         {
[10:29:57.561]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:57.561]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.561]                 ...future.FUN(...future.X_jj, ...)
[10:29:57.561]             })
[10:29:57.561]         }
[10:29:57.561]     }, args = future.call.arguments)
[10:29:57.561] }
[10:29:57.561] Lazy evaluation: FALSE
[10:29:57.561] Asynchronous evaluation: TRUE
[10:29:57.561] Local evaluation: TRUE
[10:29:57.561] Environment: R_GlobalEnv
[10:29:57.561] Capture standard output: TRUE
[10:29:57.561] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:57.561] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:57.561] Packages: 1 packages (‘stats’)
[10:29:57.561] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:57.561] Resolved: TRUE
[10:29:57.561] Value: <not collected>
[10:29:57.561] Conditions captured: <none>
[10:29:57.561] Early signaling: FALSE
[10:29:57.561] Owner process: db6eb61b-64f1-ae95-7e8b-287fbc43411a
[10:29:57.561] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:57.571] Chunk #1 of 2 ... DONE
[10:29:57.571] Chunk #2 of 2 ...
[10:29:57.572]  - Finding globals in 'X' for chunk #2 ...
[10:29:57.572] getGlobalsAndPackages() ...
[10:29:57.572] Searching for globals...
[10:29:57.572] 
[10:29:57.573] Searching for globals ... DONE
[10:29:57.573] - globals: [0] <none>
[10:29:57.573] getGlobalsAndPackages() ... DONE
[10:29:57.573]    + additional globals found: [n=0] 
[10:29:57.573]    + additional namespaces needed: [n=0] 
[10:29:57.573]  - Finding globals in 'X' for chunk #2 ... DONE
[10:29:57.573]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:57.573]  - seeds: <none>
[10:29:57.574]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.574] getGlobalsAndPackages() ...
[10:29:57.574] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.574] Resolving globals: FALSE
[10:29:57.574] Tweak future expression to call with '...' arguments ...
[10:29:57.574] {
[10:29:57.574]     do.call(function(...) {
[10:29:57.574]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.574]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:57.574]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.574]             on.exit(options(oopts), add = TRUE)
[10:29:57.574]         }
[10:29:57.574]         {
[10:29:57.574]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:57.574]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.574]                 ...future.FUN(...future.X_jj, ...)
[10:29:57.574]             })
[10:29:57.574]         }
[10:29:57.574]     }, args = future.call.arguments)
[10:29:57.574] }
[10:29:57.575] Tweak future expression to call with '...' arguments ... DONE
[10:29:57.576] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:57.576] - packages: [1] ‘stats’
[10:29:57.576] getGlobalsAndPackages() ... DONE
[10:29:57.580] run() for ‘Future’ ...
[10:29:57.580] - state: ‘created’
[10:29:57.580] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:29:57.586] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:57.586] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:29:57.586]   - Field: ‘label’
[10:29:57.586]   - Field: ‘local’
[10:29:57.587]   - Field: ‘owner’
[10:29:57.587]   - Field: ‘envir’
[10:29:57.587]   - Field: ‘workers’
[10:29:57.587]   - Field: ‘packages’
[10:29:57.587]   - Field: ‘gc’
[10:29:57.588]   - Field: ‘job’
[10:29:57.588]   - Field: ‘conditions’
[10:29:57.588]   - Field: ‘expr’
[10:29:57.588]   - Field: ‘uuid’
[10:29:57.588]   - Field: ‘seed’
[10:29:57.588]   - Field: ‘version’
[10:29:57.589]   - Field: ‘result’
[10:29:57.589]   - Field: ‘asynchronous’
[10:29:57.589]   - Field: ‘calls’
[10:29:57.589]   - Field: ‘globals’
[10:29:57.589]   - Field: ‘stdout’
[10:29:57.589]   - Field: ‘earlySignal’
[10:29:57.590]   - Field: ‘lazy’
[10:29:57.590]   - Field: ‘state’
[10:29:57.590] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:29:57.590] - Launch lazy future ...
[10:29:57.591] Packages needed by the future expression (n = 1): ‘stats’
[10:29:57.591] Packages needed by future strategies (n = 0): <none>
[10:29:57.592] {
[10:29:57.592]     {
[10:29:57.592]         {
[10:29:57.592]             ...future.startTime <- base::Sys.time()
[10:29:57.592]             {
[10:29:57.592]                 {
[10:29:57.592]                   {
[10:29:57.592]                     {
[10:29:57.592]                       {
[10:29:57.592]                         base::local({
[10:29:57.592]                           has_future <- base::requireNamespace("future", 
[10:29:57.592]                             quietly = TRUE)
[10:29:57.592]                           if (has_future) {
[10:29:57.592]                             ns <- base::getNamespace("future")
[10:29:57.592]                             version <- ns[[".package"]][["version"]]
[10:29:57.592]                             if (is.null(version)) 
[10:29:57.592]                               version <- utils::packageVersion("future")
[10:29:57.592]                           }
[10:29:57.592]                           else {
[10:29:57.592]                             version <- NULL
[10:29:57.592]                           }
[10:29:57.592]                           if (!has_future || version < "1.8.0") {
[10:29:57.592]                             info <- base::c(r_version = base::gsub("R version ", 
[10:29:57.592]                               "", base::R.version$version.string), 
[10:29:57.592]                               platform = base::sprintf("%s (%s-bit)", 
[10:29:57.592]                                 base::R.version$platform, 8 * 
[10:29:57.592]                                   base::.Machine$sizeof.pointer), 
[10:29:57.592]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:57.592]                                 "release", "version")], collapse = " "), 
[10:29:57.592]                               hostname = base::Sys.info()[["nodename"]])
[10:29:57.592]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:29:57.592]                               info)
[10:29:57.592]                             info <- base::paste(info, collapse = "; ")
[10:29:57.592]                             if (!has_future) {
[10:29:57.592]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:57.592]                                 info)
[10:29:57.592]                             }
[10:29:57.592]                             else {
[10:29:57.592]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:57.592]                                 info, version)
[10:29:57.592]                             }
[10:29:57.592]                             base::stop(msg)
[10:29:57.592]                           }
[10:29:57.592]                         })
[10:29:57.592]                       }
[10:29:57.592]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:57.592]                       base::options(mc.cores = 1L)
[10:29:57.592]                     }
[10:29:57.592]                     base::local({
[10:29:57.592]                       for (pkg in "stats") {
[10:29:57.592]                         base::loadNamespace(pkg)
[10:29:57.592]                         base::library(pkg, character.only = TRUE)
[10:29:57.592]                       }
[10:29:57.592]                     })
[10:29:57.592]                   }
[10:29:57.592]                   ...future.strategy.old <- future::plan("list")
[10:29:57.592]                   options(future.plan = NULL)
[10:29:57.592]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:57.592]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:57.592]                 }
[10:29:57.592]                 ...future.workdir <- getwd()
[10:29:57.592]             }
[10:29:57.592]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:57.592]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:57.592]         }
[10:29:57.592]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:57.592]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:57.592]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:57.592]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:57.592]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:57.592]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:57.592]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:57.592]             base::names(...future.oldOptions))
[10:29:57.592]     }
[10:29:57.592]     if (FALSE) {
[10:29:57.592]     }
[10:29:57.592]     else {
[10:29:57.592]         if (TRUE) {
[10:29:57.592]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:57.592]                 open = "w")
[10:29:57.592]         }
[10:29:57.592]         else {
[10:29:57.592]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:57.592]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:57.592]         }
[10:29:57.592]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:57.592]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:57.592]             base::sink(type = "output", split = FALSE)
[10:29:57.592]             base::close(...future.stdout)
[10:29:57.592]         }, add = TRUE)
[10:29:57.592]     }
[10:29:57.592]     ...future.frame <- base::sys.nframe()
[10:29:57.592]     ...future.conditions <- base::list()
[10:29:57.592]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:57.592]     if (FALSE) {
[10:29:57.592]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:57.592]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:57.592]     }
[10:29:57.592]     ...future.result <- base::tryCatch({
[10:29:57.592]         base::withCallingHandlers({
[10:29:57.592]             ...future.value <- base::withVisible(base::local({
[10:29:57.592]                 withCallingHandlers({
[10:29:57.592]                   {
[10:29:57.592]                     do.call(function(...) {
[10:29:57.592]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.592]                       if (!identical(...future.globals.maxSize.org, 
[10:29:57.592]                         ...future.globals.maxSize)) {
[10:29:57.592]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.592]                         on.exit(options(oopts), add = TRUE)
[10:29:57.592]                       }
[10:29:57.592]                       {
[10:29:57.592]                         lapply(seq_along(...future.elements_ii), 
[10:29:57.592]                           FUN = function(jj) {
[10:29:57.592]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.592]                             ...future.FUN(...future.X_jj, ...)
[10:29:57.592]                           })
[10:29:57.592]                       }
[10:29:57.592]                     }, args = future.call.arguments)
[10:29:57.592]                   }
[10:29:57.592]                 }, immediateCondition = function(cond) {
[10:29:57.592]                   save_rds <- function (object, pathname, ...) 
[10:29:57.592]                   {
[10:29:57.592]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:29:57.592]                     if (file_test("-f", pathname_tmp)) {
[10:29:57.592]                       fi_tmp <- file.info(pathname_tmp)
[10:29:57.592]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:29:57.592]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:57.592]                         fi_tmp[["mtime"]])
[10:29:57.592]                     }
[10:29:57.592]                     tryCatch({
[10:29:57.592]                       saveRDS(object, file = pathname_tmp, ...)
[10:29:57.592]                     }, error = function(ex) {
[10:29:57.592]                       msg <- conditionMessage(ex)
[10:29:57.592]                       fi_tmp <- file.info(pathname_tmp)
[10:29:57.592]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:29:57.592]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:57.592]                         fi_tmp[["mtime"]], msg)
[10:29:57.592]                       ex$message <- msg
[10:29:57.592]                       stop(ex)
[10:29:57.592]                     })
[10:29:57.592]                     stopifnot(file_test("-f", pathname_tmp))
[10:29:57.592]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:29:57.592]                     if (!res || file_test("-f", pathname_tmp)) {
[10:29:57.592]                       fi_tmp <- file.info(pathname_tmp)
[10:29:57.592]                       fi <- file.info(pathname)
[10:29:57.592]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:29:57.592]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:29:57.592]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:29:57.592]                         fi[["size"]], fi[["mtime"]])
[10:29:57.592]                       stop(msg)
[10:29:57.592]                     }
[10:29:57.592]                     invisible(pathname)
[10:29:57.592]                   }
[10:29:57.592]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:29:57.592]                     rootPath = tempdir()) 
[10:29:57.592]                   {
[10:29:57.592]                     obj <- list(time = Sys.time(), condition = cond)
[10:29:57.592]                     file <- tempfile(pattern = class(cond)[1], 
[10:29:57.592]                       tmpdir = path, fileext = ".rds")
[10:29:57.592]                     save_rds(obj, file)
[10:29:57.592]                   }
[10:29:57.592]                   saveImmediateCondition(cond, path = "/tmp/RtmpoCSmtD/.future/immediateConditions")
[10:29:57.592]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.592]                   {
[10:29:57.592]                     inherits <- base::inherits
[10:29:57.592]                     invokeRestart <- base::invokeRestart
[10:29:57.592]                     is.null <- base::is.null
[10:29:57.592]                     muffled <- FALSE
[10:29:57.592]                     if (inherits(cond, "message")) {
[10:29:57.592]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:57.592]                       if (muffled) 
[10:29:57.592]                         invokeRestart("muffleMessage")
[10:29:57.592]                     }
[10:29:57.592]                     else if (inherits(cond, "warning")) {
[10:29:57.592]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:57.592]                       if (muffled) 
[10:29:57.592]                         invokeRestart("muffleWarning")
[10:29:57.592]                     }
[10:29:57.592]                     else if (inherits(cond, "condition")) {
[10:29:57.592]                       if (!is.null(pattern)) {
[10:29:57.592]                         computeRestarts <- base::computeRestarts
[10:29:57.592]                         grepl <- base::grepl
[10:29:57.592]                         restarts <- computeRestarts(cond)
[10:29:57.592]                         for (restart in restarts) {
[10:29:57.592]                           name <- restart$name
[10:29:57.592]                           if (is.null(name)) 
[10:29:57.592]                             next
[10:29:57.592]                           if (!grepl(pattern, name)) 
[10:29:57.592]                             next
[10:29:57.592]                           invokeRestart(restart)
[10:29:57.592]                           muffled <- TRUE
[10:29:57.592]                           break
[10:29:57.592]                         }
[10:29:57.592]                       }
[10:29:57.592]                     }
[10:29:57.592]                     invisible(muffled)
[10:29:57.592]                   }
[10:29:57.592]                   muffleCondition(cond)
[10:29:57.592]                 })
[10:29:57.592]             }))
[10:29:57.592]             future::FutureResult(value = ...future.value$value, 
[10:29:57.592]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:57.592]                   ...future.rng), globalenv = if (FALSE) 
[10:29:57.592]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:57.592]                     ...future.globalenv.names))
[10:29:57.592]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:57.592]         }, condition = base::local({
[10:29:57.592]             c <- base::c
[10:29:57.592]             inherits <- base::inherits
[10:29:57.592]             invokeRestart <- base::invokeRestart
[10:29:57.592]             length <- base::length
[10:29:57.592]             list <- base::list
[10:29:57.592]             seq.int <- base::seq.int
[10:29:57.592]             signalCondition <- base::signalCondition
[10:29:57.592]             sys.calls <- base::sys.calls
[10:29:57.592]             `[[` <- base::`[[`
[10:29:57.592]             `+` <- base::`+`
[10:29:57.592]             `<<-` <- base::`<<-`
[10:29:57.592]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:57.592]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:57.592]                   3L)]
[10:29:57.592]             }
[10:29:57.592]             function(cond) {
[10:29:57.592]                 is_error <- inherits(cond, "error")
[10:29:57.592]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:57.592]                   NULL)
[10:29:57.592]                 if (is_error) {
[10:29:57.592]                   sessionInformation <- function() {
[10:29:57.592]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:57.592]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:57.592]                       search = base::search(), system = base::Sys.info())
[10:29:57.592]                   }
[10:29:57.592]                   ...future.conditions[[length(...future.conditions) + 
[10:29:57.592]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:57.592]                     cond$call), session = sessionInformation(), 
[10:29:57.592]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:57.592]                   signalCondition(cond)
[10:29:57.592]                 }
[10:29:57.592]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:57.592]                 "immediateCondition"))) {
[10:29:57.592]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:57.592]                   ...future.conditions[[length(...future.conditions) + 
[10:29:57.592]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:57.592]                   if (TRUE && !signal) {
[10:29:57.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.592]                     {
[10:29:57.592]                       inherits <- base::inherits
[10:29:57.592]                       invokeRestart <- base::invokeRestart
[10:29:57.592]                       is.null <- base::is.null
[10:29:57.592]                       muffled <- FALSE
[10:29:57.592]                       if (inherits(cond, "message")) {
[10:29:57.592]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:57.592]                         if (muffled) 
[10:29:57.592]                           invokeRestart("muffleMessage")
[10:29:57.592]                       }
[10:29:57.592]                       else if (inherits(cond, "warning")) {
[10:29:57.592]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:57.592]                         if (muffled) 
[10:29:57.592]                           invokeRestart("muffleWarning")
[10:29:57.592]                       }
[10:29:57.592]                       else if (inherits(cond, "condition")) {
[10:29:57.592]                         if (!is.null(pattern)) {
[10:29:57.592]                           computeRestarts <- base::computeRestarts
[10:29:57.592]                           grepl <- base::grepl
[10:29:57.592]                           restarts <- computeRestarts(cond)
[10:29:57.592]                           for (restart in restarts) {
[10:29:57.592]                             name <- restart$name
[10:29:57.592]                             if (is.null(name)) 
[10:29:57.592]                               next
[10:29:57.592]                             if (!grepl(pattern, name)) 
[10:29:57.592]                               next
[10:29:57.592]                             invokeRestart(restart)
[10:29:57.592]                             muffled <- TRUE
[10:29:57.592]                             break
[10:29:57.592]                           }
[10:29:57.592]                         }
[10:29:57.592]                       }
[10:29:57.592]                       invisible(muffled)
[10:29:57.592]                     }
[10:29:57.592]                     muffleCondition(cond, pattern = "^muffle")
[10:29:57.592]                   }
[10:29:57.592]                 }
[10:29:57.592]                 else {
[10:29:57.592]                   if (TRUE) {
[10:29:57.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:57.592]                     {
[10:29:57.592]                       inherits <- base::inherits
[10:29:57.592]                       invokeRestart <- base::invokeRestart
[10:29:57.592]                       is.null <- base::is.null
[10:29:57.592]                       muffled <- FALSE
[10:29:57.592]                       if (inherits(cond, "message")) {
[10:29:57.592]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:57.592]                         if (muffled) 
[10:29:57.592]                           invokeRestart("muffleMessage")
[10:29:57.592]                       }
[10:29:57.592]                       else if (inherits(cond, "warning")) {
[10:29:57.592]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:57.592]                         if (muffled) 
[10:29:57.592]                           invokeRestart("muffleWarning")
[10:29:57.592]                       }
[10:29:57.592]                       else if (inherits(cond, "condition")) {
[10:29:57.592]                         if (!is.null(pattern)) {
[10:29:57.592]                           computeRestarts <- base::computeRestarts
[10:29:57.592]                           grepl <- base::grepl
[10:29:57.592]                           restarts <- computeRestarts(cond)
[10:29:57.592]                           for (restart in restarts) {
[10:29:57.592]                             name <- restart$name
[10:29:57.592]                             if (is.null(name)) 
[10:29:57.592]                               next
[10:29:57.592]                             if (!grepl(pattern, name)) 
[10:29:57.592]                               next
[10:29:57.592]                             invokeRestart(restart)
[10:29:57.592]                             muffled <- TRUE
[10:29:57.592]                             break
[10:29:57.592]                           }
[10:29:57.592]                         }
[10:29:57.592]                       }
[10:29:57.592]                       invisible(muffled)
[10:29:57.592]                     }
[10:29:57.592]                     muffleCondition(cond, pattern = "^muffle")
[10:29:57.592]                   }
[10:29:57.592]                 }
[10:29:57.592]             }
[10:29:57.592]         }))
[10:29:57.592]     }, error = function(ex) {
[10:29:57.592]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:57.592]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:57.592]                 ...future.rng), started = ...future.startTime, 
[10:29:57.592]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:57.592]             version = "1.8"), class = "FutureResult")
[10:29:57.592]     }, finally = {
[10:29:57.592]         if (!identical(...future.workdir, getwd())) 
[10:29:57.592]             setwd(...future.workdir)
[10:29:57.592]         {
[10:29:57.592]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:57.592]                 ...future.oldOptions$nwarnings <- NULL
[10:29:57.592]             }
[10:29:57.592]             base::options(...future.oldOptions)
[10:29:57.592]             if (.Platform$OS.type == "windows") {
[10:29:57.592]                 old_names <- names(...future.oldEnvVars)
[10:29:57.592]                 envs <- base::Sys.getenv()
[10:29:57.592]                 names <- names(envs)
[10:29:57.592]                 common <- intersect(names, old_names)
[10:29:57.592]                 added <- setdiff(names, old_names)
[10:29:57.592]                 removed <- setdiff(old_names, names)
[10:29:57.592]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:57.592]                   envs[common]]
[10:29:57.592]                 NAMES <- toupper(changed)
[10:29:57.592]                 args <- list()
[10:29:57.592]                 for (kk in seq_along(NAMES)) {
[10:29:57.592]                   name <- changed[[kk]]
[10:29:57.592]                   NAME <- NAMES[[kk]]
[10:29:57.592]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.592]                     next
[10:29:57.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:57.592]                 }
[10:29:57.592]                 NAMES <- toupper(added)
[10:29:57.592]                 for (kk in seq_along(NAMES)) {
[10:29:57.592]                   name <- added[[kk]]
[10:29:57.592]                   NAME <- NAMES[[kk]]
[10:29:57.592]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.592]                     next
[10:29:57.592]                   args[[name]] <- ""
[10:29:57.592]                 }
[10:29:57.592]                 NAMES <- toupper(removed)
[10:29:57.592]                 for (kk in seq_along(NAMES)) {
[10:29:57.592]                   name <- removed[[kk]]
[10:29:57.592]                   NAME <- NAMES[[kk]]
[10:29:57.592]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:57.592]                     next
[10:29:57.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:57.592]                 }
[10:29:57.592]                 if (length(args) > 0) 
[10:29:57.592]                   base::do.call(base::Sys.setenv, args = args)
[10:29:57.592]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:57.592]             }
[10:29:57.592]             else {
[10:29:57.592]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:57.592]             }
[10:29:57.592]             {
[10:29:57.592]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:57.592]                   0L) {
[10:29:57.592]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:57.592]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:57.592]                   base::options(opts)
[10:29:57.592]                 }
[10:29:57.592]                 {
[10:29:57.592]                   {
[10:29:57.592]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:57.592]                     NULL
[10:29:57.592]                   }
[10:29:57.592]                   options(future.plan = NULL)
[10:29:57.592]                   if (is.na(NA_character_)) 
[10:29:57.592]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:57.592]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:57.592]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:57.592]                     .init = FALSE)
[10:29:57.592]                 }
[10:29:57.592]             }
[10:29:57.592]         }
[10:29:57.592]     })
[10:29:57.592]     if (TRUE) {
[10:29:57.592]         base::sink(type = "output", split = FALSE)
[10:29:57.592]         if (TRUE) {
[10:29:57.592]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:57.592]         }
[10:29:57.592]         else {
[10:29:57.592]             ...future.result["stdout"] <- base::list(NULL)
[10:29:57.592]         }
[10:29:57.592]         base::close(...future.stdout)
[10:29:57.592]         ...future.stdout <- NULL
[10:29:57.592]     }
[10:29:57.592]     ...future.result$conditions <- ...future.conditions
[10:29:57.592]     ...future.result$finished <- base::Sys.time()
[10:29:57.592]     ...future.result
[10:29:57.592] }
[10:29:57.594] assign_globals() ...
[10:29:57.595] List of 5
[10:29:57.595]  $ ...future.FUN            :function (x, ...)  
[10:29:57.595]  $ future.call.arguments    : list()
[10:29:57.595]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:57.595]  $ ...future.elements_ii    :List of 2
[10:29:57.595]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:29:57.595]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:29:57.595]  $ ...future.seeds_ii       : NULL
[10:29:57.595]  $ ...future.globals.maxSize: NULL
[10:29:57.595]  - attr(*, "where")=List of 5
[10:29:57.595]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:29:57.595]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:29:57.595]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:29:57.595]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:29:57.595]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:29:57.595]  - attr(*, "resolved")= logi FALSE
[10:29:57.595]  - attr(*, "total_size")= num 1248
[10:29:57.595]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:57.595]  - attr(*, "already-done")= logi TRUE
[10:29:57.602] - copied ‘...future.FUN’ to environment
[10:29:57.603] - copied ‘future.call.arguments’ to environment
[10:29:57.603] - copied ‘...future.elements_ii’ to environment
[10:29:57.603] - copied ‘...future.seeds_ii’ to environment
[10:29:57.603] - copied ‘...future.globals.maxSize’ to environment
[10:29:57.603] assign_globals() ... done
[10:29:57.603] requestCore(): workers = 2
[10:29:57.606] MulticoreFuture started
[10:29:57.606] - Launch lazy future ... done
[10:29:57.606] run() for ‘MulticoreFuture’ ... done
[10:29:57.606] Created future:
[10:29:57.607] plan(): Setting new future strategy stack:
[10:29:57.607] List of future strategies:
[10:29:57.607] 1. sequential:
[10:29:57.607]    - args: function (..., envir = parent.frame())
[10:29:57.607]    - tweaked: FALSE
[10:29:57.607]    - call: NULL
[10:29:57.608] plan(): nbrOfWorkers() = 1
[10:29:57.611] plan(): Setting new future strategy stack:
[10:29:57.611] List of future strategies:
[10:29:57.611] 1. multicore:
[10:29:57.611]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:29:57.611]    - tweaked: FALSE
[10:29:57.611]    - call: plan(strategy)
[10:29:57.616] plan(): nbrOfWorkers() = 2
[10:29:57.607] MulticoreFuture:
[10:29:57.607] Label: ‘future_eapply-2’
[10:29:57.607] Expression:
[10:29:57.607] {
[10:29:57.607]     do.call(function(...) {
[10:29:57.607]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:57.607]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:57.607]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:57.607]             on.exit(options(oopts), add = TRUE)
[10:29:57.607]         }
[10:29:57.607]         {
[10:29:57.607]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:57.607]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:57.607]                 ...future.FUN(...future.X_jj, ...)
[10:29:57.607]             })
[10:29:57.607]         }
[10:29:57.607]     }, args = future.call.arguments)
[10:29:57.607] }
[10:29:57.607] Lazy evaluation: FALSE
[10:29:57.607] Asynchronous evaluation: TRUE
[10:29:57.607] Local evaluation: TRUE
[10:29:57.607] Environment: R_GlobalEnv
[10:29:57.607] Capture standard output: TRUE
[10:29:57.607] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:57.607] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:57.607] Packages: 1 packages (‘stats’)
[10:29:57.607] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:57.607] Resolved: TRUE
[10:29:57.607] Value: <not collected>
[10:29:57.607] Conditions captured: <none>
[10:29:57.607] Early signaling: FALSE
[10:29:57.607] Owner process: db6eb61b-64f1-ae95-7e8b-287fbc43411a
[10:29:57.607] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:57.617] Chunk #2 of 2 ... DONE
[10:29:57.617] Launching 2 futures (chunks) ... DONE
[10:29:57.617] Resolving 2 futures (chunks) ...
[10:29:57.618] resolve() on list ...
[10:29:57.618]  recursive: 0
[10:29:57.618]  length: 2
[10:29:57.618] 
[10:29:57.618] Future #1
[10:29:57.619] result() for MulticoreFuture ...
[10:29:57.620] result() for MulticoreFuture ...
[10:29:57.620] result() for MulticoreFuture ... done
[10:29:57.620] result() for MulticoreFuture ... done
[10:29:57.620] result() for MulticoreFuture ...
[10:29:57.620] result() for MulticoreFuture ... done
[10:29:57.620] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:29:57.621] - nx: 2
[10:29:57.621] - relay: TRUE
[10:29:57.621] - stdout: TRUE
[10:29:57.621] - signal: TRUE
[10:29:57.621] - resignal: FALSE
[10:29:57.621] - force: TRUE
[10:29:57.621] - relayed: [n=2] FALSE, FALSE
[10:29:57.622] - queued futures: [n=2] FALSE, FALSE
[10:29:57.622]  - until=1
[10:29:57.622]  - relaying element #1
[10:29:57.622] result() for MulticoreFuture ...
[10:29:57.622] result() for MulticoreFuture ... done
[10:29:57.622] result() for MulticoreFuture ...
[10:29:57.622] result() for MulticoreFuture ... done
[10:29:57.623] result() for MulticoreFuture ...
[10:29:57.623] result() for MulticoreFuture ... done
[10:29:57.623] result() for MulticoreFuture ...
[10:29:57.623] result() for MulticoreFuture ... done
[10:29:57.623] - relayed: [n=2] TRUE, FALSE
[10:29:57.623] - queued futures: [n=2] TRUE, FALSE
[10:29:57.623] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:29:57.624]  length: 1 (resolved future 1)
[10:29:57.624] Future #2
[10:29:57.624] result() for MulticoreFuture ...
[10:29:57.625] result() for MulticoreFuture ...
[10:29:57.625] result() for MulticoreFuture ... done
[10:29:57.625] result() for MulticoreFuture ... done
[10:29:57.625] result() for MulticoreFuture ...
[10:29:57.625] result() for MulticoreFuture ... done
[10:29:57.625] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:29:57.626] - nx: 2
[10:29:57.626] - relay: TRUE
[10:29:57.626] - stdout: TRUE
[10:29:57.626] - signal: TRUE
[10:29:57.626] - resignal: FALSE
[10:29:57.626] - force: TRUE
[10:29:57.626] - relayed: [n=2] TRUE, FALSE
[10:29:57.627] - queued futures: [n=2] TRUE, FALSE
[10:29:57.627]  - until=2
[10:29:57.627]  - relaying element #2
[10:29:57.627] result() for MulticoreFuture ...
[10:29:57.627] result() for MulticoreFuture ... done
[10:29:57.627] result() for MulticoreFuture ...
[10:29:57.627] result() for MulticoreFuture ... done
[10:29:57.627] result() for MulticoreFuture ...
[10:29:57.630] result() for MulticoreFuture ... done
[10:29:57.631] result() for MulticoreFuture ...
[10:29:57.631] result() for MulticoreFuture ... done
[10:29:57.631] - relayed: [n=2] TRUE, TRUE
[10:29:57.631] - queued futures: [n=2] TRUE, TRUE
[10:29:57.631] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:29:57.631]  length: 0 (resolved future 2)
[10:29:57.631] Relaying remaining futures
[10:29:57.631] signalConditionsASAP(NULL, pos=0) ...
[10:29:57.632] - nx: 2
[10:29:57.632] - relay: TRUE
[10:29:57.632] - stdout: TRUE
[10:29:57.632] - signal: TRUE
[10:29:57.632] - resignal: FALSE
[10:29:57.632] - force: TRUE
[10:29:57.632] - relayed: [n=2] TRUE, TRUE
[10:29:57.633] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:57.633] - relayed: [n=2] TRUE, TRUE
[10:29:57.633] - queued futures: [n=2] TRUE, TRUE
[10:29:57.633] signalConditionsASAP(NULL, pos=0) ... done
[10:29:57.633] resolve() on list ... DONE
[10:29:57.633] result() for MulticoreFuture ...
[10:29:57.633] result() for MulticoreFuture ... done
[10:29:57.634] result() for MulticoreFuture ...
[10:29:57.634] result() for MulticoreFuture ... done
[10:29:57.634] result() for MulticoreFuture ...
[10:29:57.634] result() for MulticoreFuture ... done
[10:29:57.634] result() for MulticoreFuture ...
[10:29:57.634] result() for MulticoreFuture ... done
[10:29:57.634]  - Number of value chunks collected: 2
[10:29:57.635] Resolving 2 futures (chunks) ... DONE
[10:29:57.635] Reducing values from 2 chunks ...
[10:29:57.635]  - Number of values collected after concatenation: 3
[10:29:57.635]  - Number of values expected: 3
[10:29:57.635] Reducing values from 2 chunks ... DONE
[10:29:57.635] future_lapply() ... DONE
[10:29:57.636] plan(): Setting new future strategy stack:
[10:29:57.636] List of future strategies:
[10:29:57.636] 1. sequential:
[10:29:57.636]    - args: function (..., envir = parent.frame())
[10:29:57.636]    - tweaked: FALSE
[10:29:57.636]    - call: plan(sequential)
[10:29:57.636] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[10:29:57.637] plan(): Setting new future strategy stack:
[10:29:57.637] List of future strategies:
[10:29:57.637] 1. multisession:
[10:29:57.637]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:29:57.637]    - tweaked: FALSE
[10:29:57.637]    - call: plan(strategy)
[10:29:57.637] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:29:57.638] multisession:
[10:29:57.638] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:29:57.638] - tweaked: FALSE
[10:29:57.638] - call: plan(strategy)
[10:29:57.645] getGlobalsAndPackages() ...
[10:29:57.645] Not searching for globals
[10:29:57.645] - globals: [0] <none>
[10:29:57.645] getGlobalsAndPackages() ... DONE
[10:29:57.646] [local output] makeClusterPSOCK() ...
[10:29:57.691] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:29:57.693] [local output] Base port: 11644
[10:29:57.693] [local output] Getting setup options for 2 cluster nodes ...
[10:29:57.693] [local output]  - Node 1 of 2 ...
[10:29:57.693] [local output] localMachine=TRUE => revtunnel=FALSE

[10:29:57.694] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpoCSmtD/worker.rank=1.parallelly.parent=68752.10c904dff2aac.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpoCSmtD/worker.rank=1.parallelly.parent=68752.10c904dff2aac.pid")'’
[10:29:57.885] - Possible to infer worker's PID: TRUE
[10:29:57.886] [local output] Rscript port: 11644

[10:29:57.886] [local output]  - Node 2 of 2 ...
[10:29:57.886] [local output] localMachine=TRUE => revtunnel=FALSE

[10:29:57.887] [local output] Rscript port: 11644

[10:29:57.887] [local output] Getting setup options for 2 cluster nodes ... done
[10:29:57.887] [local output]  - Parallel setup requested for some PSOCK nodes
[10:29:57.888] [local output] Setting up PSOCK nodes in parallel
[10:29:57.888] List of 36
[10:29:57.888]  $ worker          : chr "localhost"
[10:29:57.888]   ..- attr(*, "localhost")= logi TRUE
[10:29:57.888]  $ master          : chr "localhost"
[10:29:57.888]  $ port            : int 11644
[10:29:57.888]  $ connectTimeout  : num 120
[10:29:57.888]  $ timeout         : num 2592000
[10:29:57.888]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:29:57.888]  $ homogeneous     : logi TRUE
[10:29:57.888]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:29:57.888]  $ rscript_envs    : NULL
[10:29:57.888]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:29:57.888]  $ rscript_startup : NULL
[10:29:57.888]  $ rscript_sh      : chr "sh"
[10:29:57.888]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:29:57.888]  $ methods         : logi TRUE
[10:29:57.888]  $ socketOptions   : chr "no-delay"
[10:29:57.888]  $ useXDR          : logi FALSE
[10:29:57.888]  $ outfile         : chr "/dev/null"
[10:29:57.888]  $ renice          : int NA
[10:29:57.888]  $ rshcmd          : NULL
[10:29:57.888]  $ user            : chr(0) 
[10:29:57.888]  $ revtunnel       : logi FALSE
[10:29:57.888]  $ rshlogfile      : NULL
[10:29:57.888]  $ rshopts         : chr(0) 
[10:29:57.888]  $ rank            : int 1
[10:29:57.888]  $ manual          : logi FALSE
[10:29:57.888]  $ dryrun          : logi FALSE
[10:29:57.888]  $ quiet           : logi FALSE
[10:29:57.888]  $ setup_strategy  : chr "parallel"
[10:29:57.888]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:29:57.888]  $ pidfile         : chr "/tmp/RtmpoCSmtD/worker.rank=1.parallelly.parent=68752.10c904dff2aac.pid"
[10:29:57.888]  $ rshcmd_label    : NULL
[10:29:57.888]  $ rsh_call        : NULL
[10:29:57.888]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:29:57.888]  $ localMachine    : logi TRUE
[10:29:57.888]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:29:57.888]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:29:57.888]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:29:57.888]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:29:57.888]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:29:57.888]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:29:57.888]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:29:57.888]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:29:57.888]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:29:57.888]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:29:57.888]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:29:57.888]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:29:57.888]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:29:57.888]  $ arguments       :List of 28
[10:29:57.888]   ..$ worker          : chr "localhost"
[10:29:57.888]   ..$ master          : NULL
[10:29:57.888]   ..$ port            : int 11644
[10:29:57.888]   ..$ connectTimeout  : num 120
[10:29:57.888]   ..$ timeout         : num 2592000
[10:29:57.888]   ..$ rscript         : NULL
[10:29:57.888]   ..$ homogeneous     : NULL
[10:29:57.888]   ..$ rscript_args    : NULL
[10:29:57.888]   ..$ rscript_envs    : NULL
[10:29:57.888]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:29:57.888]   ..$ rscript_startup : NULL
[10:29:57.888]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:29:57.888]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:29:57.888]   ..$ methods         : logi TRUE
[10:29:57.888]   ..$ socketOptions   : chr "no-delay"
[10:29:57.888]   ..$ useXDR          : logi FALSE
[10:29:57.888]   ..$ outfile         : chr "/dev/null"
[10:29:57.888]   ..$ renice          : int NA
[10:29:57.888]   ..$ rshcmd          : NULL
[10:29:57.888]   ..$ user            : NULL
[10:29:57.888]   ..$ revtunnel       : logi NA
[10:29:57.888]   ..$ rshlogfile      : NULL
[10:29:57.888]   ..$ rshopts         : NULL
[10:29:57.888]   ..$ rank            : int 1
[10:29:57.888]   ..$ manual          : logi FALSE
[10:29:57.888]   ..$ dryrun          : logi FALSE
[10:29:57.888]   ..$ quiet           : logi FALSE
[10:29:57.888]   ..$ setup_strategy  : chr "parallel"
[10:29:57.888]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:29:57.905] [local output] System call to launch all workers:
[10:29:57.905] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpoCSmtD/worker.rank=1.parallelly.parent=68752.10c904dff2aac.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11644 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:29:57.905] [local output] Starting PSOCK main server
[10:29:57.911] [local output] Workers launched
[10:29:57.911] [local output] Waiting for workers to connect back
[10:29:57.911]  - [local output] 0 workers out of 2 ready
[10:29:58.180]  - [local output] 0 workers out of 2 ready
[10:29:58.180]  - [local output] 1 workers out of 2 ready
[10:29:58.180]  - [local output] 2 workers out of 2 ready
[10:29:58.181] [local output] Launching of workers completed
[10:29:58.181] [local output] Collecting session information from workers
[10:29:58.182] [local output]  - Worker #1 of 2
[10:29:58.182] [local output]  - Worker #2 of 2
[10:29:58.182] [local output] makeClusterPSOCK() ... done
[10:29:58.194] Packages needed by the future expression (n = 0): <none>
[10:29:58.194] Packages needed by future strategies (n = 0): <none>
[10:29:58.195] {
[10:29:58.195]     {
[10:29:58.195]         {
[10:29:58.195]             ...future.startTime <- base::Sys.time()
[10:29:58.195]             {
[10:29:58.195]                 {
[10:29:58.195]                   {
[10:29:58.195]                     {
[10:29:58.195]                       base::local({
[10:29:58.195]                         has_future <- base::requireNamespace("future", 
[10:29:58.195]                           quietly = TRUE)
[10:29:58.195]                         if (has_future) {
[10:29:58.195]                           ns <- base::getNamespace("future")
[10:29:58.195]                           version <- ns[[".package"]][["version"]]
[10:29:58.195]                           if (is.null(version)) 
[10:29:58.195]                             version <- utils::packageVersion("future")
[10:29:58.195]                         }
[10:29:58.195]                         else {
[10:29:58.195]                           version <- NULL
[10:29:58.195]                         }
[10:29:58.195]                         if (!has_future || version < "1.8.0") {
[10:29:58.195]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:58.195]                             "", base::R.version$version.string), 
[10:29:58.195]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:58.195]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:58.195]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:58.195]                               "release", "version")], collapse = " "), 
[10:29:58.195]                             hostname = base::Sys.info()[["nodename"]])
[10:29:58.195]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:58.195]                             info)
[10:29:58.195]                           info <- base::paste(info, collapse = "; ")
[10:29:58.195]                           if (!has_future) {
[10:29:58.195]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:58.195]                               info)
[10:29:58.195]                           }
[10:29:58.195]                           else {
[10:29:58.195]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:58.195]                               info, version)
[10:29:58.195]                           }
[10:29:58.195]                           base::stop(msg)
[10:29:58.195]                         }
[10:29:58.195]                       })
[10:29:58.195]                     }
[10:29:58.195]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:58.195]                     base::options(mc.cores = 1L)
[10:29:58.195]                   }
[10:29:58.195]                   ...future.strategy.old <- future::plan("list")
[10:29:58.195]                   options(future.plan = NULL)
[10:29:58.195]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:58.195]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:58.195]                 }
[10:29:58.195]                 ...future.workdir <- getwd()
[10:29:58.195]             }
[10:29:58.195]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:58.195]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:58.195]         }
[10:29:58.195]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:58.195]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:29:58.195]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:58.195]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:58.195]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:58.195]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:58.195]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:58.195]             base::names(...future.oldOptions))
[10:29:58.195]     }
[10:29:58.195]     if (FALSE) {
[10:29:58.195]     }
[10:29:58.195]     else {
[10:29:58.195]         if (TRUE) {
[10:29:58.195]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:58.195]                 open = "w")
[10:29:58.195]         }
[10:29:58.195]         else {
[10:29:58.195]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:58.195]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:58.195]         }
[10:29:58.195]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:58.195]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:58.195]             base::sink(type = "output", split = FALSE)
[10:29:58.195]             base::close(...future.stdout)
[10:29:58.195]         }, add = TRUE)
[10:29:58.195]     }
[10:29:58.195]     ...future.frame <- base::sys.nframe()
[10:29:58.195]     ...future.conditions <- base::list()
[10:29:58.195]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:58.195]     if (FALSE) {
[10:29:58.195]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:58.195]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:58.195]     }
[10:29:58.195]     ...future.result <- base::tryCatch({
[10:29:58.195]         base::withCallingHandlers({
[10:29:58.195]             ...future.value <- base::withVisible(base::local({
[10:29:58.195]                 ...future.makeSendCondition <- base::local({
[10:29:58.195]                   sendCondition <- NULL
[10:29:58.195]                   function(frame = 1L) {
[10:29:58.195]                     if (is.function(sendCondition)) 
[10:29:58.195]                       return(sendCondition)
[10:29:58.195]                     ns <- getNamespace("parallel")
[10:29:58.195]                     if (exists("sendData", mode = "function", 
[10:29:58.195]                       envir = ns)) {
[10:29:58.195]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:58.195]                         envir = ns)
[10:29:58.195]                       envir <- sys.frame(frame)
[10:29:58.195]                       master <- NULL
[10:29:58.195]                       while (!identical(envir, .GlobalEnv) && 
[10:29:58.195]                         !identical(envir, emptyenv())) {
[10:29:58.195]                         if (exists("master", mode = "list", envir = envir, 
[10:29:58.195]                           inherits = FALSE)) {
[10:29:58.195]                           master <- get("master", mode = "list", 
[10:29:58.195]                             envir = envir, inherits = FALSE)
[10:29:58.195]                           if (inherits(master, c("SOCKnode", 
[10:29:58.195]                             "SOCK0node"))) {
[10:29:58.195]                             sendCondition <<- function(cond) {
[10:29:58.195]                               data <- list(type = "VALUE", value = cond, 
[10:29:58.195]                                 success = TRUE)
[10:29:58.195]                               parallel_sendData(master, data)
[10:29:58.195]                             }
[10:29:58.195]                             return(sendCondition)
[10:29:58.195]                           }
[10:29:58.195]                         }
[10:29:58.195]                         frame <- frame + 1L
[10:29:58.195]                         envir <- sys.frame(frame)
[10:29:58.195]                       }
[10:29:58.195]                     }
[10:29:58.195]                     sendCondition <<- function(cond) NULL
[10:29:58.195]                   }
[10:29:58.195]                 })
[10:29:58.195]                 withCallingHandlers({
[10:29:58.195]                   NA
[10:29:58.195]                 }, immediateCondition = function(cond) {
[10:29:58.195]                   sendCondition <- ...future.makeSendCondition()
[10:29:58.195]                   sendCondition(cond)
[10:29:58.195]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.195]                   {
[10:29:58.195]                     inherits <- base::inherits
[10:29:58.195]                     invokeRestart <- base::invokeRestart
[10:29:58.195]                     is.null <- base::is.null
[10:29:58.195]                     muffled <- FALSE
[10:29:58.195]                     if (inherits(cond, "message")) {
[10:29:58.195]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:58.195]                       if (muffled) 
[10:29:58.195]                         invokeRestart("muffleMessage")
[10:29:58.195]                     }
[10:29:58.195]                     else if (inherits(cond, "warning")) {
[10:29:58.195]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:58.195]                       if (muffled) 
[10:29:58.195]                         invokeRestart("muffleWarning")
[10:29:58.195]                     }
[10:29:58.195]                     else if (inherits(cond, "condition")) {
[10:29:58.195]                       if (!is.null(pattern)) {
[10:29:58.195]                         computeRestarts <- base::computeRestarts
[10:29:58.195]                         grepl <- base::grepl
[10:29:58.195]                         restarts <- computeRestarts(cond)
[10:29:58.195]                         for (restart in restarts) {
[10:29:58.195]                           name <- restart$name
[10:29:58.195]                           if (is.null(name)) 
[10:29:58.195]                             next
[10:29:58.195]                           if (!grepl(pattern, name)) 
[10:29:58.195]                             next
[10:29:58.195]                           invokeRestart(restart)
[10:29:58.195]                           muffled <- TRUE
[10:29:58.195]                           break
[10:29:58.195]                         }
[10:29:58.195]                       }
[10:29:58.195]                     }
[10:29:58.195]                     invisible(muffled)
[10:29:58.195]                   }
[10:29:58.195]                   muffleCondition(cond)
[10:29:58.195]                 })
[10:29:58.195]             }))
[10:29:58.195]             future::FutureResult(value = ...future.value$value, 
[10:29:58.195]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:58.195]                   ...future.rng), globalenv = if (FALSE) 
[10:29:58.195]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:58.195]                     ...future.globalenv.names))
[10:29:58.195]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:58.195]         }, condition = base::local({
[10:29:58.195]             c <- base::c
[10:29:58.195]             inherits <- base::inherits
[10:29:58.195]             invokeRestart <- base::invokeRestart
[10:29:58.195]             length <- base::length
[10:29:58.195]             list <- base::list
[10:29:58.195]             seq.int <- base::seq.int
[10:29:58.195]             signalCondition <- base::signalCondition
[10:29:58.195]             sys.calls <- base::sys.calls
[10:29:58.195]             `[[` <- base::`[[`
[10:29:58.195]             `+` <- base::`+`
[10:29:58.195]             `<<-` <- base::`<<-`
[10:29:58.195]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:58.195]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:58.195]                   3L)]
[10:29:58.195]             }
[10:29:58.195]             function(cond) {
[10:29:58.195]                 is_error <- inherits(cond, "error")
[10:29:58.195]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:58.195]                   NULL)
[10:29:58.195]                 if (is_error) {
[10:29:58.195]                   sessionInformation <- function() {
[10:29:58.195]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:58.195]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:58.195]                       search = base::search(), system = base::Sys.info())
[10:29:58.195]                   }
[10:29:58.195]                   ...future.conditions[[length(...future.conditions) + 
[10:29:58.195]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:58.195]                     cond$call), session = sessionInformation(), 
[10:29:58.195]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:58.195]                   signalCondition(cond)
[10:29:58.195]                 }
[10:29:58.195]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:58.195]                 "immediateCondition"))) {
[10:29:58.195]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:58.195]                   ...future.conditions[[length(...future.conditions) + 
[10:29:58.195]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:58.195]                   if (TRUE && !signal) {
[10:29:58.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.195]                     {
[10:29:58.195]                       inherits <- base::inherits
[10:29:58.195]                       invokeRestart <- base::invokeRestart
[10:29:58.195]                       is.null <- base::is.null
[10:29:58.195]                       muffled <- FALSE
[10:29:58.195]                       if (inherits(cond, "message")) {
[10:29:58.195]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:58.195]                         if (muffled) 
[10:29:58.195]                           invokeRestart("muffleMessage")
[10:29:58.195]                       }
[10:29:58.195]                       else if (inherits(cond, "warning")) {
[10:29:58.195]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:58.195]                         if (muffled) 
[10:29:58.195]                           invokeRestart("muffleWarning")
[10:29:58.195]                       }
[10:29:58.195]                       else if (inherits(cond, "condition")) {
[10:29:58.195]                         if (!is.null(pattern)) {
[10:29:58.195]                           computeRestarts <- base::computeRestarts
[10:29:58.195]                           grepl <- base::grepl
[10:29:58.195]                           restarts <- computeRestarts(cond)
[10:29:58.195]                           for (restart in restarts) {
[10:29:58.195]                             name <- restart$name
[10:29:58.195]                             if (is.null(name)) 
[10:29:58.195]                               next
[10:29:58.195]                             if (!grepl(pattern, name)) 
[10:29:58.195]                               next
[10:29:58.195]                             invokeRestart(restart)
[10:29:58.195]                             muffled <- TRUE
[10:29:58.195]                             break
[10:29:58.195]                           }
[10:29:58.195]                         }
[10:29:58.195]                       }
[10:29:58.195]                       invisible(muffled)
[10:29:58.195]                     }
[10:29:58.195]                     muffleCondition(cond, pattern = "^muffle")
[10:29:58.195]                   }
[10:29:58.195]                 }
[10:29:58.195]                 else {
[10:29:58.195]                   if (TRUE) {
[10:29:58.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.195]                     {
[10:29:58.195]                       inherits <- base::inherits
[10:29:58.195]                       invokeRestart <- base::invokeRestart
[10:29:58.195]                       is.null <- base::is.null
[10:29:58.195]                       muffled <- FALSE
[10:29:58.195]                       if (inherits(cond, "message")) {
[10:29:58.195]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:58.195]                         if (muffled) 
[10:29:58.195]                           invokeRestart("muffleMessage")
[10:29:58.195]                       }
[10:29:58.195]                       else if (inherits(cond, "warning")) {
[10:29:58.195]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:58.195]                         if (muffled) 
[10:29:58.195]                           invokeRestart("muffleWarning")
[10:29:58.195]                       }
[10:29:58.195]                       else if (inherits(cond, "condition")) {
[10:29:58.195]                         if (!is.null(pattern)) {
[10:29:58.195]                           computeRestarts <- base::computeRestarts
[10:29:58.195]                           grepl <- base::grepl
[10:29:58.195]                           restarts <- computeRestarts(cond)
[10:29:58.195]                           for (restart in restarts) {
[10:29:58.195]                             name <- restart$name
[10:29:58.195]                             if (is.null(name)) 
[10:29:58.195]                               next
[10:29:58.195]                             if (!grepl(pattern, name)) 
[10:29:58.195]                               next
[10:29:58.195]                             invokeRestart(restart)
[10:29:58.195]                             muffled <- TRUE
[10:29:58.195]                             break
[10:29:58.195]                           }
[10:29:58.195]                         }
[10:29:58.195]                       }
[10:29:58.195]                       invisible(muffled)
[10:29:58.195]                     }
[10:29:58.195]                     muffleCondition(cond, pattern = "^muffle")
[10:29:58.195]                   }
[10:29:58.195]                 }
[10:29:58.195]             }
[10:29:58.195]         }))
[10:29:58.195]     }, error = function(ex) {
[10:29:58.195]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:58.195]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:58.195]                 ...future.rng), started = ...future.startTime, 
[10:29:58.195]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:58.195]             version = "1.8"), class = "FutureResult")
[10:29:58.195]     }, finally = {
[10:29:58.195]         if (!identical(...future.workdir, getwd())) 
[10:29:58.195]             setwd(...future.workdir)
[10:29:58.195]         {
[10:29:58.195]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:58.195]                 ...future.oldOptions$nwarnings <- NULL
[10:29:58.195]             }
[10:29:58.195]             base::options(...future.oldOptions)
[10:29:58.195]             if (.Platform$OS.type == "windows") {
[10:29:58.195]                 old_names <- names(...future.oldEnvVars)
[10:29:58.195]                 envs <- base::Sys.getenv()
[10:29:58.195]                 names <- names(envs)
[10:29:58.195]                 common <- intersect(names, old_names)
[10:29:58.195]                 added <- setdiff(names, old_names)
[10:29:58.195]                 removed <- setdiff(old_names, names)
[10:29:58.195]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:58.195]                   envs[common]]
[10:29:58.195]                 NAMES <- toupper(changed)
[10:29:58.195]                 args <- list()
[10:29:58.195]                 for (kk in seq_along(NAMES)) {
[10:29:58.195]                   name <- changed[[kk]]
[10:29:58.195]                   NAME <- NAMES[[kk]]
[10:29:58.195]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.195]                     next
[10:29:58.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:58.195]                 }
[10:29:58.195]                 NAMES <- toupper(added)
[10:29:58.195]                 for (kk in seq_along(NAMES)) {
[10:29:58.195]                   name <- added[[kk]]
[10:29:58.195]                   NAME <- NAMES[[kk]]
[10:29:58.195]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.195]                     next
[10:29:58.195]                   args[[name]] <- ""
[10:29:58.195]                 }
[10:29:58.195]                 NAMES <- toupper(removed)
[10:29:58.195]                 for (kk in seq_along(NAMES)) {
[10:29:58.195]                   name <- removed[[kk]]
[10:29:58.195]                   NAME <- NAMES[[kk]]
[10:29:58.195]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.195]                     next
[10:29:58.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:58.195]                 }
[10:29:58.195]                 if (length(args) > 0) 
[10:29:58.195]                   base::do.call(base::Sys.setenv, args = args)
[10:29:58.195]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:58.195]             }
[10:29:58.195]             else {
[10:29:58.195]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:58.195]             }
[10:29:58.195]             {
[10:29:58.195]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:58.195]                   0L) {
[10:29:58.195]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:58.195]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:58.195]                   base::options(opts)
[10:29:58.195]                 }
[10:29:58.195]                 {
[10:29:58.195]                   {
[10:29:58.195]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:58.195]                     NULL
[10:29:58.195]                   }
[10:29:58.195]                   options(future.plan = NULL)
[10:29:58.195]                   if (is.na(NA_character_)) 
[10:29:58.195]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:58.195]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:58.195]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:58.195]                     .init = FALSE)
[10:29:58.195]                 }
[10:29:58.195]             }
[10:29:58.195]         }
[10:29:58.195]     })
[10:29:58.195]     if (TRUE) {
[10:29:58.195]         base::sink(type = "output", split = FALSE)
[10:29:58.195]         if (TRUE) {
[10:29:58.195]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:58.195]         }
[10:29:58.195]         else {
[10:29:58.195]             ...future.result["stdout"] <- base::list(NULL)
[10:29:58.195]         }
[10:29:58.195]         base::close(...future.stdout)
[10:29:58.195]         ...future.stdout <- NULL
[10:29:58.195]     }
[10:29:58.195]     ...future.result$conditions <- ...future.conditions
[10:29:58.195]     ...future.result$finished <- base::Sys.time()
[10:29:58.195]     ...future.result
[10:29:58.195] }
[10:29:58.249] MultisessionFuture started
[10:29:58.249] result() for ClusterFuture ...
[10:29:58.250] receiveMessageFromWorker() for ClusterFuture ...
[10:29:58.250] - Validating connection of MultisessionFuture
[10:29:58.283] - received message: FutureResult
[10:29:58.284] - Received FutureResult
[10:29:58.284] - Erased future from FutureRegistry
[10:29:58.284] result() for ClusterFuture ...
[10:29:58.284] - result already collected: FutureResult
[10:29:58.284] result() for ClusterFuture ... done
[10:29:58.284] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:58.285] result() for ClusterFuture ... done
[10:29:58.285] result() for ClusterFuture ...
[10:29:58.285] - result already collected: FutureResult
[10:29:58.285] result() for ClusterFuture ... done
[10:29:58.285] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:29:58.289] plan(): nbrOfWorkers() = 2
[10:29:58.289] future_lapply() ...
[10:29:58.294] Number of chunks: 2
[10:29:58.294] getGlobalsAndPackagesXApply() ...
[10:29:58.294]  - future.globals: TRUE
[10:29:58.294] getGlobalsAndPackages() ...
[10:29:58.294] Searching for globals...
[10:29:58.296] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:58.296] Searching for globals ... DONE
[10:29:58.296] Resolving globals: FALSE
[10:29:58.296] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[10:29:58.297] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[10:29:58.297] - globals: [1] ‘FUN’
[10:29:58.297] 
[10:29:58.297] getGlobalsAndPackages() ... DONE
[10:29:58.297]  - globals found/used: [n=1] ‘FUN’
[10:29:58.298]  - needed namespaces: [n=0] 
[10:29:58.298] Finding globals ... DONE
[10:29:58.298]  - use_args: TRUE
[10:29:58.298]  - Getting '...' globals ...
[10:29:58.298] resolve() on list ...
[10:29:58.298]  recursive: 0
[10:29:58.298]  length: 1
[10:29:58.299]  elements: ‘...’
[10:29:58.299]  length: 0 (resolved future 1)
[10:29:58.299] resolve() on list ... DONE
[10:29:58.299]    - '...' content: [n=0] 
[10:29:58.299] List of 1
[10:29:58.299]  $ ...: list()
[10:29:58.299]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:58.299]  - attr(*, "where")=List of 1
[10:29:58.299]   ..$ ...:<environment: 0x55974c6e5fa0> 
[10:29:58.299]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:58.299]  - attr(*, "resolved")= logi TRUE
[10:29:58.299]  - attr(*, "total_size")= num NA
[10:29:58.302]  - Getting '...' globals ... DONE
[10:29:58.303] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:58.303] List of 2
[10:29:58.303]  $ ...future.FUN:function (x, ...)  
[10:29:58.303]  $ ...          : list()
[10:29:58.303]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:58.303]  - attr(*, "where")=List of 2
[10:29:58.303]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:58.303]   ..$ ...          :<environment: 0x55974c6e5fa0> 
[10:29:58.303]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:58.303]  - attr(*, "resolved")= logi FALSE
[10:29:58.303]  - attr(*, "total_size")= num 1240
[10:29:58.306] Packages to be attached in all futures: [n=0] 
[10:29:58.306] getGlobalsAndPackagesXApply() ... DONE
[10:29:58.306] Number of futures (= number of chunks): 2
[10:29:58.307] Launching 2 futures (chunks) ...
[10:29:58.307] Chunk #1 of 2 ...
[10:29:58.307]  - Finding globals in 'X' for chunk #1 ...
[10:29:58.307] getGlobalsAndPackages() ...
[10:29:58.307] Searching for globals...
[10:29:58.307] 
[10:29:58.308] Searching for globals ... DONE
[10:29:58.308] - globals: [0] <none>
[10:29:58.308] getGlobalsAndPackages() ... DONE
[10:29:58.308]    + additional globals found: [n=0] 
[10:29:58.308]    + additional namespaces needed: [n=0] 
[10:29:58.308]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:58.308]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:58.308]  - seeds: <none>
[10:29:58.308]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:58.309] getGlobalsAndPackages() ...
[10:29:58.309] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:58.309] Resolving globals: FALSE
[10:29:58.309] Tweak future expression to call with '...' arguments ...
[10:29:58.309] {
[10:29:58.309]     do.call(function(...) {
[10:29:58.309]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:58.309]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:58.309]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:58.309]             on.exit(options(oopts), add = TRUE)
[10:29:58.309]         }
[10:29:58.309]         {
[10:29:58.309]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:58.309]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:58.309]                 ...future.FUN(...future.X_jj, ...)
[10:29:58.309]             })
[10:29:58.309]         }
[10:29:58.309]     }, args = future.call.arguments)
[10:29:58.309] }
[10:29:58.310] Tweak future expression to call with '...' arguments ... DONE
[10:29:58.310] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:58.310] 
[10:29:58.310] getGlobalsAndPackages() ... DONE
[10:29:58.311] run() for ‘Future’ ...
[10:29:58.311] - state: ‘created’
[10:29:58.311] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:58.325] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:58.325] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:58.325]   - Field: ‘node’
[10:29:58.326]   - Field: ‘label’
[10:29:58.326]   - Field: ‘local’
[10:29:58.326]   - Field: ‘owner’
[10:29:58.326]   - Field: ‘envir’
[10:29:58.326]   - Field: ‘workers’
[10:29:58.326]   - Field: ‘packages’
[10:29:58.326]   - Field: ‘gc’
[10:29:58.326]   - Field: ‘conditions’
[10:29:58.326]   - Field: ‘persistent’
[10:29:58.326]   - Field: ‘expr’
[10:29:58.327]   - Field: ‘uuid’
[10:29:58.327]   - Field: ‘seed’
[10:29:58.327]   - Field: ‘version’
[10:29:58.327]   - Field: ‘result’
[10:29:58.327]   - Field: ‘asynchronous’
[10:29:58.327]   - Field: ‘calls’
[10:29:58.327]   - Field: ‘globals’
[10:29:58.327]   - Field: ‘stdout’
[10:29:58.327]   - Field: ‘earlySignal’
[10:29:58.328]   - Field: ‘lazy’
[10:29:58.328]   - Field: ‘state’
[10:29:58.328] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:58.328] - Launch lazy future ...
[10:29:58.328] Packages needed by the future expression (n = 0): <none>
[10:29:58.328] Packages needed by future strategies (n = 0): <none>
[10:29:58.329] {
[10:29:58.329]     {
[10:29:58.329]         {
[10:29:58.329]             ...future.startTime <- base::Sys.time()
[10:29:58.329]             {
[10:29:58.329]                 {
[10:29:58.329]                   {
[10:29:58.329]                     {
[10:29:58.329]                       base::local({
[10:29:58.329]                         has_future <- base::requireNamespace("future", 
[10:29:58.329]                           quietly = TRUE)
[10:29:58.329]                         if (has_future) {
[10:29:58.329]                           ns <- base::getNamespace("future")
[10:29:58.329]                           version <- ns[[".package"]][["version"]]
[10:29:58.329]                           if (is.null(version)) 
[10:29:58.329]                             version <- utils::packageVersion("future")
[10:29:58.329]                         }
[10:29:58.329]                         else {
[10:29:58.329]                           version <- NULL
[10:29:58.329]                         }
[10:29:58.329]                         if (!has_future || version < "1.8.0") {
[10:29:58.329]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:58.329]                             "", base::R.version$version.string), 
[10:29:58.329]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:58.329]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:58.329]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:58.329]                               "release", "version")], collapse = " "), 
[10:29:58.329]                             hostname = base::Sys.info()[["nodename"]])
[10:29:58.329]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:58.329]                             info)
[10:29:58.329]                           info <- base::paste(info, collapse = "; ")
[10:29:58.329]                           if (!has_future) {
[10:29:58.329]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:58.329]                               info)
[10:29:58.329]                           }
[10:29:58.329]                           else {
[10:29:58.329]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:58.329]                               info, version)
[10:29:58.329]                           }
[10:29:58.329]                           base::stop(msg)
[10:29:58.329]                         }
[10:29:58.329]                       })
[10:29:58.329]                     }
[10:29:58.329]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:58.329]                     base::options(mc.cores = 1L)
[10:29:58.329]                   }
[10:29:58.329]                   ...future.strategy.old <- future::plan("list")
[10:29:58.329]                   options(future.plan = NULL)
[10:29:58.329]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:58.329]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:58.329]                 }
[10:29:58.329]                 ...future.workdir <- getwd()
[10:29:58.329]             }
[10:29:58.329]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:58.329]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:58.329]         }
[10:29:58.329]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:58.329]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:58.329]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:58.329]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:58.329]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:58.329]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:58.329]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:58.329]             base::names(...future.oldOptions))
[10:29:58.329]     }
[10:29:58.329]     if (FALSE) {
[10:29:58.329]     }
[10:29:58.329]     else {
[10:29:58.329]         if (TRUE) {
[10:29:58.329]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:58.329]                 open = "w")
[10:29:58.329]         }
[10:29:58.329]         else {
[10:29:58.329]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:58.329]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:58.329]         }
[10:29:58.329]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:58.329]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:58.329]             base::sink(type = "output", split = FALSE)
[10:29:58.329]             base::close(...future.stdout)
[10:29:58.329]         }, add = TRUE)
[10:29:58.329]     }
[10:29:58.329]     ...future.frame <- base::sys.nframe()
[10:29:58.329]     ...future.conditions <- base::list()
[10:29:58.329]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:58.329]     if (FALSE) {
[10:29:58.329]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:58.329]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:58.329]     }
[10:29:58.329]     ...future.result <- base::tryCatch({
[10:29:58.329]         base::withCallingHandlers({
[10:29:58.329]             ...future.value <- base::withVisible(base::local({
[10:29:58.329]                 ...future.makeSendCondition <- base::local({
[10:29:58.329]                   sendCondition <- NULL
[10:29:58.329]                   function(frame = 1L) {
[10:29:58.329]                     if (is.function(sendCondition)) 
[10:29:58.329]                       return(sendCondition)
[10:29:58.329]                     ns <- getNamespace("parallel")
[10:29:58.329]                     if (exists("sendData", mode = "function", 
[10:29:58.329]                       envir = ns)) {
[10:29:58.329]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:58.329]                         envir = ns)
[10:29:58.329]                       envir <- sys.frame(frame)
[10:29:58.329]                       master <- NULL
[10:29:58.329]                       while (!identical(envir, .GlobalEnv) && 
[10:29:58.329]                         !identical(envir, emptyenv())) {
[10:29:58.329]                         if (exists("master", mode = "list", envir = envir, 
[10:29:58.329]                           inherits = FALSE)) {
[10:29:58.329]                           master <- get("master", mode = "list", 
[10:29:58.329]                             envir = envir, inherits = FALSE)
[10:29:58.329]                           if (inherits(master, c("SOCKnode", 
[10:29:58.329]                             "SOCK0node"))) {
[10:29:58.329]                             sendCondition <<- function(cond) {
[10:29:58.329]                               data <- list(type = "VALUE", value = cond, 
[10:29:58.329]                                 success = TRUE)
[10:29:58.329]                               parallel_sendData(master, data)
[10:29:58.329]                             }
[10:29:58.329]                             return(sendCondition)
[10:29:58.329]                           }
[10:29:58.329]                         }
[10:29:58.329]                         frame <- frame + 1L
[10:29:58.329]                         envir <- sys.frame(frame)
[10:29:58.329]                       }
[10:29:58.329]                     }
[10:29:58.329]                     sendCondition <<- function(cond) NULL
[10:29:58.329]                   }
[10:29:58.329]                 })
[10:29:58.329]                 withCallingHandlers({
[10:29:58.329]                   {
[10:29:58.329]                     do.call(function(...) {
[10:29:58.329]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:58.329]                       if (!identical(...future.globals.maxSize.org, 
[10:29:58.329]                         ...future.globals.maxSize)) {
[10:29:58.329]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:58.329]                         on.exit(options(oopts), add = TRUE)
[10:29:58.329]                       }
[10:29:58.329]                       {
[10:29:58.329]                         lapply(seq_along(...future.elements_ii), 
[10:29:58.329]                           FUN = function(jj) {
[10:29:58.329]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:58.329]                             ...future.FUN(...future.X_jj, ...)
[10:29:58.329]                           })
[10:29:58.329]                       }
[10:29:58.329]                     }, args = future.call.arguments)
[10:29:58.329]                   }
[10:29:58.329]                 }, immediateCondition = function(cond) {
[10:29:58.329]                   sendCondition <- ...future.makeSendCondition()
[10:29:58.329]                   sendCondition(cond)
[10:29:58.329]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.329]                   {
[10:29:58.329]                     inherits <- base::inherits
[10:29:58.329]                     invokeRestart <- base::invokeRestart
[10:29:58.329]                     is.null <- base::is.null
[10:29:58.329]                     muffled <- FALSE
[10:29:58.329]                     if (inherits(cond, "message")) {
[10:29:58.329]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:58.329]                       if (muffled) 
[10:29:58.329]                         invokeRestart("muffleMessage")
[10:29:58.329]                     }
[10:29:58.329]                     else if (inherits(cond, "warning")) {
[10:29:58.329]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:58.329]                       if (muffled) 
[10:29:58.329]                         invokeRestart("muffleWarning")
[10:29:58.329]                     }
[10:29:58.329]                     else if (inherits(cond, "condition")) {
[10:29:58.329]                       if (!is.null(pattern)) {
[10:29:58.329]                         computeRestarts <- base::computeRestarts
[10:29:58.329]                         grepl <- base::grepl
[10:29:58.329]                         restarts <- computeRestarts(cond)
[10:29:58.329]                         for (restart in restarts) {
[10:29:58.329]                           name <- restart$name
[10:29:58.329]                           if (is.null(name)) 
[10:29:58.329]                             next
[10:29:58.329]                           if (!grepl(pattern, name)) 
[10:29:58.329]                             next
[10:29:58.329]                           invokeRestart(restart)
[10:29:58.329]                           muffled <- TRUE
[10:29:58.329]                           break
[10:29:58.329]                         }
[10:29:58.329]                       }
[10:29:58.329]                     }
[10:29:58.329]                     invisible(muffled)
[10:29:58.329]                   }
[10:29:58.329]                   muffleCondition(cond)
[10:29:58.329]                 })
[10:29:58.329]             }))
[10:29:58.329]             future::FutureResult(value = ...future.value$value, 
[10:29:58.329]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:58.329]                   ...future.rng), globalenv = if (FALSE) 
[10:29:58.329]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:58.329]                     ...future.globalenv.names))
[10:29:58.329]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:58.329]         }, condition = base::local({
[10:29:58.329]             c <- base::c
[10:29:58.329]             inherits <- base::inherits
[10:29:58.329]             invokeRestart <- base::invokeRestart
[10:29:58.329]             length <- base::length
[10:29:58.329]             list <- base::list
[10:29:58.329]             seq.int <- base::seq.int
[10:29:58.329]             signalCondition <- base::signalCondition
[10:29:58.329]             sys.calls <- base::sys.calls
[10:29:58.329]             `[[` <- base::`[[`
[10:29:58.329]             `+` <- base::`+`
[10:29:58.329]             `<<-` <- base::`<<-`
[10:29:58.329]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:58.329]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:58.329]                   3L)]
[10:29:58.329]             }
[10:29:58.329]             function(cond) {
[10:29:58.329]                 is_error <- inherits(cond, "error")
[10:29:58.329]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:58.329]                   NULL)
[10:29:58.329]                 if (is_error) {
[10:29:58.329]                   sessionInformation <- function() {
[10:29:58.329]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:58.329]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:58.329]                       search = base::search(), system = base::Sys.info())
[10:29:58.329]                   }
[10:29:58.329]                   ...future.conditions[[length(...future.conditions) + 
[10:29:58.329]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:58.329]                     cond$call), session = sessionInformation(), 
[10:29:58.329]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:58.329]                   signalCondition(cond)
[10:29:58.329]                 }
[10:29:58.329]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:58.329]                 "immediateCondition"))) {
[10:29:58.329]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:58.329]                   ...future.conditions[[length(...future.conditions) + 
[10:29:58.329]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:58.329]                   if (TRUE && !signal) {
[10:29:58.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.329]                     {
[10:29:58.329]                       inherits <- base::inherits
[10:29:58.329]                       invokeRestart <- base::invokeRestart
[10:29:58.329]                       is.null <- base::is.null
[10:29:58.329]                       muffled <- FALSE
[10:29:58.329]                       if (inherits(cond, "message")) {
[10:29:58.329]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:58.329]                         if (muffled) 
[10:29:58.329]                           invokeRestart("muffleMessage")
[10:29:58.329]                       }
[10:29:58.329]                       else if (inherits(cond, "warning")) {
[10:29:58.329]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:58.329]                         if (muffled) 
[10:29:58.329]                           invokeRestart("muffleWarning")
[10:29:58.329]                       }
[10:29:58.329]                       else if (inherits(cond, "condition")) {
[10:29:58.329]                         if (!is.null(pattern)) {
[10:29:58.329]                           computeRestarts <- base::computeRestarts
[10:29:58.329]                           grepl <- base::grepl
[10:29:58.329]                           restarts <- computeRestarts(cond)
[10:29:58.329]                           for (restart in restarts) {
[10:29:58.329]                             name <- restart$name
[10:29:58.329]                             if (is.null(name)) 
[10:29:58.329]                               next
[10:29:58.329]                             if (!grepl(pattern, name)) 
[10:29:58.329]                               next
[10:29:58.329]                             invokeRestart(restart)
[10:29:58.329]                             muffled <- TRUE
[10:29:58.329]                             break
[10:29:58.329]                           }
[10:29:58.329]                         }
[10:29:58.329]                       }
[10:29:58.329]                       invisible(muffled)
[10:29:58.329]                     }
[10:29:58.329]                     muffleCondition(cond, pattern = "^muffle")
[10:29:58.329]                   }
[10:29:58.329]                 }
[10:29:58.329]                 else {
[10:29:58.329]                   if (TRUE) {
[10:29:58.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.329]                     {
[10:29:58.329]                       inherits <- base::inherits
[10:29:58.329]                       invokeRestart <- base::invokeRestart
[10:29:58.329]                       is.null <- base::is.null
[10:29:58.329]                       muffled <- FALSE
[10:29:58.329]                       if (inherits(cond, "message")) {
[10:29:58.329]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:58.329]                         if (muffled) 
[10:29:58.329]                           invokeRestart("muffleMessage")
[10:29:58.329]                       }
[10:29:58.329]                       else if (inherits(cond, "warning")) {
[10:29:58.329]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:58.329]                         if (muffled) 
[10:29:58.329]                           invokeRestart("muffleWarning")
[10:29:58.329]                       }
[10:29:58.329]                       else if (inherits(cond, "condition")) {
[10:29:58.329]                         if (!is.null(pattern)) {
[10:29:58.329]                           computeRestarts <- base::computeRestarts
[10:29:58.329]                           grepl <- base::grepl
[10:29:58.329]                           restarts <- computeRestarts(cond)
[10:29:58.329]                           for (restart in restarts) {
[10:29:58.329]                             name <- restart$name
[10:29:58.329]                             if (is.null(name)) 
[10:29:58.329]                               next
[10:29:58.329]                             if (!grepl(pattern, name)) 
[10:29:58.329]                               next
[10:29:58.329]                             invokeRestart(restart)
[10:29:58.329]                             muffled <- TRUE
[10:29:58.329]                             break
[10:29:58.329]                           }
[10:29:58.329]                         }
[10:29:58.329]                       }
[10:29:58.329]                       invisible(muffled)
[10:29:58.329]                     }
[10:29:58.329]                     muffleCondition(cond, pattern = "^muffle")
[10:29:58.329]                   }
[10:29:58.329]                 }
[10:29:58.329]             }
[10:29:58.329]         }))
[10:29:58.329]     }, error = function(ex) {
[10:29:58.329]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:58.329]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:58.329]                 ...future.rng), started = ...future.startTime, 
[10:29:58.329]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:58.329]             version = "1.8"), class = "FutureResult")
[10:29:58.329]     }, finally = {
[10:29:58.329]         if (!identical(...future.workdir, getwd())) 
[10:29:58.329]             setwd(...future.workdir)
[10:29:58.329]         {
[10:29:58.329]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:58.329]                 ...future.oldOptions$nwarnings <- NULL
[10:29:58.329]             }
[10:29:58.329]             base::options(...future.oldOptions)
[10:29:58.329]             if (.Platform$OS.type == "windows") {
[10:29:58.329]                 old_names <- names(...future.oldEnvVars)
[10:29:58.329]                 envs <- base::Sys.getenv()
[10:29:58.329]                 names <- names(envs)
[10:29:58.329]                 common <- intersect(names, old_names)
[10:29:58.329]                 added <- setdiff(names, old_names)
[10:29:58.329]                 removed <- setdiff(old_names, names)
[10:29:58.329]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:58.329]                   envs[common]]
[10:29:58.329]                 NAMES <- toupper(changed)
[10:29:58.329]                 args <- list()
[10:29:58.329]                 for (kk in seq_along(NAMES)) {
[10:29:58.329]                   name <- changed[[kk]]
[10:29:58.329]                   NAME <- NAMES[[kk]]
[10:29:58.329]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.329]                     next
[10:29:58.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:58.329]                 }
[10:29:58.329]                 NAMES <- toupper(added)
[10:29:58.329]                 for (kk in seq_along(NAMES)) {
[10:29:58.329]                   name <- added[[kk]]
[10:29:58.329]                   NAME <- NAMES[[kk]]
[10:29:58.329]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.329]                     next
[10:29:58.329]                   args[[name]] <- ""
[10:29:58.329]                 }
[10:29:58.329]                 NAMES <- toupper(removed)
[10:29:58.329]                 for (kk in seq_along(NAMES)) {
[10:29:58.329]                   name <- removed[[kk]]
[10:29:58.329]                   NAME <- NAMES[[kk]]
[10:29:58.329]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.329]                     next
[10:29:58.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:58.329]                 }
[10:29:58.329]                 if (length(args) > 0) 
[10:29:58.329]                   base::do.call(base::Sys.setenv, args = args)
[10:29:58.329]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:58.329]             }
[10:29:58.329]             else {
[10:29:58.329]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:58.329]             }
[10:29:58.329]             {
[10:29:58.329]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:58.329]                   0L) {
[10:29:58.329]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:58.329]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:58.329]                   base::options(opts)
[10:29:58.329]                 }
[10:29:58.329]                 {
[10:29:58.329]                   {
[10:29:58.329]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:58.329]                     NULL
[10:29:58.329]                   }
[10:29:58.329]                   options(future.plan = NULL)
[10:29:58.329]                   if (is.na(NA_character_)) 
[10:29:58.329]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:58.329]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:58.329]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:58.329]                     .init = FALSE)
[10:29:58.329]                 }
[10:29:58.329]             }
[10:29:58.329]         }
[10:29:58.329]     })
[10:29:58.329]     if (TRUE) {
[10:29:58.329]         base::sink(type = "output", split = FALSE)
[10:29:58.329]         if (TRUE) {
[10:29:58.329]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:58.329]         }
[10:29:58.329]         else {
[10:29:58.329]             ...future.result["stdout"] <- base::list(NULL)
[10:29:58.329]         }
[10:29:58.329]         base::close(...future.stdout)
[10:29:58.329]         ...future.stdout <- NULL
[10:29:58.329]     }
[10:29:58.329]     ...future.result$conditions <- ...future.conditions
[10:29:58.329]     ...future.result$finished <- base::Sys.time()
[10:29:58.329]     ...future.result
[10:29:58.329] }
[10:29:58.332] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[10:29:58.332] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[10:29:58.333] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[10:29:58.333] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:29:58.334] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:29:58.334] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[10:29:58.334] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[10:29:58.334] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:29:58.335] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:29:58.335] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:29:58.335] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:29:58.336] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[10:29:58.336] MultisessionFuture started
[10:29:58.336] - Launch lazy future ... done
[10:29:58.337] run() for ‘MultisessionFuture’ ... done
[10:29:58.337] Created future:
[10:29:58.337] MultisessionFuture:
[10:29:58.337] Label: ‘future_eapply-1’
[10:29:58.337] Expression:
[10:29:58.337] {
[10:29:58.337]     do.call(function(...) {
[10:29:58.337]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:58.337]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:58.337]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:58.337]             on.exit(options(oopts), add = TRUE)
[10:29:58.337]         }
[10:29:58.337]         {
[10:29:58.337]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:58.337]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:58.337]                 ...future.FUN(...future.X_jj, ...)
[10:29:58.337]             })
[10:29:58.337]         }
[10:29:58.337]     }, args = future.call.arguments)
[10:29:58.337] }
[10:29:58.337] Lazy evaluation: FALSE
[10:29:58.337] Asynchronous evaluation: TRUE
[10:29:58.337] Local evaluation: TRUE
[10:29:58.337] Environment: R_GlobalEnv
[10:29:58.337] Capture standard output: TRUE
[10:29:58.337] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:58.337] Globals: 5 objects totaling 1.27 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:58.337] Packages: <none>
[10:29:58.337] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:58.337] Resolved: FALSE
[10:29:58.337] Value: <not collected>
[10:29:58.337] Conditions captured: <none>
[10:29:58.337] Early signaling: FALSE
[10:29:58.337] Owner process: db6eb61b-64f1-ae95-7e8b-287fbc43411a
[10:29:58.337] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:58.349] Chunk #1 of 2 ... DONE
[10:29:58.349] Chunk #2 of 2 ...
[10:29:58.349]  - Finding globals in 'X' for chunk #2 ...
[10:29:58.350] getGlobalsAndPackages() ...
[10:29:58.350] Searching for globals...
[10:29:58.350] 
[10:29:58.350] Searching for globals ... DONE
[10:29:58.350] - globals: [0] <none>
[10:29:58.350] getGlobalsAndPackages() ... DONE
[10:29:58.350]    + additional globals found: [n=0] 
[10:29:58.351]    + additional namespaces needed: [n=0] 
[10:29:58.351]  - Finding globals in 'X' for chunk #2 ... DONE
[10:29:58.351]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:58.351]  - seeds: <none>
[10:29:58.351]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:58.351] getGlobalsAndPackages() ...
[10:29:58.351] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:58.351] Resolving globals: FALSE
[10:29:58.352] Tweak future expression to call with '...' arguments ...
[10:29:58.352] {
[10:29:58.352]     do.call(function(...) {
[10:29:58.352]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:58.352]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:58.352]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:58.352]             on.exit(options(oopts), add = TRUE)
[10:29:58.352]         }
[10:29:58.352]         {
[10:29:58.352]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:58.352]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:58.352]                 ...future.FUN(...future.X_jj, ...)
[10:29:58.352]             })
[10:29:58.352]         }
[10:29:58.352]     }, args = future.call.arguments)
[10:29:58.352] }
[10:29:58.352] Tweak future expression to call with '...' arguments ... DONE
[10:29:58.352] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:58.353] 
[10:29:58.353] getGlobalsAndPackages() ... DONE
[10:29:58.353] run() for ‘Future’ ...
[10:29:58.353] - state: ‘created’
[10:29:58.353] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:58.368] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:58.369] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:58.369]   - Field: ‘node’
[10:29:58.369]   - Field: ‘label’
[10:29:58.369]   - Field: ‘local’
[10:29:58.369]   - Field: ‘owner’
[10:29:58.369]   - Field: ‘envir’
[10:29:58.369]   - Field: ‘workers’
[10:29:58.369]   - Field: ‘packages’
[10:29:58.370]   - Field: ‘gc’
[10:29:58.370]   - Field: ‘conditions’
[10:29:58.370]   - Field: ‘persistent’
[10:29:58.370]   - Field: ‘expr’
[10:29:58.370]   - Field: ‘uuid’
[10:29:58.370]   - Field: ‘seed’
[10:29:58.370]   - Field: ‘version’
[10:29:58.370]   - Field: ‘result’
[10:29:58.370]   - Field: ‘asynchronous’
[10:29:58.371]   - Field: ‘calls’
[10:29:58.371]   - Field: ‘globals’
[10:29:58.371]   - Field: ‘stdout’
[10:29:58.371]   - Field: ‘earlySignal’
[10:29:58.371]   - Field: ‘lazy’
[10:29:58.371]   - Field: ‘state’
[10:29:58.371] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:58.371] - Launch lazy future ...
[10:29:58.372] Packages needed by the future expression (n = 0): <none>
[10:29:58.372] Packages needed by future strategies (n = 0): <none>
[10:29:58.372] {
[10:29:58.372]     {
[10:29:58.372]         {
[10:29:58.372]             ...future.startTime <- base::Sys.time()
[10:29:58.372]             {
[10:29:58.372]                 {
[10:29:58.372]                   {
[10:29:58.372]                     {
[10:29:58.372]                       base::local({
[10:29:58.372]                         has_future <- base::requireNamespace("future", 
[10:29:58.372]                           quietly = TRUE)
[10:29:58.372]                         if (has_future) {
[10:29:58.372]                           ns <- base::getNamespace("future")
[10:29:58.372]                           version <- ns[[".package"]][["version"]]
[10:29:58.372]                           if (is.null(version)) 
[10:29:58.372]                             version <- utils::packageVersion("future")
[10:29:58.372]                         }
[10:29:58.372]                         else {
[10:29:58.372]                           version <- NULL
[10:29:58.372]                         }
[10:29:58.372]                         if (!has_future || version < "1.8.0") {
[10:29:58.372]                           info <- base::c(r_version = base::gsub("R version ", 
[10:29:58.372]                             "", base::R.version$version.string), 
[10:29:58.372]                             platform = base::sprintf("%s (%s-bit)", 
[10:29:58.372]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:29:58.372]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:58.372]                               "release", "version")], collapse = " "), 
[10:29:58.372]                             hostname = base::Sys.info()[["nodename"]])
[10:29:58.372]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:29:58.372]                             info)
[10:29:58.372]                           info <- base::paste(info, collapse = "; ")
[10:29:58.372]                           if (!has_future) {
[10:29:58.372]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:58.372]                               info)
[10:29:58.372]                           }
[10:29:58.372]                           else {
[10:29:58.372]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:58.372]                               info, version)
[10:29:58.372]                           }
[10:29:58.372]                           base::stop(msg)
[10:29:58.372]                         }
[10:29:58.372]                       })
[10:29:58.372]                     }
[10:29:58.372]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:58.372]                     base::options(mc.cores = 1L)
[10:29:58.372]                   }
[10:29:58.372]                   ...future.strategy.old <- future::plan("list")
[10:29:58.372]                   options(future.plan = NULL)
[10:29:58.372]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:58.372]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:58.372]                 }
[10:29:58.372]                 ...future.workdir <- getwd()
[10:29:58.372]             }
[10:29:58.372]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:58.372]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:58.372]         }
[10:29:58.372]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:58.372]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:58.372]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:58.372]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:58.372]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:58.372]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:58.372]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:58.372]             base::names(...future.oldOptions))
[10:29:58.372]     }
[10:29:58.372]     if (FALSE) {
[10:29:58.372]     }
[10:29:58.372]     else {
[10:29:58.372]         if (TRUE) {
[10:29:58.372]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:58.372]                 open = "w")
[10:29:58.372]         }
[10:29:58.372]         else {
[10:29:58.372]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:58.372]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:58.372]         }
[10:29:58.372]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:58.372]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:58.372]             base::sink(type = "output", split = FALSE)
[10:29:58.372]             base::close(...future.stdout)
[10:29:58.372]         }, add = TRUE)
[10:29:58.372]     }
[10:29:58.372]     ...future.frame <- base::sys.nframe()
[10:29:58.372]     ...future.conditions <- base::list()
[10:29:58.372]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:58.372]     if (FALSE) {
[10:29:58.372]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:58.372]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:58.372]     }
[10:29:58.372]     ...future.result <- base::tryCatch({
[10:29:58.372]         base::withCallingHandlers({
[10:29:58.372]             ...future.value <- base::withVisible(base::local({
[10:29:58.372]                 ...future.makeSendCondition <- base::local({
[10:29:58.372]                   sendCondition <- NULL
[10:29:58.372]                   function(frame = 1L) {
[10:29:58.372]                     if (is.function(sendCondition)) 
[10:29:58.372]                       return(sendCondition)
[10:29:58.372]                     ns <- getNamespace("parallel")
[10:29:58.372]                     if (exists("sendData", mode = "function", 
[10:29:58.372]                       envir = ns)) {
[10:29:58.372]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:58.372]                         envir = ns)
[10:29:58.372]                       envir <- sys.frame(frame)
[10:29:58.372]                       master <- NULL
[10:29:58.372]                       while (!identical(envir, .GlobalEnv) && 
[10:29:58.372]                         !identical(envir, emptyenv())) {
[10:29:58.372]                         if (exists("master", mode = "list", envir = envir, 
[10:29:58.372]                           inherits = FALSE)) {
[10:29:58.372]                           master <- get("master", mode = "list", 
[10:29:58.372]                             envir = envir, inherits = FALSE)
[10:29:58.372]                           if (inherits(master, c("SOCKnode", 
[10:29:58.372]                             "SOCK0node"))) {
[10:29:58.372]                             sendCondition <<- function(cond) {
[10:29:58.372]                               data <- list(type = "VALUE", value = cond, 
[10:29:58.372]                                 success = TRUE)
[10:29:58.372]                               parallel_sendData(master, data)
[10:29:58.372]                             }
[10:29:58.372]                             return(sendCondition)
[10:29:58.372]                           }
[10:29:58.372]                         }
[10:29:58.372]                         frame <- frame + 1L
[10:29:58.372]                         envir <- sys.frame(frame)
[10:29:58.372]                       }
[10:29:58.372]                     }
[10:29:58.372]                     sendCondition <<- function(cond) NULL
[10:29:58.372]                   }
[10:29:58.372]                 })
[10:29:58.372]                 withCallingHandlers({
[10:29:58.372]                   {
[10:29:58.372]                     do.call(function(...) {
[10:29:58.372]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:58.372]                       if (!identical(...future.globals.maxSize.org, 
[10:29:58.372]                         ...future.globals.maxSize)) {
[10:29:58.372]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:58.372]                         on.exit(options(oopts), add = TRUE)
[10:29:58.372]                       }
[10:29:58.372]                       {
[10:29:58.372]                         lapply(seq_along(...future.elements_ii), 
[10:29:58.372]                           FUN = function(jj) {
[10:29:58.372]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:58.372]                             ...future.FUN(...future.X_jj, ...)
[10:29:58.372]                           })
[10:29:58.372]                       }
[10:29:58.372]                     }, args = future.call.arguments)
[10:29:58.372]                   }
[10:29:58.372]                 }, immediateCondition = function(cond) {
[10:29:58.372]                   sendCondition <- ...future.makeSendCondition()
[10:29:58.372]                   sendCondition(cond)
[10:29:58.372]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.372]                   {
[10:29:58.372]                     inherits <- base::inherits
[10:29:58.372]                     invokeRestart <- base::invokeRestart
[10:29:58.372]                     is.null <- base::is.null
[10:29:58.372]                     muffled <- FALSE
[10:29:58.372]                     if (inherits(cond, "message")) {
[10:29:58.372]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:58.372]                       if (muffled) 
[10:29:58.372]                         invokeRestart("muffleMessage")
[10:29:58.372]                     }
[10:29:58.372]                     else if (inherits(cond, "warning")) {
[10:29:58.372]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:58.372]                       if (muffled) 
[10:29:58.372]                         invokeRestart("muffleWarning")
[10:29:58.372]                     }
[10:29:58.372]                     else if (inherits(cond, "condition")) {
[10:29:58.372]                       if (!is.null(pattern)) {
[10:29:58.372]                         computeRestarts <- base::computeRestarts
[10:29:58.372]                         grepl <- base::grepl
[10:29:58.372]                         restarts <- computeRestarts(cond)
[10:29:58.372]                         for (restart in restarts) {
[10:29:58.372]                           name <- restart$name
[10:29:58.372]                           if (is.null(name)) 
[10:29:58.372]                             next
[10:29:58.372]                           if (!grepl(pattern, name)) 
[10:29:58.372]                             next
[10:29:58.372]                           invokeRestart(restart)
[10:29:58.372]                           muffled <- TRUE
[10:29:58.372]                           break
[10:29:58.372]                         }
[10:29:58.372]                       }
[10:29:58.372]                     }
[10:29:58.372]                     invisible(muffled)
[10:29:58.372]                   }
[10:29:58.372]                   muffleCondition(cond)
[10:29:58.372]                 })
[10:29:58.372]             }))
[10:29:58.372]             future::FutureResult(value = ...future.value$value, 
[10:29:58.372]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:58.372]                   ...future.rng), globalenv = if (FALSE) 
[10:29:58.372]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:58.372]                     ...future.globalenv.names))
[10:29:58.372]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:58.372]         }, condition = base::local({
[10:29:58.372]             c <- base::c
[10:29:58.372]             inherits <- base::inherits
[10:29:58.372]             invokeRestart <- base::invokeRestart
[10:29:58.372]             length <- base::length
[10:29:58.372]             list <- base::list
[10:29:58.372]             seq.int <- base::seq.int
[10:29:58.372]             signalCondition <- base::signalCondition
[10:29:58.372]             sys.calls <- base::sys.calls
[10:29:58.372]             `[[` <- base::`[[`
[10:29:58.372]             `+` <- base::`+`
[10:29:58.372]             `<<-` <- base::`<<-`
[10:29:58.372]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:58.372]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:58.372]                   3L)]
[10:29:58.372]             }
[10:29:58.372]             function(cond) {
[10:29:58.372]                 is_error <- inherits(cond, "error")
[10:29:58.372]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:58.372]                   NULL)
[10:29:58.372]                 if (is_error) {
[10:29:58.372]                   sessionInformation <- function() {
[10:29:58.372]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:58.372]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:58.372]                       search = base::search(), system = base::Sys.info())
[10:29:58.372]                   }
[10:29:58.372]                   ...future.conditions[[length(...future.conditions) + 
[10:29:58.372]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:58.372]                     cond$call), session = sessionInformation(), 
[10:29:58.372]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:58.372]                   signalCondition(cond)
[10:29:58.372]                 }
[10:29:58.372]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:58.372]                 "immediateCondition"))) {
[10:29:58.372]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:58.372]                   ...future.conditions[[length(...future.conditions) + 
[10:29:58.372]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:58.372]                   if (TRUE && !signal) {
[10:29:58.372]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.372]                     {
[10:29:58.372]                       inherits <- base::inherits
[10:29:58.372]                       invokeRestart <- base::invokeRestart
[10:29:58.372]                       is.null <- base::is.null
[10:29:58.372]                       muffled <- FALSE
[10:29:58.372]                       if (inherits(cond, "message")) {
[10:29:58.372]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:58.372]                         if (muffled) 
[10:29:58.372]                           invokeRestart("muffleMessage")
[10:29:58.372]                       }
[10:29:58.372]                       else if (inherits(cond, "warning")) {
[10:29:58.372]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:58.372]                         if (muffled) 
[10:29:58.372]                           invokeRestart("muffleWarning")
[10:29:58.372]                       }
[10:29:58.372]                       else if (inherits(cond, "condition")) {
[10:29:58.372]                         if (!is.null(pattern)) {
[10:29:58.372]                           computeRestarts <- base::computeRestarts
[10:29:58.372]                           grepl <- base::grepl
[10:29:58.372]                           restarts <- computeRestarts(cond)
[10:29:58.372]                           for (restart in restarts) {
[10:29:58.372]                             name <- restart$name
[10:29:58.372]                             if (is.null(name)) 
[10:29:58.372]                               next
[10:29:58.372]                             if (!grepl(pattern, name)) 
[10:29:58.372]                               next
[10:29:58.372]                             invokeRestart(restart)
[10:29:58.372]                             muffled <- TRUE
[10:29:58.372]                             break
[10:29:58.372]                           }
[10:29:58.372]                         }
[10:29:58.372]                       }
[10:29:58.372]                       invisible(muffled)
[10:29:58.372]                     }
[10:29:58.372]                     muffleCondition(cond, pattern = "^muffle")
[10:29:58.372]                   }
[10:29:58.372]                 }
[10:29:58.372]                 else {
[10:29:58.372]                   if (TRUE) {
[10:29:58.372]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.372]                     {
[10:29:58.372]                       inherits <- base::inherits
[10:29:58.372]                       invokeRestart <- base::invokeRestart
[10:29:58.372]                       is.null <- base::is.null
[10:29:58.372]                       muffled <- FALSE
[10:29:58.372]                       if (inherits(cond, "message")) {
[10:29:58.372]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:58.372]                         if (muffled) 
[10:29:58.372]                           invokeRestart("muffleMessage")
[10:29:58.372]                       }
[10:29:58.372]                       else if (inherits(cond, "warning")) {
[10:29:58.372]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:58.372]                         if (muffled) 
[10:29:58.372]                           invokeRestart("muffleWarning")
[10:29:58.372]                       }
[10:29:58.372]                       else if (inherits(cond, "condition")) {
[10:29:58.372]                         if (!is.null(pattern)) {
[10:29:58.372]                           computeRestarts <- base::computeRestarts
[10:29:58.372]                           grepl <- base::grepl
[10:29:58.372]                           restarts <- computeRestarts(cond)
[10:29:58.372]                           for (restart in restarts) {
[10:29:58.372]                             name <- restart$name
[10:29:58.372]                             if (is.null(name)) 
[10:29:58.372]                               next
[10:29:58.372]                             if (!grepl(pattern, name)) 
[10:29:58.372]                               next
[10:29:58.372]                             invokeRestart(restart)
[10:29:58.372]                             muffled <- TRUE
[10:29:58.372]                             break
[10:29:58.372]                           }
[10:29:58.372]                         }
[10:29:58.372]                       }
[10:29:58.372]                       invisible(muffled)
[10:29:58.372]                     }
[10:29:58.372]                     muffleCondition(cond, pattern = "^muffle")
[10:29:58.372]                   }
[10:29:58.372]                 }
[10:29:58.372]             }
[10:29:58.372]         }))
[10:29:58.372]     }, error = function(ex) {
[10:29:58.372]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:58.372]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:58.372]                 ...future.rng), started = ...future.startTime, 
[10:29:58.372]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:58.372]             version = "1.8"), class = "FutureResult")
[10:29:58.372]     }, finally = {
[10:29:58.372]         if (!identical(...future.workdir, getwd())) 
[10:29:58.372]             setwd(...future.workdir)
[10:29:58.372]         {
[10:29:58.372]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:58.372]                 ...future.oldOptions$nwarnings <- NULL
[10:29:58.372]             }
[10:29:58.372]             base::options(...future.oldOptions)
[10:29:58.372]             if (.Platform$OS.type == "windows") {
[10:29:58.372]                 old_names <- names(...future.oldEnvVars)
[10:29:58.372]                 envs <- base::Sys.getenv()
[10:29:58.372]                 names <- names(envs)
[10:29:58.372]                 common <- intersect(names, old_names)
[10:29:58.372]                 added <- setdiff(names, old_names)
[10:29:58.372]                 removed <- setdiff(old_names, names)
[10:29:58.372]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:58.372]                   envs[common]]
[10:29:58.372]                 NAMES <- toupper(changed)
[10:29:58.372]                 args <- list()
[10:29:58.372]                 for (kk in seq_along(NAMES)) {
[10:29:58.372]                   name <- changed[[kk]]
[10:29:58.372]                   NAME <- NAMES[[kk]]
[10:29:58.372]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.372]                     next
[10:29:58.372]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:58.372]                 }
[10:29:58.372]                 NAMES <- toupper(added)
[10:29:58.372]                 for (kk in seq_along(NAMES)) {
[10:29:58.372]                   name <- added[[kk]]
[10:29:58.372]                   NAME <- NAMES[[kk]]
[10:29:58.372]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.372]                     next
[10:29:58.372]                   args[[name]] <- ""
[10:29:58.372]                 }
[10:29:58.372]                 NAMES <- toupper(removed)
[10:29:58.372]                 for (kk in seq_along(NAMES)) {
[10:29:58.372]                   name <- removed[[kk]]
[10:29:58.372]                   NAME <- NAMES[[kk]]
[10:29:58.372]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.372]                     next
[10:29:58.372]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:58.372]                 }
[10:29:58.372]                 if (length(args) > 0) 
[10:29:58.372]                   base::do.call(base::Sys.setenv, args = args)
[10:29:58.372]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:58.372]             }
[10:29:58.372]             else {
[10:29:58.372]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:58.372]             }
[10:29:58.372]             {
[10:29:58.372]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:58.372]                   0L) {
[10:29:58.372]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:58.372]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:58.372]                   base::options(opts)
[10:29:58.372]                 }
[10:29:58.372]                 {
[10:29:58.372]                   {
[10:29:58.372]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:58.372]                     NULL
[10:29:58.372]                   }
[10:29:58.372]                   options(future.plan = NULL)
[10:29:58.372]                   if (is.na(NA_character_)) 
[10:29:58.372]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:58.372]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:58.372]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:58.372]                     .init = FALSE)
[10:29:58.372]                 }
[10:29:58.372]             }
[10:29:58.372]         }
[10:29:58.372]     })
[10:29:58.372]     if (TRUE) {
[10:29:58.372]         base::sink(type = "output", split = FALSE)
[10:29:58.372]         if (TRUE) {
[10:29:58.372]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:58.372]         }
[10:29:58.372]         else {
[10:29:58.372]             ...future.result["stdout"] <- base::list(NULL)
[10:29:58.372]         }
[10:29:58.372]         base::close(...future.stdout)
[10:29:58.372]         ...future.stdout <- NULL
[10:29:58.372]     }
[10:29:58.372]     ...future.result$conditions <- ...future.conditions
[10:29:58.372]     ...future.result$finished <- base::Sys.time()
[10:29:58.372]     ...future.result
[10:29:58.372] }
[10:29:58.428] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[10:29:58.428] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[10:29:58.429] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[10:29:58.429] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:29:58.429] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:29:58.430] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[10:29:58.430] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[10:29:58.430] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:29:58.430] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:29:58.431] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:29:58.431] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:29:58.431] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[10:29:58.432] MultisessionFuture started
[10:29:58.432] - Launch lazy future ... done
[10:29:58.432] run() for ‘MultisessionFuture’ ... done
[10:29:58.432] Created future:
[10:29:58.432] MultisessionFuture:
[10:29:58.432] Label: ‘future_eapply-2’
[10:29:58.432] Expression:
[10:29:58.432] {
[10:29:58.432]     do.call(function(...) {
[10:29:58.432]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:58.432]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:58.432]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:58.432]             on.exit(options(oopts), add = TRUE)
[10:29:58.432]         }
[10:29:58.432]         {
[10:29:58.432]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:58.432]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:58.432]                 ...future.FUN(...future.X_jj, ...)
[10:29:58.432]             })
[10:29:58.432]         }
[10:29:58.432]     }, args = future.call.arguments)
[10:29:58.432] }
[10:29:58.432] Lazy evaluation: FALSE
[10:29:58.432] Asynchronous evaluation: TRUE
[10:29:58.432] Local evaluation: TRUE
[10:29:58.432] Environment: R_GlobalEnv
[10:29:58.432] Capture standard output: TRUE
[10:29:58.432] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:58.432] Globals: 5 objects totaling 1.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:58.432] Packages: <none>
[10:29:58.432] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:58.432] Resolved: FALSE
[10:29:58.432] Value: <not collected>
[10:29:58.432] Conditions captured: <none>
[10:29:58.432] Early signaling: FALSE
[10:29:58.432] Owner process: db6eb61b-64f1-ae95-7e8b-287fbc43411a
[10:29:58.432] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:58.444] Chunk #2 of 2 ... DONE
[10:29:58.444] Launching 2 futures (chunks) ... DONE
[10:29:58.444] Resolving 2 futures (chunks) ...
[10:29:58.444] resolve() on list ...
[10:29:58.445]  recursive: 0
[10:29:58.445]  length: 2
[10:29:58.445] 
[10:29:58.445] receiveMessageFromWorker() for ClusterFuture ...
[10:29:58.446] - Validating connection of MultisessionFuture
[10:29:58.446] - received message: FutureResult
[10:29:58.446] - Received FutureResult
[10:29:58.446] - Erased future from FutureRegistry
[10:29:58.446] result() for ClusterFuture ...
[10:29:58.446] - result already collected: FutureResult
[10:29:58.446] result() for ClusterFuture ... done
[10:29:58.446] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:58.447] Future #1
[10:29:58.447] result() for ClusterFuture ...
[10:29:58.447] - result already collected: FutureResult
[10:29:58.451] result() for ClusterFuture ... done
[10:29:58.451] result() for ClusterFuture ...
[10:29:58.451] - result already collected: FutureResult
[10:29:58.451] result() for ClusterFuture ... done
[10:29:58.452] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:29:58.452] - nx: 2
[10:29:58.452] - relay: TRUE
[10:29:58.452] - stdout: TRUE
[10:29:58.452] - signal: TRUE
[10:29:58.452] - resignal: FALSE
[10:29:58.452] - force: TRUE
[10:29:58.452] - relayed: [n=2] FALSE, FALSE
[10:29:58.452] - queued futures: [n=2] FALSE, FALSE
[10:29:58.452]  - until=1
[10:29:58.452]  - relaying element #1
[10:29:58.452] result() for ClusterFuture ...
[10:29:58.453] - result already collected: FutureResult
[10:29:58.453] result() for ClusterFuture ... done
[10:29:58.453] result() for ClusterFuture ...
[10:29:58.453] - result already collected: FutureResult
[10:29:58.453] result() for ClusterFuture ... done
[10:29:58.453] result() for ClusterFuture ...
[10:29:58.453] - result already collected: FutureResult
[10:29:58.453] result() for ClusterFuture ... done
[10:29:58.453] result() for ClusterFuture ...
[10:29:58.453] - result already collected: FutureResult
[10:29:58.453] result() for ClusterFuture ... done
[10:29:58.454] - relayed: [n=2] TRUE, FALSE
[10:29:58.454] - queued futures: [n=2] TRUE, FALSE
[10:29:58.454] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:29:58.454]  length: 1 (resolved future 1)
[10:29:58.516] receiveMessageFromWorker() for ClusterFuture ...
[10:29:58.517] - Validating connection of MultisessionFuture
[10:29:58.517] - received message: FutureResult
[10:29:58.517] - Received FutureResult
[10:29:58.517] - Erased future from FutureRegistry
[10:29:58.517] result() for ClusterFuture ...
[10:29:58.517] - result already collected: FutureResult
[10:29:58.517] result() for ClusterFuture ... done
[10:29:58.518] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:58.518] Future #2
[10:29:58.518] result() for ClusterFuture ...
[10:29:58.518] - result already collected: FutureResult
[10:29:58.518] result() for ClusterFuture ... done
[10:29:58.518] result() for ClusterFuture ...
[10:29:58.518] - result already collected: FutureResult
[10:29:58.518] result() for ClusterFuture ... done
[10:29:58.518] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:29:58.518] - nx: 2
[10:29:58.518] - relay: TRUE
[10:29:58.519] - stdout: TRUE
[10:29:58.519] - signal: TRUE
[10:29:58.519] - resignal: FALSE
[10:29:58.519] - force: TRUE
[10:29:58.519] - relayed: [n=2] TRUE, FALSE
[10:29:58.519] - queued futures: [n=2] TRUE, FALSE
[10:29:58.519]  - until=2
[10:29:58.519]  - relaying element #2
[10:29:58.519] result() for ClusterFuture ...
[10:29:58.519] - result already collected: FutureResult
[10:29:58.519] result() for ClusterFuture ... done
[10:29:58.519] result() for ClusterFuture ...
[10:29:58.520] - result already collected: FutureResult
[10:29:58.520] result() for ClusterFuture ... done
[10:29:58.520] result() for ClusterFuture ...
[10:29:58.520] - result already collected: FutureResult
[10:29:58.520] result() for ClusterFuture ... done
[10:29:58.520] result() for ClusterFuture ...
[10:29:58.520] - result already collected: FutureResult
[10:29:58.520] result() for ClusterFuture ... done
[10:29:58.520] - relayed: [n=2] TRUE, TRUE
[10:29:58.520] - queued futures: [n=2] TRUE, TRUE
[10:29:58.520] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:29:58.521]  length: 0 (resolved future 2)
[10:29:58.521] Relaying remaining futures
[10:29:58.521] signalConditionsASAP(NULL, pos=0) ...
[10:29:58.521] - nx: 2
[10:29:58.521] - relay: TRUE
[10:29:58.521] - stdout: TRUE
[10:29:58.521] - signal: TRUE
[10:29:58.521] - resignal: FALSE
[10:29:58.521] - force: TRUE
[10:29:58.521] - relayed: [n=2] TRUE, TRUE
[10:29:58.521] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:58.522] - relayed: [n=2] TRUE, TRUE
[10:29:58.522] - queued futures: [n=2] TRUE, TRUE
[10:29:58.522] signalConditionsASAP(NULL, pos=0) ... done
[10:29:58.522] resolve() on list ... DONE
[10:29:58.522] result() for ClusterFuture ...
[10:29:58.522] - result already collected: FutureResult
[10:29:58.522] result() for ClusterFuture ... done
[10:29:58.522] result() for ClusterFuture ...
[10:29:58.522] - result already collected: FutureResult
[10:29:58.522] result() for ClusterFuture ... done
[10:29:58.522] result() for ClusterFuture ...
[10:29:58.523] - result already collected: FutureResult
[10:29:58.523] result() for ClusterFuture ... done
[10:29:58.523] result() for ClusterFuture ...
[10:29:58.523] - result already collected: FutureResult
[10:29:58.523] result() for ClusterFuture ... done
[10:29:58.523]  - Number of value chunks collected: 2
[10:29:58.523] Resolving 2 futures (chunks) ... DONE
[10:29:58.523] Reducing values from 2 chunks ...
[10:29:58.523]  - Number of values collected after concatenation: 3
[10:29:58.523]  - Number of values expected: 3
[10:29:58.523] Reducing values from 2 chunks ... DONE
[10:29:58.524] future_lapply() ... DONE
[10:29:58.524] future_lapply() ...
[10:29:58.528] Number of chunks: 2
[10:29:58.528] getGlobalsAndPackagesXApply() ...
[10:29:58.529]  - future.globals: TRUE
[10:29:58.529] getGlobalsAndPackages() ...
[10:29:58.529] Searching for globals...
[10:29:58.530] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:58.530] Searching for globals ... DONE
[10:29:58.530] Resolving globals: FALSE
[10:29:58.531] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[10:29:58.531] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[10:29:58.531] - globals: [1] ‘FUN’
[10:29:58.531] - packages: [1] ‘stats’
[10:29:58.532] getGlobalsAndPackages() ... DONE
[10:29:58.532]  - globals found/used: [n=1] ‘FUN’
[10:29:58.532]  - needed namespaces: [n=1] ‘stats’
[10:29:58.532] Finding globals ... DONE
[10:29:58.532]  - use_args: TRUE
[10:29:58.532]  - Getting '...' globals ...
[10:29:58.532] resolve() on list ...
[10:29:58.532]  recursive: 0
[10:29:58.533]  length: 1
[10:29:58.533]  elements: ‘...’
[10:29:58.533]  length: 0 (resolved future 1)
[10:29:58.533] resolve() on list ... DONE
[10:29:58.533]    - '...' content: [n=1] ‘probs’
[10:29:58.533] List of 1
[10:29:58.533]  $ ...:List of 1
[10:29:58.533]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:29:58.533]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:58.533]  - attr(*, "where")=List of 1
[10:29:58.533]   ..$ ...:<environment: 0x55974b62b9c0> 
[10:29:58.533]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:58.533]  - attr(*, "resolved")= logi TRUE
[10:29:58.533]  - attr(*, "total_size")= num NA
[10:29:58.536]  - Getting '...' globals ... DONE
[10:29:58.536] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:58.536] List of 2
[10:29:58.536]  $ ...future.FUN:function (x, ...)  
[10:29:58.536]  $ ...          :List of 1
[10:29:58.536]   ..$ probs: num [1:3] 0.25 0.5 0.75
[10:29:58.536]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:58.536]  - attr(*, "where")=List of 2
[10:29:58.536]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:58.536]   ..$ ...          :<environment: 0x55974b62b9c0> 
[10:29:58.536]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:58.536]  - attr(*, "resolved")= logi FALSE
[10:29:58.536]  - attr(*, "total_size")= num 1328
[10:29:58.540] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:58.540] getGlobalsAndPackagesXApply() ... DONE
[10:29:58.540] Number of futures (= number of chunks): 2
[10:29:58.540] Launching 2 futures (chunks) ...
[10:29:58.540] Chunk #1 of 2 ...
[10:29:58.540]  - Finding globals in 'X' for chunk #1 ...
[10:29:58.540] getGlobalsAndPackages() ...
[10:29:58.540] Searching for globals...
[10:29:58.541] 
[10:29:58.541] Searching for globals ... DONE
[10:29:58.541] - globals: [0] <none>
[10:29:58.541] getGlobalsAndPackages() ... DONE
[10:29:58.541]    + additional globals found: [n=0] 
[10:29:58.541]    + additional namespaces needed: [n=0] 
[10:29:58.541]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:58.541]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:58.541]  - seeds: <none>
[10:29:58.542]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:58.542] getGlobalsAndPackages() ...
[10:29:58.542] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:58.542] Resolving globals: FALSE
[10:29:58.542] Tweak future expression to call with '...' arguments ...
[10:29:58.542] {
[10:29:58.542]     do.call(function(...) {
[10:29:58.542]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:58.542]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:58.542]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:58.542]             on.exit(options(oopts), add = TRUE)
[10:29:58.542]         }
[10:29:58.542]         {
[10:29:58.542]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:58.542]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:58.542]                 ...future.FUN(...future.X_jj, ...)
[10:29:58.542]             })
[10:29:58.542]         }
[10:29:58.542]     }, args = future.call.arguments)
[10:29:58.542] }
[10:29:58.542] Tweak future expression to call with '...' arguments ... DONE
[10:29:58.543] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:58.543] - packages: [1] ‘stats’
[10:29:58.543] getGlobalsAndPackages() ... DONE
[10:29:58.543] run() for ‘Future’ ...
[10:29:58.543] - state: ‘created’
[10:29:58.544] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:58.558] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:58.558] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:58.558]   - Field: ‘node’
[10:29:58.558]   - Field: ‘label’
[10:29:58.558]   - Field: ‘local’
[10:29:58.558]   - Field: ‘owner’
[10:29:58.559]   - Field: ‘envir’
[10:29:58.559]   - Field: ‘workers’
[10:29:58.559]   - Field: ‘packages’
[10:29:58.559]   - Field: ‘gc’
[10:29:58.559]   - Field: ‘conditions’
[10:29:58.559]   - Field: ‘persistent’
[10:29:58.559]   - Field: ‘expr’
[10:29:58.559]   - Field: ‘uuid’
[10:29:58.559]   - Field: ‘seed’
[10:29:58.559]   - Field: ‘version’
[10:29:58.559]   - Field: ‘result’
[10:29:58.560]   - Field: ‘asynchronous’
[10:29:58.560]   - Field: ‘calls’
[10:29:58.560]   - Field: ‘globals’
[10:29:58.560]   - Field: ‘stdout’
[10:29:58.560]   - Field: ‘earlySignal’
[10:29:58.560]   - Field: ‘lazy’
[10:29:58.560]   - Field: ‘state’
[10:29:58.560] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:58.560] - Launch lazy future ...
[10:29:58.561] Packages needed by the future expression (n = 1): ‘stats’
[10:29:58.561] Packages needed by future strategies (n = 0): <none>
[10:29:58.561] {
[10:29:58.561]     {
[10:29:58.561]         {
[10:29:58.561]             ...future.startTime <- base::Sys.time()
[10:29:58.561]             {
[10:29:58.561]                 {
[10:29:58.561]                   {
[10:29:58.561]                     {
[10:29:58.561]                       {
[10:29:58.561]                         base::local({
[10:29:58.561]                           has_future <- base::requireNamespace("future", 
[10:29:58.561]                             quietly = TRUE)
[10:29:58.561]                           if (has_future) {
[10:29:58.561]                             ns <- base::getNamespace("future")
[10:29:58.561]                             version <- ns[[".package"]][["version"]]
[10:29:58.561]                             if (is.null(version)) 
[10:29:58.561]                               version <- utils::packageVersion("future")
[10:29:58.561]                           }
[10:29:58.561]                           else {
[10:29:58.561]                             version <- NULL
[10:29:58.561]                           }
[10:29:58.561]                           if (!has_future || version < "1.8.0") {
[10:29:58.561]                             info <- base::c(r_version = base::gsub("R version ", 
[10:29:58.561]                               "", base::R.version$version.string), 
[10:29:58.561]                               platform = base::sprintf("%s (%s-bit)", 
[10:29:58.561]                                 base::R.version$platform, 8 * 
[10:29:58.561]                                   base::.Machine$sizeof.pointer), 
[10:29:58.561]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:58.561]                                 "release", "version")], collapse = " "), 
[10:29:58.561]                               hostname = base::Sys.info()[["nodename"]])
[10:29:58.561]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:29:58.561]                               info)
[10:29:58.561]                             info <- base::paste(info, collapse = "; ")
[10:29:58.561]                             if (!has_future) {
[10:29:58.561]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:58.561]                                 info)
[10:29:58.561]                             }
[10:29:58.561]                             else {
[10:29:58.561]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:58.561]                                 info, version)
[10:29:58.561]                             }
[10:29:58.561]                             base::stop(msg)
[10:29:58.561]                           }
[10:29:58.561]                         })
[10:29:58.561]                       }
[10:29:58.561]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:58.561]                       base::options(mc.cores = 1L)
[10:29:58.561]                     }
[10:29:58.561]                     base::local({
[10:29:58.561]                       for (pkg in "stats") {
[10:29:58.561]                         base::loadNamespace(pkg)
[10:29:58.561]                         base::library(pkg, character.only = TRUE)
[10:29:58.561]                       }
[10:29:58.561]                     })
[10:29:58.561]                   }
[10:29:58.561]                   ...future.strategy.old <- future::plan("list")
[10:29:58.561]                   options(future.plan = NULL)
[10:29:58.561]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:58.561]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:58.561]                 }
[10:29:58.561]                 ...future.workdir <- getwd()
[10:29:58.561]             }
[10:29:58.561]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:58.561]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:58.561]         }
[10:29:58.561]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:58.561]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:58.561]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:58.561]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:58.561]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:58.561]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:58.561]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:58.561]             base::names(...future.oldOptions))
[10:29:58.561]     }
[10:29:58.561]     if (FALSE) {
[10:29:58.561]     }
[10:29:58.561]     else {
[10:29:58.561]         if (TRUE) {
[10:29:58.561]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:58.561]                 open = "w")
[10:29:58.561]         }
[10:29:58.561]         else {
[10:29:58.561]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:58.561]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:58.561]         }
[10:29:58.561]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:58.561]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:58.561]             base::sink(type = "output", split = FALSE)
[10:29:58.561]             base::close(...future.stdout)
[10:29:58.561]         }, add = TRUE)
[10:29:58.561]     }
[10:29:58.561]     ...future.frame <- base::sys.nframe()
[10:29:58.561]     ...future.conditions <- base::list()
[10:29:58.561]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:58.561]     if (FALSE) {
[10:29:58.561]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:58.561]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:58.561]     }
[10:29:58.561]     ...future.result <- base::tryCatch({
[10:29:58.561]         base::withCallingHandlers({
[10:29:58.561]             ...future.value <- base::withVisible(base::local({
[10:29:58.561]                 ...future.makeSendCondition <- base::local({
[10:29:58.561]                   sendCondition <- NULL
[10:29:58.561]                   function(frame = 1L) {
[10:29:58.561]                     if (is.function(sendCondition)) 
[10:29:58.561]                       return(sendCondition)
[10:29:58.561]                     ns <- getNamespace("parallel")
[10:29:58.561]                     if (exists("sendData", mode = "function", 
[10:29:58.561]                       envir = ns)) {
[10:29:58.561]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:58.561]                         envir = ns)
[10:29:58.561]                       envir <- sys.frame(frame)
[10:29:58.561]                       master <- NULL
[10:29:58.561]                       while (!identical(envir, .GlobalEnv) && 
[10:29:58.561]                         !identical(envir, emptyenv())) {
[10:29:58.561]                         if (exists("master", mode = "list", envir = envir, 
[10:29:58.561]                           inherits = FALSE)) {
[10:29:58.561]                           master <- get("master", mode = "list", 
[10:29:58.561]                             envir = envir, inherits = FALSE)
[10:29:58.561]                           if (inherits(master, c("SOCKnode", 
[10:29:58.561]                             "SOCK0node"))) {
[10:29:58.561]                             sendCondition <<- function(cond) {
[10:29:58.561]                               data <- list(type = "VALUE", value = cond, 
[10:29:58.561]                                 success = TRUE)
[10:29:58.561]                               parallel_sendData(master, data)
[10:29:58.561]                             }
[10:29:58.561]                             return(sendCondition)
[10:29:58.561]                           }
[10:29:58.561]                         }
[10:29:58.561]                         frame <- frame + 1L
[10:29:58.561]                         envir <- sys.frame(frame)
[10:29:58.561]                       }
[10:29:58.561]                     }
[10:29:58.561]                     sendCondition <<- function(cond) NULL
[10:29:58.561]                   }
[10:29:58.561]                 })
[10:29:58.561]                 withCallingHandlers({
[10:29:58.561]                   {
[10:29:58.561]                     do.call(function(...) {
[10:29:58.561]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:58.561]                       if (!identical(...future.globals.maxSize.org, 
[10:29:58.561]                         ...future.globals.maxSize)) {
[10:29:58.561]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:58.561]                         on.exit(options(oopts), add = TRUE)
[10:29:58.561]                       }
[10:29:58.561]                       {
[10:29:58.561]                         lapply(seq_along(...future.elements_ii), 
[10:29:58.561]                           FUN = function(jj) {
[10:29:58.561]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:58.561]                             ...future.FUN(...future.X_jj, ...)
[10:29:58.561]                           })
[10:29:58.561]                       }
[10:29:58.561]                     }, args = future.call.arguments)
[10:29:58.561]                   }
[10:29:58.561]                 }, immediateCondition = function(cond) {
[10:29:58.561]                   sendCondition <- ...future.makeSendCondition()
[10:29:58.561]                   sendCondition(cond)
[10:29:58.561]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.561]                   {
[10:29:58.561]                     inherits <- base::inherits
[10:29:58.561]                     invokeRestart <- base::invokeRestart
[10:29:58.561]                     is.null <- base::is.null
[10:29:58.561]                     muffled <- FALSE
[10:29:58.561]                     if (inherits(cond, "message")) {
[10:29:58.561]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:58.561]                       if (muffled) 
[10:29:58.561]                         invokeRestart("muffleMessage")
[10:29:58.561]                     }
[10:29:58.561]                     else if (inherits(cond, "warning")) {
[10:29:58.561]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:58.561]                       if (muffled) 
[10:29:58.561]                         invokeRestart("muffleWarning")
[10:29:58.561]                     }
[10:29:58.561]                     else if (inherits(cond, "condition")) {
[10:29:58.561]                       if (!is.null(pattern)) {
[10:29:58.561]                         computeRestarts <- base::computeRestarts
[10:29:58.561]                         grepl <- base::grepl
[10:29:58.561]                         restarts <- computeRestarts(cond)
[10:29:58.561]                         for (restart in restarts) {
[10:29:58.561]                           name <- restart$name
[10:29:58.561]                           if (is.null(name)) 
[10:29:58.561]                             next
[10:29:58.561]                           if (!grepl(pattern, name)) 
[10:29:58.561]                             next
[10:29:58.561]                           invokeRestart(restart)
[10:29:58.561]                           muffled <- TRUE
[10:29:58.561]                           break
[10:29:58.561]                         }
[10:29:58.561]                       }
[10:29:58.561]                     }
[10:29:58.561]                     invisible(muffled)
[10:29:58.561]                   }
[10:29:58.561]                   muffleCondition(cond)
[10:29:58.561]                 })
[10:29:58.561]             }))
[10:29:58.561]             future::FutureResult(value = ...future.value$value, 
[10:29:58.561]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:58.561]                   ...future.rng), globalenv = if (FALSE) 
[10:29:58.561]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:58.561]                     ...future.globalenv.names))
[10:29:58.561]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:58.561]         }, condition = base::local({
[10:29:58.561]             c <- base::c
[10:29:58.561]             inherits <- base::inherits
[10:29:58.561]             invokeRestart <- base::invokeRestart
[10:29:58.561]             length <- base::length
[10:29:58.561]             list <- base::list
[10:29:58.561]             seq.int <- base::seq.int
[10:29:58.561]             signalCondition <- base::signalCondition
[10:29:58.561]             sys.calls <- base::sys.calls
[10:29:58.561]             `[[` <- base::`[[`
[10:29:58.561]             `+` <- base::`+`
[10:29:58.561]             `<<-` <- base::`<<-`
[10:29:58.561]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:58.561]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:58.561]                   3L)]
[10:29:58.561]             }
[10:29:58.561]             function(cond) {
[10:29:58.561]                 is_error <- inherits(cond, "error")
[10:29:58.561]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:58.561]                   NULL)
[10:29:58.561]                 if (is_error) {
[10:29:58.561]                   sessionInformation <- function() {
[10:29:58.561]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:58.561]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:58.561]                       search = base::search(), system = base::Sys.info())
[10:29:58.561]                   }
[10:29:58.561]                   ...future.conditions[[length(...future.conditions) + 
[10:29:58.561]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:58.561]                     cond$call), session = sessionInformation(), 
[10:29:58.561]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:58.561]                   signalCondition(cond)
[10:29:58.561]                 }
[10:29:58.561]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:58.561]                 "immediateCondition"))) {
[10:29:58.561]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:58.561]                   ...future.conditions[[length(...future.conditions) + 
[10:29:58.561]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:58.561]                   if (TRUE && !signal) {
[10:29:58.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.561]                     {
[10:29:58.561]                       inherits <- base::inherits
[10:29:58.561]                       invokeRestart <- base::invokeRestart
[10:29:58.561]                       is.null <- base::is.null
[10:29:58.561]                       muffled <- FALSE
[10:29:58.561]                       if (inherits(cond, "message")) {
[10:29:58.561]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:58.561]                         if (muffled) 
[10:29:58.561]                           invokeRestart("muffleMessage")
[10:29:58.561]                       }
[10:29:58.561]                       else if (inherits(cond, "warning")) {
[10:29:58.561]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:58.561]                         if (muffled) 
[10:29:58.561]                           invokeRestart("muffleWarning")
[10:29:58.561]                       }
[10:29:58.561]                       else if (inherits(cond, "condition")) {
[10:29:58.561]                         if (!is.null(pattern)) {
[10:29:58.561]                           computeRestarts <- base::computeRestarts
[10:29:58.561]                           grepl <- base::grepl
[10:29:58.561]                           restarts <- computeRestarts(cond)
[10:29:58.561]                           for (restart in restarts) {
[10:29:58.561]                             name <- restart$name
[10:29:58.561]                             if (is.null(name)) 
[10:29:58.561]                               next
[10:29:58.561]                             if (!grepl(pattern, name)) 
[10:29:58.561]                               next
[10:29:58.561]                             invokeRestart(restart)
[10:29:58.561]                             muffled <- TRUE
[10:29:58.561]                             break
[10:29:58.561]                           }
[10:29:58.561]                         }
[10:29:58.561]                       }
[10:29:58.561]                       invisible(muffled)
[10:29:58.561]                     }
[10:29:58.561]                     muffleCondition(cond, pattern = "^muffle")
[10:29:58.561]                   }
[10:29:58.561]                 }
[10:29:58.561]                 else {
[10:29:58.561]                   if (TRUE) {
[10:29:58.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.561]                     {
[10:29:58.561]                       inherits <- base::inherits
[10:29:58.561]                       invokeRestart <- base::invokeRestart
[10:29:58.561]                       is.null <- base::is.null
[10:29:58.561]                       muffled <- FALSE
[10:29:58.561]                       if (inherits(cond, "message")) {
[10:29:58.561]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:58.561]                         if (muffled) 
[10:29:58.561]                           invokeRestart("muffleMessage")
[10:29:58.561]                       }
[10:29:58.561]                       else if (inherits(cond, "warning")) {
[10:29:58.561]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:58.561]                         if (muffled) 
[10:29:58.561]                           invokeRestart("muffleWarning")
[10:29:58.561]                       }
[10:29:58.561]                       else if (inherits(cond, "condition")) {
[10:29:58.561]                         if (!is.null(pattern)) {
[10:29:58.561]                           computeRestarts <- base::computeRestarts
[10:29:58.561]                           grepl <- base::grepl
[10:29:58.561]                           restarts <- computeRestarts(cond)
[10:29:58.561]                           for (restart in restarts) {
[10:29:58.561]                             name <- restart$name
[10:29:58.561]                             if (is.null(name)) 
[10:29:58.561]                               next
[10:29:58.561]                             if (!grepl(pattern, name)) 
[10:29:58.561]                               next
[10:29:58.561]                             invokeRestart(restart)
[10:29:58.561]                             muffled <- TRUE
[10:29:58.561]                             break
[10:29:58.561]                           }
[10:29:58.561]                         }
[10:29:58.561]                       }
[10:29:58.561]                       invisible(muffled)
[10:29:58.561]                     }
[10:29:58.561]                     muffleCondition(cond, pattern = "^muffle")
[10:29:58.561]                   }
[10:29:58.561]                 }
[10:29:58.561]             }
[10:29:58.561]         }))
[10:29:58.561]     }, error = function(ex) {
[10:29:58.561]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:58.561]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:58.561]                 ...future.rng), started = ...future.startTime, 
[10:29:58.561]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:58.561]             version = "1.8"), class = "FutureResult")
[10:29:58.561]     }, finally = {
[10:29:58.561]         if (!identical(...future.workdir, getwd())) 
[10:29:58.561]             setwd(...future.workdir)
[10:29:58.561]         {
[10:29:58.561]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:58.561]                 ...future.oldOptions$nwarnings <- NULL
[10:29:58.561]             }
[10:29:58.561]             base::options(...future.oldOptions)
[10:29:58.561]             if (.Platform$OS.type == "windows") {
[10:29:58.561]                 old_names <- names(...future.oldEnvVars)
[10:29:58.561]                 envs <- base::Sys.getenv()
[10:29:58.561]                 names <- names(envs)
[10:29:58.561]                 common <- intersect(names, old_names)
[10:29:58.561]                 added <- setdiff(names, old_names)
[10:29:58.561]                 removed <- setdiff(old_names, names)
[10:29:58.561]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:58.561]                   envs[common]]
[10:29:58.561]                 NAMES <- toupper(changed)
[10:29:58.561]                 args <- list()
[10:29:58.561]                 for (kk in seq_along(NAMES)) {
[10:29:58.561]                   name <- changed[[kk]]
[10:29:58.561]                   NAME <- NAMES[[kk]]
[10:29:58.561]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.561]                     next
[10:29:58.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:58.561]                 }
[10:29:58.561]                 NAMES <- toupper(added)
[10:29:58.561]                 for (kk in seq_along(NAMES)) {
[10:29:58.561]                   name <- added[[kk]]
[10:29:58.561]                   NAME <- NAMES[[kk]]
[10:29:58.561]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.561]                     next
[10:29:58.561]                   args[[name]] <- ""
[10:29:58.561]                 }
[10:29:58.561]                 NAMES <- toupper(removed)
[10:29:58.561]                 for (kk in seq_along(NAMES)) {
[10:29:58.561]                   name <- removed[[kk]]
[10:29:58.561]                   NAME <- NAMES[[kk]]
[10:29:58.561]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.561]                     next
[10:29:58.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:58.561]                 }
[10:29:58.561]                 if (length(args) > 0) 
[10:29:58.561]                   base::do.call(base::Sys.setenv, args = args)
[10:29:58.561]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:58.561]             }
[10:29:58.561]             else {
[10:29:58.561]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:58.561]             }
[10:29:58.561]             {
[10:29:58.561]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:58.561]                   0L) {
[10:29:58.561]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:58.561]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:58.561]                   base::options(opts)
[10:29:58.561]                 }
[10:29:58.561]                 {
[10:29:58.561]                   {
[10:29:58.561]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:58.561]                     NULL
[10:29:58.561]                   }
[10:29:58.561]                   options(future.plan = NULL)
[10:29:58.561]                   if (is.na(NA_character_)) 
[10:29:58.561]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:58.561]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:58.561]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:58.561]                     .init = FALSE)
[10:29:58.561]                 }
[10:29:58.561]             }
[10:29:58.561]         }
[10:29:58.561]     })
[10:29:58.561]     if (TRUE) {
[10:29:58.561]         base::sink(type = "output", split = FALSE)
[10:29:58.561]         if (TRUE) {
[10:29:58.561]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:58.561]         }
[10:29:58.561]         else {
[10:29:58.561]             ...future.result["stdout"] <- base::list(NULL)
[10:29:58.561]         }
[10:29:58.561]         base::close(...future.stdout)
[10:29:58.561]         ...future.stdout <- NULL
[10:29:58.561]     }
[10:29:58.561]     ...future.result$conditions <- ...future.conditions
[10:29:58.561]     ...future.result$finished <- base::Sys.time()
[10:29:58.561]     ...future.result
[10:29:58.561] }
[10:29:58.564] Exporting 5 global objects (1.30 KiB) to cluster node #1 ...
[10:29:58.564] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[10:29:58.565] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[10:29:58.565] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #1 ...
[10:29:58.565] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #1 ... DONE
[10:29:58.565] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[10:29:58.566] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[10:29:58.566] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:29:58.566] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:29:58.566] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:29:58.566] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:29:58.567] Exporting 5 global objects (1.30 KiB) to cluster node #1 ... DONE
[10:29:58.567] MultisessionFuture started
[10:29:58.567] - Launch lazy future ... done
[10:29:58.567] run() for ‘MultisessionFuture’ ... done
[10:29:58.567] Created future:
[10:29:58.567] MultisessionFuture:
[10:29:58.567] Label: ‘future_eapply-1’
[10:29:58.567] Expression:
[10:29:58.567] {
[10:29:58.567]     do.call(function(...) {
[10:29:58.567]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:58.567]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:58.567]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:58.567]             on.exit(options(oopts), add = TRUE)
[10:29:58.567]         }
[10:29:58.567]         {
[10:29:58.567]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:58.567]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:58.567]                 ...future.FUN(...future.X_jj, ...)
[10:29:58.567]             })
[10:29:58.567]         }
[10:29:58.567]     }, args = future.call.arguments)
[10:29:58.567] }
[10:29:58.567] Lazy evaluation: FALSE
[10:29:58.567] Asynchronous evaluation: TRUE
[10:29:58.567] Local evaluation: TRUE
[10:29:58.567] Environment: R_GlobalEnv
[10:29:58.567] Capture standard output: TRUE
[10:29:58.567] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:58.567] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:58.567] Packages: 1 packages (‘stats’)
[10:29:58.567] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:58.567] Resolved: FALSE
[10:29:58.567] Value: <not collected>
[10:29:58.567] Conditions captured: <none>
[10:29:58.567] Early signaling: FALSE
[10:29:58.567] Owner process: db6eb61b-64f1-ae95-7e8b-287fbc43411a
[10:29:58.567] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:58.579] Chunk #1 of 2 ... DONE
[10:29:58.579] Chunk #2 of 2 ...
[10:29:58.579]  - Finding globals in 'X' for chunk #2 ...
[10:29:58.579] getGlobalsAndPackages() ...
[10:29:58.579] Searching for globals...
[10:29:58.580] 
[10:29:58.580] Searching for globals ... DONE
[10:29:58.580] - globals: [0] <none>
[10:29:58.580] getGlobalsAndPackages() ... DONE
[10:29:58.580]    + additional globals found: [n=0] 
[10:29:58.580]    + additional namespaces needed: [n=0] 
[10:29:58.580]  - Finding globals in 'X' for chunk #2 ... DONE
[10:29:58.580]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:58.581]  - seeds: <none>
[10:29:58.581]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:58.581] getGlobalsAndPackages() ...
[10:29:58.581] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:58.581] Resolving globals: FALSE
[10:29:58.581] Tweak future expression to call with '...' arguments ...
[10:29:58.581] {
[10:29:58.581]     do.call(function(...) {
[10:29:58.581]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:58.581]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:58.581]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:58.581]             on.exit(options(oopts), add = TRUE)
[10:29:58.581]         }
[10:29:58.581]         {
[10:29:58.581]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:58.581]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:58.581]                 ...future.FUN(...future.X_jj, ...)
[10:29:58.581]             })
[10:29:58.581]         }
[10:29:58.581]     }, args = future.call.arguments)
[10:29:58.581] }
[10:29:58.581] Tweak future expression to call with '...' arguments ... DONE
[10:29:58.582] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:58.582] - packages: [1] ‘stats’
[10:29:58.582] getGlobalsAndPackages() ... DONE
[10:29:58.582] run() for ‘Future’ ...
[10:29:58.583] - state: ‘created’
[10:29:58.583] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:58.596] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:58.596] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:58.597]   - Field: ‘node’
[10:29:58.597]   - Field: ‘label’
[10:29:58.597]   - Field: ‘local’
[10:29:58.597]   - Field: ‘owner’
[10:29:58.597]   - Field: ‘envir’
[10:29:58.597]   - Field: ‘workers’
[10:29:58.597]   - Field: ‘packages’
[10:29:58.597]   - Field: ‘gc’
[10:29:58.597]   - Field: ‘conditions’
[10:29:58.597]   - Field: ‘persistent’
[10:29:58.598]   - Field: ‘expr’
[10:29:58.598]   - Field: ‘uuid’
[10:29:58.598]   - Field: ‘seed’
[10:29:58.598]   - Field: ‘version’
[10:29:58.598]   - Field: ‘result’
[10:29:58.598]   - Field: ‘asynchronous’
[10:29:58.598]   - Field: ‘calls’
[10:29:58.598]   - Field: ‘globals’
[10:29:58.598]   - Field: ‘stdout’
[10:29:58.598]   - Field: ‘earlySignal’
[10:29:58.598]   - Field: ‘lazy’
[10:29:58.599]   - Field: ‘state’
[10:29:58.599] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:58.599] - Launch lazy future ...
[10:29:58.599] Packages needed by the future expression (n = 1): ‘stats’
[10:29:58.599] Packages needed by future strategies (n = 0): <none>
[10:29:58.600] {
[10:29:58.600]     {
[10:29:58.600]         {
[10:29:58.600]             ...future.startTime <- base::Sys.time()
[10:29:58.600]             {
[10:29:58.600]                 {
[10:29:58.600]                   {
[10:29:58.600]                     {
[10:29:58.600]                       {
[10:29:58.600]                         base::local({
[10:29:58.600]                           has_future <- base::requireNamespace("future", 
[10:29:58.600]                             quietly = TRUE)
[10:29:58.600]                           if (has_future) {
[10:29:58.600]                             ns <- base::getNamespace("future")
[10:29:58.600]                             version <- ns[[".package"]][["version"]]
[10:29:58.600]                             if (is.null(version)) 
[10:29:58.600]                               version <- utils::packageVersion("future")
[10:29:58.600]                           }
[10:29:58.600]                           else {
[10:29:58.600]                             version <- NULL
[10:29:58.600]                           }
[10:29:58.600]                           if (!has_future || version < "1.8.0") {
[10:29:58.600]                             info <- base::c(r_version = base::gsub("R version ", 
[10:29:58.600]                               "", base::R.version$version.string), 
[10:29:58.600]                               platform = base::sprintf("%s (%s-bit)", 
[10:29:58.600]                                 base::R.version$platform, 8 * 
[10:29:58.600]                                   base::.Machine$sizeof.pointer), 
[10:29:58.600]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:58.600]                                 "release", "version")], collapse = " "), 
[10:29:58.600]                               hostname = base::Sys.info()[["nodename"]])
[10:29:58.600]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:29:58.600]                               info)
[10:29:58.600]                             info <- base::paste(info, collapse = "; ")
[10:29:58.600]                             if (!has_future) {
[10:29:58.600]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:58.600]                                 info)
[10:29:58.600]                             }
[10:29:58.600]                             else {
[10:29:58.600]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:58.600]                                 info, version)
[10:29:58.600]                             }
[10:29:58.600]                             base::stop(msg)
[10:29:58.600]                           }
[10:29:58.600]                         })
[10:29:58.600]                       }
[10:29:58.600]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:58.600]                       base::options(mc.cores = 1L)
[10:29:58.600]                     }
[10:29:58.600]                     base::local({
[10:29:58.600]                       for (pkg in "stats") {
[10:29:58.600]                         base::loadNamespace(pkg)
[10:29:58.600]                         base::library(pkg, character.only = TRUE)
[10:29:58.600]                       }
[10:29:58.600]                     })
[10:29:58.600]                   }
[10:29:58.600]                   ...future.strategy.old <- future::plan("list")
[10:29:58.600]                   options(future.plan = NULL)
[10:29:58.600]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:58.600]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:58.600]                 }
[10:29:58.600]                 ...future.workdir <- getwd()
[10:29:58.600]             }
[10:29:58.600]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:58.600]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:58.600]         }
[10:29:58.600]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:58.600]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:58.600]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:58.600]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:58.600]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:58.600]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:58.600]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:58.600]             base::names(...future.oldOptions))
[10:29:58.600]     }
[10:29:58.600]     if (FALSE) {
[10:29:58.600]     }
[10:29:58.600]     else {
[10:29:58.600]         if (TRUE) {
[10:29:58.600]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:58.600]                 open = "w")
[10:29:58.600]         }
[10:29:58.600]         else {
[10:29:58.600]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:58.600]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:58.600]         }
[10:29:58.600]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:58.600]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:58.600]             base::sink(type = "output", split = FALSE)
[10:29:58.600]             base::close(...future.stdout)
[10:29:58.600]         }, add = TRUE)
[10:29:58.600]     }
[10:29:58.600]     ...future.frame <- base::sys.nframe()
[10:29:58.600]     ...future.conditions <- base::list()
[10:29:58.600]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:58.600]     if (FALSE) {
[10:29:58.600]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:58.600]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:58.600]     }
[10:29:58.600]     ...future.result <- base::tryCatch({
[10:29:58.600]         base::withCallingHandlers({
[10:29:58.600]             ...future.value <- base::withVisible(base::local({
[10:29:58.600]                 ...future.makeSendCondition <- base::local({
[10:29:58.600]                   sendCondition <- NULL
[10:29:58.600]                   function(frame = 1L) {
[10:29:58.600]                     if (is.function(sendCondition)) 
[10:29:58.600]                       return(sendCondition)
[10:29:58.600]                     ns <- getNamespace("parallel")
[10:29:58.600]                     if (exists("sendData", mode = "function", 
[10:29:58.600]                       envir = ns)) {
[10:29:58.600]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:58.600]                         envir = ns)
[10:29:58.600]                       envir <- sys.frame(frame)
[10:29:58.600]                       master <- NULL
[10:29:58.600]                       while (!identical(envir, .GlobalEnv) && 
[10:29:58.600]                         !identical(envir, emptyenv())) {
[10:29:58.600]                         if (exists("master", mode = "list", envir = envir, 
[10:29:58.600]                           inherits = FALSE)) {
[10:29:58.600]                           master <- get("master", mode = "list", 
[10:29:58.600]                             envir = envir, inherits = FALSE)
[10:29:58.600]                           if (inherits(master, c("SOCKnode", 
[10:29:58.600]                             "SOCK0node"))) {
[10:29:58.600]                             sendCondition <<- function(cond) {
[10:29:58.600]                               data <- list(type = "VALUE", value = cond, 
[10:29:58.600]                                 success = TRUE)
[10:29:58.600]                               parallel_sendData(master, data)
[10:29:58.600]                             }
[10:29:58.600]                             return(sendCondition)
[10:29:58.600]                           }
[10:29:58.600]                         }
[10:29:58.600]                         frame <- frame + 1L
[10:29:58.600]                         envir <- sys.frame(frame)
[10:29:58.600]                       }
[10:29:58.600]                     }
[10:29:58.600]                     sendCondition <<- function(cond) NULL
[10:29:58.600]                   }
[10:29:58.600]                 })
[10:29:58.600]                 withCallingHandlers({
[10:29:58.600]                   {
[10:29:58.600]                     do.call(function(...) {
[10:29:58.600]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:58.600]                       if (!identical(...future.globals.maxSize.org, 
[10:29:58.600]                         ...future.globals.maxSize)) {
[10:29:58.600]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:58.600]                         on.exit(options(oopts), add = TRUE)
[10:29:58.600]                       }
[10:29:58.600]                       {
[10:29:58.600]                         lapply(seq_along(...future.elements_ii), 
[10:29:58.600]                           FUN = function(jj) {
[10:29:58.600]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:58.600]                             ...future.FUN(...future.X_jj, ...)
[10:29:58.600]                           })
[10:29:58.600]                       }
[10:29:58.600]                     }, args = future.call.arguments)
[10:29:58.600]                   }
[10:29:58.600]                 }, immediateCondition = function(cond) {
[10:29:58.600]                   sendCondition <- ...future.makeSendCondition()
[10:29:58.600]                   sendCondition(cond)
[10:29:58.600]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.600]                   {
[10:29:58.600]                     inherits <- base::inherits
[10:29:58.600]                     invokeRestart <- base::invokeRestart
[10:29:58.600]                     is.null <- base::is.null
[10:29:58.600]                     muffled <- FALSE
[10:29:58.600]                     if (inherits(cond, "message")) {
[10:29:58.600]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:58.600]                       if (muffled) 
[10:29:58.600]                         invokeRestart("muffleMessage")
[10:29:58.600]                     }
[10:29:58.600]                     else if (inherits(cond, "warning")) {
[10:29:58.600]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:58.600]                       if (muffled) 
[10:29:58.600]                         invokeRestart("muffleWarning")
[10:29:58.600]                     }
[10:29:58.600]                     else if (inherits(cond, "condition")) {
[10:29:58.600]                       if (!is.null(pattern)) {
[10:29:58.600]                         computeRestarts <- base::computeRestarts
[10:29:58.600]                         grepl <- base::grepl
[10:29:58.600]                         restarts <- computeRestarts(cond)
[10:29:58.600]                         for (restart in restarts) {
[10:29:58.600]                           name <- restart$name
[10:29:58.600]                           if (is.null(name)) 
[10:29:58.600]                             next
[10:29:58.600]                           if (!grepl(pattern, name)) 
[10:29:58.600]                             next
[10:29:58.600]                           invokeRestart(restart)
[10:29:58.600]                           muffled <- TRUE
[10:29:58.600]                           break
[10:29:58.600]                         }
[10:29:58.600]                       }
[10:29:58.600]                     }
[10:29:58.600]                     invisible(muffled)
[10:29:58.600]                   }
[10:29:58.600]                   muffleCondition(cond)
[10:29:58.600]                 })
[10:29:58.600]             }))
[10:29:58.600]             future::FutureResult(value = ...future.value$value, 
[10:29:58.600]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:58.600]                   ...future.rng), globalenv = if (FALSE) 
[10:29:58.600]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:58.600]                     ...future.globalenv.names))
[10:29:58.600]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:58.600]         }, condition = base::local({
[10:29:58.600]             c <- base::c
[10:29:58.600]             inherits <- base::inherits
[10:29:58.600]             invokeRestart <- base::invokeRestart
[10:29:58.600]             length <- base::length
[10:29:58.600]             list <- base::list
[10:29:58.600]             seq.int <- base::seq.int
[10:29:58.600]             signalCondition <- base::signalCondition
[10:29:58.600]             sys.calls <- base::sys.calls
[10:29:58.600]             `[[` <- base::`[[`
[10:29:58.600]             `+` <- base::`+`
[10:29:58.600]             `<<-` <- base::`<<-`
[10:29:58.600]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:58.600]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:58.600]                   3L)]
[10:29:58.600]             }
[10:29:58.600]             function(cond) {
[10:29:58.600]                 is_error <- inherits(cond, "error")
[10:29:58.600]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:58.600]                   NULL)
[10:29:58.600]                 if (is_error) {
[10:29:58.600]                   sessionInformation <- function() {
[10:29:58.600]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:58.600]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:58.600]                       search = base::search(), system = base::Sys.info())
[10:29:58.600]                   }
[10:29:58.600]                   ...future.conditions[[length(...future.conditions) + 
[10:29:58.600]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:58.600]                     cond$call), session = sessionInformation(), 
[10:29:58.600]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:58.600]                   signalCondition(cond)
[10:29:58.600]                 }
[10:29:58.600]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:58.600]                 "immediateCondition"))) {
[10:29:58.600]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:58.600]                   ...future.conditions[[length(...future.conditions) + 
[10:29:58.600]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:58.600]                   if (TRUE && !signal) {
[10:29:58.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.600]                     {
[10:29:58.600]                       inherits <- base::inherits
[10:29:58.600]                       invokeRestart <- base::invokeRestart
[10:29:58.600]                       is.null <- base::is.null
[10:29:58.600]                       muffled <- FALSE
[10:29:58.600]                       if (inherits(cond, "message")) {
[10:29:58.600]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:58.600]                         if (muffled) 
[10:29:58.600]                           invokeRestart("muffleMessage")
[10:29:58.600]                       }
[10:29:58.600]                       else if (inherits(cond, "warning")) {
[10:29:58.600]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:58.600]                         if (muffled) 
[10:29:58.600]                           invokeRestart("muffleWarning")
[10:29:58.600]                       }
[10:29:58.600]                       else if (inherits(cond, "condition")) {
[10:29:58.600]                         if (!is.null(pattern)) {
[10:29:58.600]                           computeRestarts <- base::computeRestarts
[10:29:58.600]                           grepl <- base::grepl
[10:29:58.600]                           restarts <- computeRestarts(cond)
[10:29:58.600]                           for (restart in restarts) {
[10:29:58.600]                             name <- restart$name
[10:29:58.600]                             if (is.null(name)) 
[10:29:58.600]                               next
[10:29:58.600]                             if (!grepl(pattern, name)) 
[10:29:58.600]                               next
[10:29:58.600]                             invokeRestart(restart)
[10:29:58.600]                             muffled <- TRUE
[10:29:58.600]                             break
[10:29:58.600]                           }
[10:29:58.600]                         }
[10:29:58.600]                       }
[10:29:58.600]                       invisible(muffled)
[10:29:58.600]                     }
[10:29:58.600]                     muffleCondition(cond, pattern = "^muffle")
[10:29:58.600]                   }
[10:29:58.600]                 }
[10:29:58.600]                 else {
[10:29:58.600]                   if (TRUE) {
[10:29:58.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.600]                     {
[10:29:58.600]                       inherits <- base::inherits
[10:29:58.600]                       invokeRestart <- base::invokeRestart
[10:29:58.600]                       is.null <- base::is.null
[10:29:58.600]                       muffled <- FALSE
[10:29:58.600]                       if (inherits(cond, "message")) {
[10:29:58.600]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:58.600]                         if (muffled) 
[10:29:58.600]                           invokeRestart("muffleMessage")
[10:29:58.600]                       }
[10:29:58.600]                       else if (inherits(cond, "warning")) {
[10:29:58.600]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:58.600]                         if (muffled) 
[10:29:58.600]                           invokeRestart("muffleWarning")
[10:29:58.600]                       }
[10:29:58.600]                       else if (inherits(cond, "condition")) {
[10:29:58.600]                         if (!is.null(pattern)) {
[10:29:58.600]                           computeRestarts <- base::computeRestarts
[10:29:58.600]                           grepl <- base::grepl
[10:29:58.600]                           restarts <- computeRestarts(cond)
[10:29:58.600]                           for (restart in restarts) {
[10:29:58.600]                             name <- restart$name
[10:29:58.600]                             if (is.null(name)) 
[10:29:58.600]                               next
[10:29:58.600]                             if (!grepl(pattern, name)) 
[10:29:58.600]                               next
[10:29:58.600]                             invokeRestart(restart)
[10:29:58.600]                             muffled <- TRUE
[10:29:58.600]                             break
[10:29:58.600]                           }
[10:29:58.600]                         }
[10:29:58.600]                       }
[10:29:58.600]                       invisible(muffled)
[10:29:58.600]                     }
[10:29:58.600]                     muffleCondition(cond, pattern = "^muffle")
[10:29:58.600]                   }
[10:29:58.600]                 }
[10:29:58.600]             }
[10:29:58.600]         }))
[10:29:58.600]     }, error = function(ex) {
[10:29:58.600]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:58.600]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:58.600]                 ...future.rng), started = ...future.startTime, 
[10:29:58.600]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:58.600]             version = "1.8"), class = "FutureResult")
[10:29:58.600]     }, finally = {
[10:29:58.600]         if (!identical(...future.workdir, getwd())) 
[10:29:58.600]             setwd(...future.workdir)
[10:29:58.600]         {
[10:29:58.600]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:58.600]                 ...future.oldOptions$nwarnings <- NULL
[10:29:58.600]             }
[10:29:58.600]             base::options(...future.oldOptions)
[10:29:58.600]             if (.Platform$OS.type == "windows") {
[10:29:58.600]                 old_names <- names(...future.oldEnvVars)
[10:29:58.600]                 envs <- base::Sys.getenv()
[10:29:58.600]                 names <- names(envs)
[10:29:58.600]                 common <- intersect(names, old_names)
[10:29:58.600]                 added <- setdiff(names, old_names)
[10:29:58.600]                 removed <- setdiff(old_names, names)
[10:29:58.600]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:58.600]                   envs[common]]
[10:29:58.600]                 NAMES <- toupper(changed)
[10:29:58.600]                 args <- list()
[10:29:58.600]                 for (kk in seq_along(NAMES)) {
[10:29:58.600]                   name <- changed[[kk]]
[10:29:58.600]                   NAME <- NAMES[[kk]]
[10:29:58.600]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.600]                     next
[10:29:58.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:58.600]                 }
[10:29:58.600]                 NAMES <- toupper(added)
[10:29:58.600]                 for (kk in seq_along(NAMES)) {
[10:29:58.600]                   name <- added[[kk]]
[10:29:58.600]                   NAME <- NAMES[[kk]]
[10:29:58.600]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.600]                     next
[10:29:58.600]                   args[[name]] <- ""
[10:29:58.600]                 }
[10:29:58.600]                 NAMES <- toupper(removed)
[10:29:58.600]                 for (kk in seq_along(NAMES)) {
[10:29:58.600]                   name <- removed[[kk]]
[10:29:58.600]                   NAME <- NAMES[[kk]]
[10:29:58.600]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.600]                     next
[10:29:58.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:58.600]                 }
[10:29:58.600]                 if (length(args) > 0) 
[10:29:58.600]                   base::do.call(base::Sys.setenv, args = args)
[10:29:58.600]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:58.600]             }
[10:29:58.600]             else {
[10:29:58.600]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:58.600]             }
[10:29:58.600]             {
[10:29:58.600]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:58.600]                   0L) {
[10:29:58.600]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:58.600]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:58.600]                   base::options(opts)
[10:29:58.600]                 }
[10:29:58.600]                 {
[10:29:58.600]                   {
[10:29:58.600]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:58.600]                     NULL
[10:29:58.600]                   }
[10:29:58.600]                   options(future.plan = NULL)
[10:29:58.600]                   if (is.na(NA_character_)) 
[10:29:58.600]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:58.600]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:58.600]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:58.600]                     .init = FALSE)
[10:29:58.600]                 }
[10:29:58.600]             }
[10:29:58.600]         }
[10:29:58.600]     })
[10:29:58.600]     if (TRUE) {
[10:29:58.600]         base::sink(type = "output", split = FALSE)
[10:29:58.600]         if (TRUE) {
[10:29:58.600]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:58.600]         }
[10:29:58.600]         else {
[10:29:58.600]             ...future.result["stdout"] <- base::list(NULL)
[10:29:58.600]         }
[10:29:58.600]         base::close(...future.stdout)
[10:29:58.600]         ...future.stdout <- NULL
[10:29:58.600]     }
[10:29:58.600]     ...future.result$conditions <- ...future.conditions
[10:29:58.600]     ...future.result$finished <- base::Sys.time()
[10:29:58.600]     ...future.result
[10:29:58.600] }
[10:29:58.602] Exporting 5 global objects (1.30 KiB) to cluster node #2 ...
[10:29:58.603] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[10:29:58.603] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[10:29:58.603] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #2 ...
[10:29:58.603] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #2 ... DONE
[10:29:58.604] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[10:29:58.604] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[10:29:58.604] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:29:58.604] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:29:58.604] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:29:58.608] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:29:58.608] Exporting 5 global objects (1.30 KiB) to cluster node #2 ... DONE
[10:29:58.609] MultisessionFuture started
[10:29:58.609] - Launch lazy future ... done
[10:29:58.609] run() for ‘MultisessionFuture’ ... done
[10:29:58.609] Created future:
[10:29:58.610] MultisessionFuture:
[10:29:58.610] Label: ‘future_eapply-2’
[10:29:58.610] Expression:
[10:29:58.610] {
[10:29:58.610]     do.call(function(...) {
[10:29:58.610]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:58.610]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:58.610]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:58.610]             on.exit(options(oopts), add = TRUE)
[10:29:58.610]         }
[10:29:58.610]         {
[10:29:58.610]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:58.610]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:58.610]                 ...future.FUN(...future.X_jj, ...)
[10:29:58.610]             })
[10:29:58.610]         }
[10:29:58.610]     }, args = future.call.arguments)
[10:29:58.610] }
[10:29:58.610] Lazy evaluation: FALSE
[10:29:58.610] Asynchronous evaluation: TRUE
[10:29:58.610] Local evaluation: TRUE
[10:29:58.610] Environment: R_GlobalEnv
[10:29:58.610] Capture standard output: TRUE
[10:29:58.610] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:58.610] Globals: 5 objects totaling 1.50 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:58.610] Packages: 1 packages (‘stats’)
[10:29:58.610] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:58.610] Resolved: FALSE
[10:29:58.610] Value: <not collected>
[10:29:58.610] Conditions captured: <none>
[10:29:58.610] Early signaling: FALSE
[10:29:58.610] Owner process: db6eb61b-64f1-ae95-7e8b-287fbc43411a
[10:29:58.610] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:58.622] Chunk #2 of 2 ... DONE
[10:29:58.622] Launching 2 futures (chunks) ... DONE
[10:29:58.622] Resolving 2 futures (chunks) ...
[10:29:58.622] resolve() on list ...
[10:29:58.622]  recursive: 0
[10:29:58.622]  length: 2
[10:29:58.622] 
[10:29:58.623] receiveMessageFromWorker() for ClusterFuture ...
[10:29:58.623] - Validating connection of MultisessionFuture
[10:29:58.623] - received message: FutureResult
[10:29:58.623] - Received FutureResult
[10:29:58.623] - Erased future from FutureRegistry
[10:29:58.623] result() for ClusterFuture ...
[10:29:58.623] - result already collected: FutureResult
[10:29:58.624] result() for ClusterFuture ... done
[10:29:58.624] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:58.624] Future #1
[10:29:58.624] result() for ClusterFuture ...
[10:29:58.624] - result already collected: FutureResult
[10:29:58.624] result() for ClusterFuture ... done
[10:29:58.624] result() for ClusterFuture ...
[10:29:58.624] - result already collected: FutureResult
[10:29:58.624] result() for ClusterFuture ... done
[10:29:58.624] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:29:58.624] - nx: 2
[10:29:58.625] - relay: TRUE
[10:29:58.625] - stdout: TRUE
[10:29:58.625] - signal: TRUE
[10:29:58.625] - resignal: FALSE
[10:29:58.625] - force: TRUE
[10:29:58.625] - relayed: [n=2] FALSE, FALSE
[10:29:58.625] - queued futures: [n=2] FALSE, FALSE
[10:29:58.625]  - until=1
[10:29:58.625]  - relaying element #1
[10:29:58.625] result() for ClusterFuture ...
[10:29:58.626] - result already collected: FutureResult
[10:29:58.626] result() for ClusterFuture ... done
[10:29:58.626] result() for ClusterFuture ...
[10:29:58.626] - result already collected: FutureResult
[10:29:58.626] result() for ClusterFuture ... done
[10:29:58.626] result() for ClusterFuture ...
[10:29:58.626] - result already collected: FutureResult
[10:29:58.626] result() for ClusterFuture ... done
[10:29:58.626] result() for ClusterFuture ...
[10:29:58.626] - result already collected: FutureResult
[10:29:58.626] result() for ClusterFuture ... done
[10:29:58.626] - relayed: [n=2] TRUE, FALSE
[10:29:58.627] - queued futures: [n=2] TRUE, FALSE
[10:29:58.627] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:29:58.627]  length: 1 (resolved future 1)
[10:29:58.656] receiveMessageFromWorker() for ClusterFuture ...
[10:29:58.656] - Validating connection of MultisessionFuture
[10:29:58.657] - received message: FutureResult
[10:29:58.657] - Received FutureResult
[10:29:58.657] - Erased future from FutureRegistry
[10:29:58.657] result() for ClusterFuture ...
[10:29:58.657] - result already collected: FutureResult
[10:29:58.657] result() for ClusterFuture ... done
[10:29:58.657] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:58.657] Future #2
[10:29:58.658] result() for ClusterFuture ...
[10:29:58.658] - result already collected: FutureResult
[10:29:58.658] result() for ClusterFuture ... done
[10:29:58.658] result() for ClusterFuture ...
[10:29:58.658] - result already collected: FutureResult
[10:29:58.658] result() for ClusterFuture ... done
[10:29:58.658] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:29:58.658] - nx: 2
[10:29:58.658] - relay: TRUE
[10:29:58.658] - stdout: TRUE
[10:29:58.658] - signal: TRUE
[10:29:58.659] - resignal: FALSE
[10:29:58.659] - force: TRUE
[10:29:58.659] - relayed: [n=2] TRUE, FALSE
[10:29:58.659] - queued futures: [n=2] TRUE, FALSE
[10:29:58.659]  - until=2
[10:29:58.659]  - relaying element #2
[10:29:58.659] result() for ClusterFuture ...
[10:29:58.659] - result already collected: FutureResult
[10:29:58.659] result() for ClusterFuture ... done
[10:29:58.659] result() for ClusterFuture ...
[10:29:58.659] - result already collected: FutureResult
[10:29:58.660] result() for ClusterFuture ... done
[10:29:58.660] result() for ClusterFuture ...
[10:29:58.660] - result already collected: FutureResult
[10:29:58.660] result() for ClusterFuture ... done
[10:29:58.660] result() for ClusterFuture ...
[10:29:58.660] - result already collected: FutureResult
[10:29:58.660] result() for ClusterFuture ... done
[10:29:58.660] - relayed: [n=2] TRUE, TRUE
[10:29:58.660] - queued futures: [n=2] TRUE, TRUE
[10:29:58.660] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:29:58.660]  length: 0 (resolved future 2)
[10:29:58.661] Relaying remaining futures
[10:29:58.661] signalConditionsASAP(NULL, pos=0) ...
[10:29:58.661] - nx: 2
[10:29:58.661] - relay: TRUE
[10:29:58.661] - stdout: TRUE
[10:29:58.661] - signal: TRUE
[10:29:58.661] - resignal: FALSE
[10:29:58.661] - force: TRUE
[10:29:58.661] - relayed: [n=2] TRUE, TRUE
[10:29:58.661] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:58.661] - relayed: [n=2] TRUE, TRUE
[10:29:58.662] - queued futures: [n=2] TRUE, TRUE
[10:29:58.662] signalConditionsASAP(NULL, pos=0) ... done
[10:29:58.662] resolve() on list ... DONE
[10:29:58.662] result() for ClusterFuture ...
[10:29:58.662] - result already collected: FutureResult
[10:29:58.662] result() for ClusterFuture ... done
[10:29:58.662] result() for ClusterFuture ...
[10:29:58.662] - result already collected: FutureResult
[10:29:58.662] result() for ClusterFuture ... done
[10:29:58.662] result() for ClusterFuture ...
[10:29:58.662] - result already collected: FutureResult
[10:29:58.663] result() for ClusterFuture ... done
[10:29:58.663] result() for ClusterFuture ...
[10:29:58.663] - result already collected: FutureResult
[10:29:58.663] result() for ClusterFuture ... done
[10:29:58.663]  - Number of value chunks collected: 2
[10:29:58.663] Resolving 2 futures (chunks) ... DONE
[10:29:58.663] Reducing values from 2 chunks ...
[10:29:58.663]  - Number of values collected after concatenation: 3
[10:29:58.663]  - Number of values expected: 3
[10:29:58.663] Reducing values from 2 chunks ... DONE
[10:29:58.663] future_lapply() ... DONE
[10:29:58.664] future_lapply() ...
[10:29:58.668] Number of chunks: 2
[10:29:58.669] getGlobalsAndPackagesXApply() ...
[10:29:58.669]  - future.globals: TRUE
[10:29:58.669] getGlobalsAndPackages() ...
[10:29:58.669] Searching for globals...
[10:29:58.670] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:58.670] Searching for globals ... DONE
[10:29:58.670] Resolving globals: FALSE
[10:29:58.671] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[10:29:58.671] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[10:29:58.671] - globals: [1] ‘FUN’
[10:29:58.671] - packages: [1] ‘stats’
[10:29:58.671] getGlobalsAndPackages() ... DONE
[10:29:58.671]  - globals found/used: [n=1] ‘FUN’
[10:29:58.671]  - needed namespaces: [n=1] ‘stats’
[10:29:58.672] Finding globals ... DONE
[10:29:58.672]  - use_args: TRUE
[10:29:58.672]  - Getting '...' globals ...
[10:29:58.672] resolve() on list ...
[10:29:58.672]  recursive: 0
[10:29:58.672]  length: 1
[10:29:58.672]  elements: ‘...’
[10:29:58.672]  length: 0 (resolved future 1)
[10:29:58.673] resolve() on list ... DONE
[10:29:58.673]    - '...' content: [n=0] 
[10:29:58.673] List of 1
[10:29:58.673]  $ ...: list()
[10:29:58.673]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:58.673]  - attr(*, "where")=List of 1
[10:29:58.673]   ..$ ...:<environment: 0x55974d492ab8> 
[10:29:58.673]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:58.673]  - attr(*, "resolved")= logi TRUE
[10:29:58.673]  - attr(*, "total_size")= num NA
[10:29:58.677]  - Getting '...' globals ... DONE
[10:29:58.677] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:58.677] List of 2
[10:29:58.677]  $ ...future.FUN:function (x, ...)  
[10:29:58.677]  $ ...          : list()
[10:29:58.677]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:58.677]  - attr(*, "where")=List of 2
[10:29:58.677]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:58.677]   ..$ ...          :<environment: 0x55974d492ab8> 
[10:29:58.677]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:58.677]  - attr(*, "resolved")= logi FALSE
[10:29:58.677]  - attr(*, "total_size")= num 1248
[10:29:58.680] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:58.680] getGlobalsAndPackagesXApply() ... DONE
[10:29:58.680] Number of futures (= number of chunks): 2
[10:29:58.680] Launching 2 futures (chunks) ...
[10:29:58.680] Chunk #1 of 2 ...
[10:29:58.681]  - Finding globals in 'X' for chunk #1 ...
[10:29:58.681] getGlobalsAndPackages() ...
[10:29:58.681] Searching for globals...
[10:29:58.681] 
[10:29:58.681] Searching for globals ... DONE
[10:29:58.681] - globals: [0] <none>
[10:29:58.681] getGlobalsAndPackages() ... DONE
[10:29:58.681]    + additional globals found: [n=0] 
[10:29:58.681]    + additional namespaces needed: [n=0] 
[10:29:58.682]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:58.682]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:58.682]  - seeds: <none>
[10:29:58.682]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:58.682] getGlobalsAndPackages() ...
[10:29:58.682] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:58.682] Resolving globals: FALSE
[10:29:58.682] Tweak future expression to call with '...' arguments ...
[10:29:58.682] {
[10:29:58.682]     do.call(function(...) {
[10:29:58.682]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:58.682]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:58.682]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:58.682]             on.exit(options(oopts), add = TRUE)
[10:29:58.682]         }
[10:29:58.682]         {
[10:29:58.682]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:58.682]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:58.682]                 ...future.FUN(...future.X_jj, ...)
[10:29:58.682]             })
[10:29:58.682]         }
[10:29:58.682]     }, args = future.call.arguments)
[10:29:58.682] }
[10:29:58.683] Tweak future expression to call with '...' arguments ... DONE
[10:29:58.683] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:58.683] - packages: [1] ‘stats’
[10:29:58.683] getGlobalsAndPackages() ... DONE
[10:29:58.683] run() for ‘Future’ ...
[10:29:58.684] - state: ‘created’
[10:29:58.684] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:58.697] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:58.697] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:58.697]   - Field: ‘node’
[10:29:58.697]   - Field: ‘label’
[10:29:58.697]   - Field: ‘local’
[10:29:58.697]   - Field: ‘owner’
[10:29:58.698]   - Field: ‘envir’
[10:29:58.698]   - Field: ‘workers’
[10:29:58.698]   - Field: ‘packages’
[10:29:58.698]   - Field: ‘gc’
[10:29:58.698]   - Field: ‘conditions’
[10:29:58.698]   - Field: ‘persistent’
[10:29:58.698]   - Field: ‘expr’
[10:29:58.698]   - Field: ‘uuid’
[10:29:58.698]   - Field: ‘seed’
[10:29:58.698]   - Field: ‘version’
[10:29:58.698]   - Field: ‘result’
[10:29:58.699]   - Field: ‘asynchronous’
[10:29:58.699]   - Field: ‘calls’
[10:29:58.699]   - Field: ‘globals’
[10:29:58.699]   - Field: ‘stdout’
[10:29:58.699]   - Field: ‘earlySignal’
[10:29:58.699]   - Field: ‘lazy’
[10:29:58.699]   - Field: ‘state’
[10:29:58.699] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:58.699] - Launch lazy future ...
[10:29:58.700] Packages needed by the future expression (n = 1): ‘stats’
[10:29:58.700] Packages needed by future strategies (n = 0): <none>
[10:29:58.700] {
[10:29:58.700]     {
[10:29:58.700]         {
[10:29:58.700]             ...future.startTime <- base::Sys.time()
[10:29:58.700]             {
[10:29:58.700]                 {
[10:29:58.700]                   {
[10:29:58.700]                     {
[10:29:58.700]                       {
[10:29:58.700]                         base::local({
[10:29:58.700]                           has_future <- base::requireNamespace("future", 
[10:29:58.700]                             quietly = TRUE)
[10:29:58.700]                           if (has_future) {
[10:29:58.700]                             ns <- base::getNamespace("future")
[10:29:58.700]                             version <- ns[[".package"]][["version"]]
[10:29:58.700]                             if (is.null(version)) 
[10:29:58.700]                               version <- utils::packageVersion("future")
[10:29:58.700]                           }
[10:29:58.700]                           else {
[10:29:58.700]                             version <- NULL
[10:29:58.700]                           }
[10:29:58.700]                           if (!has_future || version < "1.8.0") {
[10:29:58.700]                             info <- base::c(r_version = base::gsub("R version ", 
[10:29:58.700]                               "", base::R.version$version.string), 
[10:29:58.700]                               platform = base::sprintf("%s (%s-bit)", 
[10:29:58.700]                                 base::R.version$platform, 8 * 
[10:29:58.700]                                   base::.Machine$sizeof.pointer), 
[10:29:58.700]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:58.700]                                 "release", "version")], collapse = " "), 
[10:29:58.700]                               hostname = base::Sys.info()[["nodename"]])
[10:29:58.700]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:29:58.700]                               info)
[10:29:58.700]                             info <- base::paste(info, collapse = "; ")
[10:29:58.700]                             if (!has_future) {
[10:29:58.700]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:58.700]                                 info)
[10:29:58.700]                             }
[10:29:58.700]                             else {
[10:29:58.700]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:58.700]                                 info, version)
[10:29:58.700]                             }
[10:29:58.700]                             base::stop(msg)
[10:29:58.700]                           }
[10:29:58.700]                         })
[10:29:58.700]                       }
[10:29:58.700]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:58.700]                       base::options(mc.cores = 1L)
[10:29:58.700]                     }
[10:29:58.700]                     base::local({
[10:29:58.700]                       for (pkg in "stats") {
[10:29:58.700]                         base::loadNamespace(pkg)
[10:29:58.700]                         base::library(pkg, character.only = TRUE)
[10:29:58.700]                       }
[10:29:58.700]                     })
[10:29:58.700]                   }
[10:29:58.700]                   ...future.strategy.old <- future::plan("list")
[10:29:58.700]                   options(future.plan = NULL)
[10:29:58.700]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:58.700]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:58.700]                 }
[10:29:58.700]                 ...future.workdir <- getwd()
[10:29:58.700]             }
[10:29:58.700]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:58.700]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:58.700]         }
[10:29:58.700]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:58.700]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:58.700]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:58.700]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:58.700]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:58.700]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:58.700]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:58.700]             base::names(...future.oldOptions))
[10:29:58.700]     }
[10:29:58.700]     if (FALSE) {
[10:29:58.700]     }
[10:29:58.700]     else {
[10:29:58.700]         if (TRUE) {
[10:29:58.700]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:58.700]                 open = "w")
[10:29:58.700]         }
[10:29:58.700]         else {
[10:29:58.700]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:58.700]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:58.700]         }
[10:29:58.700]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:58.700]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:58.700]             base::sink(type = "output", split = FALSE)
[10:29:58.700]             base::close(...future.stdout)
[10:29:58.700]         }, add = TRUE)
[10:29:58.700]     }
[10:29:58.700]     ...future.frame <- base::sys.nframe()
[10:29:58.700]     ...future.conditions <- base::list()
[10:29:58.700]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:58.700]     if (FALSE) {
[10:29:58.700]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:58.700]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:58.700]     }
[10:29:58.700]     ...future.result <- base::tryCatch({
[10:29:58.700]         base::withCallingHandlers({
[10:29:58.700]             ...future.value <- base::withVisible(base::local({
[10:29:58.700]                 ...future.makeSendCondition <- base::local({
[10:29:58.700]                   sendCondition <- NULL
[10:29:58.700]                   function(frame = 1L) {
[10:29:58.700]                     if (is.function(sendCondition)) 
[10:29:58.700]                       return(sendCondition)
[10:29:58.700]                     ns <- getNamespace("parallel")
[10:29:58.700]                     if (exists("sendData", mode = "function", 
[10:29:58.700]                       envir = ns)) {
[10:29:58.700]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:58.700]                         envir = ns)
[10:29:58.700]                       envir <- sys.frame(frame)
[10:29:58.700]                       master <- NULL
[10:29:58.700]                       while (!identical(envir, .GlobalEnv) && 
[10:29:58.700]                         !identical(envir, emptyenv())) {
[10:29:58.700]                         if (exists("master", mode = "list", envir = envir, 
[10:29:58.700]                           inherits = FALSE)) {
[10:29:58.700]                           master <- get("master", mode = "list", 
[10:29:58.700]                             envir = envir, inherits = FALSE)
[10:29:58.700]                           if (inherits(master, c("SOCKnode", 
[10:29:58.700]                             "SOCK0node"))) {
[10:29:58.700]                             sendCondition <<- function(cond) {
[10:29:58.700]                               data <- list(type = "VALUE", value = cond, 
[10:29:58.700]                                 success = TRUE)
[10:29:58.700]                               parallel_sendData(master, data)
[10:29:58.700]                             }
[10:29:58.700]                             return(sendCondition)
[10:29:58.700]                           }
[10:29:58.700]                         }
[10:29:58.700]                         frame <- frame + 1L
[10:29:58.700]                         envir <- sys.frame(frame)
[10:29:58.700]                       }
[10:29:58.700]                     }
[10:29:58.700]                     sendCondition <<- function(cond) NULL
[10:29:58.700]                   }
[10:29:58.700]                 })
[10:29:58.700]                 withCallingHandlers({
[10:29:58.700]                   {
[10:29:58.700]                     do.call(function(...) {
[10:29:58.700]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:58.700]                       if (!identical(...future.globals.maxSize.org, 
[10:29:58.700]                         ...future.globals.maxSize)) {
[10:29:58.700]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:58.700]                         on.exit(options(oopts), add = TRUE)
[10:29:58.700]                       }
[10:29:58.700]                       {
[10:29:58.700]                         lapply(seq_along(...future.elements_ii), 
[10:29:58.700]                           FUN = function(jj) {
[10:29:58.700]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:58.700]                             ...future.FUN(...future.X_jj, ...)
[10:29:58.700]                           })
[10:29:58.700]                       }
[10:29:58.700]                     }, args = future.call.arguments)
[10:29:58.700]                   }
[10:29:58.700]                 }, immediateCondition = function(cond) {
[10:29:58.700]                   sendCondition <- ...future.makeSendCondition()
[10:29:58.700]                   sendCondition(cond)
[10:29:58.700]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.700]                   {
[10:29:58.700]                     inherits <- base::inherits
[10:29:58.700]                     invokeRestart <- base::invokeRestart
[10:29:58.700]                     is.null <- base::is.null
[10:29:58.700]                     muffled <- FALSE
[10:29:58.700]                     if (inherits(cond, "message")) {
[10:29:58.700]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:58.700]                       if (muffled) 
[10:29:58.700]                         invokeRestart("muffleMessage")
[10:29:58.700]                     }
[10:29:58.700]                     else if (inherits(cond, "warning")) {
[10:29:58.700]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:58.700]                       if (muffled) 
[10:29:58.700]                         invokeRestart("muffleWarning")
[10:29:58.700]                     }
[10:29:58.700]                     else if (inherits(cond, "condition")) {
[10:29:58.700]                       if (!is.null(pattern)) {
[10:29:58.700]                         computeRestarts <- base::computeRestarts
[10:29:58.700]                         grepl <- base::grepl
[10:29:58.700]                         restarts <- computeRestarts(cond)
[10:29:58.700]                         for (restart in restarts) {
[10:29:58.700]                           name <- restart$name
[10:29:58.700]                           if (is.null(name)) 
[10:29:58.700]                             next
[10:29:58.700]                           if (!grepl(pattern, name)) 
[10:29:58.700]                             next
[10:29:58.700]                           invokeRestart(restart)
[10:29:58.700]                           muffled <- TRUE
[10:29:58.700]                           break
[10:29:58.700]                         }
[10:29:58.700]                       }
[10:29:58.700]                     }
[10:29:58.700]                     invisible(muffled)
[10:29:58.700]                   }
[10:29:58.700]                   muffleCondition(cond)
[10:29:58.700]                 })
[10:29:58.700]             }))
[10:29:58.700]             future::FutureResult(value = ...future.value$value, 
[10:29:58.700]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:58.700]                   ...future.rng), globalenv = if (FALSE) 
[10:29:58.700]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:58.700]                     ...future.globalenv.names))
[10:29:58.700]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:58.700]         }, condition = base::local({
[10:29:58.700]             c <- base::c
[10:29:58.700]             inherits <- base::inherits
[10:29:58.700]             invokeRestart <- base::invokeRestart
[10:29:58.700]             length <- base::length
[10:29:58.700]             list <- base::list
[10:29:58.700]             seq.int <- base::seq.int
[10:29:58.700]             signalCondition <- base::signalCondition
[10:29:58.700]             sys.calls <- base::sys.calls
[10:29:58.700]             `[[` <- base::`[[`
[10:29:58.700]             `+` <- base::`+`
[10:29:58.700]             `<<-` <- base::`<<-`
[10:29:58.700]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:58.700]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:58.700]                   3L)]
[10:29:58.700]             }
[10:29:58.700]             function(cond) {
[10:29:58.700]                 is_error <- inherits(cond, "error")
[10:29:58.700]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:58.700]                   NULL)
[10:29:58.700]                 if (is_error) {
[10:29:58.700]                   sessionInformation <- function() {
[10:29:58.700]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:58.700]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:58.700]                       search = base::search(), system = base::Sys.info())
[10:29:58.700]                   }
[10:29:58.700]                   ...future.conditions[[length(...future.conditions) + 
[10:29:58.700]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:58.700]                     cond$call), session = sessionInformation(), 
[10:29:58.700]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:58.700]                   signalCondition(cond)
[10:29:58.700]                 }
[10:29:58.700]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:58.700]                 "immediateCondition"))) {
[10:29:58.700]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:58.700]                   ...future.conditions[[length(...future.conditions) + 
[10:29:58.700]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:58.700]                   if (TRUE && !signal) {
[10:29:58.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.700]                     {
[10:29:58.700]                       inherits <- base::inherits
[10:29:58.700]                       invokeRestart <- base::invokeRestart
[10:29:58.700]                       is.null <- base::is.null
[10:29:58.700]                       muffled <- FALSE
[10:29:58.700]                       if (inherits(cond, "message")) {
[10:29:58.700]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:58.700]                         if (muffled) 
[10:29:58.700]                           invokeRestart("muffleMessage")
[10:29:58.700]                       }
[10:29:58.700]                       else if (inherits(cond, "warning")) {
[10:29:58.700]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:58.700]                         if (muffled) 
[10:29:58.700]                           invokeRestart("muffleWarning")
[10:29:58.700]                       }
[10:29:58.700]                       else if (inherits(cond, "condition")) {
[10:29:58.700]                         if (!is.null(pattern)) {
[10:29:58.700]                           computeRestarts <- base::computeRestarts
[10:29:58.700]                           grepl <- base::grepl
[10:29:58.700]                           restarts <- computeRestarts(cond)
[10:29:58.700]                           for (restart in restarts) {
[10:29:58.700]                             name <- restart$name
[10:29:58.700]                             if (is.null(name)) 
[10:29:58.700]                               next
[10:29:58.700]                             if (!grepl(pattern, name)) 
[10:29:58.700]                               next
[10:29:58.700]                             invokeRestart(restart)
[10:29:58.700]                             muffled <- TRUE
[10:29:58.700]                             break
[10:29:58.700]                           }
[10:29:58.700]                         }
[10:29:58.700]                       }
[10:29:58.700]                       invisible(muffled)
[10:29:58.700]                     }
[10:29:58.700]                     muffleCondition(cond, pattern = "^muffle")
[10:29:58.700]                   }
[10:29:58.700]                 }
[10:29:58.700]                 else {
[10:29:58.700]                   if (TRUE) {
[10:29:58.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.700]                     {
[10:29:58.700]                       inherits <- base::inherits
[10:29:58.700]                       invokeRestart <- base::invokeRestart
[10:29:58.700]                       is.null <- base::is.null
[10:29:58.700]                       muffled <- FALSE
[10:29:58.700]                       if (inherits(cond, "message")) {
[10:29:58.700]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:58.700]                         if (muffled) 
[10:29:58.700]                           invokeRestart("muffleMessage")
[10:29:58.700]                       }
[10:29:58.700]                       else if (inherits(cond, "warning")) {
[10:29:58.700]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:58.700]                         if (muffled) 
[10:29:58.700]                           invokeRestart("muffleWarning")
[10:29:58.700]                       }
[10:29:58.700]                       else if (inherits(cond, "condition")) {
[10:29:58.700]                         if (!is.null(pattern)) {
[10:29:58.700]                           computeRestarts <- base::computeRestarts
[10:29:58.700]                           grepl <- base::grepl
[10:29:58.700]                           restarts <- computeRestarts(cond)
[10:29:58.700]                           for (restart in restarts) {
[10:29:58.700]                             name <- restart$name
[10:29:58.700]                             if (is.null(name)) 
[10:29:58.700]                               next
[10:29:58.700]                             if (!grepl(pattern, name)) 
[10:29:58.700]                               next
[10:29:58.700]                             invokeRestart(restart)
[10:29:58.700]                             muffled <- TRUE
[10:29:58.700]                             break
[10:29:58.700]                           }
[10:29:58.700]                         }
[10:29:58.700]                       }
[10:29:58.700]                       invisible(muffled)
[10:29:58.700]                     }
[10:29:58.700]                     muffleCondition(cond, pattern = "^muffle")
[10:29:58.700]                   }
[10:29:58.700]                 }
[10:29:58.700]             }
[10:29:58.700]         }))
[10:29:58.700]     }, error = function(ex) {
[10:29:58.700]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:58.700]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:58.700]                 ...future.rng), started = ...future.startTime, 
[10:29:58.700]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:58.700]             version = "1.8"), class = "FutureResult")
[10:29:58.700]     }, finally = {
[10:29:58.700]         if (!identical(...future.workdir, getwd())) 
[10:29:58.700]             setwd(...future.workdir)
[10:29:58.700]         {
[10:29:58.700]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:58.700]                 ...future.oldOptions$nwarnings <- NULL
[10:29:58.700]             }
[10:29:58.700]             base::options(...future.oldOptions)
[10:29:58.700]             if (.Platform$OS.type == "windows") {
[10:29:58.700]                 old_names <- names(...future.oldEnvVars)
[10:29:58.700]                 envs <- base::Sys.getenv()
[10:29:58.700]                 names <- names(envs)
[10:29:58.700]                 common <- intersect(names, old_names)
[10:29:58.700]                 added <- setdiff(names, old_names)
[10:29:58.700]                 removed <- setdiff(old_names, names)
[10:29:58.700]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:58.700]                   envs[common]]
[10:29:58.700]                 NAMES <- toupper(changed)
[10:29:58.700]                 args <- list()
[10:29:58.700]                 for (kk in seq_along(NAMES)) {
[10:29:58.700]                   name <- changed[[kk]]
[10:29:58.700]                   NAME <- NAMES[[kk]]
[10:29:58.700]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.700]                     next
[10:29:58.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:58.700]                 }
[10:29:58.700]                 NAMES <- toupper(added)
[10:29:58.700]                 for (kk in seq_along(NAMES)) {
[10:29:58.700]                   name <- added[[kk]]
[10:29:58.700]                   NAME <- NAMES[[kk]]
[10:29:58.700]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.700]                     next
[10:29:58.700]                   args[[name]] <- ""
[10:29:58.700]                 }
[10:29:58.700]                 NAMES <- toupper(removed)
[10:29:58.700]                 for (kk in seq_along(NAMES)) {
[10:29:58.700]                   name <- removed[[kk]]
[10:29:58.700]                   NAME <- NAMES[[kk]]
[10:29:58.700]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.700]                     next
[10:29:58.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:58.700]                 }
[10:29:58.700]                 if (length(args) > 0) 
[10:29:58.700]                   base::do.call(base::Sys.setenv, args = args)
[10:29:58.700]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:58.700]             }
[10:29:58.700]             else {
[10:29:58.700]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:58.700]             }
[10:29:58.700]             {
[10:29:58.700]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:58.700]                   0L) {
[10:29:58.700]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:58.700]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:58.700]                   base::options(opts)
[10:29:58.700]                 }
[10:29:58.700]                 {
[10:29:58.700]                   {
[10:29:58.700]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:58.700]                     NULL
[10:29:58.700]                   }
[10:29:58.700]                   options(future.plan = NULL)
[10:29:58.700]                   if (is.na(NA_character_)) 
[10:29:58.700]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:58.700]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:58.700]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:58.700]                     .init = FALSE)
[10:29:58.700]                 }
[10:29:58.700]             }
[10:29:58.700]         }
[10:29:58.700]     })
[10:29:58.700]     if (TRUE) {
[10:29:58.700]         base::sink(type = "output", split = FALSE)
[10:29:58.700]         if (TRUE) {
[10:29:58.700]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:58.700]         }
[10:29:58.700]         else {
[10:29:58.700]             ...future.result["stdout"] <- base::list(NULL)
[10:29:58.700]         }
[10:29:58.700]         base::close(...future.stdout)
[10:29:58.700]         ...future.stdout <- NULL
[10:29:58.700]     }
[10:29:58.700]     ...future.result$conditions <- ...future.conditions
[10:29:58.700]     ...future.result$finished <- base::Sys.time()
[10:29:58.700]     ...future.result
[10:29:58.700] }
[10:29:58.703] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[10:29:58.703] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[10:29:58.703] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[10:29:58.704] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:29:58.704] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:29:58.704] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[10:29:58.704] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[10:29:58.705] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:29:58.705] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:29:58.705] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:29:58.705] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:29:58.705] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[10:29:58.706] MultisessionFuture started
[10:29:58.706] - Launch lazy future ... done
[10:29:58.706] run() for ‘MultisessionFuture’ ... done
[10:29:58.706] Created future:
[10:29:58.706] MultisessionFuture:
[10:29:58.706] Label: ‘future_eapply-1’
[10:29:58.706] Expression:
[10:29:58.706] {
[10:29:58.706]     do.call(function(...) {
[10:29:58.706]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:58.706]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:58.706]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:58.706]             on.exit(options(oopts), add = TRUE)
[10:29:58.706]         }
[10:29:58.706]         {
[10:29:58.706]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:58.706]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:58.706]                 ...future.FUN(...future.X_jj, ...)
[10:29:58.706]             })
[10:29:58.706]         }
[10:29:58.706]     }, args = future.call.arguments)
[10:29:58.706] }
[10:29:58.706] Lazy evaluation: FALSE
[10:29:58.706] Asynchronous evaluation: TRUE
[10:29:58.706] Local evaluation: TRUE
[10:29:58.706] Environment: R_GlobalEnv
[10:29:58.706] Capture standard output: TRUE
[10:29:58.706] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:58.706] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:58.706] Packages: 1 packages (‘stats’)
[10:29:58.706] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:58.706] Resolved: FALSE
[10:29:58.706] Value: <not collected>
[10:29:58.706] Conditions captured: <none>
[10:29:58.706] Early signaling: FALSE
[10:29:58.706] Owner process: db6eb61b-64f1-ae95-7e8b-287fbc43411a
[10:29:58.706] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:58.718] Chunk #1 of 2 ... DONE
[10:29:58.718] Chunk #2 of 2 ...
[10:29:58.718]  - Finding globals in 'X' for chunk #2 ...
[10:29:58.718] getGlobalsAndPackages() ...
[10:29:58.718] Searching for globals...
[10:29:58.718] 
[10:29:58.719] Searching for globals ... DONE
[10:29:58.719] - globals: [0] <none>
[10:29:58.719] getGlobalsAndPackages() ... DONE
[10:29:58.719]    + additional globals found: [n=0] 
[10:29:58.719]    + additional namespaces needed: [n=0] 
[10:29:58.719]  - Finding globals in 'X' for chunk #2 ... DONE
[10:29:58.719]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:58.719]  - seeds: <none>
[10:29:58.719]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:58.719] getGlobalsAndPackages() ...
[10:29:58.719] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:58.720] Resolving globals: FALSE
[10:29:58.720] Tweak future expression to call with '...' arguments ...
[10:29:58.720] {
[10:29:58.720]     do.call(function(...) {
[10:29:58.720]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:58.720]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:58.720]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:58.720]             on.exit(options(oopts), add = TRUE)
[10:29:58.720]         }
[10:29:58.720]         {
[10:29:58.720]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:58.720]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:58.720]                 ...future.FUN(...future.X_jj, ...)
[10:29:58.720]             })
[10:29:58.720]         }
[10:29:58.720]     }, args = future.call.arguments)
[10:29:58.720] }
[10:29:58.720] Tweak future expression to call with '...' arguments ... DONE
[10:29:58.720] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:58.721] - packages: [1] ‘stats’
[10:29:58.721] getGlobalsAndPackages() ... DONE
[10:29:58.721] run() for ‘Future’ ...
[10:29:58.721] - state: ‘created’
[10:29:58.721] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:58.736] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:58.736] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:58.736]   - Field: ‘node’
[10:29:58.736]   - Field: ‘label’
[10:29:58.736]   - Field: ‘local’
[10:29:58.736]   - Field: ‘owner’
[10:29:58.736]   - Field: ‘envir’
[10:29:58.736]   - Field: ‘workers’
[10:29:58.736]   - Field: ‘packages’
[10:29:58.737]   - Field: ‘gc’
[10:29:58.737]   - Field: ‘conditions’
[10:29:58.737]   - Field: ‘persistent’
[10:29:58.737]   - Field: ‘expr’
[10:29:58.737]   - Field: ‘uuid’
[10:29:58.737]   - Field: ‘seed’
[10:29:58.737]   - Field: ‘version’
[10:29:58.737]   - Field: ‘result’
[10:29:58.737]   - Field: ‘asynchronous’
[10:29:58.737]   - Field: ‘calls’
[10:29:58.738]   - Field: ‘globals’
[10:29:58.738]   - Field: ‘stdout’
[10:29:58.738]   - Field: ‘earlySignal’
[10:29:58.738]   - Field: ‘lazy’
[10:29:58.738]   - Field: ‘state’
[10:29:58.738] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:58.738] - Launch lazy future ...
[10:29:58.738] Packages needed by the future expression (n = 1): ‘stats’
[10:29:58.739] Packages needed by future strategies (n = 0): <none>
[10:29:58.739] {
[10:29:58.739]     {
[10:29:58.739]         {
[10:29:58.739]             ...future.startTime <- base::Sys.time()
[10:29:58.739]             {
[10:29:58.739]                 {
[10:29:58.739]                   {
[10:29:58.739]                     {
[10:29:58.739]                       {
[10:29:58.739]                         base::local({
[10:29:58.739]                           has_future <- base::requireNamespace("future", 
[10:29:58.739]                             quietly = TRUE)
[10:29:58.739]                           if (has_future) {
[10:29:58.739]                             ns <- base::getNamespace("future")
[10:29:58.739]                             version <- ns[[".package"]][["version"]]
[10:29:58.739]                             if (is.null(version)) 
[10:29:58.739]                               version <- utils::packageVersion("future")
[10:29:58.739]                           }
[10:29:58.739]                           else {
[10:29:58.739]                             version <- NULL
[10:29:58.739]                           }
[10:29:58.739]                           if (!has_future || version < "1.8.0") {
[10:29:58.739]                             info <- base::c(r_version = base::gsub("R version ", 
[10:29:58.739]                               "", base::R.version$version.string), 
[10:29:58.739]                               platform = base::sprintf("%s (%s-bit)", 
[10:29:58.739]                                 base::R.version$platform, 8 * 
[10:29:58.739]                                   base::.Machine$sizeof.pointer), 
[10:29:58.739]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:58.739]                                 "release", "version")], collapse = " "), 
[10:29:58.739]                               hostname = base::Sys.info()[["nodename"]])
[10:29:58.739]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:29:58.739]                               info)
[10:29:58.739]                             info <- base::paste(info, collapse = "; ")
[10:29:58.739]                             if (!has_future) {
[10:29:58.739]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:58.739]                                 info)
[10:29:58.739]                             }
[10:29:58.739]                             else {
[10:29:58.739]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:58.739]                                 info, version)
[10:29:58.739]                             }
[10:29:58.739]                             base::stop(msg)
[10:29:58.739]                           }
[10:29:58.739]                         })
[10:29:58.739]                       }
[10:29:58.739]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:58.739]                       base::options(mc.cores = 1L)
[10:29:58.739]                     }
[10:29:58.739]                     base::local({
[10:29:58.739]                       for (pkg in "stats") {
[10:29:58.739]                         base::loadNamespace(pkg)
[10:29:58.739]                         base::library(pkg, character.only = TRUE)
[10:29:58.739]                       }
[10:29:58.739]                     })
[10:29:58.739]                   }
[10:29:58.739]                   ...future.strategy.old <- future::plan("list")
[10:29:58.739]                   options(future.plan = NULL)
[10:29:58.739]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:58.739]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:58.739]                 }
[10:29:58.739]                 ...future.workdir <- getwd()
[10:29:58.739]             }
[10:29:58.739]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:58.739]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:58.739]         }
[10:29:58.739]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:58.739]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:58.739]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:58.739]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:58.739]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:58.739]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:58.739]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:58.739]             base::names(...future.oldOptions))
[10:29:58.739]     }
[10:29:58.739]     if (FALSE) {
[10:29:58.739]     }
[10:29:58.739]     else {
[10:29:58.739]         if (TRUE) {
[10:29:58.739]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:58.739]                 open = "w")
[10:29:58.739]         }
[10:29:58.739]         else {
[10:29:58.739]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:58.739]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:58.739]         }
[10:29:58.739]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:58.739]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:58.739]             base::sink(type = "output", split = FALSE)
[10:29:58.739]             base::close(...future.stdout)
[10:29:58.739]         }, add = TRUE)
[10:29:58.739]     }
[10:29:58.739]     ...future.frame <- base::sys.nframe()
[10:29:58.739]     ...future.conditions <- base::list()
[10:29:58.739]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:58.739]     if (FALSE) {
[10:29:58.739]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:58.739]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:58.739]     }
[10:29:58.739]     ...future.result <- base::tryCatch({
[10:29:58.739]         base::withCallingHandlers({
[10:29:58.739]             ...future.value <- base::withVisible(base::local({
[10:29:58.739]                 ...future.makeSendCondition <- base::local({
[10:29:58.739]                   sendCondition <- NULL
[10:29:58.739]                   function(frame = 1L) {
[10:29:58.739]                     if (is.function(sendCondition)) 
[10:29:58.739]                       return(sendCondition)
[10:29:58.739]                     ns <- getNamespace("parallel")
[10:29:58.739]                     if (exists("sendData", mode = "function", 
[10:29:58.739]                       envir = ns)) {
[10:29:58.739]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:58.739]                         envir = ns)
[10:29:58.739]                       envir <- sys.frame(frame)
[10:29:58.739]                       master <- NULL
[10:29:58.739]                       while (!identical(envir, .GlobalEnv) && 
[10:29:58.739]                         !identical(envir, emptyenv())) {
[10:29:58.739]                         if (exists("master", mode = "list", envir = envir, 
[10:29:58.739]                           inherits = FALSE)) {
[10:29:58.739]                           master <- get("master", mode = "list", 
[10:29:58.739]                             envir = envir, inherits = FALSE)
[10:29:58.739]                           if (inherits(master, c("SOCKnode", 
[10:29:58.739]                             "SOCK0node"))) {
[10:29:58.739]                             sendCondition <<- function(cond) {
[10:29:58.739]                               data <- list(type = "VALUE", value = cond, 
[10:29:58.739]                                 success = TRUE)
[10:29:58.739]                               parallel_sendData(master, data)
[10:29:58.739]                             }
[10:29:58.739]                             return(sendCondition)
[10:29:58.739]                           }
[10:29:58.739]                         }
[10:29:58.739]                         frame <- frame + 1L
[10:29:58.739]                         envir <- sys.frame(frame)
[10:29:58.739]                       }
[10:29:58.739]                     }
[10:29:58.739]                     sendCondition <<- function(cond) NULL
[10:29:58.739]                   }
[10:29:58.739]                 })
[10:29:58.739]                 withCallingHandlers({
[10:29:58.739]                   {
[10:29:58.739]                     do.call(function(...) {
[10:29:58.739]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:58.739]                       if (!identical(...future.globals.maxSize.org, 
[10:29:58.739]                         ...future.globals.maxSize)) {
[10:29:58.739]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:58.739]                         on.exit(options(oopts), add = TRUE)
[10:29:58.739]                       }
[10:29:58.739]                       {
[10:29:58.739]                         lapply(seq_along(...future.elements_ii), 
[10:29:58.739]                           FUN = function(jj) {
[10:29:58.739]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:58.739]                             ...future.FUN(...future.X_jj, ...)
[10:29:58.739]                           })
[10:29:58.739]                       }
[10:29:58.739]                     }, args = future.call.arguments)
[10:29:58.739]                   }
[10:29:58.739]                 }, immediateCondition = function(cond) {
[10:29:58.739]                   sendCondition <- ...future.makeSendCondition()
[10:29:58.739]                   sendCondition(cond)
[10:29:58.739]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.739]                   {
[10:29:58.739]                     inherits <- base::inherits
[10:29:58.739]                     invokeRestart <- base::invokeRestart
[10:29:58.739]                     is.null <- base::is.null
[10:29:58.739]                     muffled <- FALSE
[10:29:58.739]                     if (inherits(cond, "message")) {
[10:29:58.739]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:58.739]                       if (muffled) 
[10:29:58.739]                         invokeRestart("muffleMessage")
[10:29:58.739]                     }
[10:29:58.739]                     else if (inherits(cond, "warning")) {
[10:29:58.739]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:58.739]                       if (muffled) 
[10:29:58.739]                         invokeRestart("muffleWarning")
[10:29:58.739]                     }
[10:29:58.739]                     else if (inherits(cond, "condition")) {
[10:29:58.739]                       if (!is.null(pattern)) {
[10:29:58.739]                         computeRestarts <- base::computeRestarts
[10:29:58.739]                         grepl <- base::grepl
[10:29:58.739]                         restarts <- computeRestarts(cond)
[10:29:58.739]                         for (restart in restarts) {
[10:29:58.739]                           name <- restart$name
[10:29:58.739]                           if (is.null(name)) 
[10:29:58.739]                             next
[10:29:58.739]                           if (!grepl(pattern, name)) 
[10:29:58.739]                             next
[10:29:58.739]                           invokeRestart(restart)
[10:29:58.739]                           muffled <- TRUE
[10:29:58.739]                           break
[10:29:58.739]                         }
[10:29:58.739]                       }
[10:29:58.739]                     }
[10:29:58.739]                     invisible(muffled)
[10:29:58.739]                   }
[10:29:58.739]                   muffleCondition(cond)
[10:29:58.739]                 })
[10:29:58.739]             }))
[10:29:58.739]             future::FutureResult(value = ...future.value$value, 
[10:29:58.739]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:58.739]                   ...future.rng), globalenv = if (FALSE) 
[10:29:58.739]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:58.739]                     ...future.globalenv.names))
[10:29:58.739]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:58.739]         }, condition = base::local({
[10:29:58.739]             c <- base::c
[10:29:58.739]             inherits <- base::inherits
[10:29:58.739]             invokeRestart <- base::invokeRestart
[10:29:58.739]             length <- base::length
[10:29:58.739]             list <- base::list
[10:29:58.739]             seq.int <- base::seq.int
[10:29:58.739]             signalCondition <- base::signalCondition
[10:29:58.739]             sys.calls <- base::sys.calls
[10:29:58.739]             `[[` <- base::`[[`
[10:29:58.739]             `+` <- base::`+`
[10:29:58.739]             `<<-` <- base::`<<-`
[10:29:58.739]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:58.739]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:58.739]                   3L)]
[10:29:58.739]             }
[10:29:58.739]             function(cond) {
[10:29:58.739]                 is_error <- inherits(cond, "error")
[10:29:58.739]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:58.739]                   NULL)
[10:29:58.739]                 if (is_error) {
[10:29:58.739]                   sessionInformation <- function() {
[10:29:58.739]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:58.739]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:58.739]                       search = base::search(), system = base::Sys.info())
[10:29:58.739]                   }
[10:29:58.739]                   ...future.conditions[[length(...future.conditions) + 
[10:29:58.739]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:58.739]                     cond$call), session = sessionInformation(), 
[10:29:58.739]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:58.739]                   signalCondition(cond)
[10:29:58.739]                 }
[10:29:58.739]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:58.739]                 "immediateCondition"))) {
[10:29:58.739]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:58.739]                   ...future.conditions[[length(...future.conditions) + 
[10:29:58.739]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:58.739]                   if (TRUE && !signal) {
[10:29:58.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.739]                     {
[10:29:58.739]                       inherits <- base::inherits
[10:29:58.739]                       invokeRestart <- base::invokeRestart
[10:29:58.739]                       is.null <- base::is.null
[10:29:58.739]                       muffled <- FALSE
[10:29:58.739]                       if (inherits(cond, "message")) {
[10:29:58.739]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:58.739]                         if (muffled) 
[10:29:58.739]                           invokeRestart("muffleMessage")
[10:29:58.739]                       }
[10:29:58.739]                       else if (inherits(cond, "warning")) {
[10:29:58.739]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:58.739]                         if (muffled) 
[10:29:58.739]                           invokeRestart("muffleWarning")
[10:29:58.739]                       }
[10:29:58.739]                       else if (inherits(cond, "condition")) {
[10:29:58.739]                         if (!is.null(pattern)) {
[10:29:58.739]                           computeRestarts <- base::computeRestarts
[10:29:58.739]                           grepl <- base::grepl
[10:29:58.739]                           restarts <- computeRestarts(cond)
[10:29:58.739]                           for (restart in restarts) {
[10:29:58.739]                             name <- restart$name
[10:29:58.739]                             if (is.null(name)) 
[10:29:58.739]                               next
[10:29:58.739]                             if (!grepl(pattern, name)) 
[10:29:58.739]                               next
[10:29:58.739]                             invokeRestart(restart)
[10:29:58.739]                             muffled <- TRUE
[10:29:58.739]                             break
[10:29:58.739]                           }
[10:29:58.739]                         }
[10:29:58.739]                       }
[10:29:58.739]                       invisible(muffled)
[10:29:58.739]                     }
[10:29:58.739]                     muffleCondition(cond, pattern = "^muffle")
[10:29:58.739]                   }
[10:29:58.739]                 }
[10:29:58.739]                 else {
[10:29:58.739]                   if (TRUE) {
[10:29:58.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.739]                     {
[10:29:58.739]                       inherits <- base::inherits
[10:29:58.739]                       invokeRestart <- base::invokeRestart
[10:29:58.739]                       is.null <- base::is.null
[10:29:58.739]                       muffled <- FALSE
[10:29:58.739]                       if (inherits(cond, "message")) {
[10:29:58.739]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:58.739]                         if (muffled) 
[10:29:58.739]                           invokeRestart("muffleMessage")
[10:29:58.739]                       }
[10:29:58.739]                       else if (inherits(cond, "warning")) {
[10:29:58.739]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:58.739]                         if (muffled) 
[10:29:58.739]                           invokeRestart("muffleWarning")
[10:29:58.739]                       }
[10:29:58.739]                       else if (inherits(cond, "condition")) {
[10:29:58.739]                         if (!is.null(pattern)) {
[10:29:58.739]                           computeRestarts <- base::computeRestarts
[10:29:58.739]                           grepl <- base::grepl
[10:29:58.739]                           restarts <- computeRestarts(cond)
[10:29:58.739]                           for (restart in restarts) {
[10:29:58.739]                             name <- restart$name
[10:29:58.739]                             if (is.null(name)) 
[10:29:58.739]                               next
[10:29:58.739]                             if (!grepl(pattern, name)) 
[10:29:58.739]                               next
[10:29:58.739]                             invokeRestart(restart)
[10:29:58.739]                             muffled <- TRUE
[10:29:58.739]                             break
[10:29:58.739]                           }
[10:29:58.739]                         }
[10:29:58.739]                       }
[10:29:58.739]                       invisible(muffled)
[10:29:58.739]                     }
[10:29:58.739]                     muffleCondition(cond, pattern = "^muffle")
[10:29:58.739]                   }
[10:29:58.739]                 }
[10:29:58.739]             }
[10:29:58.739]         }))
[10:29:58.739]     }, error = function(ex) {
[10:29:58.739]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:58.739]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:58.739]                 ...future.rng), started = ...future.startTime, 
[10:29:58.739]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:58.739]             version = "1.8"), class = "FutureResult")
[10:29:58.739]     }, finally = {
[10:29:58.739]         if (!identical(...future.workdir, getwd())) 
[10:29:58.739]             setwd(...future.workdir)
[10:29:58.739]         {
[10:29:58.739]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:58.739]                 ...future.oldOptions$nwarnings <- NULL
[10:29:58.739]             }
[10:29:58.739]             base::options(...future.oldOptions)
[10:29:58.739]             if (.Platform$OS.type == "windows") {
[10:29:58.739]                 old_names <- names(...future.oldEnvVars)
[10:29:58.739]                 envs <- base::Sys.getenv()
[10:29:58.739]                 names <- names(envs)
[10:29:58.739]                 common <- intersect(names, old_names)
[10:29:58.739]                 added <- setdiff(names, old_names)
[10:29:58.739]                 removed <- setdiff(old_names, names)
[10:29:58.739]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:58.739]                   envs[common]]
[10:29:58.739]                 NAMES <- toupper(changed)
[10:29:58.739]                 args <- list()
[10:29:58.739]                 for (kk in seq_along(NAMES)) {
[10:29:58.739]                   name <- changed[[kk]]
[10:29:58.739]                   NAME <- NAMES[[kk]]
[10:29:58.739]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.739]                     next
[10:29:58.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:58.739]                 }
[10:29:58.739]                 NAMES <- toupper(added)
[10:29:58.739]                 for (kk in seq_along(NAMES)) {
[10:29:58.739]                   name <- added[[kk]]
[10:29:58.739]                   NAME <- NAMES[[kk]]
[10:29:58.739]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.739]                     next
[10:29:58.739]                   args[[name]] <- ""
[10:29:58.739]                 }
[10:29:58.739]                 NAMES <- toupper(removed)
[10:29:58.739]                 for (kk in seq_along(NAMES)) {
[10:29:58.739]                   name <- removed[[kk]]
[10:29:58.739]                   NAME <- NAMES[[kk]]
[10:29:58.739]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.739]                     next
[10:29:58.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:58.739]                 }
[10:29:58.739]                 if (length(args) > 0) 
[10:29:58.739]                   base::do.call(base::Sys.setenv, args = args)
[10:29:58.739]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:58.739]             }
[10:29:58.739]             else {
[10:29:58.739]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:58.739]             }
[10:29:58.739]             {
[10:29:58.739]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:58.739]                   0L) {
[10:29:58.739]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:58.739]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:58.739]                   base::options(opts)
[10:29:58.739]                 }
[10:29:58.739]                 {
[10:29:58.739]                   {
[10:29:58.739]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:58.739]                     NULL
[10:29:58.739]                   }
[10:29:58.739]                   options(future.plan = NULL)
[10:29:58.739]                   if (is.na(NA_character_)) 
[10:29:58.739]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:58.739]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:58.739]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:58.739]                     .init = FALSE)
[10:29:58.739]                 }
[10:29:58.739]             }
[10:29:58.739]         }
[10:29:58.739]     })
[10:29:58.739]     if (TRUE) {
[10:29:58.739]         base::sink(type = "output", split = FALSE)
[10:29:58.739]         if (TRUE) {
[10:29:58.739]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:58.739]         }
[10:29:58.739]         else {
[10:29:58.739]             ...future.result["stdout"] <- base::list(NULL)
[10:29:58.739]         }
[10:29:58.739]         base::close(...future.stdout)
[10:29:58.739]         ...future.stdout <- NULL
[10:29:58.739]     }
[10:29:58.739]     ...future.result$conditions <- ...future.conditions
[10:29:58.739]     ...future.result$finished <- base::Sys.time()
[10:29:58.739]     ...future.result
[10:29:58.739] }
[10:29:58.742] Exporting 5 global objects (1.22 KiB) to cluster node #2 ...
[10:29:58.742] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[10:29:58.742] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[10:29:58.743] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:29:58.743] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:29:58.743] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[10:29:58.743] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[10:29:58.744] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:29:58.744] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:29:58.744] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:29:58.744] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:29:58.744] Exporting 5 global objects (1.22 KiB) to cluster node #2 ... DONE
[10:29:58.745] MultisessionFuture started
[10:29:58.745] - Launch lazy future ... done
[10:29:58.745] run() for ‘MultisessionFuture’ ... done
[10:29:58.745] Created future:
[10:29:58.745] MultisessionFuture:
[10:29:58.745] Label: ‘future_eapply-2’
[10:29:58.745] Expression:
[10:29:58.745] {
[10:29:58.745]     do.call(function(...) {
[10:29:58.745]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:58.745]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:58.745]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:58.745]             on.exit(options(oopts), add = TRUE)
[10:29:58.745]         }
[10:29:58.745]         {
[10:29:58.745]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:58.745]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:58.745]                 ...future.FUN(...future.X_jj, ...)
[10:29:58.745]             })
[10:29:58.745]         }
[10:29:58.745]     }, args = future.call.arguments)
[10:29:58.745] }
[10:29:58.745] Lazy evaluation: FALSE
[10:29:58.745] Asynchronous evaluation: TRUE
[10:29:58.745] Local evaluation: TRUE
[10:29:58.745] Environment: R_GlobalEnv
[10:29:58.745] Capture standard output: TRUE
[10:29:58.745] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:58.745] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:58.745] Packages: 1 packages (‘stats’)
[10:29:58.745] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:58.745] Resolved: FALSE
[10:29:58.745] Value: <not collected>
[10:29:58.745] Conditions captured: <none>
[10:29:58.745] Early signaling: FALSE
[10:29:58.745] Owner process: db6eb61b-64f1-ae95-7e8b-287fbc43411a
[10:29:58.745] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:58.757] Chunk #2 of 2 ... DONE
[10:29:58.757] Launching 2 futures (chunks) ... DONE
[10:29:58.757] Resolving 2 futures (chunks) ...
[10:29:58.757] resolve() on list ...
[10:29:58.757]  recursive: 0
[10:29:58.757]  length: 2
[10:29:58.758] 
[10:29:58.758] receiveMessageFromWorker() for ClusterFuture ...
[10:29:58.758] - Validating connection of MultisessionFuture
[10:29:58.758] - received message: FutureResult
[10:29:58.758] - Received FutureResult
[10:29:58.759] - Erased future from FutureRegistry
[10:29:58.759] result() for ClusterFuture ...
[10:29:58.759] - result already collected: FutureResult
[10:29:58.759] result() for ClusterFuture ... done
[10:29:58.759] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:58.759] Future #1
[10:29:58.759] result() for ClusterFuture ...
[10:29:58.759] - result already collected: FutureResult
[10:29:58.759] result() for ClusterFuture ... done
[10:29:58.759] result() for ClusterFuture ...
[10:29:58.759] - result already collected: FutureResult
[10:29:58.760] result() for ClusterFuture ... done
[10:29:58.760] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:29:58.760] - nx: 2
[10:29:58.760] - relay: TRUE
[10:29:58.760] - stdout: TRUE
[10:29:58.760] - signal: TRUE
[10:29:58.760] - resignal: FALSE
[10:29:58.760] - force: TRUE
[10:29:58.760] - relayed: [n=2] FALSE, FALSE
[10:29:58.760] - queued futures: [n=2] FALSE, FALSE
[10:29:58.760]  - until=1
[10:29:58.761]  - relaying element #1
[10:29:58.761] result() for ClusterFuture ...
[10:29:58.761] - result already collected: FutureResult
[10:29:58.761] result() for ClusterFuture ... done
[10:29:58.761] result() for ClusterFuture ...
[10:29:58.761] - result already collected: FutureResult
[10:29:58.761] result() for ClusterFuture ... done
[10:29:58.761] result() for ClusterFuture ...
[10:29:58.761] - result already collected: FutureResult
[10:29:58.761] result() for ClusterFuture ... done
[10:29:58.761] result() for ClusterFuture ...
[10:29:58.762] - result already collected: FutureResult
[10:29:58.762] result() for ClusterFuture ... done
[10:29:58.762] - relayed: [n=2] TRUE, FALSE
[10:29:58.762] - queued futures: [n=2] TRUE, FALSE
[10:29:58.762] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:29:58.762]  length: 1 (resolved future 1)
[10:29:58.791] receiveMessageFromWorker() for ClusterFuture ...
[10:29:58.792] - Validating connection of MultisessionFuture
[10:29:58.792] - received message: FutureResult
[10:29:58.792] - Received FutureResult
[10:29:58.792] - Erased future from FutureRegistry
[10:29:58.792] result() for ClusterFuture ...
[10:29:58.792] - result already collected: FutureResult
[10:29:58.792] result() for ClusterFuture ... done
[10:29:58.792] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:58.793] Future #2
[10:29:58.793] result() for ClusterFuture ...
[10:29:58.793] - result already collected: FutureResult
[10:29:58.793] result() for ClusterFuture ... done
[10:29:58.793] result() for ClusterFuture ...
[10:29:58.793] - result already collected: FutureResult
[10:29:58.793] result() for ClusterFuture ... done
[10:29:58.793] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:29:58.793] - nx: 2
[10:29:58.793] - relay: TRUE
[10:29:58.794] - stdout: TRUE
[10:29:58.794] - signal: TRUE
[10:29:58.794] - resignal: FALSE
[10:29:58.794] - force: TRUE
[10:29:58.794] - relayed: [n=2] TRUE, FALSE
[10:29:58.794] - queued futures: [n=2] TRUE, FALSE
[10:29:58.794]  - until=2
[10:29:58.794]  - relaying element #2
[10:29:58.794] result() for ClusterFuture ...
[10:29:58.794] - result already collected: FutureResult
[10:29:58.794] result() for ClusterFuture ... done
[10:29:58.794] result() for ClusterFuture ...
[10:29:58.795] - result already collected: FutureResult
[10:29:58.795] result() for ClusterFuture ... done
[10:29:58.795] result() for ClusterFuture ...
[10:29:58.795] - result already collected: FutureResult
[10:29:58.795] result() for ClusterFuture ... done
[10:29:58.795] result() for ClusterFuture ...
[10:29:58.795] - result already collected: FutureResult
[10:29:58.795] result() for ClusterFuture ... done
[10:29:58.795] - relayed: [n=2] TRUE, TRUE
[10:29:58.795] - queued futures: [n=2] TRUE, TRUE
[10:29:58.795] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:29:58.796]  length: 0 (resolved future 2)
[10:29:58.796] Relaying remaining futures
[10:29:58.796] signalConditionsASAP(NULL, pos=0) ...
[10:29:58.796] - nx: 2
[10:29:58.796] - relay: TRUE
[10:29:58.796] - stdout: TRUE
[10:29:58.796] - signal: TRUE
[10:29:58.796] - resignal: FALSE
[10:29:58.796] - force: TRUE
[10:29:58.796] - relayed: [n=2] TRUE, TRUE
[10:29:58.796] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:58.797] - relayed: [n=2] TRUE, TRUE
[10:29:58.797] - queued futures: [n=2] TRUE, TRUE
[10:29:58.797] signalConditionsASAP(NULL, pos=0) ... done
[10:29:58.797] resolve() on list ... DONE
[10:29:58.797] result() for ClusterFuture ...
[10:29:58.797] - result already collected: FutureResult
[10:29:58.797] result() for ClusterFuture ... done
[10:29:58.797] result() for ClusterFuture ...
[10:29:58.797] - result already collected: FutureResult
[10:29:58.797] result() for ClusterFuture ... done
[10:29:58.798] result() for ClusterFuture ...
[10:29:58.798] - result already collected: FutureResult
[10:29:58.798] result() for ClusterFuture ... done
[10:29:58.798] result() for ClusterFuture ...
[10:29:58.798] - result already collected: FutureResult
[10:29:58.798] result() for ClusterFuture ... done
[10:29:58.798]  - Number of value chunks collected: 2
[10:29:58.798] Resolving 2 futures (chunks) ... DONE
[10:29:58.798] Reducing values from 2 chunks ...
[10:29:58.798]  - Number of values collected after concatenation: 3
[10:29:58.798]  - Number of values expected: 3
[10:29:58.799] Reducing values from 2 chunks ... DONE
[10:29:58.799] future_lapply() ... DONE
[10:29:58.799] future_lapply() ...
[10:29:58.803] Number of chunks: 2
[10:29:58.803] getGlobalsAndPackagesXApply() ...
[10:29:58.804]  - future.globals: TRUE
[10:29:58.804] getGlobalsAndPackages() ...
[10:29:58.804] Searching for globals...
[10:29:58.805] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:29:58.805] Searching for globals ... DONE
[10:29:58.805] Resolving globals: FALSE
[10:29:58.806] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[10:29:58.806] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[10:29:58.806] - globals: [1] ‘FUN’
[10:29:58.806] - packages: [1] ‘stats’
[10:29:58.806] getGlobalsAndPackages() ... DONE
[10:29:58.807]  - globals found/used: [n=1] ‘FUN’
[10:29:58.807]  - needed namespaces: [n=1] ‘stats’
[10:29:58.807] Finding globals ... DONE
[10:29:58.807]  - use_args: TRUE
[10:29:58.807]  - Getting '...' globals ...
[10:29:58.807] resolve() on list ...
[10:29:58.807]  recursive: 0
[10:29:58.807]  length: 1
[10:29:58.807]  elements: ‘...’
[10:29:58.808]  length: 0 (resolved future 1)
[10:29:58.808] resolve() on list ... DONE
[10:29:58.808]    - '...' content: [n=0] 
[10:29:58.808] List of 1
[10:29:58.808]  $ ...: list()
[10:29:58.808]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:58.808]  - attr(*, "where")=List of 1
[10:29:58.808]   ..$ ...:<environment: 0x55974c80fac8> 
[10:29:58.808]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:58.808]  - attr(*, "resolved")= logi TRUE
[10:29:58.808]  - attr(*, "total_size")= num NA
[10:29:58.811]  - Getting '...' globals ... DONE
[10:29:58.811] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:29:58.811] List of 2
[10:29:58.811]  $ ...future.FUN:function (x, ...)  
[10:29:58.811]  $ ...          : list()
[10:29:58.811]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:29:58.811]  - attr(*, "where")=List of 2
[10:29:58.811]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:29:58.811]   ..$ ...          :<environment: 0x55974c80fac8> 
[10:29:58.811]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:29:58.811]  - attr(*, "resolved")= logi FALSE
[10:29:58.811]  - attr(*, "total_size")= num 1248
[10:29:58.813] Packages to be attached in all futures: [n=1] ‘stats’
[10:29:58.814] getGlobalsAndPackagesXApply() ... DONE
[10:29:58.814] Number of futures (= number of chunks): 2
[10:29:58.814] Launching 2 futures (chunks) ...
[10:29:58.814] Chunk #1 of 2 ...
[10:29:58.814]  - Finding globals in 'X' for chunk #1 ...
[10:29:58.814] getGlobalsAndPackages() ...
[10:29:58.814] Searching for globals...
[10:29:58.815] 
[10:29:58.815] Searching for globals ... DONE
[10:29:58.815] - globals: [0] <none>
[10:29:58.815] getGlobalsAndPackages() ... DONE
[10:29:58.815]    + additional globals found: [n=0] 
[10:29:58.815]    + additional namespaces needed: [n=0] 
[10:29:58.815]  - Finding globals in 'X' for chunk #1 ... DONE
[10:29:58.815]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:58.815]  - seeds: <none>
[10:29:58.815]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:58.815] getGlobalsAndPackages() ...
[10:29:58.816] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:58.816] Resolving globals: FALSE
[10:29:58.816] Tweak future expression to call with '...' arguments ...
[10:29:58.816] {
[10:29:58.816]     do.call(function(...) {
[10:29:58.816]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:58.816]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:58.816]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:58.816]             on.exit(options(oopts), add = TRUE)
[10:29:58.816]         }
[10:29:58.816]         {
[10:29:58.816]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:58.816]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:58.816]                 ...future.FUN(...future.X_jj, ...)
[10:29:58.816]             })
[10:29:58.816]         }
[10:29:58.816]     }, args = future.call.arguments)
[10:29:58.816] }
[10:29:58.816] Tweak future expression to call with '...' arguments ... DONE
[10:29:58.817] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:58.817] - packages: [1] ‘stats’
[10:29:58.817] getGlobalsAndPackages() ... DONE
[10:29:58.817] run() for ‘Future’ ...
[10:29:58.817] - state: ‘created’
[10:29:58.817] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:58.831] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:58.831] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:58.831]   - Field: ‘node’
[10:29:58.831]   - Field: ‘label’
[10:29:58.831]   - Field: ‘local’
[10:29:58.831]   - Field: ‘owner’
[10:29:58.832]   - Field: ‘envir’
[10:29:58.832]   - Field: ‘workers’
[10:29:58.832]   - Field: ‘packages’
[10:29:58.832]   - Field: ‘gc’
[10:29:58.832]   - Field: ‘conditions’
[10:29:58.832]   - Field: ‘persistent’
[10:29:58.832]   - Field: ‘expr’
[10:29:58.832]   - Field: ‘uuid’
[10:29:58.832]   - Field: ‘seed’
[10:29:58.832]   - Field: ‘version’
[10:29:58.832]   - Field: ‘result’
[10:29:58.833]   - Field: ‘asynchronous’
[10:29:58.833]   - Field: ‘calls’
[10:29:58.833]   - Field: ‘globals’
[10:29:58.833]   - Field: ‘stdout’
[10:29:58.833]   - Field: ‘earlySignal’
[10:29:58.833]   - Field: ‘lazy’
[10:29:58.833]   - Field: ‘state’
[10:29:58.833] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:58.833] - Launch lazy future ...
[10:29:58.834] Packages needed by the future expression (n = 1): ‘stats’
[10:29:58.834] Packages needed by future strategies (n = 0): <none>
[10:29:58.834] {
[10:29:58.834]     {
[10:29:58.834]         {
[10:29:58.834]             ...future.startTime <- base::Sys.time()
[10:29:58.834]             {
[10:29:58.834]                 {
[10:29:58.834]                   {
[10:29:58.834]                     {
[10:29:58.834]                       {
[10:29:58.834]                         base::local({
[10:29:58.834]                           has_future <- base::requireNamespace("future", 
[10:29:58.834]                             quietly = TRUE)
[10:29:58.834]                           if (has_future) {
[10:29:58.834]                             ns <- base::getNamespace("future")
[10:29:58.834]                             version <- ns[[".package"]][["version"]]
[10:29:58.834]                             if (is.null(version)) 
[10:29:58.834]                               version <- utils::packageVersion("future")
[10:29:58.834]                           }
[10:29:58.834]                           else {
[10:29:58.834]                             version <- NULL
[10:29:58.834]                           }
[10:29:58.834]                           if (!has_future || version < "1.8.0") {
[10:29:58.834]                             info <- base::c(r_version = base::gsub("R version ", 
[10:29:58.834]                               "", base::R.version$version.string), 
[10:29:58.834]                               platform = base::sprintf("%s (%s-bit)", 
[10:29:58.834]                                 base::R.version$platform, 8 * 
[10:29:58.834]                                   base::.Machine$sizeof.pointer), 
[10:29:58.834]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:58.834]                                 "release", "version")], collapse = " "), 
[10:29:58.834]                               hostname = base::Sys.info()[["nodename"]])
[10:29:58.834]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:29:58.834]                               info)
[10:29:58.834]                             info <- base::paste(info, collapse = "; ")
[10:29:58.834]                             if (!has_future) {
[10:29:58.834]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:58.834]                                 info)
[10:29:58.834]                             }
[10:29:58.834]                             else {
[10:29:58.834]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:58.834]                                 info, version)
[10:29:58.834]                             }
[10:29:58.834]                             base::stop(msg)
[10:29:58.834]                           }
[10:29:58.834]                         })
[10:29:58.834]                       }
[10:29:58.834]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:58.834]                       base::options(mc.cores = 1L)
[10:29:58.834]                     }
[10:29:58.834]                     base::local({
[10:29:58.834]                       for (pkg in "stats") {
[10:29:58.834]                         base::loadNamespace(pkg)
[10:29:58.834]                         base::library(pkg, character.only = TRUE)
[10:29:58.834]                       }
[10:29:58.834]                     })
[10:29:58.834]                   }
[10:29:58.834]                   ...future.strategy.old <- future::plan("list")
[10:29:58.834]                   options(future.plan = NULL)
[10:29:58.834]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:58.834]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:58.834]                 }
[10:29:58.834]                 ...future.workdir <- getwd()
[10:29:58.834]             }
[10:29:58.834]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:58.834]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:58.834]         }
[10:29:58.834]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:58.834]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:58.834]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:58.834]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:58.834]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:58.834]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:58.834]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:58.834]             base::names(...future.oldOptions))
[10:29:58.834]     }
[10:29:58.834]     if (FALSE) {
[10:29:58.834]     }
[10:29:58.834]     else {
[10:29:58.834]         if (TRUE) {
[10:29:58.834]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:58.834]                 open = "w")
[10:29:58.834]         }
[10:29:58.834]         else {
[10:29:58.834]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:58.834]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:58.834]         }
[10:29:58.834]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:58.834]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:58.834]             base::sink(type = "output", split = FALSE)
[10:29:58.834]             base::close(...future.stdout)
[10:29:58.834]         }, add = TRUE)
[10:29:58.834]     }
[10:29:58.834]     ...future.frame <- base::sys.nframe()
[10:29:58.834]     ...future.conditions <- base::list()
[10:29:58.834]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:58.834]     if (FALSE) {
[10:29:58.834]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:58.834]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:58.834]     }
[10:29:58.834]     ...future.result <- base::tryCatch({
[10:29:58.834]         base::withCallingHandlers({
[10:29:58.834]             ...future.value <- base::withVisible(base::local({
[10:29:58.834]                 ...future.makeSendCondition <- base::local({
[10:29:58.834]                   sendCondition <- NULL
[10:29:58.834]                   function(frame = 1L) {
[10:29:58.834]                     if (is.function(sendCondition)) 
[10:29:58.834]                       return(sendCondition)
[10:29:58.834]                     ns <- getNamespace("parallel")
[10:29:58.834]                     if (exists("sendData", mode = "function", 
[10:29:58.834]                       envir = ns)) {
[10:29:58.834]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:58.834]                         envir = ns)
[10:29:58.834]                       envir <- sys.frame(frame)
[10:29:58.834]                       master <- NULL
[10:29:58.834]                       while (!identical(envir, .GlobalEnv) && 
[10:29:58.834]                         !identical(envir, emptyenv())) {
[10:29:58.834]                         if (exists("master", mode = "list", envir = envir, 
[10:29:58.834]                           inherits = FALSE)) {
[10:29:58.834]                           master <- get("master", mode = "list", 
[10:29:58.834]                             envir = envir, inherits = FALSE)
[10:29:58.834]                           if (inherits(master, c("SOCKnode", 
[10:29:58.834]                             "SOCK0node"))) {
[10:29:58.834]                             sendCondition <<- function(cond) {
[10:29:58.834]                               data <- list(type = "VALUE", value = cond, 
[10:29:58.834]                                 success = TRUE)
[10:29:58.834]                               parallel_sendData(master, data)
[10:29:58.834]                             }
[10:29:58.834]                             return(sendCondition)
[10:29:58.834]                           }
[10:29:58.834]                         }
[10:29:58.834]                         frame <- frame + 1L
[10:29:58.834]                         envir <- sys.frame(frame)
[10:29:58.834]                       }
[10:29:58.834]                     }
[10:29:58.834]                     sendCondition <<- function(cond) NULL
[10:29:58.834]                   }
[10:29:58.834]                 })
[10:29:58.834]                 withCallingHandlers({
[10:29:58.834]                   {
[10:29:58.834]                     do.call(function(...) {
[10:29:58.834]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:58.834]                       if (!identical(...future.globals.maxSize.org, 
[10:29:58.834]                         ...future.globals.maxSize)) {
[10:29:58.834]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:58.834]                         on.exit(options(oopts), add = TRUE)
[10:29:58.834]                       }
[10:29:58.834]                       {
[10:29:58.834]                         lapply(seq_along(...future.elements_ii), 
[10:29:58.834]                           FUN = function(jj) {
[10:29:58.834]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:58.834]                             ...future.FUN(...future.X_jj, ...)
[10:29:58.834]                           })
[10:29:58.834]                       }
[10:29:58.834]                     }, args = future.call.arguments)
[10:29:58.834]                   }
[10:29:58.834]                 }, immediateCondition = function(cond) {
[10:29:58.834]                   sendCondition <- ...future.makeSendCondition()
[10:29:58.834]                   sendCondition(cond)
[10:29:58.834]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.834]                   {
[10:29:58.834]                     inherits <- base::inherits
[10:29:58.834]                     invokeRestart <- base::invokeRestart
[10:29:58.834]                     is.null <- base::is.null
[10:29:58.834]                     muffled <- FALSE
[10:29:58.834]                     if (inherits(cond, "message")) {
[10:29:58.834]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:58.834]                       if (muffled) 
[10:29:58.834]                         invokeRestart("muffleMessage")
[10:29:58.834]                     }
[10:29:58.834]                     else if (inherits(cond, "warning")) {
[10:29:58.834]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:58.834]                       if (muffled) 
[10:29:58.834]                         invokeRestart("muffleWarning")
[10:29:58.834]                     }
[10:29:58.834]                     else if (inherits(cond, "condition")) {
[10:29:58.834]                       if (!is.null(pattern)) {
[10:29:58.834]                         computeRestarts <- base::computeRestarts
[10:29:58.834]                         grepl <- base::grepl
[10:29:58.834]                         restarts <- computeRestarts(cond)
[10:29:58.834]                         for (restart in restarts) {
[10:29:58.834]                           name <- restart$name
[10:29:58.834]                           if (is.null(name)) 
[10:29:58.834]                             next
[10:29:58.834]                           if (!grepl(pattern, name)) 
[10:29:58.834]                             next
[10:29:58.834]                           invokeRestart(restart)
[10:29:58.834]                           muffled <- TRUE
[10:29:58.834]                           break
[10:29:58.834]                         }
[10:29:58.834]                       }
[10:29:58.834]                     }
[10:29:58.834]                     invisible(muffled)
[10:29:58.834]                   }
[10:29:58.834]                   muffleCondition(cond)
[10:29:58.834]                 })
[10:29:58.834]             }))
[10:29:58.834]             future::FutureResult(value = ...future.value$value, 
[10:29:58.834]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:58.834]                   ...future.rng), globalenv = if (FALSE) 
[10:29:58.834]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:58.834]                     ...future.globalenv.names))
[10:29:58.834]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:58.834]         }, condition = base::local({
[10:29:58.834]             c <- base::c
[10:29:58.834]             inherits <- base::inherits
[10:29:58.834]             invokeRestart <- base::invokeRestart
[10:29:58.834]             length <- base::length
[10:29:58.834]             list <- base::list
[10:29:58.834]             seq.int <- base::seq.int
[10:29:58.834]             signalCondition <- base::signalCondition
[10:29:58.834]             sys.calls <- base::sys.calls
[10:29:58.834]             `[[` <- base::`[[`
[10:29:58.834]             `+` <- base::`+`
[10:29:58.834]             `<<-` <- base::`<<-`
[10:29:58.834]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:58.834]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:58.834]                   3L)]
[10:29:58.834]             }
[10:29:58.834]             function(cond) {
[10:29:58.834]                 is_error <- inherits(cond, "error")
[10:29:58.834]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:58.834]                   NULL)
[10:29:58.834]                 if (is_error) {
[10:29:58.834]                   sessionInformation <- function() {
[10:29:58.834]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:58.834]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:58.834]                       search = base::search(), system = base::Sys.info())
[10:29:58.834]                   }
[10:29:58.834]                   ...future.conditions[[length(...future.conditions) + 
[10:29:58.834]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:58.834]                     cond$call), session = sessionInformation(), 
[10:29:58.834]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:58.834]                   signalCondition(cond)
[10:29:58.834]                 }
[10:29:58.834]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:58.834]                 "immediateCondition"))) {
[10:29:58.834]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:58.834]                   ...future.conditions[[length(...future.conditions) + 
[10:29:58.834]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:58.834]                   if (TRUE && !signal) {
[10:29:58.834]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.834]                     {
[10:29:58.834]                       inherits <- base::inherits
[10:29:58.834]                       invokeRestart <- base::invokeRestart
[10:29:58.834]                       is.null <- base::is.null
[10:29:58.834]                       muffled <- FALSE
[10:29:58.834]                       if (inherits(cond, "message")) {
[10:29:58.834]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:58.834]                         if (muffled) 
[10:29:58.834]                           invokeRestart("muffleMessage")
[10:29:58.834]                       }
[10:29:58.834]                       else if (inherits(cond, "warning")) {
[10:29:58.834]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:58.834]                         if (muffled) 
[10:29:58.834]                           invokeRestart("muffleWarning")
[10:29:58.834]                       }
[10:29:58.834]                       else if (inherits(cond, "condition")) {
[10:29:58.834]                         if (!is.null(pattern)) {
[10:29:58.834]                           computeRestarts <- base::computeRestarts
[10:29:58.834]                           grepl <- base::grepl
[10:29:58.834]                           restarts <- computeRestarts(cond)
[10:29:58.834]                           for (restart in restarts) {
[10:29:58.834]                             name <- restart$name
[10:29:58.834]                             if (is.null(name)) 
[10:29:58.834]                               next
[10:29:58.834]                             if (!grepl(pattern, name)) 
[10:29:58.834]                               next
[10:29:58.834]                             invokeRestart(restart)
[10:29:58.834]                             muffled <- TRUE
[10:29:58.834]                             break
[10:29:58.834]                           }
[10:29:58.834]                         }
[10:29:58.834]                       }
[10:29:58.834]                       invisible(muffled)
[10:29:58.834]                     }
[10:29:58.834]                     muffleCondition(cond, pattern = "^muffle")
[10:29:58.834]                   }
[10:29:58.834]                 }
[10:29:58.834]                 else {
[10:29:58.834]                   if (TRUE) {
[10:29:58.834]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.834]                     {
[10:29:58.834]                       inherits <- base::inherits
[10:29:58.834]                       invokeRestart <- base::invokeRestart
[10:29:58.834]                       is.null <- base::is.null
[10:29:58.834]                       muffled <- FALSE
[10:29:58.834]                       if (inherits(cond, "message")) {
[10:29:58.834]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:58.834]                         if (muffled) 
[10:29:58.834]                           invokeRestart("muffleMessage")
[10:29:58.834]                       }
[10:29:58.834]                       else if (inherits(cond, "warning")) {
[10:29:58.834]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:58.834]                         if (muffled) 
[10:29:58.834]                           invokeRestart("muffleWarning")
[10:29:58.834]                       }
[10:29:58.834]                       else if (inherits(cond, "condition")) {
[10:29:58.834]                         if (!is.null(pattern)) {
[10:29:58.834]                           computeRestarts <- base::computeRestarts
[10:29:58.834]                           grepl <- base::grepl
[10:29:58.834]                           restarts <- computeRestarts(cond)
[10:29:58.834]                           for (restart in restarts) {
[10:29:58.834]                             name <- restart$name
[10:29:58.834]                             if (is.null(name)) 
[10:29:58.834]                               next
[10:29:58.834]                             if (!grepl(pattern, name)) 
[10:29:58.834]                               next
[10:29:58.834]                             invokeRestart(restart)
[10:29:58.834]                             muffled <- TRUE
[10:29:58.834]                             break
[10:29:58.834]                           }
[10:29:58.834]                         }
[10:29:58.834]                       }
[10:29:58.834]                       invisible(muffled)
[10:29:58.834]                     }
[10:29:58.834]                     muffleCondition(cond, pattern = "^muffle")
[10:29:58.834]                   }
[10:29:58.834]                 }
[10:29:58.834]             }
[10:29:58.834]         }))
[10:29:58.834]     }, error = function(ex) {
[10:29:58.834]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:58.834]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:58.834]                 ...future.rng), started = ...future.startTime, 
[10:29:58.834]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:58.834]             version = "1.8"), class = "FutureResult")
[10:29:58.834]     }, finally = {
[10:29:58.834]         if (!identical(...future.workdir, getwd())) 
[10:29:58.834]             setwd(...future.workdir)
[10:29:58.834]         {
[10:29:58.834]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:58.834]                 ...future.oldOptions$nwarnings <- NULL
[10:29:58.834]             }
[10:29:58.834]             base::options(...future.oldOptions)
[10:29:58.834]             if (.Platform$OS.type == "windows") {
[10:29:58.834]                 old_names <- names(...future.oldEnvVars)
[10:29:58.834]                 envs <- base::Sys.getenv()
[10:29:58.834]                 names <- names(envs)
[10:29:58.834]                 common <- intersect(names, old_names)
[10:29:58.834]                 added <- setdiff(names, old_names)
[10:29:58.834]                 removed <- setdiff(old_names, names)
[10:29:58.834]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:58.834]                   envs[common]]
[10:29:58.834]                 NAMES <- toupper(changed)
[10:29:58.834]                 args <- list()
[10:29:58.834]                 for (kk in seq_along(NAMES)) {
[10:29:58.834]                   name <- changed[[kk]]
[10:29:58.834]                   NAME <- NAMES[[kk]]
[10:29:58.834]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.834]                     next
[10:29:58.834]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:58.834]                 }
[10:29:58.834]                 NAMES <- toupper(added)
[10:29:58.834]                 for (kk in seq_along(NAMES)) {
[10:29:58.834]                   name <- added[[kk]]
[10:29:58.834]                   NAME <- NAMES[[kk]]
[10:29:58.834]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.834]                     next
[10:29:58.834]                   args[[name]] <- ""
[10:29:58.834]                 }
[10:29:58.834]                 NAMES <- toupper(removed)
[10:29:58.834]                 for (kk in seq_along(NAMES)) {
[10:29:58.834]                   name <- removed[[kk]]
[10:29:58.834]                   NAME <- NAMES[[kk]]
[10:29:58.834]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.834]                     next
[10:29:58.834]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:58.834]                 }
[10:29:58.834]                 if (length(args) > 0) 
[10:29:58.834]                   base::do.call(base::Sys.setenv, args = args)
[10:29:58.834]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:58.834]             }
[10:29:58.834]             else {
[10:29:58.834]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:58.834]             }
[10:29:58.834]             {
[10:29:58.834]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:58.834]                   0L) {
[10:29:58.834]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:58.834]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:58.834]                   base::options(opts)
[10:29:58.834]                 }
[10:29:58.834]                 {
[10:29:58.834]                   {
[10:29:58.834]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:58.834]                     NULL
[10:29:58.834]                   }
[10:29:58.834]                   options(future.plan = NULL)
[10:29:58.834]                   if (is.na(NA_character_)) 
[10:29:58.834]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:58.834]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:58.834]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:58.834]                     .init = FALSE)
[10:29:58.834]                 }
[10:29:58.834]             }
[10:29:58.834]         }
[10:29:58.834]     })
[10:29:58.834]     if (TRUE) {
[10:29:58.834]         base::sink(type = "output", split = FALSE)
[10:29:58.834]         if (TRUE) {
[10:29:58.834]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:58.834]         }
[10:29:58.834]         else {
[10:29:58.834]             ...future.result["stdout"] <- base::list(NULL)
[10:29:58.834]         }
[10:29:58.834]         base::close(...future.stdout)
[10:29:58.834]         ...future.stdout <- NULL
[10:29:58.834]     }
[10:29:58.834]     ...future.result$conditions <- ...future.conditions
[10:29:58.834]     ...future.result$finished <- base::Sys.time()
[10:29:58.834]     ...future.result
[10:29:58.834] }
[10:29:58.837] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[10:29:58.837] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[10:29:58.838] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[10:29:58.838] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:29:58.838] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:29:58.838] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[10:29:58.839] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[10:29:58.839] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:29:58.839] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:29:58.839] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:29:58.839] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:29:58.839] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[10:29:58.840] MultisessionFuture started
[10:29:58.840] - Launch lazy future ... done
[10:29:58.840] run() for ‘MultisessionFuture’ ... done
[10:29:58.840] Created future:
[10:29:58.840] MultisessionFuture:
[10:29:58.840] Label: ‘future_eapply-1’
[10:29:58.840] Expression:
[10:29:58.840] {
[10:29:58.840]     do.call(function(...) {
[10:29:58.840]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:58.840]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:58.840]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:58.840]             on.exit(options(oopts), add = TRUE)
[10:29:58.840]         }
[10:29:58.840]         {
[10:29:58.840]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:58.840]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:58.840]                 ...future.FUN(...future.X_jj, ...)
[10:29:58.840]             })
[10:29:58.840]         }
[10:29:58.840]     }, args = future.call.arguments)
[10:29:58.840] }
[10:29:58.840] Lazy evaluation: FALSE
[10:29:58.840] Asynchronous evaluation: TRUE
[10:29:58.840] Local evaluation: TRUE
[10:29:58.840] Environment: R_GlobalEnv
[10:29:58.840] Capture standard output: TRUE
[10:29:58.840] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:58.840] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:58.840] Packages: 1 packages (‘stats’)
[10:29:58.840] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:58.840] Resolved: FALSE
[10:29:58.840] Value: <not collected>
[10:29:58.840] Conditions captured: <none>
[10:29:58.840] Early signaling: FALSE
[10:29:58.840] Owner process: db6eb61b-64f1-ae95-7e8b-287fbc43411a
[10:29:58.840] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:58.852] Chunk #1 of 2 ... DONE
[10:29:58.852] Chunk #2 of 2 ...
[10:29:58.852]  - Finding globals in 'X' for chunk #2 ...
[10:29:58.852] getGlobalsAndPackages() ...
[10:29:58.852] Searching for globals...
[10:29:58.853] 
[10:29:58.853] Searching for globals ... DONE
[10:29:58.853] - globals: [0] <none>
[10:29:58.853] getGlobalsAndPackages() ... DONE
[10:29:58.853]    + additional globals found: [n=0] 
[10:29:58.853]    + additional namespaces needed: [n=0] 
[10:29:58.853]  - Finding globals in 'X' for chunk #2 ... DONE
[10:29:58.853]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:29:58.853]  - seeds: <none>
[10:29:58.854]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:58.854] getGlobalsAndPackages() ...
[10:29:58.854] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:58.854] Resolving globals: FALSE
[10:29:58.854] Tweak future expression to call with '...' arguments ...
[10:29:58.854] {
[10:29:58.854]     do.call(function(...) {
[10:29:58.854]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:58.854]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:58.854]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:58.854]             on.exit(options(oopts), add = TRUE)
[10:29:58.854]         }
[10:29:58.854]         {
[10:29:58.854]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:58.854]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:58.854]                 ...future.FUN(...future.X_jj, ...)
[10:29:58.854]             })
[10:29:58.854]         }
[10:29:58.854]     }, args = future.call.arguments)
[10:29:58.854] }
[10:29:58.854] Tweak future expression to call with '...' arguments ... DONE
[10:29:58.855] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:29:58.855] - packages: [1] ‘stats’
[10:29:58.855] getGlobalsAndPackages() ... DONE
[10:29:58.855] run() for ‘Future’ ...
[10:29:58.857] - state: ‘created’
[10:29:58.857] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:29:58.871] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:58.871] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:29:58.872]   - Field: ‘node’
[10:29:58.872]   - Field: ‘label’
[10:29:58.872]   - Field: ‘local’
[10:29:58.872]   - Field: ‘owner’
[10:29:58.872]   - Field: ‘envir’
[10:29:58.872]   - Field: ‘workers’
[10:29:58.872]   - Field: ‘packages’
[10:29:58.872]   - Field: ‘gc’
[10:29:58.872]   - Field: ‘conditions’
[10:29:58.872]   - Field: ‘persistent’
[10:29:58.873]   - Field: ‘expr’
[10:29:58.873]   - Field: ‘uuid’
[10:29:58.873]   - Field: ‘seed’
[10:29:58.873]   - Field: ‘version’
[10:29:58.873]   - Field: ‘result’
[10:29:58.873]   - Field: ‘asynchronous’
[10:29:58.873]   - Field: ‘calls’
[10:29:58.873]   - Field: ‘globals’
[10:29:58.873]   - Field: ‘stdout’
[10:29:58.873]   - Field: ‘earlySignal’
[10:29:58.873]   - Field: ‘lazy’
[10:29:58.874]   - Field: ‘state’
[10:29:58.874] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:29:58.874] - Launch lazy future ...
[10:29:58.874] Packages needed by the future expression (n = 1): ‘stats’
[10:29:58.874] Packages needed by future strategies (n = 0): <none>
[10:29:58.875] {
[10:29:58.875]     {
[10:29:58.875]         {
[10:29:58.875]             ...future.startTime <- base::Sys.time()
[10:29:58.875]             {
[10:29:58.875]                 {
[10:29:58.875]                   {
[10:29:58.875]                     {
[10:29:58.875]                       {
[10:29:58.875]                         base::local({
[10:29:58.875]                           has_future <- base::requireNamespace("future", 
[10:29:58.875]                             quietly = TRUE)
[10:29:58.875]                           if (has_future) {
[10:29:58.875]                             ns <- base::getNamespace("future")
[10:29:58.875]                             version <- ns[[".package"]][["version"]]
[10:29:58.875]                             if (is.null(version)) 
[10:29:58.875]                               version <- utils::packageVersion("future")
[10:29:58.875]                           }
[10:29:58.875]                           else {
[10:29:58.875]                             version <- NULL
[10:29:58.875]                           }
[10:29:58.875]                           if (!has_future || version < "1.8.0") {
[10:29:58.875]                             info <- base::c(r_version = base::gsub("R version ", 
[10:29:58.875]                               "", base::R.version$version.string), 
[10:29:58.875]                               platform = base::sprintf("%s (%s-bit)", 
[10:29:58.875]                                 base::R.version$platform, 8 * 
[10:29:58.875]                                   base::.Machine$sizeof.pointer), 
[10:29:58.875]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:29:58.875]                                 "release", "version")], collapse = " "), 
[10:29:58.875]                               hostname = base::Sys.info()[["nodename"]])
[10:29:58.875]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:29:58.875]                               info)
[10:29:58.875]                             info <- base::paste(info, collapse = "; ")
[10:29:58.875]                             if (!has_future) {
[10:29:58.875]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:29:58.875]                                 info)
[10:29:58.875]                             }
[10:29:58.875]                             else {
[10:29:58.875]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:29:58.875]                                 info, version)
[10:29:58.875]                             }
[10:29:58.875]                             base::stop(msg)
[10:29:58.875]                           }
[10:29:58.875]                         })
[10:29:58.875]                       }
[10:29:58.875]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:29:58.875]                       base::options(mc.cores = 1L)
[10:29:58.875]                     }
[10:29:58.875]                     base::local({
[10:29:58.875]                       for (pkg in "stats") {
[10:29:58.875]                         base::loadNamespace(pkg)
[10:29:58.875]                         base::library(pkg, character.only = TRUE)
[10:29:58.875]                       }
[10:29:58.875]                     })
[10:29:58.875]                   }
[10:29:58.875]                   ...future.strategy.old <- future::plan("list")
[10:29:58.875]                   options(future.plan = NULL)
[10:29:58.875]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:29:58.875]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:29:58.875]                 }
[10:29:58.875]                 ...future.workdir <- getwd()
[10:29:58.875]             }
[10:29:58.875]             ...future.oldOptions <- base::as.list(base::.Options)
[10:29:58.875]             ...future.oldEnvVars <- base::Sys.getenv()
[10:29:58.875]         }
[10:29:58.875]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:29:58.875]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:29:58.875]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:29:58.875]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:29:58.875]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:29:58.875]             future.stdout.windows.reencode = NULL, width = 80L)
[10:29:58.875]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:29:58.875]             base::names(...future.oldOptions))
[10:29:58.875]     }
[10:29:58.875]     if (FALSE) {
[10:29:58.875]     }
[10:29:58.875]     else {
[10:29:58.875]         if (TRUE) {
[10:29:58.875]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:29:58.875]                 open = "w")
[10:29:58.875]         }
[10:29:58.875]         else {
[10:29:58.875]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:29:58.875]                 windows = "NUL", "/dev/null"), open = "w")
[10:29:58.875]         }
[10:29:58.875]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:29:58.875]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:29:58.875]             base::sink(type = "output", split = FALSE)
[10:29:58.875]             base::close(...future.stdout)
[10:29:58.875]         }, add = TRUE)
[10:29:58.875]     }
[10:29:58.875]     ...future.frame <- base::sys.nframe()
[10:29:58.875]     ...future.conditions <- base::list()
[10:29:58.875]     ...future.rng <- base::globalenv()$.Random.seed
[10:29:58.875]     if (FALSE) {
[10:29:58.875]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:29:58.875]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:29:58.875]     }
[10:29:58.875]     ...future.result <- base::tryCatch({
[10:29:58.875]         base::withCallingHandlers({
[10:29:58.875]             ...future.value <- base::withVisible(base::local({
[10:29:58.875]                 ...future.makeSendCondition <- base::local({
[10:29:58.875]                   sendCondition <- NULL
[10:29:58.875]                   function(frame = 1L) {
[10:29:58.875]                     if (is.function(sendCondition)) 
[10:29:58.875]                       return(sendCondition)
[10:29:58.875]                     ns <- getNamespace("parallel")
[10:29:58.875]                     if (exists("sendData", mode = "function", 
[10:29:58.875]                       envir = ns)) {
[10:29:58.875]                       parallel_sendData <- get("sendData", mode = "function", 
[10:29:58.875]                         envir = ns)
[10:29:58.875]                       envir <- sys.frame(frame)
[10:29:58.875]                       master <- NULL
[10:29:58.875]                       while (!identical(envir, .GlobalEnv) && 
[10:29:58.875]                         !identical(envir, emptyenv())) {
[10:29:58.875]                         if (exists("master", mode = "list", envir = envir, 
[10:29:58.875]                           inherits = FALSE)) {
[10:29:58.875]                           master <- get("master", mode = "list", 
[10:29:58.875]                             envir = envir, inherits = FALSE)
[10:29:58.875]                           if (inherits(master, c("SOCKnode", 
[10:29:58.875]                             "SOCK0node"))) {
[10:29:58.875]                             sendCondition <<- function(cond) {
[10:29:58.875]                               data <- list(type = "VALUE", value = cond, 
[10:29:58.875]                                 success = TRUE)
[10:29:58.875]                               parallel_sendData(master, data)
[10:29:58.875]                             }
[10:29:58.875]                             return(sendCondition)
[10:29:58.875]                           }
[10:29:58.875]                         }
[10:29:58.875]                         frame <- frame + 1L
[10:29:58.875]                         envir <- sys.frame(frame)
[10:29:58.875]                       }
[10:29:58.875]                     }
[10:29:58.875]                     sendCondition <<- function(cond) NULL
[10:29:58.875]                   }
[10:29:58.875]                 })
[10:29:58.875]                 withCallingHandlers({
[10:29:58.875]                   {
[10:29:58.875]                     do.call(function(...) {
[10:29:58.875]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:58.875]                       if (!identical(...future.globals.maxSize.org, 
[10:29:58.875]                         ...future.globals.maxSize)) {
[10:29:58.875]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:58.875]                         on.exit(options(oopts), add = TRUE)
[10:29:58.875]                       }
[10:29:58.875]                       {
[10:29:58.875]                         lapply(seq_along(...future.elements_ii), 
[10:29:58.875]                           FUN = function(jj) {
[10:29:58.875]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:58.875]                             ...future.FUN(...future.X_jj, ...)
[10:29:58.875]                           })
[10:29:58.875]                       }
[10:29:58.875]                     }, args = future.call.arguments)
[10:29:58.875]                   }
[10:29:58.875]                 }, immediateCondition = function(cond) {
[10:29:58.875]                   sendCondition <- ...future.makeSendCondition()
[10:29:58.875]                   sendCondition(cond)
[10:29:58.875]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.875]                   {
[10:29:58.875]                     inherits <- base::inherits
[10:29:58.875]                     invokeRestart <- base::invokeRestart
[10:29:58.875]                     is.null <- base::is.null
[10:29:58.875]                     muffled <- FALSE
[10:29:58.875]                     if (inherits(cond, "message")) {
[10:29:58.875]                       muffled <- grepl(pattern, "muffleMessage")
[10:29:58.875]                       if (muffled) 
[10:29:58.875]                         invokeRestart("muffleMessage")
[10:29:58.875]                     }
[10:29:58.875]                     else if (inherits(cond, "warning")) {
[10:29:58.875]                       muffled <- grepl(pattern, "muffleWarning")
[10:29:58.875]                       if (muffled) 
[10:29:58.875]                         invokeRestart("muffleWarning")
[10:29:58.875]                     }
[10:29:58.875]                     else if (inherits(cond, "condition")) {
[10:29:58.875]                       if (!is.null(pattern)) {
[10:29:58.875]                         computeRestarts <- base::computeRestarts
[10:29:58.875]                         grepl <- base::grepl
[10:29:58.875]                         restarts <- computeRestarts(cond)
[10:29:58.875]                         for (restart in restarts) {
[10:29:58.875]                           name <- restart$name
[10:29:58.875]                           if (is.null(name)) 
[10:29:58.875]                             next
[10:29:58.875]                           if (!grepl(pattern, name)) 
[10:29:58.875]                             next
[10:29:58.875]                           invokeRestart(restart)
[10:29:58.875]                           muffled <- TRUE
[10:29:58.875]                           break
[10:29:58.875]                         }
[10:29:58.875]                       }
[10:29:58.875]                     }
[10:29:58.875]                     invisible(muffled)
[10:29:58.875]                   }
[10:29:58.875]                   muffleCondition(cond)
[10:29:58.875]                 })
[10:29:58.875]             }))
[10:29:58.875]             future::FutureResult(value = ...future.value$value, 
[10:29:58.875]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:58.875]                   ...future.rng), globalenv = if (FALSE) 
[10:29:58.875]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:29:58.875]                     ...future.globalenv.names))
[10:29:58.875]                 else NULL, started = ...future.startTime, version = "1.8")
[10:29:58.875]         }, condition = base::local({
[10:29:58.875]             c <- base::c
[10:29:58.875]             inherits <- base::inherits
[10:29:58.875]             invokeRestart <- base::invokeRestart
[10:29:58.875]             length <- base::length
[10:29:58.875]             list <- base::list
[10:29:58.875]             seq.int <- base::seq.int
[10:29:58.875]             signalCondition <- base::signalCondition
[10:29:58.875]             sys.calls <- base::sys.calls
[10:29:58.875]             `[[` <- base::`[[`
[10:29:58.875]             `+` <- base::`+`
[10:29:58.875]             `<<-` <- base::`<<-`
[10:29:58.875]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:29:58.875]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:29:58.875]                   3L)]
[10:29:58.875]             }
[10:29:58.875]             function(cond) {
[10:29:58.875]                 is_error <- inherits(cond, "error")
[10:29:58.875]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:29:58.875]                   NULL)
[10:29:58.875]                 if (is_error) {
[10:29:58.875]                   sessionInformation <- function() {
[10:29:58.875]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:29:58.875]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:29:58.875]                       search = base::search(), system = base::Sys.info())
[10:29:58.875]                   }
[10:29:58.875]                   ...future.conditions[[length(...future.conditions) + 
[10:29:58.875]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:29:58.875]                     cond$call), session = sessionInformation(), 
[10:29:58.875]                     timestamp = base::Sys.time(), signaled = 0L)
[10:29:58.875]                   signalCondition(cond)
[10:29:58.875]                 }
[10:29:58.875]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:29:58.875]                 "immediateCondition"))) {
[10:29:58.875]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:29:58.875]                   ...future.conditions[[length(...future.conditions) + 
[10:29:58.875]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:29:58.875]                   if (TRUE && !signal) {
[10:29:58.875]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.875]                     {
[10:29:58.875]                       inherits <- base::inherits
[10:29:58.875]                       invokeRestart <- base::invokeRestart
[10:29:58.875]                       is.null <- base::is.null
[10:29:58.875]                       muffled <- FALSE
[10:29:58.875]                       if (inherits(cond, "message")) {
[10:29:58.875]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:58.875]                         if (muffled) 
[10:29:58.875]                           invokeRestart("muffleMessage")
[10:29:58.875]                       }
[10:29:58.875]                       else if (inherits(cond, "warning")) {
[10:29:58.875]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:58.875]                         if (muffled) 
[10:29:58.875]                           invokeRestart("muffleWarning")
[10:29:58.875]                       }
[10:29:58.875]                       else if (inherits(cond, "condition")) {
[10:29:58.875]                         if (!is.null(pattern)) {
[10:29:58.875]                           computeRestarts <- base::computeRestarts
[10:29:58.875]                           grepl <- base::grepl
[10:29:58.875]                           restarts <- computeRestarts(cond)
[10:29:58.875]                           for (restart in restarts) {
[10:29:58.875]                             name <- restart$name
[10:29:58.875]                             if (is.null(name)) 
[10:29:58.875]                               next
[10:29:58.875]                             if (!grepl(pattern, name)) 
[10:29:58.875]                               next
[10:29:58.875]                             invokeRestart(restart)
[10:29:58.875]                             muffled <- TRUE
[10:29:58.875]                             break
[10:29:58.875]                           }
[10:29:58.875]                         }
[10:29:58.875]                       }
[10:29:58.875]                       invisible(muffled)
[10:29:58.875]                     }
[10:29:58.875]                     muffleCondition(cond, pattern = "^muffle")
[10:29:58.875]                   }
[10:29:58.875]                 }
[10:29:58.875]                 else {
[10:29:58.875]                   if (TRUE) {
[10:29:58.875]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:29:58.875]                     {
[10:29:58.875]                       inherits <- base::inherits
[10:29:58.875]                       invokeRestart <- base::invokeRestart
[10:29:58.875]                       is.null <- base::is.null
[10:29:58.875]                       muffled <- FALSE
[10:29:58.875]                       if (inherits(cond, "message")) {
[10:29:58.875]                         muffled <- grepl(pattern, "muffleMessage")
[10:29:58.875]                         if (muffled) 
[10:29:58.875]                           invokeRestart("muffleMessage")
[10:29:58.875]                       }
[10:29:58.875]                       else if (inherits(cond, "warning")) {
[10:29:58.875]                         muffled <- grepl(pattern, "muffleWarning")
[10:29:58.875]                         if (muffled) 
[10:29:58.875]                           invokeRestart("muffleWarning")
[10:29:58.875]                       }
[10:29:58.875]                       else if (inherits(cond, "condition")) {
[10:29:58.875]                         if (!is.null(pattern)) {
[10:29:58.875]                           computeRestarts <- base::computeRestarts
[10:29:58.875]                           grepl <- base::grepl
[10:29:58.875]                           restarts <- computeRestarts(cond)
[10:29:58.875]                           for (restart in restarts) {
[10:29:58.875]                             name <- restart$name
[10:29:58.875]                             if (is.null(name)) 
[10:29:58.875]                               next
[10:29:58.875]                             if (!grepl(pattern, name)) 
[10:29:58.875]                               next
[10:29:58.875]                             invokeRestart(restart)
[10:29:58.875]                             muffled <- TRUE
[10:29:58.875]                             break
[10:29:58.875]                           }
[10:29:58.875]                         }
[10:29:58.875]                       }
[10:29:58.875]                       invisible(muffled)
[10:29:58.875]                     }
[10:29:58.875]                     muffleCondition(cond, pattern = "^muffle")
[10:29:58.875]                   }
[10:29:58.875]                 }
[10:29:58.875]             }
[10:29:58.875]         }))
[10:29:58.875]     }, error = function(ex) {
[10:29:58.875]         base::structure(base::list(value = NULL, visible = NULL, 
[10:29:58.875]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:29:58.875]                 ...future.rng), started = ...future.startTime, 
[10:29:58.875]             finished = Sys.time(), session_uuid = NA_character_, 
[10:29:58.875]             version = "1.8"), class = "FutureResult")
[10:29:58.875]     }, finally = {
[10:29:58.875]         if (!identical(...future.workdir, getwd())) 
[10:29:58.875]             setwd(...future.workdir)
[10:29:58.875]         {
[10:29:58.875]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:29:58.875]                 ...future.oldOptions$nwarnings <- NULL
[10:29:58.875]             }
[10:29:58.875]             base::options(...future.oldOptions)
[10:29:58.875]             if (.Platform$OS.type == "windows") {
[10:29:58.875]                 old_names <- names(...future.oldEnvVars)
[10:29:58.875]                 envs <- base::Sys.getenv()
[10:29:58.875]                 names <- names(envs)
[10:29:58.875]                 common <- intersect(names, old_names)
[10:29:58.875]                 added <- setdiff(names, old_names)
[10:29:58.875]                 removed <- setdiff(old_names, names)
[10:29:58.875]                 changed <- common[...future.oldEnvVars[common] != 
[10:29:58.875]                   envs[common]]
[10:29:58.875]                 NAMES <- toupper(changed)
[10:29:58.875]                 args <- list()
[10:29:58.875]                 for (kk in seq_along(NAMES)) {
[10:29:58.875]                   name <- changed[[kk]]
[10:29:58.875]                   NAME <- NAMES[[kk]]
[10:29:58.875]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.875]                     next
[10:29:58.875]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:58.875]                 }
[10:29:58.875]                 NAMES <- toupper(added)
[10:29:58.875]                 for (kk in seq_along(NAMES)) {
[10:29:58.875]                   name <- added[[kk]]
[10:29:58.875]                   NAME <- NAMES[[kk]]
[10:29:58.875]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.875]                     next
[10:29:58.875]                   args[[name]] <- ""
[10:29:58.875]                 }
[10:29:58.875]                 NAMES <- toupper(removed)
[10:29:58.875]                 for (kk in seq_along(NAMES)) {
[10:29:58.875]                   name <- removed[[kk]]
[10:29:58.875]                   NAME <- NAMES[[kk]]
[10:29:58.875]                   if (name != NAME && is.element(NAME, old_names)) 
[10:29:58.875]                     next
[10:29:58.875]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:29:58.875]                 }
[10:29:58.875]                 if (length(args) > 0) 
[10:29:58.875]                   base::do.call(base::Sys.setenv, args = args)
[10:29:58.875]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:29:58.875]             }
[10:29:58.875]             else {
[10:29:58.875]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:29:58.875]             }
[10:29:58.875]             {
[10:29:58.875]                 if (base::length(...future.futureOptionsAdded) > 
[10:29:58.875]                   0L) {
[10:29:58.875]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:29:58.875]                   base::names(opts) <- ...future.futureOptionsAdded
[10:29:58.875]                   base::options(opts)
[10:29:58.875]                 }
[10:29:58.875]                 {
[10:29:58.875]                   {
[10:29:58.875]                     base::options(mc.cores = ...future.mc.cores.old)
[10:29:58.875]                     NULL
[10:29:58.875]                   }
[10:29:58.875]                   options(future.plan = NULL)
[10:29:58.875]                   if (is.na(NA_character_)) 
[10:29:58.875]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:29:58.875]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:29:58.875]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:29:58.875]                     .init = FALSE)
[10:29:58.875]                 }
[10:29:58.875]             }
[10:29:58.875]         }
[10:29:58.875]     })
[10:29:58.875]     if (TRUE) {
[10:29:58.875]         base::sink(type = "output", split = FALSE)
[10:29:58.875]         if (TRUE) {
[10:29:58.875]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:29:58.875]         }
[10:29:58.875]         else {
[10:29:58.875]             ...future.result["stdout"] <- base::list(NULL)
[10:29:58.875]         }
[10:29:58.875]         base::close(...future.stdout)
[10:29:58.875]         ...future.stdout <- NULL
[10:29:58.875]     }
[10:29:58.875]     ...future.result$conditions <- ...future.conditions
[10:29:58.875]     ...future.result$finished <- base::Sys.time()
[10:29:58.875]     ...future.result
[10:29:58.875] }
[10:29:58.877] Exporting 5 global objects (1.22 KiB) to cluster node #2 ...
[10:29:58.878] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[10:29:58.878] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[10:29:58.878] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:29:58.879] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:29:58.879] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[10:29:58.879] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[10:29:58.879] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:29:58.880] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:29:58.880] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:29:58.880] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:29:58.880] Exporting 5 global objects (1.22 KiB) to cluster node #2 ... DONE
[10:29:58.881] MultisessionFuture started
[10:29:58.881] - Launch lazy future ... done
[10:29:58.881] run() for ‘MultisessionFuture’ ... done
[10:29:58.881] Created future:
[10:29:58.881] MultisessionFuture:
[10:29:58.881] Label: ‘future_eapply-2’
[10:29:58.881] Expression:
[10:29:58.881] {
[10:29:58.881]     do.call(function(...) {
[10:29:58.881]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:29:58.881]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:29:58.881]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:29:58.881]             on.exit(options(oopts), add = TRUE)
[10:29:58.881]         }
[10:29:58.881]         {
[10:29:58.881]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:29:58.881]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:29:58.881]                 ...future.FUN(...future.X_jj, ...)
[10:29:58.881]             })
[10:29:58.881]         }
[10:29:58.881]     }, args = future.call.arguments)
[10:29:58.881] }
[10:29:58.881] Lazy evaluation: FALSE
[10:29:58.881] Asynchronous evaluation: TRUE
[10:29:58.881] Local evaluation: TRUE
[10:29:58.881] Environment: R_GlobalEnv
[10:29:58.881] Capture standard output: TRUE
[10:29:58.881] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:29:58.881] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:29:58.881] Packages: 1 packages (‘stats’)
[10:29:58.881] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:29:58.881] Resolved: FALSE
[10:29:58.881] Value: <not collected>
[10:29:58.881] Conditions captured: <none>
[10:29:58.881] Early signaling: FALSE
[10:29:58.881] Owner process: db6eb61b-64f1-ae95-7e8b-287fbc43411a
[10:29:58.881] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:29:58.893] Chunk #2 of 2 ... DONE
[10:29:58.893] Launching 2 futures (chunks) ... DONE
[10:29:58.893] Resolving 2 futures (chunks) ...
[10:29:58.893] resolve() on list ...
[10:29:58.893]  recursive: 0
[10:29:58.893]  length: 2
[10:29:58.893] 
[10:29:58.894] receiveMessageFromWorker() for ClusterFuture ...
[10:29:58.894] - Validating connection of MultisessionFuture
[10:29:58.894] - received message: FutureResult
[10:29:58.894] - Received FutureResult
[10:29:58.894] - Erased future from FutureRegistry
[10:29:58.895] result() for ClusterFuture ...
[10:29:58.895] - result already collected: FutureResult
[10:29:58.895] result() for ClusterFuture ... done
[10:29:58.895] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:58.895] Future #1
[10:29:58.895] result() for ClusterFuture ...
[10:29:58.895] - result already collected: FutureResult
[10:29:58.895] result() for ClusterFuture ... done
[10:29:58.895] result() for ClusterFuture ...
[10:29:58.895] - result already collected: FutureResult
[10:29:58.895] result() for ClusterFuture ... done
[10:29:58.895] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:29:58.896] - nx: 2
[10:29:58.896] - relay: TRUE
[10:29:58.896] - stdout: TRUE
[10:29:58.896] - signal: TRUE
[10:29:58.896] - resignal: FALSE
[10:29:58.896] - force: TRUE
[10:29:58.896] - relayed: [n=2] FALSE, FALSE
[10:29:58.896] - queued futures: [n=2] FALSE, FALSE
[10:29:58.896]  - until=1
[10:29:58.896]  - relaying element #1
[10:29:58.896] result() for ClusterFuture ...
[10:29:58.896] - result already collected: FutureResult
[10:29:58.897] result() for ClusterFuture ... done
[10:29:58.897] result() for ClusterFuture ...
[10:29:58.897] - result already collected: FutureResult
[10:29:58.897] result() for ClusterFuture ... done
[10:29:58.897] result() for ClusterFuture ...
[10:29:58.897] - result already collected: FutureResult
[10:29:58.897] result() for ClusterFuture ... done
[10:29:58.897] result() for ClusterFuture ...
[10:29:58.897] - result already collected: FutureResult
[10:29:58.897] result() for ClusterFuture ... done
[10:29:58.898] - relayed: [n=2] TRUE, FALSE
[10:29:58.898] - queued futures: [n=2] TRUE, FALSE
[10:29:58.898] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:29:58.898]  length: 1 (resolved future 1)
[10:29:58.923] receiveMessageFromWorker() for ClusterFuture ...
[10:29:58.923] - Validating connection of MultisessionFuture
[10:29:58.923] - received message: FutureResult
[10:29:58.923] - Received FutureResult
[10:29:58.923] - Erased future from FutureRegistry
[10:29:58.924] result() for ClusterFuture ...
[10:29:58.924] - result already collected: FutureResult
[10:29:58.924] result() for ClusterFuture ... done
[10:29:58.924] receiveMessageFromWorker() for ClusterFuture ... done
[10:29:58.924] Future #2
[10:29:58.924] result() for ClusterFuture ...
[10:29:58.924] - result already collected: FutureResult
[10:29:58.924] result() for ClusterFuture ... done
[10:29:58.924] result() for ClusterFuture ...
[10:29:58.924] - result already collected: FutureResult
[10:29:58.924] result() for ClusterFuture ... done
[10:29:58.925] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:29:58.925] - nx: 2
[10:29:58.925] - relay: TRUE
[10:29:58.925] - stdout: TRUE
[10:29:58.925] - signal: TRUE
[10:29:58.925] - resignal: FALSE
[10:29:58.925] - force: TRUE
[10:29:58.925] - relayed: [n=2] TRUE, FALSE
[10:29:58.925] - queued futures: [n=2] TRUE, FALSE
[10:29:58.925]  - until=2
[10:29:58.925]  - relaying element #2
[10:29:58.926] result() for ClusterFuture ...
[10:29:58.926] - result already collected: FutureResult
[10:29:58.926] result() for ClusterFuture ... done
[10:29:58.926] result() for ClusterFuture ...
[10:29:58.926] - result already collected: FutureResult
[10:29:58.926] result() for ClusterFuture ... done
[10:29:58.926] result() for ClusterFuture ...
[10:29:58.926] - result already collected: FutureResult
[10:29:58.926] result() for ClusterFuture ... done
[10:29:58.926] result() for ClusterFuture ...
[10:29:58.926] - result already collected: FutureResult
[10:29:58.927] result() for ClusterFuture ... done
[10:29:58.927] - relayed: [n=2] TRUE, TRUE
[10:29:58.927] - queued futures: [n=2] TRUE, TRUE
[10:29:58.927] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:29:58.927]  length: 0 (resolved future 2)
[10:29:58.927] Relaying remaining futures
[10:29:58.927] signalConditionsASAP(NULL, pos=0) ...
[10:29:58.927] - nx: 2
[10:29:58.927] - relay: TRUE
[10:29:58.927] - stdout: TRUE
[10:29:58.927] - signal: TRUE
[10:29:58.928] - resignal: FALSE
[10:29:58.928] - force: TRUE
[10:29:58.928] - relayed: [n=2] TRUE, TRUE
[10:29:58.928] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:29:58.928] - relayed: [n=2] TRUE, TRUE
[10:29:58.928] - queued futures: [n=2] TRUE, TRUE
[10:29:58.928] signalConditionsASAP(NULL, pos=0) ... done
[10:29:58.928] resolve() on list ... DONE
[10:29:58.928] result() for ClusterFuture ...
[10:29:58.928] - result already collected: FutureResult
[10:29:58.928] result() for ClusterFuture ... done
[10:29:58.929] result() for ClusterFuture ...
[10:29:58.929] - result already collected: FutureResult
[10:29:58.929] result() for ClusterFuture ... done
[10:29:58.929] result() for ClusterFuture ...
[10:29:58.929] - result already collected: FutureResult
[10:29:58.929] result() for ClusterFuture ... done
[10:29:58.929] result() for ClusterFuture ...
[10:29:58.929] - result already collected: FutureResult
[10:29:58.929] result() for ClusterFuture ... done
[10:29:58.929]  - Number of value chunks collected: 2
[10:29:58.929] Resolving 2 futures (chunks) ... DONE
[10:29:58.930] Reducing values from 2 chunks ...
[10:29:58.930]  - Number of values collected after concatenation: 3
[10:29:58.930]  - Number of values expected: 3
[10:29:58.930] Reducing values from 2 chunks ... DONE
[10:29:58.930] future_lapply() ... DONE
[10:29:58.930] plan(): Setting new future strategy stack:
[10:29:58.930] List of future strategies:
[10:29:58.930] 1. sequential:
[10:29:58.930]    - args: function (..., envir = parent.frame())
[10:29:58.930]    - tweaked: FALSE
[10:29:58.930]    - call: plan(sequential)
[10:29:58.931] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> message("*** future_eapply() ... DONE")
*** future_eapply() ... DONE
> 
> source("incl/end.R")
[10:29:58.932] plan(): Setting new future strategy stack:
[10:29:58.932] List of future strategies:
[10:29:58.932] 1. FutureStrategy:
[10:29:58.932]    - args: function (..., envir = parent.frame())
[10:29:58.932]    - tweaked: FALSE
[10:29:58.932]    - call: future::plan(oplan)
[10:29:58.933] plan(): nbrOfWorkers() = 1
> 
