
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[13:33:44.334] plan(): Setting new future strategy stack:
[13:33:44.335] List of future strategies:
[13:33:44.335] 1. sequential:
[13:33:44.335]    - args: function (..., envir = parent.frame())
[13:33:44.335]    - tweaked: FALSE
[13:33:44.335]    - call: future::plan("sequential")
[13:33:44.349] plan(): nbrOfWorkers() = 1
> 
> message("*** future_eapply() ...")
*** future_eapply() ...
> 
> message("- From example(eapply) ...")
- From example(eapply) ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   env <- new.env(hash = FALSE)
+   env$a <- 1:10
+   env$beta <- exp(-3:3)
+   env$logic <- c(TRUE, FALSE, FALSE, TRUE)
+   
+   y0 <- unlist(eapply(env, mean, USE.NAMES = FALSE))
+   y1 <- unlist(future_eapply(env, mean, USE.NAMES = FALSE))
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile, probs = 1:3/4)
+   y1 <- future_eapply(env, quantile, probs = 1:3/4)
+   stopifnot(all.equal(y1, y0))
+   
+   y0 <- eapply(env, quantile)
+   y1 <- future_eapply(env, quantile)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_eapply(env, "quantile")
+   stopifnot(all.equal(y2, y0))
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[13:33:44.371] plan(): Setting new future strategy stack:
[13:33:44.371] List of future strategies:
[13:33:44.371] 1. sequential:
[13:33:44.371]    - args: function (..., envir = parent.frame())
[13:33:44.371]    - tweaked: FALSE
[13:33:44.371]    - call: plan(strategy)
[13:33:44.382] plan(): nbrOfWorkers() = 1
[13:33:44.383] future_lapply() ...
[13:33:44.387] Number of chunks: 1
[13:33:44.387] getGlobalsAndPackagesXApply() ...
[13:33:44.387]  - future.globals: TRUE
[13:33:44.388] getGlobalsAndPackages() ...
[13:33:44.388] Searching for globals...
[13:33:44.390] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:44.391] Searching for globals ... DONE
[13:33:44.391] Resolving globals: FALSE
[13:33:44.392] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:44.392] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:44.392] - globals: [1] ‘FUN’
[13:33:44.392] 
[13:33:44.392] getGlobalsAndPackages() ... DONE
[13:33:44.392]  - globals found/used: [n=1] ‘FUN’
[13:33:44.393]  - needed namespaces: [n=0] 
[13:33:44.393] Finding globals ... DONE
[13:33:44.393]  - use_args: TRUE
[13:33:44.393]  - Getting '...' globals ...
[13:33:44.394] resolve() on list ...
[13:33:44.394]  recursive: 0
[13:33:44.394]  length: 1
[13:33:44.394]  elements: ‘...’
[13:33:44.394]  length: 0 (resolved future 1)
[13:33:44.394] resolve() on list ... DONE
[13:33:44.394]    - '...' content: [n=0] 
[13:33:44.395] List of 1
[13:33:44.395]  $ ...: list()
[13:33:44.395]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.395]  - attr(*, "where")=List of 1
[13:33:44.395]   ..$ ...:<environment: 0x559844125ed0> 
[13:33:44.395]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.395]  - attr(*, "resolved")= logi TRUE
[13:33:44.395]  - attr(*, "total_size")= num NA
[13:33:44.399]  - Getting '...' globals ... DONE
[13:33:44.400] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:44.400] List of 2
[13:33:44.400]  $ ...future.FUN:function (x, ...)  
[13:33:44.400]  $ ...          : list()
[13:33:44.400]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.400]  - attr(*, "where")=List of 2
[13:33:44.400]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:44.400]   ..$ ...          :<environment: 0x559844125ed0> 
[13:33:44.400]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.400]  - attr(*, "resolved")= logi FALSE
[13:33:44.400]  - attr(*, "total_size")= num 1240
[13:33:44.402] Packages to be attached in all futures: [n=0] 
[13:33:44.402] getGlobalsAndPackagesXApply() ... DONE
[13:33:44.403] Number of futures (= number of chunks): 1
[13:33:44.403] Launching 1 futures (chunks) ...
[13:33:44.403] Chunk #1 of 1 ...
[13:33:44.403]  - Finding globals in 'X' for chunk #1 ...
[13:33:44.403] getGlobalsAndPackages() ...
[13:33:44.403] Searching for globals...
[13:33:44.404] 
[13:33:44.404] Searching for globals ... DONE
[13:33:44.404] - globals: [0] <none>
[13:33:44.404] getGlobalsAndPackages() ... DONE
[13:33:44.404]    + additional globals found: [n=0] 
[13:33:44.404]    + additional namespaces needed: [n=0] 
[13:33:44.404]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:44.404]  - seeds: <none>
[13:33:44.404]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.405] getGlobalsAndPackages() ...
[13:33:44.405] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.405] Resolving globals: FALSE
[13:33:44.405] Tweak future expression to call with '...' arguments ...
[13:33:44.405] {
[13:33:44.405]     do.call(function(...) {
[13:33:44.405]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.405]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:44.405]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.405]             on.exit(options(oopts), add = TRUE)
[13:33:44.405]         }
[13:33:44.405]         {
[13:33:44.405]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:44.405]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.405]                 ...future.FUN(...future.X_jj, ...)
[13:33:44.405]             })
[13:33:44.405]         }
[13:33:44.405]     }, args = future.call.arguments)
[13:33:44.405] }
[13:33:44.405] Tweak future expression to call with '...' arguments ... DONE
[13:33:44.405] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.406] 
[13:33:44.406] getGlobalsAndPackages() ... DONE
[13:33:44.406] run() for ‘Future’ ...
[13:33:44.407] - state: ‘created’
[13:33:44.407] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:33:44.407] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:44.407] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:44.407]   - Field: ‘label’
[13:33:44.407]   - Field: ‘local’
[13:33:44.408]   - Field: ‘owner’
[13:33:44.408]   - Field: ‘envir’
[13:33:44.408]   - Field: ‘packages’
[13:33:44.408]   - Field: ‘gc’
[13:33:44.408]   - Field: ‘conditions’
[13:33:44.408]   - Field: ‘expr’
[13:33:44.408]   - Field: ‘uuid’
[13:33:44.408]   - Field: ‘seed’
[13:33:44.408]   - Field: ‘version’
[13:33:44.408]   - Field: ‘result’
[13:33:44.408]   - Field: ‘asynchronous’
[13:33:44.409]   - Field: ‘calls’
[13:33:44.409]   - Field: ‘globals’
[13:33:44.409]   - Field: ‘stdout’
[13:33:44.409]   - Field: ‘earlySignal’
[13:33:44.409]   - Field: ‘lazy’
[13:33:44.409]   - Field: ‘state’
[13:33:44.409] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:44.409] - Launch lazy future ...
[13:33:44.410] Packages needed by the future expression (n = 0): <none>
[13:33:44.410] Packages needed by future strategies (n = 0): <none>
[13:33:44.413] {
[13:33:44.413]     {
[13:33:44.413]         {
[13:33:44.413]             ...future.startTime <- base::Sys.time()
[13:33:44.413]             {
[13:33:44.413]                 {
[13:33:44.413]                   {
[13:33:44.413]                     base::local({
[13:33:44.413]                       has_future <- base::requireNamespace("future", 
[13:33:44.413]                         quietly = TRUE)
[13:33:44.413]                       if (has_future) {
[13:33:44.413]                         ns <- base::getNamespace("future")
[13:33:44.413]                         version <- ns[[".package"]][["version"]]
[13:33:44.413]                         if (is.null(version)) 
[13:33:44.413]                           version <- utils::packageVersion("future")
[13:33:44.413]                       }
[13:33:44.413]                       else {
[13:33:44.413]                         version <- NULL
[13:33:44.413]                       }
[13:33:44.413]                       if (!has_future || version < "1.8.0") {
[13:33:44.413]                         info <- base::c(r_version = base::gsub("R version ", 
[13:33:44.413]                           "", base::R.version$version.string), 
[13:33:44.413]                           platform = base::sprintf("%s (%s-bit)", 
[13:33:44.413]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:44.413]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:44.413]                             "release", "version")], collapse = " "), 
[13:33:44.413]                           hostname = base::Sys.info()[["nodename"]])
[13:33:44.413]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:33:44.413]                           info)
[13:33:44.413]                         info <- base::paste(info, collapse = "; ")
[13:33:44.413]                         if (!has_future) {
[13:33:44.413]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:44.413]                             info)
[13:33:44.413]                         }
[13:33:44.413]                         else {
[13:33:44.413]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:44.413]                             info, version)
[13:33:44.413]                         }
[13:33:44.413]                         base::stop(msg)
[13:33:44.413]                       }
[13:33:44.413]                     })
[13:33:44.413]                   }
[13:33:44.413]                   ...future.strategy.old <- future::plan("list")
[13:33:44.413]                   options(future.plan = NULL)
[13:33:44.413]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:44.413]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:44.413]                 }
[13:33:44.413]                 ...future.workdir <- getwd()
[13:33:44.413]             }
[13:33:44.413]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:44.413]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:44.413]         }
[13:33:44.413]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:44.413]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:44.413]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:44.413]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:44.413]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:44.413]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:44.413]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:44.413]             base::names(...future.oldOptions))
[13:33:44.413]     }
[13:33:44.413]     if (FALSE) {
[13:33:44.413]     }
[13:33:44.413]     else {
[13:33:44.413]         if (TRUE) {
[13:33:44.413]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:44.413]                 open = "w")
[13:33:44.413]         }
[13:33:44.413]         else {
[13:33:44.413]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:44.413]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:44.413]         }
[13:33:44.413]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:44.413]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:44.413]             base::sink(type = "output", split = FALSE)
[13:33:44.413]             base::close(...future.stdout)
[13:33:44.413]         }, add = TRUE)
[13:33:44.413]     }
[13:33:44.413]     ...future.frame <- base::sys.nframe()
[13:33:44.413]     ...future.conditions <- base::list()
[13:33:44.413]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:44.413]     if (FALSE) {
[13:33:44.413]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:44.413]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:44.413]     }
[13:33:44.413]     ...future.result <- base::tryCatch({
[13:33:44.413]         base::withCallingHandlers({
[13:33:44.413]             ...future.value <- base::withVisible(base::local({
[13:33:44.413]                 do.call(function(...) {
[13:33:44.413]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.413]                   if (!identical(...future.globals.maxSize.org, 
[13:33:44.413]                     ...future.globals.maxSize)) {
[13:33:44.413]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.413]                     on.exit(options(oopts), add = TRUE)
[13:33:44.413]                   }
[13:33:44.413]                   {
[13:33:44.413]                     lapply(seq_along(...future.elements_ii), 
[13:33:44.413]                       FUN = function(jj) {
[13:33:44.413]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.413]                         ...future.FUN(...future.X_jj, ...)
[13:33:44.413]                       })
[13:33:44.413]                   }
[13:33:44.413]                 }, args = future.call.arguments)
[13:33:44.413]             }))
[13:33:44.413]             future::FutureResult(value = ...future.value$value, 
[13:33:44.413]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:44.413]                   ...future.rng), globalenv = if (FALSE) 
[13:33:44.413]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:44.413]                     ...future.globalenv.names))
[13:33:44.413]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:44.413]         }, condition = base::local({
[13:33:44.413]             c <- base::c
[13:33:44.413]             inherits <- base::inherits
[13:33:44.413]             invokeRestart <- base::invokeRestart
[13:33:44.413]             length <- base::length
[13:33:44.413]             list <- base::list
[13:33:44.413]             seq.int <- base::seq.int
[13:33:44.413]             signalCondition <- base::signalCondition
[13:33:44.413]             sys.calls <- base::sys.calls
[13:33:44.413]             `[[` <- base::`[[`
[13:33:44.413]             `+` <- base::`+`
[13:33:44.413]             `<<-` <- base::`<<-`
[13:33:44.413]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:44.413]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:44.413]                   3L)]
[13:33:44.413]             }
[13:33:44.413]             function(cond) {
[13:33:44.413]                 is_error <- inherits(cond, "error")
[13:33:44.413]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:44.413]                   NULL)
[13:33:44.413]                 if (is_error) {
[13:33:44.413]                   sessionInformation <- function() {
[13:33:44.413]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:44.413]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:44.413]                       search = base::search(), system = base::Sys.info())
[13:33:44.413]                   }
[13:33:44.413]                   ...future.conditions[[length(...future.conditions) + 
[13:33:44.413]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:44.413]                     cond$call), session = sessionInformation(), 
[13:33:44.413]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:44.413]                   signalCondition(cond)
[13:33:44.413]                 }
[13:33:44.413]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:44.413]                 "immediateCondition"))) {
[13:33:44.413]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:44.413]                   ...future.conditions[[length(...future.conditions) + 
[13:33:44.413]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:44.413]                   if (TRUE && !signal) {
[13:33:44.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.413]                     {
[13:33:44.413]                       inherits <- base::inherits
[13:33:44.413]                       invokeRestart <- base::invokeRestart
[13:33:44.413]                       is.null <- base::is.null
[13:33:44.413]                       muffled <- FALSE
[13:33:44.413]                       if (inherits(cond, "message")) {
[13:33:44.413]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:44.413]                         if (muffled) 
[13:33:44.413]                           invokeRestart("muffleMessage")
[13:33:44.413]                       }
[13:33:44.413]                       else if (inherits(cond, "warning")) {
[13:33:44.413]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:44.413]                         if (muffled) 
[13:33:44.413]                           invokeRestart("muffleWarning")
[13:33:44.413]                       }
[13:33:44.413]                       else if (inherits(cond, "condition")) {
[13:33:44.413]                         if (!is.null(pattern)) {
[13:33:44.413]                           computeRestarts <- base::computeRestarts
[13:33:44.413]                           grepl <- base::grepl
[13:33:44.413]                           restarts <- computeRestarts(cond)
[13:33:44.413]                           for (restart in restarts) {
[13:33:44.413]                             name <- restart$name
[13:33:44.413]                             if (is.null(name)) 
[13:33:44.413]                               next
[13:33:44.413]                             if (!grepl(pattern, name)) 
[13:33:44.413]                               next
[13:33:44.413]                             invokeRestart(restart)
[13:33:44.413]                             muffled <- TRUE
[13:33:44.413]                             break
[13:33:44.413]                           }
[13:33:44.413]                         }
[13:33:44.413]                       }
[13:33:44.413]                       invisible(muffled)
[13:33:44.413]                     }
[13:33:44.413]                     muffleCondition(cond, pattern = "^muffle")
[13:33:44.413]                   }
[13:33:44.413]                 }
[13:33:44.413]                 else {
[13:33:44.413]                   if (TRUE) {
[13:33:44.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.413]                     {
[13:33:44.413]                       inherits <- base::inherits
[13:33:44.413]                       invokeRestart <- base::invokeRestart
[13:33:44.413]                       is.null <- base::is.null
[13:33:44.413]                       muffled <- FALSE
[13:33:44.413]                       if (inherits(cond, "message")) {
[13:33:44.413]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:44.413]                         if (muffled) 
[13:33:44.413]                           invokeRestart("muffleMessage")
[13:33:44.413]                       }
[13:33:44.413]                       else if (inherits(cond, "warning")) {
[13:33:44.413]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:44.413]                         if (muffled) 
[13:33:44.413]                           invokeRestart("muffleWarning")
[13:33:44.413]                       }
[13:33:44.413]                       else if (inherits(cond, "condition")) {
[13:33:44.413]                         if (!is.null(pattern)) {
[13:33:44.413]                           computeRestarts <- base::computeRestarts
[13:33:44.413]                           grepl <- base::grepl
[13:33:44.413]                           restarts <- computeRestarts(cond)
[13:33:44.413]                           for (restart in restarts) {
[13:33:44.413]                             name <- restart$name
[13:33:44.413]                             if (is.null(name)) 
[13:33:44.413]                               next
[13:33:44.413]                             if (!grepl(pattern, name)) 
[13:33:44.413]                               next
[13:33:44.413]                             invokeRestart(restart)
[13:33:44.413]                             muffled <- TRUE
[13:33:44.413]                             break
[13:33:44.413]                           }
[13:33:44.413]                         }
[13:33:44.413]                       }
[13:33:44.413]                       invisible(muffled)
[13:33:44.413]                     }
[13:33:44.413]                     muffleCondition(cond, pattern = "^muffle")
[13:33:44.413]                   }
[13:33:44.413]                 }
[13:33:44.413]             }
[13:33:44.413]         }))
[13:33:44.413]     }, error = function(ex) {
[13:33:44.413]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:44.413]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:44.413]                 ...future.rng), started = ...future.startTime, 
[13:33:44.413]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:44.413]             version = "1.8"), class = "FutureResult")
[13:33:44.413]     }, finally = {
[13:33:44.413]         if (!identical(...future.workdir, getwd())) 
[13:33:44.413]             setwd(...future.workdir)
[13:33:44.413]         {
[13:33:44.413]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:44.413]                 ...future.oldOptions$nwarnings <- NULL
[13:33:44.413]             }
[13:33:44.413]             base::options(...future.oldOptions)
[13:33:44.413]             if (.Platform$OS.type == "windows") {
[13:33:44.413]                 old_names <- names(...future.oldEnvVars)
[13:33:44.413]                 envs <- base::Sys.getenv()
[13:33:44.413]                 names <- names(envs)
[13:33:44.413]                 common <- intersect(names, old_names)
[13:33:44.413]                 added <- setdiff(names, old_names)
[13:33:44.413]                 removed <- setdiff(old_names, names)
[13:33:44.413]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:44.413]                   envs[common]]
[13:33:44.413]                 NAMES <- toupper(changed)
[13:33:44.413]                 args <- list()
[13:33:44.413]                 for (kk in seq_along(NAMES)) {
[13:33:44.413]                   name <- changed[[kk]]
[13:33:44.413]                   NAME <- NAMES[[kk]]
[13:33:44.413]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.413]                     next
[13:33:44.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:44.413]                 }
[13:33:44.413]                 NAMES <- toupper(added)
[13:33:44.413]                 for (kk in seq_along(NAMES)) {
[13:33:44.413]                   name <- added[[kk]]
[13:33:44.413]                   NAME <- NAMES[[kk]]
[13:33:44.413]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.413]                     next
[13:33:44.413]                   args[[name]] <- ""
[13:33:44.413]                 }
[13:33:44.413]                 NAMES <- toupper(removed)
[13:33:44.413]                 for (kk in seq_along(NAMES)) {
[13:33:44.413]                   name <- removed[[kk]]
[13:33:44.413]                   NAME <- NAMES[[kk]]
[13:33:44.413]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.413]                     next
[13:33:44.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:44.413]                 }
[13:33:44.413]                 if (length(args) > 0) 
[13:33:44.413]                   base::do.call(base::Sys.setenv, args = args)
[13:33:44.413]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:44.413]             }
[13:33:44.413]             else {
[13:33:44.413]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:44.413]             }
[13:33:44.413]             {
[13:33:44.413]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:44.413]                   0L) {
[13:33:44.413]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:44.413]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:44.413]                   base::options(opts)
[13:33:44.413]                 }
[13:33:44.413]                 {
[13:33:44.413]                   {
[13:33:44.413]                     NULL
[13:33:44.413]                     RNGkind("Mersenne-Twister")
[13:33:44.413]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:44.413]                       inherits = FALSE)
[13:33:44.413]                   }
[13:33:44.413]                   options(future.plan = NULL)
[13:33:44.413]                   if (is.na(NA_character_)) 
[13:33:44.413]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:44.413]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:44.413]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:44.413]                     .init = FALSE)
[13:33:44.413]                 }
[13:33:44.413]             }
[13:33:44.413]         }
[13:33:44.413]     })
[13:33:44.413]     if (TRUE) {
[13:33:44.413]         base::sink(type = "output", split = FALSE)
[13:33:44.413]         if (TRUE) {
[13:33:44.413]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:44.413]         }
[13:33:44.413]         else {
[13:33:44.413]             ...future.result["stdout"] <- base::list(NULL)
[13:33:44.413]         }
[13:33:44.413]         base::close(...future.stdout)
[13:33:44.413]         ...future.stdout <- NULL
[13:33:44.413]     }
[13:33:44.413]     ...future.result$conditions <- ...future.conditions
[13:33:44.413]     ...future.result$finished <- base::Sys.time()
[13:33:44.413]     ...future.result
[13:33:44.413] }
[13:33:44.414] assign_globals() ...
[13:33:44.415] List of 5
[13:33:44.415]  $ ...future.FUN            :function (x, ...)  
[13:33:44.415]  $ future.call.arguments    : list()
[13:33:44.415]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.415]  $ ...future.elements_ii    :List of 3
[13:33:44.415]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[13:33:44.415]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:33:44.415]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:33:44.415]  $ ...future.seeds_ii       : NULL
[13:33:44.415]  $ ...future.globals.maxSize: NULL
[13:33:44.415]  - attr(*, "where")=List of 5
[13:33:44.415]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:44.415]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:44.415]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:44.415]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:44.415]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:44.415]  - attr(*, "resolved")= logi FALSE
[13:33:44.415]  - attr(*, "total_size")= num 1240
[13:33:44.415]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.415]  - attr(*, "already-done")= logi TRUE
[13:33:44.420] - copied ‘...future.FUN’ to environment
[13:33:44.420] - copied ‘future.call.arguments’ to environment
[13:33:44.420] - copied ‘...future.elements_ii’ to environment
[13:33:44.420] - copied ‘...future.seeds_ii’ to environment
[13:33:44.420] - copied ‘...future.globals.maxSize’ to environment
[13:33:44.420] assign_globals() ... done
[13:33:44.420] plan(): Setting new future strategy stack:
[13:33:44.421] List of future strategies:
[13:33:44.421] 1. sequential:
[13:33:44.421]    - args: function (..., envir = parent.frame())
[13:33:44.421]    - tweaked: FALSE
[13:33:44.421]    - call: NULL
[13:33:44.421] plan(): nbrOfWorkers() = 1
[13:33:44.422] plan(): Setting new future strategy stack:
[13:33:44.422] List of future strategies:
[13:33:44.422] 1. sequential:
[13:33:44.422]    - args: function (..., envir = parent.frame())
[13:33:44.422]    - tweaked: FALSE
[13:33:44.422]    - call: plan(strategy)
[13:33:44.422] plan(): nbrOfWorkers() = 1
[13:33:44.423] SequentialFuture started (and completed)
[13:33:44.423] - Launch lazy future ... done
[13:33:44.423] run() for ‘SequentialFuture’ ... done
[13:33:44.423] Created future:
[13:33:44.423] SequentialFuture:
[13:33:44.423] Label: ‘future_eapply-1’
[13:33:44.423] Expression:
[13:33:44.423] {
[13:33:44.423]     do.call(function(...) {
[13:33:44.423]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.423]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:44.423]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.423]             on.exit(options(oopts), add = TRUE)
[13:33:44.423]         }
[13:33:44.423]         {
[13:33:44.423]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:44.423]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.423]                 ...future.FUN(...future.X_jj, ...)
[13:33:44.423]             })
[13:33:44.423]         }
[13:33:44.423]     }, args = future.call.arguments)
[13:33:44.423] }
[13:33:44.423] Lazy evaluation: FALSE
[13:33:44.423] Asynchronous evaluation: FALSE
[13:33:44.423] Local evaluation: TRUE
[13:33:44.423] Environment: R_GlobalEnv
[13:33:44.423] Capture standard output: TRUE
[13:33:44.423] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:44.423] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:44.423] Packages: <none>
[13:33:44.423] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:44.423] Resolved: TRUE
[13:33:44.423] Value: 168 bytes of class ‘list’
[13:33:44.423] Early signaling: FALSE
[13:33:44.423] Owner process: b6e93464-7fc2-3f8d-23d1-d8004201d1f1
[13:33:44.423] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:44.425] Chunk #1 of 1 ... DONE
[13:33:44.425] Launching 1 futures (chunks) ... DONE
[13:33:44.425] Resolving 1 futures (chunks) ...
[13:33:44.425] resolve() on list ...
[13:33:44.425]  recursive: 0
[13:33:44.425]  length: 1
[13:33:44.425] 
[13:33:44.426] resolved() for ‘SequentialFuture’ ...
[13:33:44.426] - state: ‘finished’
[13:33:44.426] - run: TRUE
[13:33:44.426] - result: ‘FutureResult’
[13:33:44.426] resolved() for ‘SequentialFuture’ ... done
[13:33:44.426] Future #1
[13:33:44.427] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:44.427] - nx: 1
[13:33:44.427] - relay: TRUE
[13:33:44.427] - stdout: TRUE
[13:33:44.427] - signal: TRUE
[13:33:44.427] - resignal: FALSE
[13:33:44.427] - force: TRUE
[13:33:44.427] - relayed: [n=1] FALSE
[13:33:44.427] - queued futures: [n=1] FALSE
[13:33:44.427]  - until=1
[13:33:44.427]  - relaying element #1
[13:33:44.428] - relayed: [n=1] TRUE
[13:33:44.428] - queued futures: [n=1] TRUE
[13:33:44.428] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:44.428]  length: 0 (resolved future 1)
[13:33:44.428] Relaying remaining futures
[13:33:44.428] signalConditionsASAP(NULL, pos=0) ...
[13:33:44.428] - nx: 1
[13:33:44.428] - relay: TRUE
[13:33:44.428] - stdout: TRUE
[13:33:44.428] - signal: TRUE
[13:33:44.429] - resignal: FALSE
[13:33:44.429] - force: TRUE
[13:33:44.429] - relayed: [n=1] TRUE
[13:33:44.429] - queued futures: [n=1] TRUE
 - flush all
[13:33:44.429] - relayed: [n=1] TRUE
[13:33:44.429] - queued futures: [n=1] TRUE
[13:33:44.429] signalConditionsASAP(NULL, pos=0) ... done
[13:33:44.429] resolve() on list ... DONE
[13:33:44.429]  - Number of value chunks collected: 1
[13:33:44.429] Resolving 1 futures (chunks) ... DONE
[13:33:44.430] Reducing values from 1 chunks ...
[13:33:44.430]  - Number of values collected after concatenation: 3
[13:33:44.430]  - Number of values expected: 3
[13:33:44.430] Reducing values from 1 chunks ... DONE
[13:33:44.430] future_lapply() ... DONE
[13:33:44.432] future_lapply() ...
[13:33:44.432] Number of chunks: 1
[13:33:44.433] getGlobalsAndPackagesXApply() ...
[13:33:44.433]  - future.globals: TRUE
[13:33:44.433] getGlobalsAndPackages() ...
[13:33:44.433] Searching for globals...
[13:33:44.434] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:44.434] Searching for globals ... DONE
[13:33:44.434] Resolving globals: FALSE
[13:33:44.434] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:33:44.435] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:33:44.435] - globals: [1] ‘FUN’
[13:33:44.435] - packages: [1] ‘stats’
[13:33:44.435] getGlobalsAndPackages() ... DONE
[13:33:44.435]  - globals found/used: [n=1] ‘FUN’
[13:33:44.435]  - needed namespaces: [n=1] ‘stats’
[13:33:44.435] Finding globals ... DONE
[13:33:44.435]  - use_args: TRUE
[13:33:44.435]  - Getting '...' globals ...
[13:33:44.436] resolve() on list ...
[13:33:44.436]  recursive: 0
[13:33:44.436]  length: 1
[13:33:44.436]  elements: ‘...’
[13:33:44.436]  length: 0 (resolved future 1)
[13:33:44.436] resolve() on list ... DONE
[13:33:44.436]    - '...' content: [n=1] ‘probs’
[13:33:44.436] List of 1
[13:33:44.436]  $ ...:List of 1
[13:33:44.436]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:33:44.436]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.436]  - attr(*, "where")=List of 1
[13:33:44.436]   ..$ ...:<environment: 0x55984618f2f8> 
[13:33:44.436]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.436]  - attr(*, "resolved")= logi TRUE
[13:33:44.436]  - attr(*, "total_size")= num NA
[13:33:44.440]  - Getting '...' globals ... DONE
[13:33:44.440] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:44.441] List of 2
[13:33:44.441]  $ ...future.FUN:function (x, ...)  
[13:33:44.441]  $ ...          :List of 1
[13:33:44.441]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:33:44.441]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.441]  - attr(*, "where")=List of 2
[13:33:44.441]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:44.441]   ..$ ...          :<environment: 0x55984618f2f8> 
[13:33:44.441]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.441]  - attr(*, "resolved")= logi FALSE
[13:33:44.441]  - attr(*, "total_size")= num 1328
[13:33:44.444] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:44.444] getGlobalsAndPackagesXApply() ... DONE
[13:33:44.444] Number of futures (= number of chunks): 1
[13:33:44.444] Launching 1 futures (chunks) ...
[13:33:44.444] Chunk #1 of 1 ...
[13:33:44.444]  - Finding globals in 'X' for chunk #1 ...
[13:33:44.444] getGlobalsAndPackages() ...
[13:33:44.444] Searching for globals...
[13:33:44.445] 
[13:33:44.445] Searching for globals ... DONE
[13:33:44.445] - globals: [0] <none>
[13:33:44.445] getGlobalsAndPackages() ... DONE
[13:33:44.445]    + additional globals found: [n=0] 
[13:33:44.445]    + additional namespaces needed: [n=0] 
[13:33:44.445]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:44.445]  - seeds: <none>
[13:33:44.445]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.445] getGlobalsAndPackages() ...
[13:33:44.445] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.446] Resolving globals: FALSE
[13:33:44.446] Tweak future expression to call with '...' arguments ...
[13:33:44.446] {
[13:33:44.446]     do.call(function(...) {
[13:33:44.446]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.446]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:44.446]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.446]             on.exit(options(oopts), add = TRUE)
[13:33:44.446]         }
[13:33:44.446]         {
[13:33:44.446]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:44.446]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.446]                 ...future.FUN(...future.X_jj, ...)
[13:33:44.446]             })
[13:33:44.446]         }
[13:33:44.446]     }, args = future.call.arguments)
[13:33:44.446] }
[13:33:44.446] Tweak future expression to call with '...' arguments ... DONE
[13:33:44.446] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.446] - packages: [1] ‘stats’
[13:33:44.447] getGlobalsAndPackages() ... DONE
[13:33:44.447] run() for ‘Future’ ...
[13:33:44.447] - state: ‘created’
[13:33:44.447] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:33:44.447] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:44.447] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:44.447]   - Field: ‘label’
[13:33:44.448]   - Field: ‘local’
[13:33:44.448]   - Field: ‘owner’
[13:33:44.448]   - Field: ‘envir’
[13:33:44.448]   - Field: ‘packages’
[13:33:44.448]   - Field: ‘gc’
[13:33:44.448]   - Field: ‘conditions’
[13:33:44.448]   - Field: ‘expr’
[13:33:44.448]   - Field: ‘uuid’
[13:33:44.448]   - Field: ‘seed’
[13:33:44.448]   - Field: ‘version’
[13:33:44.448]   - Field: ‘result’
[13:33:44.449]   - Field: ‘asynchronous’
[13:33:44.449]   - Field: ‘calls’
[13:33:44.449]   - Field: ‘globals’
[13:33:44.449]   - Field: ‘stdout’
[13:33:44.449]   - Field: ‘earlySignal’
[13:33:44.449]   - Field: ‘lazy’
[13:33:44.449]   - Field: ‘state’
[13:33:44.449] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:44.449] - Launch lazy future ...
[13:33:44.449] Packages needed by the future expression (n = 1): ‘stats’
[13:33:44.450] Packages needed by future strategies (n = 0): <none>
[13:33:44.450] {
[13:33:44.450]     {
[13:33:44.450]         {
[13:33:44.450]             ...future.startTime <- base::Sys.time()
[13:33:44.450]             {
[13:33:44.450]                 {
[13:33:44.450]                   {
[13:33:44.450]                     {
[13:33:44.450]                       base::local({
[13:33:44.450]                         has_future <- base::requireNamespace("future", 
[13:33:44.450]                           quietly = TRUE)
[13:33:44.450]                         if (has_future) {
[13:33:44.450]                           ns <- base::getNamespace("future")
[13:33:44.450]                           version <- ns[[".package"]][["version"]]
[13:33:44.450]                           if (is.null(version)) 
[13:33:44.450]                             version <- utils::packageVersion("future")
[13:33:44.450]                         }
[13:33:44.450]                         else {
[13:33:44.450]                           version <- NULL
[13:33:44.450]                         }
[13:33:44.450]                         if (!has_future || version < "1.8.0") {
[13:33:44.450]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:44.450]                             "", base::R.version$version.string), 
[13:33:44.450]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:44.450]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:44.450]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:44.450]                               "release", "version")], collapse = " "), 
[13:33:44.450]                             hostname = base::Sys.info()[["nodename"]])
[13:33:44.450]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:44.450]                             info)
[13:33:44.450]                           info <- base::paste(info, collapse = "; ")
[13:33:44.450]                           if (!has_future) {
[13:33:44.450]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:44.450]                               info)
[13:33:44.450]                           }
[13:33:44.450]                           else {
[13:33:44.450]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:44.450]                               info, version)
[13:33:44.450]                           }
[13:33:44.450]                           base::stop(msg)
[13:33:44.450]                         }
[13:33:44.450]                       })
[13:33:44.450]                     }
[13:33:44.450]                     base::local({
[13:33:44.450]                       for (pkg in "stats") {
[13:33:44.450]                         base::loadNamespace(pkg)
[13:33:44.450]                         base::library(pkg, character.only = TRUE)
[13:33:44.450]                       }
[13:33:44.450]                     })
[13:33:44.450]                   }
[13:33:44.450]                   ...future.strategy.old <- future::plan("list")
[13:33:44.450]                   options(future.plan = NULL)
[13:33:44.450]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:44.450]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:44.450]                 }
[13:33:44.450]                 ...future.workdir <- getwd()
[13:33:44.450]             }
[13:33:44.450]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:44.450]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:44.450]         }
[13:33:44.450]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:44.450]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:44.450]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:44.450]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:44.450]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:44.450]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:44.450]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:44.450]             base::names(...future.oldOptions))
[13:33:44.450]     }
[13:33:44.450]     if (FALSE) {
[13:33:44.450]     }
[13:33:44.450]     else {
[13:33:44.450]         if (TRUE) {
[13:33:44.450]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:44.450]                 open = "w")
[13:33:44.450]         }
[13:33:44.450]         else {
[13:33:44.450]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:44.450]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:44.450]         }
[13:33:44.450]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:44.450]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:44.450]             base::sink(type = "output", split = FALSE)
[13:33:44.450]             base::close(...future.stdout)
[13:33:44.450]         }, add = TRUE)
[13:33:44.450]     }
[13:33:44.450]     ...future.frame <- base::sys.nframe()
[13:33:44.450]     ...future.conditions <- base::list()
[13:33:44.450]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:44.450]     if (FALSE) {
[13:33:44.450]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:44.450]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:44.450]     }
[13:33:44.450]     ...future.result <- base::tryCatch({
[13:33:44.450]         base::withCallingHandlers({
[13:33:44.450]             ...future.value <- base::withVisible(base::local({
[13:33:44.450]                 do.call(function(...) {
[13:33:44.450]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.450]                   if (!identical(...future.globals.maxSize.org, 
[13:33:44.450]                     ...future.globals.maxSize)) {
[13:33:44.450]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.450]                     on.exit(options(oopts), add = TRUE)
[13:33:44.450]                   }
[13:33:44.450]                   {
[13:33:44.450]                     lapply(seq_along(...future.elements_ii), 
[13:33:44.450]                       FUN = function(jj) {
[13:33:44.450]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.450]                         ...future.FUN(...future.X_jj, ...)
[13:33:44.450]                       })
[13:33:44.450]                   }
[13:33:44.450]                 }, args = future.call.arguments)
[13:33:44.450]             }))
[13:33:44.450]             future::FutureResult(value = ...future.value$value, 
[13:33:44.450]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:44.450]                   ...future.rng), globalenv = if (FALSE) 
[13:33:44.450]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:44.450]                     ...future.globalenv.names))
[13:33:44.450]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:44.450]         }, condition = base::local({
[13:33:44.450]             c <- base::c
[13:33:44.450]             inherits <- base::inherits
[13:33:44.450]             invokeRestart <- base::invokeRestart
[13:33:44.450]             length <- base::length
[13:33:44.450]             list <- base::list
[13:33:44.450]             seq.int <- base::seq.int
[13:33:44.450]             signalCondition <- base::signalCondition
[13:33:44.450]             sys.calls <- base::sys.calls
[13:33:44.450]             `[[` <- base::`[[`
[13:33:44.450]             `+` <- base::`+`
[13:33:44.450]             `<<-` <- base::`<<-`
[13:33:44.450]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:44.450]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:44.450]                   3L)]
[13:33:44.450]             }
[13:33:44.450]             function(cond) {
[13:33:44.450]                 is_error <- inherits(cond, "error")
[13:33:44.450]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:44.450]                   NULL)
[13:33:44.450]                 if (is_error) {
[13:33:44.450]                   sessionInformation <- function() {
[13:33:44.450]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:44.450]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:44.450]                       search = base::search(), system = base::Sys.info())
[13:33:44.450]                   }
[13:33:44.450]                   ...future.conditions[[length(...future.conditions) + 
[13:33:44.450]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:44.450]                     cond$call), session = sessionInformation(), 
[13:33:44.450]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:44.450]                   signalCondition(cond)
[13:33:44.450]                 }
[13:33:44.450]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:44.450]                 "immediateCondition"))) {
[13:33:44.450]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:44.450]                   ...future.conditions[[length(...future.conditions) + 
[13:33:44.450]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:44.450]                   if (TRUE && !signal) {
[13:33:44.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.450]                     {
[13:33:44.450]                       inherits <- base::inherits
[13:33:44.450]                       invokeRestart <- base::invokeRestart
[13:33:44.450]                       is.null <- base::is.null
[13:33:44.450]                       muffled <- FALSE
[13:33:44.450]                       if (inherits(cond, "message")) {
[13:33:44.450]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:44.450]                         if (muffled) 
[13:33:44.450]                           invokeRestart("muffleMessage")
[13:33:44.450]                       }
[13:33:44.450]                       else if (inherits(cond, "warning")) {
[13:33:44.450]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:44.450]                         if (muffled) 
[13:33:44.450]                           invokeRestart("muffleWarning")
[13:33:44.450]                       }
[13:33:44.450]                       else if (inherits(cond, "condition")) {
[13:33:44.450]                         if (!is.null(pattern)) {
[13:33:44.450]                           computeRestarts <- base::computeRestarts
[13:33:44.450]                           grepl <- base::grepl
[13:33:44.450]                           restarts <- computeRestarts(cond)
[13:33:44.450]                           for (restart in restarts) {
[13:33:44.450]                             name <- restart$name
[13:33:44.450]                             if (is.null(name)) 
[13:33:44.450]                               next
[13:33:44.450]                             if (!grepl(pattern, name)) 
[13:33:44.450]                               next
[13:33:44.450]                             invokeRestart(restart)
[13:33:44.450]                             muffled <- TRUE
[13:33:44.450]                             break
[13:33:44.450]                           }
[13:33:44.450]                         }
[13:33:44.450]                       }
[13:33:44.450]                       invisible(muffled)
[13:33:44.450]                     }
[13:33:44.450]                     muffleCondition(cond, pattern = "^muffle")
[13:33:44.450]                   }
[13:33:44.450]                 }
[13:33:44.450]                 else {
[13:33:44.450]                   if (TRUE) {
[13:33:44.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.450]                     {
[13:33:44.450]                       inherits <- base::inherits
[13:33:44.450]                       invokeRestart <- base::invokeRestart
[13:33:44.450]                       is.null <- base::is.null
[13:33:44.450]                       muffled <- FALSE
[13:33:44.450]                       if (inherits(cond, "message")) {
[13:33:44.450]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:44.450]                         if (muffled) 
[13:33:44.450]                           invokeRestart("muffleMessage")
[13:33:44.450]                       }
[13:33:44.450]                       else if (inherits(cond, "warning")) {
[13:33:44.450]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:44.450]                         if (muffled) 
[13:33:44.450]                           invokeRestart("muffleWarning")
[13:33:44.450]                       }
[13:33:44.450]                       else if (inherits(cond, "condition")) {
[13:33:44.450]                         if (!is.null(pattern)) {
[13:33:44.450]                           computeRestarts <- base::computeRestarts
[13:33:44.450]                           grepl <- base::grepl
[13:33:44.450]                           restarts <- computeRestarts(cond)
[13:33:44.450]                           for (restart in restarts) {
[13:33:44.450]                             name <- restart$name
[13:33:44.450]                             if (is.null(name)) 
[13:33:44.450]                               next
[13:33:44.450]                             if (!grepl(pattern, name)) 
[13:33:44.450]                               next
[13:33:44.450]                             invokeRestart(restart)
[13:33:44.450]                             muffled <- TRUE
[13:33:44.450]                             break
[13:33:44.450]                           }
[13:33:44.450]                         }
[13:33:44.450]                       }
[13:33:44.450]                       invisible(muffled)
[13:33:44.450]                     }
[13:33:44.450]                     muffleCondition(cond, pattern = "^muffle")
[13:33:44.450]                   }
[13:33:44.450]                 }
[13:33:44.450]             }
[13:33:44.450]         }))
[13:33:44.450]     }, error = function(ex) {
[13:33:44.450]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:44.450]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:44.450]                 ...future.rng), started = ...future.startTime, 
[13:33:44.450]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:44.450]             version = "1.8"), class = "FutureResult")
[13:33:44.450]     }, finally = {
[13:33:44.450]         if (!identical(...future.workdir, getwd())) 
[13:33:44.450]             setwd(...future.workdir)
[13:33:44.450]         {
[13:33:44.450]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:44.450]                 ...future.oldOptions$nwarnings <- NULL
[13:33:44.450]             }
[13:33:44.450]             base::options(...future.oldOptions)
[13:33:44.450]             if (.Platform$OS.type == "windows") {
[13:33:44.450]                 old_names <- names(...future.oldEnvVars)
[13:33:44.450]                 envs <- base::Sys.getenv()
[13:33:44.450]                 names <- names(envs)
[13:33:44.450]                 common <- intersect(names, old_names)
[13:33:44.450]                 added <- setdiff(names, old_names)
[13:33:44.450]                 removed <- setdiff(old_names, names)
[13:33:44.450]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:44.450]                   envs[common]]
[13:33:44.450]                 NAMES <- toupper(changed)
[13:33:44.450]                 args <- list()
[13:33:44.450]                 for (kk in seq_along(NAMES)) {
[13:33:44.450]                   name <- changed[[kk]]
[13:33:44.450]                   NAME <- NAMES[[kk]]
[13:33:44.450]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.450]                     next
[13:33:44.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:44.450]                 }
[13:33:44.450]                 NAMES <- toupper(added)
[13:33:44.450]                 for (kk in seq_along(NAMES)) {
[13:33:44.450]                   name <- added[[kk]]
[13:33:44.450]                   NAME <- NAMES[[kk]]
[13:33:44.450]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.450]                     next
[13:33:44.450]                   args[[name]] <- ""
[13:33:44.450]                 }
[13:33:44.450]                 NAMES <- toupper(removed)
[13:33:44.450]                 for (kk in seq_along(NAMES)) {
[13:33:44.450]                   name <- removed[[kk]]
[13:33:44.450]                   NAME <- NAMES[[kk]]
[13:33:44.450]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.450]                     next
[13:33:44.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:44.450]                 }
[13:33:44.450]                 if (length(args) > 0) 
[13:33:44.450]                   base::do.call(base::Sys.setenv, args = args)
[13:33:44.450]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:44.450]             }
[13:33:44.450]             else {
[13:33:44.450]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:44.450]             }
[13:33:44.450]             {
[13:33:44.450]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:44.450]                   0L) {
[13:33:44.450]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:44.450]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:44.450]                   base::options(opts)
[13:33:44.450]                 }
[13:33:44.450]                 {
[13:33:44.450]                   {
[13:33:44.450]                     NULL
[13:33:44.450]                     RNGkind("Mersenne-Twister")
[13:33:44.450]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:44.450]                       inherits = FALSE)
[13:33:44.450]                   }
[13:33:44.450]                   options(future.plan = NULL)
[13:33:44.450]                   if (is.na(NA_character_)) 
[13:33:44.450]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:44.450]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:44.450]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:44.450]                     .init = FALSE)
[13:33:44.450]                 }
[13:33:44.450]             }
[13:33:44.450]         }
[13:33:44.450]     })
[13:33:44.450]     if (TRUE) {
[13:33:44.450]         base::sink(type = "output", split = FALSE)
[13:33:44.450]         if (TRUE) {
[13:33:44.450]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:44.450]         }
[13:33:44.450]         else {
[13:33:44.450]             ...future.result["stdout"] <- base::list(NULL)
[13:33:44.450]         }
[13:33:44.450]         base::close(...future.stdout)
[13:33:44.450]         ...future.stdout <- NULL
[13:33:44.450]     }
[13:33:44.450]     ...future.result$conditions <- ...future.conditions
[13:33:44.450]     ...future.result$finished <- base::Sys.time()
[13:33:44.450]     ...future.result
[13:33:44.450] }
[13:33:44.452] assign_globals() ...
[13:33:44.452] List of 5
[13:33:44.452]  $ ...future.FUN            :function (x, ...)  
[13:33:44.452]  $ future.call.arguments    :List of 1
[13:33:44.452]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:33:44.452]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.452]  $ ...future.elements_ii    :List of 3
[13:33:44.452]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[13:33:44.452]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:33:44.452]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:33:44.452]  $ ...future.seeds_ii       : NULL
[13:33:44.452]  $ ...future.globals.maxSize: NULL
[13:33:44.452]  - attr(*, "where")=List of 5
[13:33:44.452]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:44.452]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:44.452]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:44.452]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:44.452]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:44.452]  - attr(*, "resolved")= logi FALSE
[13:33:44.452]  - attr(*, "total_size")= num 1328
[13:33:44.452]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.452]  - attr(*, "already-done")= logi TRUE
[13:33:44.457] - copied ‘...future.FUN’ to environment
[13:33:44.457] - copied ‘future.call.arguments’ to environment
[13:33:44.457] - copied ‘...future.elements_ii’ to environment
[13:33:44.457] - copied ‘...future.seeds_ii’ to environment
[13:33:44.457] - copied ‘...future.globals.maxSize’ to environment
[13:33:44.458] assign_globals() ... done
[13:33:44.458] plan(): Setting new future strategy stack:
[13:33:44.458] List of future strategies:
[13:33:44.458] 1. sequential:
[13:33:44.458]    - args: function (..., envir = parent.frame())
[13:33:44.458]    - tweaked: FALSE
[13:33:44.458]    - call: NULL
[13:33:44.458] plan(): nbrOfWorkers() = 1
[13:33:44.459] plan(): Setting new future strategy stack:
[13:33:44.459] List of future strategies:
[13:33:44.459] 1. sequential:
[13:33:44.459]    - args: function (..., envir = parent.frame())
[13:33:44.459]    - tweaked: FALSE
[13:33:44.459]    - call: plan(strategy)
[13:33:44.460] plan(): nbrOfWorkers() = 1
[13:33:44.460] SequentialFuture started (and completed)
[13:33:44.460] - Launch lazy future ... done
[13:33:44.460] run() for ‘SequentialFuture’ ... done
[13:33:44.460] Created future:
[13:33:44.460] SequentialFuture:
[13:33:44.460] Label: ‘future_eapply-1’
[13:33:44.460] Expression:
[13:33:44.460] {
[13:33:44.460]     do.call(function(...) {
[13:33:44.460]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.460]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:44.460]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.460]             on.exit(options(oopts), add = TRUE)
[13:33:44.460]         }
[13:33:44.460]         {
[13:33:44.460]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:44.460]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.460]                 ...future.FUN(...future.X_jj, ...)
[13:33:44.460]             })
[13:33:44.460]         }
[13:33:44.460]     }, args = future.call.arguments)
[13:33:44.460] }
[13:33:44.460] Lazy evaluation: FALSE
[13:33:44.460] Asynchronous evaluation: FALSE
[13:33:44.460] Local evaluation: TRUE
[13:33:44.460] Environment: R_GlobalEnv
[13:33:44.460] Capture standard output: TRUE
[13:33:44.460] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:44.460] Globals: 5 objects totaling 1.56 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:44.460] Packages: 1 packages (‘stats’)
[13:33:44.460] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:44.460] Resolved: TRUE
[13:33:44.460] Value: 1.29 KiB of class ‘list’
[13:33:44.460] Early signaling: FALSE
[13:33:44.460] Owner process: b6e93464-7fc2-3f8d-23d1-d8004201d1f1
[13:33:44.460] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:44.461] Chunk #1 of 1 ... DONE
[13:33:44.461] Launching 1 futures (chunks) ... DONE
[13:33:44.461] Resolving 1 futures (chunks) ...
[13:33:44.462] resolve() on list ...
[13:33:44.462]  recursive: 0
[13:33:44.462]  length: 1
[13:33:44.462] 
[13:33:44.462] resolved() for ‘SequentialFuture’ ...
[13:33:44.462] - state: ‘finished’
[13:33:44.462] - run: TRUE
[13:33:44.462] - result: ‘FutureResult’
[13:33:44.462] resolved() for ‘SequentialFuture’ ... done
[13:33:44.462] Future #1
[13:33:44.463] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:44.463] - nx: 1
[13:33:44.464] - relay: TRUE
[13:33:44.464] - stdout: TRUE
[13:33:44.464] - signal: TRUE
[13:33:44.464] - resignal: FALSE
[13:33:44.464] - force: TRUE
[13:33:44.464] - relayed: [n=1] FALSE
[13:33:44.464] - queued futures: [n=1] FALSE
[13:33:44.464]  - until=1
[13:33:44.464]  - relaying element #1
[13:33:44.464] - relayed: [n=1] TRUE
[13:33:44.464] - queued futures: [n=1] TRUE
[13:33:44.465] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:44.465]  length: 0 (resolved future 1)
[13:33:44.465] Relaying remaining futures
[13:33:44.465] signalConditionsASAP(NULL, pos=0) ...
[13:33:44.465] - nx: 1
[13:33:44.465] - relay: TRUE
[13:33:44.465] - stdout: TRUE
[13:33:44.465] - signal: TRUE
[13:33:44.465] - resignal: FALSE
[13:33:44.465] - force: TRUE
[13:33:44.465] - relayed: [n=1] TRUE
[13:33:44.465] - queued futures: [n=1] TRUE
 - flush all
[13:33:44.466] - relayed: [n=1] TRUE
[13:33:44.466] - queued futures: [n=1] TRUE
[13:33:44.466] signalConditionsASAP(NULL, pos=0) ... done
[13:33:44.466] resolve() on list ... DONE
[13:33:44.466]  - Number of value chunks collected: 1
[13:33:44.466] Resolving 1 futures (chunks) ... DONE
[13:33:44.466] Reducing values from 1 chunks ...
[13:33:44.466]  - Number of values collected after concatenation: 3
[13:33:44.466]  - Number of values expected: 3
[13:33:44.466] Reducing values from 1 chunks ... DONE
[13:33:44.467] future_lapply() ... DONE
[13:33:44.468] future_lapply() ...
[13:33:44.468] Number of chunks: 1
[13:33:44.468] getGlobalsAndPackagesXApply() ...
[13:33:44.468]  - future.globals: TRUE
[13:33:44.469] getGlobalsAndPackages() ...
[13:33:44.469] Searching for globals...
[13:33:44.470] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:44.470] Searching for globals ... DONE
[13:33:44.470] Resolving globals: FALSE
[13:33:44.470] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:33:44.470] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:33:44.471] - globals: [1] ‘FUN’
[13:33:44.471] - packages: [1] ‘stats’
[13:33:44.471] getGlobalsAndPackages() ... DONE
[13:33:44.471]  - globals found/used: [n=1] ‘FUN’
[13:33:44.471]  - needed namespaces: [n=1] ‘stats’
[13:33:44.471] Finding globals ... DONE
[13:33:44.471]  - use_args: TRUE
[13:33:44.471]  - Getting '...' globals ...
[13:33:44.471] resolve() on list ...
[13:33:44.472]  recursive: 0
[13:33:44.472]  length: 1
[13:33:44.472]  elements: ‘...’
[13:33:44.472]  length: 0 (resolved future 1)
[13:33:44.472] resolve() on list ... DONE
[13:33:44.472]    - '...' content: [n=0] 
[13:33:44.472] List of 1
[13:33:44.472]  $ ...: list()
[13:33:44.472]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.472]  - attr(*, "where")=List of 1
[13:33:44.472]   ..$ ...:<environment: 0x559844150760> 
[13:33:44.472]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.472]  - attr(*, "resolved")= logi TRUE
[13:33:44.472]  - attr(*, "total_size")= num NA
[13:33:44.474]  - Getting '...' globals ... DONE
[13:33:44.475] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:44.475] List of 2
[13:33:44.475]  $ ...future.FUN:function (x, ...)  
[13:33:44.475]  $ ...          : list()
[13:33:44.475]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.475]  - attr(*, "where")=List of 2
[13:33:44.475]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:44.475]   ..$ ...          :<environment: 0x559844150760> 
[13:33:44.475]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.475]  - attr(*, "resolved")= logi FALSE
[13:33:44.475]  - attr(*, "total_size")= num 1248
[13:33:44.477] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:44.477] getGlobalsAndPackagesXApply() ... DONE
[13:33:44.477] Number of futures (= number of chunks): 1
[13:33:44.477] Launching 1 futures (chunks) ...
[13:33:44.478] Chunk #1 of 1 ...
[13:33:44.478]  - Finding globals in 'X' for chunk #1 ...
[13:33:44.478] getGlobalsAndPackages() ...
[13:33:44.478] Searching for globals...
[13:33:44.478] 
[13:33:44.478] Searching for globals ... DONE
[13:33:44.478] - globals: [0] <none>
[13:33:44.478] getGlobalsAndPackages() ... DONE
[13:33:44.478]    + additional globals found: [n=0] 
[13:33:44.479]    + additional namespaces needed: [n=0] 
[13:33:44.479]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:44.479]  - seeds: <none>
[13:33:44.479]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.479] getGlobalsAndPackages() ...
[13:33:44.479] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.479] Resolving globals: FALSE
[13:33:44.479] Tweak future expression to call with '...' arguments ...
[13:33:44.479] {
[13:33:44.479]     do.call(function(...) {
[13:33:44.479]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.479]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:44.479]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.479]             on.exit(options(oopts), add = TRUE)
[13:33:44.479]         }
[13:33:44.479]         {
[13:33:44.479]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:44.479]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.479]                 ...future.FUN(...future.X_jj, ...)
[13:33:44.479]             })
[13:33:44.479]         }
[13:33:44.479]     }, args = future.call.arguments)
[13:33:44.479] }
[13:33:44.480] Tweak future expression to call with '...' arguments ... DONE
[13:33:44.480] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.480] - packages: [1] ‘stats’
[13:33:44.480] getGlobalsAndPackages() ... DONE
[13:33:44.480] run() for ‘Future’ ...
[13:33:44.480] - state: ‘created’
[13:33:44.480] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:33:44.481] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:44.481] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:44.481]   - Field: ‘label’
[13:33:44.481]   - Field: ‘local’
[13:33:44.481]   - Field: ‘owner’
[13:33:44.481]   - Field: ‘envir’
[13:33:44.481]   - Field: ‘packages’
[13:33:44.481]   - Field: ‘gc’
[13:33:44.481]   - Field: ‘conditions’
[13:33:44.482]   - Field: ‘expr’
[13:33:44.482]   - Field: ‘uuid’
[13:33:44.482]   - Field: ‘seed’
[13:33:44.482]   - Field: ‘version’
[13:33:44.482]   - Field: ‘result’
[13:33:44.482]   - Field: ‘asynchronous’
[13:33:44.482]   - Field: ‘calls’
[13:33:44.482]   - Field: ‘globals’
[13:33:44.482]   - Field: ‘stdout’
[13:33:44.482]   - Field: ‘earlySignal’
[13:33:44.482]   - Field: ‘lazy’
[13:33:44.483]   - Field: ‘state’
[13:33:44.483] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:44.483] - Launch lazy future ...
[13:33:44.483] Packages needed by the future expression (n = 1): ‘stats’
[13:33:44.483] Packages needed by future strategies (n = 0): <none>
[13:33:44.483] {
[13:33:44.483]     {
[13:33:44.483]         {
[13:33:44.483]             ...future.startTime <- base::Sys.time()
[13:33:44.483]             {
[13:33:44.483]                 {
[13:33:44.483]                   {
[13:33:44.483]                     {
[13:33:44.483]                       base::local({
[13:33:44.483]                         has_future <- base::requireNamespace("future", 
[13:33:44.483]                           quietly = TRUE)
[13:33:44.483]                         if (has_future) {
[13:33:44.483]                           ns <- base::getNamespace("future")
[13:33:44.483]                           version <- ns[[".package"]][["version"]]
[13:33:44.483]                           if (is.null(version)) 
[13:33:44.483]                             version <- utils::packageVersion("future")
[13:33:44.483]                         }
[13:33:44.483]                         else {
[13:33:44.483]                           version <- NULL
[13:33:44.483]                         }
[13:33:44.483]                         if (!has_future || version < "1.8.0") {
[13:33:44.483]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:44.483]                             "", base::R.version$version.string), 
[13:33:44.483]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:44.483]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:44.483]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:44.483]                               "release", "version")], collapse = " "), 
[13:33:44.483]                             hostname = base::Sys.info()[["nodename"]])
[13:33:44.483]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:44.483]                             info)
[13:33:44.483]                           info <- base::paste(info, collapse = "; ")
[13:33:44.483]                           if (!has_future) {
[13:33:44.483]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:44.483]                               info)
[13:33:44.483]                           }
[13:33:44.483]                           else {
[13:33:44.483]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:44.483]                               info, version)
[13:33:44.483]                           }
[13:33:44.483]                           base::stop(msg)
[13:33:44.483]                         }
[13:33:44.483]                       })
[13:33:44.483]                     }
[13:33:44.483]                     base::local({
[13:33:44.483]                       for (pkg in "stats") {
[13:33:44.483]                         base::loadNamespace(pkg)
[13:33:44.483]                         base::library(pkg, character.only = TRUE)
[13:33:44.483]                       }
[13:33:44.483]                     })
[13:33:44.483]                   }
[13:33:44.483]                   ...future.strategy.old <- future::plan("list")
[13:33:44.483]                   options(future.plan = NULL)
[13:33:44.483]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:44.483]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:44.483]                 }
[13:33:44.483]                 ...future.workdir <- getwd()
[13:33:44.483]             }
[13:33:44.483]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:44.483]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:44.483]         }
[13:33:44.483]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:44.483]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:44.483]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:44.483]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:44.483]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:44.483]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:44.483]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:44.483]             base::names(...future.oldOptions))
[13:33:44.483]     }
[13:33:44.483]     if (FALSE) {
[13:33:44.483]     }
[13:33:44.483]     else {
[13:33:44.483]         if (TRUE) {
[13:33:44.483]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:44.483]                 open = "w")
[13:33:44.483]         }
[13:33:44.483]         else {
[13:33:44.483]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:44.483]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:44.483]         }
[13:33:44.483]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:44.483]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:44.483]             base::sink(type = "output", split = FALSE)
[13:33:44.483]             base::close(...future.stdout)
[13:33:44.483]         }, add = TRUE)
[13:33:44.483]     }
[13:33:44.483]     ...future.frame <- base::sys.nframe()
[13:33:44.483]     ...future.conditions <- base::list()
[13:33:44.483]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:44.483]     if (FALSE) {
[13:33:44.483]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:44.483]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:44.483]     }
[13:33:44.483]     ...future.result <- base::tryCatch({
[13:33:44.483]         base::withCallingHandlers({
[13:33:44.483]             ...future.value <- base::withVisible(base::local({
[13:33:44.483]                 do.call(function(...) {
[13:33:44.483]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.483]                   if (!identical(...future.globals.maxSize.org, 
[13:33:44.483]                     ...future.globals.maxSize)) {
[13:33:44.483]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.483]                     on.exit(options(oopts), add = TRUE)
[13:33:44.483]                   }
[13:33:44.483]                   {
[13:33:44.483]                     lapply(seq_along(...future.elements_ii), 
[13:33:44.483]                       FUN = function(jj) {
[13:33:44.483]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.483]                         ...future.FUN(...future.X_jj, ...)
[13:33:44.483]                       })
[13:33:44.483]                   }
[13:33:44.483]                 }, args = future.call.arguments)
[13:33:44.483]             }))
[13:33:44.483]             future::FutureResult(value = ...future.value$value, 
[13:33:44.483]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:44.483]                   ...future.rng), globalenv = if (FALSE) 
[13:33:44.483]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:44.483]                     ...future.globalenv.names))
[13:33:44.483]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:44.483]         }, condition = base::local({
[13:33:44.483]             c <- base::c
[13:33:44.483]             inherits <- base::inherits
[13:33:44.483]             invokeRestart <- base::invokeRestart
[13:33:44.483]             length <- base::length
[13:33:44.483]             list <- base::list
[13:33:44.483]             seq.int <- base::seq.int
[13:33:44.483]             signalCondition <- base::signalCondition
[13:33:44.483]             sys.calls <- base::sys.calls
[13:33:44.483]             `[[` <- base::`[[`
[13:33:44.483]             `+` <- base::`+`
[13:33:44.483]             `<<-` <- base::`<<-`
[13:33:44.483]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:44.483]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:44.483]                   3L)]
[13:33:44.483]             }
[13:33:44.483]             function(cond) {
[13:33:44.483]                 is_error <- inherits(cond, "error")
[13:33:44.483]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:44.483]                   NULL)
[13:33:44.483]                 if (is_error) {
[13:33:44.483]                   sessionInformation <- function() {
[13:33:44.483]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:44.483]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:44.483]                       search = base::search(), system = base::Sys.info())
[13:33:44.483]                   }
[13:33:44.483]                   ...future.conditions[[length(...future.conditions) + 
[13:33:44.483]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:44.483]                     cond$call), session = sessionInformation(), 
[13:33:44.483]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:44.483]                   signalCondition(cond)
[13:33:44.483]                 }
[13:33:44.483]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:44.483]                 "immediateCondition"))) {
[13:33:44.483]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:44.483]                   ...future.conditions[[length(...future.conditions) + 
[13:33:44.483]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:44.483]                   if (TRUE && !signal) {
[13:33:44.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.483]                     {
[13:33:44.483]                       inherits <- base::inherits
[13:33:44.483]                       invokeRestart <- base::invokeRestart
[13:33:44.483]                       is.null <- base::is.null
[13:33:44.483]                       muffled <- FALSE
[13:33:44.483]                       if (inherits(cond, "message")) {
[13:33:44.483]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:44.483]                         if (muffled) 
[13:33:44.483]                           invokeRestart("muffleMessage")
[13:33:44.483]                       }
[13:33:44.483]                       else if (inherits(cond, "warning")) {
[13:33:44.483]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:44.483]                         if (muffled) 
[13:33:44.483]                           invokeRestart("muffleWarning")
[13:33:44.483]                       }
[13:33:44.483]                       else if (inherits(cond, "condition")) {
[13:33:44.483]                         if (!is.null(pattern)) {
[13:33:44.483]                           computeRestarts <- base::computeRestarts
[13:33:44.483]                           grepl <- base::grepl
[13:33:44.483]                           restarts <- computeRestarts(cond)
[13:33:44.483]                           for (restart in restarts) {
[13:33:44.483]                             name <- restart$name
[13:33:44.483]                             if (is.null(name)) 
[13:33:44.483]                               next
[13:33:44.483]                             if (!grepl(pattern, name)) 
[13:33:44.483]                               next
[13:33:44.483]                             invokeRestart(restart)
[13:33:44.483]                             muffled <- TRUE
[13:33:44.483]                             break
[13:33:44.483]                           }
[13:33:44.483]                         }
[13:33:44.483]                       }
[13:33:44.483]                       invisible(muffled)
[13:33:44.483]                     }
[13:33:44.483]                     muffleCondition(cond, pattern = "^muffle")
[13:33:44.483]                   }
[13:33:44.483]                 }
[13:33:44.483]                 else {
[13:33:44.483]                   if (TRUE) {
[13:33:44.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.483]                     {
[13:33:44.483]                       inherits <- base::inherits
[13:33:44.483]                       invokeRestart <- base::invokeRestart
[13:33:44.483]                       is.null <- base::is.null
[13:33:44.483]                       muffled <- FALSE
[13:33:44.483]                       if (inherits(cond, "message")) {
[13:33:44.483]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:44.483]                         if (muffled) 
[13:33:44.483]                           invokeRestart("muffleMessage")
[13:33:44.483]                       }
[13:33:44.483]                       else if (inherits(cond, "warning")) {
[13:33:44.483]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:44.483]                         if (muffled) 
[13:33:44.483]                           invokeRestart("muffleWarning")
[13:33:44.483]                       }
[13:33:44.483]                       else if (inherits(cond, "condition")) {
[13:33:44.483]                         if (!is.null(pattern)) {
[13:33:44.483]                           computeRestarts <- base::computeRestarts
[13:33:44.483]                           grepl <- base::grepl
[13:33:44.483]                           restarts <- computeRestarts(cond)
[13:33:44.483]                           for (restart in restarts) {
[13:33:44.483]                             name <- restart$name
[13:33:44.483]                             if (is.null(name)) 
[13:33:44.483]                               next
[13:33:44.483]                             if (!grepl(pattern, name)) 
[13:33:44.483]                               next
[13:33:44.483]                             invokeRestart(restart)
[13:33:44.483]                             muffled <- TRUE
[13:33:44.483]                             break
[13:33:44.483]                           }
[13:33:44.483]                         }
[13:33:44.483]                       }
[13:33:44.483]                       invisible(muffled)
[13:33:44.483]                     }
[13:33:44.483]                     muffleCondition(cond, pattern = "^muffle")
[13:33:44.483]                   }
[13:33:44.483]                 }
[13:33:44.483]             }
[13:33:44.483]         }))
[13:33:44.483]     }, error = function(ex) {
[13:33:44.483]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:44.483]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:44.483]                 ...future.rng), started = ...future.startTime, 
[13:33:44.483]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:44.483]             version = "1.8"), class = "FutureResult")
[13:33:44.483]     }, finally = {
[13:33:44.483]         if (!identical(...future.workdir, getwd())) 
[13:33:44.483]             setwd(...future.workdir)
[13:33:44.483]         {
[13:33:44.483]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:44.483]                 ...future.oldOptions$nwarnings <- NULL
[13:33:44.483]             }
[13:33:44.483]             base::options(...future.oldOptions)
[13:33:44.483]             if (.Platform$OS.type == "windows") {
[13:33:44.483]                 old_names <- names(...future.oldEnvVars)
[13:33:44.483]                 envs <- base::Sys.getenv()
[13:33:44.483]                 names <- names(envs)
[13:33:44.483]                 common <- intersect(names, old_names)
[13:33:44.483]                 added <- setdiff(names, old_names)
[13:33:44.483]                 removed <- setdiff(old_names, names)
[13:33:44.483]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:44.483]                   envs[common]]
[13:33:44.483]                 NAMES <- toupper(changed)
[13:33:44.483]                 args <- list()
[13:33:44.483]                 for (kk in seq_along(NAMES)) {
[13:33:44.483]                   name <- changed[[kk]]
[13:33:44.483]                   NAME <- NAMES[[kk]]
[13:33:44.483]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.483]                     next
[13:33:44.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:44.483]                 }
[13:33:44.483]                 NAMES <- toupper(added)
[13:33:44.483]                 for (kk in seq_along(NAMES)) {
[13:33:44.483]                   name <- added[[kk]]
[13:33:44.483]                   NAME <- NAMES[[kk]]
[13:33:44.483]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.483]                     next
[13:33:44.483]                   args[[name]] <- ""
[13:33:44.483]                 }
[13:33:44.483]                 NAMES <- toupper(removed)
[13:33:44.483]                 for (kk in seq_along(NAMES)) {
[13:33:44.483]                   name <- removed[[kk]]
[13:33:44.483]                   NAME <- NAMES[[kk]]
[13:33:44.483]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.483]                     next
[13:33:44.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:44.483]                 }
[13:33:44.483]                 if (length(args) > 0) 
[13:33:44.483]                   base::do.call(base::Sys.setenv, args = args)
[13:33:44.483]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:44.483]             }
[13:33:44.483]             else {
[13:33:44.483]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:44.483]             }
[13:33:44.483]             {
[13:33:44.483]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:44.483]                   0L) {
[13:33:44.483]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:44.483]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:44.483]                   base::options(opts)
[13:33:44.483]                 }
[13:33:44.483]                 {
[13:33:44.483]                   {
[13:33:44.483]                     NULL
[13:33:44.483]                     RNGkind("Mersenne-Twister")
[13:33:44.483]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:44.483]                       inherits = FALSE)
[13:33:44.483]                   }
[13:33:44.483]                   options(future.plan = NULL)
[13:33:44.483]                   if (is.na(NA_character_)) 
[13:33:44.483]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:44.483]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:44.483]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:44.483]                     .init = FALSE)
[13:33:44.483]                 }
[13:33:44.483]             }
[13:33:44.483]         }
[13:33:44.483]     })
[13:33:44.483]     if (TRUE) {
[13:33:44.483]         base::sink(type = "output", split = FALSE)
[13:33:44.483]         if (TRUE) {
[13:33:44.483]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:44.483]         }
[13:33:44.483]         else {
[13:33:44.483]             ...future.result["stdout"] <- base::list(NULL)
[13:33:44.483]         }
[13:33:44.483]         base::close(...future.stdout)
[13:33:44.483]         ...future.stdout <- NULL
[13:33:44.483]     }
[13:33:44.483]     ...future.result$conditions <- ...future.conditions
[13:33:44.483]     ...future.result$finished <- base::Sys.time()
[13:33:44.483]     ...future.result
[13:33:44.483] }
[13:33:44.485] assign_globals() ...
[13:33:44.485] List of 5
[13:33:44.485]  $ ...future.FUN            :function (x, ...)  
[13:33:44.485]  $ future.call.arguments    : list()
[13:33:44.485]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.485]  $ ...future.elements_ii    :List of 3
[13:33:44.485]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[13:33:44.485]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:33:44.485]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:33:44.485]  $ ...future.seeds_ii       : NULL
[13:33:44.485]  $ ...future.globals.maxSize: NULL
[13:33:44.485]  - attr(*, "where")=List of 5
[13:33:44.485]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:44.485]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:44.485]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:44.485]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:44.485]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:44.485]  - attr(*, "resolved")= logi FALSE
[13:33:44.485]  - attr(*, "total_size")= num 1248
[13:33:44.485]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.485]  - attr(*, "already-done")= logi TRUE
[13:33:44.491] - copied ‘...future.FUN’ to environment
[13:33:44.491] - copied ‘future.call.arguments’ to environment
[13:33:44.491] - copied ‘...future.elements_ii’ to environment
[13:33:44.491] - copied ‘...future.seeds_ii’ to environment
[13:33:44.491] - copied ‘...future.globals.maxSize’ to environment
[13:33:44.491] assign_globals() ... done
[13:33:44.492] plan(): Setting new future strategy stack:
[13:33:44.492] List of future strategies:
[13:33:44.492] 1. sequential:
[13:33:44.492]    - args: function (..., envir = parent.frame())
[13:33:44.492]    - tweaked: FALSE
[13:33:44.492]    - call: NULL
[13:33:44.492] plan(): nbrOfWorkers() = 1
[13:33:44.493] plan(): Setting new future strategy stack:
[13:33:44.493] List of future strategies:
[13:33:44.493] 1. sequential:
[13:33:44.493]    - args: function (..., envir = parent.frame())
[13:33:44.493]    - tweaked: FALSE
[13:33:44.493]    - call: plan(strategy)
[13:33:44.494] plan(): nbrOfWorkers() = 1
[13:33:44.494] SequentialFuture started (and completed)
[13:33:44.494] - Launch lazy future ... done
[13:33:44.494] run() for ‘SequentialFuture’ ... done
[13:33:44.494] Created future:
[13:33:44.494] SequentialFuture:
[13:33:44.494] Label: ‘future_eapply-1’
[13:33:44.494] Expression:
[13:33:44.494] {
[13:33:44.494]     do.call(function(...) {
[13:33:44.494]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.494]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:44.494]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.494]             on.exit(options(oopts), add = TRUE)
[13:33:44.494]         }
[13:33:44.494]         {
[13:33:44.494]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:44.494]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.494]                 ...future.FUN(...future.X_jj, ...)
[13:33:44.494]             })
[13:33:44.494]         }
[13:33:44.494]     }, args = future.call.arguments)
[13:33:44.494] }
[13:33:44.494] Lazy evaluation: FALSE
[13:33:44.494] Asynchronous evaluation: FALSE
[13:33:44.494] Local evaluation: TRUE
[13:33:44.494] Environment: R_GlobalEnv
[13:33:44.494] Capture standard output: TRUE
[13:33:44.494] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:44.494] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:44.494] Packages: 1 packages (‘stats’)
[13:33:44.494] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:44.494] Resolved: TRUE
[13:33:44.494] Value: 1.71 KiB of class ‘list’
[13:33:44.494] Early signaling: FALSE
[13:33:44.494] Owner process: b6e93464-7fc2-3f8d-23d1-d8004201d1f1
[13:33:44.494] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:44.495] Chunk #1 of 1 ... DONE
[13:33:44.495] Launching 1 futures (chunks) ... DONE
[13:33:44.495] Resolving 1 futures (chunks) ...
[13:33:44.495] resolve() on list ...
[13:33:44.495]  recursive: 0
[13:33:44.496]  length: 1
[13:33:44.496] 
[13:33:44.496] resolved() for ‘SequentialFuture’ ...
[13:33:44.496] - state: ‘finished’
[13:33:44.496] - run: TRUE
[13:33:44.496] - result: ‘FutureResult’
[13:33:44.496] resolved() for ‘SequentialFuture’ ... done
[13:33:44.496] Future #1
[13:33:44.496] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:44.496] - nx: 1
[13:33:44.496] - relay: TRUE
[13:33:44.497] - stdout: TRUE
[13:33:44.497] - signal: TRUE
[13:33:44.497] - resignal: FALSE
[13:33:44.497] - force: TRUE
[13:33:44.497] - relayed: [n=1] FALSE
[13:33:44.497] - queued futures: [n=1] FALSE
[13:33:44.497]  - until=1
[13:33:44.497]  - relaying element #1
[13:33:44.497] - relayed: [n=1] TRUE
[13:33:44.497] - queued futures: [n=1] TRUE
[13:33:44.497] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:44.497]  length: 0 (resolved future 1)
[13:33:44.498] Relaying remaining futures
[13:33:44.498] signalConditionsASAP(NULL, pos=0) ...
[13:33:44.498] - nx: 1
[13:33:44.498] - relay: TRUE
[13:33:44.498] - stdout: TRUE
[13:33:44.498] - signal: TRUE
[13:33:44.498] - resignal: FALSE
[13:33:44.498] - force: TRUE
[13:33:44.498] - relayed: [n=1] TRUE
[13:33:44.498] - queued futures: [n=1] TRUE
 - flush all
[13:33:44.498] - relayed: [n=1] TRUE
[13:33:44.499] - queued futures: [n=1] TRUE
[13:33:44.499] signalConditionsASAP(NULL, pos=0) ... done
[13:33:44.499] resolve() on list ... DONE
[13:33:44.499]  - Number of value chunks collected: 1
[13:33:44.499] Resolving 1 futures (chunks) ... DONE
[13:33:44.499] Reducing values from 1 chunks ...
[13:33:44.499]  - Number of values collected after concatenation: 3
[13:33:44.499]  - Number of values expected: 3
[13:33:44.499] Reducing values from 1 chunks ... DONE
[13:33:44.499] future_lapply() ... DONE
[13:33:44.500] future_lapply() ...
[13:33:44.500] Number of chunks: 1
[13:33:44.500] getGlobalsAndPackagesXApply() ...
[13:33:44.500]  - future.globals: TRUE
[13:33:44.500] getGlobalsAndPackages() ...
[13:33:44.500] Searching for globals...
[13:33:44.501] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:44.502] Searching for globals ... DONE
[13:33:44.502] Resolving globals: FALSE
[13:33:44.502] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:33:44.502] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:33:44.502] - globals: [1] ‘FUN’
[13:33:44.502] - packages: [1] ‘stats’
[13:33:44.503] getGlobalsAndPackages() ... DONE
[13:33:44.503]  - globals found/used: [n=1] ‘FUN’
[13:33:44.503]  - needed namespaces: [n=1] ‘stats’
[13:33:44.503] Finding globals ... DONE
[13:33:44.503]  - use_args: TRUE
[13:33:44.503]  - Getting '...' globals ...
[13:33:44.503] resolve() on list ...
[13:33:44.503]  recursive: 0
[13:33:44.503]  length: 1
[13:33:44.504]  elements: ‘...’
[13:33:44.504]  length: 0 (resolved future 1)
[13:33:44.504] resolve() on list ... DONE
[13:33:44.504]    - '...' content: [n=0] 
[13:33:44.504] List of 1
[13:33:44.504]  $ ...: list()
[13:33:44.504]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.504]  - attr(*, "where")=List of 1
[13:33:44.504]   ..$ ...:<environment: 0x55984615b528> 
[13:33:44.504]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.504]  - attr(*, "resolved")= logi TRUE
[13:33:44.504]  - attr(*, "total_size")= num NA
[13:33:44.506]  - Getting '...' globals ... DONE
[13:33:44.507] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:44.507] List of 2
[13:33:44.507]  $ ...future.FUN:function (x, ...)  
[13:33:44.507]  $ ...          : list()
[13:33:44.507]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.507]  - attr(*, "where")=List of 2
[13:33:44.507]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:44.507]   ..$ ...          :<environment: 0x55984615b528> 
[13:33:44.507]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.507]  - attr(*, "resolved")= logi FALSE
[13:33:44.507]  - attr(*, "total_size")= num 1248
[13:33:44.510] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:44.510] getGlobalsAndPackagesXApply() ... DONE
[13:33:44.510] Number of futures (= number of chunks): 1
[13:33:44.510] Launching 1 futures (chunks) ...
[13:33:44.510] Chunk #1 of 1 ...
[13:33:44.510]  - Finding globals in 'X' for chunk #1 ...
[13:33:44.510] getGlobalsAndPackages() ...
[13:33:44.511] Searching for globals...
[13:33:44.511] 
[13:33:44.511] Searching for globals ... DONE
[13:33:44.511] - globals: [0] <none>
[13:33:44.511] getGlobalsAndPackages() ... DONE
[13:33:44.511]    + additional globals found: [n=0] 
[13:33:44.511]    + additional namespaces needed: [n=0] 
[13:33:44.511]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:44.511]  - seeds: <none>
[13:33:44.511]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.512] getGlobalsAndPackages() ...
[13:33:44.512] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.512] Resolving globals: FALSE
[13:33:44.512] Tweak future expression to call with '...' arguments ...
[13:33:44.512] {
[13:33:44.512]     do.call(function(...) {
[13:33:44.512]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.512]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:44.512]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.512]             on.exit(options(oopts), add = TRUE)
[13:33:44.512]         }
[13:33:44.512]         {
[13:33:44.512]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:44.512]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.512]                 ...future.FUN(...future.X_jj, ...)
[13:33:44.512]             })
[13:33:44.512]         }
[13:33:44.512]     }, args = future.call.arguments)
[13:33:44.512] }
[13:33:44.512] Tweak future expression to call with '...' arguments ... DONE
[13:33:44.512] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.513] - packages: [1] ‘stats’
[13:33:44.513] getGlobalsAndPackages() ... DONE
[13:33:44.513] run() for ‘Future’ ...
[13:33:44.513] - state: ‘created’
[13:33:44.513] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:33:44.513] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:44.513] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:33:44.514]   - Field: ‘label’
[13:33:44.514]   - Field: ‘local’
[13:33:44.514]   - Field: ‘owner’
[13:33:44.514]   - Field: ‘envir’
[13:33:44.514]   - Field: ‘packages’
[13:33:44.514]   - Field: ‘gc’
[13:33:44.514]   - Field: ‘conditions’
[13:33:44.514]   - Field: ‘expr’
[13:33:44.514]   - Field: ‘uuid’
[13:33:44.514]   - Field: ‘seed’
[13:33:44.514]   - Field: ‘version’
[13:33:44.515]   - Field: ‘result’
[13:33:44.515]   - Field: ‘asynchronous’
[13:33:44.515]   - Field: ‘calls’
[13:33:44.515]   - Field: ‘globals’
[13:33:44.515]   - Field: ‘stdout’
[13:33:44.515]   - Field: ‘earlySignal’
[13:33:44.515]   - Field: ‘lazy’
[13:33:44.515]   - Field: ‘state’
[13:33:44.515] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:33:44.515] - Launch lazy future ...
[13:33:44.515] Packages needed by the future expression (n = 1): ‘stats’
[13:33:44.516] Packages needed by future strategies (n = 0): <none>
[13:33:44.516] {
[13:33:44.516]     {
[13:33:44.516]         {
[13:33:44.516]             ...future.startTime <- base::Sys.time()
[13:33:44.516]             {
[13:33:44.516]                 {
[13:33:44.516]                   {
[13:33:44.516]                     {
[13:33:44.516]                       base::local({
[13:33:44.516]                         has_future <- base::requireNamespace("future", 
[13:33:44.516]                           quietly = TRUE)
[13:33:44.516]                         if (has_future) {
[13:33:44.516]                           ns <- base::getNamespace("future")
[13:33:44.516]                           version <- ns[[".package"]][["version"]]
[13:33:44.516]                           if (is.null(version)) 
[13:33:44.516]                             version <- utils::packageVersion("future")
[13:33:44.516]                         }
[13:33:44.516]                         else {
[13:33:44.516]                           version <- NULL
[13:33:44.516]                         }
[13:33:44.516]                         if (!has_future || version < "1.8.0") {
[13:33:44.516]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:44.516]                             "", base::R.version$version.string), 
[13:33:44.516]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:44.516]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:44.516]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:44.516]                               "release", "version")], collapse = " "), 
[13:33:44.516]                             hostname = base::Sys.info()[["nodename"]])
[13:33:44.516]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:44.516]                             info)
[13:33:44.516]                           info <- base::paste(info, collapse = "; ")
[13:33:44.516]                           if (!has_future) {
[13:33:44.516]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:44.516]                               info)
[13:33:44.516]                           }
[13:33:44.516]                           else {
[13:33:44.516]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:44.516]                               info, version)
[13:33:44.516]                           }
[13:33:44.516]                           base::stop(msg)
[13:33:44.516]                         }
[13:33:44.516]                       })
[13:33:44.516]                     }
[13:33:44.516]                     base::local({
[13:33:44.516]                       for (pkg in "stats") {
[13:33:44.516]                         base::loadNamespace(pkg)
[13:33:44.516]                         base::library(pkg, character.only = TRUE)
[13:33:44.516]                       }
[13:33:44.516]                     })
[13:33:44.516]                   }
[13:33:44.516]                   ...future.strategy.old <- future::plan("list")
[13:33:44.516]                   options(future.plan = NULL)
[13:33:44.516]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:44.516]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:44.516]                 }
[13:33:44.516]                 ...future.workdir <- getwd()
[13:33:44.516]             }
[13:33:44.516]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:44.516]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:44.516]         }
[13:33:44.516]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:44.516]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:44.516]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:44.516]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:44.516]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:44.516]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:44.516]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:44.516]             base::names(...future.oldOptions))
[13:33:44.516]     }
[13:33:44.516]     if (FALSE) {
[13:33:44.516]     }
[13:33:44.516]     else {
[13:33:44.516]         if (TRUE) {
[13:33:44.516]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:44.516]                 open = "w")
[13:33:44.516]         }
[13:33:44.516]         else {
[13:33:44.516]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:44.516]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:44.516]         }
[13:33:44.516]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:44.516]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:44.516]             base::sink(type = "output", split = FALSE)
[13:33:44.516]             base::close(...future.stdout)
[13:33:44.516]         }, add = TRUE)
[13:33:44.516]     }
[13:33:44.516]     ...future.frame <- base::sys.nframe()
[13:33:44.516]     ...future.conditions <- base::list()
[13:33:44.516]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:44.516]     if (FALSE) {
[13:33:44.516]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:44.516]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:44.516]     }
[13:33:44.516]     ...future.result <- base::tryCatch({
[13:33:44.516]         base::withCallingHandlers({
[13:33:44.516]             ...future.value <- base::withVisible(base::local({
[13:33:44.516]                 do.call(function(...) {
[13:33:44.516]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.516]                   if (!identical(...future.globals.maxSize.org, 
[13:33:44.516]                     ...future.globals.maxSize)) {
[13:33:44.516]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.516]                     on.exit(options(oopts), add = TRUE)
[13:33:44.516]                   }
[13:33:44.516]                   {
[13:33:44.516]                     lapply(seq_along(...future.elements_ii), 
[13:33:44.516]                       FUN = function(jj) {
[13:33:44.516]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.516]                         ...future.FUN(...future.X_jj, ...)
[13:33:44.516]                       })
[13:33:44.516]                   }
[13:33:44.516]                 }, args = future.call.arguments)
[13:33:44.516]             }))
[13:33:44.516]             future::FutureResult(value = ...future.value$value, 
[13:33:44.516]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:44.516]                   ...future.rng), globalenv = if (FALSE) 
[13:33:44.516]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:44.516]                     ...future.globalenv.names))
[13:33:44.516]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:44.516]         }, condition = base::local({
[13:33:44.516]             c <- base::c
[13:33:44.516]             inherits <- base::inherits
[13:33:44.516]             invokeRestart <- base::invokeRestart
[13:33:44.516]             length <- base::length
[13:33:44.516]             list <- base::list
[13:33:44.516]             seq.int <- base::seq.int
[13:33:44.516]             signalCondition <- base::signalCondition
[13:33:44.516]             sys.calls <- base::sys.calls
[13:33:44.516]             `[[` <- base::`[[`
[13:33:44.516]             `+` <- base::`+`
[13:33:44.516]             `<<-` <- base::`<<-`
[13:33:44.516]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:44.516]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:44.516]                   3L)]
[13:33:44.516]             }
[13:33:44.516]             function(cond) {
[13:33:44.516]                 is_error <- inherits(cond, "error")
[13:33:44.516]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:44.516]                   NULL)
[13:33:44.516]                 if (is_error) {
[13:33:44.516]                   sessionInformation <- function() {
[13:33:44.516]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:44.516]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:44.516]                       search = base::search(), system = base::Sys.info())
[13:33:44.516]                   }
[13:33:44.516]                   ...future.conditions[[length(...future.conditions) + 
[13:33:44.516]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:44.516]                     cond$call), session = sessionInformation(), 
[13:33:44.516]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:44.516]                   signalCondition(cond)
[13:33:44.516]                 }
[13:33:44.516]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:44.516]                 "immediateCondition"))) {
[13:33:44.516]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:44.516]                   ...future.conditions[[length(...future.conditions) + 
[13:33:44.516]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:44.516]                   if (TRUE && !signal) {
[13:33:44.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.516]                     {
[13:33:44.516]                       inherits <- base::inherits
[13:33:44.516]                       invokeRestart <- base::invokeRestart
[13:33:44.516]                       is.null <- base::is.null
[13:33:44.516]                       muffled <- FALSE
[13:33:44.516]                       if (inherits(cond, "message")) {
[13:33:44.516]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:44.516]                         if (muffled) 
[13:33:44.516]                           invokeRestart("muffleMessage")
[13:33:44.516]                       }
[13:33:44.516]                       else if (inherits(cond, "warning")) {
[13:33:44.516]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:44.516]                         if (muffled) 
[13:33:44.516]                           invokeRestart("muffleWarning")
[13:33:44.516]                       }
[13:33:44.516]                       else if (inherits(cond, "condition")) {
[13:33:44.516]                         if (!is.null(pattern)) {
[13:33:44.516]                           computeRestarts <- base::computeRestarts
[13:33:44.516]                           grepl <- base::grepl
[13:33:44.516]                           restarts <- computeRestarts(cond)
[13:33:44.516]                           for (restart in restarts) {
[13:33:44.516]                             name <- restart$name
[13:33:44.516]                             if (is.null(name)) 
[13:33:44.516]                               next
[13:33:44.516]                             if (!grepl(pattern, name)) 
[13:33:44.516]                               next
[13:33:44.516]                             invokeRestart(restart)
[13:33:44.516]                             muffled <- TRUE
[13:33:44.516]                             break
[13:33:44.516]                           }
[13:33:44.516]                         }
[13:33:44.516]                       }
[13:33:44.516]                       invisible(muffled)
[13:33:44.516]                     }
[13:33:44.516]                     muffleCondition(cond, pattern = "^muffle")
[13:33:44.516]                   }
[13:33:44.516]                 }
[13:33:44.516]                 else {
[13:33:44.516]                   if (TRUE) {
[13:33:44.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.516]                     {
[13:33:44.516]                       inherits <- base::inherits
[13:33:44.516]                       invokeRestart <- base::invokeRestart
[13:33:44.516]                       is.null <- base::is.null
[13:33:44.516]                       muffled <- FALSE
[13:33:44.516]                       if (inherits(cond, "message")) {
[13:33:44.516]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:44.516]                         if (muffled) 
[13:33:44.516]                           invokeRestart("muffleMessage")
[13:33:44.516]                       }
[13:33:44.516]                       else if (inherits(cond, "warning")) {
[13:33:44.516]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:44.516]                         if (muffled) 
[13:33:44.516]                           invokeRestart("muffleWarning")
[13:33:44.516]                       }
[13:33:44.516]                       else if (inherits(cond, "condition")) {
[13:33:44.516]                         if (!is.null(pattern)) {
[13:33:44.516]                           computeRestarts <- base::computeRestarts
[13:33:44.516]                           grepl <- base::grepl
[13:33:44.516]                           restarts <- computeRestarts(cond)
[13:33:44.516]                           for (restart in restarts) {
[13:33:44.516]                             name <- restart$name
[13:33:44.516]                             if (is.null(name)) 
[13:33:44.516]                               next
[13:33:44.516]                             if (!grepl(pattern, name)) 
[13:33:44.516]                               next
[13:33:44.516]                             invokeRestart(restart)
[13:33:44.516]                             muffled <- TRUE
[13:33:44.516]                             break
[13:33:44.516]                           }
[13:33:44.516]                         }
[13:33:44.516]                       }
[13:33:44.516]                       invisible(muffled)
[13:33:44.516]                     }
[13:33:44.516]                     muffleCondition(cond, pattern = "^muffle")
[13:33:44.516]                   }
[13:33:44.516]                 }
[13:33:44.516]             }
[13:33:44.516]         }))
[13:33:44.516]     }, error = function(ex) {
[13:33:44.516]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:44.516]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:44.516]                 ...future.rng), started = ...future.startTime, 
[13:33:44.516]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:44.516]             version = "1.8"), class = "FutureResult")
[13:33:44.516]     }, finally = {
[13:33:44.516]         if (!identical(...future.workdir, getwd())) 
[13:33:44.516]             setwd(...future.workdir)
[13:33:44.516]         {
[13:33:44.516]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:44.516]                 ...future.oldOptions$nwarnings <- NULL
[13:33:44.516]             }
[13:33:44.516]             base::options(...future.oldOptions)
[13:33:44.516]             if (.Platform$OS.type == "windows") {
[13:33:44.516]                 old_names <- names(...future.oldEnvVars)
[13:33:44.516]                 envs <- base::Sys.getenv()
[13:33:44.516]                 names <- names(envs)
[13:33:44.516]                 common <- intersect(names, old_names)
[13:33:44.516]                 added <- setdiff(names, old_names)
[13:33:44.516]                 removed <- setdiff(old_names, names)
[13:33:44.516]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:44.516]                   envs[common]]
[13:33:44.516]                 NAMES <- toupper(changed)
[13:33:44.516]                 args <- list()
[13:33:44.516]                 for (kk in seq_along(NAMES)) {
[13:33:44.516]                   name <- changed[[kk]]
[13:33:44.516]                   NAME <- NAMES[[kk]]
[13:33:44.516]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.516]                     next
[13:33:44.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:44.516]                 }
[13:33:44.516]                 NAMES <- toupper(added)
[13:33:44.516]                 for (kk in seq_along(NAMES)) {
[13:33:44.516]                   name <- added[[kk]]
[13:33:44.516]                   NAME <- NAMES[[kk]]
[13:33:44.516]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.516]                     next
[13:33:44.516]                   args[[name]] <- ""
[13:33:44.516]                 }
[13:33:44.516]                 NAMES <- toupper(removed)
[13:33:44.516]                 for (kk in seq_along(NAMES)) {
[13:33:44.516]                   name <- removed[[kk]]
[13:33:44.516]                   NAME <- NAMES[[kk]]
[13:33:44.516]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.516]                     next
[13:33:44.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:44.516]                 }
[13:33:44.516]                 if (length(args) > 0) 
[13:33:44.516]                   base::do.call(base::Sys.setenv, args = args)
[13:33:44.516]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:44.516]             }
[13:33:44.516]             else {
[13:33:44.516]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:44.516]             }
[13:33:44.516]             {
[13:33:44.516]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:44.516]                   0L) {
[13:33:44.516]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:44.516]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:44.516]                   base::options(opts)
[13:33:44.516]                 }
[13:33:44.516]                 {
[13:33:44.516]                   {
[13:33:44.516]                     NULL
[13:33:44.516]                     RNGkind("Mersenne-Twister")
[13:33:44.516]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:33:44.516]                       inherits = FALSE)
[13:33:44.516]                   }
[13:33:44.516]                   options(future.plan = NULL)
[13:33:44.516]                   if (is.na(NA_character_)) 
[13:33:44.516]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:44.516]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:44.516]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:44.516]                     .init = FALSE)
[13:33:44.516]                 }
[13:33:44.516]             }
[13:33:44.516]         }
[13:33:44.516]     })
[13:33:44.516]     if (TRUE) {
[13:33:44.516]         base::sink(type = "output", split = FALSE)
[13:33:44.516]         if (TRUE) {
[13:33:44.516]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:44.516]         }
[13:33:44.516]         else {
[13:33:44.516]             ...future.result["stdout"] <- base::list(NULL)
[13:33:44.516]         }
[13:33:44.516]         base::close(...future.stdout)
[13:33:44.516]         ...future.stdout <- NULL
[13:33:44.516]     }
[13:33:44.516]     ...future.result$conditions <- ...future.conditions
[13:33:44.516]     ...future.result$finished <- base::Sys.time()
[13:33:44.516]     ...future.result
[13:33:44.516] }
[13:33:44.518] assign_globals() ...
[13:33:44.518] List of 5
[13:33:44.518]  $ ...future.FUN            :function (x, ...)  
[13:33:44.518]  $ future.call.arguments    : list()
[13:33:44.518]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.518]  $ ...future.elements_ii    :List of 3
[13:33:44.518]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[13:33:44.518]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:33:44.518]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:33:44.518]  $ ...future.seeds_ii       : NULL
[13:33:44.518]  $ ...future.globals.maxSize: NULL
[13:33:44.518]  - attr(*, "where")=List of 5
[13:33:44.518]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:44.518]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:44.518]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:44.518]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:44.518]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:44.518]  - attr(*, "resolved")= logi FALSE
[13:33:44.518]  - attr(*, "total_size")= num 1248
[13:33:44.518]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.518]  - attr(*, "already-done")= logi TRUE
[13:33:44.523] - copied ‘...future.FUN’ to environment
[13:33:44.523] - copied ‘future.call.arguments’ to environment
[13:33:44.523] - copied ‘...future.elements_ii’ to environment
[13:33:44.523] - copied ‘...future.seeds_ii’ to environment
[13:33:44.523] - copied ‘...future.globals.maxSize’ to environment
[13:33:44.523] assign_globals() ... done
[13:33:44.523] plan(): Setting new future strategy stack:
[13:33:44.524] List of future strategies:
[13:33:44.524] 1. sequential:
[13:33:44.524]    - args: function (..., envir = parent.frame())
[13:33:44.524]    - tweaked: FALSE
[13:33:44.524]    - call: NULL
[13:33:44.524] plan(): nbrOfWorkers() = 1
[13:33:44.525] plan(): Setting new future strategy stack:
[13:33:44.525] List of future strategies:
[13:33:44.525] 1. sequential:
[13:33:44.525]    - args: function (..., envir = parent.frame())
[13:33:44.525]    - tweaked: FALSE
[13:33:44.525]    - call: plan(strategy)
[13:33:44.525] plan(): nbrOfWorkers() = 1
[13:33:44.526] SequentialFuture started (and completed)
[13:33:44.526] - Launch lazy future ... done
[13:33:44.526] run() for ‘SequentialFuture’ ... done
[13:33:44.526] Created future:
[13:33:44.526] SequentialFuture:
[13:33:44.526] Label: ‘future_eapply-1’
[13:33:44.526] Expression:
[13:33:44.526] {
[13:33:44.526]     do.call(function(...) {
[13:33:44.526]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.526]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:44.526]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.526]             on.exit(options(oopts), add = TRUE)
[13:33:44.526]         }
[13:33:44.526]         {
[13:33:44.526]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:44.526]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.526]                 ...future.FUN(...future.X_jj, ...)
[13:33:44.526]             })
[13:33:44.526]         }
[13:33:44.526]     }, args = future.call.arguments)
[13:33:44.526] }
[13:33:44.526] Lazy evaluation: FALSE
[13:33:44.526] Asynchronous evaluation: FALSE
[13:33:44.526] Local evaluation: TRUE
[13:33:44.526] Environment: R_GlobalEnv
[13:33:44.526] Capture standard output: TRUE
[13:33:44.526] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:44.526] Globals: 5 objects totaling 1.48 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 272 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:44.526] Packages: 1 packages (‘stats’)
[13:33:44.526] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:44.526] Resolved: TRUE
[13:33:44.526] Value: 1.71 KiB of class ‘list’
[13:33:44.526] Early signaling: FALSE
[13:33:44.526] Owner process: b6e93464-7fc2-3f8d-23d1-d8004201d1f1
[13:33:44.526] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:33:44.527] Chunk #1 of 1 ... DONE
[13:33:44.527] Launching 1 futures (chunks) ... DONE
[13:33:44.527] Resolving 1 futures (chunks) ...
[13:33:44.527] resolve() on list ...
[13:33:44.527]  recursive: 0
[13:33:44.527]  length: 1
[13:33:44.527] 
[13:33:44.527] resolved() for ‘SequentialFuture’ ...
[13:33:44.528] - state: ‘finished’
[13:33:44.528] - run: TRUE
[13:33:44.528] - result: ‘FutureResult’
[13:33:44.528] resolved() for ‘SequentialFuture’ ... done
[13:33:44.528] Future #1
[13:33:44.528] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:33:44.528] - nx: 1
[13:33:44.528] - relay: TRUE
[13:33:44.528] - stdout: TRUE
[13:33:44.528] - signal: TRUE
[13:33:44.528] - resignal: FALSE
[13:33:44.529] - force: TRUE
[13:33:44.529] - relayed: [n=1] FALSE
[13:33:44.529] - queued futures: [n=1] FALSE
[13:33:44.530]  - until=1
[13:33:44.530]  - relaying element #1
[13:33:44.530] - relayed: [n=1] TRUE
[13:33:44.530] - queued futures: [n=1] TRUE
[13:33:44.530] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:33:44.530]  length: 0 (resolved future 1)
[13:33:44.530] Relaying remaining futures
[13:33:44.530] signalConditionsASAP(NULL, pos=0) ...
[13:33:44.530] - nx: 1
[13:33:44.530] - relay: TRUE
[13:33:44.531] - stdout: TRUE
[13:33:44.531] - signal: TRUE
[13:33:44.531] - resignal: FALSE
[13:33:44.531] - force: TRUE
[13:33:44.531] - relayed: [n=1] TRUE
[13:33:44.531] - queued futures: [n=1] TRUE
 - flush all
[13:33:44.531] - relayed: [n=1] TRUE
[13:33:44.531] - queued futures: [n=1] TRUE
[13:33:44.531] signalConditionsASAP(NULL, pos=0) ... done
[13:33:44.531] resolve() on list ... DONE
[13:33:44.531]  - Number of value chunks collected: 1
[13:33:44.532] Resolving 1 futures (chunks) ... DONE
[13:33:44.532] Reducing values from 1 chunks ...
[13:33:44.532]  - Number of values collected after concatenation: 3
[13:33:44.532]  - Number of values expected: 3
[13:33:44.532] Reducing values from 1 chunks ... DONE
[13:33:44.532] future_lapply() ... DONE
[13:33:44.532] plan(): Setting new future strategy stack:
[13:33:44.532] List of future strategies:
[13:33:44.532] 1. sequential:
[13:33:44.532]    - args: function (..., envir = parent.frame())
[13:33:44.532]    - tweaked: FALSE
[13:33:44.532]    - call: plan(sequential)
[13:33:44.533] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[13:33:44.533] plan(): Setting new future strategy stack:
[13:33:44.533] List of future strategies:
[13:33:44.533] 1. multicore:
[13:33:44.533]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:44.533]    - tweaked: FALSE
[13:33:44.533]    - call: plan(strategy)
[13:33:44.537] plan(): nbrOfWorkers() = 2
[13:33:44.537] future_lapply() ...
[13:33:44.541] Number of chunks: 2
[13:33:44.542] getGlobalsAndPackagesXApply() ...
[13:33:44.542]  - future.globals: TRUE
[13:33:44.542] getGlobalsAndPackages() ...
[13:33:44.542] Searching for globals...
[13:33:44.543] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:44.543] Searching for globals ... DONE
[13:33:44.543] Resolving globals: FALSE
[13:33:44.543] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:44.544] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:44.544] - globals: [1] ‘FUN’
[13:33:44.544] 
[13:33:44.544] getGlobalsAndPackages() ... DONE
[13:33:44.544]  - globals found/used: [n=1] ‘FUN’
[13:33:44.544]  - needed namespaces: [n=0] 
[13:33:44.544] Finding globals ... DONE
[13:33:44.544]  - use_args: TRUE
[13:33:44.544]  - Getting '...' globals ...
[13:33:44.545] resolve() on list ...
[13:33:44.545]  recursive: 0
[13:33:44.545]  length: 1
[13:33:44.545]  elements: ‘...’
[13:33:44.545]  length: 0 (resolved future 1)
[13:33:44.545] resolve() on list ... DONE
[13:33:44.545]    - '...' content: [n=0] 
[13:33:44.545] List of 1
[13:33:44.545]  $ ...: list()
[13:33:44.545]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.545]  - attr(*, "where")=List of 1
[13:33:44.545]   ..$ ...:<environment: 0x559843dd57b8> 
[13:33:44.545]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.545]  - attr(*, "resolved")= logi TRUE
[13:33:44.545]  - attr(*, "total_size")= num NA
[13:33:44.548]  - Getting '...' globals ... DONE
[13:33:44.548] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:44.548] List of 2
[13:33:44.548]  $ ...future.FUN:function (x, ...)  
[13:33:44.548]  $ ...          : list()
[13:33:44.548]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.548]  - attr(*, "where")=List of 2
[13:33:44.548]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:44.548]   ..$ ...          :<environment: 0x559843dd57b8> 
[13:33:44.548]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.548]  - attr(*, "resolved")= logi FALSE
[13:33:44.548]  - attr(*, "total_size")= num 1240
[13:33:44.550] Packages to be attached in all futures: [n=0] 
[13:33:44.551] getGlobalsAndPackagesXApply() ... DONE
[13:33:44.551] Number of futures (= number of chunks): 2
[13:33:44.551] Launching 2 futures (chunks) ...
[13:33:44.551] Chunk #1 of 2 ...
[13:33:44.551]  - Finding globals in 'X' for chunk #1 ...
[13:33:44.551] getGlobalsAndPackages() ...
[13:33:44.551] Searching for globals...
[13:33:44.551] 
[13:33:44.552] Searching for globals ... DONE
[13:33:44.552] - globals: [0] <none>
[13:33:44.552] getGlobalsAndPackages() ... DONE
[13:33:44.552]    + additional globals found: [n=0] 
[13:33:44.552]    + additional namespaces needed: [n=0] 
[13:33:44.552]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:44.552]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:44.552]  - seeds: <none>
[13:33:44.552]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.552] getGlobalsAndPackages() ...
[13:33:44.552] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.553] Resolving globals: FALSE
[13:33:44.553] Tweak future expression to call with '...' arguments ...
[13:33:44.553] {
[13:33:44.553]     do.call(function(...) {
[13:33:44.553]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.553]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:44.553]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.553]             on.exit(options(oopts), add = TRUE)
[13:33:44.553]         }
[13:33:44.553]         {
[13:33:44.553]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:44.553]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.553]                 ...future.FUN(...future.X_jj, ...)
[13:33:44.553]             })
[13:33:44.553]         }
[13:33:44.553]     }, args = future.call.arguments)
[13:33:44.553] }
[13:33:44.553] Tweak future expression to call with '...' arguments ... DONE
[13:33:44.553] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.553] 
[13:33:44.554] getGlobalsAndPackages() ... DONE
[13:33:44.554] run() for ‘Future’ ...
[13:33:44.554] - state: ‘created’
[13:33:44.554] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:44.559] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:44.559] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:44.559]   - Field: ‘label’
[13:33:44.559]   - Field: ‘local’
[13:33:44.559]   - Field: ‘owner’
[13:33:44.559]   - Field: ‘envir’
[13:33:44.559]   - Field: ‘workers’
[13:33:44.559]   - Field: ‘packages’
[13:33:44.560]   - Field: ‘gc’
[13:33:44.560]   - Field: ‘job’
[13:33:44.560]   - Field: ‘conditions’
[13:33:44.560]   - Field: ‘expr’
[13:33:44.560]   - Field: ‘uuid’
[13:33:44.560]   - Field: ‘seed’
[13:33:44.560]   - Field: ‘version’
[13:33:44.560]   - Field: ‘result’
[13:33:44.560]   - Field: ‘asynchronous’
[13:33:44.560]   - Field: ‘calls’
[13:33:44.560]   - Field: ‘globals’
[13:33:44.560]   - Field: ‘stdout’
[13:33:44.561]   - Field: ‘earlySignal’
[13:33:44.561]   - Field: ‘lazy’
[13:33:44.561]   - Field: ‘state’
[13:33:44.561] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:44.561] - Launch lazy future ...
[13:33:44.562] Packages needed by the future expression (n = 0): <none>
[13:33:44.562] Packages needed by future strategies (n = 0): <none>
[13:33:44.563] {
[13:33:44.563]     {
[13:33:44.563]         {
[13:33:44.563]             ...future.startTime <- base::Sys.time()
[13:33:44.563]             {
[13:33:44.563]                 {
[13:33:44.563]                   {
[13:33:44.563]                     {
[13:33:44.563]                       base::local({
[13:33:44.563]                         has_future <- base::requireNamespace("future", 
[13:33:44.563]                           quietly = TRUE)
[13:33:44.563]                         if (has_future) {
[13:33:44.563]                           ns <- base::getNamespace("future")
[13:33:44.563]                           version <- ns[[".package"]][["version"]]
[13:33:44.563]                           if (is.null(version)) 
[13:33:44.563]                             version <- utils::packageVersion("future")
[13:33:44.563]                         }
[13:33:44.563]                         else {
[13:33:44.563]                           version <- NULL
[13:33:44.563]                         }
[13:33:44.563]                         if (!has_future || version < "1.8.0") {
[13:33:44.563]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:44.563]                             "", base::R.version$version.string), 
[13:33:44.563]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:44.563]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:44.563]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:44.563]                               "release", "version")], collapse = " "), 
[13:33:44.563]                             hostname = base::Sys.info()[["nodename"]])
[13:33:44.563]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:44.563]                             info)
[13:33:44.563]                           info <- base::paste(info, collapse = "; ")
[13:33:44.563]                           if (!has_future) {
[13:33:44.563]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:44.563]                               info)
[13:33:44.563]                           }
[13:33:44.563]                           else {
[13:33:44.563]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:44.563]                               info, version)
[13:33:44.563]                           }
[13:33:44.563]                           base::stop(msg)
[13:33:44.563]                         }
[13:33:44.563]                       })
[13:33:44.563]                     }
[13:33:44.563]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:44.563]                     base::options(mc.cores = 1L)
[13:33:44.563]                   }
[13:33:44.563]                   ...future.strategy.old <- future::plan("list")
[13:33:44.563]                   options(future.plan = NULL)
[13:33:44.563]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:44.563]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:44.563]                 }
[13:33:44.563]                 ...future.workdir <- getwd()
[13:33:44.563]             }
[13:33:44.563]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:44.563]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:44.563]         }
[13:33:44.563]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:44.563]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:44.563]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:44.563]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:44.563]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:44.563]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:44.563]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:44.563]             base::names(...future.oldOptions))
[13:33:44.563]     }
[13:33:44.563]     if (FALSE) {
[13:33:44.563]     }
[13:33:44.563]     else {
[13:33:44.563]         if (TRUE) {
[13:33:44.563]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:44.563]                 open = "w")
[13:33:44.563]         }
[13:33:44.563]         else {
[13:33:44.563]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:44.563]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:44.563]         }
[13:33:44.563]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:44.563]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:44.563]             base::sink(type = "output", split = FALSE)
[13:33:44.563]             base::close(...future.stdout)
[13:33:44.563]         }, add = TRUE)
[13:33:44.563]     }
[13:33:44.563]     ...future.frame <- base::sys.nframe()
[13:33:44.563]     ...future.conditions <- base::list()
[13:33:44.563]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:44.563]     if (FALSE) {
[13:33:44.563]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:44.563]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:44.563]     }
[13:33:44.563]     ...future.result <- base::tryCatch({
[13:33:44.563]         base::withCallingHandlers({
[13:33:44.563]             ...future.value <- base::withVisible(base::local({
[13:33:44.563]                 withCallingHandlers({
[13:33:44.563]                   {
[13:33:44.563]                     do.call(function(...) {
[13:33:44.563]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.563]                       if (!identical(...future.globals.maxSize.org, 
[13:33:44.563]                         ...future.globals.maxSize)) {
[13:33:44.563]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.563]                         on.exit(options(oopts), add = TRUE)
[13:33:44.563]                       }
[13:33:44.563]                       {
[13:33:44.563]                         lapply(seq_along(...future.elements_ii), 
[13:33:44.563]                           FUN = function(jj) {
[13:33:44.563]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.563]                             ...future.FUN(...future.X_jj, ...)
[13:33:44.563]                           })
[13:33:44.563]                       }
[13:33:44.563]                     }, args = future.call.arguments)
[13:33:44.563]                   }
[13:33:44.563]                 }, immediateCondition = function(cond) {
[13:33:44.563]                   save_rds <- function (object, pathname, ...) 
[13:33:44.563]                   {
[13:33:44.563]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:44.563]                     if (file_test("-f", pathname_tmp)) {
[13:33:44.563]                       fi_tmp <- file.info(pathname_tmp)
[13:33:44.563]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:44.563]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:44.563]                         fi_tmp[["mtime"]])
[13:33:44.563]                     }
[13:33:44.563]                     tryCatch({
[13:33:44.563]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:44.563]                     }, error = function(ex) {
[13:33:44.563]                       msg <- conditionMessage(ex)
[13:33:44.563]                       fi_tmp <- file.info(pathname_tmp)
[13:33:44.563]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:44.563]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:44.563]                         fi_tmp[["mtime"]], msg)
[13:33:44.563]                       ex$message <- msg
[13:33:44.563]                       stop(ex)
[13:33:44.563]                     })
[13:33:44.563]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:44.563]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:44.563]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:44.563]                       fi_tmp <- file.info(pathname_tmp)
[13:33:44.563]                       fi <- file.info(pathname)
[13:33:44.563]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:44.563]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:44.563]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:44.563]                         fi[["size"]], fi[["mtime"]])
[13:33:44.563]                       stop(msg)
[13:33:44.563]                     }
[13:33:44.563]                     invisible(pathname)
[13:33:44.563]                   }
[13:33:44.563]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:44.563]                     rootPath = tempdir()) 
[13:33:44.563]                   {
[13:33:44.563]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:44.563]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:44.563]                       tmpdir = path, fileext = ".rds")
[13:33:44.563]                     save_rds(obj, file)
[13:33:44.563]                   }
[13:33:44.563]                   saveImmediateCondition(cond, path = "/tmp/RtmpC9rl05/.future/immediateConditions")
[13:33:44.563]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.563]                   {
[13:33:44.563]                     inherits <- base::inherits
[13:33:44.563]                     invokeRestart <- base::invokeRestart
[13:33:44.563]                     is.null <- base::is.null
[13:33:44.563]                     muffled <- FALSE
[13:33:44.563]                     if (inherits(cond, "message")) {
[13:33:44.563]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:44.563]                       if (muffled) 
[13:33:44.563]                         invokeRestart("muffleMessage")
[13:33:44.563]                     }
[13:33:44.563]                     else if (inherits(cond, "warning")) {
[13:33:44.563]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:44.563]                       if (muffled) 
[13:33:44.563]                         invokeRestart("muffleWarning")
[13:33:44.563]                     }
[13:33:44.563]                     else if (inherits(cond, "condition")) {
[13:33:44.563]                       if (!is.null(pattern)) {
[13:33:44.563]                         computeRestarts <- base::computeRestarts
[13:33:44.563]                         grepl <- base::grepl
[13:33:44.563]                         restarts <- computeRestarts(cond)
[13:33:44.563]                         for (restart in restarts) {
[13:33:44.563]                           name <- restart$name
[13:33:44.563]                           if (is.null(name)) 
[13:33:44.563]                             next
[13:33:44.563]                           if (!grepl(pattern, name)) 
[13:33:44.563]                             next
[13:33:44.563]                           invokeRestart(restart)
[13:33:44.563]                           muffled <- TRUE
[13:33:44.563]                           break
[13:33:44.563]                         }
[13:33:44.563]                       }
[13:33:44.563]                     }
[13:33:44.563]                     invisible(muffled)
[13:33:44.563]                   }
[13:33:44.563]                   muffleCondition(cond)
[13:33:44.563]                 })
[13:33:44.563]             }))
[13:33:44.563]             future::FutureResult(value = ...future.value$value, 
[13:33:44.563]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:44.563]                   ...future.rng), globalenv = if (FALSE) 
[13:33:44.563]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:44.563]                     ...future.globalenv.names))
[13:33:44.563]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:44.563]         }, condition = base::local({
[13:33:44.563]             c <- base::c
[13:33:44.563]             inherits <- base::inherits
[13:33:44.563]             invokeRestart <- base::invokeRestart
[13:33:44.563]             length <- base::length
[13:33:44.563]             list <- base::list
[13:33:44.563]             seq.int <- base::seq.int
[13:33:44.563]             signalCondition <- base::signalCondition
[13:33:44.563]             sys.calls <- base::sys.calls
[13:33:44.563]             `[[` <- base::`[[`
[13:33:44.563]             `+` <- base::`+`
[13:33:44.563]             `<<-` <- base::`<<-`
[13:33:44.563]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:44.563]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:44.563]                   3L)]
[13:33:44.563]             }
[13:33:44.563]             function(cond) {
[13:33:44.563]                 is_error <- inherits(cond, "error")
[13:33:44.563]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:44.563]                   NULL)
[13:33:44.563]                 if (is_error) {
[13:33:44.563]                   sessionInformation <- function() {
[13:33:44.563]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:44.563]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:44.563]                       search = base::search(), system = base::Sys.info())
[13:33:44.563]                   }
[13:33:44.563]                   ...future.conditions[[length(...future.conditions) + 
[13:33:44.563]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:44.563]                     cond$call), session = sessionInformation(), 
[13:33:44.563]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:44.563]                   signalCondition(cond)
[13:33:44.563]                 }
[13:33:44.563]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:44.563]                 "immediateCondition"))) {
[13:33:44.563]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:44.563]                   ...future.conditions[[length(...future.conditions) + 
[13:33:44.563]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:44.563]                   if (TRUE && !signal) {
[13:33:44.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.563]                     {
[13:33:44.563]                       inherits <- base::inherits
[13:33:44.563]                       invokeRestart <- base::invokeRestart
[13:33:44.563]                       is.null <- base::is.null
[13:33:44.563]                       muffled <- FALSE
[13:33:44.563]                       if (inherits(cond, "message")) {
[13:33:44.563]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:44.563]                         if (muffled) 
[13:33:44.563]                           invokeRestart("muffleMessage")
[13:33:44.563]                       }
[13:33:44.563]                       else if (inherits(cond, "warning")) {
[13:33:44.563]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:44.563]                         if (muffled) 
[13:33:44.563]                           invokeRestart("muffleWarning")
[13:33:44.563]                       }
[13:33:44.563]                       else if (inherits(cond, "condition")) {
[13:33:44.563]                         if (!is.null(pattern)) {
[13:33:44.563]                           computeRestarts <- base::computeRestarts
[13:33:44.563]                           grepl <- base::grepl
[13:33:44.563]                           restarts <- computeRestarts(cond)
[13:33:44.563]                           for (restart in restarts) {
[13:33:44.563]                             name <- restart$name
[13:33:44.563]                             if (is.null(name)) 
[13:33:44.563]                               next
[13:33:44.563]                             if (!grepl(pattern, name)) 
[13:33:44.563]                               next
[13:33:44.563]                             invokeRestart(restart)
[13:33:44.563]                             muffled <- TRUE
[13:33:44.563]                             break
[13:33:44.563]                           }
[13:33:44.563]                         }
[13:33:44.563]                       }
[13:33:44.563]                       invisible(muffled)
[13:33:44.563]                     }
[13:33:44.563]                     muffleCondition(cond, pattern = "^muffle")
[13:33:44.563]                   }
[13:33:44.563]                 }
[13:33:44.563]                 else {
[13:33:44.563]                   if (TRUE) {
[13:33:44.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.563]                     {
[13:33:44.563]                       inherits <- base::inherits
[13:33:44.563]                       invokeRestart <- base::invokeRestart
[13:33:44.563]                       is.null <- base::is.null
[13:33:44.563]                       muffled <- FALSE
[13:33:44.563]                       if (inherits(cond, "message")) {
[13:33:44.563]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:44.563]                         if (muffled) 
[13:33:44.563]                           invokeRestart("muffleMessage")
[13:33:44.563]                       }
[13:33:44.563]                       else if (inherits(cond, "warning")) {
[13:33:44.563]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:44.563]                         if (muffled) 
[13:33:44.563]                           invokeRestart("muffleWarning")
[13:33:44.563]                       }
[13:33:44.563]                       else if (inherits(cond, "condition")) {
[13:33:44.563]                         if (!is.null(pattern)) {
[13:33:44.563]                           computeRestarts <- base::computeRestarts
[13:33:44.563]                           grepl <- base::grepl
[13:33:44.563]                           restarts <- computeRestarts(cond)
[13:33:44.563]                           for (restart in restarts) {
[13:33:44.563]                             name <- restart$name
[13:33:44.563]                             if (is.null(name)) 
[13:33:44.563]                               next
[13:33:44.563]                             if (!grepl(pattern, name)) 
[13:33:44.563]                               next
[13:33:44.563]                             invokeRestart(restart)
[13:33:44.563]                             muffled <- TRUE
[13:33:44.563]                             break
[13:33:44.563]                           }
[13:33:44.563]                         }
[13:33:44.563]                       }
[13:33:44.563]                       invisible(muffled)
[13:33:44.563]                     }
[13:33:44.563]                     muffleCondition(cond, pattern = "^muffle")
[13:33:44.563]                   }
[13:33:44.563]                 }
[13:33:44.563]             }
[13:33:44.563]         }))
[13:33:44.563]     }, error = function(ex) {
[13:33:44.563]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:44.563]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:44.563]                 ...future.rng), started = ...future.startTime, 
[13:33:44.563]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:44.563]             version = "1.8"), class = "FutureResult")
[13:33:44.563]     }, finally = {
[13:33:44.563]         if (!identical(...future.workdir, getwd())) 
[13:33:44.563]             setwd(...future.workdir)
[13:33:44.563]         {
[13:33:44.563]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:44.563]                 ...future.oldOptions$nwarnings <- NULL
[13:33:44.563]             }
[13:33:44.563]             base::options(...future.oldOptions)
[13:33:44.563]             if (.Platform$OS.type == "windows") {
[13:33:44.563]                 old_names <- names(...future.oldEnvVars)
[13:33:44.563]                 envs <- base::Sys.getenv()
[13:33:44.563]                 names <- names(envs)
[13:33:44.563]                 common <- intersect(names, old_names)
[13:33:44.563]                 added <- setdiff(names, old_names)
[13:33:44.563]                 removed <- setdiff(old_names, names)
[13:33:44.563]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:44.563]                   envs[common]]
[13:33:44.563]                 NAMES <- toupper(changed)
[13:33:44.563]                 args <- list()
[13:33:44.563]                 for (kk in seq_along(NAMES)) {
[13:33:44.563]                   name <- changed[[kk]]
[13:33:44.563]                   NAME <- NAMES[[kk]]
[13:33:44.563]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.563]                     next
[13:33:44.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:44.563]                 }
[13:33:44.563]                 NAMES <- toupper(added)
[13:33:44.563]                 for (kk in seq_along(NAMES)) {
[13:33:44.563]                   name <- added[[kk]]
[13:33:44.563]                   NAME <- NAMES[[kk]]
[13:33:44.563]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.563]                     next
[13:33:44.563]                   args[[name]] <- ""
[13:33:44.563]                 }
[13:33:44.563]                 NAMES <- toupper(removed)
[13:33:44.563]                 for (kk in seq_along(NAMES)) {
[13:33:44.563]                   name <- removed[[kk]]
[13:33:44.563]                   NAME <- NAMES[[kk]]
[13:33:44.563]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.563]                     next
[13:33:44.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:44.563]                 }
[13:33:44.563]                 if (length(args) > 0) 
[13:33:44.563]                   base::do.call(base::Sys.setenv, args = args)
[13:33:44.563]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:44.563]             }
[13:33:44.563]             else {
[13:33:44.563]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:44.563]             }
[13:33:44.563]             {
[13:33:44.563]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:44.563]                   0L) {
[13:33:44.563]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:44.563]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:44.563]                   base::options(opts)
[13:33:44.563]                 }
[13:33:44.563]                 {
[13:33:44.563]                   {
[13:33:44.563]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:44.563]                     NULL
[13:33:44.563]                   }
[13:33:44.563]                   options(future.plan = NULL)
[13:33:44.563]                   if (is.na(NA_character_)) 
[13:33:44.563]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:44.563]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:44.563]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:44.563]                     .init = FALSE)
[13:33:44.563]                 }
[13:33:44.563]             }
[13:33:44.563]         }
[13:33:44.563]     })
[13:33:44.563]     if (TRUE) {
[13:33:44.563]         base::sink(type = "output", split = FALSE)
[13:33:44.563]         if (TRUE) {
[13:33:44.563]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:44.563]         }
[13:33:44.563]         else {
[13:33:44.563]             ...future.result["stdout"] <- base::list(NULL)
[13:33:44.563]         }
[13:33:44.563]         base::close(...future.stdout)
[13:33:44.563]         ...future.stdout <- NULL
[13:33:44.563]     }
[13:33:44.563]     ...future.result$conditions <- ...future.conditions
[13:33:44.563]     ...future.result$finished <- base::Sys.time()
[13:33:44.563]     ...future.result
[13:33:44.563] }
[13:33:44.565] assign_globals() ...
[13:33:44.565] List of 5
[13:33:44.565]  $ ...future.FUN            :function (x, ...)  
[13:33:44.565]  $ future.call.arguments    : list()
[13:33:44.565]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.565]  $ ...future.elements_ii    :List of 1
[13:33:44.565]   ..$ : logi [1:4] TRUE FALSE FALSE TRUE
[13:33:44.565]  $ ...future.seeds_ii       : NULL
[13:33:44.565]  $ ...future.globals.maxSize: NULL
[13:33:44.565]  - attr(*, "where")=List of 5
[13:33:44.565]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:44.565]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:44.565]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:44.565]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:44.565]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:44.565]  - attr(*, "resolved")= logi FALSE
[13:33:44.565]  - attr(*, "total_size")= num 1240
[13:33:44.565]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.565]  - attr(*, "already-done")= logi TRUE
[13:33:44.569] - copied ‘...future.FUN’ to environment
[13:33:44.569] - copied ‘future.call.arguments’ to environment
[13:33:44.569] - copied ‘...future.elements_ii’ to environment
[13:33:44.569] - copied ‘...future.seeds_ii’ to environment
[13:33:44.570] - copied ‘...future.globals.maxSize’ to environment
[13:33:44.570] assign_globals() ... done
[13:33:44.570] requestCore(): workers = 2
[13:33:44.573] MulticoreFuture started
[13:33:44.573] - Launch lazy future ... done
[13:33:44.574] plan(): Setting new future strategy stack:
[13:33:44.574] run() for ‘MulticoreFuture’ ... done
[13:33:44.574] Created future:
[13:33:44.574] List of future strategies:
[13:33:44.574] 1. sequential:
[13:33:44.574]    - args: function (..., envir = parent.frame())
[13:33:44.574]    - tweaked: FALSE
[13:33:44.574]    - call: NULL
[13:33:44.575] plan(): nbrOfWorkers() = 1
[13:33:44.577] plan(): Setting new future strategy stack:
[13:33:44.577] List of future strategies:
[13:33:44.577] 1. multicore:
[13:33:44.577]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:44.577]    - tweaked: FALSE
[13:33:44.577]    - call: plan(strategy)
[13:33:44.581] plan(): nbrOfWorkers() = 2
[13:33:44.574] MulticoreFuture:
[13:33:44.574] Label: ‘future_eapply-1’
[13:33:44.574] Expression:
[13:33:44.574] {
[13:33:44.574]     do.call(function(...) {
[13:33:44.574]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.574]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:44.574]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.574]             on.exit(options(oopts), add = TRUE)
[13:33:44.574]         }
[13:33:44.574]         {
[13:33:44.574]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:44.574]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.574]                 ...future.FUN(...future.X_jj, ...)
[13:33:44.574]             })
[13:33:44.574]         }
[13:33:44.574]     }, args = future.call.arguments)
[13:33:44.574] }
[13:33:44.574] Lazy evaluation: FALSE
[13:33:44.574] Asynchronous evaluation: TRUE
[13:33:44.574] Local evaluation: TRUE
[13:33:44.574] Environment: R_GlobalEnv
[13:33:44.574] Capture standard output: TRUE
[13:33:44.574] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:44.574] Globals: 5 objects totaling 1.27 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:44.574] Packages: <none>
[13:33:44.574] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:44.574] Resolved: TRUE
[13:33:44.574] Value: <not collected>
[13:33:44.574] Conditions captured: <none>
[13:33:44.574] Early signaling: FALSE
[13:33:44.574] Owner process: b6e93464-7fc2-3f8d-23d1-d8004201d1f1
[13:33:44.574] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:44.583] Chunk #1 of 2 ... DONE
[13:33:44.583] Chunk #2 of 2 ...
[13:33:44.583]  - Finding globals in 'X' for chunk #2 ...
[13:33:44.583] getGlobalsAndPackages() ...
[13:33:44.583] Searching for globals...
[13:33:44.584] 
[13:33:44.584] Searching for globals ... DONE
[13:33:44.584] - globals: [0] <none>
[13:33:44.584] getGlobalsAndPackages() ... DONE
[13:33:44.584]    + additional globals found: [n=0] 
[13:33:44.585]    + additional namespaces needed: [n=0] 
[13:33:44.585]  - Finding globals in 'X' for chunk #2 ... DONE
[13:33:44.585]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:44.585]  - seeds: <none>
[13:33:44.585]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.585] getGlobalsAndPackages() ...
[13:33:44.586] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.586] Resolving globals: FALSE
[13:33:44.586] Tweak future expression to call with '...' arguments ...
[13:33:44.586] {
[13:33:44.586]     do.call(function(...) {
[13:33:44.586]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.586]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:44.586]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.586]             on.exit(options(oopts), add = TRUE)
[13:33:44.586]         }
[13:33:44.586]         {
[13:33:44.586]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:44.586]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.586]                 ...future.FUN(...future.X_jj, ...)
[13:33:44.586]             })
[13:33:44.586]         }
[13:33:44.586]     }, args = future.call.arguments)
[13:33:44.586] }
[13:33:44.587] Tweak future expression to call with '...' arguments ... DONE
[13:33:44.587] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.587] 
[13:33:44.587] getGlobalsAndPackages() ... DONE
[13:33:44.588] run() for ‘Future’ ...
[13:33:44.588] - state: ‘created’
[13:33:44.588] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:44.593] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:44.593] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:44.593]   - Field: ‘label’
[13:33:44.593]   - Field: ‘local’
[13:33:44.593]   - Field: ‘owner’
[13:33:44.593]   - Field: ‘envir’
[13:33:44.593]   - Field: ‘workers’
[13:33:44.594]   - Field: ‘packages’
[13:33:44.594]   - Field: ‘gc’
[13:33:44.594]   - Field: ‘job’
[13:33:44.594]   - Field: ‘conditions’
[13:33:44.594]   - Field: ‘expr’
[13:33:44.594]   - Field: ‘uuid’
[13:33:44.594]   - Field: ‘seed’
[13:33:44.595]   - Field: ‘version’
[13:33:44.595]   - Field: ‘result’
[13:33:44.595]   - Field: ‘asynchronous’
[13:33:44.595]   - Field: ‘calls’
[13:33:44.595]   - Field: ‘globals’
[13:33:44.595]   - Field: ‘stdout’
[13:33:44.595]   - Field: ‘earlySignal’
[13:33:44.595]   - Field: ‘lazy’
[13:33:44.596]   - Field: ‘state’
[13:33:44.596] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:44.596] - Launch lazy future ...
[13:33:44.596] Packages needed by the future expression (n = 0): <none>
[13:33:44.596] Packages needed by future strategies (n = 0): <none>
[13:33:44.597] {
[13:33:44.597]     {
[13:33:44.597]         {
[13:33:44.597]             ...future.startTime <- base::Sys.time()
[13:33:44.597]             {
[13:33:44.597]                 {
[13:33:44.597]                   {
[13:33:44.597]                     {
[13:33:44.597]                       base::local({
[13:33:44.597]                         has_future <- base::requireNamespace("future", 
[13:33:44.597]                           quietly = TRUE)
[13:33:44.597]                         if (has_future) {
[13:33:44.597]                           ns <- base::getNamespace("future")
[13:33:44.597]                           version <- ns[[".package"]][["version"]]
[13:33:44.597]                           if (is.null(version)) 
[13:33:44.597]                             version <- utils::packageVersion("future")
[13:33:44.597]                         }
[13:33:44.597]                         else {
[13:33:44.597]                           version <- NULL
[13:33:44.597]                         }
[13:33:44.597]                         if (!has_future || version < "1.8.0") {
[13:33:44.597]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:44.597]                             "", base::R.version$version.string), 
[13:33:44.597]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:44.597]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:44.597]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:44.597]                               "release", "version")], collapse = " "), 
[13:33:44.597]                             hostname = base::Sys.info()[["nodename"]])
[13:33:44.597]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:44.597]                             info)
[13:33:44.597]                           info <- base::paste(info, collapse = "; ")
[13:33:44.597]                           if (!has_future) {
[13:33:44.597]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:44.597]                               info)
[13:33:44.597]                           }
[13:33:44.597]                           else {
[13:33:44.597]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:44.597]                               info, version)
[13:33:44.597]                           }
[13:33:44.597]                           base::stop(msg)
[13:33:44.597]                         }
[13:33:44.597]                       })
[13:33:44.597]                     }
[13:33:44.597]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:44.597]                     base::options(mc.cores = 1L)
[13:33:44.597]                   }
[13:33:44.597]                   ...future.strategy.old <- future::plan("list")
[13:33:44.597]                   options(future.plan = NULL)
[13:33:44.597]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:44.597]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:44.597]                 }
[13:33:44.597]                 ...future.workdir <- getwd()
[13:33:44.597]             }
[13:33:44.597]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:44.597]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:44.597]         }
[13:33:44.597]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:44.597]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:44.597]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:44.597]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:44.597]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:44.597]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:44.597]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:44.597]             base::names(...future.oldOptions))
[13:33:44.597]     }
[13:33:44.597]     if (FALSE) {
[13:33:44.597]     }
[13:33:44.597]     else {
[13:33:44.597]         if (TRUE) {
[13:33:44.597]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:44.597]                 open = "w")
[13:33:44.597]         }
[13:33:44.597]         else {
[13:33:44.597]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:44.597]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:44.597]         }
[13:33:44.597]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:44.597]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:44.597]             base::sink(type = "output", split = FALSE)
[13:33:44.597]             base::close(...future.stdout)
[13:33:44.597]         }, add = TRUE)
[13:33:44.597]     }
[13:33:44.597]     ...future.frame <- base::sys.nframe()
[13:33:44.597]     ...future.conditions <- base::list()
[13:33:44.597]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:44.597]     if (FALSE) {
[13:33:44.597]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:44.597]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:44.597]     }
[13:33:44.597]     ...future.result <- base::tryCatch({
[13:33:44.597]         base::withCallingHandlers({
[13:33:44.597]             ...future.value <- base::withVisible(base::local({
[13:33:44.597]                 withCallingHandlers({
[13:33:44.597]                   {
[13:33:44.597]                     do.call(function(...) {
[13:33:44.597]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.597]                       if (!identical(...future.globals.maxSize.org, 
[13:33:44.597]                         ...future.globals.maxSize)) {
[13:33:44.597]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.597]                         on.exit(options(oopts), add = TRUE)
[13:33:44.597]                       }
[13:33:44.597]                       {
[13:33:44.597]                         lapply(seq_along(...future.elements_ii), 
[13:33:44.597]                           FUN = function(jj) {
[13:33:44.597]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.597]                             ...future.FUN(...future.X_jj, ...)
[13:33:44.597]                           })
[13:33:44.597]                       }
[13:33:44.597]                     }, args = future.call.arguments)
[13:33:44.597]                   }
[13:33:44.597]                 }, immediateCondition = function(cond) {
[13:33:44.597]                   save_rds <- function (object, pathname, ...) 
[13:33:44.597]                   {
[13:33:44.597]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:44.597]                     if (file_test("-f", pathname_tmp)) {
[13:33:44.597]                       fi_tmp <- file.info(pathname_tmp)
[13:33:44.597]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:44.597]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:44.597]                         fi_tmp[["mtime"]])
[13:33:44.597]                     }
[13:33:44.597]                     tryCatch({
[13:33:44.597]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:44.597]                     }, error = function(ex) {
[13:33:44.597]                       msg <- conditionMessage(ex)
[13:33:44.597]                       fi_tmp <- file.info(pathname_tmp)
[13:33:44.597]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:44.597]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:44.597]                         fi_tmp[["mtime"]], msg)
[13:33:44.597]                       ex$message <- msg
[13:33:44.597]                       stop(ex)
[13:33:44.597]                     })
[13:33:44.597]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:44.597]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:44.597]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:44.597]                       fi_tmp <- file.info(pathname_tmp)
[13:33:44.597]                       fi <- file.info(pathname)
[13:33:44.597]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:44.597]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:44.597]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:44.597]                         fi[["size"]], fi[["mtime"]])
[13:33:44.597]                       stop(msg)
[13:33:44.597]                     }
[13:33:44.597]                     invisible(pathname)
[13:33:44.597]                   }
[13:33:44.597]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:44.597]                     rootPath = tempdir()) 
[13:33:44.597]                   {
[13:33:44.597]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:44.597]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:44.597]                       tmpdir = path, fileext = ".rds")
[13:33:44.597]                     save_rds(obj, file)
[13:33:44.597]                   }
[13:33:44.597]                   saveImmediateCondition(cond, path = "/tmp/RtmpC9rl05/.future/immediateConditions")
[13:33:44.597]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.597]                   {
[13:33:44.597]                     inherits <- base::inherits
[13:33:44.597]                     invokeRestart <- base::invokeRestart
[13:33:44.597]                     is.null <- base::is.null
[13:33:44.597]                     muffled <- FALSE
[13:33:44.597]                     if (inherits(cond, "message")) {
[13:33:44.597]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:44.597]                       if (muffled) 
[13:33:44.597]                         invokeRestart("muffleMessage")
[13:33:44.597]                     }
[13:33:44.597]                     else if (inherits(cond, "warning")) {
[13:33:44.597]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:44.597]                       if (muffled) 
[13:33:44.597]                         invokeRestart("muffleWarning")
[13:33:44.597]                     }
[13:33:44.597]                     else if (inherits(cond, "condition")) {
[13:33:44.597]                       if (!is.null(pattern)) {
[13:33:44.597]                         computeRestarts <- base::computeRestarts
[13:33:44.597]                         grepl <- base::grepl
[13:33:44.597]                         restarts <- computeRestarts(cond)
[13:33:44.597]                         for (restart in restarts) {
[13:33:44.597]                           name <- restart$name
[13:33:44.597]                           if (is.null(name)) 
[13:33:44.597]                             next
[13:33:44.597]                           if (!grepl(pattern, name)) 
[13:33:44.597]                             next
[13:33:44.597]                           invokeRestart(restart)
[13:33:44.597]                           muffled <- TRUE
[13:33:44.597]                           break
[13:33:44.597]                         }
[13:33:44.597]                       }
[13:33:44.597]                     }
[13:33:44.597]                     invisible(muffled)
[13:33:44.597]                   }
[13:33:44.597]                   muffleCondition(cond)
[13:33:44.597]                 })
[13:33:44.597]             }))
[13:33:44.597]             future::FutureResult(value = ...future.value$value, 
[13:33:44.597]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:44.597]                   ...future.rng), globalenv = if (FALSE) 
[13:33:44.597]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:44.597]                     ...future.globalenv.names))
[13:33:44.597]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:44.597]         }, condition = base::local({
[13:33:44.597]             c <- base::c
[13:33:44.597]             inherits <- base::inherits
[13:33:44.597]             invokeRestart <- base::invokeRestart
[13:33:44.597]             length <- base::length
[13:33:44.597]             list <- base::list
[13:33:44.597]             seq.int <- base::seq.int
[13:33:44.597]             signalCondition <- base::signalCondition
[13:33:44.597]             sys.calls <- base::sys.calls
[13:33:44.597]             `[[` <- base::`[[`
[13:33:44.597]             `+` <- base::`+`
[13:33:44.597]             `<<-` <- base::`<<-`
[13:33:44.597]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:44.597]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:44.597]                   3L)]
[13:33:44.597]             }
[13:33:44.597]             function(cond) {
[13:33:44.597]                 is_error <- inherits(cond, "error")
[13:33:44.597]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:44.597]                   NULL)
[13:33:44.597]                 if (is_error) {
[13:33:44.597]                   sessionInformation <- function() {
[13:33:44.597]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:44.597]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:44.597]                       search = base::search(), system = base::Sys.info())
[13:33:44.597]                   }
[13:33:44.597]                   ...future.conditions[[length(...future.conditions) + 
[13:33:44.597]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:44.597]                     cond$call), session = sessionInformation(), 
[13:33:44.597]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:44.597]                   signalCondition(cond)
[13:33:44.597]                 }
[13:33:44.597]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:44.597]                 "immediateCondition"))) {
[13:33:44.597]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:44.597]                   ...future.conditions[[length(...future.conditions) + 
[13:33:44.597]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:44.597]                   if (TRUE && !signal) {
[13:33:44.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.597]                     {
[13:33:44.597]                       inherits <- base::inherits
[13:33:44.597]                       invokeRestart <- base::invokeRestart
[13:33:44.597]                       is.null <- base::is.null
[13:33:44.597]                       muffled <- FALSE
[13:33:44.597]                       if (inherits(cond, "message")) {
[13:33:44.597]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:44.597]                         if (muffled) 
[13:33:44.597]                           invokeRestart("muffleMessage")
[13:33:44.597]                       }
[13:33:44.597]                       else if (inherits(cond, "warning")) {
[13:33:44.597]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:44.597]                         if (muffled) 
[13:33:44.597]                           invokeRestart("muffleWarning")
[13:33:44.597]                       }
[13:33:44.597]                       else if (inherits(cond, "condition")) {
[13:33:44.597]                         if (!is.null(pattern)) {
[13:33:44.597]                           computeRestarts <- base::computeRestarts
[13:33:44.597]                           grepl <- base::grepl
[13:33:44.597]                           restarts <- computeRestarts(cond)
[13:33:44.597]                           for (restart in restarts) {
[13:33:44.597]                             name <- restart$name
[13:33:44.597]                             if (is.null(name)) 
[13:33:44.597]                               next
[13:33:44.597]                             if (!grepl(pattern, name)) 
[13:33:44.597]                               next
[13:33:44.597]                             invokeRestart(restart)
[13:33:44.597]                             muffled <- TRUE
[13:33:44.597]                             break
[13:33:44.597]                           }
[13:33:44.597]                         }
[13:33:44.597]                       }
[13:33:44.597]                       invisible(muffled)
[13:33:44.597]                     }
[13:33:44.597]                     muffleCondition(cond, pattern = "^muffle")
[13:33:44.597]                   }
[13:33:44.597]                 }
[13:33:44.597]                 else {
[13:33:44.597]                   if (TRUE) {
[13:33:44.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.597]                     {
[13:33:44.597]                       inherits <- base::inherits
[13:33:44.597]                       invokeRestart <- base::invokeRestart
[13:33:44.597]                       is.null <- base::is.null
[13:33:44.597]                       muffled <- FALSE
[13:33:44.597]                       if (inherits(cond, "message")) {
[13:33:44.597]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:44.597]                         if (muffled) 
[13:33:44.597]                           invokeRestart("muffleMessage")
[13:33:44.597]                       }
[13:33:44.597]                       else if (inherits(cond, "warning")) {
[13:33:44.597]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:44.597]                         if (muffled) 
[13:33:44.597]                           invokeRestart("muffleWarning")
[13:33:44.597]                       }
[13:33:44.597]                       else if (inherits(cond, "condition")) {
[13:33:44.597]                         if (!is.null(pattern)) {
[13:33:44.597]                           computeRestarts <- base::computeRestarts
[13:33:44.597]                           grepl <- base::grepl
[13:33:44.597]                           restarts <- computeRestarts(cond)
[13:33:44.597]                           for (restart in restarts) {
[13:33:44.597]                             name <- restart$name
[13:33:44.597]                             if (is.null(name)) 
[13:33:44.597]                               next
[13:33:44.597]                             if (!grepl(pattern, name)) 
[13:33:44.597]                               next
[13:33:44.597]                             invokeRestart(restart)
[13:33:44.597]                             muffled <- TRUE
[13:33:44.597]                             break
[13:33:44.597]                           }
[13:33:44.597]                         }
[13:33:44.597]                       }
[13:33:44.597]                       invisible(muffled)
[13:33:44.597]                     }
[13:33:44.597]                     muffleCondition(cond, pattern = "^muffle")
[13:33:44.597]                   }
[13:33:44.597]                 }
[13:33:44.597]             }
[13:33:44.597]         }))
[13:33:44.597]     }, error = function(ex) {
[13:33:44.597]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:44.597]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:44.597]                 ...future.rng), started = ...future.startTime, 
[13:33:44.597]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:44.597]             version = "1.8"), class = "FutureResult")
[13:33:44.597]     }, finally = {
[13:33:44.597]         if (!identical(...future.workdir, getwd())) 
[13:33:44.597]             setwd(...future.workdir)
[13:33:44.597]         {
[13:33:44.597]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:44.597]                 ...future.oldOptions$nwarnings <- NULL
[13:33:44.597]             }
[13:33:44.597]             base::options(...future.oldOptions)
[13:33:44.597]             if (.Platform$OS.type == "windows") {
[13:33:44.597]                 old_names <- names(...future.oldEnvVars)
[13:33:44.597]                 envs <- base::Sys.getenv()
[13:33:44.597]                 names <- names(envs)
[13:33:44.597]                 common <- intersect(names, old_names)
[13:33:44.597]                 added <- setdiff(names, old_names)
[13:33:44.597]                 removed <- setdiff(old_names, names)
[13:33:44.597]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:44.597]                   envs[common]]
[13:33:44.597]                 NAMES <- toupper(changed)
[13:33:44.597]                 args <- list()
[13:33:44.597]                 for (kk in seq_along(NAMES)) {
[13:33:44.597]                   name <- changed[[kk]]
[13:33:44.597]                   NAME <- NAMES[[kk]]
[13:33:44.597]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.597]                     next
[13:33:44.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:44.597]                 }
[13:33:44.597]                 NAMES <- toupper(added)
[13:33:44.597]                 for (kk in seq_along(NAMES)) {
[13:33:44.597]                   name <- added[[kk]]
[13:33:44.597]                   NAME <- NAMES[[kk]]
[13:33:44.597]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.597]                     next
[13:33:44.597]                   args[[name]] <- ""
[13:33:44.597]                 }
[13:33:44.597]                 NAMES <- toupper(removed)
[13:33:44.597]                 for (kk in seq_along(NAMES)) {
[13:33:44.597]                   name <- removed[[kk]]
[13:33:44.597]                   NAME <- NAMES[[kk]]
[13:33:44.597]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.597]                     next
[13:33:44.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:44.597]                 }
[13:33:44.597]                 if (length(args) > 0) 
[13:33:44.597]                   base::do.call(base::Sys.setenv, args = args)
[13:33:44.597]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:44.597]             }
[13:33:44.597]             else {
[13:33:44.597]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:44.597]             }
[13:33:44.597]             {
[13:33:44.597]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:44.597]                   0L) {
[13:33:44.597]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:44.597]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:44.597]                   base::options(opts)
[13:33:44.597]                 }
[13:33:44.597]                 {
[13:33:44.597]                   {
[13:33:44.597]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:44.597]                     NULL
[13:33:44.597]                   }
[13:33:44.597]                   options(future.plan = NULL)
[13:33:44.597]                   if (is.na(NA_character_)) 
[13:33:44.597]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:44.597]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:44.597]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:44.597]                     .init = FALSE)
[13:33:44.597]                 }
[13:33:44.597]             }
[13:33:44.597]         }
[13:33:44.597]     })
[13:33:44.597]     if (TRUE) {
[13:33:44.597]         base::sink(type = "output", split = FALSE)
[13:33:44.597]         if (TRUE) {
[13:33:44.597]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:44.597]         }
[13:33:44.597]         else {
[13:33:44.597]             ...future.result["stdout"] <- base::list(NULL)
[13:33:44.597]         }
[13:33:44.597]         base::close(...future.stdout)
[13:33:44.597]         ...future.stdout <- NULL
[13:33:44.597]     }
[13:33:44.597]     ...future.result$conditions <- ...future.conditions
[13:33:44.597]     ...future.result$finished <- base::Sys.time()
[13:33:44.597]     ...future.result
[13:33:44.597] }
[13:33:44.600] assign_globals() ...
[13:33:44.601] List of 5
[13:33:44.601]  $ ...future.FUN            :function (x, ...)  
[13:33:44.601]  $ future.call.arguments    : list()
[13:33:44.601]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.601]  $ ...future.elements_ii    :List of 2
[13:33:44.601]   ..$ : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:33:44.601]   ..$ : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:33:44.601]  $ ...future.seeds_ii       : NULL
[13:33:44.601]  $ ...future.globals.maxSize: NULL
[13:33:44.601]  - attr(*, "where")=List of 5
[13:33:44.601]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:44.601]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:44.601]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:44.601]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:44.601]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:44.601]  - attr(*, "resolved")= logi FALSE
[13:33:44.601]  - attr(*, "total_size")= num 1240
[13:33:44.601]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.601]  - attr(*, "already-done")= logi TRUE
[13:33:44.613] - copied ‘...future.FUN’ to environment
[13:33:44.613] - copied ‘future.call.arguments’ to environment
[13:33:44.614] - copied ‘...future.elements_ii’ to environment
[13:33:44.614] - copied ‘...future.seeds_ii’ to environment
[13:33:44.614] - copied ‘...future.globals.maxSize’ to environment
[13:33:44.614] assign_globals() ... done
[13:33:44.614] requestCore(): workers = 2
[13:33:44.620] MulticoreFuture started
[13:33:44.621] - Launch lazy future ... done
[13:33:44.621] run() for ‘MulticoreFuture’ ... done
[13:33:44.621] Created future:
[13:33:44.621] plan(): Setting new future strategy stack:
[13:33:44.622] List of future strategies:
[13:33:44.622] 1. sequential:
[13:33:44.622]    - args: function (..., envir = parent.frame())
[13:33:44.622]    - tweaked: FALSE
[13:33:44.622]    - call: NULL
[13:33:44.623] plan(): nbrOfWorkers() = 1
[13:33:44.625] plan(): Setting new future strategy stack:
[13:33:44.625] List of future strategies:
[13:33:44.625] 1. multicore:
[13:33:44.625]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:44.625]    - tweaked: FALSE
[13:33:44.625]    - call: plan(strategy)
[13:33:44.630] plan(): nbrOfWorkers() = 2
[13:33:44.621] MulticoreFuture:
[13:33:44.621] Label: ‘future_eapply-2’
[13:33:44.621] Expression:
[13:33:44.621] {
[13:33:44.621]     do.call(function(...) {
[13:33:44.621]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.621]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:44.621]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.621]             on.exit(options(oopts), add = TRUE)
[13:33:44.621]         }
[13:33:44.621]         {
[13:33:44.621]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:44.621]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.621]                 ...future.FUN(...future.X_jj, ...)
[13:33:44.621]             })
[13:33:44.621]         }
[13:33:44.621]     }, args = future.call.arguments)
[13:33:44.621] }
[13:33:44.621] Lazy evaluation: FALSE
[13:33:44.621] Asynchronous evaluation: TRUE
[13:33:44.621] Local evaluation: TRUE
[13:33:44.621] Environment: R_GlobalEnv
[13:33:44.621] Capture standard output: TRUE
[13:33:44.621] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:44.621] Globals: 5 objects totaling 1.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:44.621] Packages: <none>
[13:33:44.621] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:44.621] Resolved: TRUE
[13:33:44.621] Value: <not collected>
[13:33:44.621] Conditions captured: <none>
[13:33:44.621] Early signaling: FALSE
[13:33:44.621] Owner process: b6e93464-7fc2-3f8d-23d1-d8004201d1f1
[13:33:44.621] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:44.631] Chunk #2 of 2 ... DONE
[13:33:44.631] Launching 2 futures (chunks) ... DONE
[13:33:44.631] Resolving 2 futures (chunks) ...
[13:33:44.631] resolve() on list ...
[13:33:44.632]  recursive: 0
[13:33:44.632]  length: 2
[13:33:44.632] 
[13:33:44.632] Future #1
[13:33:44.633] result() for MulticoreFuture ...
[13:33:44.635] result() for MulticoreFuture ...
[13:33:44.635] result() for MulticoreFuture ... done
[13:33:44.635] result() for MulticoreFuture ... done
[13:33:44.635] result() for MulticoreFuture ...
[13:33:44.635] result() for MulticoreFuture ... done
[13:33:44.636] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:33:44.636] - nx: 2
[13:33:44.636] - relay: TRUE
[13:33:44.636] - stdout: TRUE
[13:33:44.636] - signal: TRUE
[13:33:44.636] - resignal: FALSE
[13:33:44.636] - force: TRUE
[13:33:44.637] - relayed: [n=2] FALSE, FALSE
[13:33:44.637] - queued futures: [n=2] FALSE, FALSE
[13:33:44.637]  - until=1
[13:33:44.637]  - relaying element #1
[13:33:44.637] result() for MulticoreFuture ...
[13:33:44.637] result() for MulticoreFuture ... done
[13:33:44.637] result() for MulticoreFuture ...
[13:33:44.638] result() for MulticoreFuture ... done
[13:33:44.638] result() for MulticoreFuture ...
[13:33:44.638] result() for MulticoreFuture ... done
[13:33:44.638] result() for MulticoreFuture ...
[13:33:44.638] result() for MulticoreFuture ... done
[13:33:44.638] - relayed: [n=2] TRUE, FALSE
[13:33:44.638] - queued futures: [n=2] TRUE, FALSE
[13:33:44.639] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:33:44.639]  length: 1 (resolved future 1)
[13:33:44.639] Future #2
[13:33:44.639] result() for MulticoreFuture ...
[13:33:44.640] result() for MulticoreFuture ...
[13:33:44.640] result() for MulticoreFuture ... done
[13:33:44.640] result() for MulticoreFuture ... done
[13:33:44.640] result() for MulticoreFuture ...
[13:33:44.640] result() for MulticoreFuture ... done
[13:33:44.641] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:33:44.641] - nx: 2
[13:33:44.641] - relay: TRUE
[13:33:44.641] - stdout: TRUE
[13:33:44.641] - signal: TRUE
[13:33:44.641] - resignal: FALSE
[13:33:44.641] - force: TRUE
[13:33:44.641] - relayed: [n=2] TRUE, FALSE
[13:33:44.642] - queued futures: [n=2] TRUE, FALSE
[13:33:44.642]  - until=2
[13:33:44.642]  - relaying element #2
[13:33:44.642] result() for MulticoreFuture ...
[13:33:44.642] result() for MulticoreFuture ... done
[13:33:44.642] result() for MulticoreFuture ...
[13:33:44.642] result() for MulticoreFuture ... done
[13:33:44.643] result() for MulticoreFuture ...
[13:33:44.643] result() for MulticoreFuture ... done
[13:33:44.643] result() for MulticoreFuture ...
[13:33:44.643] result() for MulticoreFuture ... done
[13:33:44.643] - relayed: [n=2] TRUE, TRUE
[13:33:44.643] - queued futures: [n=2] TRUE, TRUE
[13:33:44.643] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:33:44.643]  length: 0 (resolved future 2)
[13:33:44.643] Relaying remaining futures
[13:33:44.643] signalConditionsASAP(NULL, pos=0) ...
[13:33:44.644] - nx: 2
[13:33:44.644] - relay: TRUE
[13:33:44.644] - stdout: TRUE
[13:33:44.644] - signal: TRUE
[13:33:44.644] - resignal: FALSE
[13:33:44.644] - force: TRUE
[13:33:44.644] - relayed: [n=2] TRUE, TRUE
[13:33:44.644] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:44.644] - relayed: [n=2] TRUE, TRUE
[13:33:44.645] - queued futures: [n=2] TRUE, TRUE
[13:33:44.645] signalConditionsASAP(NULL, pos=0) ... done
[13:33:44.645] resolve() on list ... DONE
[13:33:44.645] result() for MulticoreFuture ...
[13:33:44.645] result() for MulticoreFuture ... done
[13:33:44.645] result() for MulticoreFuture ...
[13:33:44.645] result() for MulticoreFuture ... done
[13:33:44.645] result() for MulticoreFuture ...
[13:33:44.645] result() for MulticoreFuture ... done
[13:33:44.646] result() for MulticoreFuture ...
[13:33:44.646] result() for MulticoreFuture ... done
[13:33:44.646]  - Number of value chunks collected: 2
[13:33:44.646] Resolving 2 futures (chunks) ... DONE
[13:33:44.646] Reducing values from 2 chunks ...
[13:33:44.646]  - Number of values collected after concatenation: 3
[13:33:44.646]  - Number of values expected: 3
[13:33:44.646] Reducing values from 2 chunks ... DONE
[13:33:44.647] future_lapply() ... DONE
[13:33:44.647] future_lapply() ...
[13:33:44.654] Number of chunks: 2
[13:33:44.654] getGlobalsAndPackagesXApply() ...
[13:33:44.655]  - future.globals: TRUE
[13:33:44.655] getGlobalsAndPackages() ...
[13:33:44.655] Searching for globals...
[13:33:44.657] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:44.657] Searching for globals ... DONE
[13:33:44.657] Resolving globals: FALSE
[13:33:44.657] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:33:44.658] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:33:44.658] - globals: [1] ‘FUN’
[13:33:44.658] - packages: [1] ‘stats’
[13:33:44.658] getGlobalsAndPackages() ... DONE
[13:33:44.658]  - globals found/used: [n=1] ‘FUN’
[13:33:44.659]  - needed namespaces: [n=1] ‘stats’
[13:33:44.659] Finding globals ... DONE
[13:33:44.659]  - use_args: TRUE
[13:33:44.659]  - Getting '...' globals ...
[13:33:44.659] resolve() on list ...
[13:33:44.660]  recursive: 0
[13:33:44.660]  length: 1
[13:33:44.660]  elements: ‘...’
[13:33:44.660]  length: 0 (resolved future 1)
[13:33:44.660] resolve() on list ... DONE
[13:33:44.660]    - '...' content: [n=1] ‘probs’
[13:33:44.660] List of 1
[13:33:44.660]  $ ...:List of 1
[13:33:44.660]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:33:44.660]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.660]  - attr(*, "where")=List of 1
[13:33:44.660]   ..$ ...:<environment: 0x559846588b88> 
[13:33:44.660]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.660]  - attr(*, "resolved")= logi TRUE
[13:33:44.660]  - attr(*, "total_size")= num NA
[13:33:44.664]  - Getting '...' globals ... DONE
[13:33:44.664] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:44.664] List of 2
[13:33:44.664]  $ ...future.FUN:function (x, ...)  
[13:33:44.664]  $ ...          :List of 1
[13:33:44.664]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:33:44.664]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.664]  - attr(*, "where")=List of 2
[13:33:44.664]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:44.664]   ..$ ...          :<environment: 0x559846588b88> 
[13:33:44.664]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.664]  - attr(*, "resolved")= logi FALSE
[13:33:44.664]  - attr(*, "total_size")= num 1328
[13:33:44.667] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:44.667] getGlobalsAndPackagesXApply() ... DONE
[13:33:44.668] Number of futures (= number of chunks): 2
[13:33:44.668] Launching 2 futures (chunks) ...
[13:33:44.668] Chunk #1 of 2 ...
[13:33:44.668]  - Finding globals in 'X' for chunk #1 ...
[13:33:44.668] getGlobalsAndPackages() ...
[13:33:44.668] Searching for globals...
[13:33:44.668] 
[13:33:44.668] Searching for globals ... DONE
[13:33:44.669] - globals: [0] <none>
[13:33:44.669] getGlobalsAndPackages() ... DONE
[13:33:44.669]    + additional globals found: [n=0] 
[13:33:44.669]    + additional namespaces needed: [n=0] 
[13:33:44.669]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:44.669]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:44.669]  - seeds: <none>
[13:33:44.669]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.669] getGlobalsAndPackages() ...
[13:33:44.669] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.669] Resolving globals: FALSE
[13:33:44.670] Tweak future expression to call with '...' arguments ...
[13:33:44.670] {
[13:33:44.670]     do.call(function(...) {
[13:33:44.670]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.670]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:44.670]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.670]             on.exit(options(oopts), add = TRUE)
[13:33:44.670]         }
[13:33:44.670]         {
[13:33:44.670]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:44.670]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.670]                 ...future.FUN(...future.X_jj, ...)
[13:33:44.670]             })
[13:33:44.670]         }
[13:33:44.670]     }, args = future.call.arguments)
[13:33:44.670] }
[13:33:44.670] Tweak future expression to call with '...' arguments ... DONE
[13:33:44.670] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.670] - packages: [1] ‘stats’
[13:33:44.671] getGlobalsAndPackages() ... DONE
[13:33:44.671] run() for ‘Future’ ...
[13:33:44.671] - state: ‘created’
[13:33:44.671] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:44.675] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:44.675] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:44.675]   - Field: ‘label’
[13:33:44.675]   - Field: ‘local’
[13:33:44.675]   - Field: ‘owner’
[13:33:44.675]   - Field: ‘envir’
[13:33:44.675]   - Field: ‘workers’
[13:33:44.675]   - Field: ‘packages’
[13:33:44.675]   - Field: ‘gc’
[13:33:44.676]   - Field: ‘job’
[13:33:44.676]   - Field: ‘conditions’
[13:33:44.676]   - Field: ‘expr’
[13:33:44.676]   - Field: ‘uuid’
[13:33:44.676]   - Field: ‘seed’
[13:33:44.676]   - Field: ‘version’
[13:33:44.676]   - Field: ‘result’
[13:33:44.676]   - Field: ‘asynchronous’
[13:33:44.676]   - Field: ‘calls’
[13:33:44.676]   - Field: ‘globals’
[13:33:44.676]   - Field: ‘stdout’
[13:33:44.677]   - Field: ‘earlySignal’
[13:33:44.677]   - Field: ‘lazy’
[13:33:44.677]   - Field: ‘state’
[13:33:44.677] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:44.677] - Launch lazy future ...
[13:33:44.677] Packages needed by the future expression (n = 1): ‘stats’
[13:33:44.677] Packages needed by future strategies (n = 0): <none>
[13:33:44.678] {
[13:33:44.678]     {
[13:33:44.678]         {
[13:33:44.678]             ...future.startTime <- base::Sys.time()
[13:33:44.678]             {
[13:33:44.678]                 {
[13:33:44.678]                   {
[13:33:44.678]                     {
[13:33:44.678]                       {
[13:33:44.678]                         base::local({
[13:33:44.678]                           has_future <- base::requireNamespace("future", 
[13:33:44.678]                             quietly = TRUE)
[13:33:44.678]                           if (has_future) {
[13:33:44.678]                             ns <- base::getNamespace("future")
[13:33:44.678]                             version <- ns[[".package"]][["version"]]
[13:33:44.678]                             if (is.null(version)) 
[13:33:44.678]                               version <- utils::packageVersion("future")
[13:33:44.678]                           }
[13:33:44.678]                           else {
[13:33:44.678]                             version <- NULL
[13:33:44.678]                           }
[13:33:44.678]                           if (!has_future || version < "1.8.0") {
[13:33:44.678]                             info <- base::c(r_version = base::gsub("R version ", 
[13:33:44.678]                               "", base::R.version$version.string), 
[13:33:44.678]                               platform = base::sprintf("%s (%s-bit)", 
[13:33:44.678]                                 base::R.version$platform, 8 * 
[13:33:44.678]                                   base::.Machine$sizeof.pointer), 
[13:33:44.678]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:44.678]                                 "release", "version")], collapse = " "), 
[13:33:44.678]                               hostname = base::Sys.info()[["nodename"]])
[13:33:44.678]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:33:44.678]                               info)
[13:33:44.678]                             info <- base::paste(info, collapse = "; ")
[13:33:44.678]                             if (!has_future) {
[13:33:44.678]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:44.678]                                 info)
[13:33:44.678]                             }
[13:33:44.678]                             else {
[13:33:44.678]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:44.678]                                 info, version)
[13:33:44.678]                             }
[13:33:44.678]                             base::stop(msg)
[13:33:44.678]                           }
[13:33:44.678]                         })
[13:33:44.678]                       }
[13:33:44.678]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:44.678]                       base::options(mc.cores = 1L)
[13:33:44.678]                     }
[13:33:44.678]                     base::local({
[13:33:44.678]                       for (pkg in "stats") {
[13:33:44.678]                         base::loadNamespace(pkg)
[13:33:44.678]                         base::library(pkg, character.only = TRUE)
[13:33:44.678]                       }
[13:33:44.678]                     })
[13:33:44.678]                   }
[13:33:44.678]                   ...future.strategy.old <- future::plan("list")
[13:33:44.678]                   options(future.plan = NULL)
[13:33:44.678]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:44.678]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:44.678]                 }
[13:33:44.678]                 ...future.workdir <- getwd()
[13:33:44.678]             }
[13:33:44.678]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:44.678]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:44.678]         }
[13:33:44.678]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:44.678]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:44.678]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:44.678]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:44.678]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:44.678]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:44.678]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:44.678]             base::names(...future.oldOptions))
[13:33:44.678]     }
[13:33:44.678]     if (FALSE) {
[13:33:44.678]     }
[13:33:44.678]     else {
[13:33:44.678]         if (TRUE) {
[13:33:44.678]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:44.678]                 open = "w")
[13:33:44.678]         }
[13:33:44.678]         else {
[13:33:44.678]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:44.678]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:44.678]         }
[13:33:44.678]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:44.678]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:44.678]             base::sink(type = "output", split = FALSE)
[13:33:44.678]             base::close(...future.stdout)
[13:33:44.678]         }, add = TRUE)
[13:33:44.678]     }
[13:33:44.678]     ...future.frame <- base::sys.nframe()
[13:33:44.678]     ...future.conditions <- base::list()
[13:33:44.678]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:44.678]     if (FALSE) {
[13:33:44.678]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:44.678]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:44.678]     }
[13:33:44.678]     ...future.result <- base::tryCatch({
[13:33:44.678]         base::withCallingHandlers({
[13:33:44.678]             ...future.value <- base::withVisible(base::local({
[13:33:44.678]                 withCallingHandlers({
[13:33:44.678]                   {
[13:33:44.678]                     do.call(function(...) {
[13:33:44.678]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.678]                       if (!identical(...future.globals.maxSize.org, 
[13:33:44.678]                         ...future.globals.maxSize)) {
[13:33:44.678]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.678]                         on.exit(options(oopts), add = TRUE)
[13:33:44.678]                       }
[13:33:44.678]                       {
[13:33:44.678]                         lapply(seq_along(...future.elements_ii), 
[13:33:44.678]                           FUN = function(jj) {
[13:33:44.678]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.678]                             ...future.FUN(...future.X_jj, ...)
[13:33:44.678]                           })
[13:33:44.678]                       }
[13:33:44.678]                     }, args = future.call.arguments)
[13:33:44.678]                   }
[13:33:44.678]                 }, immediateCondition = function(cond) {
[13:33:44.678]                   save_rds <- function (object, pathname, ...) 
[13:33:44.678]                   {
[13:33:44.678]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:44.678]                     if (file_test("-f", pathname_tmp)) {
[13:33:44.678]                       fi_tmp <- file.info(pathname_tmp)
[13:33:44.678]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:44.678]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:44.678]                         fi_tmp[["mtime"]])
[13:33:44.678]                     }
[13:33:44.678]                     tryCatch({
[13:33:44.678]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:44.678]                     }, error = function(ex) {
[13:33:44.678]                       msg <- conditionMessage(ex)
[13:33:44.678]                       fi_tmp <- file.info(pathname_tmp)
[13:33:44.678]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:44.678]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:44.678]                         fi_tmp[["mtime"]], msg)
[13:33:44.678]                       ex$message <- msg
[13:33:44.678]                       stop(ex)
[13:33:44.678]                     })
[13:33:44.678]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:44.678]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:44.678]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:44.678]                       fi_tmp <- file.info(pathname_tmp)
[13:33:44.678]                       fi <- file.info(pathname)
[13:33:44.678]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:44.678]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:44.678]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:44.678]                         fi[["size"]], fi[["mtime"]])
[13:33:44.678]                       stop(msg)
[13:33:44.678]                     }
[13:33:44.678]                     invisible(pathname)
[13:33:44.678]                   }
[13:33:44.678]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:44.678]                     rootPath = tempdir()) 
[13:33:44.678]                   {
[13:33:44.678]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:44.678]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:44.678]                       tmpdir = path, fileext = ".rds")
[13:33:44.678]                     save_rds(obj, file)
[13:33:44.678]                   }
[13:33:44.678]                   saveImmediateCondition(cond, path = "/tmp/RtmpC9rl05/.future/immediateConditions")
[13:33:44.678]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.678]                   {
[13:33:44.678]                     inherits <- base::inherits
[13:33:44.678]                     invokeRestart <- base::invokeRestart
[13:33:44.678]                     is.null <- base::is.null
[13:33:44.678]                     muffled <- FALSE
[13:33:44.678]                     if (inherits(cond, "message")) {
[13:33:44.678]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:44.678]                       if (muffled) 
[13:33:44.678]                         invokeRestart("muffleMessage")
[13:33:44.678]                     }
[13:33:44.678]                     else if (inherits(cond, "warning")) {
[13:33:44.678]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:44.678]                       if (muffled) 
[13:33:44.678]                         invokeRestart("muffleWarning")
[13:33:44.678]                     }
[13:33:44.678]                     else if (inherits(cond, "condition")) {
[13:33:44.678]                       if (!is.null(pattern)) {
[13:33:44.678]                         computeRestarts <- base::computeRestarts
[13:33:44.678]                         grepl <- base::grepl
[13:33:44.678]                         restarts <- computeRestarts(cond)
[13:33:44.678]                         for (restart in restarts) {
[13:33:44.678]                           name <- restart$name
[13:33:44.678]                           if (is.null(name)) 
[13:33:44.678]                             next
[13:33:44.678]                           if (!grepl(pattern, name)) 
[13:33:44.678]                             next
[13:33:44.678]                           invokeRestart(restart)
[13:33:44.678]                           muffled <- TRUE
[13:33:44.678]                           break
[13:33:44.678]                         }
[13:33:44.678]                       }
[13:33:44.678]                     }
[13:33:44.678]                     invisible(muffled)
[13:33:44.678]                   }
[13:33:44.678]                   muffleCondition(cond)
[13:33:44.678]                 })
[13:33:44.678]             }))
[13:33:44.678]             future::FutureResult(value = ...future.value$value, 
[13:33:44.678]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:44.678]                   ...future.rng), globalenv = if (FALSE) 
[13:33:44.678]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:44.678]                     ...future.globalenv.names))
[13:33:44.678]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:44.678]         }, condition = base::local({
[13:33:44.678]             c <- base::c
[13:33:44.678]             inherits <- base::inherits
[13:33:44.678]             invokeRestart <- base::invokeRestart
[13:33:44.678]             length <- base::length
[13:33:44.678]             list <- base::list
[13:33:44.678]             seq.int <- base::seq.int
[13:33:44.678]             signalCondition <- base::signalCondition
[13:33:44.678]             sys.calls <- base::sys.calls
[13:33:44.678]             `[[` <- base::`[[`
[13:33:44.678]             `+` <- base::`+`
[13:33:44.678]             `<<-` <- base::`<<-`
[13:33:44.678]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:44.678]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:44.678]                   3L)]
[13:33:44.678]             }
[13:33:44.678]             function(cond) {
[13:33:44.678]                 is_error <- inherits(cond, "error")
[13:33:44.678]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:44.678]                   NULL)
[13:33:44.678]                 if (is_error) {
[13:33:44.678]                   sessionInformation <- function() {
[13:33:44.678]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:44.678]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:44.678]                       search = base::search(), system = base::Sys.info())
[13:33:44.678]                   }
[13:33:44.678]                   ...future.conditions[[length(...future.conditions) + 
[13:33:44.678]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:44.678]                     cond$call), session = sessionInformation(), 
[13:33:44.678]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:44.678]                   signalCondition(cond)
[13:33:44.678]                 }
[13:33:44.678]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:44.678]                 "immediateCondition"))) {
[13:33:44.678]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:44.678]                   ...future.conditions[[length(...future.conditions) + 
[13:33:44.678]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:44.678]                   if (TRUE && !signal) {
[13:33:44.678]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.678]                     {
[13:33:44.678]                       inherits <- base::inherits
[13:33:44.678]                       invokeRestart <- base::invokeRestart
[13:33:44.678]                       is.null <- base::is.null
[13:33:44.678]                       muffled <- FALSE
[13:33:44.678]                       if (inherits(cond, "message")) {
[13:33:44.678]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:44.678]                         if (muffled) 
[13:33:44.678]                           invokeRestart("muffleMessage")
[13:33:44.678]                       }
[13:33:44.678]                       else if (inherits(cond, "warning")) {
[13:33:44.678]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:44.678]                         if (muffled) 
[13:33:44.678]                           invokeRestart("muffleWarning")
[13:33:44.678]                       }
[13:33:44.678]                       else if (inherits(cond, "condition")) {
[13:33:44.678]                         if (!is.null(pattern)) {
[13:33:44.678]                           computeRestarts <- base::computeRestarts
[13:33:44.678]                           grepl <- base::grepl
[13:33:44.678]                           restarts <- computeRestarts(cond)
[13:33:44.678]                           for (restart in restarts) {
[13:33:44.678]                             name <- restart$name
[13:33:44.678]                             if (is.null(name)) 
[13:33:44.678]                               next
[13:33:44.678]                             if (!grepl(pattern, name)) 
[13:33:44.678]                               next
[13:33:44.678]                             invokeRestart(restart)
[13:33:44.678]                             muffled <- TRUE
[13:33:44.678]                             break
[13:33:44.678]                           }
[13:33:44.678]                         }
[13:33:44.678]                       }
[13:33:44.678]                       invisible(muffled)
[13:33:44.678]                     }
[13:33:44.678]                     muffleCondition(cond, pattern = "^muffle")
[13:33:44.678]                   }
[13:33:44.678]                 }
[13:33:44.678]                 else {
[13:33:44.678]                   if (TRUE) {
[13:33:44.678]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.678]                     {
[13:33:44.678]                       inherits <- base::inherits
[13:33:44.678]                       invokeRestart <- base::invokeRestart
[13:33:44.678]                       is.null <- base::is.null
[13:33:44.678]                       muffled <- FALSE
[13:33:44.678]                       if (inherits(cond, "message")) {
[13:33:44.678]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:44.678]                         if (muffled) 
[13:33:44.678]                           invokeRestart("muffleMessage")
[13:33:44.678]                       }
[13:33:44.678]                       else if (inherits(cond, "warning")) {
[13:33:44.678]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:44.678]                         if (muffled) 
[13:33:44.678]                           invokeRestart("muffleWarning")
[13:33:44.678]                       }
[13:33:44.678]                       else if (inherits(cond, "condition")) {
[13:33:44.678]                         if (!is.null(pattern)) {
[13:33:44.678]                           computeRestarts <- base::computeRestarts
[13:33:44.678]                           grepl <- base::grepl
[13:33:44.678]                           restarts <- computeRestarts(cond)
[13:33:44.678]                           for (restart in restarts) {
[13:33:44.678]                             name <- restart$name
[13:33:44.678]                             if (is.null(name)) 
[13:33:44.678]                               next
[13:33:44.678]                             if (!grepl(pattern, name)) 
[13:33:44.678]                               next
[13:33:44.678]                             invokeRestart(restart)
[13:33:44.678]                             muffled <- TRUE
[13:33:44.678]                             break
[13:33:44.678]                           }
[13:33:44.678]                         }
[13:33:44.678]                       }
[13:33:44.678]                       invisible(muffled)
[13:33:44.678]                     }
[13:33:44.678]                     muffleCondition(cond, pattern = "^muffle")
[13:33:44.678]                   }
[13:33:44.678]                 }
[13:33:44.678]             }
[13:33:44.678]         }))
[13:33:44.678]     }, error = function(ex) {
[13:33:44.678]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:44.678]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:44.678]                 ...future.rng), started = ...future.startTime, 
[13:33:44.678]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:44.678]             version = "1.8"), class = "FutureResult")
[13:33:44.678]     }, finally = {
[13:33:44.678]         if (!identical(...future.workdir, getwd())) 
[13:33:44.678]             setwd(...future.workdir)
[13:33:44.678]         {
[13:33:44.678]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:44.678]                 ...future.oldOptions$nwarnings <- NULL
[13:33:44.678]             }
[13:33:44.678]             base::options(...future.oldOptions)
[13:33:44.678]             if (.Platform$OS.type == "windows") {
[13:33:44.678]                 old_names <- names(...future.oldEnvVars)
[13:33:44.678]                 envs <- base::Sys.getenv()
[13:33:44.678]                 names <- names(envs)
[13:33:44.678]                 common <- intersect(names, old_names)
[13:33:44.678]                 added <- setdiff(names, old_names)
[13:33:44.678]                 removed <- setdiff(old_names, names)
[13:33:44.678]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:44.678]                   envs[common]]
[13:33:44.678]                 NAMES <- toupper(changed)
[13:33:44.678]                 args <- list()
[13:33:44.678]                 for (kk in seq_along(NAMES)) {
[13:33:44.678]                   name <- changed[[kk]]
[13:33:44.678]                   NAME <- NAMES[[kk]]
[13:33:44.678]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.678]                     next
[13:33:44.678]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:44.678]                 }
[13:33:44.678]                 NAMES <- toupper(added)
[13:33:44.678]                 for (kk in seq_along(NAMES)) {
[13:33:44.678]                   name <- added[[kk]]
[13:33:44.678]                   NAME <- NAMES[[kk]]
[13:33:44.678]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.678]                     next
[13:33:44.678]                   args[[name]] <- ""
[13:33:44.678]                 }
[13:33:44.678]                 NAMES <- toupper(removed)
[13:33:44.678]                 for (kk in seq_along(NAMES)) {
[13:33:44.678]                   name <- removed[[kk]]
[13:33:44.678]                   NAME <- NAMES[[kk]]
[13:33:44.678]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.678]                     next
[13:33:44.678]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:44.678]                 }
[13:33:44.678]                 if (length(args) > 0) 
[13:33:44.678]                   base::do.call(base::Sys.setenv, args = args)
[13:33:44.678]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:44.678]             }
[13:33:44.678]             else {
[13:33:44.678]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:44.678]             }
[13:33:44.678]             {
[13:33:44.678]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:44.678]                   0L) {
[13:33:44.678]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:44.678]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:44.678]                   base::options(opts)
[13:33:44.678]                 }
[13:33:44.678]                 {
[13:33:44.678]                   {
[13:33:44.678]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:44.678]                     NULL
[13:33:44.678]                   }
[13:33:44.678]                   options(future.plan = NULL)
[13:33:44.678]                   if (is.na(NA_character_)) 
[13:33:44.678]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:44.678]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:44.678]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:44.678]                     .init = FALSE)
[13:33:44.678]                 }
[13:33:44.678]             }
[13:33:44.678]         }
[13:33:44.678]     })
[13:33:44.678]     if (TRUE) {
[13:33:44.678]         base::sink(type = "output", split = FALSE)
[13:33:44.678]         if (TRUE) {
[13:33:44.678]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:44.678]         }
[13:33:44.678]         else {
[13:33:44.678]             ...future.result["stdout"] <- base::list(NULL)
[13:33:44.678]         }
[13:33:44.678]         base::close(...future.stdout)
[13:33:44.678]         ...future.stdout <- NULL
[13:33:44.678]     }
[13:33:44.678]     ...future.result$conditions <- ...future.conditions
[13:33:44.678]     ...future.result$finished <- base::Sys.time()
[13:33:44.678]     ...future.result
[13:33:44.678] }
[13:33:44.680] assign_globals() ...
[13:33:44.681] List of 5
[13:33:44.681]  $ ...future.FUN            :function (x, ...)  
[13:33:44.681]  $ future.call.arguments    :List of 1
[13:33:44.681]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:33:44.681]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.681]  $ ...future.elements_ii    :List of 1
[13:33:44.681]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[13:33:44.681]  $ ...future.seeds_ii       : NULL
[13:33:44.681]  $ ...future.globals.maxSize: NULL
[13:33:44.681]  - attr(*, "where")=List of 5
[13:33:44.681]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:44.681]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:44.681]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:44.681]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:44.681]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:44.681]  - attr(*, "resolved")= logi FALSE
[13:33:44.681]  - attr(*, "total_size")= num 1328
[13:33:44.681]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.681]  - attr(*, "already-done")= logi TRUE
[13:33:44.687] - copied ‘...future.FUN’ to environment
[13:33:44.688] - copied ‘future.call.arguments’ to environment
[13:33:44.688] - copied ‘...future.elements_ii’ to environment
[13:33:44.688] - copied ‘...future.seeds_ii’ to environment
[13:33:44.688] - copied ‘...future.globals.maxSize’ to environment
[13:33:44.688] assign_globals() ... done
[13:33:44.688] requestCore(): workers = 2
[13:33:44.690] MulticoreFuture started
[13:33:44.690] - Launch lazy future ... done
[13:33:44.691] run() for ‘MulticoreFuture’ ... done
[13:33:44.691] Created future:
[13:33:44.692] plan(): Setting new future strategy stack:
[13:33:44.692] List of future strategies:
[13:33:44.692] 1. sequential:
[13:33:44.692]    - args: function (..., envir = parent.frame())
[13:33:44.692]    - tweaked: FALSE
[13:33:44.692]    - call: NULL
[13:33:44.693] plan(): nbrOfWorkers() = 1
[13:33:44.695] plan(): Setting new future strategy stack:
[13:33:44.695] List of future strategies:
[13:33:44.695] 1. multicore:
[13:33:44.695]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:44.695]    - tweaked: FALSE
[13:33:44.695]    - call: plan(strategy)
[13:33:44.700] plan(): nbrOfWorkers() = 2
[13:33:44.691] MulticoreFuture:
[13:33:44.691] Label: ‘future_eapply-1’
[13:33:44.691] Expression:
[13:33:44.691] {
[13:33:44.691]     do.call(function(...) {
[13:33:44.691]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.691]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:44.691]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.691]             on.exit(options(oopts), add = TRUE)
[13:33:44.691]         }
[13:33:44.691]         {
[13:33:44.691]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:44.691]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.691]                 ...future.FUN(...future.X_jj, ...)
[13:33:44.691]             })
[13:33:44.691]         }
[13:33:44.691]     }, args = future.call.arguments)
[13:33:44.691] }
[13:33:44.691] Lazy evaluation: FALSE
[13:33:44.691] Asynchronous evaluation: TRUE
[13:33:44.691] Local evaluation: TRUE
[13:33:44.691] Environment: R_GlobalEnv
[13:33:44.691] Capture standard output: TRUE
[13:33:44.691] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:44.691] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:44.691] Packages: 1 packages (‘stats’)
[13:33:44.691] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:44.691] Resolved: TRUE
[13:33:44.691] Value: <not collected>
[13:33:44.691] Conditions captured: <none>
[13:33:44.691] Early signaling: FALSE
[13:33:44.691] Owner process: b6e93464-7fc2-3f8d-23d1-d8004201d1f1
[13:33:44.691] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:44.701] Chunk #1 of 2 ... DONE
[13:33:44.702] Chunk #2 of 2 ...
[13:33:44.702]  - Finding globals in 'X' for chunk #2 ...
[13:33:44.702] getGlobalsAndPackages() ...
[13:33:44.702] Searching for globals...
[13:33:44.703] 
[13:33:44.703] Searching for globals ... DONE
[13:33:44.703] - globals: [0] <none>
[13:33:44.703] getGlobalsAndPackages() ... DONE
[13:33:44.703]    + additional globals found: [n=0] 
[13:33:44.703]    + additional namespaces needed: [n=0] 
[13:33:44.703]  - Finding globals in 'X' for chunk #2 ... DONE
[13:33:44.703]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:44.704]  - seeds: <none>
[13:33:44.704]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.704] getGlobalsAndPackages() ...
[13:33:44.704] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.704] Resolving globals: FALSE
[13:33:44.704] Tweak future expression to call with '...' arguments ...
[13:33:44.705] {
[13:33:44.705]     do.call(function(...) {
[13:33:44.705]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.705]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:44.705]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.705]             on.exit(options(oopts), add = TRUE)
[13:33:44.705]         }
[13:33:44.705]         {
[13:33:44.705]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:44.705]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.705]                 ...future.FUN(...future.X_jj, ...)
[13:33:44.705]             })
[13:33:44.705]         }
[13:33:44.705]     }, args = future.call.arguments)
[13:33:44.705] }
[13:33:44.705] Tweak future expression to call with '...' arguments ... DONE
[13:33:44.706] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.706] - packages: [1] ‘stats’
[13:33:44.706] getGlobalsAndPackages() ... DONE
[13:33:44.707] run() for ‘Future’ ...
[13:33:44.707] - state: ‘created’
[13:33:44.707] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:44.711] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:44.712] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:44.712]   - Field: ‘label’
[13:33:44.712]   - Field: ‘local’
[13:33:44.712]   - Field: ‘owner’
[13:33:44.712]   - Field: ‘envir’
[13:33:44.712]   - Field: ‘workers’
[13:33:44.713]   - Field: ‘packages’
[13:33:44.713]   - Field: ‘gc’
[13:33:44.713]   - Field: ‘job’
[13:33:44.713]   - Field: ‘conditions’
[13:33:44.713]   - Field: ‘expr’
[13:33:44.713]   - Field: ‘uuid’
[13:33:44.713]   - Field: ‘seed’
[13:33:44.713]   - Field: ‘version’
[13:33:44.714]   - Field: ‘result’
[13:33:44.714]   - Field: ‘asynchronous’
[13:33:44.714]   - Field: ‘calls’
[13:33:44.714]   - Field: ‘globals’
[13:33:44.714]   - Field: ‘stdout’
[13:33:44.714]   - Field: ‘earlySignal’
[13:33:44.715]   - Field: ‘lazy’
[13:33:44.715]   - Field: ‘state’
[13:33:44.715] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:44.715] - Launch lazy future ...
[13:33:44.715] Packages needed by the future expression (n = 1): ‘stats’
[13:33:44.716] Packages needed by future strategies (n = 0): <none>
[13:33:44.716] {
[13:33:44.716]     {
[13:33:44.716]         {
[13:33:44.716]             ...future.startTime <- base::Sys.time()
[13:33:44.716]             {
[13:33:44.716]                 {
[13:33:44.716]                   {
[13:33:44.716]                     {
[13:33:44.716]                       {
[13:33:44.716]                         base::local({
[13:33:44.716]                           has_future <- base::requireNamespace("future", 
[13:33:44.716]                             quietly = TRUE)
[13:33:44.716]                           if (has_future) {
[13:33:44.716]                             ns <- base::getNamespace("future")
[13:33:44.716]                             version <- ns[[".package"]][["version"]]
[13:33:44.716]                             if (is.null(version)) 
[13:33:44.716]                               version <- utils::packageVersion("future")
[13:33:44.716]                           }
[13:33:44.716]                           else {
[13:33:44.716]                             version <- NULL
[13:33:44.716]                           }
[13:33:44.716]                           if (!has_future || version < "1.8.0") {
[13:33:44.716]                             info <- base::c(r_version = base::gsub("R version ", 
[13:33:44.716]                               "", base::R.version$version.string), 
[13:33:44.716]                               platform = base::sprintf("%s (%s-bit)", 
[13:33:44.716]                                 base::R.version$platform, 8 * 
[13:33:44.716]                                   base::.Machine$sizeof.pointer), 
[13:33:44.716]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:44.716]                                 "release", "version")], collapse = " "), 
[13:33:44.716]                               hostname = base::Sys.info()[["nodename"]])
[13:33:44.716]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:33:44.716]                               info)
[13:33:44.716]                             info <- base::paste(info, collapse = "; ")
[13:33:44.716]                             if (!has_future) {
[13:33:44.716]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:44.716]                                 info)
[13:33:44.716]                             }
[13:33:44.716]                             else {
[13:33:44.716]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:44.716]                                 info, version)
[13:33:44.716]                             }
[13:33:44.716]                             base::stop(msg)
[13:33:44.716]                           }
[13:33:44.716]                         })
[13:33:44.716]                       }
[13:33:44.716]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:44.716]                       base::options(mc.cores = 1L)
[13:33:44.716]                     }
[13:33:44.716]                     base::local({
[13:33:44.716]                       for (pkg in "stats") {
[13:33:44.716]                         base::loadNamespace(pkg)
[13:33:44.716]                         base::library(pkg, character.only = TRUE)
[13:33:44.716]                       }
[13:33:44.716]                     })
[13:33:44.716]                   }
[13:33:44.716]                   ...future.strategy.old <- future::plan("list")
[13:33:44.716]                   options(future.plan = NULL)
[13:33:44.716]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:44.716]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:44.716]                 }
[13:33:44.716]                 ...future.workdir <- getwd()
[13:33:44.716]             }
[13:33:44.716]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:44.716]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:44.716]         }
[13:33:44.716]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:44.716]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:44.716]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:44.716]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:44.716]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:44.716]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:44.716]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:44.716]             base::names(...future.oldOptions))
[13:33:44.716]     }
[13:33:44.716]     if (FALSE) {
[13:33:44.716]     }
[13:33:44.716]     else {
[13:33:44.716]         if (TRUE) {
[13:33:44.716]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:44.716]                 open = "w")
[13:33:44.716]         }
[13:33:44.716]         else {
[13:33:44.716]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:44.716]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:44.716]         }
[13:33:44.716]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:44.716]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:44.716]             base::sink(type = "output", split = FALSE)
[13:33:44.716]             base::close(...future.stdout)
[13:33:44.716]         }, add = TRUE)
[13:33:44.716]     }
[13:33:44.716]     ...future.frame <- base::sys.nframe()
[13:33:44.716]     ...future.conditions <- base::list()
[13:33:44.716]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:44.716]     if (FALSE) {
[13:33:44.716]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:44.716]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:44.716]     }
[13:33:44.716]     ...future.result <- base::tryCatch({
[13:33:44.716]         base::withCallingHandlers({
[13:33:44.716]             ...future.value <- base::withVisible(base::local({
[13:33:44.716]                 withCallingHandlers({
[13:33:44.716]                   {
[13:33:44.716]                     do.call(function(...) {
[13:33:44.716]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.716]                       if (!identical(...future.globals.maxSize.org, 
[13:33:44.716]                         ...future.globals.maxSize)) {
[13:33:44.716]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.716]                         on.exit(options(oopts), add = TRUE)
[13:33:44.716]                       }
[13:33:44.716]                       {
[13:33:44.716]                         lapply(seq_along(...future.elements_ii), 
[13:33:44.716]                           FUN = function(jj) {
[13:33:44.716]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.716]                             ...future.FUN(...future.X_jj, ...)
[13:33:44.716]                           })
[13:33:44.716]                       }
[13:33:44.716]                     }, args = future.call.arguments)
[13:33:44.716]                   }
[13:33:44.716]                 }, immediateCondition = function(cond) {
[13:33:44.716]                   save_rds <- function (object, pathname, ...) 
[13:33:44.716]                   {
[13:33:44.716]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:44.716]                     if (file_test("-f", pathname_tmp)) {
[13:33:44.716]                       fi_tmp <- file.info(pathname_tmp)
[13:33:44.716]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:44.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:44.716]                         fi_tmp[["mtime"]])
[13:33:44.716]                     }
[13:33:44.716]                     tryCatch({
[13:33:44.716]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:44.716]                     }, error = function(ex) {
[13:33:44.716]                       msg <- conditionMessage(ex)
[13:33:44.716]                       fi_tmp <- file.info(pathname_tmp)
[13:33:44.716]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:44.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:44.716]                         fi_tmp[["mtime"]], msg)
[13:33:44.716]                       ex$message <- msg
[13:33:44.716]                       stop(ex)
[13:33:44.716]                     })
[13:33:44.716]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:44.716]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:44.716]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:44.716]                       fi_tmp <- file.info(pathname_tmp)
[13:33:44.716]                       fi <- file.info(pathname)
[13:33:44.716]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:44.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:44.716]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:44.716]                         fi[["size"]], fi[["mtime"]])
[13:33:44.716]                       stop(msg)
[13:33:44.716]                     }
[13:33:44.716]                     invisible(pathname)
[13:33:44.716]                   }
[13:33:44.716]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:44.716]                     rootPath = tempdir()) 
[13:33:44.716]                   {
[13:33:44.716]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:44.716]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:44.716]                       tmpdir = path, fileext = ".rds")
[13:33:44.716]                     save_rds(obj, file)
[13:33:44.716]                   }
[13:33:44.716]                   saveImmediateCondition(cond, path = "/tmp/RtmpC9rl05/.future/immediateConditions")
[13:33:44.716]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.716]                   {
[13:33:44.716]                     inherits <- base::inherits
[13:33:44.716]                     invokeRestart <- base::invokeRestart
[13:33:44.716]                     is.null <- base::is.null
[13:33:44.716]                     muffled <- FALSE
[13:33:44.716]                     if (inherits(cond, "message")) {
[13:33:44.716]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:44.716]                       if (muffled) 
[13:33:44.716]                         invokeRestart("muffleMessage")
[13:33:44.716]                     }
[13:33:44.716]                     else if (inherits(cond, "warning")) {
[13:33:44.716]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:44.716]                       if (muffled) 
[13:33:44.716]                         invokeRestart("muffleWarning")
[13:33:44.716]                     }
[13:33:44.716]                     else if (inherits(cond, "condition")) {
[13:33:44.716]                       if (!is.null(pattern)) {
[13:33:44.716]                         computeRestarts <- base::computeRestarts
[13:33:44.716]                         grepl <- base::grepl
[13:33:44.716]                         restarts <- computeRestarts(cond)
[13:33:44.716]                         for (restart in restarts) {
[13:33:44.716]                           name <- restart$name
[13:33:44.716]                           if (is.null(name)) 
[13:33:44.716]                             next
[13:33:44.716]                           if (!grepl(pattern, name)) 
[13:33:44.716]                             next
[13:33:44.716]                           invokeRestart(restart)
[13:33:44.716]                           muffled <- TRUE
[13:33:44.716]                           break
[13:33:44.716]                         }
[13:33:44.716]                       }
[13:33:44.716]                     }
[13:33:44.716]                     invisible(muffled)
[13:33:44.716]                   }
[13:33:44.716]                   muffleCondition(cond)
[13:33:44.716]                 })
[13:33:44.716]             }))
[13:33:44.716]             future::FutureResult(value = ...future.value$value, 
[13:33:44.716]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:44.716]                   ...future.rng), globalenv = if (FALSE) 
[13:33:44.716]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:44.716]                     ...future.globalenv.names))
[13:33:44.716]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:44.716]         }, condition = base::local({
[13:33:44.716]             c <- base::c
[13:33:44.716]             inherits <- base::inherits
[13:33:44.716]             invokeRestart <- base::invokeRestart
[13:33:44.716]             length <- base::length
[13:33:44.716]             list <- base::list
[13:33:44.716]             seq.int <- base::seq.int
[13:33:44.716]             signalCondition <- base::signalCondition
[13:33:44.716]             sys.calls <- base::sys.calls
[13:33:44.716]             `[[` <- base::`[[`
[13:33:44.716]             `+` <- base::`+`
[13:33:44.716]             `<<-` <- base::`<<-`
[13:33:44.716]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:44.716]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:44.716]                   3L)]
[13:33:44.716]             }
[13:33:44.716]             function(cond) {
[13:33:44.716]                 is_error <- inherits(cond, "error")
[13:33:44.716]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:44.716]                   NULL)
[13:33:44.716]                 if (is_error) {
[13:33:44.716]                   sessionInformation <- function() {
[13:33:44.716]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:44.716]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:44.716]                       search = base::search(), system = base::Sys.info())
[13:33:44.716]                   }
[13:33:44.716]                   ...future.conditions[[length(...future.conditions) + 
[13:33:44.716]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:44.716]                     cond$call), session = sessionInformation(), 
[13:33:44.716]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:44.716]                   signalCondition(cond)
[13:33:44.716]                 }
[13:33:44.716]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:44.716]                 "immediateCondition"))) {
[13:33:44.716]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:44.716]                   ...future.conditions[[length(...future.conditions) + 
[13:33:44.716]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:44.716]                   if (TRUE && !signal) {
[13:33:44.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.716]                     {
[13:33:44.716]                       inherits <- base::inherits
[13:33:44.716]                       invokeRestart <- base::invokeRestart
[13:33:44.716]                       is.null <- base::is.null
[13:33:44.716]                       muffled <- FALSE
[13:33:44.716]                       if (inherits(cond, "message")) {
[13:33:44.716]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:44.716]                         if (muffled) 
[13:33:44.716]                           invokeRestart("muffleMessage")
[13:33:44.716]                       }
[13:33:44.716]                       else if (inherits(cond, "warning")) {
[13:33:44.716]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:44.716]                         if (muffled) 
[13:33:44.716]                           invokeRestart("muffleWarning")
[13:33:44.716]                       }
[13:33:44.716]                       else if (inherits(cond, "condition")) {
[13:33:44.716]                         if (!is.null(pattern)) {
[13:33:44.716]                           computeRestarts <- base::computeRestarts
[13:33:44.716]                           grepl <- base::grepl
[13:33:44.716]                           restarts <- computeRestarts(cond)
[13:33:44.716]                           for (restart in restarts) {
[13:33:44.716]                             name <- restart$name
[13:33:44.716]                             if (is.null(name)) 
[13:33:44.716]                               next
[13:33:44.716]                             if (!grepl(pattern, name)) 
[13:33:44.716]                               next
[13:33:44.716]                             invokeRestart(restart)
[13:33:44.716]                             muffled <- TRUE
[13:33:44.716]                             break
[13:33:44.716]                           }
[13:33:44.716]                         }
[13:33:44.716]                       }
[13:33:44.716]                       invisible(muffled)
[13:33:44.716]                     }
[13:33:44.716]                     muffleCondition(cond, pattern = "^muffle")
[13:33:44.716]                   }
[13:33:44.716]                 }
[13:33:44.716]                 else {
[13:33:44.716]                   if (TRUE) {
[13:33:44.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.716]                     {
[13:33:44.716]                       inherits <- base::inherits
[13:33:44.716]                       invokeRestart <- base::invokeRestart
[13:33:44.716]                       is.null <- base::is.null
[13:33:44.716]                       muffled <- FALSE
[13:33:44.716]                       if (inherits(cond, "message")) {
[13:33:44.716]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:44.716]                         if (muffled) 
[13:33:44.716]                           invokeRestart("muffleMessage")
[13:33:44.716]                       }
[13:33:44.716]                       else if (inherits(cond, "warning")) {
[13:33:44.716]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:44.716]                         if (muffled) 
[13:33:44.716]                           invokeRestart("muffleWarning")
[13:33:44.716]                       }
[13:33:44.716]                       else if (inherits(cond, "condition")) {
[13:33:44.716]                         if (!is.null(pattern)) {
[13:33:44.716]                           computeRestarts <- base::computeRestarts
[13:33:44.716]                           grepl <- base::grepl
[13:33:44.716]                           restarts <- computeRestarts(cond)
[13:33:44.716]                           for (restart in restarts) {
[13:33:44.716]                             name <- restart$name
[13:33:44.716]                             if (is.null(name)) 
[13:33:44.716]                               next
[13:33:44.716]                             if (!grepl(pattern, name)) 
[13:33:44.716]                               next
[13:33:44.716]                             invokeRestart(restart)
[13:33:44.716]                             muffled <- TRUE
[13:33:44.716]                             break
[13:33:44.716]                           }
[13:33:44.716]                         }
[13:33:44.716]                       }
[13:33:44.716]                       invisible(muffled)
[13:33:44.716]                     }
[13:33:44.716]                     muffleCondition(cond, pattern = "^muffle")
[13:33:44.716]                   }
[13:33:44.716]                 }
[13:33:44.716]             }
[13:33:44.716]         }))
[13:33:44.716]     }, error = function(ex) {
[13:33:44.716]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:44.716]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:44.716]                 ...future.rng), started = ...future.startTime, 
[13:33:44.716]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:44.716]             version = "1.8"), class = "FutureResult")
[13:33:44.716]     }, finally = {
[13:33:44.716]         if (!identical(...future.workdir, getwd())) 
[13:33:44.716]             setwd(...future.workdir)
[13:33:44.716]         {
[13:33:44.716]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:44.716]                 ...future.oldOptions$nwarnings <- NULL
[13:33:44.716]             }
[13:33:44.716]             base::options(...future.oldOptions)
[13:33:44.716]             if (.Platform$OS.type == "windows") {
[13:33:44.716]                 old_names <- names(...future.oldEnvVars)
[13:33:44.716]                 envs <- base::Sys.getenv()
[13:33:44.716]                 names <- names(envs)
[13:33:44.716]                 common <- intersect(names, old_names)
[13:33:44.716]                 added <- setdiff(names, old_names)
[13:33:44.716]                 removed <- setdiff(old_names, names)
[13:33:44.716]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:44.716]                   envs[common]]
[13:33:44.716]                 NAMES <- toupper(changed)
[13:33:44.716]                 args <- list()
[13:33:44.716]                 for (kk in seq_along(NAMES)) {
[13:33:44.716]                   name <- changed[[kk]]
[13:33:44.716]                   NAME <- NAMES[[kk]]
[13:33:44.716]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.716]                     next
[13:33:44.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:44.716]                 }
[13:33:44.716]                 NAMES <- toupper(added)
[13:33:44.716]                 for (kk in seq_along(NAMES)) {
[13:33:44.716]                   name <- added[[kk]]
[13:33:44.716]                   NAME <- NAMES[[kk]]
[13:33:44.716]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.716]                     next
[13:33:44.716]                   args[[name]] <- ""
[13:33:44.716]                 }
[13:33:44.716]                 NAMES <- toupper(removed)
[13:33:44.716]                 for (kk in seq_along(NAMES)) {
[13:33:44.716]                   name <- removed[[kk]]
[13:33:44.716]                   NAME <- NAMES[[kk]]
[13:33:44.716]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.716]                     next
[13:33:44.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:44.716]                 }
[13:33:44.716]                 if (length(args) > 0) 
[13:33:44.716]                   base::do.call(base::Sys.setenv, args = args)
[13:33:44.716]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:44.716]             }
[13:33:44.716]             else {
[13:33:44.716]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:44.716]             }
[13:33:44.716]             {
[13:33:44.716]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:44.716]                   0L) {
[13:33:44.716]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:44.716]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:44.716]                   base::options(opts)
[13:33:44.716]                 }
[13:33:44.716]                 {
[13:33:44.716]                   {
[13:33:44.716]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:44.716]                     NULL
[13:33:44.716]                   }
[13:33:44.716]                   options(future.plan = NULL)
[13:33:44.716]                   if (is.na(NA_character_)) 
[13:33:44.716]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:44.716]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:44.716]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:44.716]                     .init = FALSE)
[13:33:44.716]                 }
[13:33:44.716]             }
[13:33:44.716]         }
[13:33:44.716]     })
[13:33:44.716]     if (TRUE) {
[13:33:44.716]         base::sink(type = "output", split = FALSE)
[13:33:44.716]         if (TRUE) {
[13:33:44.716]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:44.716]         }
[13:33:44.716]         else {
[13:33:44.716]             ...future.result["stdout"] <- base::list(NULL)
[13:33:44.716]         }
[13:33:44.716]         base::close(...future.stdout)
[13:33:44.716]         ...future.stdout <- NULL
[13:33:44.716]     }
[13:33:44.716]     ...future.result$conditions <- ...future.conditions
[13:33:44.716]     ...future.result$finished <- base::Sys.time()
[13:33:44.716]     ...future.result
[13:33:44.716] }
[13:33:44.720] assign_globals() ...
[13:33:44.720] List of 5
[13:33:44.720]  $ ...future.FUN            :function (x, ...)  
[13:33:44.720]  $ future.call.arguments    :List of 1
[13:33:44.720]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:33:44.720]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.720]  $ ...future.elements_ii    :List of 2
[13:33:44.720]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:33:44.720]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:33:44.720]  $ ...future.seeds_ii       : NULL
[13:33:44.720]  $ ...future.globals.maxSize: NULL
[13:33:44.720]  - attr(*, "where")=List of 5
[13:33:44.720]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:44.720]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:44.720]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:44.720]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:44.720]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:44.720]  - attr(*, "resolved")= logi FALSE
[13:33:44.720]  - attr(*, "total_size")= num 1328
[13:33:44.720]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.720]  - attr(*, "already-done")= logi TRUE
[13:33:44.731] - copied ‘...future.FUN’ to environment
[13:33:44.731] - copied ‘future.call.arguments’ to environment
[13:33:44.732] - copied ‘...future.elements_ii’ to environment
[13:33:44.732] - copied ‘...future.seeds_ii’ to environment
[13:33:44.732] - copied ‘...future.globals.maxSize’ to environment
[13:33:44.732] assign_globals() ... done
[13:33:44.732] requestCore(): workers = 2
[13:33:44.734] MulticoreFuture started
[13:33:44.735] - Launch lazy future ... done
[13:33:44.735] run() for ‘MulticoreFuture’ ... done
[13:33:44.735] Created future:
[13:33:44.736] plan(): Setting new future strategy stack:
[13:33:44.736] List of future strategies:
[13:33:44.736] 1. sequential:
[13:33:44.736]    - args: function (..., envir = parent.frame())
[13:33:44.736]    - tweaked: FALSE
[13:33:44.736]    - call: NULL
[13:33:44.737] plan(): nbrOfWorkers() = 1
[13:33:44.740] plan(): Setting new future strategy stack:
[13:33:44.741] List of future strategies:
[13:33:44.741] 1. multicore:
[13:33:44.741]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:44.741]    - tweaked: FALSE
[13:33:44.741]    - call: plan(strategy)
[13:33:44.745] plan(): nbrOfWorkers() = 2
[13:33:44.736] MulticoreFuture:
[13:33:44.736] Label: ‘future_eapply-2’
[13:33:44.736] Expression:
[13:33:44.736] {
[13:33:44.736]     do.call(function(...) {
[13:33:44.736]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.736]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:44.736]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.736]             on.exit(options(oopts), add = TRUE)
[13:33:44.736]         }
[13:33:44.736]         {
[13:33:44.736]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:44.736]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.736]                 ...future.FUN(...future.X_jj, ...)
[13:33:44.736]             })
[13:33:44.736]         }
[13:33:44.736]     }, args = future.call.arguments)
[13:33:44.736] }
[13:33:44.736] Lazy evaluation: FALSE
[13:33:44.736] Asynchronous evaluation: TRUE
[13:33:44.736] Local evaluation: TRUE
[13:33:44.736] Environment: R_GlobalEnv
[13:33:44.736] Capture standard output: TRUE
[13:33:44.736] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:44.736] Globals: 5 objects totaling 1.50 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:44.736] Packages: 1 packages (‘stats’)
[13:33:44.736] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:44.736] Resolved: TRUE
[13:33:44.736] Value: <not collected>
[13:33:44.736] Conditions captured: <none>
[13:33:44.736] Early signaling: FALSE
[13:33:44.736] Owner process: b6e93464-7fc2-3f8d-23d1-d8004201d1f1
[13:33:44.736] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:44.747] Chunk #2 of 2 ... DONE
[13:33:44.747] Launching 2 futures (chunks) ... DONE
[13:33:44.747] Resolving 2 futures (chunks) ...
[13:33:44.747] resolve() on list ...
[13:33:44.747]  recursive: 0
[13:33:44.748]  length: 2
[13:33:44.748] 
[13:33:44.748] Future #1
[13:33:44.748] result() for MulticoreFuture ...
[13:33:44.749] result() for MulticoreFuture ...
[13:33:44.749] result() for MulticoreFuture ... done
[13:33:44.750] result() for MulticoreFuture ... done
[13:33:44.750] result() for MulticoreFuture ...
[13:33:44.750] result() for MulticoreFuture ... done
[13:33:44.750] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:33:44.750] - nx: 2
[13:33:44.750] - relay: TRUE
[13:33:44.750] - stdout: TRUE
[13:33:44.751] - signal: TRUE
[13:33:44.751] - resignal: FALSE
[13:33:44.751] - force: TRUE
[13:33:44.751] - relayed: [n=2] FALSE, FALSE
[13:33:44.751] - queued futures: [n=2] FALSE, FALSE
[13:33:44.751]  - until=1
[13:33:44.752]  - relaying element #1
[13:33:44.752] result() for MulticoreFuture ...
[13:33:44.752] result() for MulticoreFuture ... done
[13:33:44.752] result() for MulticoreFuture ...
[13:33:44.752] result() for MulticoreFuture ... done
[13:33:44.752] result() for MulticoreFuture ...
[13:33:44.753] result() for MulticoreFuture ... done
[13:33:44.753] result() for MulticoreFuture ...
[13:33:44.753] result() for MulticoreFuture ... done
[13:33:44.753] - relayed: [n=2] TRUE, FALSE
[13:33:44.753] - queued futures: [n=2] TRUE, FALSE
[13:33:44.753] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:33:44.754]  length: 1 (resolved future 1)
[13:33:44.754] Future #2
[13:33:44.754] result() for MulticoreFuture ...
[13:33:44.755] result() for MulticoreFuture ...
[13:33:44.755] result() for MulticoreFuture ... done
[13:33:44.755] result() for MulticoreFuture ... done
[13:33:44.755] result() for MulticoreFuture ...
[13:33:44.755] result() for MulticoreFuture ... done
[13:33:44.756] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:33:44.756] - nx: 2
[13:33:44.756] - relay: TRUE
[13:33:44.756] - stdout: TRUE
[13:33:44.756] - signal: TRUE
[13:33:44.756] - resignal: FALSE
[13:33:44.756] - force: TRUE
[13:33:44.756] - relayed: [n=2] TRUE, FALSE
[13:33:44.756] - queued futures: [n=2] TRUE, FALSE
[13:33:44.757]  - until=2
[13:33:44.757]  - relaying element #2
[13:33:44.757] result() for MulticoreFuture ...
[13:33:44.757] result() for MulticoreFuture ... done
[13:33:44.757] result() for MulticoreFuture ...
[13:33:44.757] result() for MulticoreFuture ... done
[13:33:44.757] result() for MulticoreFuture ...
[13:33:44.757] result() for MulticoreFuture ... done
[13:33:44.758] result() for MulticoreFuture ...
[13:33:44.758] result() for MulticoreFuture ... done
[13:33:44.758] - relayed: [n=2] TRUE, TRUE
[13:33:44.758] - queued futures: [n=2] TRUE, TRUE
[13:33:44.758] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:33:44.758]  length: 0 (resolved future 2)
[13:33:44.758] Relaying remaining futures
[13:33:44.758] signalConditionsASAP(NULL, pos=0) ...
[13:33:44.758] - nx: 2
[13:33:44.759] - relay: TRUE
[13:33:44.759] - stdout: TRUE
[13:33:44.759] - signal: TRUE
[13:33:44.759] - resignal: FALSE
[13:33:44.759] - force: TRUE
[13:33:44.759] - relayed: [n=2] TRUE, TRUE
[13:33:44.759] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:44.759] - relayed: [n=2] TRUE, TRUE
[13:33:44.759] - queued futures: [n=2] TRUE, TRUE
[13:33:44.760] signalConditionsASAP(NULL, pos=0) ... done
[13:33:44.760] resolve() on list ... DONE
[13:33:44.760] result() for MulticoreFuture ...
[13:33:44.760] result() for MulticoreFuture ... done
[13:33:44.760] result() for MulticoreFuture ...
[13:33:44.760] result() for MulticoreFuture ... done
[13:33:44.760] result() for MulticoreFuture ...
[13:33:44.760] result() for MulticoreFuture ... done
[13:33:44.760] result() for MulticoreFuture ...
[13:33:44.761] result() for MulticoreFuture ... done
[13:33:44.761]  - Number of value chunks collected: 2
[13:33:44.761] Resolving 2 futures (chunks) ... DONE
[13:33:44.761] Reducing values from 2 chunks ...
[13:33:44.761]  - Number of values collected after concatenation: 3
[13:33:44.761]  - Number of values expected: 3
[13:33:44.761] Reducing values from 2 chunks ... DONE
[13:33:44.761] future_lapply() ... DONE
[13:33:44.762] future_lapply() ...
[13:33:44.767] Number of chunks: 2
[13:33:44.767] getGlobalsAndPackagesXApply() ...
[13:33:44.767]  - future.globals: TRUE
[13:33:44.767] getGlobalsAndPackages() ...
[13:33:44.767] Searching for globals...
[13:33:44.768] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:44.769] Searching for globals ... DONE
[13:33:44.769] Resolving globals: FALSE
[13:33:44.769] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:33:44.769] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:33:44.770] - globals: [1] ‘FUN’
[13:33:44.770] - packages: [1] ‘stats’
[13:33:44.770] getGlobalsAndPackages() ... DONE
[13:33:44.770]  - globals found/used: [n=1] ‘FUN’
[13:33:44.770]  - needed namespaces: [n=1] ‘stats’
[13:33:44.770] Finding globals ... DONE
[13:33:44.770]  - use_args: TRUE
[13:33:44.771]  - Getting '...' globals ...
[13:33:44.771] resolve() on list ...
[13:33:44.771]  recursive: 0
[13:33:44.771]  length: 1
[13:33:44.771]  elements: ‘...’
[13:33:44.771]  length: 0 (resolved future 1)
[13:33:44.774] resolve() on list ... DONE
[13:33:44.774]    - '...' content: [n=0] 
[13:33:44.774] List of 1
[13:33:44.774]  $ ...: list()
[13:33:44.774]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.774]  - attr(*, "where")=List of 1
[13:33:44.774]   ..$ ...:<environment: 0x5598461b00e8> 
[13:33:44.774]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.774]  - attr(*, "resolved")= logi TRUE
[13:33:44.774]  - attr(*, "total_size")= num NA
[13:33:44.777]  - Getting '...' globals ... DONE
[13:33:44.777] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:44.778] List of 2
[13:33:44.778]  $ ...future.FUN:function (x, ...)  
[13:33:44.778]  $ ...          : list()
[13:33:44.778]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.778]  - attr(*, "where")=List of 2
[13:33:44.778]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:44.778]   ..$ ...          :<environment: 0x5598461b00e8> 
[13:33:44.778]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.778]  - attr(*, "resolved")= logi FALSE
[13:33:44.778]  - attr(*, "total_size")= num 1248
[13:33:44.780] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:44.780] getGlobalsAndPackagesXApply() ... DONE
[13:33:44.781] Number of futures (= number of chunks): 2
[13:33:44.781] Launching 2 futures (chunks) ...
[13:33:44.781] Chunk #1 of 2 ...
[13:33:44.781]  - Finding globals in 'X' for chunk #1 ...
[13:33:44.781] getGlobalsAndPackages() ...
[13:33:44.781] Searching for globals...
[13:33:44.781] 
[13:33:44.781] Searching for globals ... DONE
[13:33:44.782] - globals: [0] <none>
[13:33:44.782] getGlobalsAndPackages() ... DONE
[13:33:44.782]    + additional globals found: [n=0] 
[13:33:44.782]    + additional namespaces needed: [n=0] 
[13:33:44.782]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:44.782]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:44.782]  - seeds: <none>
[13:33:44.782]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.782] getGlobalsAndPackages() ...
[13:33:44.782] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.783] Resolving globals: FALSE
[13:33:44.783] Tweak future expression to call with '...' arguments ...
[13:33:44.783] {
[13:33:44.783]     do.call(function(...) {
[13:33:44.783]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.783]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:44.783]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.783]             on.exit(options(oopts), add = TRUE)
[13:33:44.783]         }
[13:33:44.783]         {
[13:33:44.783]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:44.783]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.783]                 ...future.FUN(...future.X_jj, ...)
[13:33:44.783]             })
[13:33:44.783]         }
[13:33:44.783]     }, args = future.call.arguments)
[13:33:44.783] }
[13:33:44.783] Tweak future expression to call with '...' arguments ... DONE
[13:33:44.783] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.783] - packages: [1] ‘stats’
[13:33:44.784] getGlobalsAndPackages() ... DONE
[13:33:44.784] run() for ‘Future’ ...
[13:33:44.784] - state: ‘created’
[13:33:44.784] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:44.788] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:44.788] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:44.788]   - Field: ‘label’
[13:33:44.788]   - Field: ‘local’
[13:33:44.788]   - Field: ‘owner’
[13:33:44.788]   - Field: ‘envir’
[13:33:44.788]   - Field: ‘workers’
[13:33:44.788]   - Field: ‘packages’
[13:33:44.789]   - Field: ‘gc’
[13:33:44.789]   - Field: ‘job’
[13:33:44.789]   - Field: ‘conditions’
[13:33:44.789]   - Field: ‘expr’
[13:33:44.789]   - Field: ‘uuid’
[13:33:44.789]   - Field: ‘seed’
[13:33:44.789]   - Field: ‘version’
[13:33:44.789]   - Field: ‘result’
[13:33:44.789]   - Field: ‘asynchronous’
[13:33:44.789]   - Field: ‘calls’
[13:33:44.789]   - Field: ‘globals’
[13:33:44.790]   - Field: ‘stdout’
[13:33:44.790]   - Field: ‘earlySignal’
[13:33:44.790]   - Field: ‘lazy’
[13:33:44.790]   - Field: ‘state’
[13:33:44.790] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:44.790] - Launch lazy future ...
[13:33:44.790] Packages needed by the future expression (n = 1): ‘stats’
[13:33:44.790] Packages needed by future strategies (n = 0): <none>
[13:33:44.791] {
[13:33:44.791]     {
[13:33:44.791]         {
[13:33:44.791]             ...future.startTime <- base::Sys.time()
[13:33:44.791]             {
[13:33:44.791]                 {
[13:33:44.791]                   {
[13:33:44.791]                     {
[13:33:44.791]                       {
[13:33:44.791]                         base::local({
[13:33:44.791]                           has_future <- base::requireNamespace("future", 
[13:33:44.791]                             quietly = TRUE)
[13:33:44.791]                           if (has_future) {
[13:33:44.791]                             ns <- base::getNamespace("future")
[13:33:44.791]                             version <- ns[[".package"]][["version"]]
[13:33:44.791]                             if (is.null(version)) 
[13:33:44.791]                               version <- utils::packageVersion("future")
[13:33:44.791]                           }
[13:33:44.791]                           else {
[13:33:44.791]                             version <- NULL
[13:33:44.791]                           }
[13:33:44.791]                           if (!has_future || version < "1.8.0") {
[13:33:44.791]                             info <- base::c(r_version = base::gsub("R version ", 
[13:33:44.791]                               "", base::R.version$version.string), 
[13:33:44.791]                               platform = base::sprintf("%s (%s-bit)", 
[13:33:44.791]                                 base::R.version$platform, 8 * 
[13:33:44.791]                                   base::.Machine$sizeof.pointer), 
[13:33:44.791]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:44.791]                                 "release", "version")], collapse = " "), 
[13:33:44.791]                               hostname = base::Sys.info()[["nodename"]])
[13:33:44.791]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:33:44.791]                               info)
[13:33:44.791]                             info <- base::paste(info, collapse = "; ")
[13:33:44.791]                             if (!has_future) {
[13:33:44.791]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:44.791]                                 info)
[13:33:44.791]                             }
[13:33:44.791]                             else {
[13:33:44.791]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:44.791]                                 info, version)
[13:33:44.791]                             }
[13:33:44.791]                             base::stop(msg)
[13:33:44.791]                           }
[13:33:44.791]                         })
[13:33:44.791]                       }
[13:33:44.791]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:44.791]                       base::options(mc.cores = 1L)
[13:33:44.791]                     }
[13:33:44.791]                     base::local({
[13:33:44.791]                       for (pkg in "stats") {
[13:33:44.791]                         base::loadNamespace(pkg)
[13:33:44.791]                         base::library(pkg, character.only = TRUE)
[13:33:44.791]                       }
[13:33:44.791]                     })
[13:33:44.791]                   }
[13:33:44.791]                   ...future.strategy.old <- future::plan("list")
[13:33:44.791]                   options(future.plan = NULL)
[13:33:44.791]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:44.791]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:44.791]                 }
[13:33:44.791]                 ...future.workdir <- getwd()
[13:33:44.791]             }
[13:33:44.791]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:44.791]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:44.791]         }
[13:33:44.791]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:44.791]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:44.791]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:44.791]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:44.791]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:44.791]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:44.791]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:44.791]             base::names(...future.oldOptions))
[13:33:44.791]     }
[13:33:44.791]     if (FALSE) {
[13:33:44.791]     }
[13:33:44.791]     else {
[13:33:44.791]         if (TRUE) {
[13:33:44.791]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:44.791]                 open = "w")
[13:33:44.791]         }
[13:33:44.791]         else {
[13:33:44.791]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:44.791]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:44.791]         }
[13:33:44.791]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:44.791]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:44.791]             base::sink(type = "output", split = FALSE)
[13:33:44.791]             base::close(...future.stdout)
[13:33:44.791]         }, add = TRUE)
[13:33:44.791]     }
[13:33:44.791]     ...future.frame <- base::sys.nframe()
[13:33:44.791]     ...future.conditions <- base::list()
[13:33:44.791]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:44.791]     if (FALSE) {
[13:33:44.791]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:44.791]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:44.791]     }
[13:33:44.791]     ...future.result <- base::tryCatch({
[13:33:44.791]         base::withCallingHandlers({
[13:33:44.791]             ...future.value <- base::withVisible(base::local({
[13:33:44.791]                 withCallingHandlers({
[13:33:44.791]                   {
[13:33:44.791]                     do.call(function(...) {
[13:33:44.791]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.791]                       if (!identical(...future.globals.maxSize.org, 
[13:33:44.791]                         ...future.globals.maxSize)) {
[13:33:44.791]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.791]                         on.exit(options(oopts), add = TRUE)
[13:33:44.791]                       }
[13:33:44.791]                       {
[13:33:44.791]                         lapply(seq_along(...future.elements_ii), 
[13:33:44.791]                           FUN = function(jj) {
[13:33:44.791]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.791]                             ...future.FUN(...future.X_jj, ...)
[13:33:44.791]                           })
[13:33:44.791]                       }
[13:33:44.791]                     }, args = future.call.arguments)
[13:33:44.791]                   }
[13:33:44.791]                 }, immediateCondition = function(cond) {
[13:33:44.791]                   save_rds <- function (object, pathname, ...) 
[13:33:44.791]                   {
[13:33:44.791]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:44.791]                     if (file_test("-f", pathname_tmp)) {
[13:33:44.791]                       fi_tmp <- file.info(pathname_tmp)
[13:33:44.791]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:44.791]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:44.791]                         fi_tmp[["mtime"]])
[13:33:44.791]                     }
[13:33:44.791]                     tryCatch({
[13:33:44.791]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:44.791]                     }, error = function(ex) {
[13:33:44.791]                       msg <- conditionMessage(ex)
[13:33:44.791]                       fi_tmp <- file.info(pathname_tmp)
[13:33:44.791]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:44.791]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:44.791]                         fi_tmp[["mtime"]], msg)
[13:33:44.791]                       ex$message <- msg
[13:33:44.791]                       stop(ex)
[13:33:44.791]                     })
[13:33:44.791]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:44.791]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:44.791]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:44.791]                       fi_tmp <- file.info(pathname_tmp)
[13:33:44.791]                       fi <- file.info(pathname)
[13:33:44.791]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:44.791]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:44.791]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:44.791]                         fi[["size"]], fi[["mtime"]])
[13:33:44.791]                       stop(msg)
[13:33:44.791]                     }
[13:33:44.791]                     invisible(pathname)
[13:33:44.791]                   }
[13:33:44.791]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:44.791]                     rootPath = tempdir()) 
[13:33:44.791]                   {
[13:33:44.791]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:44.791]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:44.791]                       tmpdir = path, fileext = ".rds")
[13:33:44.791]                     save_rds(obj, file)
[13:33:44.791]                   }
[13:33:44.791]                   saveImmediateCondition(cond, path = "/tmp/RtmpC9rl05/.future/immediateConditions")
[13:33:44.791]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.791]                   {
[13:33:44.791]                     inherits <- base::inherits
[13:33:44.791]                     invokeRestart <- base::invokeRestart
[13:33:44.791]                     is.null <- base::is.null
[13:33:44.791]                     muffled <- FALSE
[13:33:44.791]                     if (inherits(cond, "message")) {
[13:33:44.791]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:44.791]                       if (muffled) 
[13:33:44.791]                         invokeRestart("muffleMessage")
[13:33:44.791]                     }
[13:33:44.791]                     else if (inherits(cond, "warning")) {
[13:33:44.791]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:44.791]                       if (muffled) 
[13:33:44.791]                         invokeRestart("muffleWarning")
[13:33:44.791]                     }
[13:33:44.791]                     else if (inherits(cond, "condition")) {
[13:33:44.791]                       if (!is.null(pattern)) {
[13:33:44.791]                         computeRestarts <- base::computeRestarts
[13:33:44.791]                         grepl <- base::grepl
[13:33:44.791]                         restarts <- computeRestarts(cond)
[13:33:44.791]                         for (restart in restarts) {
[13:33:44.791]                           name <- restart$name
[13:33:44.791]                           if (is.null(name)) 
[13:33:44.791]                             next
[13:33:44.791]                           if (!grepl(pattern, name)) 
[13:33:44.791]                             next
[13:33:44.791]                           invokeRestart(restart)
[13:33:44.791]                           muffled <- TRUE
[13:33:44.791]                           break
[13:33:44.791]                         }
[13:33:44.791]                       }
[13:33:44.791]                     }
[13:33:44.791]                     invisible(muffled)
[13:33:44.791]                   }
[13:33:44.791]                   muffleCondition(cond)
[13:33:44.791]                 })
[13:33:44.791]             }))
[13:33:44.791]             future::FutureResult(value = ...future.value$value, 
[13:33:44.791]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:44.791]                   ...future.rng), globalenv = if (FALSE) 
[13:33:44.791]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:44.791]                     ...future.globalenv.names))
[13:33:44.791]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:44.791]         }, condition = base::local({
[13:33:44.791]             c <- base::c
[13:33:44.791]             inherits <- base::inherits
[13:33:44.791]             invokeRestart <- base::invokeRestart
[13:33:44.791]             length <- base::length
[13:33:44.791]             list <- base::list
[13:33:44.791]             seq.int <- base::seq.int
[13:33:44.791]             signalCondition <- base::signalCondition
[13:33:44.791]             sys.calls <- base::sys.calls
[13:33:44.791]             `[[` <- base::`[[`
[13:33:44.791]             `+` <- base::`+`
[13:33:44.791]             `<<-` <- base::`<<-`
[13:33:44.791]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:44.791]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:44.791]                   3L)]
[13:33:44.791]             }
[13:33:44.791]             function(cond) {
[13:33:44.791]                 is_error <- inherits(cond, "error")
[13:33:44.791]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:44.791]                   NULL)
[13:33:44.791]                 if (is_error) {
[13:33:44.791]                   sessionInformation <- function() {
[13:33:44.791]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:44.791]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:44.791]                       search = base::search(), system = base::Sys.info())
[13:33:44.791]                   }
[13:33:44.791]                   ...future.conditions[[length(...future.conditions) + 
[13:33:44.791]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:44.791]                     cond$call), session = sessionInformation(), 
[13:33:44.791]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:44.791]                   signalCondition(cond)
[13:33:44.791]                 }
[13:33:44.791]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:44.791]                 "immediateCondition"))) {
[13:33:44.791]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:44.791]                   ...future.conditions[[length(...future.conditions) + 
[13:33:44.791]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:44.791]                   if (TRUE && !signal) {
[13:33:44.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.791]                     {
[13:33:44.791]                       inherits <- base::inherits
[13:33:44.791]                       invokeRestart <- base::invokeRestart
[13:33:44.791]                       is.null <- base::is.null
[13:33:44.791]                       muffled <- FALSE
[13:33:44.791]                       if (inherits(cond, "message")) {
[13:33:44.791]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:44.791]                         if (muffled) 
[13:33:44.791]                           invokeRestart("muffleMessage")
[13:33:44.791]                       }
[13:33:44.791]                       else if (inherits(cond, "warning")) {
[13:33:44.791]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:44.791]                         if (muffled) 
[13:33:44.791]                           invokeRestart("muffleWarning")
[13:33:44.791]                       }
[13:33:44.791]                       else if (inherits(cond, "condition")) {
[13:33:44.791]                         if (!is.null(pattern)) {
[13:33:44.791]                           computeRestarts <- base::computeRestarts
[13:33:44.791]                           grepl <- base::grepl
[13:33:44.791]                           restarts <- computeRestarts(cond)
[13:33:44.791]                           for (restart in restarts) {
[13:33:44.791]                             name <- restart$name
[13:33:44.791]                             if (is.null(name)) 
[13:33:44.791]                               next
[13:33:44.791]                             if (!grepl(pattern, name)) 
[13:33:44.791]                               next
[13:33:44.791]                             invokeRestart(restart)
[13:33:44.791]                             muffled <- TRUE
[13:33:44.791]                             break
[13:33:44.791]                           }
[13:33:44.791]                         }
[13:33:44.791]                       }
[13:33:44.791]                       invisible(muffled)
[13:33:44.791]                     }
[13:33:44.791]                     muffleCondition(cond, pattern = "^muffle")
[13:33:44.791]                   }
[13:33:44.791]                 }
[13:33:44.791]                 else {
[13:33:44.791]                   if (TRUE) {
[13:33:44.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.791]                     {
[13:33:44.791]                       inherits <- base::inherits
[13:33:44.791]                       invokeRestart <- base::invokeRestart
[13:33:44.791]                       is.null <- base::is.null
[13:33:44.791]                       muffled <- FALSE
[13:33:44.791]                       if (inherits(cond, "message")) {
[13:33:44.791]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:44.791]                         if (muffled) 
[13:33:44.791]                           invokeRestart("muffleMessage")
[13:33:44.791]                       }
[13:33:44.791]                       else if (inherits(cond, "warning")) {
[13:33:44.791]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:44.791]                         if (muffled) 
[13:33:44.791]                           invokeRestart("muffleWarning")
[13:33:44.791]                       }
[13:33:44.791]                       else if (inherits(cond, "condition")) {
[13:33:44.791]                         if (!is.null(pattern)) {
[13:33:44.791]                           computeRestarts <- base::computeRestarts
[13:33:44.791]                           grepl <- base::grepl
[13:33:44.791]                           restarts <- computeRestarts(cond)
[13:33:44.791]                           for (restart in restarts) {
[13:33:44.791]                             name <- restart$name
[13:33:44.791]                             if (is.null(name)) 
[13:33:44.791]                               next
[13:33:44.791]                             if (!grepl(pattern, name)) 
[13:33:44.791]                               next
[13:33:44.791]                             invokeRestart(restart)
[13:33:44.791]                             muffled <- TRUE
[13:33:44.791]                             break
[13:33:44.791]                           }
[13:33:44.791]                         }
[13:33:44.791]                       }
[13:33:44.791]                       invisible(muffled)
[13:33:44.791]                     }
[13:33:44.791]                     muffleCondition(cond, pattern = "^muffle")
[13:33:44.791]                   }
[13:33:44.791]                 }
[13:33:44.791]             }
[13:33:44.791]         }))
[13:33:44.791]     }, error = function(ex) {
[13:33:44.791]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:44.791]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:44.791]                 ...future.rng), started = ...future.startTime, 
[13:33:44.791]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:44.791]             version = "1.8"), class = "FutureResult")
[13:33:44.791]     }, finally = {
[13:33:44.791]         if (!identical(...future.workdir, getwd())) 
[13:33:44.791]             setwd(...future.workdir)
[13:33:44.791]         {
[13:33:44.791]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:44.791]                 ...future.oldOptions$nwarnings <- NULL
[13:33:44.791]             }
[13:33:44.791]             base::options(...future.oldOptions)
[13:33:44.791]             if (.Platform$OS.type == "windows") {
[13:33:44.791]                 old_names <- names(...future.oldEnvVars)
[13:33:44.791]                 envs <- base::Sys.getenv()
[13:33:44.791]                 names <- names(envs)
[13:33:44.791]                 common <- intersect(names, old_names)
[13:33:44.791]                 added <- setdiff(names, old_names)
[13:33:44.791]                 removed <- setdiff(old_names, names)
[13:33:44.791]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:44.791]                   envs[common]]
[13:33:44.791]                 NAMES <- toupper(changed)
[13:33:44.791]                 args <- list()
[13:33:44.791]                 for (kk in seq_along(NAMES)) {
[13:33:44.791]                   name <- changed[[kk]]
[13:33:44.791]                   NAME <- NAMES[[kk]]
[13:33:44.791]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.791]                     next
[13:33:44.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:44.791]                 }
[13:33:44.791]                 NAMES <- toupper(added)
[13:33:44.791]                 for (kk in seq_along(NAMES)) {
[13:33:44.791]                   name <- added[[kk]]
[13:33:44.791]                   NAME <- NAMES[[kk]]
[13:33:44.791]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.791]                     next
[13:33:44.791]                   args[[name]] <- ""
[13:33:44.791]                 }
[13:33:44.791]                 NAMES <- toupper(removed)
[13:33:44.791]                 for (kk in seq_along(NAMES)) {
[13:33:44.791]                   name <- removed[[kk]]
[13:33:44.791]                   NAME <- NAMES[[kk]]
[13:33:44.791]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.791]                     next
[13:33:44.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:44.791]                 }
[13:33:44.791]                 if (length(args) > 0) 
[13:33:44.791]                   base::do.call(base::Sys.setenv, args = args)
[13:33:44.791]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:44.791]             }
[13:33:44.791]             else {
[13:33:44.791]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:44.791]             }
[13:33:44.791]             {
[13:33:44.791]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:44.791]                   0L) {
[13:33:44.791]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:44.791]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:44.791]                   base::options(opts)
[13:33:44.791]                 }
[13:33:44.791]                 {
[13:33:44.791]                   {
[13:33:44.791]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:44.791]                     NULL
[13:33:44.791]                   }
[13:33:44.791]                   options(future.plan = NULL)
[13:33:44.791]                   if (is.na(NA_character_)) 
[13:33:44.791]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:44.791]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:44.791]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:44.791]                     .init = FALSE)
[13:33:44.791]                 }
[13:33:44.791]             }
[13:33:44.791]         }
[13:33:44.791]     })
[13:33:44.791]     if (TRUE) {
[13:33:44.791]         base::sink(type = "output", split = FALSE)
[13:33:44.791]         if (TRUE) {
[13:33:44.791]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:44.791]         }
[13:33:44.791]         else {
[13:33:44.791]             ...future.result["stdout"] <- base::list(NULL)
[13:33:44.791]         }
[13:33:44.791]         base::close(...future.stdout)
[13:33:44.791]         ...future.stdout <- NULL
[13:33:44.791]     }
[13:33:44.791]     ...future.result$conditions <- ...future.conditions
[13:33:44.791]     ...future.result$finished <- base::Sys.time()
[13:33:44.791]     ...future.result
[13:33:44.791] }
[13:33:44.793] assign_globals() ...
[13:33:44.794] List of 5
[13:33:44.794]  $ ...future.FUN            :function (x, ...)  
[13:33:44.794]  $ future.call.arguments    : list()
[13:33:44.794]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.794]  $ ...future.elements_ii    :List of 1
[13:33:44.794]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[13:33:44.794]  $ ...future.seeds_ii       : NULL
[13:33:44.794]  $ ...future.globals.maxSize: NULL
[13:33:44.794]  - attr(*, "where")=List of 5
[13:33:44.794]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:44.794]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:44.794]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:44.794]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:44.794]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:44.794]  - attr(*, "resolved")= logi FALSE
[13:33:44.794]  - attr(*, "total_size")= num 1248
[13:33:44.794]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.794]  - attr(*, "already-done")= logi TRUE
[13:33:44.800] - copied ‘...future.FUN’ to environment
[13:33:44.800] - copied ‘future.call.arguments’ to environment
[13:33:44.800] - copied ‘...future.elements_ii’ to environment
[13:33:44.800] - copied ‘...future.seeds_ii’ to environment
[13:33:44.800] - copied ‘...future.globals.maxSize’ to environment
[13:33:44.800] assign_globals() ... done
[13:33:44.800] requestCore(): workers = 2
[13:33:44.802] MulticoreFuture started
[13:33:44.803] - Launch lazy future ... done
[13:33:44.803] run() for ‘MulticoreFuture’ ... done
[13:33:44.803] Created future:
[13:33:44.804] plan(): Setting new future strategy stack:
[13:33:44.804] List of future strategies:
[13:33:44.804] 1. sequential:
[13:33:44.804]    - args: function (..., envir = parent.frame())
[13:33:44.804]    - tweaked: FALSE
[13:33:44.804]    - call: NULL
[13:33:44.805] plan(): nbrOfWorkers() = 1
[13:33:44.808] plan(): Setting new future strategy stack:
[13:33:44.808] List of future strategies:
[13:33:44.808] 1. multicore:
[13:33:44.808]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:44.808]    - tweaked: FALSE
[13:33:44.808]    - call: plan(strategy)
[13:33:44.813] plan(): nbrOfWorkers() = 2
[13:33:44.804] MulticoreFuture:
[13:33:44.804] Label: ‘future_eapply-1’
[13:33:44.804] Expression:
[13:33:44.804] {
[13:33:44.804]     do.call(function(...) {
[13:33:44.804]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.804]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:44.804]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.804]             on.exit(options(oopts), add = TRUE)
[13:33:44.804]         }
[13:33:44.804]         {
[13:33:44.804]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:44.804]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.804]                 ...future.FUN(...future.X_jj, ...)
[13:33:44.804]             })
[13:33:44.804]         }
[13:33:44.804]     }, args = future.call.arguments)
[13:33:44.804] }
[13:33:44.804] Lazy evaluation: FALSE
[13:33:44.804] Asynchronous evaluation: TRUE
[13:33:44.804] Local evaluation: TRUE
[13:33:44.804] Environment: R_GlobalEnv
[13:33:44.804] Capture standard output: TRUE
[13:33:44.804] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:44.804] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:44.804] Packages: 1 packages (‘stats’)
[13:33:44.804] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:44.804] Resolved: TRUE
[13:33:44.804] Value: <not collected>
[13:33:44.804] Conditions captured: <none>
[13:33:44.804] Early signaling: FALSE
[13:33:44.804] Owner process: b6e93464-7fc2-3f8d-23d1-d8004201d1f1
[13:33:44.804] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:44.815] Chunk #1 of 2 ... DONE
[13:33:44.815] Chunk #2 of 2 ...
[13:33:44.815]  - Finding globals in 'X' for chunk #2 ...
[13:33:44.815] getGlobalsAndPackages() ...
[13:33:44.815] Searching for globals...
[13:33:44.816] 
[13:33:44.816] Searching for globals ... DONE
[13:33:44.816] - globals: [0] <none>
[13:33:44.816] getGlobalsAndPackages() ... DONE
[13:33:44.816]    + additional globals found: [n=0] 
[13:33:44.817]    + additional namespaces needed: [n=0] 
[13:33:44.817]  - Finding globals in 'X' for chunk #2 ... DONE
[13:33:44.817]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:44.817]  - seeds: <none>
[13:33:44.817]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.817] getGlobalsAndPackages() ...
[13:33:44.817] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.818] Resolving globals: FALSE
[13:33:44.818] Tweak future expression to call with '...' arguments ...
[13:33:44.818] {
[13:33:44.818]     do.call(function(...) {
[13:33:44.818]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.818]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:44.818]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.818]             on.exit(options(oopts), add = TRUE)
[13:33:44.818]         }
[13:33:44.818]         {
[13:33:44.818]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:44.818]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.818]                 ...future.FUN(...future.X_jj, ...)
[13:33:44.818]             })
[13:33:44.818]         }
[13:33:44.818]     }, args = future.call.arguments)
[13:33:44.818] }
[13:33:44.819] Tweak future expression to call with '...' arguments ... DONE
[13:33:44.819] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.819] - packages: [1] ‘stats’
[13:33:44.820] getGlobalsAndPackages() ... DONE
[13:33:44.820] run() for ‘Future’ ...
[13:33:44.820] - state: ‘created’
[13:33:44.821] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:44.825] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:44.825] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:44.826]   - Field: ‘label’
[13:33:44.826]   - Field: ‘local’
[13:33:44.826]   - Field: ‘owner’
[13:33:44.826]   - Field: ‘envir’
[13:33:44.826]   - Field: ‘workers’
[13:33:44.826]   - Field: ‘packages’
[13:33:44.827]   - Field: ‘gc’
[13:33:44.827]   - Field: ‘job’
[13:33:44.827]   - Field: ‘conditions’
[13:33:44.827]   - Field: ‘expr’
[13:33:44.827]   - Field: ‘uuid’
[13:33:44.827]   - Field: ‘seed’
[13:33:44.827]   - Field: ‘version’
[13:33:44.828]   - Field: ‘result’
[13:33:44.828]   - Field: ‘asynchronous’
[13:33:44.828]   - Field: ‘calls’
[13:33:44.828]   - Field: ‘globals’
[13:33:44.828]   - Field: ‘stdout’
[13:33:44.828]   - Field: ‘earlySignal’
[13:33:44.828]   - Field: ‘lazy’
[13:33:44.829]   - Field: ‘state’
[13:33:44.829] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:44.829] - Launch lazy future ...
[13:33:44.829] Packages needed by the future expression (n = 1): ‘stats’
[13:33:44.829] Packages needed by future strategies (n = 0): <none>
[13:33:44.830] {
[13:33:44.830]     {
[13:33:44.830]         {
[13:33:44.830]             ...future.startTime <- base::Sys.time()
[13:33:44.830]             {
[13:33:44.830]                 {
[13:33:44.830]                   {
[13:33:44.830]                     {
[13:33:44.830]                       {
[13:33:44.830]                         base::local({
[13:33:44.830]                           has_future <- base::requireNamespace("future", 
[13:33:44.830]                             quietly = TRUE)
[13:33:44.830]                           if (has_future) {
[13:33:44.830]                             ns <- base::getNamespace("future")
[13:33:44.830]                             version <- ns[[".package"]][["version"]]
[13:33:44.830]                             if (is.null(version)) 
[13:33:44.830]                               version <- utils::packageVersion("future")
[13:33:44.830]                           }
[13:33:44.830]                           else {
[13:33:44.830]                             version <- NULL
[13:33:44.830]                           }
[13:33:44.830]                           if (!has_future || version < "1.8.0") {
[13:33:44.830]                             info <- base::c(r_version = base::gsub("R version ", 
[13:33:44.830]                               "", base::R.version$version.string), 
[13:33:44.830]                               platform = base::sprintf("%s (%s-bit)", 
[13:33:44.830]                                 base::R.version$platform, 8 * 
[13:33:44.830]                                   base::.Machine$sizeof.pointer), 
[13:33:44.830]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:44.830]                                 "release", "version")], collapse = " "), 
[13:33:44.830]                               hostname = base::Sys.info()[["nodename"]])
[13:33:44.830]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:33:44.830]                               info)
[13:33:44.830]                             info <- base::paste(info, collapse = "; ")
[13:33:44.830]                             if (!has_future) {
[13:33:44.830]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:44.830]                                 info)
[13:33:44.830]                             }
[13:33:44.830]                             else {
[13:33:44.830]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:44.830]                                 info, version)
[13:33:44.830]                             }
[13:33:44.830]                             base::stop(msg)
[13:33:44.830]                           }
[13:33:44.830]                         })
[13:33:44.830]                       }
[13:33:44.830]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:44.830]                       base::options(mc.cores = 1L)
[13:33:44.830]                     }
[13:33:44.830]                     base::local({
[13:33:44.830]                       for (pkg in "stats") {
[13:33:44.830]                         base::loadNamespace(pkg)
[13:33:44.830]                         base::library(pkg, character.only = TRUE)
[13:33:44.830]                       }
[13:33:44.830]                     })
[13:33:44.830]                   }
[13:33:44.830]                   ...future.strategy.old <- future::plan("list")
[13:33:44.830]                   options(future.plan = NULL)
[13:33:44.830]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:44.830]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:44.830]                 }
[13:33:44.830]                 ...future.workdir <- getwd()
[13:33:44.830]             }
[13:33:44.830]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:44.830]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:44.830]         }
[13:33:44.830]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:44.830]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:44.830]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:44.830]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:44.830]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:44.830]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:44.830]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:44.830]             base::names(...future.oldOptions))
[13:33:44.830]     }
[13:33:44.830]     if (FALSE) {
[13:33:44.830]     }
[13:33:44.830]     else {
[13:33:44.830]         if (TRUE) {
[13:33:44.830]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:44.830]                 open = "w")
[13:33:44.830]         }
[13:33:44.830]         else {
[13:33:44.830]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:44.830]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:44.830]         }
[13:33:44.830]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:44.830]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:44.830]             base::sink(type = "output", split = FALSE)
[13:33:44.830]             base::close(...future.stdout)
[13:33:44.830]         }, add = TRUE)
[13:33:44.830]     }
[13:33:44.830]     ...future.frame <- base::sys.nframe()
[13:33:44.830]     ...future.conditions <- base::list()
[13:33:44.830]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:44.830]     if (FALSE) {
[13:33:44.830]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:44.830]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:44.830]     }
[13:33:44.830]     ...future.result <- base::tryCatch({
[13:33:44.830]         base::withCallingHandlers({
[13:33:44.830]             ...future.value <- base::withVisible(base::local({
[13:33:44.830]                 withCallingHandlers({
[13:33:44.830]                   {
[13:33:44.830]                     do.call(function(...) {
[13:33:44.830]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.830]                       if (!identical(...future.globals.maxSize.org, 
[13:33:44.830]                         ...future.globals.maxSize)) {
[13:33:44.830]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.830]                         on.exit(options(oopts), add = TRUE)
[13:33:44.830]                       }
[13:33:44.830]                       {
[13:33:44.830]                         lapply(seq_along(...future.elements_ii), 
[13:33:44.830]                           FUN = function(jj) {
[13:33:44.830]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.830]                             ...future.FUN(...future.X_jj, ...)
[13:33:44.830]                           })
[13:33:44.830]                       }
[13:33:44.830]                     }, args = future.call.arguments)
[13:33:44.830]                   }
[13:33:44.830]                 }, immediateCondition = function(cond) {
[13:33:44.830]                   save_rds <- function (object, pathname, ...) 
[13:33:44.830]                   {
[13:33:44.830]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:44.830]                     if (file_test("-f", pathname_tmp)) {
[13:33:44.830]                       fi_tmp <- file.info(pathname_tmp)
[13:33:44.830]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:44.830]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:44.830]                         fi_tmp[["mtime"]])
[13:33:44.830]                     }
[13:33:44.830]                     tryCatch({
[13:33:44.830]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:44.830]                     }, error = function(ex) {
[13:33:44.830]                       msg <- conditionMessage(ex)
[13:33:44.830]                       fi_tmp <- file.info(pathname_tmp)
[13:33:44.830]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:44.830]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:44.830]                         fi_tmp[["mtime"]], msg)
[13:33:44.830]                       ex$message <- msg
[13:33:44.830]                       stop(ex)
[13:33:44.830]                     })
[13:33:44.830]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:44.830]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:44.830]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:44.830]                       fi_tmp <- file.info(pathname_tmp)
[13:33:44.830]                       fi <- file.info(pathname)
[13:33:44.830]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:44.830]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:44.830]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:44.830]                         fi[["size"]], fi[["mtime"]])
[13:33:44.830]                       stop(msg)
[13:33:44.830]                     }
[13:33:44.830]                     invisible(pathname)
[13:33:44.830]                   }
[13:33:44.830]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:44.830]                     rootPath = tempdir()) 
[13:33:44.830]                   {
[13:33:44.830]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:44.830]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:44.830]                       tmpdir = path, fileext = ".rds")
[13:33:44.830]                     save_rds(obj, file)
[13:33:44.830]                   }
[13:33:44.830]                   saveImmediateCondition(cond, path = "/tmp/RtmpC9rl05/.future/immediateConditions")
[13:33:44.830]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.830]                   {
[13:33:44.830]                     inherits <- base::inherits
[13:33:44.830]                     invokeRestart <- base::invokeRestart
[13:33:44.830]                     is.null <- base::is.null
[13:33:44.830]                     muffled <- FALSE
[13:33:44.830]                     if (inherits(cond, "message")) {
[13:33:44.830]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:44.830]                       if (muffled) 
[13:33:44.830]                         invokeRestart("muffleMessage")
[13:33:44.830]                     }
[13:33:44.830]                     else if (inherits(cond, "warning")) {
[13:33:44.830]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:44.830]                       if (muffled) 
[13:33:44.830]                         invokeRestart("muffleWarning")
[13:33:44.830]                     }
[13:33:44.830]                     else if (inherits(cond, "condition")) {
[13:33:44.830]                       if (!is.null(pattern)) {
[13:33:44.830]                         computeRestarts <- base::computeRestarts
[13:33:44.830]                         grepl <- base::grepl
[13:33:44.830]                         restarts <- computeRestarts(cond)
[13:33:44.830]                         for (restart in restarts) {
[13:33:44.830]                           name <- restart$name
[13:33:44.830]                           if (is.null(name)) 
[13:33:44.830]                             next
[13:33:44.830]                           if (!grepl(pattern, name)) 
[13:33:44.830]                             next
[13:33:44.830]                           invokeRestart(restart)
[13:33:44.830]                           muffled <- TRUE
[13:33:44.830]                           break
[13:33:44.830]                         }
[13:33:44.830]                       }
[13:33:44.830]                     }
[13:33:44.830]                     invisible(muffled)
[13:33:44.830]                   }
[13:33:44.830]                   muffleCondition(cond)
[13:33:44.830]                 })
[13:33:44.830]             }))
[13:33:44.830]             future::FutureResult(value = ...future.value$value, 
[13:33:44.830]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:44.830]                   ...future.rng), globalenv = if (FALSE) 
[13:33:44.830]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:44.830]                     ...future.globalenv.names))
[13:33:44.830]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:44.830]         }, condition = base::local({
[13:33:44.830]             c <- base::c
[13:33:44.830]             inherits <- base::inherits
[13:33:44.830]             invokeRestart <- base::invokeRestart
[13:33:44.830]             length <- base::length
[13:33:44.830]             list <- base::list
[13:33:44.830]             seq.int <- base::seq.int
[13:33:44.830]             signalCondition <- base::signalCondition
[13:33:44.830]             sys.calls <- base::sys.calls
[13:33:44.830]             `[[` <- base::`[[`
[13:33:44.830]             `+` <- base::`+`
[13:33:44.830]             `<<-` <- base::`<<-`
[13:33:44.830]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:44.830]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:44.830]                   3L)]
[13:33:44.830]             }
[13:33:44.830]             function(cond) {
[13:33:44.830]                 is_error <- inherits(cond, "error")
[13:33:44.830]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:44.830]                   NULL)
[13:33:44.830]                 if (is_error) {
[13:33:44.830]                   sessionInformation <- function() {
[13:33:44.830]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:44.830]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:44.830]                       search = base::search(), system = base::Sys.info())
[13:33:44.830]                   }
[13:33:44.830]                   ...future.conditions[[length(...future.conditions) + 
[13:33:44.830]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:44.830]                     cond$call), session = sessionInformation(), 
[13:33:44.830]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:44.830]                   signalCondition(cond)
[13:33:44.830]                 }
[13:33:44.830]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:44.830]                 "immediateCondition"))) {
[13:33:44.830]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:44.830]                   ...future.conditions[[length(...future.conditions) + 
[13:33:44.830]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:44.830]                   if (TRUE && !signal) {
[13:33:44.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.830]                     {
[13:33:44.830]                       inherits <- base::inherits
[13:33:44.830]                       invokeRestart <- base::invokeRestart
[13:33:44.830]                       is.null <- base::is.null
[13:33:44.830]                       muffled <- FALSE
[13:33:44.830]                       if (inherits(cond, "message")) {
[13:33:44.830]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:44.830]                         if (muffled) 
[13:33:44.830]                           invokeRestart("muffleMessage")
[13:33:44.830]                       }
[13:33:44.830]                       else if (inherits(cond, "warning")) {
[13:33:44.830]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:44.830]                         if (muffled) 
[13:33:44.830]                           invokeRestart("muffleWarning")
[13:33:44.830]                       }
[13:33:44.830]                       else if (inherits(cond, "condition")) {
[13:33:44.830]                         if (!is.null(pattern)) {
[13:33:44.830]                           computeRestarts <- base::computeRestarts
[13:33:44.830]                           grepl <- base::grepl
[13:33:44.830]                           restarts <- computeRestarts(cond)
[13:33:44.830]                           for (restart in restarts) {
[13:33:44.830]                             name <- restart$name
[13:33:44.830]                             if (is.null(name)) 
[13:33:44.830]                               next
[13:33:44.830]                             if (!grepl(pattern, name)) 
[13:33:44.830]                               next
[13:33:44.830]                             invokeRestart(restart)
[13:33:44.830]                             muffled <- TRUE
[13:33:44.830]                             break
[13:33:44.830]                           }
[13:33:44.830]                         }
[13:33:44.830]                       }
[13:33:44.830]                       invisible(muffled)
[13:33:44.830]                     }
[13:33:44.830]                     muffleCondition(cond, pattern = "^muffle")
[13:33:44.830]                   }
[13:33:44.830]                 }
[13:33:44.830]                 else {
[13:33:44.830]                   if (TRUE) {
[13:33:44.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.830]                     {
[13:33:44.830]                       inherits <- base::inherits
[13:33:44.830]                       invokeRestart <- base::invokeRestart
[13:33:44.830]                       is.null <- base::is.null
[13:33:44.830]                       muffled <- FALSE
[13:33:44.830]                       if (inherits(cond, "message")) {
[13:33:44.830]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:44.830]                         if (muffled) 
[13:33:44.830]                           invokeRestart("muffleMessage")
[13:33:44.830]                       }
[13:33:44.830]                       else if (inherits(cond, "warning")) {
[13:33:44.830]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:44.830]                         if (muffled) 
[13:33:44.830]                           invokeRestart("muffleWarning")
[13:33:44.830]                       }
[13:33:44.830]                       else if (inherits(cond, "condition")) {
[13:33:44.830]                         if (!is.null(pattern)) {
[13:33:44.830]                           computeRestarts <- base::computeRestarts
[13:33:44.830]                           grepl <- base::grepl
[13:33:44.830]                           restarts <- computeRestarts(cond)
[13:33:44.830]                           for (restart in restarts) {
[13:33:44.830]                             name <- restart$name
[13:33:44.830]                             if (is.null(name)) 
[13:33:44.830]                               next
[13:33:44.830]                             if (!grepl(pattern, name)) 
[13:33:44.830]                               next
[13:33:44.830]                             invokeRestart(restart)
[13:33:44.830]                             muffled <- TRUE
[13:33:44.830]                             break
[13:33:44.830]                           }
[13:33:44.830]                         }
[13:33:44.830]                       }
[13:33:44.830]                       invisible(muffled)
[13:33:44.830]                     }
[13:33:44.830]                     muffleCondition(cond, pattern = "^muffle")
[13:33:44.830]                   }
[13:33:44.830]                 }
[13:33:44.830]             }
[13:33:44.830]         }))
[13:33:44.830]     }, error = function(ex) {
[13:33:44.830]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:44.830]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:44.830]                 ...future.rng), started = ...future.startTime, 
[13:33:44.830]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:44.830]             version = "1.8"), class = "FutureResult")
[13:33:44.830]     }, finally = {
[13:33:44.830]         if (!identical(...future.workdir, getwd())) 
[13:33:44.830]             setwd(...future.workdir)
[13:33:44.830]         {
[13:33:44.830]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:44.830]                 ...future.oldOptions$nwarnings <- NULL
[13:33:44.830]             }
[13:33:44.830]             base::options(...future.oldOptions)
[13:33:44.830]             if (.Platform$OS.type == "windows") {
[13:33:44.830]                 old_names <- names(...future.oldEnvVars)
[13:33:44.830]                 envs <- base::Sys.getenv()
[13:33:44.830]                 names <- names(envs)
[13:33:44.830]                 common <- intersect(names, old_names)
[13:33:44.830]                 added <- setdiff(names, old_names)
[13:33:44.830]                 removed <- setdiff(old_names, names)
[13:33:44.830]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:44.830]                   envs[common]]
[13:33:44.830]                 NAMES <- toupper(changed)
[13:33:44.830]                 args <- list()
[13:33:44.830]                 for (kk in seq_along(NAMES)) {
[13:33:44.830]                   name <- changed[[kk]]
[13:33:44.830]                   NAME <- NAMES[[kk]]
[13:33:44.830]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.830]                     next
[13:33:44.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:44.830]                 }
[13:33:44.830]                 NAMES <- toupper(added)
[13:33:44.830]                 for (kk in seq_along(NAMES)) {
[13:33:44.830]                   name <- added[[kk]]
[13:33:44.830]                   NAME <- NAMES[[kk]]
[13:33:44.830]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.830]                     next
[13:33:44.830]                   args[[name]] <- ""
[13:33:44.830]                 }
[13:33:44.830]                 NAMES <- toupper(removed)
[13:33:44.830]                 for (kk in seq_along(NAMES)) {
[13:33:44.830]                   name <- removed[[kk]]
[13:33:44.830]                   NAME <- NAMES[[kk]]
[13:33:44.830]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.830]                     next
[13:33:44.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:44.830]                 }
[13:33:44.830]                 if (length(args) > 0) 
[13:33:44.830]                   base::do.call(base::Sys.setenv, args = args)
[13:33:44.830]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:44.830]             }
[13:33:44.830]             else {
[13:33:44.830]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:44.830]             }
[13:33:44.830]             {
[13:33:44.830]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:44.830]                   0L) {
[13:33:44.830]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:44.830]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:44.830]                   base::options(opts)
[13:33:44.830]                 }
[13:33:44.830]                 {
[13:33:44.830]                   {
[13:33:44.830]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:44.830]                     NULL
[13:33:44.830]                   }
[13:33:44.830]                   options(future.plan = NULL)
[13:33:44.830]                   if (is.na(NA_character_)) 
[13:33:44.830]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:44.830]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:44.830]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:44.830]                     .init = FALSE)
[13:33:44.830]                 }
[13:33:44.830]             }
[13:33:44.830]         }
[13:33:44.830]     })
[13:33:44.830]     if (TRUE) {
[13:33:44.830]         base::sink(type = "output", split = FALSE)
[13:33:44.830]         if (TRUE) {
[13:33:44.830]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:44.830]         }
[13:33:44.830]         else {
[13:33:44.830]             ...future.result["stdout"] <- base::list(NULL)
[13:33:44.830]         }
[13:33:44.830]         base::close(...future.stdout)
[13:33:44.830]         ...future.stdout <- NULL
[13:33:44.830]     }
[13:33:44.830]     ...future.result$conditions <- ...future.conditions
[13:33:44.830]     ...future.result$finished <- base::Sys.time()
[13:33:44.830]     ...future.result
[13:33:44.830] }
[13:33:44.834] assign_globals() ...
[13:33:44.834] List of 5
[13:33:44.834]  $ ...future.FUN            :function (x, ...)  
[13:33:44.834]  $ future.call.arguments    : list()
[13:33:44.834]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.834]  $ ...future.elements_ii    :List of 2
[13:33:44.834]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:33:44.834]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:33:44.834]  $ ...future.seeds_ii       : NULL
[13:33:44.834]  $ ...future.globals.maxSize: NULL
[13:33:44.834]  - attr(*, "where")=List of 5
[13:33:44.834]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:44.834]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:44.834]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:44.834]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:44.834]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:44.834]  - attr(*, "resolved")= logi FALSE
[13:33:44.834]  - attr(*, "total_size")= num 1248
[13:33:44.834]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.834]  - attr(*, "already-done")= logi TRUE
[13:33:44.841] - copied ‘...future.FUN’ to environment
[13:33:44.842] - copied ‘future.call.arguments’ to environment
[13:33:44.842] - copied ‘...future.elements_ii’ to environment
[13:33:44.842] - copied ‘...future.seeds_ii’ to environment
[13:33:44.842] - copied ‘...future.globals.maxSize’ to environment
[13:33:44.842] assign_globals() ... done
[13:33:44.842] requestCore(): workers = 2
[13:33:44.844] MulticoreFuture started
[13:33:44.845] - Launch lazy future ... done
[13:33:44.845] run() for ‘MulticoreFuture’ ... done
[13:33:44.845] Created future:
[13:33:44.846] plan(): Setting new future strategy stack:
[13:33:44.846] List of future strategies:
[13:33:44.846] 1. sequential:
[13:33:44.846]    - args: function (..., envir = parent.frame())
[13:33:44.846]    - tweaked: FALSE
[13:33:44.846]    - call: NULL
[13:33:44.847] plan(): nbrOfWorkers() = 1
[13:33:44.849] plan(): Setting new future strategy stack:
[13:33:44.850] List of future strategies:
[13:33:44.850] 1. multicore:
[13:33:44.850]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:44.850]    - tweaked: FALSE
[13:33:44.850]    - call: plan(strategy)
[13:33:44.845] MulticoreFuture:
[13:33:44.845] Label: ‘future_eapply-2’
[13:33:44.845] Expression:
[13:33:44.845] {
[13:33:44.845]     do.call(function(...) {
[13:33:44.845]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.845]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:44.845]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.845]             on.exit(options(oopts), add = TRUE)
[13:33:44.845]         }
[13:33:44.845]         {
[13:33:44.845]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:44.845]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.845]                 ...future.FUN(...future.X_jj, ...)
[13:33:44.845]             })
[13:33:44.845]         }
[13:33:44.845]     }, args = future.call.arguments)
[13:33:44.845] }
[13:33:44.845] Lazy evaluation: FALSE
[13:33:44.845] Asynchronous evaluation: TRUE
[13:33:44.845] Local evaluation: TRUE
[13:33:44.845] Environment: R_GlobalEnv
[13:33:44.845] Capture standard output: TRUE
[13:33:44.845] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:44.845] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:44.845] Packages: 1 packages (‘stats’)
[13:33:44.845] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:44.845] Resolved: FALSE
[13:33:44.845] Value: <not collected>
[13:33:44.845] Conditions captured: <none>
[13:33:44.845] Early signaling: FALSE
[13:33:44.845] Owner process: b6e93464-7fc2-3f8d-23d1-d8004201d1f1
[13:33:44.845] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:44.858] Chunk #2 of 2 ... DONE
[13:33:44.858] plan(): nbrOfWorkers() = 2
[13:33:44.858] Launching 2 futures (chunks) ... DONE
[13:33:44.858] Resolving 2 futures (chunks) ...
[13:33:44.859] resolve() on list ...
[13:33:44.859]  recursive: 0
[13:33:44.859]  length: 2
[13:33:44.859] 
[13:33:44.859] Future #1
[13:33:44.860] result() for MulticoreFuture ...
[13:33:44.860] result() for MulticoreFuture ...
[13:33:44.861] result() for MulticoreFuture ... done
[13:33:44.861] result() for MulticoreFuture ... done
[13:33:44.861] result() for MulticoreFuture ...
[13:33:44.861] result() for MulticoreFuture ... done
[13:33:44.864] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:33:44.864] - nx: 2
[13:33:44.864] - relay: TRUE
[13:33:44.864] - stdout: TRUE
[13:33:44.864] - signal: TRUE
[13:33:44.865] - resignal: FALSE
[13:33:44.865] - force: TRUE
[13:33:44.865] - relayed: [n=2] FALSE, FALSE
[13:33:44.865] - queued futures: [n=2] FALSE, FALSE
[13:33:44.865]  - until=1
[13:33:44.866]  - relaying element #1
[13:33:44.866] result() for MulticoreFuture ...
[13:33:44.866] result() for MulticoreFuture ... done
[13:33:44.866] result() for MulticoreFuture ...
[13:33:44.867] result() for MulticoreFuture ... done
[13:33:44.867] result() for MulticoreFuture ...
[13:33:44.867] result() for MulticoreFuture ... done
[13:33:44.867] result() for MulticoreFuture ...
[13:33:44.867] result() for MulticoreFuture ... done
[13:33:44.868] - relayed: [n=2] TRUE, FALSE
[13:33:44.868] - queued futures: [n=2] TRUE, FALSE
[13:33:44.868] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:33:44.868]  length: 1 (resolved future 1)
[13:33:44.869] Future #2
[13:33:44.869] result() for MulticoreFuture ...
[13:33:44.870] result() for MulticoreFuture ...
[13:33:44.870] result() for MulticoreFuture ... done
[13:33:44.870] result() for MulticoreFuture ... done
[13:33:44.870] result() for MulticoreFuture ...
[13:33:44.870] result() for MulticoreFuture ... done
[13:33:44.870] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:33:44.871] - nx: 2
[13:33:44.871] - relay: TRUE
[13:33:44.871] - stdout: TRUE
[13:33:44.871] - signal: TRUE
[13:33:44.871] - resignal: FALSE
[13:33:44.871] - force: TRUE
[13:33:44.871] - relayed: [n=2] TRUE, FALSE
[13:33:44.871] - queued futures: [n=2] TRUE, FALSE
[13:33:44.872]  - until=2
[13:33:44.872]  - relaying element #2
[13:33:44.872] result() for MulticoreFuture ...
[13:33:44.872] result() for MulticoreFuture ... done
[13:33:44.872] result() for MulticoreFuture ...
[13:33:44.872] result() for MulticoreFuture ... done
[13:33:44.872] result() for MulticoreFuture ...
[13:33:44.872] result() for MulticoreFuture ... done
[13:33:44.873] result() for MulticoreFuture ...
[13:33:44.873] result() for MulticoreFuture ... done
[13:33:44.873] - relayed: [n=2] TRUE, TRUE
[13:33:44.873] - queued futures: [n=2] TRUE, TRUE
[13:33:44.873] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:33:44.873]  length: 0 (resolved future 2)
[13:33:44.873] Relaying remaining futures
[13:33:44.873] signalConditionsASAP(NULL, pos=0) ...
[13:33:44.873] - nx: 2
[13:33:44.874] - relay: TRUE
[13:33:44.874] - stdout: TRUE
[13:33:44.874] - signal: TRUE
[13:33:44.874] - resignal: FALSE
[13:33:44.874] - force: TRUE
[13:33:44.874] - relayed: [n=2] TRUE, TRUE
[13:33:44.874] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:44.874] - relayed: [n=2] TRUE, TRUE
[13:33:44.875] - queued futures: [n=2] TRUE, TRUE
[13:33:44.875] signalConditionsASAP(NULL, pos=0) ... done
[13:33:44.875] resolve() on list ... DONE
[13:33:44.875] result() for MulticoreFuture ...
[13:33:44.875] result() for MulticoreFuture ... done
[13:33:44.875] result() for MulticoreFuture ...
[13:33:44.875] result() for MulticoreFuture ... done
[13:33:44.875] result() for MulticoreFuture ...
[13:33:44.876] result() for MulticoreFuture ... done
[13:33:44.876] result() for MulticoreFuture ...
[13:33:44.876] result() for MulticoreFuture ... done
[13:33:44.876]  - Number of value chunks collected: 2
[13:33:44.876] Resolving 2 futures (chunks) ... DONE
[13:33:44.876] Reducing values from 2 chunks ...
[13:33:44.876]  - Number of values collected after concatenation: 3
[13:33:44.876]  - Number of values expected: 3
[13:33:44.877] Reducing values from 2 chunks ... DONE
[13:33:44.877] future_lapply() ... DONE
[13:33:44.877] future_lapply() ...
[13:33:44.881] Number of chunks: 2
[13:33:44.882] getGlobalsAndPackagesXApply() ...
[13:33:44.882]  - future.globals: TRUE
[13:33:44.882] getGlobalsAndPackages() ...
[13:33:44.882] Searching for globals...
[13:33:44.883] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:44.883] Searching for globals ... DONE
[13:33:44.884] Resolving globals: FALSE
[13:33:44.884] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:33:44.884] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:33:44.884] - globals: [1] ‘FUN’
[13:33:44.885] - packages: [1] ‘stats’
[13:33:44.885] getGlobalsAndPackages() ... DONE
[13:33:44.885]  - globals found/used: [n=1] ‘FUN’
[13:33:44.885]  - needed namespaces: [n=1] ‘stats’
[13:33:44.885] Finding globals ... DONE
[13:33:44.885]  - use_args: TRUE
[13:33:44.885]  - Getting '...' globals ...
[13:33:44.886] resolve() on list ...
[13:33:44.886]  recursive: 0
[13:33:44.886]  length: 1
[13:33:44.886]  elements: ‘...’
[13:33:44.886]  length: 0 (resolved future 1)
[13:33:44.886] resolve() on list ... DONE
[13:33:44.886]    - '...' content: [n=0] 
[13:33:44.886] List of 1
[13:33:44.886]  $ ...: list()
[13:33:44.886]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.886]  - attr(*, "where")=List of 1
[13:33:44.886]   ..$ ...:<environment: 0x5598458ae4f0> 
[13:33:44.886]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.886]  - attr(*, "resolved")= logi TRUE
[13:33:44.886]  - attr(*, "total_size")= num NA
[13:33:44.889]  - Getting '...' globals ... DONE
[13:33:44.890] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:44.890] List of 2
[13:33:44.890]  $ ...future.FUN:function (x, ...)  
[13:33:44.890]  $ ...          : list()
[13:33:44.890]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.890]  - attr(*, "where")=List of 2
[13:33:44.890]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:44.890]   ..$ ...          :<environment: 0x5598458ae4f0> 
[13:33:44.890]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.890]  - attr(*, "resolved")= logi FALSE
[13:33:44.890]  - attr(*, "total_size")= num 1248
[13:33:44.894] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:44.894] getGlobalsAndPackagesXApply() ... DONE
[13:33:44.894] Number of futures (= number of chunks): 2
[13:33:44.894] Launching 2 futures (chunks) ...
[13:33:44.895] Chunk #1 of 2 ...
[13:33:44.895]  - Finding globals in 'X' for chunk #1 ...
[13:33:44.895] getGlobalsAndPackages() ...
[13:33:44.895] Searching for globals...
[13:33:44.895] 
[13:33:44.895] Searching for globals ... DONE
[13:33:44.895] - globals: [0] <none>
[13:33:44.895] getGlobalsAndPackages() ... DONE
[13:33:44.895]    + additional globals found: [n=0] 
[13:33:44.896]    + additional namespaces needed: [n=0] 
[13:33:44.896]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:44.896]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:44.896]  - seeds: <none>
[13:33:44.896]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.896] getGlobalsAndPackages() ...
[13:33:44.896] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.896] Resolving globals: FALSE
[13:33:44.896] Tweak future expression to call with '...' arguments ...
[13:33:44.896] {
[13:33:44.896]     do.call(function(...) {
[13:33:44.896]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.896]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:44.896]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.896]             on.exit(options(oopts), add = TRUE)
[13:33:44.896]         }
[13:33:44.896]         {
[13:33:44.896]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:44.896]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.896]                 ...future.FUN(...future.X_jj, ...)
[13:33:44.896]             })
[13:33:44.896]         }
[13:33:44.896]     }, args = future.call.arguments)
[13:33:44.896] }
[13:33:44.897] Tweak future expression to call with '...' arguments ... DONE
[13:33:44.897] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.897] - packages: [1] ‘stats’
[13:33:44.897] getGlobalsAndPackages() ... DONE
[13:33:44.898] run() for ‘Future’ ...
[13:33:44.898] - state: ‘created’
[13:33:44.898] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:44.901] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:44.902] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:44.902]   - Field: ‘label’
[13:33:44.902]   - Field: ‘local’
[13:33:44.902]   - Field: ‘owner’
[13:33:44.902]   - Field: ‘envir’
[13:33:44.902]   - Field: ‘workers’
[13:33:44.902]   - Field: ‘packages’
[13:33:44.902]   - Field: ‘gc’
[13:33:44.902]   - Field: ‘job’
[13:33:44.903]   - Field: ‘conditions’
[13:33:44.903]   - Field: ‘expr’
[13:33:44.903]   - Field: ‘uuid’
[13:33:44.903]   - Field: ‘seed’
[13:33:44.903]   - Field: ‘version’
[13:33:44.903]   - Field: ‘result’
[13:33:44.903]   - Field: ‘asynchronous’
[13:33:44.903]   - Field: ‘calls’
[13:33:44.903]   - Field: ‘globals’
[13:33:44.903]   - Field: ‘stdout’
[13:33:44.903]   - Field: ‘earlySignal’
[13:33:44.904]   - Field: ‘lazy’
[13:33:44.904]   - Field: ‘state’
[13:33:44.904] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:44.904] - Launch lazy future ...
[13:33:44.904] Packages needed by the future expression (n = 1): ‘stats’
[13:33:44.904] Packages needed by future strategies (n = 0): <none>
[13:33:44.905] {
[13:33:44.905]     {
[13:33:44.905]         {
[13:33:44.905]             ...future.startTime <- base::Sys.time()
[13:33:44.905]             {
[13:33:44.905]                 {
[13:33:44.905]                   {
[13:33:44.905]                     {
[13:33:44.905]                       {
[13:33:44.905]                         base::local({
[13:33:44.905]                           has_future <- base::requireNamespace("future", 
[13:33:44.905]                             quietly = TRUE)
[13:33:44.905]                           if (has_future) {
[13:33:44.905]                             ns <- base::getNamespace("future")
[13:33:44.905]                             version <- ns[[".package"]][["version"]]
[13:33:44.905]                             if (is.null(version)) 
[13:33:44.905]                               version <- utils::packageVersion("future")
[13:33:44.905]                           }
[13:33:44.905]                           else {
[13:33:44.905]                             version <- NULL
[13:33:44.905]                           }
[13:33:44.905]                           if (!has_future || version < "1.8.0") {
[13:33:44.905]                             info <- base::c(r_version = base::gsub("R version ", 
[13:33:44.905]                               "", base::R.version$version.string), 
[13:33:44.905]                               platform = base::sprintf("%s (%s-bit)", 
[13:33:44.905]                                 base::R.version$platform, 8 * 
[13:33:44.905]                                   base::.Machine$sizeof.pointer), 
[13:33:44.905]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:44.905]                                 "release", "version")], collapse = " "), 
[13:33:44.905]                               hostname = base::Sys.info()[["nodename"]])
[13:33:44.905]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:33:44.905]                               info)
[13:33:44.905]                             info <- base::paste(info, collapse = "; ")
[13:33:44.905]                             if (!has_future) {
[13:33:44.905]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:44.905]                                 info)
[13:33:44.905]                             }
[13:33:44.905]                             else {
[13:33:44.905]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:44.905]                                 info, version)
[13:33:44.905]                             }
[13:33:44.905]                             base::stop(msg)
[13:33:44.905]                           }
[13:33:44.905]                         })
[13:33:44.905]                       }
[13:33:44.905]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:44.905]                       base::options(mc.cores = 1L)
[13:33:44.905]                     }
[13:33:44.905]                     base::local({
[13:33:44.905]                       for (pkg in "stats") {
[13:33:44.905]                         base::loadNamespace(pkg)
[13:33:44.905]                         base::library(pkg, character.only = TRUE)
[13:33:44.905]                       }
[13:33:44.905]                     })
[13:33:44.905]                   }
[13:33:44.905]                   ...future.strategy.old <- future::plan("list")
[13:33:44.905]                   options(future.plan = NULL)
[13:33:44.905]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:44.905]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:44.905]                 }
[13:33:44.905]                 ...future.workdir <- getwd()
[13:33:44.905]             }
[13:33:44.905]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:44.905]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:44.905]         }
[13:33:44.905]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:44.905]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:44.905]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:44.905]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:44.905]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:44.905]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:44.905]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:44.905]             base::names(...future.oldOptions))
[13:33:44.905]     }
[13:33:44.905]     if (FALSE) {
[13:33:44.905]     }
[13:33:44.905]     else {
[13:33:44.905]         if (TRUE) {
[13:33:44.905]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:44.905]                 open = "w")
[13:33:44.905]         }
[13:33:44.905]         else {
[13:33:44.905]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:44.905]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:44.905]         }
[13:33:44.905]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:44.905]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:44.905]             base::sink(type = "output", split = FALSE)
[13:33:44.905]             base::close(...future.stdout)
[13:33:44.905]         }, add = TRUE)
[13:33:44.905]     }
[13:33:44.905]     ...future.frame <- base::sys.nframe()
[13:33:44.905]     ...future.conditions <- base::list()
[13:33:44.905]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:44.905]     if (FALSE) {
[13:33:44.905]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:44.905]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:44.905]     }
[13:33:44.905]     ...future.result <- base::tryCatch({
[13:33:44.905]         base::withCallingHandlers({
[13:33:44.905]             ...future.value <- base::withVisible(base::local({
[13:33:44.905]                 withCallingHandlers({
[13:33:44.905]                   {
[13:33:44.905]                     do.call(function(...) {
[13:33:44.905]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.905]                       if (!identical(...future.globals.maxSize.org, 
[13:33:44.905]                         ...future.globals.maxSize)) {
[13:33:44.905]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.905]                         on.exit(options(oopts), add = TRUE)
[13:33:44.905]                       }
[13:33:44.905]                       {
[13:33:44.905]                         lapply(seq_along(...future.elements_ii), 
[13:33:44.905]                           FUN = function(jj) {
[13:33:44.905]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.905]                             ...future.FUN(...future.X_jj, ...)
[13:33:44.905]                           })
[13:33:44.905]                       }
[13:33:44.905]                     }, args = future.call.arguments)
[13:33:44.905]                   }
[13:33:44.905]                 }, immediateCondition = function(cond) {
[13:33:44.905]                   save_rds <- function (object, pathname, ...) 
[13:33:44.905]                   {
[13:33:44.905]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:44.905]                     if (file_test("-f", pathname_tmp)) {
[13:33:44.905]                       fi_tmp <- file.info(pathname_tmp)
[13:33:44.905]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:44.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:44.905]                         fi_tmp[["mtime"]])
[13:33:44.905]                     }
[13:33:44.905]                     tryCatch({
[13:33:44.905]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:44.905]                     }, error = function(ex) {
[13:33:44.905]                       msg <- conditionMessage(ex)
[13:33:44.905]                       fi_tmp <- file.info(pathname_tmp)
[13:33:44.905]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:44.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:44.905]                         fi_tmp[["mtime"]], msg)
[13:33:44.905]                       ex$message <- msg
[13:33:44.905]                       stop(ex)
[13:33:44.905]                     })
[13:33:44.905]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:44.905]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:44.905]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:44.905]                       fi_tmp <- file.info(pathname_tmp)
[13:33:44.905]                       fi <- file.info(pathname)
[13:33:44.905]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:44.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:44.905]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:44.905]                         fi[["size"]], fi[["mtime"]])
[13:33:44.905]                       stop(msg)
[13:33:44.905]                     }
[13:33:44.905]                     invisible(pathname)
[13:33:44.905]                   }
[13:33:44.905]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:44.905]                     rootPath = tempdir()) 
[13:33:44.905]                   {
[13:33:44.905]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:44.905]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:44.905]                       tmpdir = path, fileext = ".rds")
[13:33:44.905]                     save_rds(obj, file)
[13:33:44.905]                   }
[13:33:44.905]                   saveImmediateCondition(cond, path = "/tmp/RtmpC9rl05/.future/immediateConditions")
[13:33:44.905]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.905]                   {
[13:33:44.905]                     inherits <- base::inherits
[13:33:44.905]                     invokeRestart <- base::invokeRestart
[13:33:44.905]                     is.null <- base::is.null
[13:33:44.905]                     muffled <- FALSE
[13:33:44.905]                     if (inherits(cond, "message")) {
[13:33:44.905]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:44.905]                       if (muffled) 
[13:33:44.905]                         invokeRestart("muffleMessage")
[13:33:44.905]                     }
[13:33:44.905]                     else if (inherits(cond, "warning")) {
[13:33:44.905]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:44.905]                       if (muffled) 
[13:33:44.905]                         invokeRestart("muffleWarning")
[13:33:44.905]                     }
[13:33:44.905]                     else if (inherits(cond, "condition")) {
[13:33:44.905]                       if (!is.null(pattern)) {
[13:33:44.905]                         computeRestarts <- base::computeRestarts
[13:33:44.905]                         grepl <- base::grepl
[13:33:44.905]                         restarts <- computeRestarts(cond)
[13:33:44.905]                         for (restart in restarts) {
[13:33:44.905]                           name <- restart$name
[13:33:44.905]                           if (is.null(name)) 
[13:33:44.905]                             next
[13:33:44.905]                           if (!grepl(pattern, name)) 
[13:33:44.905]                             next
[13:33:44.905]                           invokeRestart(restart)
[13:33:44.905]                           muffled <- TRUE
[13:33:44.905]                           break
[13:33:44.905]                         }
[13:33:44.905]                       }
[13:33:44.905]                     }
[13:33:44.905]                     invisible(muffled)
[13:33:44.905]                   }
[13:33:44.905]                   muffleCondition(cond)
[13:33:44.905]                 })
[13:33:44.905]             }))
[13:33:44.905]             future::FutureResult(value = ...future.value$value, 
[13:33:44.905]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:44.905]                   ...future.rng), globalenv = if (FALSE) 
[13:33:44.905]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:44.905]                     ...future.globalenv.names))
[13:33:44.905]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:44.905]         }, condition = base::local({
[13:33:44.905]             c <- base::c
[13:33:44.905]             inherits <- base::inherits
[13:33:44.905]             invokeRestart <- base::invokeRestart
[13:33:44.905]             length <- base::length
[13:33:44.905]             list <- base::list
[13:33:44.905]             seq.int <- base::seq.int
[13:33:44.905]             signalCondition <- base::signalCondition
[13:33:44.905]             sys.calls <- base::sys.calls
[13:33:44.905]             `[[` <- base::`[[`
[13:33:44.905]             `+` <- base::`+`
[13:33:44.905]             `<<-` <- base::`<<-`
[13:33:44.905]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:44.905]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:44.905]                   3L)]
[13:33:44.905]             }
[13:33:44.905]             function(cond) {
[13:33:44.905]                 is_error <- inherits(cond, "error")
[13:33:44.905]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:44.905]                   NULL)
[13:33:44.905]                 if (is_error) {
[13:33:44.905]                   sessionInformation <- function() {
[13:33:44.905]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:44.905]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:44.905]                       search = base::search(), system = base::Sys.info())
[13:33:44.905]                   }
[13:33:44.905]                   ...future.conditions[[length(...future.conditions) + 
[13:33:44.905]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:44.905]                     cond$call), session = sessionInformation(), 
[13:33:44.905]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:44.905]                   signalCondition(cond)
[13:33:44.905]                 }
[13:33:44.905]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:44.905]                 "immediateCondition"))) {
[13:33:44.905]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:44.905]                   ...future.conditions[[length(...future.conditions) + 
[13:33:44.905]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:44.905]                   if (TRUE && !signal) {
[13:33:44.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.905]                     {
[13:33:44.905]                       inherits <- base::inherits
[13:33:44.905]                       invokeRestart <- base::invokeRestart
[13:33:44.905]                       is.null <- base::is.null
[13:33:44.905]                       muffled <- FALSE
[13:33:44.905]                       if (inherits(cond, "message")) {
[13:33:44.905]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:44.905]                         if (muffled) 
[13:33:44.905]                           invokeRestart("muffleMessage")
[13:33:44.905]                       }
[13:33:44.905]                       else if (inherits(cond, "warning")) {
[13:33:44.905]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:44.905]                         if (muffled) 
[13:33:44.905]                           invokeRestart("muffleWarning")
[13:33:44.905]                       }
[13:33:44.905]                       else if (inherits(cond, "condition")) {
[13:33:44.905]                         if (!is.null(pattern)) {
[13:33:44.905]                           computeRestarts <- base::computeRestarts
[13:33:44.905]                           grepl <- base::grepl
[13:33:44.905]                           restarts <- computeRestarts(cond)
[13:33:44.905]                           for (restart in restarts) {
[13:33:44.905]                             name <- restart$name
[13:33:44.905]                             if (is.null(name)) 
[13:33:44.905]                               next
[13:33:44.905]                             if (!grepl(pattern, name)) 
[13:33:44.905]                               next
[13:33:44.905]                             invokeRestart(restart)
[13:33:44.905]                             muffled <- TRUE
[13:33:44.905]                             break
[13:33:44.905]                           }
[13:33:44.905]                         }
[13:33:44.905]                       }
[13:33:44.905]                       invisible(muffled)
[13:33:44.905]                     }
[13:33:44.905]                     muffleCondition(cond, pattern = "^muffle")
[13:33:44.905]                   }
[13:33:44.905]                 }
[13:33:44.905]                 else {
[13:33:44.905]                   if (TRUE) {
[13:33:44.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.905]                     {
[13:33:44.905]                       inherits <- base::inherits
[13:33:44.905]                       invokeRestart <- base::invokeRestart
[13:33:44.905]                       is.null <- base::is.null
[13:33:44.905]                       muffled <- FALSE
[13:33:44.905]                       if (inherits(cond, "message")) {
[13:33:44.905]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:44.905]                         if (muffled) 
[13:33:44.905]                           invokeRestart("muffleMessage")
[13:33:44.905]                       }
[13:33:44.905]                       else if (inherits(cond, "warning")) {
[13:33:44.905]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:44.905]                         if (muffled) 
[13:33:44.905]                           invokeRestart("muffleWarning")
[13:33:44.905]                       }
[13:33:44.905]                       else if (inherits(cond, "condition")) {
[13:33:44.905]                         if (!is.null(pattern)) {
[13:33:44.905]                           computeRestarts <- base::computeRestarts
[13:33:44.905]                           grepl <- base::grepl
[13:33:44.905]                           restarts <- computeRestarts(cond)
[13:33:44.905]                           for (restart in restarts) {
[13:33:44.905]                             name <- restart$name
[13:33:44.905]                             if (is.null(name)) 
[13:33:44.905]                               next
[13:33:44.905]                             if (!grepl(pattern, name)) 
[13:33:44.905]                               next
[13:33:44.905]                             invokeRestart(restart)
[13:33:44.905]                             muffled <- TRUE
[13:33:44.905]                             break
[13:33:44.905]                           }
[13:33:44.905]                         }
[13:33:44.905]                       }
[13:33:44.905]                       invisible(muffled)
[13:33:44.905]                     }
[13:33:44.905]                     muffleCondition(cond, pattern = "^muffle")
[13:33:44.905]                   }
[13:33:44.905]                 }
[13:33:44.905]             }
[13:33:44.905]         }))
[13:33:44.905]     }, error = function(ex) {
[13:33:44.905]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:44.905]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:44.905]                 ...future.rng), started = ...future.startTime, 
[13:33:44.905]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:44.905]             version = "1.8"), class = "FutureResult")
[13:33:44.905]     }, finally = {
[13:33:44.905]         if (!identical(...future.workdir, getwd())) 
[13:33:44.905]             setwd(...future.workdir)
[13:33:44.905]         {
[13:33:44.905]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:44.905]                 ...future.oldOptions$nwarnings <- NULL
[13:33:44.905]             }
[13:33:44.905]             base::options(...future.oldOptions)
[13:33:44.905]             if (.Platform$OS.type == "windows") {
[13:33:44.905]                 old_names <- names(...future.oldEnvVars)
[13:33:44.905]                 envs <- base::Sys.getenv()
[13:33:44.905]                 names <- names(envs)
[13:33:44.905]                 common <- intersect(names, old_names)
[13:33:44.905]                 added <- setdiff(names, old_names)
[13:33:44.905]                 removed <- setdiff(old_names, names)
[13:33:44.905]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:44.905]                   envs[common]]
[13:33:44.905]                 NAMES <- toupper(changed)
[13:33:44.905]                 args <- list()
[13:33:44.905]                 for (kk in seq_along(NAMES)) {
[13:33:44.905]                   name <- changed[[kk]]
[13:33:44.905]                   NAME <- NAMES[[kk]]
[13:33:44.905]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.905]                     next
[13:33:44.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:44.905]                 }
[13:33:44.905]                 NAMES <- toupper(added)
[13:33:44.905]                 for (kk in seq_along(NAMES)) {
[13:33:44.905]                   name <- added[[kk]]
[13:33:44.905]                   NAME <- NAMES[[kk]]
[13:33:44.905]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.905]                     next
[13:33:44.905]                   args[[name]] <- ""
[13:33:44.905]                 }
[13:33:44.905]                 NAMES <- toupper(removed)
[13:33:44.905]                 for (kk in seq_along(NAMES)) {
[13:33:44.905]                   name <- removed[[kk]]
[13:33:44.905]                   NAME <- NAMES[[kk]]
[13:33:44.905]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.905]                     next
[13:33:44.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:44.905]                 }
[13:33:44.905]                 if (length(args) > 0) 
[13:33:44.905]                   base::do.call(base::Sys.setenv, args = args)
[13:33:44.905]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:44.905]             }
[13:33:44.905]             else {
[13:33:44.905]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:44.905]             }
[13:33:44.905]             {
[13:33:44.905]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:44.905]                   0L) {
[13:33:44.905]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:44.905]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:44.905]                   base::options(opts)
[13:33:44.905]                 }
[13:33:44.905]                 {
[13:33:44.905]                   {
[13:33:44.905]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:44.905]                     NULL
[13:33:44.905]                   }
[13:33:44.905]                   options(future.plan = NULL)
[13:33:44.905]                   if (is.na(NA_character_)) 
[13:33:44.905]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:44.905]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:44.905]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:44.905]                     .init = FALSE)
[13:33:44.905]                 }
[13:33:44.905]             }
[13:33:44.905]         }
[13:33:44.905]     })
[13:33:44.905]     if (TRUE) {
[13:33:44.905]         base::sink(type = "output", split = FALSE)
[13:33:44.905]         if (TRUE) {
[13:33:44.905]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:44.905]         }
[13:33:44.905]         else {
[13:33:44.905]             ...future.result["stdout"] <- base::list(NULL)
[13:33:44.905]         }
[13:33:44.905]         base::close(...future.stdout)
[13:33:44.905]         ...future.stdout <- NULL
[13:33:44.905]     }
[13:33:44.905]     ...future.result$conditions <- ...future.conditions
[13:33:44.905]     ...future.result$finished <- base::Sys.time()
[13:33:44.905]     ...future.result
[13:33:44.905] }
[13:33:44.907] assign_globals() ...
[13:33:44.907] List of 5
[13:33:44.907]  $ ...future.FUN            :function (x, ...)  
[13:33:44.907]  $ future.call.arguments    : list()
[13:33:44.907]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.907]  $ ...future.elements_ii    :List of 1
[13:33:44.907]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[13:33:44.907]  $ ...future.seeds_ii       : NULL
[13:33:44.907]  $ ...future.globals.maxSize: NULL
[13:33:44.907]  - attr(*, "where")=List of 5
[13:33:44.907]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:44.907]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:44.907]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:44.907]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:44.907]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:44.907]  - attr(*, "resolved")= logi FALSE
[13:33:44.907]  - attr(*, "total_size")= num 1248
[13:33:44.907]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.907]  - attr(*, "already-done")= logi TRUE
[13:33:44.912] - copied ‘...future.FUN’ to environment
[13:33:44.912] - copied ‘future.call.arguments’ to environment
[13:33:44.912] - copied ‘...future.elements_ii’ to environment
[13:33:44.912] - copied ‘...future.seeds_ii’ to environment
[13:33:44.912] - copied ‘...future.globals.maxSize’ to environment
[13:33:44.912] assign_globals() ... done
[13:33:44.912] requestCore(): workers = 2
[13:33:44.914] MulticoreFuture started
[13:33:44.914] - Launch lazy future ... done
[13:33:44.915] run() for ‘MulticoreFuture’ ... done
[13:33:44.915] Created future:
[13:33:44.916] plan(): Setting new future strategy stack:
[13:33:44.916] List of future strategies:
[13:33:44.916] 1. sequential:
[13:33:44.916]    - args: function (..., envir = parent.frame())
[13:33:44.916]    - tweaked: FALSE
[13:33:44.916]    - call: NULL
[13:33:44.917] plan(): nbrOfWorkers() = 1
[13:33:44.919] plan(): Setting new future strategy stack:
[13:33:44.919] List of future strategies:
[13:33:44.919] 1. multicore:
[13:33:44.919]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:44.919]    - tweaked: FALSE
[13:33:44.919]    - call: plan(strategy)
[13:33:44.924] plan(): nbrOfWorkers() = 2
[13:33:44.915] MulticoreFuture:
[13:33:44.915] Label: ‘future_eapply-1’
[13:33:44.915] Expression:
[13:33:44.915] {
[13:33:44.915]     do.call(function(...) {
[13:33:44.915]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.915]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:44.915]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.915]             on.exit(options(oopts), add = TRUE)
[13:33:44.915]         }
[13:33:44.915]         {
[13:33:44.915]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:44.915]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.915]                 ...future.FUN(...future.X_jj, ...)
[13:33:44.915]             })
[13:33:44.915]         }
[13:33:44.915]     }, args = future.call.arguments)
[13:33:44.915] }
[13:33:44.915] Lazy evaluation: FALSE
[13:33:44.915] Asynchronous evaluation: TRUE
[13:33:44.915] Local evaluation: TRUE
[13:33:44.915] Environment: R_GlobalEnv
[13:33:44.915] Capture standard output: TRUE
[13:33:44.915] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:44.915] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:44.915] Packages: 1 packages (‘stats’)
[13:33:44.915] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:44.915] Resolved: TRUE
[13:33:44.915] Value: <not collected>
[13:33:44.915] Conditions captured: <none>
[13:33:44.915] Early signaling: FALSE
[13:33:44.915] Owner process: b6e93464-7fc2-3f8d-23d1-d8004201d1f1
[13:33:44.915] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:44.925] Chunk #1 of 2 ... DONE
[13:33:44.925] Chunk #2 of 2 ...
[13:33:44.925]  - Finding globals in 'X' for chunk #2 ...
[13:33:44.926] getGlobalsAndPackages() ...
[13:33:44.926] Searching for globals...
[13:33:44.926] 
[13:33:44.926] Searching for globals ... DONE
[13:33:44.926] - globals: [0] <none>
[13:33:44.927] getGlobalsAndPackages() ... DONE
[13:33:44.927]    + additional globals found: [n=0] 
[13:33:44.927]    + additional namespaces needed: [n=0] 
[13:33:44.927]  - Finding globals in 'X' for chunk #2 ... DONE
[13:33:44.927]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:44.927]  - seeds: <none>
[13:33:44.927]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.927] getGlobalsAndPackages() ...
[13:33:44.928] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.928] Resolving globals: FALSE
[13:33:44.928] Tweak future expression to call with '...' arguments ...
[13:33:44.928] {
[13:33:44.928]     do.call(function(...) {
[13:33:44.928]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.928]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:44.928]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.928]             on.exit(options(oopts), add = TRUE)
[13:33:44.928]         }
[13:33:44.928]         {
[13:33:44.928]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:44.928]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.928]                 ...future.FUN(...future.X_jj, ...)
[13:33:44.928]             })
[13:33:44.928]         }
[13:33:44.928]     }, args = future.call.arguments)
[13:33:44.928] }
[13:33:44.929] Tweak future expression to call with '...' arguments ... DONE
[13:33:44.929] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:44.929] - packages: [1] ‘stats’
[13:33:44.930] getGlobalsAndPackages() ... DONE
[13:33:44.933] run() for ‘Future’ ...
[13:33:44.934] - state: ‘created’
[13:33:44.934] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:33:44.939] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:44.939] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:33:44.939]   - Field: ‘label’
[13:33:44.940]   - Field: ‘local’
[13:33:44.940]   - Field: ‘owner’
[13:33:44.940]   - Field: ‘envir’
[13:33:44.940]   - Field: ‘workers’
[13:33:44.940]   - Field: ‘packages’
[13:33:44.941]   - Field: ‘gc’
[13:33:44.941]   - Field: ‘job’
[13:33:44.941]   - Field: ‘conditions’
[13:33:44.941]   - Field: ‘expr’
[13:33:44.941]   - Field: ‘uuid’
[13:33:44.941]   - Field: ‘seed’
[13:33:44.942]   - Field: ‘version’
[13:33:44.942]   - Field: ‘result’
[13:33:44.942]   - Field: ‘asynchronous’
[13:33:44.942]   - Field: ‘calls’
[13:33:44.942]   - Field: ‘globals’
[13:33:44.942]   - Field: ‘stdout’
[13:33:44.943]   - Field: ‘earlySignal’
[13:33:44.943]   - Field: ‘lazy’
[13:33:44.943]   - Field: ‘state’
[13:33:44.943] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:33:44.943] - Launch lazy future ...
[13:33:44.944] Packages needed by the future expression (n = 1): ‘stats’
[13:33:44.944] Packages needed by future strategies (n = 0): <none>
[13:33:44.945] {
[13:33:44.945]     {
[13:33:44.945]         {
[13:33:44.945]             ...future.startTime <- base::Sys.time()
[13:33:44.945]             {
[13:33:44.945]                 {
[13:33:44.945]                   {
[13:33:44.945]                     {
[13:33:44.945]                       {
[13:33:44.945]                         base::local({
[13:33:44.945]                           has_future <- base::requireNamespace("future", 
[13:33:44.945]                             quietly = TRUE)
[13:33:44.945]                           if (has_future) {
[13:33:44.945]                             ns <- base::getNamespace("future")
[13:33:44.945]                             version <- ns[[".package"]][["version"]]
[13:33:44.945]                             if (is.null(version)) 
[13:33:44.945]                               version <- utils::packageVersion("future")
[13:33:44.945]                           }
[13:33:44.945]                           else {
[13:33:44.945]                             version <- NULL
[13:33:44.945]                           }
[13:33:44.945]                           if (!has_future || version < "1.8.0") {
[13:33:44.945]                             info <- base::c(r_version = base::gsub("R version ", 
[13:33:44.945]                               "", base::R.version$version.string), 
[13:33:44.945]                               platform = base::sprintf("%s (%s-bit)", 
[13:33:44.945]                                 base::R.version$platform, 8 * 
[13:33:44.945]                                   base::.Machine$sizeof.pointer), 
[13:33:44.945]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:44.945]                                 "release", "version")], collapse = " "), 
[13:33:44.945]                               hostname = base::Sys.info()[["nodename"]])
[13:33:44.945]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:33:44.945]                               info)
[13:33:44.945]                             info <- base::paste(info, collapse = "; ")
[13:33:44.945]                             if (!has_future) {
[13:33:44.945]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:44.945]                                 info)
[13:33:44.945]                             }
[13:33:44.945]                             else {
[13:33:44.945]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:44.945]                                 info, version)
[13:33:44.945]                             }
[13:33:44.945]                             base::stop(msg)
[13:33:44.945]                           }
[13:33:44.945]                         })
[13:33:44.945]                       }
[13:33:44.945]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:44.945]                       base::options(mc.cores = 1L)
[13:33:44.945]                     }
[13:33:44.945]                     base::local({
[13:33:44.945]                       for (pkg in "stats") {
[13:33:44.945]                         base::loadNamespace(pkg)
[13:33:44.945]                         base::library(pkg, character.only = TRUE)
[13:33:44.945]                       }
[13:33:44.945]                     })
[13:33:44.945]                   }
[13:33:44.945]                   ...future.strategy.old <- future::plan("list")
[13:33:44.945]                   options(future.plan = NULL)
[13:33:44.945]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:44.945]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:44.945]                 }
[13:33:44.945]                 ...future.workdir <- getwd()
[13:33:44.945]             }
[13:33:44.945]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:44.945]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:44.945]         }
[13:33:44.945]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:44.945]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:44.945]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:44.945]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:44.945]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:44.945]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:44.945]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:44.945]             base::names(...future.oldOptions))
[13:33:44.945]     }
[13:33:44.945]     if (FALSE) {
[13:33:44.945]     }
[13:33:44.945]     else {
[13:33:44.945]         if (TRUE) {
[13:33:44.945]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:44.945]                 open = "w")
[13:33:44.945]         }
[13:33:44.945]         else {
[13:33:44.945]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:44.945]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:44.945]         }
[13:33:44.945]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:44.945]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:44.945]             base::sink(type = "output", split = FALSE)
[13:33:44.945]             base::close(...future.stdout)
[13:33:44.945]         }, add = TRUE)
[13:33:44.945]     }
[13:33:44.945]     ...future.frame <- base::sys.nframe()
[13:33:44.945]     ...future.conditions <- base::list()
[13:33:44.945]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:44.945]     if (FALSE) {
[13:33:44.945]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:44.945]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:44.945]     }
[13:33:44.945]     ...future.result <- base::tryCatch({
[13:33:44.945]         base::withCallingHandlers({
[13:33:44.945]             ...future.value <- base::withVisible(base::local({
[13:33:44.945]                 withCallingHandlers({
[13:33:44.945]                   {
[13:33:44.945]                     do.call(function(...) {
[13:33:44.945]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.945]                       if (!identical(...future.globals.maxSize.org, 
[13:33:44.945]                         ...future.globals.maxSize)) {
[13:33:44.945]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.945]                         on.exit(options(oopts), add = TRUE)
[13:33:44.945]                       }
[13:33:44.945]                       {
[13:33:44.945]                         lapply(seq_along(...future.elements_ii), 
[13:33:44.945]                           FUN = function(jj) {
[13:33:44.945]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.945]                             ...future.FUN(...future.X_jj, ...)
[13:33:44.945]                           })
[13:33:44.945]                       }
[13:33:44.945]                     }, args = future.call.arguments)
[13:33:44.945]                   }
[13:33:44.945]                 }, immediateCondition = function(cond) {
[13:33:44.945]                   save_rds <- function (object, pathname, ...) 
[13:33:44.945]                   {
[13:33:44.945]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:33:44.945]                     if (file_test("-f", pathname_tmp)) {
[13:33:44.945]                       fi_tmp <- file.info(pathname_tmp)
[13:33:44.945]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:33:44.945]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:44.945]                         fi_tmp[["mtime"]])
[13:33:44.945]                     }
[13:33:44.945]                     tryCatch({
[13:33:44.945]                       saveRDS(object, file = pathname_tmp, ...)
[13:33:44.945]                     }, error = function(ex) {
[13:33:44.945]                       msg <- conditionMessage(ex)
[13:33:44.945]                       fi_tmp <- file.info(pathname_tmp)
[13:33:44.945]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:33:44.945]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:44.945]                         fi_tmp[["mtime"]], msg)
[13:33:44.945]                       ex$message <- msg
[13:33:44.945]                       stop(ex)
[13:33:44.945]                     })
[13:33:44.945]                     stopifnot(file_test("-f", pathname_tmp))
[13:33:44.945]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:33:44.945]                     if (!res || file_test("-f", pathname_tmp)) {
[13:33:44.945]                       fi_tmp <- file.info(pathname_tmp)
[13:33:44.945]                       fi <- file.info(pathname)
[13:33:44.945]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:33:44.945]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:33:44.945]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:33:44.945]                         fi[["size"]], fi[["mtime"]])
[13:33:44.945]                       stop(msg)
[13:33:44.945]                     }
[13:33:44.945]                     invisible(pathname)
[13:33:44.945]                   }
[13:33:44.945]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:33:44.945]                     rootPath = tempdir()) 
[13:33:44.945]                   {
[13:33:44.945]                     obj <- list(time = Sys.time(), condition = cond)
[13:33:44.945]                     file <- tempfile(pattern = class(cond)[1], 
[13:33:44.945]                       tmpdir = path, fileext = ".rds")
[13:33:44.945]                     save_rds(obj, file)
[13:33:44.945]                   }
[13:33:44.945]                   saveImmediateCondition(cond, path = "/tmp/RtmpC9rl05/.future/immediateConditions")
[13:33:44.945]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.945]                   {
[13:33:44.945]                     inherits <- base::inherits
[13:33:44.945]                     invokeRestart <- base::invokeRestart
[13:33:44.945]                     is.null <- base::is.null
[13:33:44.945]                     muffled <- FALSE
[13:33:44.945]                     if (inherits(cond, "message")) {
[13:33:44.945]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:44.945]                       if (muffled) 
[13:33:44.945]                         invokeRestart("muffleMessage")
[13:33:44.945]                     }
[13:33:44.945]                     else if (inherits(cond, "warning")) {
[13:33:44.945]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:44.945]                       if (muffled) 
[13:33:44.945]                         invokeRestart("muffleWarning")
[13:33:44.945]                     }
[13:33:44.945]                     else if (inherits(cond, "condition")) {
[13:33:44.945]                       if (!is.null(pattern)) {
[13:33:44.945]                         computeRestarts <- base::computeRestarts
[13:33:44.945]                         grepl <- base::grepl
[13:33:44.945]                         restarts <- computeRestarts(cond)
[13:33:44.945]                         for (restart in restarts) {
[13:33:44.945]                           name <- restart$name
[13:33:44.945]                           if (is.null(name)) 
[13:33:44.945]                             next
[13:33:44.945]                           if (!grepl(pattern, name)) 
[13:33:44.945]                             next
[13:33:44.945]                           invokeRestart(restart)
[13:33:44.945]                           muffled <- TRUE
[13:33:44.945]                           break
[13:33:44.945]                         }
[13:33:44.945]                       }
[13:33:44.945]                     }
[13:33:44.945]                     invisible(muffled)
[13:33:44.945]                   }
[13:33:44.945]                   muffleCondition(cond)
[13:33:44.945]                 })
[13:33:44.945]             }))
[13:33:44.945]             future::FutureResult(value = ...future.value$value, 
[13:33:44.945]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:44.945]                   ...future.rng), globalenv = if (FALSE) 
[13:33:44.945]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:44.945]                     ...future.globalenv.names))
[13:33:44.945]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:44.945]         }, condition = base::local({
[13:33:44.945]             c <- base::c
[13:33:44.945]             inherits <- base::inherits
[13:33:44.945]             invokeRestart <- base::invokeRestart
[13:33:44.945]             length <- base::length
[13:33:44.945]             list <- base::list
[13:33:44.945]             seq.int <- base::seq.int
[13:33:44.945]             signalCondition <- base::signalCondition
[13:33:44.945]             sys.calls <- base::sys.calls
[13:33:44.945]             `[[` <- base::`[[`
[13:33:44.945]             `+` <- base::`+`
[13:33:44.945]             `<<-` <- base::`<<-`
[13:33:44.945]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:44.945]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:44.945]                   3L)]
[13:33:44.945]             }
[13:33:44.945]             function(cond) {
[13:33:44.945]                 is_error <- inherits(cond, "error")
[13:33:44.945]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:44.945]                   NULL)
[13:33:44.945]                 if (is_error) {
[13:33:44.945]                   sessionInformation <- function() {
[13:33:44.945]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:44.945]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:44.945]                       search = base::search(), system = base::Sys.info())
[13:33:44.945]                   }
[13:33:44.945]                   ...future.conditions[[length(...future.conditions) + 
[13:33:44.945]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:44.945]                     cond$call), session = sessionInformation(), 
[13:33:44.945]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:44.945]                   signalCondition(cond)
[13:33:44.945]                 }
[13:33:44.945]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:44.945]                 "immediateCondition"))) {
[13:33:44.945]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:44.945]                   ...future.conditions[[length(...future.conditions) + 
[13:33:44.945]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:44.945]                   if (TRUE && !signal) {
[13:33:44.945]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.945]                     {
[13:33:44.945]                       inherits <- base::inherits
[13:33:44.945]                       invokeRestart <- base::invokeRestart
[13:33:44.945]                       is.null <- base::is.null
[13:33:44.945]                       muffled <- FALSE
[13:33:44.945]                       if (inherits(cond, "message")) {
[13:33:44.945]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:44.945]                         if (muffled) 
[13:33:44.945]                           invokeRestart("muffleMessage")
[13:33:44.945]                       }
[13:33:44.945]                       else if (inherits(cond, "warning")) {
[13:33:44.945]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:44.945]                         if (muffled) 
[13:33:44.945]                           invokeRestart("muffleWarning")
[13:33:44.945]                       }
[13:33:44.945]                       else if (inherits(cond, "condition")) {
[13:33:44.945]                         if (!is.null(pattern)) {
[13:33:44.945]                           computeRestarts <- base::computeRestarts
[13:33:44.945]                           grepl <- base::grepl
[13:33:44.945]                           restarts <- computeRestarts(cond)
[13:33:44.945]                           for (restart in restarts) {
[13:33:44.945]                             name <- restart$name
[13:33:44.945]                             if (is.null(name)) 
[13:33:44.945]                               next
[13:33:44.945]                             if (!grepl(pattern, name)) 
[13:33:44.945]                               next
[13:33:44.945]                             invokeRestart(restart)
[13:33:44.945]                             muffled <- TRUE
[13:33:44.945]                             break
[13:33:44.945]                           }
[13:33:44.945]                         }
[13:33:44.945]                       }
[13:33:44.945]                       invisible(muffled)
[13:33:44.945]                     }
[13:33:44.945]                     muffleCondition(cond, pattern = "^muffle")
[13:33:44.945]                   }
[13:33:44.945]                 }
[13:33:44.945]                 else {
[13:33:44.945]                   if (TRUE) {
[13:33:44.945]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:44.945]                     {
[13:33:44.945]                       inherits <- base::inherits
[13:33:44.945]                       invokeRestart <- base::invokeRestart
[13:33:44.945]                       is.null <- base::is.null
[13:33:44.945]                       muffled <- FALSE
[13:33:44.945]                       if (inherits(cond, "message")) {
[13:33:44.945]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:44.945]                         if (muffled) 
[13:33:44.945]                           invokeRestart("muffleMessage")
[13:33:44.945]                       }
[13:33:44.945]                       else if (inherits(cond, "warning")) {
[13:33:44.945]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:44.945]                         if (muffled) 
[13:33:44.945]                           invokeRestart("muffleWarning")
[13:33:44.945]                       }
[13:33:44.945]                       else if (inherits(cond, "condition")) {
[13:33:44.945]                         if (!is.null(pattern)) {
[13:33:44.945]                           computeRestarts <- base::computeRestarts
[13:33:44.945]                           grepl <- base::grepl
[13:33:44.945]                           restarts <- computeRestarts(cond)
[13:33:44.945]                           for (restart in restarts) {
[13:33:44.945]                             name <- restart$name
[13:33:44.945]                             if (is.null(name)) 
[13:33:44.945]                               next
[13:33:44.945]                             if (!grepl(pattern, name)) 
[13:33:44.945]                               next
[13:33:44.945]                             invokeRestart(restart)
[13:33:44.945]                             muffled <- TRUE
[13:33:44.945]                             break
[13:33:44.945]                           }
[13:33:44.945]                         }
[13:33:44.945]                       }
[13:33:44.945]                       invisible(muffled)
[13:33:44.945]                     }
[13:33:44.945]                     muffleCondition(cond, pattern = "^muffle")
[13:33:44.945]                   }
[13:33:44.945]                 }
[13:33:44.945]             }
[13:33:44.945]         }))
[13:33:44.945]     }, error = function(ex) {
[13:33:44.945]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:44.945]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:44.945]                 ...future.rng), started = ...future.startTime, 
[13:33:44.945]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:44.945]             version = "1.8"), class = "FutureResult")
[13:33:44.945]     }, finally = {
[13:33:44.945]         if (!identical(...future.workdir, getwd())) 
[13:33:44.945]             setwd(...future.workdir)
[13:33:44.945]         {
[13:33:44.945]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:44.945]                 ...future.oldOptions$nwarnings <- NULL
[13:33:44.945]             }
[13:33:44.945]             base::options(...future.oldOptions)
[13:33:44.945]             if (.Platform$OS.type == "windows") {
[13:33:44.945]                 old_names <- names(...future.oldEnvVars)
[13:33:44.945]                 envs <- base::Sys.getenv()
[13:33:44.945]                 names <- names(envs)
[13:33:44.945]                 common <- intersect(names, old_names)
[13:33:44.945]                 added <- setdiff(names, old_names)
[13:33:44.945]                 removed <- setdiff(old_names, names)
[13:33:44.945]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:44.945]                   envs[common]]
[13:33:44.945]                 NAMES <- toupper(changed)
[13:33:44.945]                 args <- list()
[13:33:44.945]                 for (kk in seq_along(NAMES)) {
[13:33:44.945]                   name <- changed[[kk]]
[13:33:44.945]                   NAME <- NAMES[[kk]]
[13:33:44.945]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.945]                     next
[13:33:44.945]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:44.945]                 }
[13:33:44.945]                 NAMES <- toupper(added)
[13:33:44.945]                 for (kk in seq_along(NAMES)) {
[13:33:44.945]                   name <- added[[kk]]
[13:33:44.945]                   NAME <- NAMES[[kk]]
[13:33:44.945]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.945]                     next
[13:33:44.945]                   args[[name]] <- ""
[13:33:44.945]                 }
[13:33:44.945]                 NAMES <- toupper(removed)
[13:33:44.945]                 for (kk in seq_along(NAMES)) {
[13:33:44.945]                   name <- removed[[kk]]
[13:33:44.945]                   NAME <- NAMES[[kk]]
[13:33:44.945]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:44.945]                     next
[13:33:44.945]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:44.945]                 }
[13:33:44.945]                 if (length(args) > 0) 
[13:33:44.945]                   base::do.call(base::Sys.setenv, args = args)
[13:33:44.945]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:44.945]             }
[13:33:44.945]             else {
[13:33:44.945]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:44.945]             }
[13:33:44.945]             {
[13:33:44.945]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:44.945]                   0L) {
[13:33:44.945]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:44.945]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:44.945]                   base::options(opts)
[13:33:44.945]                 }
[13:33:44.945]                 {
[13:33:44.945]                   {
[13:33:44.945]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:44.945]                     NULL
[13:33:44.945]                   }
[13:33:44.945]                   options(future.plan = NULL)
[13:33:44.945]                   if (is.na(NA_character_)) 
[13:33:44.945]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:44.945]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:44.945]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:44.945]                     .init = FALSE)
[13:33:44.945]                 }
[13:33:44.945]             }
[13:33:44.945]         }
[13:33:44.945]     })
[13:33:44.945]     if (TRUE) {
[13:33:44.945]         base::sink(type = "output", split = FALSE)
[13:33:44.945]         if (TRUE) {
[13:33:44.945]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:44.945]         }
[13:33:44.945]         else {
[13:33:44.945]             ...future.result["stdout"] <- base::list(NULL)
[13:33:44.945]         }
[13:33:44.945]         base::close(...future.stdout)
[13:33:44.945]         ...future.stdout <- NULL
[13:33:44.945]     }
[13:33:44.945]     ...future.result$conditions <- ...future.conditions
[13:33:44.945]     ...future.result$finished <- base::Sys.time()
[13:33:44.945]     ...future.result
[13:33:44.945] }
[13:33:44.947] assign_globals() ...
[13:33:44.948] List of 5
[13:33:44.948]  $ ...future.FUN            :function (x, ...)  
[13:33:44.948]  $ future.call.arguments    : list()
[13:33:44.948]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:44.948]  $ ...future.elements_ii    :List of 2
[13:33:44.948]   ..$ beta: num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:33:44.948]   ..$ a   : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:33:44.948]  $ ...future.seeds_ii       : NULL
[13:33:44.948]  $ ...future.globals.maxSize: NULL
[13:33:44.948]  - attr(*, "where")=List of 5
[13:33:44.948]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:33:44.948]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:33:44.948]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:33:44.948]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:33:44.948]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:33:44.948]  - attr(*, "resolved")= logi FALSE
[13:33:44.948]  - attr(*, "total_size")= num 1248
[13:33:44.948]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:44.948]  - attr(*, "already-done")= logi TRUE
[13:33:44.955] - copied ‘...future.FUN’ to environment
[13:33:44.955] - copied ‘future.call.arguments’ to environment
[13:33:44.955] - copied ‘...future.elements_ii’ to environment
[13:33:44.956] - copied ‘...future.seeds_ii’ to environment
[13:33:44.956] - copied ‘...future.globals.maxSize’ to environment
[13:33:44.956] assign_globals() ... done
[13:33:44.956] requestCore(): workers = 2
[13:33:44.958] MulticoreFuture started
[13:33:44.958] - Launch lazy future ... done
[13:33:44.959] run() for ‘MulticoreFuture’ ... done
[13:33:44.959] Created future:
[13:33:44.960] plan(): Setting new future strategy stack:
[13:33:44.960] List of future strategies:
[13:33:44.960] 1. sequential:
[13:33:44.960]    - args: function (..., envir = parent.frame())
[13:33:44.960]    - tweaked: FALSE
[13:33:44.960]    - call: NULL
[13:33:44.961] plan(): nbrOfWorkers() = 1
[13:33:44.963] plan(): Setting new future strategy stack:
[13:33:44.964] List of future strategies:
[13:33:44.964] 1. multicore:
[13:33:44.964]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:33:44.964]    - tweaked: FALSE
[13:33:44.964]    - call: plan(strategy)
[13:33:44.969] plan(): nbrOfWorkers() = 2
[13:33:44.959] MulticoreFuture:
[13:33:44.959] Label: ‘future_eapply-2’
[13:33:44.959] Expression:
[13:33:44.959] {
[13:33:44.959]     do.call(function(...) {
[13:33:44.959]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:44.959]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:44.959]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:44.959]             on.exit(options(oopts), add = TRUE)
[13:33:44.959]         }
[13:33:44.959]         {
[13:33:44.959]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:44.959]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:44.959]                 ...future.FUN(...future.X_jj, ...)
[13:33:44.959]             })
[13:33:44.959]         }
[13:33:44.959]     }, args = future.call.arguments)
[13:33:44.959] }
[13:33:44.959] Lazy evaluation: FALSE
[13:33:44.959] Asynchronous evaluation: TRUE
[13:33:44.959] Local evaluation: TRUE
[13:33:44.959] Environment: R_GlobalEnv
[13:33:44.959] Capture standard output: TRUE
[13:33:44.959] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:44.959] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:44.959] Packages: 1 packages (‘stats’)
[13:33:44.959] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:44.959] Resolved: TRUE
[13:33:44.959] Value: <not collected>
[13:33:44.959] Conditions captured: <none>
[13:33:44.959] Early signaling: FALSE
[13:33:44.959] Owner process: b6e93464-7fc2-3f8d-23d1-d8004201d1f1
[13:33:44.959] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:44.970] Chunk #2 of 2 ... DONE
[13:33:44.970] Launching 2 futures (chunks) ... DONE
[13:33:44.970] Resolving 2 futures (chunks) ...
[13:33:44.970] resolve() on list ...
[13:33:44.970]  recursive: 0
[13:33:44.971]  length: 2
[13:33:44.971] 
[13:33:44.971] Future #1
[13:33:44.971] result() for MulticoreFuture ...
[13:33:44.972] result() for MulticoreFuture ...
[13:33:44.972] result() for MulticoreFuture ... done
[13:33:44.972] result() for MulticoreFuture ... done
[13:33:44.973] result() for MulticoreFuture ...
[13:33:44.973] result() for MulticoreFuture ... done
[13:33:44.973] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:33:44.973] - nx: 2
[13:33:44.973] - relay: TRUE
[13:33:44.973] - stdout: TRUE
[13:33:44.973] - signal: TRUE
[13:33:44.973] - resignal: FALSE
[13:33:44.974] - force: TRUE
[13:33:44.974] - relayed: [n=2] FALSE, FALSE
[13:33:44.974] - queued futures: [n=2] FALSE, FALSE
[13:33:44.974]  - until=1
[13:33:44.974]  - relaying element #1
[13:33:44.974] result() for MulticoreFuture ...
[13:33:44.975] result() for MulticoreFuture ... done
[13:33:44.975] result() for MulticoreFuture ...
[13:33:44.975] result() for MulticoreFuture ... done
[13:33:44.975] result() for MulticoreFuture ...
[13:33:44.975] result() for MulticoreFuture ... done
[13:33:44.976] result() for MulticoreFuture ...
[13:33:44.976] result() for MulticoreFuture ... done
[13:33:44.976] - relayed: [n=2] TRUE, FALSE
[13:33:44.976] - queued futures: [n=2] TRUE, FALSE
[13:33:44.976] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:33:44.976]  length: 1 (resolved future 1)
[13:33:44.977] Future #2
[13:33:44.977] result() for MulticoreFuture ...
[13:33:44.978] result() for MulticoreFuture ...
[13:33:44.978] result() for MulticoreFuture ... done
[13:33:44.978] result() for MulticoreFuture ... done
[13:33:44.978] result() for MulticoreFuture ...
[13:33:44.978] result() for MulticoreFuture ... done
[13:33:44.979] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:33:44.979] - nx: 2
[13:33:44.979] - relay: TRUE
[13:33:44.979] - stdout: TRUE
[13:33:44.979] - signal: TRUE
[13:33:44.980] - resignal: FALSE
[13:33:44.980] - force: TRUE
[13:33:44.980] - relayed: [n=2] TRUE, FALSE
[13:33:44.980] - queued futures: [n=2] TRUE, FALSE
[13:33:44.980]  - until=2
[13:33:44.980]  - relaying element #2
[13:33:44.980] result() for MulticoreFuture ...
[13:33:44.980] result() for MulticoreFuture ... done
[13:33:44.980] result() for MulticoreFuture ...
[13:33:44.981] result() for MulticoreFuture ... done
[13:33:44.983] result() for MulticoreFuture ...
[13:33:44.984] result() for MulticoreFuture ... done
[13:33:44.984] result() for MulticoreFuture ...
[13:33:44.984] result() for MulticoreFuture ... done
[13:33:44.984] - relayed: [n=2] TRUE, TRUE
[13:33:44.984] - queued futures: [n=2] TRUE, TRUE
[13:33:44.984] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:33:44.984]  length: 0 (resolved future 2)
[13:33:44.984] Relaying remaining futures
[13:33:44.985] signalConditionsASAP(NULL, pos=0) ...
[13:33:44.985] - nx: 2
[13:33:44.985] - relay: TRUE
[13:33:44.985] - stdout: TRUE
[13:33:44.985] - signal: TRUE
[13:33:44.985] - resignal: FALSE
[13:33:44.985] - force: TRUE
[13:33:44.986] - relayed: [n=2] TRUE, TRUE
[13:33:44.986] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:44.986] - relayed: [n=2] TRUE, TRUE
[13:33:44.986] - queued futures: [n=2] TRUE, TRUE
[13:33:44.986] signalConditionsASAP(NULL, pos=0) ... done
[13:33:44.986] resolve() on list ... DONE
[13:33:44.986] result() for MulticoreFuture ...
[13:33:44.987] result() for MulticoreFuture ... done
[13:33:44.987] result() for MulticoreFuture ...
[13:33:44.987] result() for MulticoreFuture ... done
[13:33:44.987] result() for MulticoreFuture ...
[13:33:44.987] result() for MulticoreFuture ... done
[13:33:44.987] result() for MulticoreFuture ...
[13:33:44.987] result() for MulticoreFuture ... done
[13:33:44.988]  - Number of value chunks collected: 2
[13:33:44.988] Resolving 2 futures (chunks) ... DONE
[13:33:44.988] Reducing values from 2 chunks ...
[13:33:44.988]  - Number of values collected after concatenation: 3
[13:33:44.988]  - Number of values expected: 3
[13:33:44.988] Reducing values from 2 chunks ... DONE
[13:33:44.988] future_lapply() ... DONE
[13:33:44.989] plan(): Setting new future strategy stack:
[13:33:44.989] List of future strategies:
[13:33:44.989] 1. sequential:
[13:33:44.989]    - args: function (..., envir = parent.frame())
[13:33:44.989]    - tweaked: FALSE
[13:33:44.989]    - call: plan(sequential)
[13:33:44.989] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[13:33:44.990] plan(): Setting new future strategy stack:
[13:33:44.990] List of future strategies:
[13:33:44.990] 1. multisession:
[13:33:44.990]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:33:44.990]    - tweaked: FALSE
[13:33:44.990]    - call: plan(strategy)
[13:33:44.990] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:33:44.991] multisession:
[13:33:44.991] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:33:44.991] - tweaked: FALSE
[13:33:44.991] - call: plan(strategy)
[13:33:44.997] getGlobalsAndPackages() ...
[13:33:44.997] Not searching for globals
[13:33:44.997] - globals: [0] <none>
[13:33:44.998] getGlobalsAndPackages() ... DONE
[13:33:44.998] [local output] makeClusterPSOCK() ...
[13:33:45.042] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:33:45.044] [local output] Base port: 11145
[13:33:45.044] [local output] Getting setup options for 2 cluster nodes ...
[13:33:45.044] [local output]  - Node 1 of 2 ...
[13:33:45.044] [local output] localMachine=TRUE => revtunnel=FALSE

[13:33:45.045] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpC9rl05/worker.rank=1.parallelly.parent=69590.10fd67867c58f.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpC9rl05/worker.rank=1.parallelly.parent=69590.10fd67867c58f.pid")'’
[13:33:45.234] - Possible to infer worker's PID: TRUE
[13:33:45.234] [local output] Rscript port: 11145

[13:33:45.235] [local output]  - Node 2 of 2 ...
[13:33:45.235] [local output] localMachine=TRUE => revtunnel=FALSE

[13:33:45.236] [local output] Rscript port: 11145

[13:33:45.236] [local output] Getting setup options for 2 cluster nodes ... done
[13:33:45.236] [local output]  - Parallel setup requested for some PSOCK nodes
[13:33:45.237] [local output] Setting up PSOCK nodes in parallel
[13:33:45.237] List of 36
[13:33:45.237]  $ worker          : chr "localhost"
[13:33:45.237]   ..- attr(*, "localhost")= logi TRUE
[13:33:45.237]  $ master          : chr "localhost"
[13:33:45.237]  $ port            : int 11145
[13:33:45.237]  $ connectTimeout  : num 120
[13:33:45.237]  $ timeout         : num 2592000
[13:33:45.237]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:33:45.237]  $ homogeneous     : logi TRUE
[13:33:45.237]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:33:45.237]  $ rscript_envs    : NULL
[13:33:45.237]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:33:45.237]  $ rscript_startup : NULL
[13:33:45.237]  $ rscript_sh      : chr "sh"
[13:33:45.237]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:33:45.237]  $ methods         : logi TRUE
[13:33:45.237]  $ socketOptions   : chr "no-delay"
[13:33:45.237]  $ useXDR          : logi FALSE
[13:33:45.237]  $ outfile         : chr "/dev/null"
[13:33:45.237]  $ renice          : int NA
[13:33:45.237]  $ rshcmd          : NULL
[13:33:45.237]  $ user            : chr(0) 
[13:33:45.237]  $ revtunnel       : logi FALSE
[13:33:45.237]  $ rshlogfile      : NULL
[13:33:45.237]  $ rshopts         : chr(0) 
[13:33:45.237]  $ rank            : int 1
[13:33:45.237]  $ manual          : logi FALSE
[13:33:45.237]  $ dryrun          : logi FALSE
[13:33:45.237]  $ quiet           : logi FALSE
[13:33:45.237]  $ setup_strategy  : chr "parallel"
[13:33:45.237]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:33:45.237]  $ pidfile         : chr "/tmp/RtmpC9rl05/worker.rank=1.parallelly.parent=69590.10fd67867c58f.pid"
[13:33:45.237]  $ rshcmd_label    : NULL
[13:33:45.237]  $ rsh_call        : NULL
[13:33:45.237]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:33:45.237]  $ localMachine    : logi TRUE
[13:33:45.237]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:33:45.237]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:33:45.237]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:33:45.237]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:33:45.237]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:33:45.237]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:33:45.237]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:33:45.237]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:33:45.237]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:33:45.237]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:33:45.237]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:33:45.237]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:33:45.237]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:33:45.237]  $ arguments       :List of 28
[13:33:45.237]   ..$ worker          : chr "localhost"
[13:33:45.237]   ..$ master          : NULL
[13:33:45.237]   ..$ port            : int 11145
[13:33:45.237]   ..$ connectTimeout  : num 120
[13:33:45.237]   ..$ timeout         : num 2592000
[13:33:45.237]   ..$ rscript         : NULL
[13:33:45.237]   ..$ homogeneous     : NULL
[13:33:45.237]   ..$ rscript_args    : NULL
[13:33:45.237]   ..$ rscript_envs    : NULL
[13:33:45.237]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:33:45.237]   ..$ rscript_startup : NULL
[13:33:45.237]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:33:45.237]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:33:45.237]   ..$ methods         : logi TRUE
[13:33:45.237]   ..$ socketOptions   : chr "no-delay"
[13:33:45.237]   ..$ useXDR          : logi FALSE
[13:33:45.237]   ..$ outfile         : chr "/dev/null"
[13:33:45.237]   ..$ renice          : int NA
[13:33:45.237]   ..$ rshcmd          : NULL
[13:33:45.237]   ..$ user            : NULL
[13:33:45.237]   ..$ revtunnel       : logi NA
[13:33:45.237]   ..$ rshlogfile      : NULL
[13:33:45.237]   ..$ rshopts         : NULL
[13:33:45.237]   ..$ rank            : int 1
[13:33:45.237]   ..$ manual          : logi FALSE
[13:33:45.237]   ..$ dryrun          : logi FALSE
[13:33:45.237]   ..$ quiet           : logi FALSE
[13:33:45.237]   ..$ setup_strategy  : chr "parallel"
[13:33:45.237]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:33:45.254] [local output] System call to launch all workers:
[13:33:45.254] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpC9rl05/worker.rank=1.parallelly.parent=69590.10fd67867c58f.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11145 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:33:45.254] [local output] Starting PSOCK main server
[13:33:45.260] [local output] Workers launched
[13:33:45.260] [local output] Waiting for workers to connect back
[13:33:45.260]  - [local output] 0 workers out of 2 ready
[13:33:45.500]  - [local output] 0 workers out of 2 ready
[13:33:45.500]  - [local output] 1 workers out of 2 ready
[13:33:45.503]  - [local output] 1 workers out of 2 ready
[13:33:45.504]  - [local output] 2 workers out of 2 ready
[13:33:45.504] [local output] Launching of workers completed
[13:33:45.504] [local output] Collecting session information from workers
[13:33:45.505] [local output]  - Worker #1 of 2
[13:33:45.505] [local output]  - Worker #2 of 2
[13:33:45.506] [local output] makeClusterPSOCK() ... done
[13:33:45.517] Packages needed by the future expression (n = 0): <none>
[13:33:45.517] Packages needed by future strategies (n = 0): <none>
[13:33:45.518] {
[13:33:45.518]     {
[13:33:45.518]         {
[13:33:45.518]             ...future.startTime <- base::Sys.time()
[13:33:45.518]             {
[13:33:45.518]                 {
[13:33:45.518]                   {
[13:33:45.518]                     {
[13:33:45.518]                       base::local({
[13:33:45.518]                         has_future <- base::requireNamespace("future", 
[13:33:45.518]                           quietly = TRUE)
[13:33:45.518]                         if (has_future) {
[13:33:45.518]                           ns <- base::getNamespace("future")
[13:33:45.518]                           version <- ns[[".package"]][["version"]]
[13:33:45.518]                           if (is.null(version)) 
[13:33:45.518]                             version <- utils::packageVersion("future")
[13:33:45.518]                         }
[13:33:45.518]                         else {
[13:33:45.518]                           version <- NULL
[13:33:45.518]                         }
[13:33:45.518]                         if (!has_future || version < "1.8.0") {
[13:33:45.518]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:45.518]                             "", base::R.version$version.string), 
[13:33:45.518]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:45.518]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:45.518]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:45.518]                               "release", "version")], collapse = " "), 
[13:33:45.518]                             hostname = base::Sys.info()[["nodename"]])
[13:33:45.518]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:45.518]                             info)
[13:33:45.518]                           info <- base::paste(info, collapse = "; ")
[13:33:45.518]                           if (!has_future) {
[13:33:45.518]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:45.518]                               info)
[13:33:45.518]                           }
[13:33:45.518]                           else {
[13:33:45.518]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:45.518]                               info, version)
[13:33:45.518]                           }
[13:33:45.518]                           base::stop(msg)
[13:33:45.518]                         }
[13:33:45.518]                       })
[13:33:45.518]                     }
[13:33:45.518]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:45.518]                     base::options(mc.cores = 1L)
[13:33:45.518]                   }
[13:33:45.518]                   ...future.strategy.old <- future::plan("list")
[13:33:45.518]                   options(future.plan = NULL)
[13:33:45.518]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:45.518]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:45.518]                 }
[13:33:45.518]                 ...future.workdir <- getwd()
[13:33:45.518]             }
[13:33:45.518]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:45.518]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:45.518]         }
[13:33:45.518]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:45.518]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:33:45.518]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:45.518]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:45.518]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:45.518]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:45.518]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:45.518]             base::names(...future.oldOptions))
[13:33:45.518]     }
[13:33:45.518]     if (FALSE) {
[13:33:45.518]     }
[13:33:45.518]     else {
[13:33:45.518]         if (TRUE) {
[13:33:45.518]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:45.518]                 open = "w")
[13:33:45.518]         }
[13:33:45.518]         else {
[13:33:45.518]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:45.518]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:45.518]         }
[13:33:45.518]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:45.518]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:45.518]             base::sink(type = "output", split = FALSE)
[13:33:45.518]             base::close(...future.stdout)
[13:33:45.518]         }, add = TRUE)
[13:33:45.518]     }
[13:33:45.518]     ...future.frame <- base::sys.nframe()
[13:33:45.518]     ...future.conditions <- base::list()
[13:33:45.518]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:45.518]     if (FALSE) {
[13:33:45.518]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:45.518]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:45.518]     }
[13:33:45.518]     ...future.result <- base::tryCatch({
[13:33:45.518]         base::withCallingHandlers({
[13:33:45.518]             ...future.value <- base::withVisible(base::local({
[13:33:45.518]                 ...future.makeSendCondition <- base::local({
[13:33:45.518]                   sendCondition <- NULL
[13:33:45.518]                   function(frame = 1L) {
[13:33:45.518]                     if (is.function(sendCondition)) 
[13:33:45.518]                       return(sendCondition)
[13:33:45.518]                     ns <- getNamespace("parallel")
[13:33:45.518]                     if (exists("sendData", mode = "function", 
[13:33:45.518]                       envir = ns)) {
[13:33:45.518]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:45.518]                         envir = ns)
[13:33:45.518]                       envir <- sys.frame(frame)
[13:33:45.518]                       master <- NULL
[13:33:45.518]                       while (!identical(envir, .GlobalEnv) && 
[13:33:45.518]                         !identical(envir, emptyenv())) {
[13:33:45.518]                         if (exists("master", mode = "list", envir = envir, 
[13:33:45.518]                           inherits = FALSE)) {
[13:33:45.518]                           master <- get("master", mode = "list", 
[13:33:45.518]                             envir = envir, inherits = FALSE)
[13:33:45.518]                           if (inherits(master, c("SOCKnode", 
[13:33:45.518]                             "SOCK0node"))) {
[13:33:45.518]                             sendCondition <<- function(cond) {
[13:33:45.518]                               data <- list(type = "VALUE", value = cond, 
[13:33:45.518]                                 success = TRUE)
[13:33:45.518]                               parallel_sendData(master, data)
[13:33:45.518]                             }
[13:33:45.518]                             return(sendCondition)
[13:33:45.518]                           }
[13:33:45.518]                         }
[13:33:45.518]                         frame <- frame + 1L
[13:33:45.518]                         envir <- sys.frame(frame)
[13:33:45.518]                       }
[13:33:45.518]                     }
[13:33:45.518]                     sendCondition <<- function(cond) NULL
[13:33:45.518]                   }
[13:33:45.518]                 })
[13:33:45.518]                 withCallingHandlers({
[13:33:45.518]                   NA
[13:33:45.518]                 }, immediateCondition = function(cond) {
[13:33:45.518]                   sendCondition <- ...future.makeSendCondition()
[13:33:45.518]                   sendCondition(cond)
[13:33:45.518]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:45.518]                   {
[13:33:45.518]                     inherits <- base::inherits
[13:33:45.518]                     invokeRestart <- base::invokeRestart
[13:33:45.518]                     is.null <- base::is.null
[13:33:45.518]                     muffled <- FALSE
[13:33:45.518]                     if (inherits(cond, "message")) {
[13:33:45.518]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:45.518]                       if (muffled) 
[13:33:45.518]                         invokeRestart("muffleMessage")
[13:33:45.518]                     }
[13:33:45.518]                     else if (inherits(cond, "warning")) {
[13:33:45.518]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:45.518]                       if (muffled) 
[13:33:45.518]                         invokeRestart("muffleWarning")
[13:33:45.518]                     }
[13:33:45.518]                     else if (inherits(cond, "condition")) {
[13:33:45.518]                       if (!is.null(pattern)) {
[13:33:45.518]                         computeRestarts <- base::computeRestarts
[13:33:45.518]                         grepl <- base::grepl
[13:33:45.518]                         restarts <- computeRestarts(cond)
[13:33:45.518]                         for (restart in restarts) {
[13:33:45.518]                           name <- restart$name
[13:33:45.518]                           if (is.null(name)) 
[13:33:45.518]                             next
[13:33:45.518]                           if (!grepl(pattern, name)) 
[13:33:45.518]                             next
[13:33:45.518]                           invokeRestart(restart)
[13:33:45.518]                           muffled <- TRUE
[13:33:45.518]                           break
[13:33:45.518]                         }
[13:33:45.518]                       }
[13:33:45.518]                     }
[13:33:45.518]                     invisible(muffled)
[13:33:45.518]                   }
[13:33:45.518]                   muffleCondition(cond)
[13:33:45.518]                 })
[13:33:45.518]             }))
[13:33:45.518]             future::FutureResult(value = ...future.value$value, 
[13:33:45.518]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:45.518]                   ...future.rng), globalenv = if (FALSE) 
[13:33:45.518]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:45.518]                     ...future.globalenv.names))
[13:33:45.518]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:45.518]         }, condition = base::local({
[13:33:45.518]             c <- base::c
[13:33:45.518]             inherits <- base::inherits
[13:33:45.518]             invokeRestart <- base::invokeRestart
[13:33:45.518]             length <- base::length
[13:33:45.518]             list <- base::list
[13:33:45.518]             seq.int <- base::seq.int
[13:33:45.518]             signalCondition <- base::signalCondition
[13:33:45.518]             sys.calls <- base::sys.calls
[13:33:45.518]             `[[` <- base::`[[`
[13:33:45.518]             `+` <- base::`+`
[13:33:45.518]             `<<-` <- base::`<<-`
[13:33:45.518]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:45.518]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:45.518]                   3L)]
[13:33:45.518]             }
[13:33:45.518]             function(cond) {
[13:33:45.518]                 is_error <- inherits(cond, "error")
[13:33:45.518]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:45.518]                   NULL)
[13:33:45.518]                 if (is_error) {
[13:33:45.518]                   sessionInformation <- function() {
[13:33:45.518]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:45.518]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:45.518]                       search = base::search(), system = base::Sys.info())
[13:33:45.518]                   }
[13:33:45.518]                   ...future.conditions[[length(...future.conditions) + 
[13:33:45.518]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:45.518]                     cond$call), session = sessionInformation(), 
[13:33:45.518]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:45.518]                   signalCondition(cond)
[13:33:45.518]                 }
[13:33:45.518]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:45.518]                 "immediateCondition"))) {
[13:33:45.518]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:45.518]                   ...future.conditions[[length(...future.conditions) + 
[13:33:45.518]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:45.518]                   if (TRUE && !signal) {
[13:33:45.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:45.518]                     {
[13:33:45.518]                       inherits <- base::inherits
[13:33:45.518]                       invokeRestart <- base::invokeRestart
[13:33:45.518]                       is.null <- base::is.null
[13:33:45.518]                       muffled <- FALSE
[13:33:45.518]                       if (inherits(cond, "message")) {
[13:33:45.518]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:45.518]                         if (muffled) 
[13:33:45.518]                           invokeRestart("muffleMessage")
[13:33:45.518]                       }
[13:33:45.518]                       else if (inherits(cond, "warning")) {
[13:33:45.518]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:45.518]                         if (muffled) 
[13:33:45.518]                           invokeRestart("muffleWarning")
[13:33:45.518]                       }
[13:33:45.518]                       else if (inherits(cond, "condition")) {
[13:33:45.518]                         if (!is.null(pattern)) {
[13:33:45.518]                           computeRestarts <- base::computeRestarts
[13:33:45.518]                           grepl <- base::grepl
[13:33:45.518]                           restarts <- computeRestarts(cond)
[13:33:45.518]                           for (restart in restarts) {
[13:33:45.518]                             name <- restart$name
[13:33:45.518]                             if (is.null(name)) 
[13:33:45.518]                               next
[13:33:45.518]                             if (!grepl(pattern, name)) 
[13:33:45.518]                               next
[13:33:45.518]                             invokeRestart(restart)
[13:33:45.518]                             muffled <- TRUE
[13:33:45.518]                             break
[13:33:45.518]                           }
[13:33:45.518]                         }
[13:33:45.518]                       }
[13:33:45.518]                       invisible(muffled)
[13:33:45.518]                     }
[13:33:45.518]                     muffleCondition(cond, pattern = "^muffle")
[13:33:45.518]                   }
[13:33:45.518]                 }
[13:33:45.518]                 else {
[13:33:45.518]                   if (TRUE) {
[13:33:45.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:45.518]                     {
[13:33:45.518]                       inherits <- base::inherits
[13:33:45.518]                       invokeRestart <- base::invokeRestart
[13:33:45.518]                       is.null <- base::is.null
[13:33:45.518]                       muffled <- FALSE
[13:33:45.518]                       if (inherits(cond, "message")) {
[13:33:45.518]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:45.518]                         if (muffled) 
[13:33:45.518]                           invokeRestart("muffleMessage")
[13:33:45.518]                       }
[13:33:45.518]                       else if (inherits(cond, "warning")) {
[13:33:45.518]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:45.518]                         if (muffled) 
[13:33:45.518]                           invokeRestart("muffleWarning")
[13:33:45.518]                       }
[13:33:45.518]                       else if (inherits(cond, "condition")) {
[13:33:45.518]                         if (!is.null(pattern)) {
[13:33:45.518]                           computeRestarts <- base::computeRestarts
[13:33:45.518]                           grepl <- base::grepl
[13:33:45.518]                           restarts <- computeRestarts(cond)
[13:33:45.518]                           for (restart in restarts) {
[13:33:45.518]                             name <- restart$name
[13:33:45.518]                             if (is.null(name)) 
[13:33:45.518]                               next
[13:33:45.518]                             if (!grepl(pattern, name)) 
[13:33:45.518]                               next
[13:33:45.518]                             invokeRestart(restart)
[13:33:45.518]                             muffled <- TRUE
[13:33:45.518]                             break
[13:33:45.518]                           }
[13:33:45.518]                         }
[13:33:45.518]                       }
[13:33:45.518]                       invisible(muffled)
[13:33:45.518]                     }
[13:33:45.518]                     muffleCondition(cond, pattern = "^muffle")
[13:33:45.518]                   }
[13:33:45.518]                 }
[13:33:45.518]             }
[13:33:45.518]         }))
[13:33:45.518]     }, error = function(ex) {
[13:33:45.518]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:45.518]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:45.518]                 ...future.rng), started = ...future.startTime, 
[13:33:45.518]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:45.518]             version = "1.8"), class = "FutureResult")
[13:33:45.518]     }, finally = {
[13:33:45.518]         if (!identical(...future.workdir, getwd())) 
[13:33:45.518]             setwd(...future.workdir)
[13:33:45.518]         {
[13:33:45.518]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:45.518]                 ...future.oldOptions$nwarnings <- NULL
[13:33:45.518]             }
[13:33:45.518]             base::options(...future.oldOptions)
[13:33:45.518]             if (.Platform$OS.type == "windows") {
[13:33:45.518]                 old_names <- names(...future.oldEnvVars)
[13:33:45.518]                 envs <- base::Sys.getenv()
[13:33:45.518]                 names <- names(envs)
[13:33:45.518]                 common <- intersect(names, old_names)
[13:33:45.518]                 added <- setdiff(names, old_names)
[13:33:45.518]                 removed <- setdiff(old_names, names)
[13:33:45.518]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:45.518]                   envs[common]]
[13:33:45.518]                 NAMES <- toupper(changed)
[13:33:45.518]                 args <- list()
[13:33:45.518]                 for (kk in seq_along(NAMES)) {
[13:33:45.518]                   name <- changed[[kk]]
[13:33:45.518]                   NAME <- NAMES[[kk]]
[13:33:45.518]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:45.518]                     next
[13:33:45.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:45.518]                 }
[13:33:45.518]                 NAMES <- toupper(added)
[13:33:45.518]                 for (kk in seq_along(NAMES)) {
[13:33:45.518]                   name <- added[[kk]]
[13:33:45.518]                   NAME <- NAMES[[kk]]
[13:33:45.518]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:45.518]                     next
[13:33:45.518]                   args[[name]] <- ""
[13:33:45.518]                 }
[13:33:45.518]                 NAMES <- toupper(removed)
[13:33:45.518]                 for (kk in seq_along(NAMES)) {
[13:33:45.518]                   name <- removed[[kk]]
[13:33:45.518]                   NAME <- NAMES[[kk]]
[13:33:45.518]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:45.518]                     next
[13:33:45.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:45.518]                 }
[13:33:45.518]                 if (length(args) > 0) 
[13:33:45.518]                   base::do.call(base::Sys.setenv, args = args)
[13:33:45.518]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:45.518]             }
[13:33:45.518]             else {
[13:33:45.518]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:45.518]             }
[13:33:45.518]             {
[13:33:45.518]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:45.518]                   0L) {
[13:33:45.518]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:45.518]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:45.518]                   base::options(opts)
[13:33:45.518]                 }
[13:33:45.518]                 {
[13:33:45.518]                   {
[13:33:45.518]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:45.518]                     NULL
[13:33:45.518]                   }
[13:33:45.518]                   options(future.plan = NULL)
[13:33:45.518]                   if (is.na(NA_character_)) 
[13:33:45.518]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:45.518]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:45.518]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:45.518]                     .init = FALSE)
[13:33:45.518]                 }
[13:33:45.518]             }
[13:33:45.518]         }
[13:33:45.518]     })
[13:33:45.518]     if (TRUE) {
[13:33:45.518]         base::sink(type = "output", split = FALSE)
[13:33:45.518]         if (TRUE) {
[13:33:45.518]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:45.518]         }
[13:33:45.518]         else {
[13:33:45.518]             ...future.result["stdout"] <- base::list(NULL)
[13:33:45.518]         }
[13:33:45.518]         base::close(...future.stdout)
[13:33:45.518]         ...future.stdout <- NULL
[13:33:45.518]     }
[13:33:45.518]     ...future.result$conditions <- ...future.conditions
[13:33:45.518]     ...future.result$finished <- base::Sys.time()
[13:33:45.518]     ...future.result
[13:33:45.518] }
[13:33:45.571] MultisessionFuture started
[13:33:45.571] result() for ClusterFuture ...
[13:33:45.572] receiveMessageFromWorker() for ClusterFuture ...
[13:33:45.572] - Validating connection of MultisessionFuture
[13:33:45.605] - received message: FutureResult
[13:33:45.605] - Received FutureResult
[13:33:45.605] - Erased future from FutureRegistry
[13:33:45.606] result() for ClusterFuture ...
[13:33:45.606] - result already collected: FutureResult
[13:33:45.606] result() for ClusterFuture ... done
[13:33:45.606] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:45.606] result() for ClusterFuture ... done
[13:33:45.606] result() for ClusterFuture ...
[13:33:45.606] - result already collected: FutureResult
[13:33:45.606] result() for ClusterFuture ... done
[13:33:45.607] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:33:45.611] plan(): nbrOfWorkers() = 2
[13:33:45.611] future_lapply() ...
[13:33:45.615] Number of chunks: 2
[13:33:45.616] getGlobalsAndPackagesXApply() ...
[13:33:45.616]  - future.globals: TRUE
[13:33:45.616] getGlobalsAndPackages() ...
[13:33:45.616] Searching for globals...
[13:33:45.618] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:45.618] Searching for globals ... DONE
[13:33:45.618] Resolving globals: FALSE
[13:33:45.618] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[13:33:45.619] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[13:33:45.619] - globals: [1] ‘FUN’
[13:33:45.619] 
[13:33:45.619] getGlobalsAndPackages() ... DONE
[13:33:45.619]  - globals found/used: [n=1] ‘FUN’
[13:33:45.619]  - needed namespaces: [n=0] 
[13:33:45.620] Finding globals ... DONE
[13:33:45.620]  - use_args: TRUE
[13:33:45.620]  - Getting '...' globals ...
[13:33:45.620] resolve() on list ...
[13:33:45.620]  recursive: 0
[13:33:45.620]  length: 1
[13:33:45.621]  elements: ‘...’
[13:33:45.621]  length: 0 (resolved future 1)
[13:33:45.621] resolve() on list ... DONE
[13:33:45.621]    - '...' content: [n=0] 
[13:33:45.621] List of 1
[13:33:45.621]  $ ...: list()
[13:33:45.621]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:45.621]  - attr(*, "where")=List of 1
[13:33:45.621]   ..$ ...:<environment: 0x55984718b018> 
[13:33:45.621]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:45.621]  - attr(*, "resolved")= logi TRUE
[13:33:45.621]  - attr(*, "total_size")= num NA
[13:33:45.624]  - Getting '...' globals ... DONE
[13:33:45.625] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:45.625] List of 2
[13:33:45.625]  $ ...future.FUN:function (x, ...)  
[13:33:45.625]  $ ...          : list()
[13:33:45.625]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:45.625]  - attr(*, "where")=List of 2
[13:33:45.625]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:45.625]   ..$ ...          :<environment: 0x55984718b018> 
[13:33:45.625]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:45.625]  - attr(*, "resolved")= logi FALSE
[13:33:45.625]  - attr(*, "total_size")= num 1240
[13:33:45.628] Packages to be attached in all futures: [n=0] 
[13:33:45.628] getGlobalsAndPackagesXApply() ... DONE
[13:33:45.628] Number of futures (= number of chunks): 2
[13:33:45.629] Launching 2 futures (chunks) ...
[13:33:45.629] Chunk #1 of 2 ...
[13:33:45.629]  - Finding globals in 'X' for chunk #1 ...
[13:33:45.629] getGlobalsAndPackages() ...
[13:33:45.629] Searching for globals...
[13:33:45.629] 
[13:33:45.630] Searching for globals ... DONE
[13:33:45.630] - globals: [0] <none>
[13:33:45.630] getGlobalsAndPackages() ... DONE
[13:33:45.630]    + additional globals found: [n=0] 
[13:33:45.630]    + additional namespaces needed: [n=0] 
[13:33:45.630]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:45.630]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:45.630]  - seeds: <none>
[13:33:45.631]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:45.631] getGlobalsAndPackages() ...
[13:33:45.631] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:45.631] Resolving globals: FALSE
[13:33:45.631] Tweak future expression to call with '...' arguments ...
[13:33:45.631] {
[13:33:45.631]     do.call(function(...) {
[13:33:45.631]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:45.631]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:45.631]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:45.631]             on.exit(options(oopts), add = TRUE)
[13:33:45.631]         }
[13:33:45.631]         {
[13:33:45.631]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:45.631]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:45.631]                 ...future.FUN(...future.X_jj, ...)
[13:33:45.631]             })
[13:33:45.631]         }
[13:33:45.631]     }, args = future.call.arguments)
[13:33:45.631] }
[13:33:45.631] Tweak future expression to call with '...' arguments ... DONE
[13:33:45.632] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:45.632] 
[13:33:45.632] getGlobalsAndPackages() ... DONE
[13:33:45.632] run() for ‘Future’ ...
[13:33:45.633] - state: ‘created’
[13:33:45.633] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:45.647] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:45.647] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:45.648]   - Field: ‘node’
[13:33:45.648]   - Field: ‘label’
[13:33:45.648]   - Field: ‘local’
[13:33:45.648]   - Field: ‘owner’
[13:33:45.648]   - Field: ‘envir’
[13:33:45.648]   - Field: ‘workers’
[13:33:45.648]   - Field: ‘packages’
[13:33:45.648]   - Field: ‘gc’
[13:33:45.648]   - Field: ‘conditions’
[13:33:45.648]   - Field: ‘persistent’
[13:33:45.649]   - Field: ‘expr’
[13:33:45.649]   - Field: ‘uuid’
[13:33:45.649]   - Field: ‘seed’
[13:33:45.649]   - Field: ‘version’
[13:33:45.649]   - Field: ‘result’
[13:33:45.649]   - Field: ‘asynchronous’
[13:33:45.649]   - Field: ‘calls’
[13:33:45.649]   - Field: ‘globals’
[13:33:45.649]   - Field: ‘stdout’
[13:33:45.650]   - Field: ‘earlySignal’
[13:33:45.650]   - Field: ‘lazy’
[13:33:45.650]   - Field: ‘state’
[13:33:45.650] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:45.650] - Launch lazy future ...
[13:33:45.650] Packages needed by the future expression (n = 0): <none>
[13:33:45.651] Packages needed by future strategies (n = 0): <none>
[13:33:45.651] {
[13:33:45.651]     {
[13:33:45.651]         {
[13:33:45.651]             ...future.startTime <- base::Sys.time()
[13:33:45.651]             {
[13:33:45.651]                 {
[13:33:45.651]                   {
[13:33:45.651]                     {
[13:33:45.651]                       base::local({
[13:33:45.651]                         has_future <- base::requireNamespace("future", 
[13:33:45.651]                           quietly = TRUE)
[13:33:45.651]                         if (has_future) {
[13:33:45.651]                           ns <- base::getNamespace("future")
[13:33:45.651]                           version <- ns[[".package"]][["version"]]
[13:33:45.651]                           if (is.null(version)) 
[13:33:45.651]                             version <- utils::packageVersion("future")
[13:33:45.651]                         }
[13:33:45.651]                         else {
[13:33:45.651]                           version <- NULL
[13:33:45.651]                         }
[13:33:45.651]                         if (!has_future || version < "1.8.0") {
[13:33:45.651]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:45.651]                             "", base::R.version$version.string), 
[13:33:45.651]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:45.651]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:45.651]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:45.651]                               "release", "version")], collapse = " "), 
[13:33:45.651]                             hostname = base::Sys.info()[["nodename"]])
[13:33:45.651]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:45.651]                             info)
[13:33:45.651]                           info <- base::paste(info, collapse = "; ")
[13:33:45.651]                           if (!has_future) {
[13:33:45.651]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:45.651]                               info)
[13:33:45.651]                           }
[13:33:45.651]                           else {
[13:33:45.651]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:45.651]                               info, version)
[13:33:45.651]                           }
[13:33:45.651]                           base::stop(msg)
[13:33:45.651]                         }
[13:33:45.651]                       })
[13:33:45.651]                     }
[13:33:45.651]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:45.651]                     base::options(mc.cores = 1L)
[13:33:45.651]                   }
[13:33:45.651]                   ...future.strategy.old <- future::plan("list")
[13:33:45.651]                   options(future.plan = NULL)
[13:33:45.651]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:45.651]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:45.651]                 }
[13:33:45.651]                 ...future.workdir <- getwd()
[13:33:45.651]             }
[13:33:45.651]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:45.651]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:45.651]         }
[13:33:45.651]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:45.651]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:45.651]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:45.651]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:45.651]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:45.651]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:45.651]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:45.651]             base::names(...future.oldOptions))
[13:33:45.651]     }
[13:33:45.651]     if (FALSE) {
[13:33:45.651]     }
[13:33:45.651]     else {
[13:33:45.651]         if (TRUE) {
[13:33:45.651]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:45.651]                 open = "w")
[13:33:45.651]         }
[13:33:45.651]         else {
[13:33:45.651]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:45.651]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:45.651]         }
[13:33:45.651]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:45.651]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:45.651]             base::sink(type = "output", split = FALSE)
[13:33:45.651]             base::close(...future.stdout)
[13:33:45.651]         }, add = TRUE)
[13:33:45.651]     }
[13:33:45.651]     ...future.frame <- base::sys.nframe()
[13:33:45.651]     ...future.conditions <- base::list()
[13:33:45.651]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:45.651]     if (FALSE) {
[13:33:45.651]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:45.651]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:45.651]     }
[13:33:45.651]     ...future.result <- base::tryCatch({
[13:33:45.651]         base::withCallingHandlers({
[13:33:45.651]             ...future.value <- base::withVisible(base::local({
[13:33:45.651]                 ...future.makeSendCondition <- base::local({
[13:33:45.651]                   sendCondition <- NULL
[13:33:45.651]                   function(frame = 1L) {
[13:33:45.651]                     if (is.function(sendCondition)) 
[13:33:45.651]                       return(sendCondition)
[13:33:45.651]                     ns <- getNamespace("parallel")
[13:33:45.651]                     if (exists("sendData", mode = "function", 
[13:33:45.651]                       envir = ns)) {
[13:33:45.651]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:45.651]                         envir = ns)
[13:33:45.651]                       envir <- sys.frame(frame)
[13:33:45.651]                       master <- NULL
[13:33:45.651]                       while (!identical(envir, .GlobalEnv) && 
[13:33:45.651]                         !identical(envir, emptyenv())) {
[13:33:45.651]                         if (exists("master", mode = "list", envir = envir, 
[13:33:45.651]                           inherits = FALSE)) {
[13:33:45.651]                           master <- get("master", mode = "list", 
[13:33:45.651]                             envir = envir, inherits = FALSE)
[13:33:45.651]                           if (inherits(master, c("SOCKnode", 
[13:33:45.651]                             "SOCK0node"))) {
[13:33:45.651]                             sendCondition <<- function(cond) {
[13:33:45.651]                               data <- list(type = "VALUE", value = cond, 
[13:33:45.651]                                 success = TRUE)
[13:33:45.651]                               parallel_sendData(master, data)
[13:33:45.651]                             }
[13:33:45.651]                             return(sendCondition)
[13:33:45.651]                           }
[13:33:45.651]                         }
[13:33:45.651]                         frame <- frame + 1L
[13:33:45.651]                         envir <- sys.frame(frame)
[13:33:45.651]                       }
[13:33:45.651]                     }
[13:33:45.651]                     sendCondition <<- function(cond) NULL
[13:33:45.651]                   }
[13:33:45.651]                 })
[13:33:45.651]                 withCallingHandlers({
[13:33:45.651]                   {
[13:33:45.651]                     do.call(function(...) {
[13:33:45.651]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:45.651]                       if (!identical(...future.globals.maxSize.org, 
[13:33:45.651]                         ...future.globals.maxSize)) {
[13:33:45.651]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:45.651]                         on.exit(options(oopts), add = TRUE)
[13:33:45.651]                       }
[13:33:45.651]                       {
[13:33:45.651]                         lapply(seq_along(...future.elements_ii), 
[13:33:45.651]                           FUN = function(jj) {
[13:33:45.651]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:45.651]                             ...future.FUN(...future.X_jj, ...)
[13:33:45.651]                           })
[13:33:45.651]                       }
[13:33:45.651]                     }, args = future.call.arguments)
[13:33:45.651]                   }
[13:33:45.651]                 }, immediateCondition = function(cond) {
[13:33:45.651]                   sendCondition <- ...future.makeSendCondition()
[13:33:45.651]                   sendCondition(cond)
[13:33:45.651]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:45.651]                   {
[13:33:45.651]                     inherits <- base::inherits
[13:33:45.651]                     invokeRestart <- base::invokeRestart
[13:33:45.651]                     is.null <- base::is.null
[13:33:45.651]                     muffled <- FALSE
[13:33:45.651]                     if (inherits(cond, "message")) {
[13:33:45.651]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:45.651]                       if (muffled) 
[13:33:45.651]                         invokeRestart("muffleMessage")
[13:33:45.651]                     }
[13:33:45.651]                     else if (inherits(cond, "warning")) {
[13:33:45.651]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:45.651]                       if (muffled) 
[13:33:45.651]                         invokeRestart("muffleWarning")
[13:33:45.651]                     }
[13:33:45.651]                     else if (inherits(cond, "condition")) {
[13:33:45.651]                       if (!is.null(pattern)) {
[13:33:45.651]                         computeRestarts <- base::computeRestarts
[13:33:45.651]                         grepl <- base::grepl
[13:33:45.651]                         restarts <- computeRestarts(cond)
[13:33:45.651]                         for (restart in restarts) {
[13:33:45.651]                           name <- restart$name
[13:33:45.651]                           if (is.null(name)) 
[13:33:45.651]                             next
[13:33:45.651]                           if (!grepl(pattern, name)) 
[13:33:45.651]                             next
[13:33:45.651]                           invokeRestart(restart)
[13:33:45.651]                           muffled <- TRUE
[13:33:45.651]                           break
[13:33:45.651]                         }
[13:33:45.651]                       }
[13:33:45.651]                     }
[13:33:45.651]                     invisible(muffled)
[13:33:45.651]                   }
[13:33:45.651]                   muffleCondition(cond)
[13:33:45.651]                 })
[13:33:45.651]             }))
[13:33:45.651]             future::FutureResult(value = ...future.value$value, 
[13:33:45.651]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:45.651]                   ...future.rng), globalenv = if (FALSE) 
[13:33:45.651]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:45.651]                     ...future.globalenv.names))
[13:33:45.651]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:45.651]         }, condition = base::local({
[13:33:45.651]             c <- base::c
[13:33:45.651]             inherits <- base::inherits
[13:33:45.651]             invokeRestart <- base::invokeRestart
[13:33:45.651]             length <- base::length
[13:33:45.651]             list <- base::list
[13:33:45.651]             seq.int <- base::seq.int
[13:33:45.651]             signalCondition <- base::signalCondition
[13:33:45.651]             sys.calls <- base::sys.calls
[13:33:45.651]             `[[` <- base::`[[`
[13:33:45.651]             `+` <- base::`+`
[13:33:45.651]             `<<-` <- base::`<<-`
[13:33:45.651]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:45.651]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:45.651]                   3L)]
[13:33:45.651]             }
[13:33:45.651]             function(cond) {
[13:33:45.651]                 is_error <- inherits(cond, "error")
[13:33:45.651]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:45.651]                   NULL)
[13:33:45.651]                 if (is_error) {
[13:33:45.651]                   sessionInformation <- function() {
[13:33:45.651]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:45.651]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:45.651]                       search = base::search(), system = base::Sys.info())
[13:33:45.651]                   }
[13:33:45.651]                   ...future.conditions[[length(...future.conditions) + 
[13:33:45.651]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:45.651]                     cond$call), session = sessionInformation(), 
[13:33:45.651]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:45.651]                   signalCondition(cond)
[13:33:45.651]                 }
[13:33:45.651]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:45.651]                 "immediateCondition"))) {
[13:33:45.651]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:45.651]                   ...future.conditions[[length(...future.conditions) + 
[13:33:45.651]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:45.651]                   if (TRUE && !signal) {
[13:33:45.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:45.651]                     {
[13:33:45.651]                       inherits <- base::inherits
[13:33:45.651]                       invokeRestart <- base::invokeRestart
[13:33:45.651]                       is.null <- base::is.null
[13:33:45.651]                       muffled <- FALSE
[13:33:45.651]                       if (inherits(cond, "message")) {
[13:33:45.651]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:45.651]                         if (muffled) 
[13:33:45.651]                           invokeRestart("muffleMessage")
[13:33:45.651]                       }
[13:33:45.651]                       else if (inherits(cond, "warning")) {
[13:33:45.651]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:45.651]                         if (muffled) 
[13:33:45.651]                           invokeRestart("muffleWarning")
[13:33:45.651]                       }
[13:33:45.651]                       else if (inherits(cond, "condition")) {
[13:33:45.651]                         if (!is.null(pattern)) {
[13:33:45.651]                           computeRestarts <- base::computeRestarts
[13:33:45.651]                           grepl <- base::grepl
[13:33:45.651]                           restarts <- computeRestarts(cond)
[13:33:45.651]                           for (restart in restarts) {
[13:33:45.651]                             name <- restart$name
[13:33:45.651]                             if (is.null(name)) 
[13:33:45.651]                               next
[13:33:45.651]                             if (!grepl(pattern, name)) 
[13:33:45.651]                               next
[13:33:45.651]                             invokeRestart(restart)
[13:33:45.651]                             muffled <- TRUE
[13:33:45.651]                             break
[13:33:45.651]                           }
[13:33:45.651]                         }
[13:33:45.651]                       }
[13:33:45.651]                       invisible(muffled)
[13:33:45.651]                     }
[13:33:45.651]                     muffleCondition(cond, pattern = "^muffle")
[13:33:45.651]                   }
[13:33:45.651]                 }
[13:33:45.651]                 else {
[13:33:45.651]                   if (TRUE) {
[13:33:45.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:45.651]                     {
[13:33:45.651]                       inherits <- base::inherits
[13:33:45.651]                       invokeRestart <- base::invokeRestart
[13:33:45.651]                       is.null <- base::is.null
[13:33:45.651]                       muffled <- FALSE
[13:33:45.651]                       if (inherits(cond, "message")) {
[13:33:45.651]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:45.651]                         if (muffled) 
[13:33:45.651]                           invokeRestart("muffleMessage")
[13:33:45.651]                       }
[13:33:45.651]                       else if (inherits(cond, "warning")) {
[13:33:45.651]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:45.651]                         if (muffled) 
[13:33:45.651]                           invokeRestart("muffleWarning")
[13:33:45.651]                       }
[13:33:45.651]                       else if (inherits(cond, "condition")) {
[13:33:45.651]                         if (!is.null(pattern)) {
[13:33:45.651]                           computeRestarts <- base::computeRestarts
[13:33:45.651]                           grepl <- base::grepl
[13:33:45.651]                           restarts <- computeRestarts(cond)
[13:33:45.651]                           for (restart in restarts) {
[13:33:45.651]                             name <- restart$name
[13:33:45.651]                             if (is.null(name)) 
[13:33:45.651]                               next
[13:33:45.651]                             if (!grepl(pattern, name)) 
[13:33:45.651]                               next
[13:33:45.651]                             invokeRestart(restart)
[13:33:45.651]                             muffled <- TRUE
[13:33:45.651]                             break
[13:33:45.651]                           }
[13:33:45.651]                         }
[13:33:45.651]                       }
[13:33:45.651]                       invisible(muffled)
[13:33:45.651]                     }
[13:33:45.651]                     muffleCondition(cond, pattern = "^muffle")
[13:33:45.651]                   }
[13:33:45.651]                 }
[13:33:45.651]             }
[13:33:45.651]         }))
[13:33:45.651]     }, error = function(ex) {
[13:33:45.651]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:45.651]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:45.651]                 ...future.rng), started = ...future.startTime, 
[13:33:45.651]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:45.651]             version = "1.8"), class = "FutureResult")
[13:33:45.651]     }, finally = {
[13:33:45.651]         if (!identical(...future.workdir, getwd())) 
[13:33:45.651]             setwd(...future.workdir)
[13:33:45.651]         {
[13:33:45.651]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:45.651]                 ...future.oldOptions$nwarnings <- NULL
[13:33:45.651]             }
[13:33:45.651]             base::options(...future.oldOptions)
[13:33:45.651]             if (.Platform$OS.type == "windows") {
[13:33:45.651]                 old_names <- names(...future.oldEnvVars)
[13:33:45.651]                 envs <- base::Sys.getenv()
[13:33:45.651]                 names <- names(envs)
[13:33:45.651]                 common <- intersect(names, old_names)
[13:33:45.651]                 added <- setdiff(names, old_names)
[13:33:45.651]                 removed <- setdiff(old_names, names)
[13:33:45.651]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:45.651]                   envs[common]]
[13:33:45.651]                 NAMES <- toupper(changed)
[13:33:45.651]                 args <- list()
[13:33:45.651]                 for (kk in seq_along(NAMES)) {
[13:33:45.651]                   name <- changed[[kk]]
[13:33:45.651]                   NAME <- NAMES[[kk]]
[13:33:45.651]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:45.651]                     next
[13:33:45.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:45.651]                 }
[13:33:45.651]                 NAMES <- toupper(added)
[13:33:45.651]                 for (kk in seq_along(NAMES)) {
[13:33:45.651]                   name <- added[[kk]]
[13:33:45.651]                   NAME <- NAMES[[kk]]
[13:33:45.651]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:45.651]                     next
[13:33:45.651]                   args[[name]] <- ""
[13:33:45.651]                 }
[13:33:45.651]                 NAMES <- toupper(removed)
[13:33:45.651]                 for (kk in seq_along(NAMES)) {
[13:33:45.651]                   name <- removed[[kk]]
[13:33:45.651]                   NAME <- NAMES[[kk]]
[13:33:45.651]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:45.651]                     next
[13:33:45.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:45.651]                 }
[13:33:45.651]                 if (length(args) > 0) 
[13:33:45.651]                   base::do.call(base::Sys.setenv, args = args)
[13:33:45.651]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:45.651]             }
[13:33:45.651]             else {
[13:33:45.651]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:45.651]             }
[13:33:45.651]             {
[13:33:45.651]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:45.651]                   0L) {
[13:33:45.651]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:45.651]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:45.651]                   base::options(opts)
[13:33:45.651]                 }
[13:33:45.651]                 {
[13:33:45.651]                   {
[13:33:45.651]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:45.651]                     NULL
[13:33:45.651]                   }
[13:33:45.651]                   options(future.plan = NULL)
[13:33:45.651]                   if (is.na(NA_character_)) 
[13:33:45.651]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:45.651]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:45.651]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:45.651]                     .init = FALSE)
[13:33:45.651]                 }
[13:33:45.651]             }
[13:33:45.651]         }
[13:33:45.651]     })
[13:33:45.651]     if (TRUE) {
[13:33:45.651]         base::sink(type = "output", split = FALSE)
[13:33:45.651]         if (TRUE) {
[13:33:45.651]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:45.651]         }
[13:33:45.651]         else {
[13:33:45.651]             ...future.result["stdout"] <- base::list(NULL)
[13:33:45.651]         }
[13:33:45.651]         base::close(...future.stdout)
[13:33:45.651]         ...future.stdout <- NULL
[13:33:45.651]     }
[13:33:45.651]     ...future.result$conditions <- ...future.conditions
[13:33:45.651]     ...future.result$finished <- base::Sys.time()
[13:33:45.651]     ...future.result
[13:33:45.651] }
[13:33:45.654] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[13:33:45.654] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[13:33:45.655] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[13:33:45.655] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:33:45.656] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:33:45.656] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[13:33:45.656] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[13:33:45.656] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:33:45.657] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:33:45.657] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:33:45.657] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:33:45.657] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[13:33:45.658] MultisessionFuture started
[13:33:45.658] - Launch lazy future ... done
[13:33:45.658] run() for ‘MultisessionFuture’ ... done
[13:33:45.659] Created future:
[13:33:45.659] MultisessionFuture:
[13:33:45.659] Label: ‘future_eapply-1’
[13:33:45.659] Expression:
[13:33:45.659] {
[13:33:45.659]     do.call(function(...) {
[13:33:45.659]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:45.659]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:45.659]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:45.659]             on.exit(options(oopts), add = TRUE)
[13:33:45.659]         }
[13:33:45.659]         {
[13:33:45.659]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:45.659]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:45.659]                 ...future.FUN(...future.X_jj, ...)
[13:33:45.659]             })
[13:33:45.659]         }
[13:33:45.659]     }, args = future.call.arguments)
[13:33:45.659] }
[13:33:45.659] Lazy evaluation: FALSE
[13:33:45.659] Asynchronous evaluation: TRUE
[13:33:45.659] Local evaluation: TRUE
[13:33:45.659] Environment: R_GlobalEnv
[13:33:45.659] Capture standard output: TRUE
[13:33:45.659] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:45.659] Globals: 5 objects totaling 1.27 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:45.659] Packages: <none>
[13:33:45.659] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:45.659] Resolved: FALSE
[13:33:45.659] Value: <not collected>
[13:33:45.659] Conditions captured: <none>
[13:33:45.659] Early signaling: FALSE
[13:33:45.659] Owner process: b6e93464-7fc2-3f8d-23d1-d8004201d1f1
[13:33:45.659] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:45.671] Chunk #1 of 2 ... DONE
[13:33:45.671] Chunk #2 of 2 ...
[13:33:45.671]  - Finding globals in 'X' for chunk #2 ...
[13:33:45.671] getGlobalsAndPackages() ...
[13:33:45.671] Searching for globals...
[13:33:45.672] 
[13:33:45.672] Searching for globals ... DONE
[13:33:45.672] - globals: [0] <none>
[13:33:45.672] getGlobalsAndPackages() ... DONE
[13:33:45.672]    + additional globals found: [n=0] 
[13:33:45.672]    + additional namespaces needed: [n=0] 
[13:33:45.672]  - Finding globals in 'X' for chunk #2 ... DONE
[13:33:45.672]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:45.673]  - seeds: <none>
[13:33:45.673]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:45.673] getGlobalsAndPackages() ...
[13:33:45.673] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:45.673] Resolving globals: FALSE
[13:33:45.673] Tweak future expression to call with '...' arguments ...
[13:33:45.673] {
[13:33:45.673]     do.call(function(...) {
[13:33:45.673]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:45.673]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:45.673]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:45.673]             on.exit(options(oopts), add = TRUE)
[13:33:45.673]         }
[13:33:45.673]         {
[13:33:45.673]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:45.673]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:45.673]                 ...future.FUN(...future.X_jj, ...)
[13:33:45.673]             })
[13:33:45.673]         }
[13:33:45.673]     }, args = future.call.arguments)
[13:33:45.673] }
[13:33:45.674] Tweak future expression to call with '...' arguments ... DONE
[13:33:45.674] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:45.674] 
[13:33:45.674] getGlobalsAndPackages() ... DONE
[13:33:45.675] run() for ‘Future’ ...
[13:33:45.675] - state: ‘created’
[13:33:45.675] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:45.689] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:45.689] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:45.689]   - Field: ‘node’
[13:33:45.689]   - Field: ‘label’
[13:33:45.690]   - Field: ‘local’
[13:33:45.690]   - Field: ‘owner’
[13:33:45.690]   - Field: ‘envir’
[13:33:45.690]   - Field: ‘workers’
[13:33:45.690]   - Field: ‘packages’
[13:33:45.690]   - Field: ‘gc’
[13:33:45.690]   - Field: ‘conditions’
[13:33:45.690]   - Field: ‘persistent’
[13:33:45.690]   - Field: ‘expr’
[13:33:45.691]   - Field: ‘uuid’
[13:33:45.691]   - Field: ‘seed’
[13:33:45.691]   - Field: ‘version’
[13:33:45.691]   - Field: ‘result’
[13:33:45.691]   - Field: ‘asynchronous’
[13:33:45.691]   - Field: ‘calls’
[13:33:45.691]   - Field: ‘globals’
[13:33:45.691]   - Field: ‘stdout’
[13:33:45.691]   - Field: ‘earlySignal’
[13:33:45.692]   - Field: ‘lazy’
[13:33:45.692]   - Field: ‘state’
[13:33:45.692] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:45.692] - Launch lazy future ...
[13:33:45.692] Packages needed by the future expression (n = 0): <none>
[13:33:45.692] Packages needed by future strategies (n = 0): <none>
[13:33:45.693] {
[13:33:45.693]     {
[13:33:45.693]         {
[13:33:45.693]             ...future.startTime <- base::Sys.time()
[13:33:45.693]             {
[13:33:45.693]                 {
[13:33:45.693]                   {
[13:33:45.693]                     {
[13:33:45.693]                       base::local({
[13:33:45.693]                         has_future <- base::requireNamespace("future", 
[13:33:45.693]                           quietly = TRUE)
[13:33:45.693]                         if (has_future) {
[13:33:45.693]                           ns <- base::getNamespace("future")
[13:33:45.693]                           version <- ns[[".package"]][["version"]]
[13:33:45.693]                           if (is.null(version)) 
[13:33:45.693]                             version <- utils::packageVersion("future")
[13:33:45.693]                         }
[13:33:45.693]                         else {
[13:33:45.693]                           version <- NULL
[13:33:45.693]                         }
[13:33:45.693]                         if (!has_future || version < "1.8.0") {
[13:33:45.693]                           info <- base::c(r_version = base::gsub("R version ", 
[13:33:45.693]                             "", base::R.version$version.string), 
[13:33:45.693]                             platform = base::sprintf("%s (%s-bit)", 
[13:33:45.693]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:33:45.693]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:45.693]                               "release", "version")], collapse = " "), 
[13:33:45.693]                             hostname = base::Sys.info()[["nodename"]])
[13:33:45.693]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:33:45.693]                             info)
[13:33:45.693]                           info <- base::paste(info, collapse = "; ")
[13:33:45.693]                           if (!has_future) {
[13:33:45.693]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:45.693]                               info)
[13:33:45.693]                           }
[13:33:45.693]                           else {
[13:33:45.693]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:45.693]                               info, version)
[13:33:45.693]                           }
[13:33:45.693]                           base::stop(msg)
[13:33:45.693]                         }
[13:33:45.693]                       })
[13:33:45.693]                     }
[13:33:45.693]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:45.693]                     base::options(mc.cores = 1L)
[13:33:45.693]                   }
[13:33:45.693]                   ...future.strategy.old <- future::plan("list")
[13:33:45.693]                   options(future.plan = NULL)
[13:33:45.693]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:45.693]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:45.693]                 }
[13:33:45.693]                 ...future.workdir <- getwd()
[13:33:45.693]             }
[13:33:45.693]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:45.693]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:45.693]         }
[13:33:45.693]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:45.693]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:45.693]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:45.693]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:45.693]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:45.693]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:45.693]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:45.693]             base::names(...future.oldOptions))
[13:33:45.693]     }
[13:33:45.693]     if (FALSE) {
[13:33:45.693]     }
[13:33:45.693]     else {
[13:33:45.693]         if (TRUE) {
[13:33:45.693]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:45.693]                 open = "w")
[13:33:45.693]         }
[13:33:45.693]         else {
[13:33:45.693]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:45.693]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:45.693]         }
[13:33:45.693]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:45.693]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:45.693]             base::sink(type = "output", split = FALSE)
[13:33:45.693]             base::close(...future.stdout)
[13:33:45.693]         }, add = TRUE)
[13:33:45.693]     }
[13:33:45.693]     ...future.frame <- base::sys.nframe()
[13:33:45.693]     ...future.conditions <- base::list()
[13:33:45.693]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:45.693]     if (FALSE) {
[13:33:45.693]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:45.693]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:45.693]     }
[13:33:45.693]     ...future.result <- base::tryCatch({
[13:33:45.693]         base::withCallingHandlers({
[13:33:45.693]             ...future.value <- base::withVisible(base::local({
[13:33:45.693]                 ...future.makeSendCondition <- base::local({
[13:33:45.693]                   sendCondition <- NULL
[13:33:45.693]                   function(frame = 1L) {
[13:33:45.693]                     if (is.function(sendCondition)) 
[13:33:45.693]                       return(sendCondition)
[13:33:45.693]                     ns <- getNamespace("parallel")
[13:33:45.693]                     if (exists("sendData", mode = "function", 
[13:33:45.693]                       envir = ns)) {
[13:33:45.693]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:45.693]                         envir = ns)
[13:33:45.693]                       envir <- sys.frame(frame)
[13:33:45.693]                       master <- NULL
[13:33:45.693]                       while (!identical(envir, .GlobalEnv) && 
[13:33:45.693]                         !identical(envir, emptyenv())) {
[13:33:45.693]                         if (exists("master", mode = "list", envir = envir, 
[13:33:45.693]                           inherits = FALSE)) {
[13:33:45.693]                           master <- get("master", mode = "list", 
[13:33:45.693]                             envir = envir, inherits = FALSE)
[13:33:45.693]                           if (inherits(master, c("SOCKnode", 
[13:33:45.693]                             "SOCK0node"))) {
[13:33:45.693]                             sendCondition <<- function(cond) {
[13:33:45.693]                               data <- list(type = "VALUE", value = cond, 
[13:33:45.693]                                 success = TRUE)
[13:33:45.693]                               parallel_sendData(master, data)
[13:33:45.693]                             }
[13:33:45.693]                             return(sendCondition)
[13:33:45.693]                           }
[13:33:45.693]                         }
[13:33:45.693]                         frame <- frame + 1L
[13:33:45.693]                         envir <- sys.frame(frame)
[13:33:45.693]                       }
[13:33:45.693]                     }
[13:33:45.693]                     sendCondition <<- function(cond) NULL
[13:33:45.693]                   }
[13:33:45.693]                 })
[13:33:45.693]                 withCallingHandlers({
[13:33:45.693]                   {
[13:33:45.693]                     do.call(function(...) {
[13:33:45.693]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:45.693]                       if (!identical(...future.globals.maxSize.org, 
[13:33:45.693]                         ...future.globals.maxSize)) {
[13:33:45.693]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:45.693]                         on.exit(options(oopts), add = TRUE)
[13:33:45.693]                       }
[13:33:45.693]                       {
[13:33:45.693]                         lapply(seq_along(...future.elements_ii), 
[13:33:45.693]                           FUN = function(jj) {
[13:33:45.693]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:45.693]                             ...future.FUN(...future.X_jj, ...)
[13:33:45.693]                           })
[13:33:45.693]                       }
[13:33:45.693]                     }, args = future.call.arguments)
[13:33:45.693]                   }
[13:33:45.693]                 }, immediateCondition = function(cond) {
[13:33:45.693]                   sendCondition <- ...future.makeSendCondition()
[13:33:45.693]                   sendCondition(cond)
[13:33:45.693]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:45.693]                   {
[13:33:45.693]                     inherits <- base::inherits
[13:33:45.693]                     invokeRestart <- base::invokeRestart
[13:33:45.693]                     is.null <- base::is.null
[13:33:45.693]                     muffled <- FALSE
[13:33:45.693]                     if (inherits(cond, "message")) {
[13:33:45.693]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:45.693]                       if (muffled) 
[13:33:45.693]                         invokeRestart("muffleMessage")
[13:33:45.693]                     }
[13:33:45.693]                     else if (inherits(cond, "warning")) {
[13:33:45.693]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:45.693]                       if (muffled) 
[13:33:45.693]                         invokeRestart("muffleWarning")
[13:33:45.693]                     }
[13:33:45.693]                     else if (inherits(cond, "condition")) {
[13:33:45.693]                       if (!is.null(pattern)) {
[13:33:45.693]                         computeRestarts <- base::computeRestarts
[13:33:45.693]                         grepl <- base::grepl
[13:33:45.693]                         restarts <- computeRestarts(cond)
[13:33:45.693]                         for (restart in restarts) {
[13:33:45.693]                           name <- restart$name
[13:33:45.693]                           if (is.null(name)) 
[13:33:45.693]                             next
[13:33:45.693]                           if (!grepl(pattern, name)) 
[13:33:45.693]                             next
[13:33:45.693]                           invokeRestart(restart)
[13:33:45.693]                           muffled <- TRUE
[13:33:45.693]                           break
[13:33:45.693]                         }
[13:33:45.693]                       }
[13:33:45.693]                     }
[13:33:45.693]                     invisible(muffled)
[13:33:45.693]                   }
[13:33:45.693]                   muffleCondition(cond)
[13:33:45.693]                 })
[13:33:45.693]             }))
[13:33:45.693]             future::FutureResult(value = ...future.value$value, 
[13:33:45.693]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:45.693]                   ...future.rng), globalenv = if (FALSE) 
[13:33:45.693]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:45.693]                     ...future.globalenv.names))
[13:33:45.693]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:45.693]         }, condition = base::local({
[13:33:45.693]             c <- base::c
[13:33:45.693]             inherits <- base::inherits
[13:33:45.693]             invokeRestart <- base::invokeRestart
[13:33:45.693]             length <- base::length
[13:33:45.693]             list <- base::list
[13:33:45.693]             seq.int <- base::seq.int
[13:33:45.693]             signalCondition <- base::signalCondition
[13:33:45.693]             sys.calls <- base::sys.calls
[13:33:45.693]             `[[` <- base::`[[`
[13:33:45.693]             `+` <- base::`+`
[13:33:45.693]             `<<-` <- base::`<<-`
[13:33:45.693]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:45.693]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:45.693]                   3L)]
[13:33:45.693]             }
[13:33:45.693]             function(cond) {
[13:33:45.693]                 is_error <- inherits(cond, "error")
[13:33:45.693]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:45.693]                   NULL)
[13:33:45.693]                 if (is_error) {
[13:33:45.693]                   sessionInformation <- function() {
[13:33:45.693]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:45.693]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:45.693]                       search = base::search(), system = base::Sys.info())
[13:33:45.693]                   }
[13:33:45.693]                   ...future.conditions[[length(...future.conditions) + 
[13:33:45.693]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:45.693]                     cond$call), session = sessionInformation(), 
[13:33:45.693]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:45.693]                   signalCondition(cond)
[13:33:45.693]                 }
[13:33:45.693]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:45.693]                 "immediateCondition"))) {
[13:33:45.693]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:45.693]                   ...future.conditions[[length(...future.conditions) + 
[13:33:45.693]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:45.693]                   if (TRUE && !signal) {
[13:33:45.693]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:45.693]                     {
[13:33:45.693]                       inherits <- base::inherits
[13:33:45.693]                       invokeRestart <- base::invokeRestart
[13:33:45.693]                       is.null <- base::is.null
[13:33:45.693]                       muffled <- FALSE
[13:33:45.693]                       if (inherits(cond, "message")) {
[13:33:45.693]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:45.693]                         if (muffled) 
[13:33:45.693]                           invokeRestart("muffleMessage")
[13:33:45.693]                       }
[13:33:45.693]                       else if (inherits(cond, "warning")) {
[13:33:45.693]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:45.693]                         if (muffled) 
[13:33:45.693]                           invokeRestart("muffleWarning")
[13:33:45.693]                       }
[13:33:45.693]                       else if (inherits(cond, "condition")) {
[13:33:45.693]                         if (!is.null(pattern)) {
[13:33:45.693]                           computeRestarts <- base::computeRestarts
[13:33:45.693]                           grepl <- base::grepl
[13:33:45.693]                           restarts <- computeRestarts(cond)
[13:33:45.693]                           for (restart in restarts) {
[13:33:45.693]                             name <- restart$name
[13:33:45.693]                             if (is.null(name)) 
[13:33:45.693]                               next
[13:33:45.693]                             if (!grepl(pattern, name)) 
[13:33:45.693]                               next
[13:33:45.693]                             invokeRestart(restart)
[13:33:45.693]                             muffled <- TRUE
[13:33:45.693]                             break
[13:33:45.693]                           }
[13:33:45.693]                         }
[13:33:45.693]                       }
[13:33:45.693]                       invisible(muffled)
[13:33:45.693]                     }
[13:33:45.693]                     muffleCondition(cond, pattern = "^muffle")
[13:33:45.693]                   }
[13:33:45.693]                 }
[13:33:45.693]                 else {
[13:33:45.693]                   if (TRUE) {
[13:33:45.693]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:45.693]                     {
[13:33:45.693]                       inherits <- base::inherits
[13:33:45.693]                       invokeRestart <- base::invokeRestart
[13:33:45.693]                       is.null <- base::is.null
[13:33:45.693]                       muffled <- FALSE
[13:33:45.693]                       if (inherits(cond, "message")) {
[13:33:45.693]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:45.693]                         if (muffled) 
[13:33:45.693]                           invokeRestart("muffleMessage")
[13:33:45.693]                       }
[13:33:45.693]                       else if (inherits(cond, "warning")) {
[13:33:45.693]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:45.693]                         if (muffled) 
[13:33:45.693]                           invokeRestart("muffleWarning")
[13:33:45.693]                       }
[13:33:45.693]                       else if (inherits(cond, "condition")) {
[13:33:45.693]                         if (!is.null(pattern)) {
[13:33:45.693]                           computeRestarts <- base::computeRestarts
[13:33:45.693]                           grepl <- base::grepl
[13:33:45.693]                           restarts <- computeRestarts(cond)
[13:33:45.693]                           for (restart in restarts) {
[13:33:45.693]                             name <- restart$name
[13:33:45.693]                             if (is.null(name)) 
[13:33:45.693]                               next
[13:33:45.693]                             if (!grepl(pattern, name)) 
[13:33:45.693]                               next
[13:33:45.693]                             invokeRestart(restart)
[13:33:45.693]                             muffled <- TRUE
[13:33:45.693]                             break
[13:33:45.693]                           }
[13:33:45.693]                         }
[13:33:45.693]                       }
[13:33:45.693]                       invisible(muffled)
[13:33:45.693]                     }
[13:33:45.693]                     muffleCondition(cond, pattern = "^muffle")
[13:33:45.693]                   }
[13:33:45.693]                 }
[13:33:45.693]             }
[13:33:45.693]         }))
[13:33:45.693]     }, error = function(ex) {
[13:33:45.693]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:45.693]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:45.693]                 ...future.rng), started = ...future.startTime, 
[13:33:45.693]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:45.693]             version = "1.8"), class = "FutureResult")
[13:33:45.693]     }, finally = {
[13:33:45.693]         if (!identical(...future.workdir, getwd())) 
[13:33:45.693]             setwd(...future.workdir)
[13:33:45.693]         {
[13:33:45.693]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:45.693]                 ...future.oldOptions$nwarnings <- NULL
[13:33:45.693]             }
[13:33:45.693]             base::options(...future.oldOptions)
[13:33:45.693]             if (.Platform$OS.type == "windows") {
[13:33:45.693]                 old_names <- names(...future.oldEnvVars)
[13:33:45.693]                 envs <- base::Sys.getenv()
[13:33:45.693]                 names <- names(envs)
[13:33:45.693]                 common <- intersect(names, old_names)
[13:33:45.693]                 added <- setdiff(names, old_names)
[13:33:45.693]                 removed <- setdiff(old_names, names)
[13:33:45.693]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:45.693]                   envs[common]]
[13:33:45.693]                 NAMES <- toupper(changed)
[13:33:45.693]                 args <- list()
[13:33:45.693]                 for (kk in seq_along(NAMES)) {
[13:33:45.693]                   name <- changed[[kk]]
[13:33:45.693]                   NAME <- NAMES[[kk]]
[13:33:45.693]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:45.693]                     next
[13:33:45.693]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:45.693]                 }
[13:33:45.693]                 NAMES <- toupper(added)
[13:33:45.693]                 for (kk in seq_along(NAMES)) {
[13:33:45.693]                   name <- added[[kk]]
[13:33:45.693]                   NAME <- NAMES[[kk]]
[13:33:45.693]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:45.693]                     next
[13:33:45.693]                   args[[name]] <- ""
[13:33:45.693]                 }
[13:33:45.693]                 NAMES <- toupper(removed)
[13:33:45.693]                 for (kk in seq_along(NAMES)) {
[13:33:45.693]                   name <- removed[[kk]]
[13:33:45.693]                   NAME <- NAMES[[kk]]
[13:33:45.693]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:45.693]                     next
[13:33:45.693]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:45.693]                 }
[13:33:45.693]                 if (length(args) > 0) 
[13:33:45.693]                   base::do.call(base::Sys.setenv, args = args)
[13:33:45.693]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:45.693]             }
[13:33:45.693]             else {
[13:33:45.693]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:45.693]             }
[13:33:45.693]             {
[13:33:45.693]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:45.693]                   0L) {
[13:33:45.693]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:45.693]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:45.693]                   base::options(opts)
[13:33:45.693]                 }
[13:33:45.693]                 {
[13:33:45.693]                   {
[13:33:45.693]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:45.693]                     NULL
[13:33:45.693]                   }
[13:33:45.693]                   options(future.plan = NULL)
[13:33:45.693]                   if (is.na(NA_character_)) 
[13:33:45.693]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:45.693]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:45.693]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:45.693]                     .init = FALSE)
[13:33:45.693]                 }
[13:33:45.693]             }
[13:33:45.693]         }
[13:33:45.693]     })
[13:33:45.693]     if (TRUE) {
[13:33:45.693]         base::sink(type = "output", split = FALSE)
[13:33:45.693]         if (TRUE) {
[13:33:45.693]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:45.693]         }
[13:33:45.693]         else {
[13:33:45.693]             ...future.result["stdout"] <- base::list(NULL)
[13:33:45.693]         }
[13:33:45.693]         base::close(...future.stdout)
[13:33:45.693]         ...future.stdout <- NULL
[13:33:45.693]     }
[13:33:45.693]     ...future.result$conditions <- ...future.conditions
[13:33:45.693]     ...future.result$finished <- base::Sys.time()
[13:33:45.693]     ...future.result
[13:33:45.693] }
[13:33:45.747] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[13:33:45.747] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[13:33:45.748] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[13:33:45.748] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:33:45.748] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:33:45.749] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[13:33:45.749] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[13:33:45.749] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:33:45.749] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:33:45.750] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:33:45.750] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:33:45.750] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[13:33:45.751] MultisessionFuture started
[13:33:45.751] - Launch lazy future ... done
[13:33:45.751] run() for ‘MultisessionFuture’ ... done
[13:33:45.751] Created future:
[13:33:45.751] MultisessionFuture:
[13:33:45.751] Label: ‘future_eapply-2’
[13:33:45.751] Expression:
[13:33:45.751] {
[13:33:45.751]     do.call(function(...) {
[13:33:45.751]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:45.751]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:45.751]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:45.751]             on.exit(options(oopts), add = TRUE)
[13:33:45.751]         }
[13:33:45.751]         {
[13:33:45.751]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:45.751]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:45.751]                 ...future.FUN(...future.X_jj, ...)
[13:33:45.751]             })
[13:33:45.751]         }
[13:33:45.751]     }, args = future.call.arguments)
[13:33:45.751] }
[13:33:45.751] Lazy evaluation: FALSE
[13:33:45.751] Asynchronous evaluation: TRUE
[13:33:45.751] Local evaluation: TRUE
[13:33:45.751] Environment: R_GlobalEnv
[13:33:45.751] Capture standard output: TRUE
[13:33:45.751] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:45.751] Globals: 5 objects totaling 1.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:45.751] Packages: <none>
[13:33:45.751] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:45.751] Resolved: FALSE
[13:33:45.751] Value: <not collected>
[13:33:45.751] Conditions captured: <none>
[13:33:45.751] Early signaling: FALSE
[13:33:45.751] Owner process: b6e93464-7fc2-3f8d-23d1-d8004201d1f1
[13:33:45.751] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:45.763] Chunk #2 of 2 ... DONE
[13:33:45.763] Launching 2 futures (chunks) ... DONE
[13:33:45.763] Resolving 2 futures (chunks) ...
[13:33:45.764] resolve() on list ...
[13:33:45.764]  recursive: 0
[13:33:45.764]  length: 2
[13:33:45.764] 
[13:33:45.764] receiveMessageFromWorker() for ClusterFuture ...
[13:33:45.765] - Validating connection of MultisessionFuture
[13:33:45.765] - received message: FutureResult
[13:33:45.765] - Received FutureResult
[13:33:45.765] - Erased future from FutureRegistry
[13:33:45.765] result() for ClusterFuture ...
[13:33:45.765] - result already collected: FutureResult
[13:33:45.766] result() for ClusterFuture ... done
[13:33:45.766] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:45.766] Future #1
[13:33:45.766] result() for ClusterFuture ...
[13:33:45.771] - result already collected: FutureResult
[13:33:45.771] result() for ClusterFuture ... done
[13:33:45.771] result() for ClusterFuture ...
[13:33:45.771] - result already collected: FutureResult
[13:33:45.771] result() for ClusterFuture ... done
[13:33:45.771] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:33:45.771] - nx: 2
[13:33:45.771] - relay: TRUE
[13:33:45.771] - stdout: TRUE
[13:33:45.771] - signal: TRUE
[13:33:45.772] - resignal: FALSE
[13:33:45.772] - force: TRUE
[13:33:45.772] - relayed: [n=2] FALSE, FALSE
[13:33:45.772] - queued futures: [n=2] FALSE, FALSE
[13:33:45.772]  - until=1
[13:33:45.772]  - relaying element #1
[13:33:45.772] result() for ClusterFuture ...
[13:33:45.772] - result already collected: FutureResult
[13:33:45.772] result() for ClusterFuture ... done
[13:33:45.772] result() for ClusterFuture ...
[13:33:45.772] - result already collected: FutureResult
[13:33:45.772] result() for ClusterFuture ... done
[13:33:45.773] result() for ClusterFuture ...
[13:33:45.773] - result already collected: FutureResult
[13:33:45.773] result() for ClusterFuture ... done
[13:33:45.773] result() for ClusterFuture ...
[13:33:45.773] - result already collected: FutureResult
[13:33:45.773] result() for ClusterFuture ... done
[13:33:45.773] - relayed: [n=2] TRUE, FALSE
[13:33:45.773] - queued futures: [n=2] TRUE, FALSE
[13:33:45.773] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:33:45.773]  length: 1 (resolved future 1)
[13:33:45.836] receiveMessageFromWorker() for ClusterFuture ...
[13:33:45.836] - Validating connection of MultisessionFuture
[13:33:45.836] - received message: FutureResult
[13:33:45.836] - Received FutureResult
[13:33:45.836] - Erased future from FutureRegistry
[13:33:45.836] result() for ClusterFuture ...
[13:33:45.836] - result already collected: FutureResult
[13:33:45.836] result() for ClusterFuture ... done
[13:33:45.836] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:45.836] Future #2
[13:33:45.837] result() for ClusterFuture ...
[13:33:45.837] - result already collected: FutureResult
[13:33:45.837] result() for ClusterFuture ... done
[13:33:45.837] result() for ClusterFuture ...
[13:33:45.837] - result already collected: FutureResult
[13:33:45.837] result() for ClusterFuture ... done
[13:33:45.837] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:33:45.837] - nx: 2
[13:33:45.837] - relay: TRUE
[13:33:45.837] - stdout: TRUE
[13:33:45.837] - signal: TRUE
[13:33:45.838] - resignal: FALSE
[13:33:45.838] - force: TRUE
[13:33:45.838] - relayed: [n=2] TRUE, FALSE
[13:33:45.838] - queued futures: [n=2] TRUE, FALSE
[13:33:45.838]  - until=2
[13:33:45.838]  - relaying element #2
[13:33:45.838] result() for ClusterFuture ...
[13:33:45.838] - result already collected: FutureResult
[13:33:45.838] result() for ClusterFuture ... done
[13:33:45.838] result() for ClusterFuture ...
[13:33:45.838] - result already collected: FutureResult
[13:33:45.839] result() for ClusterFuture ... done
[13:33:45.839] result() for ClusterFuture ...
[13:33:45.839] - result already collected: FutureResult
[13:33:45.839] result() for ClusterFuture ... done
[13:33:45.839] result() for ClusterFuture ...
[13:33:45.839] - result already collected: FutureResult
[13:33:45.839] result() for ClusterFuture ... done
[13:33:45.839] - relayed: [n=2] TRUE, TRUE
[13:33:45.839] - queued futures: [n=2] TRUE, TRUE
[13:33:45.839] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:33:45.839]  length: 0 (resolved future 2)
[13:33:45.840] Relaying remaining futures
[13:33:45.840] signalConditionsASAP(NULL, pos=0) ...
[13:33:45.840] - nx: 2
[13:33:45.840] - relay: TRUE
[13:33:45.840] - stdout: TRUE
[13:33:45.840] - signal: TRUE
[13:33:45.840] - resignal: FALSE
[13:33:45.840] - force: TRUE
[13:33:45.840] - relayed: [n=2] TRUE, TRUE
[13:33:45.840] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:45.840] - relayed: [n=2] TRUE, TRUE
[13:33:45.841] - queued futures: [n=2] TRUE, TRUE
[13:33:45.841] signalConditionsASAP(NULL, pos=0) ... done
[13:33:45.841] resolve() on list ... DONE
[13:33:45.841] result() for ClusterFuture ...
[13:33:45.841] - result already collected: FutureResult
[13:33:45.841] result() for ClusterFuture ... done
[13:33:45.841] result() for ClusterFuture ...
[13:33:45.841] - result already collected: FutureResult
[13:33:45.841] result() for ClusterFuture ... done
[13:33:45.841] result() for ClusterFuture ...
[13:33:45.841] - result already collected: FutureResult
[13:33:45.841] result() for ClusterFuture ... done
[13:33:45.842] result() for ClusterFuture ...
[13:33:45.842] - result already collected: FutureResult
[13:33:45.842] result() for ClusterFuture ... done
[13:33:45.842]  - Number of value chunks collected: 2
[13:33:45.842] Resolving 2 futures (chunks) ... DONE
[13:33:45.842] Reducing values from 2 chunks ...
[13:33:45.842]  - Number of values collected after concatenation: 3
[13:33:45.842]  - Number of values expected: 3
[13:33:45.842] Reducing values from 2 chunks ... DONE
[13:33:45.842] future_lapply() ... DONE
[13:33:45.843] future_lapply() ...
[13:33:45.847] Number of chunks: 2
[13:33:45.847] getGlobalsAndPackagesXApply() ...
[13:33:45.847]  - future.globals: TRUE
[13:33:45.848] getGlobalsAndPackages() ...
[13:33:45.848] Searching for globals...
[13:33:45.849] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:45.849] Searching for globals ... DONE
[13:33:45.849] Resolving globals: FALSE
[13:33:45.849] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:33:45.850] The total size of the 1 globals exported for future expression (‘FUN(probs = c(0.25, 0.5, 0.75))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:33:45.850] - globals: [1] ‘FUN’
[13:33:45.850] - packages: [1] ‘stats’
[13:33:45.850] getGlobalsAndPackages() ... DONE
[13:33:45.850]  - globals found/used: [n=1] ‘FUN’
[13:33:45.850]  - needed namespaces: [n=1] ‘stats’
[13:33:45.850] Finding globals ... DONE
[13:33:45.851]  - use_args: TRUE
[13:33:45.851]  - Getting '...' globals ...
[13:33:45.851] resolve() on list ...
[13:33:45.851]  recursive: 0
[13:33:45.851]  length: 1
[13:33:45.851]  elements: ‘...’
[13:33:45.851]  length: 0 (resolved future 1)
[13:33:45.851] resolve() on list ... DONE
[13:33:45.852]    - '...' content: [n=1] ‘probs’
[13:33:45.852] List of 1
[13:33:45.852]  $ ...:List of 1
[13:33:45.852]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:33:45.852]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:45.852]  - attr(*, "where")=List of 1
[13:33:45.852]   ..$ ...:<environment: 0x5598460abc60> 
[13:33:45.852]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:45.852]  - attr(*, "resolved")= logi TRUE
[13:33:45.852]  - attr(*, "total_size")= num NA
[13:33:45.855]  - Getting '...' globals ... DONE
[13:33:45.855] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:45.855] List of 2
[13:33:45.855]  $ ...future.FUN:function (x, ...)  
[13:33:45.855]  $ ...          :List of 1
[13:33:45.855]   ..$ probs: num [1:3] 0.25 0.5 0.75
[13:33:45.855]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:45.855]  - attr(*, "where")=List of 2
[13:33:45.855]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:45.855]   ..$ ...          :<environment: 0x5598460abc60> 
[13:33:45.855]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:45.855]  - attr(*, "resolved")= logi FALSE
[13:33:45.855]  - attr(*, "total_size")= num 1328
[13:33:45.858] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:45.858] getGlobalsAndPackagesXApply() ... DONE
[13:33:45.859] Number of futures (= number of chunks): 2
[13:33:45.859] Launching 2 futures (chunks) ...
[13:33:45.859] Chunk #1 of 2 ...
[13:33:45.859]  - Finding globals in 'X' for chunk #1 ...
[13:33:45.859] getGlobalsAndPackages() ...
[13:33:45.859] Searching for globals...
[13:33:45.859] 
[13:33:45.859] Searching for globals ... DONE
[13:33:45.860] - globals: [0] <none>
[13:33:45.860] getGlobalsAndPackages() ... DONE
[13:33:45.860]    + additional globals found: [n=0] 
[13:33:45.860]    + additional namespaces needed: [n=0] 
[13:33:45.860]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:45.860]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:45.860]  - seeds: <none>
[13:33:45.860]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:45.860] getGlobalsAndPackages() ...
[13:33:45.860] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:45.860] Resolving globals: FALSE
[13:33:45.861] Tweak future expression to call with '...' arguments ...
[13:33:45.861] {
[13:33:45.861]     do.call(function(...) {
[13:33:45.861]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:45.861]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:45.861]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:45.861]             on.exit(options(oopts), add = TRUE)
[13:33:45.861]         }
[13:33:45.861]         {
[13:33:45.861]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:45.861]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:45.861]                 ...future.FUN(...future.X_jj, ...)
[13:33:45.861]             })
[13:33:45.861]         }
[13:33:45.861]     }, args = future.call.arguments)
[13:33:45.861] }
[13:33:45.861] Tweak future expression to call with '...' arguments ... DONE
[13:33:45.861] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:45.861] - packages: [1] ‘stats’
[13:33:45.862] getGlobalsAndPackages() ... DONE
[13:33:45.862] run() for ‘Future’ ...
[13:33:45.862] - state: ‘created’
[13:33:45.862] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:45.877] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:45.877] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:45.877]   - Field: ‘node’
[13:33:45.877]   - Field: ‘label’
[13:33:45.877]   - Field: ‘local’
[13:33:45.877]   - Field: ‘owner’
[13:33:45.877]   - Field: ‘envir’
[13:33:45.877]   - Field: ‘workers’
[13:33:45.877]   - Field: ‘packages’
[13:33:45.878]   - Field: ‘gc’
[13:33:45.878]   - Field: ‘conditions’
[13:33:45.878]   - Field: ‘persistent’
[13:33:45.878]   - Field: ‘expr’
[13:33:45.878]   - Field: ‘uuid’
[13:33:45.878]   - Field: ‘seed’
[13:33:45.878]   - Field: ‘version’
[13:33:45.878]   - Field: ‘result’
[13:33:45.878]   - Field: ‘asynchronous’
[13:33:45.878]   - Field: ‘calls’
[13:33:45.878]   - Field: ‘globals’
[13:33:45.879]   - Field: ‘stdout’
[13:33:45.879]   - Field: ‘earlySignal’
[13:33:45.879]   - Field: ‘lazy’
[13:33:45.879]   - Field: ‘state’
[13:33:45.879] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:45.879] - Launch lazy future ...
[13:33:45.879] Packages needed by the future expression (n = 1): ‘stats’
[13:33:45.879] Packages needed by future strategies (n = 0): <none>
[13:33:45.880] {
[13:33:45.880]     {
[13:33:45.880]         {
[13:33:45.880]             ...future.startTime <- base::Sys.time()
[13:33:45.880]             {
[13:33:45.880]                 {
[13:33:45.880]                   {
[13:33:45.880]                     {
[13:33:45.880]                       {
[13:33:45.880]                         base::local({
[13:33:45.880]                           has_future <- base::requireNamespace("future", 
[13:33:45.880]                             quietly = TRUE)
[13:33:45.880]                           if (has_future) {
[13:33:45.880]                             ns <- base::getNamespace("future")
[13:33:45.880]                             version <- ns[[".package"]][["version"]]
[13:33:45.880]                             if (is.null(version)) 
[13:33:45.880]                               version <- utils::packageVersion("future")
[13:33:45.880]                           }
[13:33:45.880]                           else {
[13:33:45.880]                             version <- NULL
[13:33:45.880]                           }
[13:33:45.880]                           if (!has_future || version < "1.8.0") {
[13:33:45.880]                             info <- base::c(r_version = base::gsub("R version ", 
[13:33:45.880]                               "", base::R.version$version.string), 
[13:33:45.880]                               platform = base::sprintf("%s (%s-bit)", 
[13:33:45.880]                                 base::R.version$platform, 8 * 
[13:33:45.880]                                   base::.Machine$sizeof.pointer), 
[13:33:45.880]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:45.880]                                 "release", "version")], collapse = " "), 
[13:33:45.880]                               hostname = base::Sys.info()[["nodename"]])
[13:33:45.880]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:33:45.880]                               info)
[13:33:45.880]                             info <- base::paste(info, collapse = "; ")
[13:33:45.880]                             if (!has_future) {
[13:33:45.880]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:45.880]                                 info)
[13:33:45.880]                             }
[13:33:45.880]                             else {
[13:33:45.880]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:45.880]                                 info, version)
[13:33:45.880]                             }
[13:33:45.880]                             base::stop(msg)
[13:33:45.880]                           }
[13:33:45.880]                         })
[13:33:45.880]                       }
[13:33:45.880]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:45.880]                       base::options(mc.cores = 1L)
[13:33:45.880]                     }
[13:33:45.880]                     base::local({
[13:33:45.880]                       for (pkg in "stats") {
[13:33:45.880]                         base::loadNamespace(pkg)
[13:33:45.880]                         base::library(pkg, character.only = TRUE)
[13:33:45.880]                       }
[13:33:45.880]                     })
[13:33:45.880]                   }
[13:33:45.880]                   ...future.strategy.old <- future::plan("list")
[13:33:45.880]                   options(future.plan = NULL)
[13:33:45.880]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:45.880]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:45.880]                 }
[13:33:45.880]                 ...future.workdir <- getwd()
[13:33:45.880]             }
[13:33:45.880]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:45.880]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:45.880]         }
[13:33:45.880]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:45.880]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:45.880]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:45.880]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:45.880]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:45.880]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:45.880]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:45.880]             base::names(...future.oldOptions))
[13:33:45.880]     }
[13:33:45.880]     if (FALSE) {
[13:33:45.880]     }
[13:33:45.880]     else {
[13:33:45.880]         if (TRUE) {
[13:33:45.880]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:45.880]                 open = "w")
[13:33:45.880]         }
[13:33:45.880]         else {
[13:33:45.880]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:45.880]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:45.880]         }
[13:33:45.880]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:45.880]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:45.880]             base::sink(type = "output", split = FALSE)
[13:33:45.880]             base::close(...future.stdout)
[13:33:45.880]         }, add = TRUE)
[13:33:45.880]     }
[13:33:45.880]     ...future.frame <- base::sys.nframe()
[13:33:45.880]     ...future.conditions <- base::list()
[13:33:45.880]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:45.880]     if (FALSE) {
[13:33:45.880]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:45.880]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:45.880]     }
[13:33:45.880]     ...future.result <- base::tryCatch({
[13:33:45.880]         base::withCallingHandlers({
[13:33:45.880]             ...future.value <- base::withVisible(base::local({
[13:33:45.880]                 ...future.makeSendCondition <- base::local({
[13:33:45.880]                   sendCondition <- NULL
[13:33:45.880]                   function(frame = 1L) {
[13:33:45.880]                     if (is.function(sendCondition)) 
[13:33:45.880]                       return(sendCondition)
[13:33:45.880]                     ns <- getNamespace("parallel")
[13:33:45.880]                     if (exists("sendData", mode = "function", 
[13:33:45.880]                       envir = ns)) {
[13:33:45.880]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:45.880]                         envir = ns)
[13:33:45.880]                       envir <- sys.frame(frame)
[13:33:45.880]                       master <- NULL
[13:33:45.880]                       while (!identical(envir, .GlobalEnv) && 
[13:33:45.880]                         !identical(envir, emptyenv())) {
[13:33:45.880]                         if (exists("master", mode = "list", envir = envir, 
[13:33:45.880]                           inherits = FALSE)) {
[13:33:45.880]                           master <- get("master", mode = "list", 
[13:33:45.880]                             envir = envir, inherits = FALSE)
[13:33:45.880]                           if (inherits(master, c("SOCKnode", 
[13:33:45.880]                             "SOCK0node"))) {
[13:33:45.880]                             sendCondition <<- function(cond) {
[13:33:45.880]                               data <- list(type = "VALUE", value = cond, 
[13:33:45.880]                                 success = TRUE)
[13:33:45.880]                               parallel_sendData(master, data)
[13:33:45.880]                             }
[13:33:45.880]                             return(sendCondition)
[13:33:45.880]                           }
[13:33:45.880]                         }
[13:33:45.880]                         frame <- frame + 1L
[13:33:45.880]                         envir <- sys.frame(frame)
[13:33:45.880]                       }
[13:33:45.880]                     }
[13:33:45.880]                     sendCondition <<- function(cond) NULL
[13:33:45.880]                   }
[13:33:45.880]                 })
[13:33:45.880]                 withCallingHandlers({
[13:33:45.880]                   {
[13:33:45.880]                     do.call(function(...) {
[13:33:45.880]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:45.880]                       if (!identical(...future.globals.maxSize.org, 
[13:33:45.880]                         ...future.globals.maxSize)) {
[13:33:45.880]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:45.880]                         on.exit(options(oopts), add = TRUE)
[13:33:45.880]                       }
[13:33:45.880]                       {
[13:33:45.880]                         lapply(seq_along(...future.elements_ii), 
[13:33:45.880]                           FUN = function(jj) {
[13:33:45.880]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:45.880]                             ...future.FUN(...future.X_jj, ...)
[13:33:45.880]                           })
[13:33:45.880]                       }
[13:33:45.880]                     }, args = future.call.arguments)
[13:33:45.880]                   }
[13:33:45.880]                 }, immediateCondition = function(cond) {
[13:33:45.880]                   sendCondition <- ...future.makeSendCondition()
[13:33:45.880]                   sendCondition(cond)
[13:33:45.880]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:45.880]                   {
[13:33:45.880]                     inherits <- base::inherits
[13:33:45.880]                     invokeRestart <- base::invokeRestart
[13:33:45.880]                     is.null <- base::is.null
[13:33:45.880]                     muffled <- FALSE
[13:33:45.880]                     if (inherits(cond, "message")) {
[13:33:45.880]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:45.880]                       if (muffled) 
[13:33:45.880]                         invokeRestart("muffleMessage")
[13:33:45.880]                     }
[13:33:45.880]                     else if (inherits(cond, "warning")) {
[13:33:45.880]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:45.880]                       if (muffled) 
[13:33:45.880]                         invokeRestart("muffleWarning")
[13:33:45.880]                     }
[13:33:45.880]                     else if (inherits(cond, "condition")) {
[13:33:45.880]                       if (!is.null(pattern)) {
[13:33:45.880]                         computeRestarts <- base::computeRestarts
[13:33:45.880]                         grepl <- base::grepl
[13:33:45.880]                         restarts <- computeRestarts(cond)
[13:33:45.880]                         for (restart in restarts) {
[13:33:45.880]                           name <- restart$name
[13:33:45.880]                           if (is.null(name)) 
[13:33:45.880]                             next
[13:33:45.880]                           if (!grepl(pattern, name)) 
[13:33:45.880]                             next
[13:33:45.880]                           invokeRestart(restart)
[13:33:45.880]                           muffled <- TRUE
[13:33:45.880]                           break
[13:33:45.880]                         }
[13:33:45.880]                       }
[13:33:45.880]                     }
[13:33:45.880]                     invisible(muffled)
[13:33:45.880]                   }
[13:33:45.880]                   muffleCondition(cond)
[13:33:45.880]                 })
[13:33:45.880]             }))
[13:33:45.880]             future::FutureResult(value = ...future.value$value, 
[13:33:45.880]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:45.880]                   ...future.rng), globalenv = if (FALSE) 
[13:33:45.880]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:45.880]                     ...future.globalenv.names))
[13:33:45.880]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:45.880]         }, condition = base::local({
[13:33:45.880]             c <- base::c
[13:33:45.880]             inherits <- base::inherits
[13:33:45.880]             invokeRestart <- base::invokeRestart
[13:33:45.880]             length <- base::length
[13:33:45.880]             list <- base::list
[13:33:45.880]             seq.int <- base::seq.int
[13:33:45.880]             signalCondition <- base::signalCondition
[13:33:45.880]             sys.calls <- base::sys.calls
[13:33:45.880]             `[[` <- base::`[[`
[13:33:45.880]             `+` <- base::`+`
[13:33:45.880]             `<<-` <- base::`<<-`
[13:33:45.880]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:45.880]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:45.880]                   3L)]
[13:33:45.880]             }
[13:33:45.880]             function(cond) {
[13:33:45.880]                 is_error <- inherits(cond, "error")
[13:33:45.880]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:45.880]                   NULL)
[13:33:45.880]                 if (is_error) {
[13:33:45.880]                   sessionInformation <- function() {
[13:33:45.880]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:45.880]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:45.880]                       search = base::search(), system = base::Sys.info())
[13:33:45.880]                   }
[13:33:45.880]                   ...future.conditions[[length(...future.conditions) + 
[13:33:45.880]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:45.880]                     cond$call), session = sessionInformation(), 
[13:33:45.880]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:45.880]                   signalCondition(cond)
[13:33:45.880]                 }
[13:33:45.880]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:45.880]                 "immediateCondition"))) {
[13:33:45.880]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:45.880]                   ...future.conditions[[length(...future.conditions) + 
[13:33:45.880]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:45.880]                   if (TRUE && !signal) {
[13:33:45.880]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:45.880]                     {
[13:33:45.880]                       inherits <- base::inherits
[13:33:45.880]                       invokeRestart <- base::invokeRestart
[13:33:45.880]                       is.null <- base::is.null
[13:33:45.880]                       muffled <- FALSE
[13:33:45.880]                       if (inherits(cond, "message")) {
[13:33:45.880]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:45.880]                         if (muffled) 
[13:33:45.880]                           invokeRestart("muffleMessage")
[13:33:45.880]                       }
[13:33:45.880]                       else if (inherits(cond, "warning")) {
[13:33:45.880]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:45.880]                         if (muffled) 
[13:33:45.880]                           invokeRestart("muffleWarning")
[13:33:45.880]                       }
[13:33:45.880]                       else if (inherits(cond, "condition")) {
[13:33:45.880]                         if (!is.null(pattern)) {
[13:33:45.880]                           computeRestarts <- base::computeRestarts
[13:33:45.880]                           grepl <- base::grepl
[13:33:45.880]                           restarts <- computeRestarts(cond)
[13:33:45.880]                           for (restart in restarts) {
[13:33:45.880]                             name <- restart$name
[13:33:45.880]                             if (is.null(name)) 
[13:33:45.880]                               next
[13:33:45.880]                             if (!grepl(pattern, name)) 
[13:33:45.880]                               next
[13:33:45.880]                             invokeRestart(restart)
[13:33:45.880]                             muffled <- TRUE
[13:33:45.880]                             break
[13:33:45.880]                           }
[13:33:45.880]                         }
[13:33:45.880]                       }
[13:33:45.880]                       invisible(muffled)
[13:33:45.880]                     }
[13:33:45.880]                     muffleCondition(cond, pattern = "^muffle")
[13:33:45.880]                   }
[13:33:45.880]                 }
[13:33:45.880]                 else {
[13:33:45.880]                   if (TRUE) {
[13:33:45.880]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:45.880]                     {
[13:33:45.880]                       inherits <- base::inherits
[13:33:45.880]                       invokeRestart <- base::invokeRestart
[13:33:45.880]                       is.null <- base::is.null
[13:33:45.880]                       muffled <- FALSE
[13:33:45.880]                       if (inherits(cond, "message")) {
[13:33:45.880]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:45.880]                         if (muffled) 
[13:33:45.880]                           invokeRestart("muffleMessage")
[13:33:45.880]                       }
[13:33:45.880]                       else if (inherits(cond, "warning")) {
[13:33:45.880]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:45.880]                         if (muffled) 
[13:33:45.880]                           invokeRestart("muffleWarning")
[13:33:45.880]                       }
[13:33:45.880]                       else if (inherits(cond, "condition")) {
[13:33:45.880]                         if (!is.null(pattern)) {
[13:33:45.880]                           computeRestarts <- base::computeRestarts
[13:33:45.880]                           grepl <- base::grepl
[13:33:45.880]                           restarts <- computeRestarts(cond)
[13:33:45.880]                           for (restart in restarts) {
[13:33:45.880]                             name <- restart$name
[13:33:45.880]                             if (is.null(name)) 
[13:33:45.880]                               next
[13:33:45.880]                             if (!grepl(pattern, name)) 
[13:33:45.880]                               next
[13:33:45.880]                             invokeRestart(restart)
[13:33:45.880]                             muffled <- TRUE
[13:33:45.880]                             break
[13:33:45.880]                           }
[13:33:45.880]                         }
[13:33:45.880]                       }
[13:33:45.880]                       invisible(muffled)
[13:33:45.880]                     }
[13:33:45.880]                     muffleCondition(cond, pattern = "^muffle")
[13:33:45.880]                   }
[13:33:45.880]                 }
[13:33:45.880]             }
[13:33:45.880]         }))
[13:33:45.880]     }, error = function(ex) {
[13:33:45.880]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:45.880]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:45.880]                 ...future.rng), started = ...future.startTime, 
[13:33:45.880]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:45.880]             version = "1.8"), class = "FutureResult")
[13:33:45.880]     }, finally = {
[13:33:45.880]         if (!identical(...future.workdir, getwd())) 
[13:33:45.880]             setwd(...future.workdir)
[13:33:45.880]         {
[13:33:45.880]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:45.880]                 ...future.oldOptions$nwarnings <- NULL
[13:33:45.880]             }
[13:33:45.880]             base::options(...future.oldOptions)
[13:33:45.880]             if (.Platform$OS.type == "windows") {
[13:33:45.880]                 old_names <- names(...future.oldEnvVars)
[13:33:45.880]                 envs <- base::Sys.getenv()
[13:33:45.880]                 names <- names(envs)
[13:33:45.880]                 common <- intersect(names, old_names)
[13:33:45.880]                 added <- setdiff(names, old_names)
[13:33:45.880]                 removed <- setdiff(old_names, names)
[13:33:45.880]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:45.880]                   envs[common]]
[13:33:45.880]                 NAMES <- toupper(changed)
[13:33:45.880]                 args <- list()
[13:33:45.880]                 for (kk in seq_along(NAMES)) {
[13:33:45.880]                   name <- changed[[kk]]
[13:33:45.880]                   NAME <- NAMES[[kk]]
[13:33:45.880]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:45.880]                     next
[13:33:45.880]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:45.880]                 }
[13:33:45.880]                 NAMES <- toupper(added)
[13:33:45.880]                 for (kk in seq_along(NAMES)) {
[13:33:45.880]                   name <- added[[kk]]
[13:33:45.880]                   NAME <- NAMES[[kk]]
[13:33:45.880]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:45.880]                     next
[13:33:45.880]                   args[[name]] <- ""
[13:33:45.880]                 }
[13:33:45.880]                 NAMES <- toupper(removed)
[13:33:45.880]                 for (kk in seq_along(NAMES)) {
[13:33:45.880]                   name <- removed[[kk]]
[13:33:45.880]                   NAME <- NAMES[[kk]]
[13:33:45.880]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:45.880]                     next
[13:33:45.880]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:45.880]                 }
[13:33:45.880]                 if (length(args) > 0) 
[13:33:45.880]                   base::do.call(base::Sys.setenv, args = args)
[13:33:45.880]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:45.880]             }
[13:33:45.880]             else {
[13:33:45.880]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:45.880]             }
[13:33:45.880]             {
[13:33:45.880]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:45.880]                   0L) {
[13:33:45.880]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:45.880]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:45.880]                   base::options(opts)
[13:33:45.880]                 }
[13:33:45.880]                 {
[13:33:45.880]                   {
[13:33:45.880]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:45.880]                     NULL
[13:33:45.880]                   }
[13:33:45.880]                   options(future.plan = NULL)
[13:33:45.880]                   if (is.na(NA_character_)) 
[13:33:45.880]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:45.880]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:45.880]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:45.880]                     .init = FALSE)
[13:33:45.880]                 }
[13:33:45.880]             }
[13:33:45.880]         }
[13:33:45.880]     })
[13:33:45.880]     if (TRUE) {
[13:33:45.880]         base::sink(type = "output", split = FALSE)
[13:33:45.880]         if (TRUE) {
[13:33:45.880]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:45.880]         }
[13:33:45.880]         else {
[13:33:45.880]             ...future.result["stdout"] <- base::list(NULL)
[13:33:45.880]         }
[13:33:45.880]         base::close(...future.stdout)
[13:33:45.880]         ...future.stdout <- NULL
[13:33:45.880]     }
[13:33:45.880]     ...future.result$conditions <- ...future.conditions
[13:33:45.880]     ...future.result$finished <- base::Sys.time()
[13:33:45.880]     ...future.result
[13:33:45.880] }
[13:33:45.883] Exporting 5 global objects (1.30 KiB) to cluster node #1 ...
[13:33:45.883] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[13:33:45.883] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[13:33:45.884] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #1 ...
[13:33:45.884] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #1 ... DONE
[13:33:45.884] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[13:33:45.884] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[13:33:45.885] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:33:45.885] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:33:45.885] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:33:45.885] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:33:45.886] Exporting 5 global objects (1.30 KiB) to cluster node #1 ... DONE
[13:33:45.886] MultisessionFuture started
[13:33:45.886] - Launch lazy future ... done
[13:33:45.886] run() for ‘MultisessionFuture’ ... done
[13:33:45.887] Created future:
[13:33:45.887] MultisessionFuture:
[13:33:45.887] Label: ‘future_eapply-1’
[13:33:45.887] Expression:
[13:33:45.887] {
[13:33:45.887]     do.call(function(...) {
[13:33:45.887]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:45.887]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:45.887]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:45.887]             on.exit(options(oopts), add = TRUE)
[13:33:45.887]         }
[13:33:45.887]         {
[13:33:45.887]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:45.887]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:45.887]                 ...future.FUN(...future.X_jj, ...)
[13:33:45.887]             })
[13:33:45.887]         }
[13:33:45.887]     }, args = future.call.arguments)
[13:33:45.887] }
[13:33:45.887] Lazy evaluation: FALSE
[13:33:45.887] Asynchronous evaluation: TRUE
[13:33:45.887] Local evaluation: TRUE
[13:33:45.887] Environment: R_GlobalEnv
[13:33:45.887] Capture standard output: TRUE
[13:33:45.887] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:45.887] Globals: 5 objects totaling 1.36 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:45.887] Packages: 1 packages (‘stats’)
[13:33:45.887] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:45.887] Resolved: FALSE
[13:33:45.887] Value: <not collected>
[13:33:45.887] Conditions captured: <none>
[13:33:45.887] Early signaling: FALSE
[13:33:45.887] Owner process: b6e93464-7fc2-3f8d-23d1-d8004201d1f1
[13:33:45.887] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:45.898] Chunk #1 of 2 ... DONE
[13:33:45.898] Chunk #2 of 2 ...
[13:33:45.899]  - Finding globals in 'X' for chunk #2 ...
[13:33:45.899] getGlobalsAndPackages() ...
[13:33:45.899] Searching for globals...
[13:33:45.899] 
[13:33:45.899] Searching for globals ... DONE
[13:33:45.899] - globals: [0] <none>
[13:33:45.900] getGlobalsAndPackages() ... DONE
[13:33:45.900]    + additional globals found: [n=0] 
[13:33:45.900]    + additional namespaces needed: [n=0] 
[13:33:45.900]  - Finding globals in 'X' for chunk #2 ... DONE
[13:33:45.900]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:45.900]  - seeds: <none>
[13:33:45.900]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:45.900] getGlobalsAndPackages() ...
[13:33:45.900] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:45.900] Resolving globals: FALSE
[13:33:45.901] Tweak future expression to call with '...' arguments ...
[13:33:45.901] {
[13:33:45.901]     do.call(function(...) {
[13:33:45.901]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:45.901]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:45.901]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:45.901]             on.exit(options(oopts), add = TRUE)
[13:33:45.901]         }
[13:33:45.901]         {
[13:33:45.901]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:45.901]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:45.901]                 ...future.FUN(...future.X_jj, ...)
[13:33:45.901]             })
[13:33:45.901]         }
[13:33:45.901]     }, args = future.call.arguments)
[13:33:45.901] }
[13:33:45.901] Tweak future expression to call with '...' arguments ... DONE
[13:33:45.901] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:45.901] - packages: [1] ‘stats’
[13:33:45.901] getGlobalsAndPackages() ... DONE
[13:33:45.902] run() for ‘Future’ ...
[13:33:45.902] - state: ‘created’
[13:33:45.902] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:45.916] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:45.916] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:45.916]   - Field: ‘node’
[13:33:45.916]   - Field: ‘label’
[13:33:45.916]   - Field: ‘local’
[13:33:45.916]   - Field: ‘owner’
[13:33:45.916]   - Field: ‘envir’
[13:33:45.916]   - Field: ‘workers’
[13:33:45.916]   - Field: ‘packages’
[13:33:45.916]   - Field: ‘gc’
[13:33:45.917]   - Field: ‘conditions’
[13:33:45.917]   - Field: ‘persistent’
[13:33:45.917]   - Field: ‘expr’
[13:33:45.917]   - Field: ‘uuid’
[13:33:45.917]   - Field: ‘seed’
[13:33:45.917]   - Field: ‘version’
[13:33:45.917]   - Field: ‘result’
[13:33:45.917]   - Field: ‘asynchronous’
[13:33:45.917]   - Field: ‘calls’
[13:33:45.917]   - Field: ‘globals’
[13:33:45.917]   - Field: ‘stdout’
[13:33:45.918]   - Field: ‘earlySignal’
[13:33:45.918]   - Field: ‘lazy’
[13:33:45.918]   - Field: ‘state’
[13:33:45.918] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:45.918] - Launch lazy future ...
[13:33:45.918] Packages needed by the future expression (n = 1): ‘stats’
[13:33:45.918] Packages needed by future strategies (n = 0): <none>
[13:33:45.919] {
[13:33:45.919]     {
[13:33:45.919]         {
[13:33:45.919]             ...future.startTime <- base::Sys.time()
[13:33:45.919]             {
[13:33:45.919]                 {
[13:33:45.919]                   {
[13:33:45.919]                     {
[13:33:45.919]                       {
[13:33:45.919]                         base::local({
[13:33:45.919]                           has_future <- base::requireNamespace("future", 
[13:33:45.919]                             quietly = TRUE)
[13:33:45.919]                           if (has_future) {
[13:33:45.919]                             ns <- base::getNamespace("future")
[13:33:45.919]                             version <- ns[[".package"]][["version"]]
[13:33:45.919]                             if (is.null(version)) 
[13:33:45.919]                               version <- utils::packageVersion("future")
[13:33:45.919]                           }
[13:33:45.919]                           else {
[13:33:45.919]                             version <- NULL
[13:33:45.919]                           }
[13:33:45.919]                           if (!has_future || version < "1.8.0") {
[13:33:45.919]                             info <- base::c(r_version = base::gsub("R version ", 
[13:33:45.919]                               "", base::R.version$version.string), 
[13:33:45.919]                               platform = base::sprintf("%s (%s-bit)", 
[13:33:45.919]                                 base::R.version$platform, 8 * 
[13:33:45.919]                                   base::.Machine$sizeof.pointer), 
[13:33:45.919]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:45.919]                                 "release", "version")], collapse = " "), 
[13:33:45.919]                               hostname = base::Sys.info()[["nodename"]])
[13:33:45.919]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:33:45.919]                               info)
[13:33:45.919]                             info <- base::paste(info, collapse = "; ")
[13:33:45.919]                             if (!has_future) {
[13:33:45.919]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:45.919]                                 info)
[13:33:45.919]                             }
[13:33:45.919]                             else {
[13:33:45.919]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:45.919]                                 info, version)
[13:33:45.919]                             }
[13:33:45.919]                             base::stop(msg)
[13:33:45.919]                           }
[13:33:45.919]                         })
[13:33:45.919]                       }
[13:33:45.919]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:45.919]                       base::options(mc.cores = 1L)
[13:33:45.919]                     }
[13:33:45.919]                     base::local({
[13:33:45.919]                       for (pkg in "stats") {
[13:33:45.919]                         base::loadNamespace(pkg)
[13:33:45.919]                         base::library(pkg, character.only = TRUE)
[13:33:45.919]                       }
[13:33:45.919]                     })
[13:33:45.919]                   }
[13:33:45.919]                   ...future.strategy.old <- future::plan("list")
[13:33:45.919]                   options(future.plan = NULL)
[13:33:45.919]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:45.919]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:45.919]                 }
[13:33:45.919]                 ...future.workdir <- getwd()
[13:33:45.919]             }
[13:33:45.919]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:45.919]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:45.919]         }
[13:33:45.919]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:45.919]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:45.919]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:45.919]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:45.919]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:45.919]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:45.919]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:45.919]             base::names(...future.oldOptions))
[13:33:45.919]     }
[13:33:45.919]     if (FALSE) {
[13:33:45.919]     }
[13:33:45.919]     else {
[13:33:45.919]         if (TRUE) {
[13:33:45.919]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:45.919]                 open = "w")
[13:33:45.919]         }
[13:33:45.919]         else {
[13:33:45.919]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:45.919]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:45.919]         }
[13:33:45.919]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:45.919]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:45.919]             base::sink(type = "output", split = FALSE)
[13:33:45.919]             base::close(...future.stdout)
[13:33:45.919]         }, add = TRUE)
[13:33:45.919]     }
[13:33:45.919]     ...future.frame <- base::sys.nframe()
[13:33:45.919]     ...future.conditions <- base::list()
[13:33:45.919]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:45.919]     if (FALSE) {
[13:33:45.919]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:45.919]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:45.919]     }
[13:33:45.919]     ...future.result <- base::tryCatch({
[13:33:45.919]         base::withCallingHandlers({
[13:33:45.919]             ...future.value <- base::withVisible(base::local({
[13:33:45.919]                 ...future.makeSendCondition <- base::local({
[13:33:45.919]                   sendCondition <- NULL
[13:33:45.919]                   function(frame = 1L) {
[13:33:45.919]                     if (is.function(sendCondition)) 
[13:33:45.919]                       return(sendCondition)
[13:33:45.919]                     ns <- getNamespace("parallel")
[13:33:45.919]                     if (exists("sendData", mode = "function", 
[13:33:45.919]                       envir = ns)) {
[13:33:45.919]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:45.919]                         envir = ns)
[13:33:45.919]                       envir <- sys.frame(frame)
[13:33:45.919]                       master <- NULL
[13:33:45.919]                       while (!identical(envir, .GlobalEnv) && 
[13:33:45.919]                         !identical(envir, emptyenv())) {
[13:33:45.919]                         if (exists("master", mode = "list", envir = envir, 
[13:33:45.919]                           inherits = FALSE)) {
[13:33:45.919]                           master <- get("master", mode = "list", 
[13:33:45.919]                             envir = envir, inherits = FALSE)
[13:33:45.919]                           if (inherits(master, c("SOCKnode", 
[13:33:45.919]                             "SOCK0node"))) {
[13:33:45.919]                             sendCondition <<- function(cond) {
[13:33:45.919]                               data <- list(type = "VALUE", value = cond, 
[13:33:45.919]                                 success = TRUE)
[13:33:45.919]                               parallel_sendData(master, data)
[13:33:45.919]                             }
[13:33:45.919]                             return(sendCondition)
[13:33:45.919]                           }
[13:33:45.919]                         }
[13:33:45.919]                         frame <- frame + 1L
[13:33:45.919]                         envir <- sys.frame(frame)
[13:33:45.919]                       }
[13:33:45.919]                     }
[13:33:45.919]                     sendCondition <<- function(cond) NULL
[13:33:45.919]                   }
[13:33:45.919]                 })
[13:33:45.919]                 withCallingHandlers({
[13:33:45.919]                   {
[13:33:45.919]                     do.call(function(...) {
[13:33:45.919]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:45.919]                       if (!identical(...future.globals.maxSize.org, 
[13:33:45.919]                         ...future.globals.maxSize)) {
[13:33:45.919]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:45.919]                         on.exit(options(oopts), add = TRUE)
[13:33:45.919]                       }
[13:33:45.919]                       {
[13:33:45.919]                         lapply(seq_along(...future.elements_ii), 
[13:33:45.919]                           FUN = function(jj) {
[13:33:45.919]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:45.919]                             ...future.FUN(...future.X_jj, ...)
[13:33:45.919]                           })
[13:33:45.919]                       }
[13:33:45.919]                     }, args = future.call.arguments)
[13:33:45.919]                   }
[13:33:45.919]                 }, immediateCondition = function(cond) {
[13:33:45.919]                   sendCondition <- ...future.makeSendCondition()
[13:33:45.919]                   sendCondition(cond)
[13:33:45.919]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:45.919]                   {
[13:33:45.919]                     inherits <- base::inherits
[13:33:45.919]                     invokeRestart <- base::invokeRestart
[13:33:45.919]                     is.null <- base::is.null
[13:33:45.919]                     muffled <- FALSE
[13:33:45.919]                     if (inherits(cond, "message")) {
[13:33:45.919]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:45.919]                       if (muffled) 
[13:33:45.919]                         invokeRestart("muffleMessage")
[13:33:45.919]                     }
[13:33:45.919]                     else if (inherits(cond, "warning")) {
[13:33:45.919]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:45.919]                       if (muffled) 
[13:33:45.919]                         invokeRestart("muffleWarning")
[13:33:45.919]                     }
[13:33:45.919]                     else if (inherits(cond, "condition")) {
[13:33:45.919]                       if (!is.null(pattern)) {
[13:33:45.919]                         computeRestarts <- base::computeRestarts
[13:33:45.919]                         grepl <- base::grepl
[13:33:45.919]                         restarts <- computeRestarts(cond)
[13:33:45.919]                         for (restart in restarts) {
[13:33:45.919]                           name <- restart$name
[13:33:45.919]                           if (is.null(name)) 
[13:33:45.919]                             next
[13:33:45.919]                           if (!grepl(pattern, name)) 
[13:33:45.919]                             next
[13:33:45.919]                           invokeRestart(restart)
[13:33:45.919]                           muffled <- TRUE
[13:33:45.919]                           break
[13:33:45.919]                         }
[13:33:45.919]                       }
[13:33:45.919]                     }
[13:33:45.919]                     invisible(muffled)
[13:33:45.919]                   }
[13:33:45.919]                   muffleCondition(cond)
[13:33:45.919]                 })
[13:33:45.919]             }))
[13:33:45.919]             future::FutureResult(value = ...future.value$value, 
[13:33:45.919]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:45.919]                   ...future.rng), globalenv = if (FALSE) 
[13:33:45.919]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:45.919]                     ...future.globalenv.names))
[13:33:45.919]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:45.919]         }, condition = base::local({
[13:33:45.919]             c <- base::c
[13:33:45.919]             inherits <- base::inherits
[13:33:45.919]             invokeRestart <- base::invokeRestart
[13:33:45.919]             length <- base::length
[13:33:45.919]             list <- base::list
[13:33:45.919]             seq.int <- base::seq.int
[13:33:45.919]             signalCondition <- base::signalCondition
[13:33:45.919]             sys.calls <- base::sys.calls
[13:33:45.919]             `[[` <- base::`[[`
[13:33:45.919]             `+` <- base::`+`
[13:33:45.919]             `<<-` <- base::`<<-`
[13:33:45.919]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:45.919]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:45.919]                   3L)]
[13:33:45.919]             }
[13:33:45.919]             function(cond) {
[13:33:45.919]                 is_error <- inherits(cond, "error")
[13:33:45.919]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:45.919]                   NULL)
[13:33:45.919]                 if (is_error) {
[13:33:45.919]                   sessionInformation <- function() {
[13:33:45.919]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:45.919]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:45.919]                       search = base::search(), system = base::Sys.info())
[13:33:45.919]                   }
[13:33:45.919]                   ...future.conditions[[length(...future.conditions) + 
[13:33:45.919]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:45.919]                     cond$call), session = sessionInformation(), 
[13:33:45.919]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:45.919]                   signalCondition(cond)
[13:33:45.919]                 }
[13:33:45.919]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:45.919]                 "immediateCondition"))) {
[13:33:45.919]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:45.919]                   ...future.conditions[[length(...future.conditions) + 
[13:33:45.919]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:45.919]                   if (TRUE && !signal) {
[13:33:45.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:45.919]                     {
[13:33:45.919]                       inherits <- base::inherits
[13:33:45.919]                       invokeRestart <- base::invokeRestart
[13:33:45.919]                       is.null <- base::is.null
[13:33:45.919]                       muffled <- FALSE
[13:33:45.919]                       if (inherits(cond, "message")) {
[13:33:45.919]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:45.919]                         if (muffled) 
[13:33:45.919]                           invokeRestart("muffleMessage")
[13:33:45.919]                       }
[13:33:45.919]                       else if (inherits(cond, "warning")) {
[13:33:45.919]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:45.919]                         if (muffled) 
[13:33:45.919]                           invokeRestart("muffleWarning")
[13:33:45.919]                       }
[13:33:45.919]                       else if (inherits(cond, "condition")) {
[13:33:45.919]                         if (!is.null(pattern)) {
[13:33:45.919]                           computeRestarts <- base::computeRestarts
[13:33:45.919]                           grepl <- base::grepl
[13:33:45.919]                           restarts <- computeRestarts(cond)
[13:33:45.919]                           for (restart in restarts) {
[13:33:45.919]                             name <- restart$name
[13:33:45.919]                             if (is.null(name)) 
[13:33:45.919]                               next
[13:33:45.919]                             if (!grepl(pattern, name)) 
[13:33:45.919]                               next
[13:33:45.919]                             invokeRestart(restart)
[13:33:45.919]                             muffled <- TRUE
[13:33:45.919]                             break
[13:33:45.919]                           }
[13:33:45.919]                         }
[13:33:45.919]                       }
[13:33:45.919]                       invisible(muffled)
[13:33:45.919]                     }
[13:33:45.919]                     muffleCondition(cond, pattern = "^muffle")
[13:33:45.919]                   }
[13:33:45.919]                 }
[13:33:45.919]                 else {
[13:33:45.919]                   if (TRUE) {
[13:33:45.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:45.919]                     {
[13:33:45.919]                       inherits <- base::inherits
[13:33:45.919]                       invokeRestart <- base::invokeRestart
[13:33:45.919]                       is.null <- base::is.null
[13:33:45.919]                       muffled <- FALSE
[13:33:45.919]                       if (inherits(cond, "message")) {
[13:33:45.919]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:45.919]                         if (muffled) 
[13:33:45.919]                           invokeRestart("muffleMessage")
[13:33:45.919]                       }
[13:33:45.919]                       else if (inherits(cond, "warning")) {
[13:33:45.919]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:45.919]                         if (muffled) 
[13:33:45.919]                           invokeRestart("muffleWarning")
[13:33:45.919]                       }
[13:33:45.919]                       else if (inherits(cond, "condition")) {
[13:33:45.919]                         if (!is.null(pattern)) {
[13:33:45.919]                           computeRestarts <- base::computeRestarts
[13:33:45.919]                           grepl <- base::grepl
[13:33:45.919]                           restarts <- computeRestarts(cond)
[13:33:45.919]                           for (restart in restarts) {
[13:33:45.919]                             name <- restart$name
[13:33:45.919]                             if (is.null(name)) 
[13:33:45.919]                               next
[13:33:45.919]                             if (!grepl(pattern, name)) 
[13:33:45.919]                               next
[13:33:45.919]                             invokeRestart(restart)
[13:33:45.919]                             muffled <- TRUE
[13:33:45.919]                             break
[13:33:45.919]                           }
[13:33:45.919]                         }
[13:33:45.919]                       }
[13:33:45.919]                       invisible(muffled)
[13:33:45.919]                     }
[13:33:45.919]                     muffleCondition(cond, pattern = "^muffle")
[13:33:45.919]                   }
[13:33:45.919]                 }
[13:33:45.919]             }
[13:33:45.919]         }))
[13:33:45.919]     }, error = function(ex) {
[13:33:45.919]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:45.919]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:45.919]                 ...future.rng), started = ...future.startTime, 
[13:33:45.919]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:45.919]             version = "1.8"), class = "FutureResult")
[13:33:45.919]     }, finally = {
[13:33:45.919]         if (!identical(...future.workdir, getwd())) 
[13:33:45.919]             setwd(...future.workdir)
[13:33:45.919]         {
[13:33:45.919]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:45.919]                 ...future.oldOptions$nwarnings <- NULL
[13:33:45.919]             }
[13:33:45.919]             base::options(...future.oldOptions)
[13:33:45.919]             if (.Platform$OS.type == "windows") {
[13:33:45.919]                 old_names <- names(...future.oldEnvVars)
[13:33:45.919]                 envs <- base::Sys.getenv()
[13:33:45.919]                 names <- names(envs)
[13:33:45.919]                 common <- intersect(names, old_names)
[13:33:45.919]                 added <- setdiff(names, old_names)
[13:33:45.919]                 removed <- setdiff(old_names, names)
[13:33:45.919]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:45.919]                   envs[common]]
[13:33:45.919]                 NAMES <- toupper(changed)
[13:33:45.919]                 args <- list()
[13:33:45.919]                 for (kk in seq_along(NAMES)) {
[13:33:45.919]                   name <- changed[[kk]]
[13:33:45.919]                   NAME <- NAMES[[kk]]
[13:33:45.919]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:45.919]                     next
[13:33:45.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:45.919]                 }
[13:33:45.919]                 NAMES <- toupper(added)
[13:33:45.919]                 for (kk in seq_along(NAMES)) {
[13:33:45.919]                   name <- added[[kk]]
[13:33:45.919]                   NAME <- NAMES[[kk]]
[13:33:45.919]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:45.919]                     next
[13:33:45.919]                   args[[name]] <- ""
[13:33:45.919]                 }
[13:33:45.919]                 NAMES <- toupper(removed)
[13:33:45.919]                 for (kk in seq_along(NAMES)) {
[13:33:45.919]                   name <- removed[[kk]]
[13:33:45.919]                   NAME <- NAMES[[kk]]
[13:33:45.919]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:45.919]                     next
[13:33:45.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:45.919]                 }
[13:33:45.919]                 if (length(args) > 0) 
[13:33:45.919]                   base::do.call(base::Sys.setenv, args = args)
[13:33:45.919]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:45.919]             }
[13:33:45.919]             else {
[13:33:45.919]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:45.919]             }
[13:33:45.919]             {
[13:33:45.919]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:45.919]                   0L) {
[13:33:45.919]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:45.919]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:45.919]                   base::options(opts)
[13:33:45.919]                 }
[13:33:45.919]                 {
[13:33:45.919]                   {
[13:33:45.919]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:45.919]                     NULL
[13:33:45.919]                   }
[13:33:45.919]                   options(future.plan = NULL)
[13:33:45.919]                   if (is.na(NA_character_)) 
[13:33:45.919]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:45.919]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:45.919]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:45.919]                     .init = FALSE)
[13:33:45.919]                 }
[13:33:45.919]             }
[13:33:45.919]         }
[13:33:45.919]     })
[13:33:45.919]     if (TRUE) {
[13:33:45.919]         base::sink(type = "output", split = FALSE)
[13:33:45.919]         if (TRUE) {
[13:33:45.919]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:45.919]         }
[13:33:45.919]         else {
[13:33:45.919]             ...future.result["stdout"] <- base::list(NULL)
[13:33:45.919]         }
[13:33:45.919]         base::close(...future.stdout)
[13:33:45.919]         ...future.stdout <- NULL
[13:33:45.919]     }
[13:33:45.919]     ...future.result$conditions <- ...future.conditions
[13:33:45.919]     ...future.result$finished <- base::Sys.time()
[13:33:45.919]     ...future.result
[13:33:45.919] }
[13:33:45.921] Exporting 5 global objects (1.30 KiB) to cluster node #2 ...
[13:33:45.922] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[13:33:45.922] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[13:33:45.922] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #2 ...
[13:33:45.923] Exporting ‘future.call.arguments’ (80 bytes) to cluster node #2 ... DONE
[13:33:45.923] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[13:33:45.923] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[13:33:45.923] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:33:45.924] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:33:45.924] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:33:45.928] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:33:45.928] Exporting 5 global objects (1.30 KiB) to cluster node #2 ... DONE
[13:33:45.929] MultisessionFuture started
[13:33:45.929] - Launch lazy future ... done
[13:33:45.929] run() for ‘MultisessionFuture’ ... done
[13:33:45.929] Created future:
[13:33:45.929] MultisessionFuture:
[13:33:45.929] Label: ‘future_eapply-2’
[13:33:45.929] Expression:
[13:33:45.929] {
[13:33:45.929]     do.call(function(...) {
[13:33:45.929]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:45.929]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:45.929]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:45.929]             on.exit(options(oopts), add = TRUE)
[13:33:45.929]         }
[13:33:45.929]         {
[13:33:45.929]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:45.929]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:45.929]                 ...future.FUN(...future.X_jj, ...)
[13:33:45.929]             })
[13:33:45.929]         }
[13:33:45.929]     }, args = future.call.arguments)
[13:33:45.929] }
[13:33:45.929] Lazy evaluation: FALSE
[13:33:45.929] Asynchronous evaluation: TRUE
[13:33:45.929] Local evaluation: TRUE
[13:33:45.929] Environment: R_GlobalEnv
[13:33:45.929] Capture standard output: TRUE
[13:33:45.929] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:45.929] Globals: 5 objects totaling 1.50 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 80 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:45.929] Packages: 1 packages (‘stats’)
[13:33:45.929] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:45.929] Resolved: FALSE
[13:33:45.929] Value: <not collected>
[13:33:45.929] Conditions captured: <none>
[13:33:45.929] Early signaling: FALSE
[13:33:45.929] Owner process: b6e93464-7fc2-3f8d-23d1-d8004201d1f1
[13:33:45.929] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:45.941] Chunk #2 of 2 ... DONE
[13:33:45.941] Launching 2 futures (chunks) ... DONE
[13:33:45.941] Resolving 2 futures (chunks) ...
[13:33:45.942] resolve() on list ...
[13:33:45.942]  recursive: 0
[13:33:45.942]  length: 2
[13:33:45.942] 
[13:33:45.942] receiveMessageFromWorker() for ClusterFuture ...
[13:33:45.942] - Validating connection of MultisessionFuture
[13:33:45.943] - received message: FutureResult
[13:33:45.943] - Received FutureResult
[13:33:45.943] - Erased future from FutureRegistry
[13:33:45.943] result() for ClusterFuture ...
[13:33:45.943] - result already collected: FutureResult
[13:33:45.943] result() for ClusterFuture ... done
[13:33:45.943] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:45.943] Future #1
[13:33:45.943] result() for ClusterFuture ...
[13:33:45.943] - result already collected: FutureResult
[13:33:45.944] result() for ClusterFuture ... done
[13:33:45.944] result() for ClusterFuture ...
[13:33:45.944] - result already collected: FutureResult
[13:33:45.944] result() for ClusterFuture ... done
[13:33:45.944] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:33:45.944] - nx: 2
[13:33:45.944] - relay: TRUE
[13:33:45.944] - stdout: TRUE
[13:33:45.944] - signal: TRUE
[13:33:45.944] - resignal: FALSE
[13:33:45.944] - force: TRUE
[13:33:45.945] - relayed: [n=2] FALSE, FALSE
[13:33:45.945] - queued futures: [n=2] FALSE, FALSE
[13:33:45.945]  - until=1
[13:33:45.945]  - relaying element #1
[13:33:45.945] result() for ClusterFuture ...
[13:33:45.945] - result already collected: FutureResult
[13:33:45.945] result() for ClusterFuture ... done
[13:33:45.945] result() for ClusterFuture ...
[13:33:45.945] - result already collected: FutureResult
[13:33:45.945] result() for ClusterFuture ... done
[13:33:45.945] result() for ClusterFuture ...
[13:33:45.946] - result already collected: FutureResult
[13:33:45.946] result() for ClusterFuture ... done
[13:33:45.946] result() for ClusterFuture ...
[13:33:45.946] - result already collected: FutureResult
[13:33:45.946] result() for ClusterFuture ... done
[13:33:45.946] - relayed: [n=2] TRUE, FALSE
[13:33:45.946] - queued futures: [n=2] TRUE, FALSE
[13:33:45.946] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:33:45.946]  length: 1 (resolved future 1)
[13:33:45.974] receiveMessageFromWorker() for ClusterFuture ...
[13:33:45.974] - Validating connection of MultisessionFuture
[13:33:45.974] - received message: FutureResult
[13:33:45.974] - Received FutureResult
[13:33:45.974] - Erased future from FutureRegistry
[13:33:45.975] result() for ClusterFuture ...
[13:33:45.975] - result already collected: FutureResult
[13:33:45.975] result() for ClusterFuture ... done
[13:33:45.975] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:45.975] Future #2
[13:33:45.975] result() for ClusterFuture ...
[13:33:45.975] - result already collected: FutureResult
[13:33:45.975] result() for ClusterFuture ... done
[13:33:45.975] result() for ClusterFuture ...
[13:33:45.975] - result already collected: FutureResult
[13:33:45.975] result() for ClusterFuture ... done
[13:33:45.976] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:33:45.976] - nx: 2
[13:33:45.976] - relay: TRUE
[13:33:45.976] - stdout: TRUE
[13:33:45.976] - signal: TRUE
[13:33:45.976] - resignal: FALSE
[13:33:45.976] - force: TRUE
[13:33:45.976] - relayed: [n=2] TRUE, FALSE
[13:33:45.976] - queued futures: [n=2] TRUE, FALSE
[13:33:45.976]  - until=2
[13:33:45.976]  - relaying element #2
[13:33:45.977] result() for ClusterFuture ...
[13:33:45.977] - result already collected: FutureResult
[13:33:45.977] result() for ClusterFuture ... done
[13:33:45.977] result() for ClusterFuture ...
[13:33:45.977] - result already collected: FutureResult
[13:33:45.977] result() for ClusterFuture ... done
[13:33:45.977] result() for ClusterFuture ...
[13:33:45.977] - result already collected: FutureResult
[13:33:45.977] result() for ClusterFuture ... done
[13:33:45.977] result() for ClusterFuture ...
[13:33:45.977] - result already collected: FutureResult
[13:33:45.978] result() for ClusterFuture ... done
[13:33:45.978] - relayed: [n=2] TRUE, TRUE
[13:33:45.978] - queued futures: [n=2] TRUE, TRUE
[13:33:45.978] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:33:45.978]  length: 0 (resolved future 2)
[13:33:45.978] Relaying remaining futures
[13:33:45.978] signalConditionsASAP(NULL, pos=0) ...
[13:33:45.978] - nx: 2
[13:33:45.978] - relay: TRUE
[13:33:45.978] - stdout: TRUE
[13:33:45.978] - signal: TRUE
[13:33:45.978] - resignal: FALSE
[13:33:45.979] - force: TRUE
[13:33:45.979] - relayed: [n=2] TRUE, TRUE
[13:33:45.979] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:45.979] - relayed: [n=2] TRUE, TRUE
[13:33:45.979] - queued futures: [n=2] TRUE, TRUE
[13:33:45.979] signalConditionsASAP(NULL, pos=0) ... done
[13:33:45.979] resolve() on list ... DONE
[13:33:45.979] result() for ClusterFuture ...
[13:33:45.979] - result already collected: FutureResult
[13:33:45.979] result() for ClusterFuture ... done
[13:33:45.979] result() for ClusterFuture ...
[13:33:45.980] - result already collected: FutureResult
[13:33:45.980] result() for ClusterFuture ... done
[13:33:45.980] result() for ClusterFuture ...
[13:33:45.980] - result already collected: FutureResult
[13:33:45.980] result() for ClusterFuture ... done
[13:33:45.980] result() for ClusterFuture ...
[13:33:45.980] - result already collected: FutureResult
[13:33:45.980] result() for ClusterFuture ... done
[13:33:45.980]  - Number of value chunks collected: 2
[13:33:45.980] Resolving 2 futures (chunks) ... DONE
[13:33:45.981] Reducing values from 2 chunks ...
[13:33:45.981]  - Number of values collected after concatenation: 3
[13:33:45.981]  - Number of values expected: 3
[13:33:45.981] Reducing values from 2 chunks ... DONE
[13:33:45.981] future_lapply() ... DONE
[13:33:45.982] future_lapply() ...
[13:33:45.986] Number of chunks: 2
[13:33:45.986] getGlobalsAndPackagesXApply() ...
[13:33:45.986]  - future.globals: TRUE
[13:33:45.986] getGlobalsAndPackages() ...
[13:33:45.986] Searching for globals...
[13:33:45.987] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:45.988] Searching for globals ... DONE
[13:33:45.988] Resolving globals: FALSE
[13:33:45.988] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:33:45.988] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:33:45.988] - globals: [1] ‘FUN’
[13:33:45.989] - packages: [1] ‘stats’
[13:33:45.989] getGlobalsAndPackages() ... DONE
[13:33:45.989]  - globals found/used: [n=1] ‘FUN’
[13:33:45.989]  - needed namespaces: [n=1] ‘stats’
[13:33:45.989] Finding globals ... DONE
[13:33:45.989]  - use_args: TRUE
[13:33:45.989]  - Getting '...' globals ...
[13:33:45.990] resolve() on list ...
[13:33:45.990]  recursive: 0
[13:33:45.990]  length: 1
[13:33:45.990]  elements: ‘...’
[13:33:45.990]  length: 0 (resolved future 1)
[13:33:45.990] resolve() on list ... DONE
[13:33:45.990]    - '...' content: [n=0] 
[13:33:45.990] List of 1
[13:33:45.990]  $ ...: list()
[13:33:45.990]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:45.990]  - attr(*, "where")=List of 1
[13:33:45.990]   ..$ ...:<environment: 0x5598482d5d00> 
[13:33:45.990]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:45.990]  - attr(*, "resolved")= logi TRUE
[13:33:45.990]  - attr(*, "total_size")= num NA
[13:33:45.995]  - Getting '...' globals ... DONE
[13:33:45.995] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:45.995] List of 2
[13:33:45.995]  $ ...future.FUN:function (x, ...)  
[13:33:45.995]  $ ...          : list()
[13:33:45.995]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:45.995]  - attr(*, "where")=List of 2
[13:33:45.995]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:45.995]   ..$ ...          :<environment: 0x5598482d5d00> 
[13:33:45.995]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:45.995]  - attr(*, "resolved")= logi FALSE
[13:33:45.995]  - attr(*, "total_size")= num 1248
[13:33:45.998] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:45.998] getGlobalsAndPackagesXApply() ... DONE
[13:33:45.998] Number of futures (= number of chunks): 2
[13:33:45.998] Launching 2 futures (chunks) ...
[13:33:45.998] Chunk #1 of 2 ...
[13:33:45.998]  - Finding globals in 'X' for chunk #1 ...
[13:33:45.999] getGlobalsAndPackages() ...
[13:33:45.999] Searching for globals...
[13:33:45.999] 
[13:33:45.999] Searching for globals ... DONE
[13:33:45.999] - globals: [0] <none>
[13:33:45.999] getGlobalsAndPackages() ... DONE
[13:33:45.999]    + additional globals found: [n=0] 
[13:33:45.999]    + additional namespaces needed: [n=0] 
[13:33:45.999]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:45.999]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:46.000]  - seeds: <none>
[13:33:46.000]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:46.000] getGlobalsAndPackages() ...
[13:33:46.000] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:46.000] Resolving globals: FALSE
[13:33:46.000] Tweak future expression to call with '...' arguments ...
[13:33:46.000] {
[13:33:46.000]     do.call(function(...) {
[13:33:46.000]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:46.000]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:46.000]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:46.000]             on.exit(options(oopts), add = TRUE)
[13:33:46.000]         }
[13:33:46.000]         {
[13:33:46.000]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:46.000]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:46.000]                 ...future.FUN(...future.X_jj, ...)
[13:33:46.000]             })
[13:33:46.000]         }
[13:33:46.000]     }, args = future.call.arguments)
[13:33:46.000] }
[13:33:46.000] Tweak future expression to call with '...' arguments ... DONE
[13:33:46.001] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:46.001] - packages: [1] ‘stats’
[13:33:46.001] getGlobalsAndPackages() ... DONE
[13:33:46.001] run() for ‘Future’ ...
[13:33:46.001] - state: ‘created’
[13:33:46.002] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:46.015] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:46.015] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:46.015]   - Field: ‘node’
[13:33:46.016]   - Field: ‘label’
[13:33:46.016]   - Field: ‘local’
[13:33:46.016]   - Field: ‘owner’
[13:33:46.016]   - Field: ‘envir’
[13:33:46.016]   - Field: ‘workers’
[13:33:46.016]   - Field: ‘packages’
[13:33:46.016]   - Field: ‘gc’
[13:33:46.016]   - Field: ‘conditions’
[13:33:46.016]   - Field: ‘persistent’
[13:33:46.016]   - Field: ‘expr’
[13:33:46.016]   - Field: ‘uuid’
[13:33:46.017]   - Field: ‘seed’
[13:33:46.017]   - Field: ‘version’
[13:33:46.017]   - Field: ‘result’
[13:33:46.017]   - Field: ‘asynchronous’
[13:33:46.017]   - Field: ‘calls’
[13:33:46.017]   - Field: ‘globals’
[13:33:46.017]   - Field: ‘stdout’
[13:33:46.017]   - Field: ‘earlySignal’
[13:33:46.017]   - Field: ‘lazy’
[13:33:46.017]   - Field: ‘state’
[13:33:46.017] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:46.018] - Launch lazy future ...
[13:33:46.018] Packages needed by the future expression (n = 1): ‘stats’
[13:33:46.018] Packages needed by future strategies (n = 0): <none>
[13:33:46.018] {
[13:33:46.018]     {
[13:33:46.018]         {
[13:33:46.018]             ...future.startTime <- base::Sys.time()
[13:33:46.018]             {
[13:33:46.018]                 {
[13:33:46.018]                   {
[13:33:46.018]                     {
[13:33:46.018]                       {
[13:33:46.018]                         base::local({
[13:33:46.018]                           has_future <- base::requireNamespace("future", 
[13:33:46.018]                             quietly = TRUE)
[13:33:46.018]                           if (has_future) {
[13:33:46.018]                             ns <- base::getNamespace("future")
[13:33:46.018]                             version <- ns[[".package"]][["version"]]
[13:33:46.018]                             if (is.null(version)) 
[13:33:46.018]                               version <- utils::packageVersion("future")
[13:33:46.018]                           }
[13:33:46.018]                           else {
[13:33:46.018]                             version <- NULL
[13:33:46.018]                           }
[13:33:46.018]                           if (!has_future || version < "1.8.0") {
[13:33:46.018]                             info <- base::c(r_version = base::gsub("R version ", 
[13:33:46.018]                               "", base::R.version$version.string), 
[13:33:46.018]                               platform = base::sprintf("%s (%s-bit)", 
[13:33:46.018]                                 base::R.version$platform, 8 * 
[13:33:46.018]                                   base::.Machine$sizeof.pointer), 
[13:33:46.018]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:46.018]                                 "release", "version")], collapse = " "), 
[13:33:46.018]                               hostname = base::Sys.info()[["nodename"]])
[13:33:46.018]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:33:46.018]                               info)
[13:33:46.018]                             info <- base::paste(info, collapse = "; ")
[13:33:46.018]                             if (!has_future) {
[13:33:46.018]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:46.018]                                 info)
[13:33:46.018]                             }
[13:33:46.018]                             else {
[13:33:46.018]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:46.018]                                 info, version)
[13:33:46.018]                             }
[13:33:46.018]                             base::stop(msg)
[13:33:46.018]                           }
[13:33:46.018]                         })
[13:33:46.018]                       }
[13:33:46.018]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:46.018]                       base::options(mc.cores = 1L)
[13:33:46.018]                     }
[13:33:46.018]                     base::local({
[13:33:46.018]                       for (pkg in "stats") {
[13:33:46.018]                         base::loadNamespace(pkg)
[13:33:46.018]                         base::library(pkg, character.only = TRUE)
[13:33:46.018]                       }
[13:33:46.018]                     })
[13:33:46.018]                   }
[13:33:46.018]                   ...future.strategy.old <- future::plan("list")
[13:33:46.018]                   options(future.plan = NULL)
[13:33:46.018]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:46.018]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:46.018]                 }
[13:33:46.018]                 ...future.workdir <- getwd()
[13:33:46.018]             }
[13:33:46.018]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:46.018]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:46.018]         }
[13:33:46.018]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:46.018]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:46.018]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:46.018]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:46.018]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:46.018]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:46.018]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:46.018]             base::names(...future.oldOptions))
[13:33:46.018]     }
[13:33:46.018]     if (FALSE) {
[13:33:46.018]     }
[13:33:46.018]     else {
[13:33:46.018]         if (TRUE) {
[13:33:46.018]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:46.018]                 open = "w")
[13:33:46.018]         }
[13:33:46.018]         else {
[13:33:46.018]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:46.018]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:46.018]         }
[13:33:46.018]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:46.018]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:46.018]             base::sink(type = "output", split = FALSE)
[13:33:46.018]             base::close(...future.stdout)
[13:33:46.018]         }, add = TRUE)
[13:33:46.018]     }
[13:33:46.018]     ...future.frame <- base::sys.nframe()
[13:33:46.018]     ...future.conditions <- base::list()
[13:33:46.018]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:46.018]     if (FALSE) {
[13:33:46.018]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:46.018]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:46.018]     }
[13:33:46.018]     ...future.result <- base::tryCatch({
[13:33:46.018]         base::withCallingHandlers({
[13:33:46.018]             ...future.value <- base::withVisible(base::local({
[13:33:46.018]                 ...future.makeSendCondition <- base::local({
[13:33:46.018]                   sendCondition <- NULL
[13:33:46.018]                   function(frame = 1L) {
[13:33:46.018]                     if (is.function(sendCondition)) 
[13:33:46.018]                       return(sendCondition)
[13:33:46.018]                     ns <- getNamespace("parallel")
[13:33:46.018]                     if (exists("sendData", mode = "function", 
[13:33:46.018]                       envir = ns)) {
[13:33:46.018]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:46.018]                         envir = ns)
[13:33:46.018]                       envir <- sys.frame(frame)
[13:33:46.018]                       master <- NULL
[13:33:46.018]                       while (!identical(envir, .GlobalEnv) && 
[13:33:46.018]                         !identical(envir, emptyenv())) {
[13:33:46.018]                         if (exists("master", mode = "list", envir = envir, 
[13:33:46.018]                           inherits = FALSE)) {
[13:33:46.018]                           master <- get("master", mode = "list", 
[13:33:46.018]                             envir = envir, inherits = FALSE)
[13:33:46.018]                           if (inherits(master, c("SOCKnode", 
[13:33:46.018]                             "SOCK0node"))) {
[13:33:46.018]                             sendCondition <<- function(cond) {
[13:33:46.018]                               data <- list(type = "VALUE", value = cond, 
[13:33:46.018]                                 success = TRUE)
[13:33:46.018]                               parallel_sendData(master, data)
[13:33:46.018]                             }
[13:33:46.018]                             return(sendCondition)
[13:33:46.018]                           }
[13:33:46.018]                         }
[13:33:46.018]                         frame <- frame + 1L
[13:33:46.018]                         envir <- sys.frame(frame)
[13:33:46.018]                       }
[13:33:46.018]                     }
[13:33:46.018]                     sendCondition <<- function(cond) NULL
[13:33:46.018]                   }
[13:33:46.018]                 })
[13:33:46.018]                 withCallingHandlers({
[13:33:46.018]                   {
[13:33:46.018]                     do.call(function(...) {
[13:33:46.018]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:46.018]                       if (!identical(...future.globals.maxSize.org, 
[13:33:46.018]                         ...future.globals.maxSize)) {
[13:33:46.018]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:46.018]                         on.exit(options(oopts), add = TRUE)
[13:33:46.018]                       }
[13:33:46.018]                       {
[13:33:46.018]                         lapply(seq_along(...future.elements_ii), 
[13:33:46.018]                           FUN = function(jj) {
[13:33:46.018]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:46.018]                             ...future.FUN(...future.X_jj, ...)
[13:33:46.018]                           })
[13:33:46.018]                       }
[13:33:46.018]                     }, args = future.call.arguments)
[13:33:46.018]                   }
[13:33:46.018]                 }, immediateCondition = function(cond) {
[13:33:46.018]                   sendCondition <- ...future.makeSendCondition()
[13:33:46.018]                   sendCondition(cond)
[13:33:46.018]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:46.018]                   {
[13:33:46.018]                     inherits <- base::inherits
[13:33:46.018]                     invokeRestart <- base::invokeRestart
[13:33:46.018]                     is.null <- base::is.null
[13:33:46.018]                     muffled <- FALSE
[13:33:46.018]                     if (inherits(cond, "message")) {
[13:33:46.018]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:46.018]                       if (muffled) 
[13:33:46.018]                         invokeRestart("muffleMessage")
[13:33:46.018]                     }
[13:33:46.018]                     else if (inherits(cond, "warning")) {
[13:33:46.018]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:46.018]                       if (muffled) 
[13:33:46.018]                         invokeRestart("muffleWarning")
[13:33:46.018]                     }
[13:33:46.018]                     else if (inherits(cond, "condition")) {
[13:33:46.018]                       if (!is.null(pattern)) {
[13:33:46.018]                         computeRestarts <- base::computeRestarts
[13:33:46.018]                         grepl <- base::grepl
[13:33:46.018]                         restarts <- computeRestarts(cond)
[13:33:46.018]                         for (restart in restarts) {
[13:33:46.018]                           name <- restart$name
[13:33:46.018]                           if (is.null(name)) 
[13:33:46.018]                             next
[13:33:46.018]                           if (!grepl(pattern, name)) 
[13:33:46.018]                             next
[13:33:46.018]                           invokeRestart(restart)
[13:33:46.018]                           muffled <- TRUE
[13:33:46.018]                           break
[13:33:46.018]                         }
[13:33:46.018]                       }
[13:33:46.018]                     }
[13:33:46.018]                     invisible(muffled)
[13:33:46.018]                   }
[13:33:46.018]                   muffleCondition(cond)
[13:33:46.018]                 })
[13:33:46.018]             }))
[13:33:46.018]             future::FutureResult(value = ...future.value$value, 
[13:33:46.018]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:46.018]                   ...future.rng), globalenv = if (FALSE) 
[13:33:46.018]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:46.018]                     ...future.globalenv.names))
[13:33:46.018]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:46.018]         }, condition = base::local({
[13:33:46.018]             c <- base::c
[13:33:46.018]             inherits <- base::inherits
[13:33:46.018]             invokeRestart <- base::invokeRestart
[13:33:46.018]             length <- base::length
[13:33:46.018]             list <- base::list
[13:33:46.018]             seq.int <- base::seq.int
[13:33:46.018]             signalCondition <- base::signalCondition
[13:33:46.018]             sys.calls <- base::sys.calls
[13:33:46.018]             `[[` <- base::`[[`
[13:33:46.018]             `+` <- base::`+`
[13:33:46.018]             `<<-` <- base::`<<-`
[13:33:46.018]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:46.018]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:46.018]                   3L)]
[13:33:46.018]             }
[13:33:46.018]             function(cond) {
[13:33:46.018]                 is_error <- inherits(cond, "error")
[13:33:46.018]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:46.018]                   NULL)
[13:33:46.018]                 if (is_error) {
[13:33:46.018]                   sessionInformation <- function() {
[13:33:46.018]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:46.018]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:46.018]                       search = base::search(), system = base::Sys.info())
[13:33:46.018]                   }
[13:33:46.018]                   ...future.conditions[[length(...future.conditions) + 
[13:33:46.018]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:46.018]                     cond$call), session = sessionInformation(), 
[13:33:46.018]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:46.018]                   signalCondition(cond)
[13:33:46.018]                 }
[13:33:46.018]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:46.018]                 "immediateCondition"))) {
[13:33:46.018]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:46.018]                   ...future.conditions[[length(...future.conditions) + 
[13:33:46.018]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:46.018]                   if (TRUE && !signal) {
[13:33:46.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:46.018]                     {
[13:33:46.018]                       inherits <- base::inherits
[13:33:46.018]                       invokeRestart <- base::invokeRestart
[13:33:46.018]                       is.null <- base::is.null
[13:33:46.018]                       muffled <- FALSE
[13:33:46.018]                       if (inherits(cond, "message")) {
[13:33:46.018]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:46.018]                         if (muffled) 
[13:33:46.018]                           invokeRestart("muffleMessage")
[13:33:46.018]                       }
[13:33:46.018]                       else if (inherits(cond, "warning")) {
[13:33:46.018]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:46.018]                         if (muffled) 
[13:33:46.018]                           invokeRestart("muffleWarning")
[13:33:46.018]                       }
[13:33:46.018]                       else if (inherits(cond, "condition")) {
[13:33:46.018]                         if (!is.null(pattern)) {
[13:33:46.018]                           computeRestarts <- base::computeRestarts
[13:33:46.018]                           grepl <- base::grepl
[13:33:46.018]                           restarts <- computeRestarts(cond)
[13:33:46.018]                           for (restart in restarts) {
[13:33:46.018]                             name <- restart$name
[13:33:46.018]                             if (is.null(name)) 
[13:33:46.018]                               next
[13:33:46.018]                             if (!grepl(pattern, name)) 
[13:33:46.018]                               next
[13:33:46.018]                             invokeRestart(restart)
[13:33:46.018]                             muffled <- TRUE
[13:33:46.018]                             break
[13:33:46.018]                           }
[13:33:46.018]                         }
[13:33:46.018]                       }
[13:33:46.018]                       invisible(muffled)
[13:33:46.018]                     }
[13:33:46.018]                     muffleCondition(cond, pattern = "^muffle")
[13:33:46.018]                   }
[13:33:46.018]                 }
[13:33:46.018]                 else {
[13:33:46.018]                   if (TRUE) {
[13:33:46.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:46.018]                     {
[13:33:46.018]                       inherits <- base::inherits
[13:33:46.018]                       invokeRestart <- base::invokeRestart
[13:33:46.018]                       is.null <- base::is.null
[13:33:46.018]                       muffled <- FALSE
[13:33:46.018]                       if (inherits(cond, "message")) {
[13:33:46.018]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:46.018]                         if (muffled) 
[13:33:46.018]                           invokeRestart("muffleMessage")
[13:33:46.018]                       }
[13:33:46.018]                       else if (inherits(cond, "warning")) {
[13:33:46.018]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:46.018]                         if (muffled) 
[13:33:46.018]                           invokeRestart("muffleWarning")
[13:33:46.018]                       }
[13:33:46.018]                       else if (inherits(cond, "condition")) {
[13:33:46.018]                         if (!is.null(pattern)) {
[13:33:46.018]                           computeRestarts <- base::computeRestarts
[13:33:46.018]                           grepl <- base::grepl
[13:33:46.018]                           restarts <- computeRestarts(cond)
[13:33:46.018]                           for (restart in restarts) {
[13:33:46.018]                             name <- restart$name
[13:33:46.018]                             if (is.null(name)) 
[13:33:46.018]                               next
[13:33:46.018]                             if (!grepl(pattern, name)) 
[13:33:46.018]                               next
[13:33:46.018]                             invokeRestart(restart)
[13:33:46.018]                             muffled <- TRUE
[13:33:46.018]                             break
[13:33:46.018]                           }
[13:33:46.018]                         }
[13:33:46.018]                       }
[13:33:46.018]                       invisible(muffled)
[13:33:46.018]                     }
[13:33:46.018]                     muffleCondition(cond, pattern = "^muffle")
[13:33:46.018]                   }
[13:33:46.018]                 }
[13:33:46.018]             }
[13:33:46.018]         }))
[13:33:46.018]     }, error = function(ex) {
[13:33:46.018]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:46.018]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:46.018]                 ...future.rng), started = ...future.startTime, 
[13:33:46.018]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:46.018]             version = "1.8"), class = "FutureResult")
[13:33:46.018]     }, finally = {
[13:33:46.018]         if (!identical(...future.workdir, getwd())) 
[13:33:46.018]             setwd(...future.workdir)
[13:33:46.018]         {
[13:33:46.018]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:46.018]                 ...future.oldOptions$nwarnings <- NULL
[13:33:46.018]             }
[13:33:46.018]             base::options(...future.oldOptions)
[13:33:46.018]             if (.Platform$OS.type == "windows") {
[13:33:46.018]                 old_names <- names(...future.oldEnvVars)
[13:33:46.018]                 envs <- base::Sys.getenv()
[13:33:46.018]                 names <- names(envs)
[13:33:46.018]                 common <- intersect(names, old_names)
[13:33:46.018]                 added <- setdiff(names, old_names)
[13:33:46.018]                 removed <- setdiff(old_names, names)
[13:33:46.018]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:46.018]                   envs[common]]
[13:33:46.018]                 NAMES <- toupper(changed)
[13:33:46.018]                 args <- list()
[13:33:46.018]                 for (kk in seq_along(NAMES)) {
[13:33:46.018]                   name <- changed[[kk]]
[13:33:46.018]                   NAME <- NAMES[[kk]]
[13:33:46.018]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:46.018]                     next
[13:33:46.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:46.018]                 }
[13:33:46.018]                 NAMES <- toupper(added)
[13:33:46.018]                 for (kk in seq_along(NAMES)) {
[13:33:46.018]                   name <- added[[kk]]
[13:33:46.018]                   NAME <- NAMES[[kk]]
[13:33:46.018]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:46.018]                     next
[13:33:46.018]                   args[[name]] <- ""
[13:33:46.018]                 }
[13:33:46.018]                 NAMES <- toupper(removed)
[13:33:46.018]                 for (kk in seq_along(NAMES)) {
[13:33:46.018]                   name <- removed[[kk]]
[13:33:46.018]                   NAME <- NAMES[[kk]]
[13:33:46.018]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:46.018]                     next
[13:33:46.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:46.018]                 }
[13:33:46.018]                 if (length(args) > 0) 
[13:33:46.018]                   base::do.call(base::Sys.setenv, args = args)
[13:33:46.018]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:46.018]             }
[13:33:46.018]             else {
[13:33:46.018]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:46.018]             }
[13:33:46.018]             {
[13:33:46.018]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:46.018]                   0L) {
[13:33:46.018]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:46.018]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:46.018]                   base::options(opts)
[13:33:46.018]                 }
[13:33:46.018]                 {
[13:33:46.018]                   {
[13:33:46.018]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:46.018]                     NULL
[13:33:46.018]                   }
[13:33:46.018]                   options(future.plan = NULL)
[13:33:46.018]                   if (is.na(NA_character_)) 
[13:33:46.018]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:46.018]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:46.018]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:46.018]                     .init = FALSE)
[13:33:46.018]                 }
[13:33:46.018]             }
[13:33:46.018]         }
[13:33:46.018]     })
[13:33:46.018]     if (TRUE) {
[13:33:46.018]         base::sink(type = "output", split = FALSE)
[13:33:46.018]         if (TRUE) {
[13:33:46.018]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:46.018]         }
[13:33:46.018]         else {
[13:33:46.018]             ...future.result["stdout"] <- base::list(NULL)
[13:33:46.018]         }
[13:33:46.018]         base::close(...future.stdout)
[13:33:46.018]         ...future.stdout <- NULL
[13:33:46.018]     }
[13:33:46.018]     ...future.result$conditions <- ...future.conditions
[13:33:46.018]     ...future.result$finished <- base::Sys.time()
[13:33:46.018]     ...future.result
[13:33:46.018] }
[13:33:46.021] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[13:33:46.021] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[13:33:46.022] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[13:33:46.022] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:33:46.022] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:33:46.023] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[13:33:46.023] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[13:33:46.023] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:33:46.023] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:33:46.024] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:33:46.024] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:33:46.024] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[13:33:46.025] MultisessionFuture started
[13:33:46.025] - Launch lazy future ... done
[13:33:46.025] run() for ‘MultisessionFuture’ ... done
[13:33:46.025] Created future:
[13:33:46.025] MultisessionFuture:
[13:33:46.025] Label: ‘future_eapply-1’
[13:33:46.025] Expression:
[13:33:46.025] {
[13:33:46.025]     do.call(function(...) {
[13:33:46.025]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:46.025]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:46.025]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:46.025]             on.exit(options(oopts), add = TRUE)
[13:33:46.025]         }
[13:33:46.025]         {
[13:33:46.025]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:46.025]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:46.025]                 ...future.FUN(...future.X_jj, ...)
[13:33:46.025]             })
[13:33:46.025]         }
[13:33:46.025]     }, args = future.call.arguments)
[13:33:46.025] }
[13:33:46.025] Lazy evaluation: FALSE
[13:33:46.025] Asynchronous evaluation: TRUE
[13:33:46.025] Local evaluation: TRUE
[13:33:46.025] Environment: R_GlobalEnv
[13:33:46.025] Capture standard output: TRUE
[13:33:46.025] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:46.025] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:46.025] Packages: 1 packages (‘stats’)
[13:33:46.025] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:46.025] Resolved: FALSE
[13:33:46.025] Value: <not collected>
[13:33:46.025] Conditions captured: <none>
[13:33:46.025] Early signaling: FALSE
[13:33:46.025] Owner process: b6e93464-7fc2-3f8d-23d1-d8004201d1f1
[13:33:46.025] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:46.037] Chunk #1 of 2 ... DONE
[13:33:46.037] Chunk #2 of 2 ...
[13:33:46.037]  - Finding globals in 'X' for chunk #2 ...
[13:33:46.037] getGlobalsAndPackages() ...
[13:33:46.037] Searching for globals...
[13:33:46.038] 
[13:33:46.038] Searching for globals ... DONE
[13:33:46.038] - globals: [0] <none>
[13:33:46.038] getGlobalsAndPackages() ... DONE
[13:33:46.038]    + additional globals found: [n=0] 
[13:33:46.038]    + additional namespaces needed: [n=0] 
[13:33:46.038]  - Finding globals in 'X' for chunk #2 ... DONE
[13:33:46.038]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:46.038]  - seeds: <none>
[13:33:46.039]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:46.039] getGlobalsAndPackages() ...
[13:33:46.039] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:46.039] Resolving globals: FALSE
[13:33:46.039] Tweak future expression to call with '...' arguments ...
[13:33:46.039] {
[13:33:46.039]     do.call(function(...) {
[13:33:46.039]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:46.039]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:46.039]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:46.039]             on.exit(options(oopts), add = TRUE)
[13:33:46.039]         }
[13:33:46.039]         {
[13:33:46.039]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:46.039]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:46.039]                 ...future.FUN(...future.X_jj, ...)
[13:33:46.039]             })
[13:33:46.039]         }
[13:33:46.039]     }, args = future.call.arguments)
[13:33:46.039] }
[13:33:46.039] Tweak future expression to call with '...' arguments ... DONE
[13:33:46.040] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:46.040] - packages: [1] ‘stats’
[13:33:46.040] getGlobalsAndPackages() ... DONE
[13:33:46.040] run() for ‘Future’ ...
[13:33:46.040] - state: ‘created’
[13:33:46.040] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:46.055] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:46.055] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:46.055]   - Field: ‘node’
[13:33:46.055]   - Field: ‘label’
[13:33:46.055]   - Field: ‘local’
[13:33:46.055]   - Field: ‘owner’
[13:33:46.055]   - Field: ‘envir’
[13:33:46.055]   - Field: ‘workers’
[13:33:46.056]   - Field: ‘packages’
[13:33:46.056]   - Field: ‘gc’
[13:33:46.056]   - Field: ‘conditions’
[13:33:46.056]   - Field: ‘persistent’
[13:33:46.056]   - Field: ‘expr’
[13:33:46.056]   - Field: ‘uuid’
[13:33:46.056]   - Field: ‘seed’
[13:33:46.056]   - Field: ‘version’
[13:33:46.056]   - Field: ‘result’
[13:33:46.056]   - Field: ‘asynchronous’
[13:33:46.056]   - Field: ‘calls’
[13:33:46.057]   - Field: ‘globals’
[13:33:46.057]   - Field: ‘stdout’
[13:33:46.057]   - Field: ‘earlySignal’
[13:33:46.057]   - Field: ‘lazy’
[13:33:46.057]   - Field: ‘state’
[13:33:46.057] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:46.057] - Launch lazy future ...
[13:33:46.057] Packages needed by the future expression (n = 1): ‘stats’
[13:33:46.058] Packages needed by future strategies (n = 0): <none>
[13:33:46.058] {
[13:33:46.058]     {
[13:33:46.058]         {
[13:33:46.058]             ...future.startTime <- base::Sys.time()
[13:33:46.058]             {
[13:33:46.058]                 {
[13:33:46.058]                   {
[13:33:46.058]                     {
[13:33:46.058]                       {
[13:33:46.058]                         base::local({
[13:33:46.058]                           has_future <- base::requireNamespace("future", 
[13:33:46.058]                             quietly = TRUE)
[13:33:46.058]                           if (has_future) {
[13:33:46.058]                             ns <- base::getNamespace("future")
[13:33:46.058]                             version <- ns[[".package"]][["version"]]
[13:33:46.058]                             if (is.null(version)) 
[13:33:46.058]                               version <- utils::packageVersion("future")
[13:33:46.058]                           }
[13:33:46.058]                           else {
[13:33:46.058]                             version <- NULL
[13:33:46.058]                           }
[13:33:46.058]                           if (!has_future || version < "1.8.0") {
[13:33:46.058]                             info <- base::c(r_version = base::gsub("R version ", 
[13:33:46.058]                               "", base::R.version$version.string), 
[13:33:46.058]                               platform = base::sprintf("%s (%s-bit)", 
[13:33:46.058]                                 base::R.version$platform, 8 * 
[13:33:46.058]                                   base::.Machine$sizeof.pointer), 
[13:33:46.058]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:46.058]                                 "release", "version")], collapse = " "), 
[13:33:46.058]                               hostname = base::Sys.info()[["nodename"]])
[13:33:46.058]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:33:46.058]                               info)
[13:33:46.058]                             info <- base::paste(info, collapse = "; ")
[13:33:46.058]                             if (!has_future) {
[13:33:46.058]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:46.058]                                 info)
[13:33:46.058]                             }
[13:33:46.058]                             else {
[13:33:46.058]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:46.058]                                 info, version)
[13:33:46.058]                             }
[13:33:46.058]                             base::stop(msg)
[13:33:46.058]                           }
[13:33:46.058]                         })
[13:33:46.058]                       }
[13:33:46.058]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:46.058]                       base::options(mc.cores = 1L)
[13:33:46.058]                     }
[13:33:46.058]                     base::local({
[13:33:46.058]                       for (pkg in "stats") {
[13:33:46.058]                         base::loadNamespace(pkg)
[13:33:46.058]                         base::library(pkg, character.only = TRUE)
[13:33:46.058]                       }
[13:33:46.058]                     })
[13:33:46.058]                   }
[13:33:46.058]                   ...future.strategy.old <- future::plan("list")
[13:33:46.058]                   options(future.plan = NULL)
[13:33:46.058]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:46.058]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:46.058]                 }
[13:33:46.058]                 ...future.workdir <- getwd()
[13:33:46.058]             }
[13:33:46.058]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:46.058]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:46.058]         }
[13:33:46.058]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:46.058]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:46.058]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:46.058]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:46.058]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:46.058]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:46.058]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:46.058]             base::names(...future.oldOptions))
[13:33:46.058]     }
[13:33:46.058]     if (FALSE) {
[13:33:46.058]     }
[13:33:46.058]     else {
[13:33:46.058]         if (TRUE) {
[13:33:46.058]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:46.058]                 open = "w")
[13:33:46.058]         }
[13:33:46.058]         else {
[13:33:46.058]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:46.058]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:46.058]         }
[13:33:46.058]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:46.058]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:46.058]             base::sink(type = "output", split = FALSE)
[13:33:46.058]             base::close(...future.stdout)
[13:33:46.058]         }, add = TRUE)
[13:33:46.058]     }
[13:33:46.058]     ...future.frame <- base::sys.nframe()
[13:33:46.058]     ...future.conditions <- base::list()
[13:33:46.058]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:46.058]     if (FALSE) {
[13:33:46.058]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:46.058]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:46.058]     }
[13:33:46.058]     ...future.result <- base::tryCatch({
[13:33:46.058]         base::withCallingHandlers({
[13:33:46.058]             ...future.value <- base::withVisible(base::local({
[13:33:46.058]                 ...future.makeSendCondition <- base::local({
[13:33:46.058]                   sendCondition <- NULL
[13:33:46.058]                   function(frame = 1L) {
[13:33:46.058]                     if (is.function(sendCondition)) 
[13:33:46.058]                       return(sendCondition)
[13:33:46.058]                     ns <- getNamespace("parallel")
[13:33:46.058]                     if (exists("sendData", mode = "function", 
[13:33:46.058]                       envir = ns)) {
[13:33:46.058]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:46.058]                         envir = ns)
[13:33:46.058]                       envir <- sys.frame(frame)
[13:33:46.058]                       master <- NULL
[13:33:46.058]                       while (!identical(envir, .GlobalEnv) && 
[13:33:46.058]                         !identical(envir, emptyenv())) {
[13:33:46.058]                         if (exists("master", mode = "list", envir = envir, 
[13:33:46.058]                           inherits = FALSE)) {
[13:33:46.058]                           master <- get("master", mode = "list", 
[13:33:46.058]                             envir = envir, inherits = FALSE)
[13:33:46.058]                           if (inherits(master, c("SOCKnode", 
[13:33:46.058]                             "SOCK0node"))) {
[13:33:46.058]                             sendCondition <<- function(cond) {
[13:33:46.058]                               data <- list(type = "VALUE", value = cond, 
[13:33:46.058]                                 success = TRUE)
[13:33:46.058]                               parallel_sendData(master, data)
[13:33:46.058]                             }
[13:33:46.058]                             return(sendCondition)
[13:33:46.058]                           }
[13:33:46.058]                         }
[13:33:46.058]                         frame <- frame + 1L
[13:33:46.058]                         envir <- sys.frame(frame)
[13:33:46.058]                       }
[13:33:46.058]                     }
[13:33:46.058]                     sendCondition <<- function(cond) NULL
[13:33:46.058]                   }
[13:33:46.058]                 })
[13:33:46.058]                 withCallingHandlers({
[13:33:46.058]                   {
[13:33:46.058]                     do.call(function(...) {
[13:33:46.058]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:46.058]                       if (!identical(...future.globals.maxSize.org, 
[13:33:46.058]                         ...future.globals.maxSize)) {
[13:33:46.058]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:46.058]                         on.exit(options(oopts), add = TRUE)
[13:33:46.058]                       }
[13:33:46.058]                       {
[13:33:46.058]                         lapply(seq_along(...future.elements_ii), 
[13:33:46.058]                           FUN = function(jj) {
[13:33:46.058]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:46.058]                             ...future.FUN(...future.X_jj, ...)
[13:33:46.058]                           })
[13:33:46.058]                       }
[13:33:46.058]                     }, args = future.call.arguments)
[13:33:46.058]                   }
[13:33:46.058]                 }, immediateCondition = function(cond) {
[13:33:46.058]                   sendCondition <- ...future.makeSendCondition()
[13:33:46.058]                   sendCondition(cond)
[13:33:46.058]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:46.058]                   {
[13:33:46.058]                     inherits <- base::inherits
[13:33:46.058]                     invokeRestart <- base::invokeRestart
[13:33:46.058]                     is.null <- base::is.null
[13:33:46.058]                     muffled <- FALSE
[13:33:46.058]                     if (inherits(cond, "message")) {
[13:33:46.058]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:46.058]                       if (muffled) 
[13:33:46.058]                         invokeRestart("muffleMessage")
[13:33:46.058]                     }
[13:33:46.058]                     else if (inherits(cond, "warning")) {
[13:33:46.058]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:46.058]                       if (muffled) 
[13:33:46.058]                         invokeRestart("muffleWarning")
[13:33:46.058]                     }
[13:33:46.058]                     else if (inherits(cond, "condition")) {
[13:33:46.058]                       if (!is.null(pattern)) {
[13:33:46.058]                         computeRestarts <- base::computeRestarts
[13:33:46.058]                         grepl <- base::grepl
[13:33:46.058]                         restarts <- computeRestarts(cond)
[13:33:46.058]                         for (restart in restarts) {
[13:33:46.058]                           name <- restart$name
[13:33:46.058]                           if (is.null(name)) 
[13:33:46.058]                             next
[13:33:46.058]                           if (!grepl(pattern, name)) 
[13:33:46.058]                             next
[13:33:46.058]                           invokeRestart(restart)
[13:33:46.058]                           muffled <- TRUE
[13:33:46.058]                           break
[13:33:46.058]                         }
[13:33:46.058]                       }
[13:33:46.058]                     }
[13:33:46.058]                     invisible(muffled)
[13:33:46.058]                   }
[13:33:46.058]                   muffleCondition(cond)
[13:33:46.058]                 })
[13:33:46.058]             }))
[13:33:46.058]             future::FutureResult(value = ...future.value$value, 
[13:33:46.058]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:46.058]                   ...future.rng), globalenv = if (FALSE) 
[13:33:46.058]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:46.058]                     ...future.globalenv.names))
[13:33:46.058]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:46.058]         }, condition = base::local({
[13:33:46.058]             c <- base::c
[13:33:46.058]             inherits <- base::inherits
[13:33:46.058]             invokeRestart <- base::invokeRestart
[13:33:46.058]             length <- base::length
[13:33:46.058]             list <- base::list
[13:33:46.058]             seq.int <- base::seq.int
[13:33:46.058]             signalCondition <- base::signalCondition
[13:33:46.058]             sys.calls <- base::sys.calls
[13:33:46.058]             `[[` <- base::`[[`
[13:33:46.058]             `+` <- base::`+`
[13:33:46.058]             `<<-` <- base::`<<-`
[13:33:46.058]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:46.058]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:46.058]                   3L)]
[13:33:46.058]             }
[13:33:46.058]             function(cond) {
[13:33:46.058]                 is_error <- inherits(cond, "error")
[13:33:46.058]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:46.058]                   NULL)
[13:33:46.058]                 if (is_error) {
[13:33:46.058]                   sessionInformation <- function() {
[13:33:46.058]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:46.058]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:46.058]                       search = base::search(), system = base::Sys.info())
[13:33:46.058]                   }
[13:33:46.058]                   ...future.conditions[[length(...future.conditions) + 
[13:33:46.058]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:46.058]                     cond$call), session = sessionInformation(), 
[13:33:46.058]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:46.058]                   signalCondition(cond)
[13:33:46.058]                 }
[13:33:46.058]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:46.058]                 "immediateCondition"))) {
[13:33:46.058]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:46.058]                   ...future.conditions[[length(...future.conditions) + 
[13:33:46.058]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:46.058]                   if (TRUE && !signal) {
[13:33:46.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:46.058]                     {
[13:33:46.058]                       inherits <- base::inherits
[13:33:46.058]                       invokeRestart <- base::invokeRestart
[13:33:46.058]                       is.null <- base::is.null
[13:33:46.058]                       muffled <- FALSE
[13:33:46.058]                       if (inherits(cond, "message")) {
[13:33:46.058]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:46.058]                         if (muffled) 
[13:33:46.058]                           invokeRestart("muffleMessage")
[13:33:46.058]                       }
[13:33:46.058]                       else if (inherits(cond, "warning")) {
[13:33:46.058]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:46.058]                         if (muffled) 
[13:33:46.058]                           invokeRestart("muffleWarning")
[13:33:46.058]                       }
[13:33:46.058]                       else if (inherits(cond, "condition")) {
[13:33:46.058]                         if (!is.null(pattern)) {
[13:33:46.058]                           computeRestarts <- base::computeRestarts
[13:33:46.058]                           grepl <- base::grepl
[13:33:46.058]                           restarts <- computeRestarts(cond)
[13:33:46.058]                           for (restart in restarts) {
[13:33:46.058]                             name <- restart$name
[13:33:46.058]                             if (is.null(name)) 
[13:33:46.058]                               next
[13:33:46.058]                             if (!grepl(pattern, name)) 
[13:33:46.058]                               next
[13:33:46.058]                             invokeRestart(restart)
[13:33:46.058]                             muffled <- TRUE
[13:33:46.058]                             break
[13:33:46.058]                           }
[13:33:46.058]                         }
[13:33:46.058]                       }
[13:33:46.058]                       invisible(muffled)
[13:33:46.058]                     }
[13:33:46.058]                     muffleCondition(cond, pattern = "^muffle")
[13:33:46.058]                   }
[13:33:46.058]                 }
[13:33:46.058]                 else {
[13:33:46.058]                   if (TRUE) {
[13:33:46.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:46.058]                     {
[13:33:46.058]                       inherits <- base::inherits
[13:33:46.058]                       invokeRestart <- base::invokeRestart
[13:33:46.058]                       is.null <- base::is.null
[13:33:46.058]                       muffled <- FALSE
[13:33:46.058]                       if (inherits(cond, "message")) {
[13:33:46.058]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:46.058]                         if (muffled) 
[13:33:46.058]                           invokeRestart("muffleMessage")
[13:33:46.058]                       }
[13:33:46.058]                       else if (inherits(cond, "warning")) {
[13:33:46.058]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:46.058]                         if (muffled) 
[13:33:46.058]                           invokeRestart("muffleWarning")
[13:33:46.058]                       }
[13:33:46.058]                       else if (inherits(cond, "condition")) {
[13:33:46.058]                         if (!is.null(pattern)) {
[13:33:46.058]                           computeRestarts <- base::computeRestarts
[13:33:46.058]                           grepl <- base::grepl
[13:33:46.058]                           restarts <- computeRestarts(cond)
[13:33:46.058]                           for (restart in restarts) {
[13:33:46.058]                             name <- restart$name
[13:33:46.058]                             if (is.null(name)) 
[13:33:46.058]                               next
[13:33:46.058]                             if (!grepl(pattern, name)) 
[13:33:46.058]                               next
[13:33:46.058]                             invokeRestart(restart)
[13:33:46.058]                             muffled <- TRUE
[13:33:46.058]                             break
[13:33:46.058]                           }
[13:33:46.058]                         }
[13:33:46.058]                       }
[13:33:46.058]                       invisible(muffled)
[13:33:46.058]                     }
[13:33:46.058]                     muffleCondition(cond, pattern = "^muffle")
[13:33:46.058]                   }
[13:33:46.058]                 }
[13:33:46.058]             }
[13:33:46.058]         }))
[13:33:46.058]     }, error = function(ex) {
[13:33:46.058]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:46.058]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:46.058]                 ...future.rng), started = ...future.startTime, 
[13:33:46.058]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:46.058]             version = "1.8"), class = "FutureResult")
[13:33:46.058]     }, finally = {
[13:33:46.058]         if (!identical(...future.workdir, getwd())) 
[13:33:46.058]             setwd(...future.workdir)
[13:33:46.058]         {
[13:33:46.058]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:46.058]                 ...future.oldOptions$nwarnings <- NULL
[13:33:46.058]             }
[13:33:46.058]             base::options(...future.oldOptions)
[13:33:46.058]             if (.Platform$OS.type == "windows") {
[13:33:46.058]                 old_names <- names(...future.oldEnvVars)
[13:33:46.058]                 envs <- base::Sys.getenv()
[13:33:46.058]                 names <- names(envs)
[13:33:46.058]                 common <- intersect(names, old_names)
[13:33:46.058]                 added <- setdiff(names, old_names)
[13:33:46.058]                 removed <- setdiff(old_names, names)
[13:33:46.058]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:46.058]                   envs[common]]
[13:33:46.058]                 NAMES <- toupper(changed)
[13:33:46.058]                 args <- list()
[13:33:46.058]                 for (kk in seq_along(NAMES)) {
[13:33:46.058]                   name <- changed[[kk]]
[13:33:46.058]                   NAME <- NAMES[[kk]]
[13:33:46.058]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:46.058]                     next
[13:33:46.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:46.058]                 }
[13:33:46.058]                 NAMES <- toupper(added)
[13:33:46.058]                 for (kk in seq_along(NAMES)) {
[13:33:46.058]                   name <- added[[kk]]
[13:33:46.058]                   NAME <- NAMES[[kk]]
[13:33:46.058]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:46.058]                     next
[13:33:46.058]                   args[[name]] <- ""
[13:33:46.058]                 }
[13:33:46.058]                 NAMES <- toupper(removed)
[13:33:46.058]                 for (kk in seq_along(NAMES)) {
[13:33:46.058]                   name <- removed[[kk]]
[13:33:46.058]                   NAME <- NAMES[[kk]]
[13:33:46.058]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:46.058]                     next
[13:33:46.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:46.058]                 }
[13:33:46.058]                 if (length(args) > 0) 
[13:33:46.058]                   base::do.call(base::Sys.setenv, args = args)
[13:33:46.058]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:46.058]             }
[13:33:46.058]             else {
[13:33:46.058]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:46.058]             }
[13:33:46.058]             {
[13:33:46.058]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:46.058]                   0L) {
[13:33:46.058]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:46.058]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:46.058]                   base::options(opts)
[13:33:46.058]                 }
[13:33:46.058]                 {
[13:33:46.058]                   {
[13:33:46.058]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:46.058]                     NULL
[13:33:46.058]                   }
[13:33:46.058]                   options(future.plan = NULL)
[13:33:46.058]                   if (is.na(NA_character_)) 
[13:33:46.058]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:46.058]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:46.058]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:46.058]                     .init = FALSE)
[13:33:46.058]                 }
[13:33:46.058]             }
[13:33:46.058]         }
[13:33:46.058]     })
[13:33:46.058]     if (TRUE) {
[13:33:46.058]         base::sink(type = "output", split = FALSE)
[13:33:46.058]         if (TRUE) {
[13:33:46.058]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:46.058]         }
[13:33:46.058]         else {
[13:33:46.058]             ...future.result["stdout"] <- base::list(NULL)
[13:33:46.058]         }
[13:33:46.058]         base::close(...future.stdout)
[13:33:46.058]         ...future.stdout <- NULL
[13:33:46.058]     }
[13:33:46.058]     ...future.result$conditions <- ...future.conditions
[13:33:46.058]     ...future.result$finished <- base::Sys.time()
[13:33:46.058]     ...future.result
[13:33:46.058] }
[13:33:46.061] Exporting 5 global objects (1.22 KiB) to cluster node #2 ...
[13:33:46.061] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[13:33:46.061] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[13:33:46.061] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:33:46.062] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:33:46.062] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[13:33:46.062] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[13:33:46.062] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:33:46.063] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:33:46.063] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:33:46.063] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:33:46.063] Exporting 5 global objects (1.22 KiB) to cluster node #2 ... DONE
[13:33:46.064] MultisessionFuture started
[13:33:46.064] - Launch lazy future ... done
[13:33:46.064] run() for ‘MultisessionFuture’ ... done
[13:33:46.064] Created future:
[13:33:46.064] MultisessionFuture:
[13:33:46.064] Label: ‘future_eapply-2’
[13:33:46.064] Expression:
[13:33:46.064] {
[13:33:46.064]     do.call(function(...) {
[13:33:46.064]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:46.064]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:46.064]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:46.064]             on.exit(options(oopts), add = TRUE)
[13:33:46.064]         }
[13:33:46.064]         {
[13:33:46.064]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:46.064]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:46.064]                 ...future.FUN(...future.X_jj, ...)
[13:33:46.064]             })
[13:33:46.064]         }
[13:33:46.064]     }, args = future.call.arguments)
[13:33:46.064] }
[13:33:46.064] Lazy evaluation: FALSE
[13:33:46.064] Asynchronous evaluation: TRUE
[13:33:46.064] Local evaluation: TRUE
[13:33:46.064] Environment: R_GlobalEnv
[13:33:46.064] Capture standard output: TRUE
[13:33:46.064] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:46.064] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:46.064] Packages: 1 packages (‘stats’)
[13:33:46.064] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:46.064] Resolved: FALSE
[13:33:46.064] Value: <not collected>
[13:33:46.064] Conditions captured: <none>
[13:33:46.064] Early signaling: FALSE
[13:33:46.064] Owner process: b6e93464-7fc2-3f8d-23d1-d8004201d1f1
[13:33:46.064] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:46.075] Chunk #2 of 2 ... DONE
[13:33:46.076] Launching 2 futures (chunks) ... DONE
[13:33:46.076] Resolving 2 futures (chunks) ...
[13:33:46.076] resolve() on list ...
[13:33:46.076]  recursive: 0
[13:33:46.076]  length: 2
[13:33:46.076] 
[13:33:46.076] receiveMessageFromWorker() for ClusterFuture ...
[13:33:46.077] - Validating connection of MultisessionFuture
[13:33:46.077] - received message: FutureResult
[13:33:46.077] - Received FutureResult
[13:33:46.077] - Erased future from FutureRegistry
[13:33:46.077] result() for ClusterFuture ...
[13:33:46.077] - result already collected: FutureResult
[13:33:46.077] result() for ClusterFuture ... done
[13:33:46.077] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:46.077] Future #1
[13:33:46.078] result() for ClusterFuture ...
[13:33:46.078] - result already collected: FutureResult
[13:33:46.078] result() for ClusterFuture ... done
[13:33:46.078] result() for ClusterFuture ...
[13:33:46.078] - result already collected: FutureResult
[13:33:46.078] result() for ClusterFuture ... done
[13:33:46.078] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:33:46.078] - nx: 2
[13:33:46.078] - relay: TRUE
[13:33:46.078] - stdout: TRUE
[13:33:46.078] - signal: TRUE
[13:33:46.079] - resignal: FALSE
[13:33:46.079] - force: TRUE
[13:33:46.079] - relayed: [n=2] FALSE, FALSE
[13:33:46.079] - queued futures: [n=2] FALSE, FALSE
[13:33:46.079]  - until=1
[13:33:46.079]  - relaying element #1
[13:33:46.079] result() for ClusterFuture ...
[13:33:46.079] - result already collected: FutureResult
[13:33:46.079] result() for ClusterFuture ... done
[13:33:46.079] result() for ClusterFuture ...
[13:33:46.079] - result already collected: FutureResult
[13:33:46.079] result() for ClusterFuture ... done
[13:33:46.080] result() for ClusterFuture ...
[13:33:46.080] - result already collected: FutureResult
[13:33:46.080] result() for ClusterFuture ... done
[13:33:46.080] result() for ClusterFuture ...
[13:33:46.080] - result already collected: FutureResult
[13:33:46.080] result() for ClusterFuture ... done
[13:33:46.080] - relayed: [n=2] TRUE, FALSE
[13:33:46.080] - queued futures: [n=2] TRUE, FALSE
[13:33:46.080] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:33:46.080]  length: 1 (resolved future 1)
[13:33:46.109] receiveMessageFromWorker() for ClusterFuture ...
[13:33:46.109] - Validating connection of MultisessionFuture
[13:33:46.109] - received message: FutureResult
[13:33:46.109] - Received FutureResult
[13:33:46.109] - Erased future from FutureRegistry
[13:33:46.110] result() for ClusterFuture ...
[13:33:46.110] - result already collected: FutureResult
[13:33:46.110] result() for ClusterFuture ... done
[13:33:46.110] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:46.110] Future #2
[13:33:46.110] result() for ClusterFuture ...
[13:33:46.110] - result already collected: FutureResult
[13:33:46.110] result() for ClusterFuture ... done
[13:33:46.110] result() for ClusterFuture ...
[13:33:46.110] - result already collected: FutureResult
[13:33:46.110] result() for ClusterFuture ... done
[13:33:46.111] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:33:46.111] - nx: 2
[13:33:46.111] - relay: TRUE
[13:33:46.111] - stdout: TRUE
[13:33:46.111] - signal: TRUE
[13:33:46.111] - resignal: FALSE
[13:33:46.111] - force: TRUE
[13:33:46.111] - relayed: [n=2] TRUE, FALSE
[13:33:46.111] - queued futures: [n=2] TRUE, FALSE
[13:33:46.111]  - until=2
[13:33:46.111]  - relaying element #2
[13:33:46.112] result() for ClusterFuture ...
[13:33:46.112] - result already collected: FutureResult
[13:33:46.112] result() for ClusterFuture ... done
[13:33:46.112] result() for ClusterFuture ...
[13:33:46.112] - result already collected: FutureResult
[13:33:46.112] result() for ClusterFuture ... done
[13:33:46.112] result() for ClusterFuture ...
[13:33:46.112] - result already collected: FutureResult
[13:33:46.112] result() for ClusterFuture ... done
[13:33:46.112] result() for ClusterFuture ...
[13:33:46.112] - result already collected: FutureResult
[13:33:46.112] result() for ClusterFuture ... done
[13:33:46.113] - relayed: [n=2] TRUE, TRUE
[13:33:46.113] - queued futures: [n=2] TRUE, TRUE
[13:33:46.113] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:33:46.113]  length: 0 (resolved future 2)
[13:33:46.113] Relaying remaining futures
[13:33:46.113] signalConditionsASAP(NULL, pos=0) ...
[13:33:46.113] - nx: 2
[13:33:46.113] - relay: TRUE
[13:33:46.113] - stdout: TRUE
[13:33:46.113] - signal: TRUE
[13:33:46.113] - resignal: FALSE
[13:33:46.114] - force: TRUE
[13:33:46.114] - relayed: [n=2] TRUE, TRUE
[13:33:46.114] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:46.114] - relayed: [n=2] TRUE, TRUE
[13:33:46.114] - queued futures: [n=2] TRUE, TRUE
[13:33:46.114] signalConditionsASAP(NULL, pos=0) ... done
[13:33:46.114] resolve() on list ... DONE
[13:33:46.114] result() for ClusterFuture ...
[13:33:46.114] - result already collected: FutureResult
[13:33:46.114] result() for ClusterFuture ... done
[13:33:46.114] result() for ClusterFuture ...
[13:33:46.115] - result already collected: FutureResult
[13:33:46.115] result() for ClusterFuture ... done
[13:33:46.115] result() for ClusterFuture ...
[13:33:46.115] - result already collected: FutureResult
[13:33:46.115] result() for ClusterFuture ... done
[13:33:46.115] result() for ClusterFuture ...
[13:33:46.115] - result already collected: FutureResult
[13:33:46.115] result() for ClusterFuture ... done
[13:33:46.115]  - Number of value chunks collected: 2
[13:33:46.115] Resolving 2 futures (chunks) ... DONE
[13:33:46.115] Reducing values from 2 chunks ...
[13:33:46.116]  - Number of values collected after concatenation: 3
[13:33:46.116]  - Number of values expected: 3
[13:33:46.116] Reducing values from 2 chunks ... DONE
[13:33:46.116] future_lapply() ... DONE
[13:33:46.116] future_lapply() ...
[13:33:46.120] Number of chunks: 2
[13:33:46.120] getGlobalsAndPackagesXApply() ...
[13:33:46.120]  - future.globals: TRUE
[13:33:46.120] getGlobalsAndPackages() ...
[13:33:46.120] Searching for globals...
[13:33:46.121] - globals found: [2] ‘FUN’, ‘UseMethod’
[13:33:46.121] Searching for globals ... DONE
[13:33:46.122] Resolving globals: FALSE
[13:33:46.122] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[13:33:46.122] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[13:33:46.122] - globals: [1] ‘FUN’
[13:33:46.123] - packages: [1] ‘stats’
[13:33:46.123] getGlobalsAndPackages() ... DONE
[13:33:46.123]  - globals found/used: [n=1] ‘FUN’
[13:33:46.123]  - needed namespaces: [n=1] ‘stats’
[13:33:46.123] Finding globals ... DONE
[13:33:46.123]  - use_args: TRUE
[13:33:46.123]  - Getting '...' globals ...
[13:33:46.123] resolve() on list ...
[13:33:46.124]  recursive: 0
[13:33:46.124]  length: 1
[13:33:46.124]  elements: ‘...’
[13:33:46.124]  length: 0 (resolved future 1)
[13:33:46.124] resolve() on list ... DONE
[13:33:46.124]    - '...' content: [n=0] 
[13:33:46.124] List of 1
[13:33:46.124]  $ ...: list()
[13:33:46.124]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:46.124]  - attr(*, "where")=List of 1
[13:33:46.124]   ..$ ...:<environment: 0x5598478c1ab8> 
[13:33:46.124]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:46.124]  - attr(*, "resolved")= logi TRUE
[13:33:46.124]  - attr(*, "total_size")= num NA
[13:33:46.127]  - Getting '...' globals ... DONE
[13:33:46.127] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:33:46.127] List of 2
[13:33:46.127]  $ ...future.FUN:function (x, ...)  
[13:33:46.127]  $ ...          : list()
[13:33:46.127]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:33:46.127]  - attr(*, "where")=List of 2
[13:33:46.127]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:33:46.127]   ..$ ...          :<environment: 0x5598478c1ab8> 
[13:33:46.127]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:33:46.127]  - attr(*, "resolved")= logi FALSE
[13:33:46.127]  - attr(*, "total_size")= num 1248
[13:33:46.130] Packages to be attached in all futures: [n=1] ‘stats’
[13:33:46.130] getGlobalsAndPackagesXApply() ... DONE
[13:33:46.130] Number of futures (= number of chunks): 2
[13:33:46.131] Launching 2 futures (chunks) ...
[13:33:46.131] Chunk #1 of 2 ...
[13:33:46.131]  - Finding globals in 'X' for chunk #1 ...
[13:33:46.131] getGlobalsAndPackages() ...
[13:33:46.131] Searching for globals...
[13:33:46.131] 
[13:33:46.131] Searching for globals ... DONE
[13:33:46.131] - globals: [0] <none>
[13:33:46.132] getGlobalsAndPackages() ... DONE
[13:33:46.132]    + additional globals found: [n=0] 
[13:33:46.132]    + additional namespaces needed: [n=0] 
[13:33:46.132]  - Finding globals in 'X' for chunk #1 ... DONE
[13:33:46.132]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:46.132]  - seeds: <none>
[13:33:46.132]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:46.132] getGlobalsAndPackages() ...
[13:33:46.132] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:46.132] Resolving globals: FALSE
[13:33:46.132] Tweak future expression to call with '...' arguments ...
[13:33:46.133] {
[13:33:46.133]     do.call(function(...) {
[13:33:46.133]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:46.133]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:46.133]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:46.133]             on.exit(options(oopts), add = TRUE)
[13:33:46.133]         }
[13:33:46.133]         {
[13:33:46.133]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:46.133]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:46.133]                 ...future.FUN(...future.X_jj, ...)
[13:33:46.133]             })
[13:33:46.133]         }
[13:33:46.133]     }, args = future.call.arguments)
[13:33:46.133] }
[13:33:46.133] Tweak future expression to call with '...' arguments ... DONE
[13:33:46.133] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:46.133] - packages: [1] ‘stats’
[13:33:46.133] getGlobalsAndPackages() ... DONE
[13:33:46.134] run() for ‘Future’ ...
[13:33:46.134] - state: ‘created’
[13:33:46.134] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:46.147] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:46.147] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:46.148]   - Field: ‘node’
[13:33:46.148]   - Field: ‘label’
[13:33:46.148]   - Field: ‘local’
[13:33:46.148]   - Field: ‘owner’
[13:33:46.148]   - Field: ‘envir’
[13:33:46.148]   - Field: ‘workers’
[13:33:46.148]   - Field: ‘packages’
[13:33:46.148]   - Field: ‘gc’
[13:33:46.148]   - Field: ‘conditions’
[13:33:46.148]   - Field: ‘persistent’
[13:33:46.148]   - Field: ‘expr’
[13:33:46.149]   - Field: ‘uuid’
[13:33:46.149]   - Field: ‘seed’
[13:33:46.149]   - Field: ‘version’
[13:33:46.149]   - Field: ‘result’
[13:33:46.149]   - Field: ‘asynchronous’
[13:33:46.149]   - Field: ‘calls’
[13:33:46.149]   - Field: ‘globals’
[13:33:46.149]   - Field: ‘stdout’
[13:33:46.149]   - Field: ‘earlySignal’
[13:33:46.149]   - Field: ‘lazy’
[13:33:46.149]   - Field: ‘state’
[13:33:46.150] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:46.150] - Launch lazy future ...
[13:33:46.150] Packages needed by the future expression (n = 1): ‘stats’
[13:33:46.150] Packages needed by future strategies (n = 0): <none>
[13:33:46.151] {
[13:33:46.151]     {
[13:33:46.151]         {
[13:33:46.151]             ...future.startTime <- base::Sys.time()
[13:33:46.151]             {
[13:33:46.151]                 {
[13:33:46.151]                   {
[13:33:46.151]                     {
[13:33:46.151]                       {
[13:33:46.151]                         base::local({
[13:33:46.151]                           has_future <- base::requireNamespace("future", 
[13:33:46.151]                             quietly = TRUE)
[13:33:46.151]                           if (has_future) {
[13:33:46.151]                             ns <- base::getNamespace("future")
[13:33:46.151]                             version <- ns[[".package"]][["version"]]
[13:33:46.151]                             if (is.null(version)) 
[13:33:46.151]                               version <- utils::packageVersion("future")
[13:33:46.151]                           }
[13:33:46.151]                           else {
[13:33:46.151]                             version <- NULL
[13:33:46.151]                           }
[13:33:46.151]                           if (!has_future || version < "1.8.0") {
[13:33:46.151]                             info <- base::c(r_version = base::gsub("R version ", 
[13:33:46.151]                               "", base::R.version$version.string), 
[13:33:46.151]                               platform = base::sprintf("%s (%s-bit)", 
[13:33:46.151]                                 base::R.version$platform, 8 * 
[13:33:46.151]                                   base::.Machine$sizeof.pointer), 
[13:33:46.151]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:46.151]                                 "release", "version")], collapse = " "), 
[13:33:46.151]                               hostname = base::Sys.info()[["nodename"]])
[13:33:46.151]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:33:46.151]                               info)
[13:33:46.151]                             info <- base::paste(info, collapse = "; ")
[13:33:46.151]                             if (!has_future) {
[13:33:46.151]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:46.151]                                 info)
[13:33:46.151]                             }
[13:33:46.151]                             else {
[13:33:46.151]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:46.151]                                 info, version)
[13:33:46.151]                             }
[13:33:46.151]                             base::stop(msg)
[13:33:46.151]                           }
[13:33:46.151]                         })
[13:33:46.151]                       }
[13:33:46.151]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:46.151]                       base::options(mc.cores = 1L)
[13:33:46.151]                     }
[13:33:46.151]                     base::local({
[13:33:46.151]                       for (pkg in "stats") {
[13:33:46.151]                         base::loadNamespace(pkg)
[13:33:46.151]                         base::library(pkg, character.only = TRUE)
[13:33:46.151]                       }
[13:33:46.151]                     })
[13:33:46.151]                   }
[13:33:46.151]                   ...future.strategy.old <- future::plan("list")
[13:33:46.151]                   options(future.plan = NULL)
[13:33:46.151]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:46.151]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:46.151]                 }
[13:33:46.151]                 ...future.workdir <- getwd()
[13:33:46.151]             }
[13:33:46.151]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:46.151]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:46.151]         }
[13:33:46.151]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:46.151]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:46.151]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:46.151]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:46.151]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:46.151]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:46.151]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:46.151]             base::names(...future.oldOptions))
[13:33:46.151]     }
[13:33:46.151]     if (FALSE) {
[13:33:46.151]     }
[13:33:46.151]     else {
[13:33:46.151]         if (TRUE) {
[13:33:46.151]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:46.151]                 open = "w")
[13:33:46.151]         }
[13:33:46.151]         else {
[13:33:46.151]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:46.151]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:46.151]         }
[13:33:46.151]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:46.151]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:46.151]             base::sink(type = "output", split = FALSE)
[13:33:46.151]             base::close(...future.stdout)
[13:33:46.151]         }, add = TRUE)
[13:33:46.151]     }
[13:33:46.151]     ...future.frame <- base::sys.nframe()
[13:33:46.151]     ...future.conditions <- base::list()
[13:33:46.151]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:46.151]     if (FALSE) {
[13:33:46.151]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:46.151]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:46.151]     }
[13:33:46.151]     ...future.result <- base::tryCatch({
[13:33:46.151]         base::withCallingHandlers({
[13:33:46.151]             ...future.value <- base::withVisible(base::local({
[13:33:46.151]                 ...future.makeSendCondition <- base::local({
[13:33:46.151]                   sendCondition <- NULL
[13:33:46.151]                   function(frame = 1L) {
[13:33:46.151]                     if (is.function(sendCondition)) 
[13:33:46.151]                       return(sendCondition)
[13:33:46.151]                     ns <- getNamespace("parallel")
[13:33:46.151]                     if (exists("sendData", mode = "function", 
[13:33:46.151]                       envir = ns)) {
[13:33:46.151]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:46.151]                         envir = ns)
[13:33:46.151]                       envir <- sys.frame(frame)
[13:33:46.151]                       master <- NULL
[13:33:46.151]                       while (!identical(envir, .GlobalEnv) && 
[13:33:46.151]                         !identical(envir, emptyenv())) {
[13:33:46.151]                         if (exists("master", mode = "list", envir = envir, 
[13:33:46.151]                           inherits = FALSE)) {
[13:33:46.151]                           master <- get("master", mode = "list", 
[13:33:46.151]                             envir = envir, inherits = FALSE)
[13:33:46.151]                           if (inherits(master, c("SOCKnode", 
[13:33:46.151]                             "SOCK0node"))) {
[13:33:46.151]                             sendCondition <<- function(cond) {
[13:33:46.151]                               data <- list(type = "VALUE", value = cond, 
[13:33:46.151]                                 success = TRUE)
[13:33:46.151]                               parallel_sendData(master, data)
[13:33:46.151]                             }
[13:33:46.151]                             return(sendCondition)
[13:33:46.151]                           }
[13:33:46.151]                         }
[13:33:46.151]                         frame <- frame + 1L
[13:33:46.151]                         envir <- sys.frame(frame)
[13:33:46.151]                       }
[13:33:46.151]                     }
[13:33:46.151]                     sendCondition <<- function(cond) NULL
[13:33:46.151]                   }
[13:33:46.151]                 })
[13:33:46.151]                 withCallingHandlers({
[13:33:46.151]                   {
[13:33:46.151]                     do.call(function(...) {
[13:33:46.151]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:46.151]                       if (!identical(...future.globals.maxSize.org, 
[13:33:46.151]                         ...future.globals.maxSize)) {
[13:33:46.151]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:46.151]                         on.exit(options(oopts), add = TRUE)
[13:33:46.151]                       }
[13:33:46.151]                       {
[13:33:46.151]                         lapply(seq_along(...future.elements_ii), 
[13:33:46.151]                           FUN = function(jj) {
[13:33:46.151]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:46.151]                             ...future.FUN(...future.X_jj, ...)
[13:33:46.151]                           })
[13:33:46.151]                       }
[13:33:46.151]                     }, args = future.call.arguments)
[13:33:46.151]                   }
[13:33:46.151]                 }, immediateCondition = function(cond) {
[13:33:46.151]                   sendCondition <- ...future.makeSendCondition()
[13:33:46.151]                   sendCondition(cond)
[13:33:46.151]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:46.151]                   {
[13:33:46.151]                     inherits <- base::inherits
[13:33:46.151]                     invokeRestart <- base::invokeRestart
[13:33:46.151]                     is.null <- base::is.null
[13:33:46.151]                     muffled <- FALSE
[13:33:46.151]                     if (inherits(cond, "message")) {
[13:33:46.151]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:46.151]                       if (muffled) 
[13:33:46.151]                         invokeRestart("muffleMessage")
[13:33:46.151]                     }
[13:33:46.151]                     else if (inherits(cond, "warning")) {
[13:33:46.151]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:46.151]                       if (muffled) 
[13:33:46.151]                         invokeRestart("muffleWarning")
[13:33:46.151]                     }
[13:33:46.151]                     else if (inherits(cond, "condition")) {
[13:33:46.151]                       if (!is.null(pattern)) {
[13:33:46.151]                         computeRestarts <- base::computeRestarts
[13:33:46.151]                         grepl <- base::grepl
[13:33:46.151]                         restarts <- computeRestarts(cond)
[13:33:46.151]                         for (restart in restarts) {
[13:33:46.151]                           name <- restart$name
[13:33:46.151]                           if (is.null(name)) 
[13:33:46.151]                             next
[13:33:46.151]                           if (!grepl(pattern, name)) 
[13:33:46.151]                             next
[13:33:46.151]                           invokeRestart(restart)
[13:33:46.151]                           muffled <- TRUE
[13:33:46.151]                           break
[13:33:46.151]                         }
[13:33:46.151]                       }
[13:33:46.151]                     }
[13:33:46.151]                     invisible(muffled)
[13:33:46.151]                   }
[13:33:46.151]                   muffleCondition(cond)
[13:33:46.151]                 })
[13:33:46.151]             }))
[13:33:46.151]             future::FutureResult(value = ...future.value$value, 
[13:33:46.151]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:46.151]                   ...future.rng), globalenv = if (FALSE) 
[13:33:46.151]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:46.151]                     ...future.globalenv.names))
[13:33:46.151]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:46.151]         }, condition = base::local({
[13:33:46.151]             c <- base::c
[13:33:46.151]             inherits <- base::inherits
[13:33:46.151]             invokeRestart <- base::invokeRestart
[13:33:46.151]             length <- base::length
[13:33:46.151]             list <- base::list
[13:33:46.151]             seq.int <- base::seq.int
[13:33:46.151]             signalCondition <- base::signalCondition
[13:33:46.151]             sys.calls <- base::sys.calls
[13:33:46.151]             `[[` <- base::`[[`
[13:33:46.151]             `+` <- base::`+`
[13:33:46.151]             `<<-` <- base::`<<-`
[13:33:46.151]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:46.151]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:46.151]                   3L)]
[13:33:46.151]             }
[13:33:46.151]             function(cond) {
[13:33:46.151]                 is_error <- inherits(cond, "error")
[13:33:46.151]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:46.151]                   NULL)
[13:33:46.151]                 if (is_error) {
[13:33:46.151]                   sessionInformation <- function() {
[13:33:46.151]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:46.151]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:46.151]                       search = base::search(), system = base::Sys.info())
[13:33:46.151]                   }
[13:33:46.151]                   ...future.conditions[[length(...future.conditions) + 
[13:33:46.151]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:46.151]                     cond$call), session = sessionInformation(), 
[13:33:46.151]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:46.151]                   signalCondition(cond)
[13:33:46.151]                 }
[13:33:46.151]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:46.151]                 "immediateCondition"))) {
[13:33:46.151]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:46.151]                   ...future.conditions[[length(...future.conditions) + 
[13:33:46.151]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:46.151]                   if (TRUE && !signal) {
[13:33:46.151]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:46.151]                     {
[13:33:46.151]                       inherits <- base::inherits
[13:33:46.151]                       invokeRestart <- base::invokeRestart
[13:33:46.151]                       is.null <- base::is.null
[13:33:46.151]                       muffled <- FALSE
[13:33:46.151]                       if (inherits(cond, "message")) {
[13:33:46.151]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:46.151]                         if (muffled) 
[13:33:46.151]                           invokeRestart("muffleMessage")
[13:33:46.151]                       }
[13:33:46.151]                       else if (inherits(cond, "warning")) {
[13:33:46.151]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:46.151]                         if (muffled) 
[13:33:46.151]                           invokeRestart("muffleWarning")
[13:33:46.151]                       }
[13:33:46.151]                       else if (inherits(cond, "condition")) {
[13:33:46.151]                         if (!is.null(pattern)) {
[13:33:46.151]                           computeRestarts <- base::computeRestarts
[13:33:46.151]                           grepl <- base::grepl
[13:33:46.151]                           restarts <- computeRestarts(cond)
[13:33:46.151]                           for (restart in restarts) {
[13:33:46.151]                             name <- restart$name
[13:33:46.151]                             if (is.null(name)) 
[13:33:46.151]                               next
[13:33:46.151]                             if (!grepl(pattern, name)) 
[13:33:46.151]                               next
[13:33:46.151]                             invokeRestart(restart)
[13:33:46.151]                             muffled <- TRUE
[13:33:46.151]                             break
[13:33:46.151]                           }
[13:33:46.151]                         }
[13:33:46.151]                       }
[13:33:46.151]                       invisible(muffled)
[13:33:46.151]                     }
[13:33:46.151]                     muffleCondition(cond, pattern = "^muffle")
[13:33:46.151]                   }
[13:33:46.151]                 }
[13:33:46.151]                 else {
[13:33:46.151]                   if (TRUE) {
[13:33:46.151]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:46.151]                     {
[13:33:46.151]                       inherits <- base::inherits
[13:33:46.151]                       invokeRestart <- base::invokeRestart
[13:33:46.151]                       is.null <- base::is.null
[13:33:46.151]                       muffled <- FALSE
[13:33:46.151]                       if (inherits(cond, "message")) {
[13:33:46.151]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:46.151]                         if (muffled) 
[13:33:46.151]                           invokeRestart("muffleMessage")
[13:33:46.151]                       }
[13:33:46.151]                       else if (inherits(cond, "warning")) {
[13:33:46.151]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:46.151]                         if (muffled) 
[13:33:46.151]                           invokeRestart("muffleWarning")
[13:33:46.151]                       }
[13:33:46.151]                       else if (inherits(cond, "condition")) {
[13:33:46.151]                         if (!is.null(pattern)) {
[13:33:46.151]                           computeRestarts <- base::computeRestarts
[13:33:46.151]                           grepl <- base::grepl
[13:33:46.151]                           restarts <- computeRestarts(cond)
[13:33:46.151]                           for (restart in restarts) {
[13:33:46.151]                             name <- restart$name
[13:33:46.151]                             if (is.null(name)) 
[13:33:46.151]                               next
[13:33:46.151]                             if (!grepl(pattern, name)) 
[13:33:46.151]                               next
[13:33:46.151]                             invokeRestart(restart)
[13:33:46.151]                             muffled <- TRUE
[13:33:46.151]                             break
[13:33:46.151]                           }
[13:33:46.151]                         }
[13:33:46.151]                       }
[13:33:46.151]                       invisible(muffled)
[13:33:46.151]                     }
[13:33:46.151]                     muffleCondition(cond, pattern = "^muffle")
[13:33:46.151]                   }
[13:33:46.151]                 }
[13:33:46.151]             }
[13:33:46.151]         }))
[13:33:46.151]     }, error = function(ex) {
[13:33:46.151]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:46.151]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:46.151]                 ...future.rng), started = ...future.startTime, 
[13:33:46.151]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:46.151]             version = "1.8"), class = "FutureResult")
[13:33:46.151]     }, finally = {
[13:33:46.151]         if (!identical(...future.workdir, getwd())) 
[13:33:46.151]             setwd(...future.workdir)
[13:33:46.151]         {
[13:33:46.151]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:46.151]                 ...future.oldOptions$nwarnings <- NULL
[13:33:46.151]             }
[13:33:46.151]             base::options(...future.oldOptions)
[13:33:46.151]             if (.Platform$OS.type == "windows") {
[13:33:46.151]                 old_names <- names(...future.oldEnvVars)
[13:33:46.151]                 envs <- base::Sys.getenv()
[13:33:46.151]                 names <- names(envs)
[13:33:46.151]                 common <- intersect(names, old_names)
[13:33:46.151]                 added <- setdiff(names, old_names)
[13:33:46.151]                 removed <- setdiff(old_names, names)
[13:33:46.151]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:46.151]                   envs[common]]
[13:33:46.151]                 NAMES <- toupper(changed)
[13:33:46.151]                 args <- list()
[13:33:46.151]                 for (kk in seq_along(NAMES)) {
[13:33:46.151]                   name <- changed[[kk]]
[13:33:46.151]                   NAME <- NAMES[[kk]]
[13:33:46.151]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:46.151]                     next
[13:33:46.151]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:46.151]                 }
[13:33:46.151]                 NAMES <- toupper(added)
[13:33:46.151]                 for (kk in seq_along(NAMES)) {
[13:33:46.151]                   name <- added[[kk]]
[13:33:46.151]                   NAME <- NAMES[[kk]]
[13:33:46.151]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:46.151]                     next
[13:33:46.151]                   args[[name]] <- ""
[13:33:46.151]                 }
[13:33:46.151]                 NAMES <- toupper(removed)
[13:33:46.151]                 for (kk in seq_along(NAMES)) {
[13:33:46.151]                   name <- removed[[kk]]
[13:33:46.151]                   NAME <- NAMES[[kk]]
[13:33:46.151]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:46.151]                     next
[13:33:46.151]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:46.151]                 }
[13:33:46.151]                 if (length(args) > 0) 
[13:33:46.151]                   base::do.call(base::Sys.setenv, args = args)
[13:33:46.151]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:46.151]             }
[13:33:46.151]             else {
[13:33:46.151]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:46.151]             }
[13:33:46.151]             {
[13:33:46.151]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:46.151]                   0L) {
[13:33:46.151]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:46.151]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:46.151]                   base::options(opts)
[13:33:46.151]                 }
[13:33:46.151]                 {
[13:33:46.151]                   {
[13:33:46.151]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:46.151]                     NULL
[13:33:46.151]                   }
[13:33:46.151]                   options(future.plan = NULL)
[13:33:46.151]                   if (is.na(NA_character_)) 
[13:33:46.151]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:46.151]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:46.151]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:46.151]                     .init = FALSE)
[13:33:46.151]                 }
[13:33:46.151]             }
[13:33:46.151]         }
[13:33:46.151]     })
[13:33:46.151]     if (TRUE) {
[13:33:46.151]         base::sink(type = "output", split = FALSE)
[13:33:46.151]         if (TRUE) {
[13:33:46.151]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:46.151]         }
[13:33:46.151]         else {
[13:33:46.151]             ...future.result["stdout"] <- base::list(NULL)
[13:33:46.151]         }
[13:33:46.151]         base::close(...future.stdout)
[13:33:46.151]         ...future.stdout <- NULL
[13:33:46.151]     }
[13:33:46.151]     ...future.result$conditions <- ...future.conditions
[13:33:46.151]     ...future.result$finished <- base::Sys.time()
[13:33:46.151]     ...future.result
[13:33:46.151] }
[13:33:46.153] Exporting 5 global objects (1.22 KiB) to cluster node #1 ...
[13:33:46.153] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[13:33:46.154] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[13:33:46.154] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:33:46.154] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:33:46.154] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ...
[13:33:46.155] Exporting ‘...future.elements_ii’ (64 bytes) to cluster node #1 ... DONE
[13:33:46.155] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:33:46.155] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:33:46.155] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:33:46.156] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:33:46.156] Exporting 5 global objects (1.22 KiB) to cluster node #1 ... DONE
[13:33:46.156] MultisessionFuture started
[13:33:46.157] - Launch lazy future ... done
[13:33:46.157] run() for ‘MultisessionFuture’ ... done
[13:33:46.157] Created future:
[13:33:46.157] MultisessionFuture:
[13:33:46.157] Label: ‘future_eapply-1’
[13:33:46.157] Expression:
[13:33:46.157] {
[13:33:46.157]     do.call(function(...) {
[13:33:46.157]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:46.157]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:46.157]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:46.157]             on.exit(options(oopts), add = TRUE)
[13:33:46.157]         }
[13:33:46.157]         {
[13:33:46.157]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:46.157]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:46.157]                 ...future.FUN(...future.X_jj, ...)
[13:33:46.157]             })
[13:33:46.157]         }
[13:33:46.157]     }, args = future.call.arguments)
[13:33:46.157] }
[13:33:46.157] Lazy evaluation: FALSE
[13:33:46.157] Asynchronous evaluation: TRUE
[13:33:46.157] Local evaluation: TRUE
[13:33:46.157] Environment: R_GlobalEnv
[13:33:46.157] Capture standard output: TRUE
[13:33:46.157] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:46.157] Globals: 5 objects totaling 1.28 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 64 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:46.157] Packages: 1 packages (‘stats’)
[13:33:46.157] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:46.157] Resolved: FALSE
[13:33:46.157] Value: <not collected>
[13:33:46.157] Conditions captured: <none>
[13:33:46.157] Early signaling: FALSE
[13:33:46.157] Owner process: b6e93464-7fc2-3f8d-23d1-d8004201d1f1
[13:33:46.157] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:46.169] Chunk #1 of 2 ... DONE
[13:33:46.169] Chunk #2 of 2 ...
[13:33:46.169]  - Finding globals in 'X' for chunk #2 ...
[13:33:46.169] getGlobalsAndPackages() ...
[13:33:46.169] Searching for globals...
[13:33:46.169] 
[13:33:46.169] Searching for globals ... DONE
[13:33:46.169] - globals: [0] <none>
[13:33:46.170] getGlobalsAndPackages() ... DONE
[13:33:46.170]    + additional globals found: [n=0] 
[13:33:46.170]    + additional namespaces needed: [n=0] 
[13:33:46.170]  - Finding globals in 'X' for chunk #2 ... DONE
[13:33:46.170]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:33:46.170]  - seeds: <none>
[13:33:46.170]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:46.170] getGlobalsAndPackages() ...
[13:33:46.170] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:46.170] Resolving globals: FALSE
[13:33:46.171] Tweak future expression to call with '...' arguments ...
[13:33:46.171] {
[13:33:46.171]     do.call(function(...) {
[13:33:46.171]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:46.171]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:46.171]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:46.171]             on.exit(options(oopts), add = TRUE)
[13:33:46.171]         }
[13:33:46.171]         {
[13:33:46.171]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:46.171]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:46.171]                 ...future.FUN(...future.X_jj, ...)
[13:33:46.171]             })
[13:33:46.171]         }
[13:33:46.171]     }, args = future.call.arguments)
[13:33:46.171] }
[13:33:46.171] Tweak future expression to call with '...' arguments ... DONE
[13:33:46.171] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:33:46.171] - packages: [1] ‘stats’
[13:33:46.172] getGlobalsAndPackages() ... DONE
[13:33:46.174] run() for ‘Future’ ...
[13:33:46.174] - state: ‘created’
[13:33:46.174] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:33:46.187] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:46.187] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:33:46.188]   - Field: ‘node’
[13:33:46.188]   - Field: ‘label’
[13:33:46.188]   - Field: ‘local’
[13:33:46.188]   - Field: ‘owner’
[13:33:46.188]   - Field: ‘envir’
[13:33:46.188]   - Field: ‘workers’
[13:33:46.188]   - Field: ‘packages’
[13:33:46.188]   - Field: ‘gc’
[13:33:46.188]   - Field: ‘conditions’
[13:33:46.188]   - Field: ‘persistent’
[13:33:46.188]   - Field: ‘expr’
[13:33:46.189]   - Field: ‘uuid’
[13:33:46.189]   - Field: ‘seed’
[13:33:46.189]   - Field: ‘version’
[13:33:46.189]   - Field: ‘result’
[13:33:46.189]   - Field: ‘asynchronous’
[13:33:46.189]   - Field: ‘calls’
[13:33:46.189]   - Field: ‘globals’
[13:33:46.189]   - Field: ‘stdout’
[13:33:46.189]   - Field: ‘earlySignal’
[13:33:46.189]   - Field: ‘lazy’
[13:33:46.189]   - Field: ‘state’
[13:33:46.189] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:33:46.190] - Launch lazy future ...
[13:33:46.190] Packages needed by the future expression (n = 1): ‘stats’
[13:33:46.190] Packages needed by future strategies (n = 0): <none>
[13:33:46.190] {
[13:33:46.190]     {
[13:33:46.190]         {
[13:33:46.190]             ...future.startTime <- base::Sys.time()
[13:33:46.190]             {
[13:33:46.190]                 {
[13:33:46.190]                   {
[13:33:46.190]                     {
[13:33:46.190]                       {
[13:33:46.190]                         base::local({
[13:33:46.190]                           has_future <- base::requireNamespace("future", 
[13:33:46.190]                             quietly = TRUE)
[13:33:46.190]                           if (has_future) {
[13:33:46.190]                             ns <- base::getNamespace("future")
[13:33:46.190]                             version <- ns[[".package"]][["version"]]
[13:33:46.190]                             if (is.null(version)) 
[13:33:46.190]                               version <- utils::packageVersion("future")
[13:33:46.190]                           }
[13:33:46.190]                           else {
[13:33:46.190]                             version <- NULL
[13:33:46.190]                           }
[13:33:46.190]                           if (!has_future || version < "1.8.0") {
[13:33:46.190]                             info <- base::c(r_version = base::gsub("R version ", 
[13:33:46.190]                               "", base::R.version$version.string), 
[13:33:46.190]                               platform = base::sprintf("%s (%s-bit)", 
[13:33:46.190]                                 base::R.version$platform, 8 * 
[13:33:46.190]                                   base::.Machine$sizeof.pointer), 
[13:33:46.190]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:33:46.190]                                 "release", "version")], collapse = " "), 
[13:33:46.190]                               hostname = base::Sys.info()[["nodename"]])
[13:33:46.190]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:33:46.190]                               info)
[13:33:46.190]                             info <- base::paste(info, collapse = "; ")
[13:33:46.190]                             if (!has_future) {
[13:33:46.190]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:33:46.190]                                 info)
[13:33:46.190]                             }
[13:33:46.190]                             else {
[13:33:46.190]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:33:46.190]                                 info, version)
[13:33:46.190]                             }
[13:33:46.190]                             base::stop(msg)
[13:33:46.190]                           }
[13:33:46.190]                         })
[13:33:46.190]                       }
[13:33:46.190]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:33:46.190]                       base::options(mc.cores = 1L)
[13:33:46.190]                     }
[13:33:46.190]                     base::local({
[13:33:46.190]                       for (pkg in "stats") {
[13:33:46.190]                         base::loadNamespace(pkg)
[13:33:46.190]                         base::library(pkg, character.only = TRUE)
[13:33:46.190]                       }
[13:33:46.190]                     })
[13:33:46.190]                   }
[13:33:46.190]                   ...future.strategy.old <- future::plan("list")
[13:33:46.190]                   options(future.plan = NULL)
[13:33:46.190]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:33:46.190]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:33:46.190]                 }
[13:33:46.190]                 ...future.workdir <- getwd()
[13:33:46.190]             }
[13:33:46.190]             ...future.oldOptions <- base::as.list(base::.Options)
[13:33:46.190]             ...future.oldEnvVars <- base::Sys.getenv()
[13:33:46.190]         }
[13:33:46.190]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:33:46.190]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:33:46.190]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:33:46.190]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:33:46.190]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:33:46.190]             future.stdout.windows.reencode = NULL, width = 80L)
[13:33:46.190]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:33:46.190]             base::names(...future.oldOptions))
[13:33:46.190]     }
[13:33:46.190]     if (FALSE) {
[13:33:46.190]     }
[13:33:46.190]     else {
[13:33:46.190]         if (TRUE) {
[13:33:46.190]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:33:46.190]                 open = "w")
[13:33:46.190]         }
[13:33:46.190]         else {
[13:33:46.190]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:33:46.190]                 windows = "NUL", "/dev/null"), open = "w")
[13:33:46.190]         }
[13:33:46.190]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:33:46.190]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:33:46.190]             base::sink(type = "output", split = FALSE)
[13:33:46.190]             base::close(...future.stdout)
[13:33:46.190]         }, add = TRUE)
[13:33:46.190]     }
[13:33:46.190]     ...future.frame <- base::sys.nframe()
[13:33:46.190]     ...future.conditions <- base::list()
[13:33:46.190]     ...future.rng <- base::globalenv()$.Random.seed
[13:33:46.190]     if (FALSE) {
[13:33:46.190]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:33:46.190]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:33:46.190]     }
[13:33:46.190]     ...future.result <- base::tryCatch({
[13:33:46.190]         base::withCallingHandlers({
[13:33:46.190]             ...future.value <- base::withVisible(base::local({
[13:33:46.190]                 ...future.makeSendCondition <- base::local({
[13:33:46.190]                   sendCondition <- NULL
[13:33:46.190]                   function(frame = 1L) {
[13:33:46.190]                     if (is.function(sendCondition)) 
[13:33:46.190]                       return(sendCondition)
[13:33:46.190]                     ns <- getNamespace("parallel")
[13:33:46.190]                     if (exists("sendData", mode = "function", 
[13:33:46.190]                       envir = ns)) {
[13:33:46.190]                       parallel_sendData <- get("sendData", mode = "function", 
[13:33:46.190]                         envir = ns)
[13:33:46.190]                       envir <- sys.frame(frame)
[13:33:46.190]                       master <- NULL
[13:33:46.190]                       while (!identical(envir, .GlobalEnv) && 
[13:33:46.190]                         !identical(envir, emptyenv())) {
[13:33:46.190]                         if (exists("master", mode = "list", envir = envir, 
[13:33:46.190]                           inherits = FALSE)) {
[13:33:46.190]                           master <- get("master", mode = "list", 
[13:33:46.190]                             envir = envir, inherits = FALSE)
[13:33:46.190]                           if (inherits(master, c("SOCKnode", 
[13:33:46.190]                             "SOCK0node"))) {
[13:33:46.190]                             sendCondition <<- function(cond) {
[13:33:46.190]                               data <- list(type = "VALUE", value = cond, 
[13:33:46.190]                                 success = TRUE)
[13:33:46.190]                               parallel_sendData(master, data)
[13:33:46.190]                             }
[13:33:46.190]                             return(sendCondition)
[13:33:46.190]                           }
[13:33:46.190]                         }
[13:33:46.190]                         frame <- frame + 1L
[13:33:46.190]                         envir <- sys.frame(frame)
[13:33:46.190]                       }
[13:33:46.190]                     }
[13:33:46.190]                     sendCondition <<- function(cond) NULL
[13:33:46.190]                   }
[13:33:46.190]                 })
[13:33:46.190]                 withCallingHandlers({
[13:33:46.190]                   {
[13:33:46.190]                     do.call(function(...) {
[13:33:46.190]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:46.190]                       if (!identical(...future.globals.maxSize.org, 
[13:33:46.190]                         ...future.globals.maxSize)) {
[13:33:46.190]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:46.190]                         on.exit(options(oopts), add = TRUE)
[13:33:46.190]                       }
[13:33:46.190]                       {
[13:33:46.190]                         lapply(seq_along(...future.elements_ii), 
[13:33:46.190]                           FUN = function(jj) {
[13:33:46.190]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:46.190]                             ...future.FUN(...future.X_jj, ...)
[13:33:46.190]                           })
[13:33:46.190]                       }
[13:33:46.190]                     }, args = future.call.arguments)
[13:33:46.190]                   }
[13:33:46.190]                 }, immediateCondition = function(cond) {
[13:33:46.190]                   sendCondition <- ...future.makeSendCondition()
[13:33:46.190]                   sendCondition(cond)
[13:33:46.190]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:46.190]                   {
[13:33:46.190]                     inherits <- base::inherits
[13:33:46.190]                     invokeRestart <- base::invokeRestart
[13:33:46.190]                     is.null <- base::is.null
[13:33:46.190]                     muffled <- FALSE
[13:33:46.190]                     if (inherits(cond, "message")) {
[13:33:46.190]                       muffled <- grepl(pattern, "muffleMessage")
[13:33:46.190]                       if (muffled) 
[13:33:46.190]                         invokeRestart("muffleMessage")
[13:33:46.190]                     }
[13:33:46.190]                     else if (inherits(cond, "warning")) {
[13:33:46.190]                       muffled <- grepl(pattern, "muffleWarning")
[13:33:46.190]                       if (muffled) 
[13:33:46.190]                         invokeRestart("muffleWarning")
[13:33:46.190]                     }
[13:33:46.190]                     else if (inherits(cond, "condition")) {
[13:33:46.190]                       if (!is.null(pattern)) {
[13:33:46.190]                         computeRestarts <- base::computeRestarts
[13:33:46.190]                         grepl <- base::grepl
[13:33:46.190]                         restarts <- computeRestarts(cond)
[13:33:46.190]                         for (restart in restarts) {
[13:33:46.190]                           name <- restart$name
[13:33:46.190]                           if (is.null(name)) 
[13:33:46.190]                             next
[13:33:46.190]                           if (!grepl(pattern, name)) 
[13:33:46.190]                             next
[13:33:46.190]                           invokeRestart(restart)
[13:33:46.190]                           muffled <- TRUE
[13:33:46.190]                           break
[13:33:46.190]                         }
[13:33:46.190]                       }
[13:33:46.190]                     }
[13:33:46.190]                     invisible(muffled)
[13:33:46.190]                   }
[13:33:46.190]                   muffleCondition(cond)
[13:33:46.190]                 })
[13:33:46.190]             }))
[13:33:46.190]             future::FutureResult(value = ...future.value$value, 
[13:33:46.190]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:46.190]                   ...future.rng), globalenv = if (FALSE) 
[13:33:46.190]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:33:46.190]                     ...future.globalenv.names))
[13:33:46.190]                 else NULL, started = ...future.startTime, version = "1.8")
[13:33:46.190]         }, condition = base::local({
[13:33:46.190]             c <- base::c
[13:33:46.190]             inherits <- base::inherits
[13:33:46.190]             invokeRestart <- base::invokeRestart
[13:33:46.190]             length <- base::length
[13:33:46.190]             list <- base::list
[13:33:46.190]             seq.int <- base::seq.int
[13:33:46.190]             signalCondition <- base::signalCondition
[13:33:46.190]             sys.calls <- base::sys.calls
[13:33:46.190]             `[[` <- base::`[[`
[13:33:46.190]             `+` <- base::`+`
[13:33:46.190]             `<<-` <- base::`<<-`
[13:33:46.190]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:33:46.190]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:33:46.190]                   3L)]
[13:33:46.190]             }
[13:33:46.190]             function(cond) {
[13:33:46.190]                 is_error <- inherits(cond, "error")
[13:33:46.190]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:33:46.190]                   NULL)
[13:33:46.190]                 if (is_error) {
[13:33:46.190]                   sessionInformation <- function() {
[13:33:46.190]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:33:46.190]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:33:46.190]                       search = base::search(), system = base::Sys.info())
[13:33:46.190]                   }
[13:33:46.190]                   ...future.conditions[[length(...future.conditions) + 
[13:33:46.190]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:33:46.190]                     cond$call), session = sessionInformation(), 
[13:33:46.190]                     timestamp = base::Sys.time(), signaled = 0L)
[13:33:46.190]                   signalCondition(cond)
[13:33:46.190]                 }
[13:33:46.190]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:33:46.190]                 "immediateCondition"))) {
[13:33:46.190]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:33:46.190]                   ...future.conditions[[length(...future.conditions) + 
[13:33:46.190]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:33:46.190]                   if (TRUE && !signal) {
[13:33:46.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:46.190]                     {
[13:33:46.190]                       inherits <- base::inherits
[13:33:46.190]                       invokeRestart <- base::invokeRestart
[13:33:46.190]                       is.null <- base::is.null
[13:33:46.190]                       muffled <- FALSE
[13:33:46.190]                       if (inherits(cond, "message")) {
[13:33:46.190]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:46.190]                         if (muffled) 
[13:33:46.190]                           invokeRestart("muffleMessage")
[13:33:46.190]                       }
[13:33:46.190]                       else if (inherits(cond, "warning")) {
[13:33:46.190]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:46.190]                         if (muffled) 
[13:33:46.190]                           invokeRestart("muffleWarning")
[13:33:46.190]                       }
[13:33:46.190]                       else if (inherits(cond, "condition")) {
[13:33:46.190]                         if (!is.null(pattern)) {
[13:33:46.190]                           computeRestarts <- base::computeRestarts
[13:33:46.190]                           grepl <- base::grepl
[13:33:46.190]                           restarts <- computeRestarts(cond)
[13:33:46.190]                           for (restart in restarts) {
[13:33:46.190]                             name <- restart$name
[13:33:46.190]                             if (is.null(name)) 
[13:33:46.190]                               next
[13:33:46.190]                             if (!grepl(pattern, name)) 
[13:33:46.190]                               next
[13:33:46.190]                             invokeRestart(restart)
[13:33:46.190]                             muffled <- TRUE
[13:33:46.190]                             break
[13:33:46.190]                           }
[13:33:46.190]                         }
[13:33:46.190]                       }
[13:33:46.190]                       invisible(muffled)
[13:33:46.190]                     }
[13:33:46.190]                     muffleCondition(cond, pattern = "^muffle")
[13:33:46.190]                   }
[13:33:46.190]                 }
[13:33:46.190]                 else {
[13:33:46.190]                   if (TRUE) {
[13:33:46.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:33:46.190]                     {
[13:33:46.190]                       inherits <- base::inherits
[13:33:46.190]                       invokeRestart <- base::invokeRestart
[13:33:46.190]                       is.null <- base::is.null
[13:33:46.190]                       muffled <- FALSE
[13:33:46.190]                       if (inherits(cond, "message")) {
[13:33:46.190]                         muffled <- grepl(pattern, "muffleMessage")
[13:33:46.190]                         if (muffled) 
[13:33:46.190]                           invokeRestart("muffleMessage")
[13:33:46.190]                       }
[13:33:46.190]                       else if (inherits(cond, "warning")) {
[13:33:46.190]                         muffled <- grepl(pattern, "muffleWarning")
[13:33:46.190]                         if (muffled) 
[13:33:46.190]                           invokeRestart("muffleWarning")
[13:33:46.190]                       }
[13:33:46.190]                       else if (inherits(cond, "condition")) {
[13:33:46.190]                         if (!is.null(pattern)) {
[13:33:46.190]                           computeRestarts <- base::computeRestarts
[13:33:46.190]                           grepl <- base::grepl
[13:33:46.190]                           restarts <- computeRestarts(cond)
[13:33:46.190]                           for (restart in restarts) {
[13:33:46.190]                             name <- restart$name
[13:33:46.190]                             if (is.null(name)) 
[13:33:46.190]                               next
[13:33:46.190]                             if (!grepl(pattern, name)) 
[13:33:46.190]                               next
[13:33:46.190]                             invokeRestart(restart)
[13:33:46.190]                             muffled <- TRUE
[13:33:46.190]                             break
[13:33:46.190]                           }
[13:33:46.190]                         }
[13:33:46.190]                       }
[13:33:46.190]                       invisible(muffled)
[13:33:46.190]                     }
[13:33:46.190]                     muffleCondition(cond, pattern = "^muffle")
[13:33:46.190]                   }
[13:33:46.190]                 }
[13:33:46.190]             }
[13:33:46.190]         }))
[13:33:46.190]     }, error = function(ex) {
[13:33:46.190]         base::structure(base::list(value = NULL, visible = NULL, 
[13:33:46.190]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:33:46.190]                 ...future.rng), started = ...future.startTime, 
[13:33:46.190]             finished = Sys.time(), session_uuid = NA_character_, 
[13:33:46.190]             version = "1.8"), class = "FutureResult")
[13:33:46.190]     }, finally = {
[13:33:46.190]         if (!identical(...future.workdir, getwd())) 
[13:33:46.190]             setwd(...future.workdir)
[13:33:46.190]         {
[13:33:46.190]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:33:46.190]                 ...future.oldOptions$nwarnings <- NULL
[13:33:46.190]             }
[13:33:46.190]             base::options(...future.oldOptions)
[13:33:46.190]             if (.Platform$OS.type == "windows") {
[13:33:46.190]                 old_names <- names(...future.oldEnvVars)
[13:33:46.190]                 envs <- base::Sys.getenv()
[13:33:46.190]                 names <- names(envs)
[13:33:46.190]                 common <- intersect(names, old_names)
[13:33:46.190]                 added <- setdiff(names, old_names)
[13:33:46.190]                 removed <- setdiff(old_names, names)
[13:33:46.190]                 changed <- common[...future.oldEnvVars[common] != 
[13:33:46.190]                   envs[common]]
[13:33:46.190]                 NAMES <- toupper(changed)
[13:33:46.190]                 args <- list()
[13:33:46.190]                 for (kk in seq_along(NAMES)) {
[13:33:46.190]                   name <- changed[[kk]]
[13:33:46.190]                   NAME <- NAMES[[kk]]
[13:33:46.190]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:46.190]                     next
[13:33:46.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:46.190]                 }
[13:33:46.190]                 NAMES <- toupper(added)
[13:33:46.190]                 for (kk in seq_along(NAMES)) {
[13:33:46.190]                   name <- added[[kk]]
[13:33:46.190]                   NAME <- NAMES[[kk]]
[13:33:46.190]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:46.190]                     next
[13:33:46.190]                   args[[name]] <- ""
[13:33:46.190]                 }
[13:33:46.190]                 NAMES <- toupper(removed)
[13:33:46.190]                 for (kk in seq_along(NAMES)) {
[13:33:46.190]                   name <- removed[[kk]]
[13:33:46.190]                   NAME <- NAMES[[kk]]
[13:33:46.190]                   if (name != NAME && is.element(NAME, old_names)) 
[13:33:46.190]                     next
[13:33:46.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:33:46.190]                 }
[13:33:46.190]                 if (length(args) > 0) 
[13:33:46.190]                   base::do.call(base::Sys.setenv, args = args)
[13:33:46.190]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:33:46.190]             }
[13:33:46.190]             else {
[13:33:46.190]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:33:46.190]             }
[13:33:46.190]             {
[13:33:46.190]                 if (base::length(...future.futureOptionsAdded) > 
[13:33:46.190]                   0L) {
[13:33:46.190]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:33:46.190]                   base::names(opts) <- ...future.futureOptionsAdded
[13:33:46.190]                   base::options(opts)
[13:33:46.190]                 }
[13:33:46.190]                 {
[13:33:46.190]                   {
[13:33:46.190]                     base::options(mc.cores = ...future.mc.cores.old)
[13:33:46.190]                     NULL
[13:33:46.190]                   }
[13:33:46.190]                   options(future.plan = NULL)
[13:33:46.190]                   if (is.na(NA_character_)) 
[13:33:46.190]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:33:46.190]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:33:46.190]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:33:46.190]                     .init = FALSE)
[13:33:46.190]                 }
[13:33:46.190]             }
[13:33:46.190]         }
[13:33:46.190]     })
[13:33:46.190]     if (TRUE) {
[13:33:46.190]         base::sink(type = "output", split = FALSE)
[13:33:46.190]         if (TRUE) {
[13:33:46.190]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:33:46.190]         }
[13:33:46.190]         else {
[13:33:46.190]             ...future.result["stdout"] <- base::list(NULL)
[13:33:46.190]         }
[13:33:46.190]         base::close(...future.stdout)
[13:33:46.190]         ...future.stdout <- NULL
[13:33:46.190]     }
[13:33:46.190]     ...future.result$conditions <- ...future.conditions
[13:33:46.190]     ...future.result$finished <- base::Sys.time()
[13:33:46.190]     ...future.result
[13:33:46.190] }
[13:33:46.193] Exporting 5 global objects (1.22 KiB) to cluster node #2 ...
[13:33:46.193] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[13:33:46.194] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[13:33:46.194] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:33:46.194] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:33:46.194] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ...
[13:33:46.195] Exporting ‘...future.elements_ii’ (208 bytes) to cluster node #2 ... DONE
[13:33:46.195] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:33:46.195] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:33:46.195] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:33:46.195] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:33:46.195] Exporting 5 global objects (1.22 KiB) to cluster node #2 ... DONE
[13:33:46.196] MultisessionFuture started
[13:33:46.196] - Launch lazy future ... done
[13:33:46.196] run() for ‘MultisessionFuture’ ... done
[13:33:46.196] Created future:
[13:33:46.196] MultisessionFuture:
[13:33:46.196] Label: ‘future_eapply-2’
[13:33:46.196] Expression:
[13:33:46.196] {
[13:33:46.196]     do.call(function(...) {
[13:33:46.196]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:33:46.196]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:33:46.196]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:33:46.196]             on.exit(options(oopts), add = TRUE)
[13:33:46.196]         }
[13:33:46.196]         {
[13:33:46.196]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:33:46.196]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:33:46.196]                 ...future.FUN(...future.X_jj, ...)
[13:33:46.196]             })
[13:33:46.196]         }
[13:33:46.196]     }, args = future.call.arguments)
[13:33:46.196] }
[13:33:46.196] Lazy evaluation: FALSE
[13:33:46.196] Asynchronous evaluation: TRUE
[13:33:46.196] Local evaluation: TRUE
[13:33:46.196] Environment: R_GlobalEnv
[13:33:46.196] Capture standard output: TRUE
[13:33:46.196] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:33:46.196] Globals: 5 objects totaling 1.42 KiB (function ‘...future.FUN’ of 1.22 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 208 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:33:46.196] Packages: 1 packages (‘stats’)
[13:33:46.196] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:33:46.196] Resolved: FALSE
[13:33:46.196] Value: <not collected>
[13:33:46.196] Conditions captured: <none>
[13:33:46.196] Early signaling: FALSE
[13:33:46.196] Owner process: b6e93464-7fc2-3f8d-23d1-d8004201d1f1
[13:33:46.196] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:33:46.208] Chunk #2 of 2 ... DONE
[13:33:46.208] Launching 2 futures (chunks) ... DONE
[13:33:46.208] Resolving 2 futures (chunks) ...
[13:33:46.208] resolve() on list ...
[13:33:46.208]  recursive: 0
[13:33:46.208]  length: 2
[13:33:46.208] 
[13:33:46.209] receiveMessageFromWorker() for ClusterFuture ...
[13:33:46.209] - Validating connection of MultisessionFuture
[13:33:46.209] - received message: FutureResult
[13:33:46.209] - Received FutureResult
[13:33:46.209] - Erased future from FutureRegistry
[13:33:46.209] result() for ClusterFuture ...
[13:33:46.209] - result already collected: FutureResult
[13:33:46.209] result() for ClusterFuture ... done
[13:33:46.210] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:46.210] Future #1
[13:33:46.210] result() for ClusterFuture ...
[13:33:46.210] - result already collected: FutureResult
[13:33:46.210] result() for ClusterFuture ... done
[13:33:46.210] result() for ClusterFuture ...
[13:33:46.210] - result already collected: FutureResult
[13:33:46.210] result() for ClusterFuture ... done
[13:33:46.210] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:33:46.210] - nx: 2
[13:33:46.210] - relay: TRUE
[13:33:46.211] - stdout: TRUE
[13:33:46.211] - signal: TRUE
[13:33:46.211] - resignal: FALSE
[13:33:46.211] - force: TRUE
[13:33:46.211] - relayed: [n=2] FALSE, FALSE
[13:33:46.211] - queued futures: [n=2] FALSE, FALSE
[13:33:46.211]  - until=1
[13:33:46.211]  - relaying element #1
[13:33:46.211] result() for ClusterFuture ...
[13:33:46.211] - result already collected: FutureResult
[13:33:46.211] result() for ClusterFuture ... done
[13:33:46.212] result() for ClusterFuture ...
[13:33:46.212] - result already collected: FutureResult
[13:33:46.212] result() for ClusterFuture ... done
[13:33:46.212] result() for ClusterFuture ...
[13:33:46.212] - result already collected: FutureResult
[13:33:46.212] result() for ClusterFuture ... done
[13:33:46.212] result() for ClusterFuture ...
[13:33:46.212] - result already collected: FutureResult
[13:33:46.212] result() for ClusterFuture ... done
[13:33:46.212] - relayed: [n=2] TRUE, FALSE
[13:33:46.212] - queued futures: [n=2] TRUE, FALSE
[13:33:46.212] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:33:46.213]  length: 1 (resolved future 1)
[13:33:46.240] receiveMessageFromWorker() for ClusterFuture ...
[13:33:46.240] - Validating connection of MultisessionFuture
[13:33:46.241] - received message: FutureResult
[13:33:46.241] - Received FutureResult
[13:33:46.241] - Erased future from FutureRegistry
[13:33:46.241] result() for ClusterFuture ...
[13:33:46.241] - result already collected: FutureResult
[13:33:46.241] result() for ClusterFuture ... done
[13:33:46.241] receiveMessageFromWorker() for ClusterFuture ... done
[13:33:46.241] Future #2
[13:33:46.242] result() for ClusterFuture ...
[13:33:46.242] - result already collected: FutureResult
[13:33:46.242] result() for ClusterFuture ... done
[13:33:46.242] result() for ClusterFuture ...
[13:33:46.242] - result already collected: FutureResult
[13:33:46.242] result() for ClusterFuture ... done
[13:33:46.242] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:33:46.242] - nx: 2
[13:33:46.242] - relay: TRUE
[13:33:46.242] - stdout: TRUE
[13:33:46.242] - signal: TRUE
[13:33:46.243] - resignal: FALSE
[13:33:46.243] - force: TRUE
[13:33:46.243] - relayed: [n=2] TRUE, FALSE
[13:33:46.243] - queued futures: [n=2] TRUE, FALSE
[13:33:46.243]  - until=2
[13:33:46.243]  - relaying element #2
[13:33:46.243] result() for ClusterFuture ...
[13:33:46.243] - result already collected: FutureResult
[13:33:46.243] result() for ClusterFuture ... done
[13:33:46.243] result() for ClusterFuture ...
[13:33:46.243] - result already collected: FutureResult
[13:33:46.244] result() for ClusterFuture ... done
[13:33:46.244] result() for ClusterFuture ...
[13:33:46.244] - result already collected: FutureResult
[13:33:46.244] result() for ClusterFuture ... done
[13:33:46.244] result() for ClusterFuture ...
[13:33:46.244] - result already collected: FutureResult
[13:33:46.244] result() for ClusterFuture ... done
[13:33:46.244] - relayed: [n=2] TRUE, TRUE
[13:33:46.244] - queued futures: [n=2] TRUE, TRUE
[13:33:46.244] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:33:46.244]  length: 0 (resolved future 2)
[13:33:46.245] Relaying remaining futures
[13:33:46.245] signalConditionsASAP(NULL, pos=0) ...
[13:33:46.245] - nx: 2
[13:33:46.245] - relay: TRUE
[13:33:46.245] - stdout: TRUE
[13:33:46.245] - signal: TRUE
[13:33:46.245] - resignal: FALSE
[13:33:46.245] - force: TRUE
[13:33:46.245] - relayed: [n=2] TRUE, TRUE
[13:33:46.245] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:33:46.245] - relayed: [n=2] TRUE, TRUE
[13:33:46.246] - queued futures: [n=2] TRUE, TRUE
[13:33:46.246] signalConditionsASAP(NULL, pos=0) ... done
[13:33:46.246] resolve() on list ... DONE
[13:33:46.246] result() for ClusterFuture ...
[13:33:46.246] - result already collected: FutureResult
[13:33:46.246] result() for ClusterFuture ... done
[13:33:46.246] result() for ClusterFuture ...
[13:33:46.246] - result already collected: FutureResult
[13:33:46.246] result() for ClusterFuture ... done
[13:33:46.246] result() for ClusterFuture ...
[13:33:46.246] - result already collected: FutureResult
[13:33:46.247] result() for ClusterFuture ... done
[13:33:46.247] result() for ClusterFuture ...
[13:33:46.247] - result already collected: FutureResult
[13:33:46.247] result() for ClusterFuture ... done
[13:33:46.247]  - Number of value chunks collected: 2
[13:33:46.247] Resolving 2 futures (chunks) ... DONE
[13:33:46.247] Reducing values from 2 chunks ...
[13:33:46.247]  - Number of values collected after concatenation: 3
[13:33:46.247]  - Number of values expected: 3
[13:33:46.247] Reducing values from 2 chunks ... DONE
[13:33:46.248] future_lapply() ... DONE
[13:33:46.248] plan(): Setting new future strategy stack:
[13:33:46.248] List of future strategies:
[13:33:46.248] 1. sequential:
[13:33:46.248]    - args: function (..., envir = parent.frame())
[13:33:46.248]    - tweaked: FALSE
[13:33:46.248]    - call: plan(sequential)
[13:33:46.249] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> message("*** future_eapply() ... DONE")
*** future_eapply() ... DONE
> 
> source("incl/end.R")
[13:33:46.250] plan(): Setting new future strategy stack:
[13:33:46.250] List of future strategies:
[13:33:46.250] 1. FutureStrategy:
[13:33:46.250]    - args: function (..., envir = parent.frame())
[13:33:46.250]    - tweaked: FALSE
[13:33:46.250]    - call: future::plan(oplan)
[13:33:46.250] plan(): nbrOfWorkers() = 1
> 
