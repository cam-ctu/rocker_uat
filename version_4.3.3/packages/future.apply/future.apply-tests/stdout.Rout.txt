
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[13:35:19.920] plan(): Setting new future strategy stack:
[13:35:19.920] List of future strategies:
[13:35:19.920] 1. sequential:
[13:35:19.920]    - args: function (..., envir = parent.frame())
[13:35:19.920]    - tweaked: FALSE
[13:35:19.920]    - call: future::plan("sequential")
[13:35:19.933] plan(): nbrOfWorkers() = 1
> 
> message("*** future_*apply() and 'future.stdout' ...")
*** future_*apply() and 'future.stdout' ...
> 
> options(future.debug = TRUE)
> 
> truth <- list()
> 
> out <- utils::capture.output({
+   y <- lapply(1:0, FUN = function(x) {
+     print(x)
+   })
+ })
> truth[["lapply"]] <- list(value = y, stdout = out)
> 
> out <- utils::capture.output({
+   y <- mapply(1:0, 0:1, FUN = function(x, y) {
+     print(list(x = x, y = y))
+   })
+ })
> truth[["mapply"]] <- list(value = y, stdout = out)
> 
> for (cores in 1:availCores) {
+   message(sprintf("  - Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+   
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("* plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     for (fun in names(truth)) {
+       for (stdout in c(FALSE, TRUE, NA)) {
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ...", fun, stdout))
+   
+         out <- utils::capture.output({
+           if (fun == "lapply") {
+             y <- future_lapply(1:0, FUN = function(x) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+ 	      print(x)
+             }, future.stdout = stdout)
+ 	  } else if (fun == "mapply") {
+             y <- future_mapply(1:0, 0:1, FUN = function(x, y) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+               print(list(x = x, y = y))
+             }, future.stdout = stdout)
+ 	  }
+         })
+         stopifnot(identical(y, truth[[fun]]$value))
+   
+         if (isTRUE(stdout)) {
+           stopifnot(identical(out, truth[[fun]]$stdout))
+         } else if (is.na(stdout)) {
+         } else {
+           stopifnot(nchar(out) == 0)
+         }
+       
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ... DONE", fun, stdout))
+       } ## for (stdout ...)
+     } ## for (fun ...)
+     
+     message(sprintf("* plan('%s') ... DONE", strategy))
+   }
+   
+   message(sprintf("  - Testing with %d cores ... DONE", cores))
+ }
  - Testing with 1 cores ...
* plan('sequential') ...
[13:35:19.965] plan(): Setting new future strategy stack:
[13:35:19.966] List of future strategies:
[13:35:19.966] 1. sequential:
[13:35:19.966]    - args: function (..., envir = parent.frame())
[13:35:19.966]    - tweaked: FALSE
[13:35:19.966]    - call: plan(strategy)
[13:35:19.976] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[13:35:19.976] future_lapply() ...
[13:35:19.980] Number of chunks: 1
[13:35:19.981] getGlobalsAndPackagesXApply() ...
[13:35:19.981]  - future.globals: TRUE
[13:35:19.981] getGlobalsAndPackages() ...
[13:35:19.981] Searching for globals...
[13:35:19.984] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:35:19.984] Searching for globals ... DONE
[13:35:19.984] Resolving globals: FALSE
[13:35:19.985] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:35:19.986] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:35:19.986] - globals: [1] ‘FUN’
[13:35:19.986] 
[13:35:19.986] getGlobalsAndPackages() ... DONE
[13:35:19.986]  - globals found/used: [n=1] ‘FUN’
[13:35:19.986]  - needed namespaces: [n=0] 
[13:35:19.986] Finding globals ... DONE
[13:35:19.986]  - use_args: TRUE
[13:35:19.987]  - Getting '...' globals ...
[13:35:19.987] resolve() on list ...
[13:35:19.987]  recursive: 0
[13:35:19.988]  length: 1
[13:35:19.988]  elements: ‘...’
[13:35:19.988]  length: 0 (resolved future 1)
[13:35:19.988] resolve() on list ... DONE
[13:35:19.988]    - '...' content: [n=0] 
[13:35:19.988] List of 1
[13:35:19.988]  $ ...: list()
[13:35:19.988]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:19.988]  - attr(*, "where")=List of 1
[13:35:19.988]   ..$ ...:<environment: 0x558d3866f738> 
[13:35:19.988]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:19.988]  - attr(*, "resolved")= logi TRUE
[13:35:19.988]  - attr(*, "total_size")= num NA
[13:35:19.995]  - Getting '...' globals ... DONE
[13:35:19.995] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:35:19.995] List of 2
[13:35:19.995]  $ ...future.FUN:function (x)  
[13:35:19.995]  $ ...          : list()
[13:35:19.995]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:19.995]  - attr(*, "where")=List of 2
[13:35:19.995]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:19.995]   ..$ ...          :<environment: 0x558d3866f738> 
[13:35:19.995]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:19.995]  - attr(*, "resolved")= logi FALSE
[13:35:19.995]  - attr(*, "total_size")= num 4720
[13:35:19.998] Packages to be attached in all futures: [n=0] 
[13:35:19.998] getGlobalsAndPackagesXApply() ... DONE
[13:35:19.998] Number of futures (= number of chunks): 1
[13:35:19.998] Launching 1 futures (chunks) ...
[13:35:19.998] Chunk #1 of 1 ...
[13:35:19.998]  - Finding globals in 'X' for chunk #1 ...
[13:35:19.999] getGlobalsAndPackages() ...
[13:35:19.999] Searching for globals...
[13:35:19.999] 
[13:35:19.999] Searching for globals ... DONE
[13:35:19.999] - globals: [0] <none>
[13:35:19.999] getGlobalsAndPackages() ... DONE
[13:35:19.999]    + additional globals found: [n=0] 
[13:35:19.999]    + additional namespaces needed: [n=0] 
[13:35:20.000]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:20.000]  - seeds: <none>
[13:35:20.000]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:20.000] getGlobalsAndPackages() ...
[13:35:20.000] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:20.000] Resolving globals: FALSE
[13:35:20.000] Tweak future expression to call with '...' arguments ...
[13:35:20.000] {
[13:35:20.000]     do.call(function(...) {
[13:35:20.000]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:20.000]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:20.000]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:20.000]             on.exit(options(oopts), add = TRUE)
[13:35:20.000]         }
[13:35:20.000]         {
[13:35:20.000]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:20.000]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:20.000]                 ...future.FUN(...future.X_jj, ...)
[13:35:20.000]             })
[13:35:20.000]         }
[13:35:20.000]     }, args = future.call.arguments)
[13:35:20.000] }
[13:35:20.001] Tweak future expression to call with '...' arguments ... DONE
[13:35:20.001] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:20.001] 
[13:35:20.001] getGlobalsAndPackages() ... DONE
[13:35:20.002] run() for ‘Future’ ...
[13:35:20.002] - state: ‘created’
[13:35:20.002] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:35:20.002] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:20.003] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:20.003]   - Field: ‘label’
[13:35:20.003]   - Field: ‘local’
[13:35:20.003]   - Field: ‘owner’
[13:35:20.003]   - Field: ‘envir’
[13:35:20.003]   - Field: ‘packages’
[13:35:20.003]   - Field: ‘gc’
[13:35:20.003]   - Field: ‘conditions’
[13:35:20.003]   - Field: ‘expr’
[13:35:20.003]   - Field: ‘uuid’
[13:35:20.003]   - Field: ‘seed’
[13:35:20.004]   - Field: ‘version’
[13:35:20.004]   - Field: ‘result’
[13:35:20.004]   - Field: ‘asynchronous’
[13:35:20.004]   - Field: ‘calls’
[13:35:20.004]   - Field: ‘globals’
[13:35:20.004]   - Field: ‘stdout’
[13:35:20.004]   - Field: ‘earlySignal’
[13:35:20.004]   - Field: ‘lazy’
[13:35:20.004]   - Field: ‘state’
[13:35:20.004] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:20.004] - Launch lazy future ...
[13:35:20.005] Packages needed by the future expression (n = 0): <none>
[13:35:20.005] Packages needed by future strategies (n = 0): <none>
[13:35:20.006] {
[13:35:20.006]     {
[13:35:20.006]         {
[13:35:20.006]             ...future.startTime <- base::Sys.time()
[13:35:20.006]             {
[13:35:20.006]                 {
[13:35:20.006]                   {
[13:35:20.006]                     base::local({
[13:35:20.006]                       has_future <- base::requireNamespace("future", 
[13:35:20.006]                         quietly = TRUE)
[13:35:20.006]                       if (has_future) {
[13:35:20.006]                         ns <- base::getNamespace("future")
[13:35:20.006]                         version <- ns[[".package"]][["version"]]
[13:35:20.006]                         if (is.null(version)) 
[13:35:20.006]                           version <- utils::packageVersion("future")
[13:35:20.006]                       }
[13:35:20.006]                       else {
[13:35:20.006]                         version <- NULL
[13:35:20.006]                       }
[13:35:20.006]                       if (!has_future || version < "1.8.0") {
[13:35:20.006]                         info <- base::c(r_version = base::gsub("R version ", 
[13:35:20.006]                           "", base::R.version$version.string), 
[13:35:20.006]                           platform = base::sprintf("%s (%s-bit)", 
[13:35:20.006]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:20.006]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:20.006]                             "release", "version")], collapse = " "), 
[13:35:20.006]                           hostname = base::Sys.info()[["nodename"]])
[13:35:20.006]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:35:20.006]                           info)
[13:35:20.006]                         info <- base::paste(info, collapse = "; ")
[13:35:20.006]                         if (!has_future) {
[13:35:20.006]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:20.006]                             info)
[13:35:20.006]                         }
[13:35:20.006]                         else {
[13:35:20.006]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:20.006]                             info, version)
[13:35:20.006]                         }
[13:35:20.006]                         base::stop(msg)
[13:35:20.006]                       }
[13:35:20.006]                     })
[13:35:20.006]                   }
[13:35:20.006]                   ...future.strategy.old <- future::plan("list")
[13:35:20.006]                   options(future.plan = NULL)
[13:35:20.006]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:20.006]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:20.006]                 }
[13:35:20.006]                 ...future.workdir <- getwd()
[13:35:20.006]             }
[13:35:20.006]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:20.006]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:20.006]         }
[13:35:20.006]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:20.006]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:20.006]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:20.006]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:20.006]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:20.006]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:20.006]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:20.006]             base::names(...future.oldOptions))
[13:35:20.006]     }
[13:35:20.006]     if (FALSE) {
[13:35:20.006]     }
[13:35:20.006]     else {
[13:35:20.006]         if (FALSE) {
[13:35:20.006]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:20.006]                 open = "w")
[13:35:20.006]         }
[13:35:20.006]         else {
[13:35:20.006]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:20.006]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:20.006]         }
[13:35:20.006]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:20.006]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:20.006]             base::sink(type = "output", split = FALSE)
[13:35:20.006]             base::close(...future.stdout)
[13:35:20.006]         }, add = TRUE)
[13:35:20.006]     }
[13:35:20.006]     ...future.frame <- base::sys.nframe()
[13:35:20.006]     ...future.conditions <- base::list()
[13:35:20.006]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:20.006]     if (FALSE) {
[13:35:20.006]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:20.006]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:20.006]     }
[13:35:20.006]     ...future.result <- base::tryCatch({
[13:35:20.006]         base::withCallingHandlers({
[13:35:20.006]             ...future.value <- base::withVisible(base::local({
[13:35:20.006]                 do.call(function(...) {
[13:35:20.006]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:20.006]                   if (!identical(...future.globals.maxSize.org, 
[13:35:20.006]                     ...future.globals.maxSize)) {
[13:35:20.006]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:20.006]                     on.exit(options(oopts), add = TRUE)
[13:35:20.006]                   }
[13:35:20.006]                   {
[13:35:20.006]                     lapply(seq_along(...future.elements_ii), 
[13:35:20.006]                       FUN = function(jj) {
[13:35:20.006]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:20.006]                         ...future.FUN(...future.X_jj, ...)
[13:35:20.006]                       })
[13:35:20.006]                   }
[13:35:20.006]                 }, args = future.call.arguments)
[13:35:20.006]             }))
[13:35:20.006]             future::FutureResult(value = ...future.value$value, 
[13:35:20.006]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:20.006]                   ...future.rng), globalenv = if (FALSE) 
[13:35:20.006]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:20.006]                     ...future.globalenv.names))
[13:35:20.006]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:20.006]         }, condition = base::local({
[13:35:20.006]             c <- base::c
[13:35:20.006]             inherits <- base::inherits
[13:35:20.006]             invokeRestart <- base::invokeRestart
[13:35:20.006]             length <- base::length
[13:35:20.006]             list <- base::list
[13:35:20.006]             seq.int <- base::seq.int
[13:35:20.006]             signalCondition <- base::signalCondition
[13:35:20.006]             sys.calls <- base::sys.calls
[13:35:20.006]             `[[` <- base::`[[`
[13:35:20.006]             `+` <- base::`+`
[13:35:20.006]             `<<-` <- base::`<<-`
[13:35:20.006]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:20.006]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:20.006]                   3L)]
[13:35:20.006]             }
[13:35:20.006]             function(cond) {
[13:35:20.006]                 is_error <- inherits(cond, "error")
[13:35:20.006]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:20.006]                   NULL)
[13:35:20.006]                 if (is_error) {
[13:35:20.006]                   sessionInformation <- function() {
[13:35:20.006]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:20.006]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:20.006]                       search = base::search(), system = base::Sys.info())
[13:35:20.006]                   }
[13:35:20.006]                   ...future.conditions[[length(...future.conditions) + 
[13:35:20.006]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:20.006]                     cond$call), session = sessionInformation(), 
[13:35:20.006]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:20.006]                   signalCondition(cond)
[13:35:20.006]                 }
[13:35:20.006]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:20.006]                 "immediateCondition"))) {
[13:35:20.006]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:20.006]                   ...future.conditions[[length(...future.conditions) + 
[13:35:20.006]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:20.006]                   if (TRUE && !signal) {
[13:35:20.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:20.006]                     {
[13:35:20.006]                       inherits <- base::inherits
[13:35:20.006]                       invokeRestart <- base::invokeRestart
[13:35:20.006]                       is.null <- base::is.null
[13:35:20.006]                       muffled <- FALSE
[13:35:20.006]                       if (inherits(cond, "message")) {
[13:35:20.006]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:20.006]                         if (muffled) 
[13:35:20.006]                           invokeRestart("muffleMessage")
[13:35:20.006]                       }
[13:35:20.006]                       else if (inherits(cond, "warning")) {
[13:35:20.006]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:20.006]                         if (muffled) 
[13:35:20.006]                           invokeRestart("muffleWarning")
[13:35:20.006]                       }
[13:35:20.006]                       else if (inherits(cond, "condition")) {
[13:35:20.006]                         if (!is.null(pattern)) {
[13:35:20.006]                           computeRestarts <- base::computeRestarts
[13:35:20.006]                           grepl <- base::grepl
[13:35:20.006]                           restarts <- computeRestarts(cond)
[13:35:20.006]                           for (restart in restarts) {
[13:35:20.006]                             name <- restart$name
[13:35:20.006]                             if (is.null(name)) 
[13:35:20.006]                               next
[13:35:20.006]                             if (!grepl(pattern, name)) 
[13:35:20.006]                               next
[13:35:20.006]                             invokeRestart(restart)
[13:35:20.006]                             muffled <- TRUE
[13:35:20.006]                             break
[13:35:20.006]                           }
[13:35:20.006]                         }
[13:35:20.006]                       }
[13:35:20.006]                       invisible(muffled)
[13:35:20.006]                     }
[13:35:20.006]                     muffleCondition(cond, pattern = "^muffle")
[13:35:20.006]                   }
[13:35:20.006]                 }
[13:35:20.006]                 else {
[13:35:20.006]                   if (TRUE) {
[13:35:20.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:20.006]                     {
[13:35:20.006]                       inherits <- base::inherits
[13:35:20.006]                       invokeRestart <- base::invokeRestart
[13:35:20.006]                       is.null <- base::is.null
[13:35:20.006]                       muffled <- FALSE
[13:35:20.006]                       if (inherits(cond, "message")) {
[13:35:20.006]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:20.006]                         if (muffled) 
[13:35:20.006]                           invokeRestart("muffleMessage")
[13:35:20.006]                       }
[13:35:20.006]                       else if (inherits(cond, "warning")) {
[13:35:20.006]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:20.006]                         if (muffled) 
[13:35:20.006]                           invokeRestart("muffleWarning")
[13:35:20.006]                       }
[13:35:20.006]                       else if (inherits(cond, "condition")) {
[13:35:20.006]                         if (!is.null(pattern)) {
[13:35:20.006]                           computeRestarts <- base::computeRestarts
[13:35:20.006]                           grepl <- base::grepl
[13:35:20.006]                           restarts <- computeRestarts(cond)
[13:35:20.006]                           for (restart in restarts) {
[13:35:20.006]                             name <- restart$name
[13:35:20.006]                             if (is.null(name)) 
[13:35:20.006]                               next
[13:35:20.006]                             if (!grepl(pattern, name)) 
[13:35:20.006]                               next
[13:35:20.006]                             invokeRestart(restart)
[13:35:20.006]                             muffled <- TRUE
[13:35:20.006]                             break
[13:35:20.006]                           }
[13:35:20.006]                         }
[13:35:20.006]                       }
[13:35:20.006]                       invisible(muffled)
[13:35:20.006]                     }
[13:35:20.006]                     muffleCondition(cond, pattern = "^muffle")
[13:35:20.006]                   }
[13:35:20.006]                 }
[13:35:20.006]             }
[13:35:20.006]         }))
[13:35:20.006]     }, error = function(ex) {
[13:35:20.006]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:20.006]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:20.006]                 ...future.rng), started = ...future.startTime, 
[13:35:20.006]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:20.006]             version = "1.8"), class = "FutureResult")
[13:35:20.006]     }, finally = {
[13:35:20.006]         if (!identical(...future.workdir, getwd())) 
[13:35:20.006]             setwd(...future.workdir)
[13:35:20.006]         {
[13:35:20.006]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:20.006]                 ...future.oldOptions$nwarnings <- NULL
[13:35:20.006]             }
[13:35:20.006]             base::options(...future.oldOptions)
[13:35:20.006]             if (.Platform$OS.type == "windows") {
[13:35:20.006]                 old_names <- names(...future.oldEnvVars)
[13:35:20.006]                 envs <- base::Sys.getenv()
[13:35:20.006]                 names <- names(envs)
[13:35:20.006]                 common <- intersect(names, old_names)
[13:35:20.006]                 added <- setdiff(names, old_names)
[13:35:20.006]                 removed <- setdiff(old_names, names)
[13:35:20.006]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:20.006]                   envs[common]]
[13:35:20.006]                 NAMES <- toupper(changed)
[13:35:20.006]                 args <- list()
[13:35:20.006]                 for (kk in seq_along(NAMES)) {
[13:35:20.006]                   name <- changed[[kk]]
[13:35:20.006]                   NAME <- NAMES[[kk]]
[13:35:20.006]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:20.006]                     next
[13:35:20.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:20.006]                 }
[13:35:20.006]                 NAMES <- toupper(added)
[13:35:20.006]                 for (kk in seq_along(NAMES)) {
[13:35:20.006]                   name <- added[[kk]]
[13:35:20.006]                   NAME <- NAMES[[kk]]
[13:35:20.006]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:20.006]                     next
[13:35:20.006]                   args[[name]] <- ""
[13:35:20.006]                 }
[13:35:20.006]                 NAMES <- toupper(removed)
[13:35:20.006]                 for (kk in seq_along(NAMES)) {
[13:35:20.006]                   name <- removed[[kk]]
[13:35:20.006]                   NAME <- NAMES[[kk]]
[13:35:20.006]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:20.006]                     next
[13:35:20.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:20.006]                 }
[13:35:20.006]                 if (length(args) > 0) 
[13:35:20.006]                   base::do.call(base::Sys.setenv, args = args)
[13:35:20.006]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:20.006]             }
[13:35:20.006]             else {
[13:35:20.006]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:20.006]             }
[13:35:20.006]             {
[13:35:20.006]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:20.006]                   0L) {
[13:35:20.006]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:20.006]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:20.006]                   base::options(opts)
[13:35:20.006]                 }
[13:35:20.006]                 {
[13:35:20.006]                   {
[13:35:20.006]                     NULL
[13:35:20.006]                     RNGkind("Mersenne-Twister")
[13:35:20.006]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:20.006]                       inherits = FALSE)
[13:35:20.006]                   }
[13:35:20.006]                   options(future.plan = NULL)
[13:35:20.006]                   if (is.na(NA_character_)) 
[13:35:20.006]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:20.006]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:20.006]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:20.006]                     .init = FALSE)
[13:35:20.006]                 }
[13:35:20.006]             }
[13:35:20.006]         }
[13:35:20.006]     })
[13:35:20.006]     if (TRUE) {
[13:35:20.006]         base::sink(type = "output", split = FALSE)
[13:35:20.006]         if (FALSE) {
[13:35:20.006]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:20.006]         }
[13:35:20.006]         else {
[13:35:20.006]             ...future.result["stdout"] <- base::list(NULL)
[13:35:20.006]         }
[13:35:20.006]         base::close(...future.stdout)
[13:35:20.006]         ...future.stdout <- NULL
[13:35:20.006]     }
[13:35:20.006]     ...future.result$conditions <- ...future.conditions
[13:35:20.006]     ...future.result$finished <- base::Sys.time()
[13:35:20.006]     ...future.result
[13:35:20.006] }
[13:35:20.008] assign_globals() ...
[13:35:20.008] List of 5
[13:35:20.008]  $ ...future.FUN            :function (x)  
[13:35:20.008]  $ future.call.arguments    : list()
[13:35:20.008]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:20.008]  $ ...future.elements_ii    :List of 2
[13:35:20.008]   ..$ : int 1
[13:35:20.008]   ..$ : int 0
[13:35:20.008]  $ ...future.seeds_ii       : NULL
[13:35:20.008]  $ ...future.globals.maxSize: NULL
[13:35:20.008]  - attr(*, "where")=List of 5
[13:35:20.008]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:20.008]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:20.008]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:20.008]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:20.008]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:20.008]  - attr(*, "resolved")= logi FALSE
[13:35:20.008]  - attr(*, "total_size")= num 4720
[13:35:20.008]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:20.008]  - attr(*, "already-done")= logi TRUE
[13:35:20.013] - reassign environment for ‘...future.FUN’
[13:35:20.013] - copied ‘...future.FUN’ to environment
[13:35:20.013] - copied ‘future.call.arguments’ to environment
[13:35:20.013] - copied ‘...future.elements_ii’ to environment
[13:35:20.013] - copied ‘...future.seeds_ii’ to environment
[13:35:20.013] - copied ‘...future.globals.maxSize’ to environment
[13:35:20.013] assign_globals() ... done
[13:35:20.014] plan(): Setting new future strategy stack:
[13:35:20.014] List of future strategies:
[13:35:20.014] 1. sequential:
[13:35:20.014]    - args: function (..., envir = parent.frame())
[13:35:20.014]    - tweaked: FALSE
[13:35:20.014]    - call: NULL
[13:35:20.014] plan(): nbrOfWorkers() = 1
[13:35:20.516] plan(): Setting new future strategy stack:
[13:35:20.516] List of future strategies:
[13:35:20.516] 1. sequential:
[13:35:20.516]    - args: function (..., envir = parent.frame())
[13:35:20.516]    - tweaked: FALSE
[13:35:20.516]    - call: plan(strategy)
[13:35:20.517] plan(): nbrOfWorkers() = 1
[13:35:20.517] SequentialFuture started (and completed)
[13:35:20.517] - Launch lazy future ... done
[13:35:20.518] run() for ‘SequentialFuture’ ... done
[13:35:20.518] Created future:
[13:35:20.518] SequentialFuture:
[13:35:20.518] Label: ‘future_lapply-1’
[13:35:20.518] Expression:
[13:35:20.518] {
[13:35:20.518]     do.call(function(...) {
[13:35:20.518]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:20.518]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:20.518]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:20.518]             on.exit(options(oopts), add = TRUE)
[13:35:20.518]         }
[13:35:20.518]         {
[13:35:20.518]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:20.518]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:20.518]                 ...future.FUN(...future.X_jj, ...)
[13:35:20.518]             })
[13:35:20.518]         }
[13:35:20.518]     }, args = future.call.arguments)
[13:35:20.518] }
[13:35:20.518] Lazy evaluation: FALSE
[13:35:20.518] Asynchronous evaluation: FALSE
[13:35:20.518] Local evaluation: TRUE
[13:35:20.518] Environment: R_GlobalEnv
[13:35:20.518] Capture standard output: FALSE
[13:35:20.518] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:20.518] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:20.518] Packages: <none>
[13:35:20.518] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:20.518] Resolved: TRUE
[13:35:20.518] Value: 112 bytes of class ‘list’
[13:35:20.518] Early signaling: FALSE
[13:35:20.518] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:20.518] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:20.519] Chunk #1 of 1 ... DONE
[13:35:20.519] Launching 1 futures (chunks) ... DONE
[13:35:20.520] Resolving 1 futures (chunks) ...
[13:35:20.520] resolve() on list ...
[13:35:20.520]  recursive: 0
[13:35:20.520]  length: 1
[13:35:20.520] 
[13:35:20.520] resolved() for ‘SequentialFuture’ ...
[13:35:20.520] - state: ‘finished’
[13:35:20.520] - run: TRUE
[13:35:20.520] - result: ‘FutureResult’
[13:35:20.521] resolved() for ‘SequentialFuture’ ... done
[13:35:20.521] Future #1
[13:35:20.521] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:20.521] - nx: 1
[13:35:20.521] - relay: TRUE
[13:35:20.521] - stdout: TRUE
[13:35:20.521] - signal: TRUE
[13:35:20.521] - resignal: FALSE
[13:35:20.522] - force: TRUE
[13:35:20.522] - relayed: [n=1] FALSE
[13:35:20.522] - queued futures: [n=1] FALSE
[13:35:20.522]  - until=1
[13:35:20.522]  - relaying element #1
[13:35:20.522] - relayed: [n=1] TRUE
[13:35:20.522] - queued futures: [n=1] TRUE
[13:35:20.522] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:20.523]  length: 0 (resolved future 1)
[13:35:20.525] Relaying remaining futures
[13:35:20.525] signalConditionsASAP(NULL, pos=0) ...
[13:35:20.525] - nx: 1
[13:35:20.525] - relay: TRUE
[13:35:20.525] - stdout: TRUE
[13:35:20.525] - signal: TRUE
[13:35:20.525] - resignal: FALSE
[13:35:20.525] - force: TRUE
[13:35:20.525] - relayed: [n=1] TRUE
[13:35:20.525] - queued futures: [n=1] TRUE
 - flush all
[13:35:20.525] - relayed: [n=1] TRUE
[13:35:20.526] - queued futures: [n=1] TRUE
[13:35:20.526] signalConditionsASAP(NULL, pos=0) ... done
[13:35:20.526] resolve() on list ... DONE
[13:35:20.526]  - Number of value chunks collected: 1
[13:35:20.526] Resolving 1 futures (chunks) ... DONE
[13:35:20.526] Reducing values from 1 chunks ...
[13:35:20.526]  - Number of values collected after concatenation: 2
[13:35:20.526]  - Number of values expected: 2
[13:35:20.526] Reducing values from 1 chunks ... DONE
[13:35:20.527] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[13:35:20.527] future_lapply() ...
[13:35:20.528] Number of chunks: 1
[13:35:20.528] getGlobalsAndPackagesXApply() ...
[13:35:20.528]  - future.globals: TRUE
[13:35:20.528] getGlobalsAndPackages() ...
[13:35:20.528] Searching for globals...
[13:35:20.529] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:35:20.529] Searching for globals ... DONE
[13:35:20.529] Resolving globals: FALSE
[13:35:20.530] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:35:20.530] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:35:20.530] - globals: [1] ‘FUN’
[13:35:20.530] 
[13:35:20.531] getGlobalsAndPackages() ... DONE
[13:35:20.531]  - globals found/used: [n=1] ‘FUN’
[13:35:20.531]  - needed namespaces: [n=0] 
[13:35:20.531] Finding globals ... DONE
[13:35:20.531]  - use_args: TRUE
[13:35:20.531]  - Getting '...' globals ...
[13:35:20.531] resolve() on list ...
[13:35:20.531]  recursive: 0
[13:35:20.531]  length: 1
[13:35:20.532]  elements: ‘...’
[13:35:20.532]  length: 0 (resolved future 1)
[13:35:20.532] resolve() on list ... DONE
[13:35:20.532]    - '...' content: [n=0] 
[13:35:20.532] List of 1
[13:35:20.532]  $ ...: list()
[13:35:20.532]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:20.532]  - attr(*, "where")=List of 1
[13:35:20.532]   ..$ ...:<environment: 0x558d371314f0> 
[13:35:20.532]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:20.532]  - attr(*, "resolved")= logi TRUE
[13:35:20.532]  - attr(*, "total_size")= num NA
[13:35:20.534]  - Getting '...' globals ... DONE
[13:35:20.535] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:35:20.535] List of 2
[13:35:20.535]  $ ...future.FUN:function (x)  
[13:35:20.535]  $ ...          : list()
[13:35:20.535]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:20.535]  - attr(*, "where")=List of 2
[13:35:20.535]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:20.535]   ..$ ...          :<environment: 0x558d371314f0> 
[13:35:20.535]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:20.535]  - attr(*, "resolved")= logi FALSE
[13:35:20.535]  - attr(*, "total_size")= num 4720
[13:35:20.537] Packages to be attached in all futures: [n=0] 
[13:35:20.537] getGlobalsAndPackagesXApply() ... DONE
[13:35:20.538] Number of futures (= number of chunks): 1
[13:35:20.538] Launching 1 futures (chunks) ...
[13:35:20.538] Chunk #1 of 1 ...
[13:35:20.538]  - Finding globals in 'X' for chunk #1 ...
[13:35:20.538] getGlobalsAndPackages() ...
[13:35:20.538] Searching for globals...
[13:35:20.538] 
[13:35:20.538] Searching for globals ... DONE
[13:35:20.539] - globals: [0] <none>
[13:35:20.539] getGlobalsAndPackages() ... DONE
[13:35:20.539]    + additional globals found: [n=0] 
[13:35:20.539]    + additional namespaces needed: [n=0] 
[13:35:20.539]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:20.539]  - seeds: <none>
[13:35:20.539]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:20.539] getGlobalsAndPackages() ...
[13:35:20.539] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:20.539] Resolving globals: FALSE
[13:35:20.539] Tweak future expression to call with '...' arguments ...
[13:35:20.540] {
[13:35:20.540]     do.call(function(...) {
[13:35:20.540]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:20.540]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:20.540]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:20.540]             on.exit(options(oopts), add = TRUE)
[13:35:20.540]         }
[13:35:20.540]         {
[13:35:20.540]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:20.540]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:20.540]                 ...future.FUN(...future.X_jj, ...)
[13:35:20.540]             })
[13:35:20.540]         }
[13:35:20.540]     }, args = future.call.arguments)
[13:35:20.540] }
[13:35:20.540] Tweak future expression to call with '...' arguments ... DONE
[13:35:20.540] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:20.540] 
[13:35:20.540] getGlobalsAndPackages() ... DONE
[13:35:20.541] run() for ‘Future’ ...
[13:35:20.541] - state: ‘created’
[13:35:20.541] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:35:20.541] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:20.541] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:20.541]   - Field: ‘label’
[13:35:20.541]   - Field: ‘local’
[13:35:20.542]   - Field: ‘owner’
[13:35:20.542]   - Field: ‘envir’
[13:35:20.542]   - Field: ‘packages’
[13:35:20.542]   - Field: ‘gc’
[13:35:20.542]   - Field: ‘conditions’
[13:35:20.542]   - Field: ‘expr’
[13:35:20.542]   - Field: ‘uuid’
[13:35:20.542]   - Field: ‘seed’
[13:35:20.542]   - Field: ‘version’
[13:35:20.542]   - Field: ‘result’
[13:35:20.542]   - Field: ‘asynchronous’
[13:35:20.543]   - Field: ‘calls’
[13:35:20.543]   - Field: ‘globals’
[13:35:20.543]   - Field: ‘stdout’
[13:35:20.543]   - Field: ‘earlySignal’
[13:35:20.543]   - Field: ‘lazy’
[13:35:20.543]   - Field: ‘state’
[13:35:20.543] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:20.543] - Launch lazy future ...
[13:35:20.543] Packages needed by the future expression (n = 0): <none>
[13:35:20.543] Packages needed by future strategies (n = 0): <none>
[13:35:20.544] {
[13:35:20.544]     {
[13:35:20.544]         {
[13:35:20.544]             ...future.startTime <- base::Sys.time()
[13:35:20.544]             {
[13:35:20.544]                 {
[13:35:20.544]                   {
[13:35:20.544]                     base::local({
[13:35:20.544]                       has_future <- base::requireNamespace("future", 
[13:35:20.544]                         quietly = TRUE)
[13:35:20.544]                       if (has_future) {
[13:35:20.544]                         ns <- base::getNamespace("future")
[13:35:20.544]                         version <- ns[[".package"]][["version"]]
[13:35:20.544]                         if (is.null(version)) 
[13:35:20.544]                           version <- utils::packageVersion("future")
[13:35:20.544]                       }
[13:35:20.544]                       else {
[13:35:20.544]                         version <- NULL
[13:35:20.544]                       }
[13:35:20.544]                       if (!has_future || version < "1.8.0") {
[13:35:20.544]                         info <- base::c(r_version = base::gsub("R version ", 
[13:35:20.544]                           "", base::R.version$version.string), 
[13:35:20.544]                           platform = base::sprintf("%s (%s-bit)", 
[13:35:20.544]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:20.544]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:20.544]                             "release", "version")], collapse = " "), 
[13:35:20.544]                           hostname = base::Sys.info()[["nodename"]])
[13:35:20.544]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:35:20.544]                           info)
[13:35:20.544]                         info <- base::paste(info, collapse = "; ")
[13:35:20.544]                         if (!has_future) {
[13:35:20.544]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:20.544]                             info)
[13:35:20.544]                         }
[13:35:20.544]                         else {
[13:35:20.544]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:20.544]                             info, version)
[13:35:20.544]                         }
[13:35:20.544]                         base::stop(msg)
[13:35:20.544]                       }
[13:35:20.544]                     })
[13:35:20.544]                   }
[13:35:20.544]                   ...future.strategy.old <- future::plan("list")
[13:35:20.544]                   options(future.plan = NULL)
[13:35:20.544]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:20.544]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:20.544]                 }
[13:35:20.544]                 ...future.workdir <- getwd()
[13:35:20.544]             }
[13:35:20.544]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:20.544]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:20.544]         }
[13:35:20.544]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:20.544]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:20.544]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:20.544]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:20.544]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:20.544]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:20.544]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:20.544]             base::names(...future.oldOptions))
[13:35:20.544]     }
[13:35:20.544]     if (FALSE) {
[13:35:20.544]     }
[13:35:20.544]     else {
[13:35:20.544]         if (TRUE) {
[13:35:20.544]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:20.544]                 open = "w")
[13:35:20.544]         }
[13:35:20.544]         else {
[13:35:20.544]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:20.544]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:20.544]         }
[13:35:20.544]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:20.544]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:20.544]             base::sink(type = "output", split = FALSE)
[13:35:20.544]             base::close(...future.stdout)
[13:35:20.544]         }, add = TRUE)
[13:35:20.544]     }
[13:35:20.544]     ...future.frame <- base::sys.nframe()
[13:35:20.544]     ...future.conditions <- base::list()
[13:35:20.544]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:20.544]     if (FALSE) {
[13:35:20.544]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:20.544]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:20.544]     }
[13:35:20.544]     ...future.result <- base::tryCatch({
[13:35:20.544]         base::withCallingHandlers({
[13:35:20.544]             ...future.value <- base::withVisible(base::local({
[13:35:20.544]                 do.call(function(...) {
[13:35:20.544]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:20.544]                   if (!identical(...future.globals.maxSize.org, 
[13:35:20.544]                     ...future.globals.maxSize)) {
[13:35:20.544]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:20.544]                     on.exit(options(oopts), add = TRUE)
[13:35:20.544]                   }
[13:35:20.544]                   {
[13:35:20.544]                     lapply(seq_along(...future.elements_ii), 
[13:35:20.544]                       FUN = function(jj) {
[13:35:20.544]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:20.544]                         ...future.FUN(...future.X_jj, ...)
[13:35:20.544]                       })
[13:35:20.544]                   }
[13:35:20.544]                 }, args = future.call.arguments)
[13:35:20.544]             }))
[13:35:20.544]             future::FutureResult(value = ...future.value$value, 
[13:35:20.544]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:20.544]                   ...future.rng), globalenv = if (FALSE) 
[13:35:20.544]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:20.544]                     ...future.globalenv.names))
[13:35:20.544]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:20.544]         }, condition = base::local({
[13:35:20.544]             c <- base::c
[13:35:20.544]             inherits <- base::inherits
[13:35:20.544]             invokeRestart <- base::invokeRestart
[13:35:20.544]             length <- base::length
[13:35:20.544]             list <- base::list
[13:35:20.544]             seq.int <- base::seq.int
[13:35:20.544]             signalCondition <- base::signalCondition
[13:35:20.544]             sys.calls <- base::sys.calls
[13:35:20.544]             `[[` <- base::`[[`
[13:35:20.544]             `+` <- base::`+`
[13:35:20.544]             `<<-` <- base::`<<-`
[13:35:20.544]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:20.544]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:20.544]                   3L)]
[13:35:20.544]             }
[13:35:20.544]             function(cond) {
[13:35:20.544]                 is_error <- inherits(cond, "error")
[13:35:20.544]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:20.544]                   NULL)
[13:35:20.544]                 if (is_error) {
[13:35:20.544]                   sessionInformation <- function() {
[13:35:20.544]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:20.544]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:20.544]                       search = base::search(), system = base::Sys.info())
[13:35:20.544]                   }
[13:35:20.544]                   ...future.conditions[[length(...future.conditions) + 
[13:35:20.544]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:20.544]                     cond$call), session = sessionInformation(), 
[13:35:20.544]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:20.544]                   signalCondition(cond)
[13:35:20.544]                 }
[13:35:20.544]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:20.544]                 "immediateCondition"))) {
[13:35:20.544]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:20.544]                   ...future.conditions[[length(...future.conditions) + 
[13:35:20.544]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:20.544]                   if (TRUE && !signal) {
[13:35:20.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:20.544]                     {
[13:35:20.544]                       inherits <- base::inherits
[13:35:20.544]                       invokeRestart <- base::invokeRestart
[13:35:20.544]                       is.null <- base::is.null
[13:35:20.544]                       muffled <- FALSE
[13:35:20.544]                       if (inherits(cond, "message")) {
[13:35:20.544]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:20.544]                         if (muffled) 
[13:35:20.544]                           invokeRestart("muffleMessage")
[13:35:20.544]                       }
[13:35:20.544]                       else if (inherits(cond, "warning")) {
[13:35:20.544]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:20.544]                         if (muffled) 
[13:35:20.544]                           invokeRestart("muffleWarning")
[13:35:20.544]                       }
[13:35:20.544]                       else if (inherits(cond, "condition")) {
[13:35:20.544]                         if (!is.null(pattern)) {
[13:35:20.544]                           computeRestarts <- base::computeRestarts
[13:35:20.544]                           grepl <- base::grepl
[13:35:20.544]                           restarts <- computeRestarts(cond)
[13:35:20.544]                           for (restart in restarts) {
[13:35:20.544]                             name <- restart$name
[13:35:20.544]                             if (is.null(name)) 
[13:35:20.544]                               next
[13:35:20.544]                             if (!grepl(pattern, name)) 
[13:35:20.544]                               next
[13:35:20.544]                             invokeRestart(restart)
[13:35:20.544]                             muffled <- TRUE
[13:35:20.544]                             break
[13:35:20.544]                           }
[13:35:20.544]                         }
[13:35:20.544]                       }
[13:35:20.544]                       invisible(muffled)
[13:35:20.544]                     }
[13:35:20.544]                     muffleCondition(cond, pattern = "^muffle")
[13:35:20.544]                   }
[13:35:20.544]                 }
[13:35:20.544]                 else {
[13:35:20.544]                   if (TRUE) {
[13:35:20.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:20.544]                     {
[13:35:20.544]                       inherits <- base::inherits
[13:35:20.544]                       invokeRestart <- base::invokeRestart
[13:35:20.544]                       is.null <- base::is.null
[13:35:20.544]                       muffled <- FALSE
[13:35:20.544]                       if (inherits(cond, "message")) {
[13:35:20.544]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:20.544]                         if (muffled) 
[13:35:20.544]                           invokeRestart("muffleMessage")
[13:35:20.544]                       }
[13:35:20.544]                       else if (inherits(cond, "warning")) {
[13:35:20.544]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:20.544]                         if (muffled) 
[13:35:20.544]                           invokeRestart("muffleWarning")
[13:35:20.544]                       }
[13:35:20.544]                       else if (inherits(cond, "condition")) {
[13:35:20.544]                         if (!is.null(pattern)) {
[13:35:20.544]                           computeRestarts <- base::computeRestarts
[13:35:20.544]                           grepl <- base::grepl
[13:35:20.544]                           restarts <- computeRestarts(cond)
[13:35:20.544]                           for (restart in restarts) {
[13:35:20.544]                             name <- restart$name
[13:35:20.544]                             if (is.null(name)) 
[13:35:20.544]                               next
[13:35:20.544]                             if (!grepl(pattern, name)) 
[13:35:20.544]                               next
[13:35:20.544]                             invokeRestart(restart)
[13:35:20.544]                             muffled <- TRUE
[13:35:20.544]                             break
[13:35:20.544]                           }
[13:35:20.544]                         }
[13:35:20.544]                       }
[13:35:20.544]                       invisible(muffled)
[13:35:20.544]                     }
[13:35:20.544]                     muffleCondition(cond, pattern = "^muffle")
[13:35:20.544]                   }
[13:35:20.544]                 }
[13:35:20.544]             }
[13:35:20.544]         }))
[13:35:20.544]     }, error = function(ex) {
[13:35:20.544]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:20.544]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:20.544]                 ...future.rng), started = ...future.startTime, 
[13:35:20.544]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:20.544]             version = "1.8"), class = "FutureResult")
[13:35:20.544]     }, finally = {
[13:35:20.544]         if (!identical(...future.workdir, getwd())) 
[13:35:20.544]             setwd(...future.workdir)
[13:35:20.544]         {
[13:35:20.544]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:20.544]                 ...future.oldOptions$nwarnings <- NULL
[13:35:20.544]             }
[13:35:20.544]             base::options(...future.oldOptions)
[13:35:20.544]             if (.Platform$OS.type == "windows") {
[13:35:20.544]                 old_names <- names(...future.oldEnvVars)
[13:35:20.544]                 envs <- base::Sys.getenv()
[13:35:20.544]                 names <- names(envs)
[13:35:20.544]                 common <- intersect(names, old_names)
[13:35:20.544]                 added <- setdiff(names, old_names)
[13:35:20.544]                 removed <- setdiff(old_names, names)
[13:35:20.544]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:20.544]                   envs[common]]
[13:35:20.544]                 NAMES <- toupper(changed)
[13:35:20.544]                 args <- list()
[13:35:20.544]                 for (kk in seq_along(NAMES)) {
[13:35:20.544]                   name <- changed[[kk]]
[13:35:20.544]                   NAME <- NAMES[[kk]]
[13:35:20.544]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:20.544]                     next
[13:35:20.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:20.544]                 }
[13:35:20.544]                 NAMES <- toupper(added)
[13:35:20.544]                 for (kk in seq_along(NAMES)) {
[13:35:20.544]                   name <- added[[kk]]
[13:35:20.544]                   NAME <- NAMES[[kk]]
[13:35:20.544]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:20.544]                     next
[13:35:20.544]                   args[[name]] <- ""
[13:35:20.544]                 }
[13:35:20.544]                 NAMES <- toupper(removed)
[13:35:20.544]                 for (kk in seq_along(NAMES)) {
[13:35:20.544]                   name <- removed[[kk]]
[13:35:20.544]                   NAME <- NAMES[[kk]]
[13:35:20.544]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:20.544]                     next
[13:35:20.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:20.544]                 }
[13:35:20.544]                 if (length(args) > 0) 
[13:35:20.544]                   base::do.call(base::Sys.setenv, args = args)
[13:35:20.544]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:20.544]             }
[13:35:20.544]             else {
[13:35:20.544]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:20.544]             }
[13:35:20.544]             {
[13:35:20.544]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:20.544]                   0L) {
[13:35:20.544]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:20.544]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:20.544]                   base::options(opts)
[13:35:20.544]                 }
[13:35:20.544]                 {
[13:35:20.544]                   {
[13:35:20.544]                     NULL
[13:35:20.544]                     RNGkind("Mersenne-Twister")
[13:35:20.544]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:20.544]                       inherits = FALSE)
[13:35:20.544]                   }
[13:35:20.544]                   options(future.plan = NULL)
[13:35:20.544]                   if (is.na(NA_character_)) 
[13:35:20.544]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:20.544]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:20.544]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:20.544]                     .init = FALSE)
[13:35:20.544]                 }
[13:35:20.544]             }
[13:35:20.544]         }
[13:35:20.544]     })
[13:35:20.544]     if (TRUE) {
[13:35:20.544]         base::sink(type = "output", split = FALSE)
[13:35:20.544]         if (TRUE) {
[13:35:20.544]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:20.544]         }
[13:35:20.544]         else {
[13:35:20.544]             ...future.result["stdout"] <- base::list(NULL)
[13:35:20.544]         }
[13:35:20.544]         base::close(...future.stdout)
[13:35:20.544]         ...future.stdout <- NULL
[13:35:20.544]     }
[13:35:20.544]     ...future.result$conditions <- ...future.conditions
[13:35:20.544]     ...future.result$finished <- base::Sys.time()
[13:35:20.544]     ...future.result
[13:35:20.544] }
[13:35:20.545] assign_globals() ...
[13:35:20.546] List of 5
[13:35:20.546]  $ ...future.FUN            :function (x)  
[13:35:20.546]  $ future.call.arguments    : list()
[13:35:20.546]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:20.546]  $ ...future.elements_ii    :List of 2
[13:35:20.546]   ..$ : int 1
[13:35:20.546]   ..$ : int 0
[13:35:20.546]  $ ...future.seeds_ii       : NULL
[13:35:20.546]  $ ...future.globals.maxSize: NULL
[13:35:20.546]  - attr(*, "where")=List of 5
[13:35:20.546]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:20.546]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:20.546]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:20.546]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:20.546]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:20.546]  - attr(*, "resolved")= logi FALSE
[13:35:20.546]  - attr(*, "total_size")= num 4720
[13:35:20.546]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:20.546]  - attr(*, "already-done")= logi TRUE
[13:35:20.551] - reassign environment for ‘...future.FUN’
[13:35:20.551] - copied ‘...future.FUN’ to environment
[13:35:20.551] - copied ‘future.call.arguments’ to environment
[13:35:20.551] - copied ‘...future.elements_ii’ to environment
[13:35:20.552] - copied ‘...future.seeds_ii’ to environment
[13:35:20.552] - copied ‘...future.globals.maxSize’ to environment
[13:35:20.552] assign_globals() ... done
[13:35:20.552] plan(): Setting new future strategy stack:
[13:35:20.552] List of future strategies:
[13:35:20.552] 1. sequential:
[13:35:20.552]    - args: function (..., envir = parent.frame())
[13:35:20.552]    - tweaked: FALSE
[13:35:20.552]    - call: NULL
[13:35:20.552] plan(): nbrOfWorkers() = 1
[13:35:21.054] plan(): Setting new future strategy stack:
[13:35:21.054] List of future strategies:
[13:35:21.054] 1. sequential:
[13:35:21.054]    - args: function (..., envir = parent.frame())
[13:35:21.054]    - tweaked: FALSE
[13:35:21.054]    - call: plan(strategy)
[13:35:21.055] plan(): nbrOfWorkers() = 1
[13:35:21.055] SequentialFuture started (and completed)
[13:35:21.055] - Launch lazy future ... done
[13:35:21.055] run() for ‘SequentialFuture’ ... done
[13:35:21.055] Created future:
[13:35:21.055] SequentialFuture:
[13:35:21.055] Label: ‘future_lapply-1’
[13:35:21.055] Expression:
[13:35:21.055] {
[13:35:21.055]     do.call(function(...) {
[13:35:21.055]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:21.055]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:21.055]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:21.055]             on.exit(options(oopts), add = TRUE)
[13:35:21.055]         }
[13:35:21.055]         {
[13:35:21.055]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:21.055]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:21.055]                 ...future.FUN(...future.X_jj, ...)
[13:35:21.055]             })
[13:35:21.055]         }
[13:35:21.055]     }, args = future.call.arguments)
[13:35:21.055] }
[13:35:21.055] Lazy evaluation: FALSE
[13:35:21.055] Asynchronous evaluation: FALSE
[13:35:21.055] Local evaluation: TRUE
[13:35:21.055] Environment: R_GlobalEnv
[13:35:21.055] Capture standard output: TRUE
[13:35:21.055] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:21.055] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:21.055] Packages: <none>
[13:35:21.055] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:21.055] Resolved: TRUE
[13:35:21.055] Value: 112 bytes of class ‘list’
[13:35:21.055] Early signaling: FALSE
[13:35:21.055] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:21.055] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:21.056] Chunk #1 of 1 ... DONE
[13:35:21.056] Launching 1 futures (chunks) ... DONE
[13:35:21.056] Resolving 1 futures (chunks) ...
[13:35:21.057] resolve() on list ...
[13:35:21.057]  recursive: 0
[13:35:21.057]  length: 1
[13:35:21.057] 
[13:35:21.057] resolved() for ‘SequentialFuture’ ...
[13:35:21.057] - state: ‘finished’
[13:35:21.057] - run: TRUE
[13:35:21.057] - result: ‘FutureResult’
[13:35:21.057] resolved() for ‘SequentialFuture’ ... done
[13:35:21.057] Future #1
[13:35:21.058] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:21.058] - nx: 1
[13:35:21.058] - relay: TRUE
[13:35:21.058] - stdout: TRUE
[13:35:21.058] - signal: TRUE
[13:35:21.058] - resignal: FALSE
[13:35:21.058] - force: TRUE
[13:35:21.058] - relayed: [n=1] FALSE
[13:35:21.058] - queued futures: [n=1] FALSE
[13:35:21.058]  - until=1
[13:35:21.058]  - relaying element #1
[13:35:21.059] - relayed: [n=1] TRUE
[13:35:21.059] - queued futures: [n=1] TRUE
[13:35:21.059] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:21.059]  length: 0 (resolved future 1)
[13:35:21.059] Relaying remaining futures
[13:35:21.059] signalConditionsASAP(NULL, pos=0) ...
[13:35:21.059] - nx: 1
[13:35:21.059] - relay: TRUE
[13:35:21.059] - stdout: TRUE
[13:35:21.059] - signal: TRUE
[13:35:21.059] - resignal: FALSE
[13:35:21.060] - force: TRUE
[13:35:21.060] - relayed: [n=1] TRUE
[13:35:21.060] - queued futures: [n=1] TRUE
 - flush all
[13:35:21.060] - relayed: [n=1] TRUE
[13:35:21.060] - queued futures: [n=1] TRUE
[13:35:21.060] signalConditionsASAP(NULL, pos=0) ... done
[13:35:21.060] resolve() on list ... DONE
[13:35:21.060]  - Number of value chunks collected: 1
[13:35:21.060] Resolving 1 futures (chunks) ... DONE
[13:35:21.060] Reducing values from 1 chunks ...
[13:35:21.061]  - Number of values collected after concatenation: 2
[13:35:21.061]  - Number of values expected: 2
[13:35:21.061] Reducing values from 1 chunks ... DONE
[13:35:21.061] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[13:35:21.061] future_lapply() ...
[13:35:21.062] Number of chunks: 1
[13:35:21.062] getGlobalsAndPackagesXApply() ...
[13:35:21.062]  - future.globals: TRUE
[13:35:21.062] getGlobalsAndPackages() ...
[13:35:21.062] Searching for globals...
[13:35:21.063] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:35:21.064] Searching for globals ... DONE
[13:35:21.064] Resolving globals: FALSE
[13:35:21.064] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:35:21.064] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:35:21.065] - globals: [1] ‘FUN’
[13:35:21.065] 
[13:35:21.065] getGlobalsAndPackages() ... DONE
[13:35:21.065]  - globals found/used: [n=1] ‘FUN’
[13:35:21.065]  - needed namespaces: [n=0] 
[13:35:21.065] Finding globals ... DONE
[13:35:21.065]  - use_args: TRUE
[13:35:21.065]  - Getting '...' globals ...
[13:35:21.065] resolve() on list ...
[13:35:21.066]  recursive: 0
[13:35:21.066]  length: 1
[13:35:21.066]  elements: ‘...’
[13:35:21.066]  length: 0 (resolved future 1)
[13:35:21.066] resolve() on list ... DONE
[13:35:21.066]    - '...' content: [n=0] 
[13:35:21.066] List of 1
[13:35:21.066]  $ ...: list()
[13:35:21.066]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:21.066]  - attr(*, "where")=List of 1
[13:35:21.066]   ..$ ...:<environment: 0x558d37eeff30> 
[13:35:21.066]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:21.066]  - attr(*, "resolved")= logi TRUE
[13:35:21.066]  - attr(*, "total_size")= num NA
[13:35:21.069]  - Getting '...' globals ... DONE
[13:35:21.069] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:35:21.069] List of 2
[13:35:21.069]  $ ...future.FUN:function (x)  
[13:35:21.069]  $ ...          : list()
[13:35:21.069]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:21.069]  - attr(*, "where")=List of 2
[13:35:21.069]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:21.069]   ..$ ...          :<environment: 0x558d37eeff30> 
[13:35:21.069]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:21.069]  - attr(*, "resolved")= logi FALSE
[13:35:21.069]  - attr(*, "total_size")= num 4720
[13:35:21.071] Packages to be attached in all futures: [n=0] 
[13:35:21.072] getGlobalsAndPackagesXApply() ... DONE
[13:35:21.072] Number of futures (= number of chunks): 1
[13:35:21.072] Launching 1 futures (chunks) ...
[13:35:21.072] Chunk #1 of 1 ...
[13:35:21.072]  - Finding globals in 'X' for chunk #1 ...
[13:35:21.074] getGlobalsAndPackages() ...
[13:35:21.074] Searching for globals...
[13:35:21.074] 
[13:35:21.074] Searching for globals ... DONE
[13:35:21.074] - globals: [0] <none>
[13:35:21.074] getGlobalsAndPackages() ... DONE
[13:35:21.075]    + additional globals found: [n=0] 
[13:35:21.075]    + additional namespaces needed: [n=0] 
[13:35:21.075]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:21.075]  - seeds: <none>
[13:35:21.075]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:21.075] getGlobalsAndPackages() ...
[13:35:21.075] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:21.075] Resolving globals: FALSE
[13:35:21.075] Tweak future expression to call with '...' arguments ...
[13:35:21.075] {
[13:35:21.075]     do.call(function(...) {
[13:35:21.075]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:21.075]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:21.075]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:21.075]             on.exit(options(oopts), add = TRUE)
[13:35:21.075]         }
[13:35:21.075]         {
[13:35:21.075]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:21.075]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:21.075]                 ...future.FUN(...future.X_jj, ...)
[13:35:21.075]             })
[13:35:21.075]         }
[13:35:21.075]     }, args = future.call.arguments)
[13:35:21.075] }
[13:35:21.076] Tweak future expression to call with '...' arguments ... DONE
[13:35:21.076] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:21.076] 
[13:35:21.076] getGlobalsAndPackages() ... DONE
[13:35:21.077] run() for ‘Future’ ...
[13:35:21.077] - state: ‘created’
[13:35:21.077] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:35:21.077] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:21.077] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:21.077]   - Field: ‘label’
[13:35:21.077]   - Field: ‘local’
[13:35:21.077]   - Field: ‘owner’
[13:35:21.078]   - Field: ‘envir’
[13:35:21.078]   - Field: ‘packages’
[13:35:21.078]   - Field: ‘gc’
[13:35:21.078]   - Field: ‘conditions’
[13:35:21.078]   - Field: ‘expr’
[13:35:21.078]   - Field: ‘uuid’
[13:35:21.078]   - Field: ‘seed’
[13:35:21.078]   - Field: ‘version’
[13:35:21.078]   - Field: ‘result’
[13:35:21.078]   - Field: ‘asynchronous’
[13:35:21.078]   - Field: ‘calls’
[13:35:21.079]   - Field: ‘globals’
[13:35:21.079]   - Field: ‘stdout’
[13:35:21.079]   - Field: ‘earlySignal’
[13:35:21.079]   - Field: ‘lazy’
[13:35:21.079]   - Field: ‘state’
[13:35:21.079] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:21.079] - Launch lazy future ...
[13:35:21.079] Packages needed by the future expression (n = 0): <none>
[13:35:21.079] Packages needed by future strategies (n = 0): <none>
[13:35:21.080] {
[13:35:21.080]     {
[13:35:21.080]         {
[13:35:21.080]             ...future.startTime <- base::Sys.time()
[13:35:21.080]             {
[13:35:21.080]                 {
[13:35:21.080]                   {
[13:35:21.080]                     base::local({
[13:35:21.080]                       has_future <- base::requireNamespace("future", 
[13:35:21.080]                         quietly = TRUE)
[13:35:21.080]                       if (has_future) {
[13:35:21.080]                         ns <- base::getNamespace("future")
[13:35:21.080]                         version <- ns[[".package"]][["version"]]
[13:35:21.080]                         if (is.null(version)) 
[13:35:21.080]                           version <- utils::packageVersion("future")
[13:35:21.080]                       }
[13:35:21.080]                       else {
[13:35:21.080]                         version <- NULL
[13:35:21.080]                       }
[13:35:21.080]                       if (!has_future || version < "1.8.0") {
[13:35:21.080]                         info <- base::c(r_version = base::gsub("R version ", 
[13:35:21.080]                           "", base::R.version$version.string), 
[13:35:21.080]                           platform = base::sprintf("%s (%s-bit)", 
[13:35:21.080]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:21.080]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:21.080]                             "release", "version")], collapse = " "), 
[13:35:21.080]                           hostname = base::Sys.info()[["nodename"]])
[13:35:21.080]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:35:21.080]                           info)
[13:35:21.080]                         info <- base::paste(info, collapse = "; ")
[13:35:21.080]                         if (!has_future) {
[13:35:21.080]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:21.080]                             info)
[13:35:21.080]                         }
[13:35:21.080]                         else {
[13:35:21.080]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:21.080]                             info, version)
[13:35:21.080]                         }
[13:35:21.080]                         base::stop(msg)
[13:35:21.080]                       }
[13:35:21.080]                     })
[13:35:21.080]                   }
[13:35:21.080]                   ...future.strategy.old <- future::plan("list")
[13:35:21.080]                   options(future.plan = NULL)
[13:35:21.080]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:21.080]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:21.080]                 }
[13:35:21.080]                 ...future.workdir <- getwd()
[13:35:21.080]             }
[13:35:21.080]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:21.080]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:21.080]         }
[13:35:21.080]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:21.080]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:21.080]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:21.080]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:21.080]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:21.080]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:21.080]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:21.080]             base::names(...future.oldOptions))
[13:35:21.080]     }
[13:35:21.080]     if (TRUE) {
[13:35:21.080]     }
[13:35:21.080]     else {
[13:35:21.080]         if (NA) {
[13:35:21.080]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:21.080]                 open = "w")
[13:35:21.080]         }
[13:35:21.080]         else {
[13:35:21.080]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:21.080]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:21.080]         }
[13:35:21.080]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:21.080]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:21.080]             base::sink(type = "output", split = FALSE)
[13:35:21.080]             base::close(...future.stdout)
[13:35:21.080]         }, add = TRUE)
[13:35:21.080]     }
[13:35:21.080]     ...future.frame <- base::sys.nframe()
[13:35:21.080]     ...future.conditions <- base::list()
[13:35:21.080]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:21.080]     if (FALSE) {
[13:35:21.080]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:21.080]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:21.080]     }
[13:35:21.080]     ...future.result <- base::tryCatch({
[13:35:21.080]         base::withCallingHandlers({
[13:35:21.080]             ...future.value <- base::withVisible(base::local({
[13:35:21.080]                 do.call(function(...) {
[13:35:21.080]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:21.080]                   if (!identical(...future.globals.maxSize.org, 
[13:35:21.080]                     ...future.globals.maxSize)) {
[13:35:21.080]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:21.080]                     on.exit(options(oopts), add = TRUE)
[13:35:21.080]                   }
[13:35:21.080]                   {
[13:35:21.080]                     lapply(seq_along(...future.elements_ii), 
[13:35:21.080]                       FUN = function(jj) {
[13:35:21.080]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:21.080]                         ...future.FUN(...future.X_jj, ...)
[13:35:21.080]                       })
[13:35:21.080]                   }
[13:35:21.080]                 }, args = future.call.arguments)
[13:35:21.080]             }))
[13:35:21.080]             future::FutureResult(value = ...future.value$value, 
[13:35:21.080]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:21.080]                   ...future.rng), globalenv = if (FALSE) 
[13:35:21.080]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:21.080]                     ...future.globalenv.names))
[13:35:21.080]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:21.080]         }, condition = base::local({
[13:35:21.080]             c <- base::c
[13:35:21.080]             inherits <- base::inherits
[13:35:21.080]             invokeRestart <- base::invokeRestart
[13:35:21.080]             length <- base::length
[13:35:21.080]             list <- base::list
[13:35:21.080]             seq.int <- base::seq.int
[13:35:21.080]             signalCondition <- base::signalCondition
[13:35:21.080]             sys.calls <- base::sys.calls
[13:35:21.080]             `[[` <- base::`[[`
[13:35:21.080]             `+` <- base::`+`
[13:35:21.080]             `<<-` <- base::`<<-`
[13:35:21.080]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:21.080]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:21.080]                   3L)]
[13:35:21.080]             }
[13:35:21.080]             function(cond) {
[13:35:21.080]                 is_error <- inherits(cond, "error")
[13:35:21.080]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:21.080]                   NULL)
[13:35:21.080]                 if (is_error) {
[13:35:21.080]                   sessionInformation <- function() {
[13:35:21.080]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:21.080]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:21.080]                       search = base::search(), system = base::Sys.info())
[13:35:21.080]                   }
[13:35:21.080]                   ...future.conditions[[length(...future.conditions) + 
[13:35:21.080]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:21.080]                     cond$call), session = sessionInformation(), 
[13:35:21.080]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:21.080]                   signalCondition(cond)
[13:35:21.080]                 }
[13:35:21.080]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:21.080]                 "immediateCondition"))) {
[13:35:21.080]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:21.080]                   ...future.conditions[[length(...future.conditions) + 
[13:35:21.080]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:21.080]                   if (TRUE && !signal) {
[13:35:21.080]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:21.080]                     {
[13:35:21.080]                       inherits <- base::inherits
[13:35:21.080]                       invokeRestart <- base::invokeRestart
[13:35:21.080]                       is.null <- base::is.null
[13:35:21.080]                       muffled <- FALSE
[13:35:21.080]                       if (inherits(cond, "message")) {
[13:35:21.080]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:21.080]                         if (muffled) 
[13:35:21.080]                           invokeRestart("muffleMessage")
[13:35:21.080]                       }
[13:35:21.080]                       else if (inherits(cond, "warning")) {
[13:35:21.080]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:21.080]                         if (muffled) 
[13:35:21.080]                           invokeRestart("muffleWarning")
[13:35:21.080]                       }
[13:35:21.080]                       else if (inherits(cond, "condition")) {
[13:35:21.080]                         if (!is.null(pattern)) {
[13:35:21.080]                           computeRestarts <- base::computeRestarts
[13:35:21.080]                           grepl <- base::grepl
[13:35:21.080]                           restarts <- computeRestarts(cond)
[13:35:21.080]                           for (restart in restarts) {
[13:35:21.080]                             name <- restart$name
[13:35:21.080]                             if (is.null(name)) 
[13:35:21.080]                               next
[13:35:21.080]                             if (!grepl(pattern, name)) 
[13:35:21.080]                               next
[13:35:21.080]                             invokeRestart(restart)
[13:35:21.080]                             muffled <- TRUE
[13:35:21.080]                             break
[13:35:21.080]                           }
[13:35:21.080]                         }
[13:35:21.080]                       }
[13:35:21.080]                       invisible(muffled)
[13:35:21.080]                     }
[13:35:21.080]                     muffleCondition(cond, pattern = "^muffle")
[13:35:21.080]                   }
[13:35:21.080]                 }
[13:35:21.080]                 else {
[13:35:21.080]                   if (TRUE) {
[13:35:21.080]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:21.080]                     {
[13:35:21.080]                       inherits <- base::inherits
[13:35:21.080]                       invokeRestart <- base::invokeRestart
[13:35:21.080]                       is.null <- base::is.null
[13:35:21.080]                       muffled <- FALSE
[13:35:21.080]                       if (inherits(cond, "message")) {
[13:35:21.080]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:21.080]                         if (muffled) 
[13:35:21.080]                           invokeRestart("muffleMessage")
[13:35:21.080]                       }
[13:35:21.080]                       else if (inherits(cond, "warning")) {
[13:35:21.080]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:21.080]                         if (muffled) 
[13:35:21.080]                           invokeRestart("muffleWarning")
[13:35:21.080]                       }
[13:35:21.080]                       else if (inherits(cond, "condition")) {
[13:35:21.080]                         if (!is.null(pattern)) {
[13:35:21.080]                           computeRestarts <- base::computeRestarts
[13:35:21.080]                           grepl <- base::grepl
[13:35:21.080]                           restarts <- computeRestarts(cond)
[13:35:21.080]                           for (restart in restarts) {
[13:35:21.080]                             name <- restart$name
[13:35:21.080]                             if (is.null(name)) 
[13:35:21.080]                               next
[13:35:21.080]                             if (!grepl(pattern, name)) 
[13:35:21.080]                               next
[13:35:21.080]                             invokeRestart(restart)
[13:35:21.080]                             muffled <- TRUE
[13:35:21.080]                             break
[13:35:21.080]                           }
[13:35:21.080]                         }
[13:35:21.080]                       }
[13:35:21.080]                       invisible(muffled)
[13:35:21.080]                     }
[13:35:21.080]                     muffleCondition(cond, pattern = "^muffle")
[13:35:21.080]                   }
[13:35:21.080]                 }
[13:35:21.080]             }
[13:35:21.080]         }))
[13:35:21.080]     }, error = function(ex) {
[13:35:21.080]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:21.080]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:21.080]                 ...future.rng), started = ...future.startTime, 
[13:35:21.080]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:21.080]             version = "1.8"), class = "FutureResult")
[13:35:21.080]     }, finally = {
[13:35:21.080]         if (!identical(...future.workdir, getwd())) 
[13:35:21.080]             setwd(...future.workdir)
[13:35:21.080]         {
[13:35:21.080]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:21.080]                 ...future.oldOptions$nwarnings <- NULL
[13:35:21.080]             }
[13:35:21.080]             base::options(...future.oldOptions)
[13:35:21.080]             if (.Platform$OS.type == "windows") {
[13:35:21.080]                 old_names <- names(...future.oldEnvVars)
[13:35:21.080]                 envs <- base::Sys.getenv()
[13:35:21.080]                 names <- names(envs)
[13:35:21.080]                 common <- intersect(names, old_names)
[13:35:21.080]                 added <- setdiff(names, old_names)
[13:35:21.080]                 removed <- setdiff(old_names, names)
[13:35:21.080]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:21.080]                   envs[common]]
[13:35:21.080]                 NAMES <- toupper(changed)
[13:35:21.080]                 args <- list()
[13:35:21.080]                 for (kk in seq_along(NAMES)) {
[13:35:21.080]                   name <- changed[[kk]]
[13:35:21.080]                   NAME <- NAMES[[kk]]
[13:35:21.080]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:21.080]                     next
[13:35:21.080]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:21.080]                 }
[13:35:21.080]                 NAMES <- toupper(added)
[13:35:21.080]                 for (kk in seq_along(NAMES)) {
[13:35:21.080]                   name <- added[[kk]]
[13:35:21.080]                   NAME <- NAMES[[kk]]
[13:35:21.080]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:21.080]                     next
[13:35:21.080]                   args[[name]] <- ""
[13:35:21.080]                 }
[13:35:21.080]                 NAMES <- toupper(removed)
[13:35:21.080]                 for (kk in seq_along(NAMES)) {
[13:35:21.080]                   name <- removed[[kk]]
[13:35:21.080]                   NAME <- NAMES[[kk]]
[13:35:21.080]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:21.080]                     next
[13:35:21.080]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:21.080]                 }
[13:35:21.080]                 if (length(args) > 0) 
[13:35:21.080]                   base::do.call(base::Sys.setenv, args = args)
[13:35:21.080]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:21.080]             }
[13:35:21.080]             else {
[13:35:21.080]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:21.080]             }
[13:35:21.080]             {
[13:35:21.080]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:21.080]                   0L) {
[13:35:21.080]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:21.080]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:21.080]                   base::options(opts)
[13:35:21.080]                 }
[13:35:21.080]                 {
[13:35:21.080]                   {
[13:35:21.080]                     NULL
[13:35:21.080]                     RNGkind("Mersenne-Twister")
[13:35:21.080]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:21.080]                       inherits = FALSE)
[13:35:21.080]                   }
[13:35:21.080]                   options(future.plan = NULL)
[13:35:21.080]                   if (is.na(NA_character_)) 
[13:35:21.080]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:21.080]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:21.080]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:21.080]                     .init = FALSE)
[13:35:21.080]                 }
[13:35:21.080]             }
[13:35:21.080]         }
[13:35:21.080]     })
[13:35:21.080]     if (FALSE) {
[13:35:21.080]         base::sink(type = "output", split = FALSE)
[13:35:21.080]         if (NA) {
[13:35:21.080]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:21.080]         }
[13:35:21.080]         else {
[13:35:21.080]             ...future.result["stdout"] <- base::list(NULL)
[13:35:21.080]         }
[13:35:21.080]         base::close(...future.stdout)
[13:35:21.080]         ...future.stdout <- NULL
[13:35:21.080]     }
[13:35:21.080]     ...future.result$conditions <- ...future.conditions
[13:35:21.080]     ...future.result$finished <- base::Sys.time()
[13:35:21.080]     ...future.result
[13:35:21.080] }
[13:35:21.081] assign_globals() ...
[13:35:21.081] List of 5
[13:35:21.081]  $ ...future.FUN            :function (x)  
[13:35:21.081]  $ future.call.arguments    : list()
[13:35:21.081]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:21.081]  $ ...future.elements_ii    :List of 2
[13:35:21.081]   ..$ : int 1
[13:35:21.081]   ..$ : int 0
[13:35:21.081]  $ ...future.seeds_ii       : NULL
[13:35:21.081]  $ ...future.globals.maxSize: NULL
[13:35:21.081]  - attr(*, "where")=List of 5
[13:35:21.081]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:21.081]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:21.081]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:21.081]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:21.081]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:21.081]  - attr(*, "resolved")= logi FALSE
[13:35:21.081]  - attr(*, "total_size")= num 4720
[13:35:21.081]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:21.081]  - attr(*, "already-done")= logi TRUE
[13:35:21.086] - reassign environment for ‘...future.FUN’
[13:35:21.086] - copied ‘...future.FUN’ to environment
[13:35:21.086] - copied ‘future.call.arguments’ to environment
[13:35:21.086] - copied ‘...future.elements_ii’ to environment
[13:35:21.087] - copied ‘...future.seeds_ii’ to environment
[13:35:21.087] - copied ‘...future.globals.maxSize’ to environment
[13:35:21.087] assign_globals() ... done
[13:35:21.087] plan(): Setting new future strategy stack:
[13:35:21.087] List of future strategies:
[13:35:21.087] 1. sequential:
[13:35:21.087]    - args: function (..., envir = parent.frame())
[13:35:21.087]    - tweaked: FALSE
[13:35:21.087]    - call: NULL
[13:35:21.087] plan(): nbrOfWorkers() = 1
[13:35:21.589] plan(): Setting new future strategy stack:
[13:35:21.589] List of future strategies:
[13:35:21.589] 1. sequential:
[13:35:21.589]    - args: function (..., envir = parent.frame())
[13:35:21.589]    - tweaked: FALSE
[13:35:21.589]    - call: plan(strategy)
[13:35:21.590] plan(): nbrOfWorkers() = 1
[13:35:21.590] SequentialFuture started (and completed)
[13:35:21.590] - Launch lazy future ... done
[13:35:21.590] run() for ‘SequentialFuture’ ... done
[13:35:21.590] Created future:
[13:35:21.591] SequentialFuture:
[13:35:21.591] Label: ‘future_lapply-1’
[13:35:21.591] Expression:
[13:35:21.591] {
[13:35:21.591]     do.call(function(...) {
[13:35:21.591]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:21.591]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:21.591]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:21.591]             on.exit(options(oopts), add = TRUE)
[13:35:21.591]         }
[13:35:21.591]         {
[13:35:21.591]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:21.591]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:21.591]                 ...future.FUN(...future.X_jj, ...)
[13:35:21.591]             })
[13:35:21.591]         }
[13:35:21.591]     }, args = future.call.arguments)
[13:35:21.591] }
[13:35:21.591] Lazy evaluation: FALSE
[13:35:21.591] Asynchronous evaluation: FALSE
[13:35:21.591] Local evaluation: TRUE
[13:35:21.591] Environment: R_GlobalEnv
[13:35:21.591] Capture standard output: NA
[13:35:21.591] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:21.591] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:21.591] Packages: <none>
[13:35:21.591] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:21.591] Resolved: TRUE
[13:35:21.591] Value: 112 bytes of class ‘list’
[13:35:21.591] Early signaling: FALSE
[13:35:21.591] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:21.591] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:21.592] Chunk #1 of 1 ... DONE
[13:35:21.592] Launching 1 futures (chunks) ... DONE
[13:35:21.592] Resolving 1 futures (chunks) ...
[13:35:21.592] resolve() on list ...
[13:35:21.592]  recursive: 0
[13:35:21.592]  length: 1
[13:35:21.592] 
[13:35:21.592] resolved() for ‘SequentialFuture’ ...
[13:35:21.592] - state: ‘finished’
[13:35:21.593] - run: TRUE
[13:35:21.593] - result: ‘FutureResult’
[13:35:21.593] resolved() for ‘SequentialFuture’ ... done
[13:35:21.593] Future #1
[13:35:21.593] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:21.593] - nx: 1
[13:35:21.593] - relay: TRUE
[13:35:21.593] - stdout: TRUE
[13:35:21.593] - signal: TRUE
[13:35:21.593] - resignal: FALSE
[13:35:21.593] - force: TRUE
[13:35:21.594] - relayed: [n=1] FALSE
[13:35:21.594] - queued futures: [n=1] FALSE
[13:35:21.594]  - until=1
[13:35:21.594]  - relaying element #1
[13:35:21.594] - relayed: [n=1] TRUE
[13:35:21.594] - queued futures: [n=1] TRUE
[13:35:21.594] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:21.594]  length: 0 (resolved future 1)
[13:35:21.594] Relaying remaining futures
[13:35:21.595] signalConditionsASAP(NULL, pos=0) ...
[13:35:21.595] - nx: 1
[13:35:21.595] - relay: TRUE
[13:35:21.595] - stdout: TRUE
[13:35:21.595] - signal: TRUE
[13:35:21.595] - resignal: FALSE
[13:35:21.595] - force: TRUE
[13:35:21.595] - relayed: [n=1] TRUE
[13:35:21.595] - queued futures: [n=1] TRUE
 - flush all
[13:35:21.595] - relayed: [n=1] TRUE
[13:35:21.595] - queued futures: [n=1] TRUE
[13:35:21.596] signalConditionsASAP(NULL, pos=0) ... done
[13:35:21.596] resolve() on list ... DONE
[13:35:21.596]  - Number of value chunks collected: 1
[13:35:21.596] Resolving 1 futures (chunks) ... DONE
[13:35:21.596] Reducing values from 1 chunks ...
[13:35:21.596]  - Number of values collected after concatenation: 2
[13:35:21.596]  - Number of values expected: 2
[13:35:21.596] Reducing values from 1 chunks ... DONE
[13:35:21.596] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[13:35:21.597] future_mapply() ...
[13:35:21.597] Number of chunks: 1
[13:35:21.597] getGlobalsAndPackagesXApply() ...
[13:35:21.597]  - future.globals: TRUE
[13:35:21.597] getGlobalsAndPackages() ...
[13:35:21.597] Searching for globals...
[13:35:21.599] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:35:21.599] Searching for globals ... DONE
[13:35:21.599] Resolving globals: FALSE
[13:35:21.601] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:35:21.601] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:35:21.601] - globals: [1] ‘FUN’
[13:35:21.602] 
[13:35:21.602] getGlobalsAndPackages() ... DONE
[13:35:21.602]  - globals found/used: [n=1] ‘FUN’
[13:35:21.602]  - needed namespaces: [n=0] 
[13:35:21.602] Finding globals ... DONE
[13:35:21.602] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:35:21.602] List of 2
[13:35:21.602]  $ ...future.FUN:function (x, y)  
[13:35:21.602]  $ MoreArgs     : NULL
[13:35:21.602]  - attr(*, "where")=List of 2
[13:35:21.602]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:21.602]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:35:21.602]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:21.602]  - attr(*, "resolved")= logi FALSE
[13:35:21.602]  - attr(*, "total_size")= num NA
[13:35:21.605] Packages to be attached in all futures: [n=0] 
[13:35:21.605] getGlobalsAndPackagesXApply() ... DONE
[13:35:21.605] Number of futures (= number of chunks): 1
[13:35:21.605] Launching 1 futures (chunks) ...
[13:35:21.605] Chunk #1 of 1 ...
[13:35:21.605]  - Finding globals in '...' for chunk #1 ...
[13:35:21.606] getGlobalsAndPackages() ...
[13:35:21.606] Searching for globals...
[13:35:21.606] 
[13:35:21.606] Searching for globals ... DONE
[13:35:21.606] - globals: [0] <none>
[13:35:21.606] getGlobalsAndPackages() ... DONE
[13:35:21.606]    + additional globals found: [n=0] 
[13:35:21.606]    + additional namespaces needed: [n=0] 
[13:35:21.607]  - Finding globals in '...' for chunk #1 ... DONE
[13:35:21.607]  - seeds: <none>
[13:35:21.607]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:21.607] getGlobalsAndPackages() ...
[13:35:21.607] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:21.607] Resolving globals: FALSE
[13:35:21.607] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:35:21.608] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:35:21.608] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:21.608] 
[13:35:21.608] getGlobalsAndPackages() ... DONE
[13:35:21.609] run() for ‘Future’ ...
[13:35:21.609] - state: ‘created’
[13:35:21.609] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:35:21.609] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:21.609] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:21.609]   - Field: ‘label’
[13:35:21.609]   - Field: ‘local’
[13:35:21.609]   - Field: ‘owner’
[13:35:21.610]   - Field: ‘envir’
[13:35:21.610]   - Field: ‘packages’
[13:35:21.610]   - Field: ‘gc’
[13:35:21.610]   - Field: ‘conditions’
[13:35:21.610]   - Field: ‘expr’
[13:35:21.610]   - Field: ‘uuid’
[13:35:21.610]   - Field: ‘seed’
[13:35:21.610]   - Field: ‘version’
[13:35:21.610]   - Field: ‘result’
[13:35:21.610]   - Field: ‘asynchronous’
[13:35:21.611]   - Field: ‘calls’
[13:35:21.611]   - Field: ‘globals’
[13:35:21.611]   - Field: ‘stdout’
[13:35:21.611]   - Field: ‘earlySignal’
[13:35:21.611]   - Field: ‘lazy’
[13:35:21.611]   - Field: ‘state’
[13:35:21.611] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:21.611] - Launch lazy future ...
[13:35:21.611] Packages needed by the future expression (n = 0): <none>
[13:35:21.611] Packages needed by future strategies (n = 0): <none>
[13:35:21.612] {
[13:35:21.612]     {
[13:35:21.612]         {
[13:35:21.612]             ...future.startTime <- base::Sys.time()
[13:35:21.612]             {
[13:35:21.612]                 {
[13:35:21.612]                   {
[13:35:21.612]                     base::local({
[13:35:21.612]                       has_future <- base::requireNamespace("future", 
[13:35:21.612]                         quietly = TRUE)
[13:35:21.612]                       if (has_future) {
[13:35:21.612]                         ns <- base::getNamespace("future")
[13:35:21.612]                         version <- ns[[".package"]][["version"]]
[13:35:21.612]                         if (is.null(version)) 
[13:35:21.612]                           version <- utils::packageVersion("future")
[13:35:21.612]                       }
[13:35:21.612]                       else {
[13:35:21.612]                         version <- NULL
[13:35:21.612]                       }
[13:35:21.612]                       if (!has_future || version < "1.8.0") {
[13:35:21.612]                         info <- base::c(r_version = base::gsub("R version ", 
[13:35:21.612]                           "", base::R.version$version.string), 
[13:35:21.612]                           platform = base::sprintf("%s (%s-bit)", 
[13:35:21.612]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:21.612]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:21.612]                             "release", "version")], collapse = " "), 
[13:35:21.612]                           hostname = base::Sys.info()[["nodename"]])
[13:35:21.612]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:35:21.612]                           info)
[13:35:21.612]                         info <- base::paste(info, collapse = "; ")
[13:35:21.612]                         if (!has_future) {
[13:35:21.612]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:21.612]                             info)
[13:35:21.612]                         }
[13:35:21.612]                         else {
[13:35:21.612]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:21.612]                             info, version)
[13:35:21.612]                         }
[13:35:21.612]                         base::stop(msg)
[13:35:21.612]                       }
[13:35:21.612]                     })
[13:35:21.612]                   }
[13:35:21.612]                   ...future.strategy.old <- future::plan("list")
[13:35:21.612]                   options(future.plan = NULL)
[13:35:21.612]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:21.612]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:21.612]                 }
[13:35:21.612]                 ...future.workdir <- getwd()
[13:35:21.612]             }
[13:35:21.612]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:21.612]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:21.612]         }
[13:35:21.612]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:21.612]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:21.612]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:21.612]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:21.612]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:21.612]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:21.612]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:21.612]             base::names(...future.oldOptions))
[13:35:21.612]     }
[13:35:21.612]     if (FALSE) {
[13:35:21.612]     }
[13:35:21.612]     else {
[13:35:21.612]         if (FALSE) {
[13:35:21.612]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:21.612]                 open = "w")
[13:35:21.612]         }
[13:35:21.612]         else {
[13:35:21.612]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:21.612]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:21.612]         }
[13:35:21.612]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:21.612]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:21.612]             base::sink(type = "output", split = FALSE)
[13:35:21.612]             base::close(...future.stdout)
[13:35:21.612]         }, add = TRUE)
[13:35:21.612]     }
[13:35:21.612]     ...future.frame <- base::sys.nframe()
[13:35:21.612]     ...future.conditions <- base::list()
[13:35:21.612]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:21.612]     if (FALSE) {
[13:35:21.612]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:21.612]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:21.612]     }
[13:35:21.612]     ...future.result <- base::tryCatch({
[13:35:21.612]         base::withCallingHandlers({
[13:35:21.612]             ...future.value <- base::withVisible(base::local({
[13:35:21.612]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:21.612]                 if (!identical(...future.globals.maxSize.org, 
[13:35:21.612]                   ...future.globals.maxSize)) {
[13:35:21.612]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:21.612]                   on.exit(options(oopts), add = TRUE)
[13:35:21.612]                 }
[13:35:21.612]                 {
[13:35:21.612]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:21.612]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:35:21.612]                     USE.NAMES = FALSE)
[13:35:21.612]                   do.call(mapply, args = args)
[13:35:21.612]                 }
[13:35:21.612]             }))
[13:35:21.612]             future::FutureResult(value = ...future.value$value, 
[13:35:21.612]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:21.612]                   ...future.rng), globalenv = if (FALSE) 
[13:35:21.612]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:21.612]                     ...future.globalenv.names))
[13:35:21.612]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:21.612]         }, condition = base::local({
[13:35:21.612]             c <- base::c
[13:35:21.612]             inherits <- base::inherits
[13:35:21.612]             invokeRestart <- base::invokeRestart
[13:35:21.612]             length <- base::length
[13:35:21.612]             list <- base::list
[13:35:21.612]             seq.int <- base::seq.int
[13:35:21.612]             signalCondition <- base::signalCondition
[13:35:21.612]             sys.calls <- base::sys.calls
[13:35:21.612]             `[[` <- base::`[[`
[13:35:21.612]             `+` <- base::`+`
[13:35:21.612]             `<<-` <- base::`<<-`
[13:35:21.612]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:21.612]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:21.612]                   3L)]
[13:35:21.612]             }
[13:35:21.612]             function(cond) {
[13:35:21.612]                 is_error <- inherits(cond, "error")
[13:35:21.612]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:21.612]                   NULL)
[13:35:21.612]                 if (is_error) {
[13:35:21.612]                   sessionInformation <- function() {
[13:35:21.612]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:21.612]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:21.612]                       search = base::search(), system = base::Sys.info())
[13:35:21.612]                   }
[13:35:21.612]                   ...future.conditions[[length(...future.conditions) + 
[13:35:21.612]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:21.612]                     cond$call), session = sessionInformation(), 
[13:35:21.612]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:21.612]                   signalCondition(cond)
[13:35:21.612]                 }
[13:35:21.612]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:21.612]                 "immediateCondition"))) {
[13:35:21.612]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:21.612]                   ...future.conditions[[length(...future.conditions) + 
[13:35:21.612]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:21.612]                   if (TRUE && !signal) {
[13:35:21.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:21.612]                     {
[13:35:21.612]                       inherits <- base::inherits
[13:35:21.612]                       invokeRestart <- base::invokeRestart
[13:35:21.612]                       is.null <- base::is.null
[13:35:21.612]                       muffled <- FALSE
[13:35:21.612]                       if (inherits(cond, "message")) {
[13:35:21.612]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:21.612]                         if (muffled) 
[13:35:21.612]                           invokeRestart("muffleMessage")
[13:35:21.612]                       }
[13:35:21.612]                       else if (inherits(cond, "warning")) {
[13:35:21.612]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:21.612]                         if (muffled) 
[13:35:21.612]                           invokeRestart("muffleWarning")
[13:35:21.612]                       }
[13:35:21.612]                       else if (inherits(cond, "condition")) {
[13:35:21.612]                         if (!is.null(pattern)) {
[13:35:21.612]                           computeRestarts <- base::computeRestarts
[13:35:21.612]                           grepl <- base::grepl
[13:35:21.612]                           restarts <- computeRestarts(cond)
[13:35:21.612]                           for (restart in restarts) {
[13:35:21.612]                             name <- restart$name
[13:35:21.612]                             if (is.null(name)) 
[13:35:21.612]                               next
[13:35:21.612]                             if (!grepl(pattern, name)) 
[13:35:21.612]                               next
[13:35:21.612]                             invokeRestart(restart)
[13:35:21.612]                             muffled <- TRUE
[13:35:21.612]                             break
[13:35:21.612]                           }
[13:35:21.612]                         }
[13:35:21.612]                       }
[13:35:21.612]                       invisible(muffled)
[13:35:21.612]                     }
[13:35:21.612]                     muffleCondition(cond, pattern = "^muffle")
[13:35:21.612]                   }
[13:35:21.612]                 }
[13:35:21.612]                 else {
[13:35:21.612]                   if (TRUE) {
[13:35:21.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:21.612]                     {
[13:35:21.612]                       inherits <- base::inherits
[13:35:21.612]                       invokeRestart <- base::invokeRestart
[13:35:21.612]                       is.null <- base::is.null
[13:35:21.612]                       muffled <- FALSE
[13:35:21.612]                       if (inherits(cond, "message")) {
[13:35:21.612]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:21.612]                         if (muffled) 
[13:35:21.612]                           invokeRestart("muffleMessage")
[13:35:21.612]                       }
[13:35:21.612]                       else if (inherits(cond, "warning")) {
[13:35:21.612]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:21.612]                         if (muffled) 
[13:35:21.612]                           invokeRestart("muffleWarning")
[13:35:21.612]                       }
[13:35:21.612]                       else if (inherits(cond, "condition")) {
[13:35:21.612]                         if (!is.null(pattern)) {
[13:35:21.612]                           computeRestarts <- base::computeRestarts
[13:35:21.612]                           grepl <- base::grepl
[13:35:21.612]                           restarts <- computeRestarts(cond)
[13:35:21.612]                           for (restart in restarts) {
[13:35:21.612]                             name <- restart$name
[13:35:21.612]                             if (is.null(name)) 
[13:35:21.612]                               next
[13:35:21.612]                             if (!grepl(pattern, name)) 
[13:35:21.612]                               next
[13:35:21.612]                             invokeRestart(restart)
[13:35:21.612]                             muffled <- TRUE
[13:35:21.612]                             break
[13:35:21.612]                           }
[13:35:21.612]                         }
[13:35:21.612]                       }
[13:35:21.612]                       invisible(muffled)
[13:35:21.612]                     }
[13:35:21.612]                     muffleCondition(cond, pattern = "^muffle")
[13:35:21.612]                   }
[13:35:21.612]                 }
[13:35:21.612]             }
[13:35:21.612]         }))
[13:35:21.612]     }, error = function(ex) {
[13:35:21.612]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:21.612]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:21.612]                 ...future.rng), started = ...future.startTime, 
[13:35:21.612]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:21.612]             version = "1.8"), class = "FutureResult")
[13:35:21.612]     }, finally = {
[13:35:21.612]         if (!identical(...future.workdir, getwd())) 
[13:35:21.612]             setwd(...future.workdir)
[13:35:21.612]         {
[13:35:21.612]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:21.612]                 ...future.oldOptions$nwarnings <- NULL
[13:35:21.612]             }
[13:35:21.612]             base::options(...future.oldOptions)
[13:35:21.612]             if (.Platform$OS.type == "windows") {
[13:35:21.612]                 old_names <- names(...future.oldEnvVars)
[13:35:21.612]                 envs <- base::Sys.getenv()
[13:35:21.612]                 names <- names(envs)
[13:35:21.612]                 common <- intersect(names, old_names)
[13:35:21.612]                 added <- setdiff(names, old_names)
[13:35:21.612]                 removed <- setdiff(old_names, names)
[13:35:21.612]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:21.612]                   envs[common]]
[13:35:21.612]                 NAMES <- toupper(changed)
[13:35:21.612]                 args <- list()
[13:35:21.612]                 for (kk in seq_along(NAMES)) {
[13:35:21.612]                   name <- changed[[kk]]
[13:35:21.612]                   NAME <- NAMES[[kk]]
[13:35:21.612]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:21.612]                     next
[13:35:21.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:21.612]                 }
[13:35:21.612]                 NAMES <- toupper(added)
[13:35:21.612]                 for (kk in seq_along(NAMES)) {
[13:35:21.612]                   name <- added[[kk]]
[13:35:21.612]                   NAME <- NAMES[[kk]]
[13:35:21.612]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:21.612]                     next
[13:35:21.612]                   args[[name]] <- ""
[13:35:21.612]                 }
[13:35:21.612]                 NAMES <- toupper(removed)
[13:35:21.612]                 for (kk in seq_along(NAMES)) {
[13:35:21.612]                   name <- removed[[kk]]
[13:35:21.612]                   NAME <- NAMES[[kk]]
[13:35:21.612]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:21.612]                     next
[13:35:21.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:21.612]                 }
[13:35:21.612]                 if (length(args) > 0) 
[13:35:21.612]                   base::do.call(base::Sys.setenv, args = args)
[13:35:21.612]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:21.612]             }
[13:35:21.612]             else {
[13:35:21.612]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:21.612]             }
[13:35:21.612]             {
[13:35:21.612]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:21.612]                   0L) {
[13:35:21.612]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:21.612]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:21.612]                   base::options(opts)
[13:35:21.612]                 }
[13:35:21.612]                 {
[13:35:21.612]                   {
[13:35:21.612]                     NULL
[13:35:21.612]                     RNGkind("Mersenne-Twister")
[13:35:21.612]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:21.612]                       inherits = FALSE)
[13:35:21.612]                   }
[13:35:21.612]                   options(future.plan = NULL)
[13:35:21.612]                   if (is.na(NA_character_)) 
[13:35:21.612]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:21.612]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:21.612]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:21.612]                     .init = FALSE)
[13:35:21.612]                 }
[13:35:21.612]             }
[13:35:21.612]         }
[13:35:21.612]     })
[13:35:21.612]     if (TRUE) {
[13:35:21.612]         base::sink(type = "output", split = FALSE)
[13:35:21.612]         if (FALSE) {
[13:35:21.612]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:21.612]         }
[13:35:21.612]         else {
[13:35:21.612]             ...future.result["stdout"] <- base::list(NULL)
[13:35:21.612]         }
[13:35:21.612]         base::close(...future.stdout)
[13:35:21.612]         ...future.stdout <- NULL
[13:35:21.612]     }
[13:35:21.612]     ...future.result$conditions <- ...future.conditions
[13:35:21.612]     ...future.result$finished <- base::Sys.time()
[13:35:21.612]     ...future.result
[13:35:21.612] }
[13:35:21.614] assign_globals() ...
[13:35:21.614] List of 5
[13:35:21.614]  $ ...future.FUN            :function (x, y)  
[13:35:21.614]  $ MoreArgs                 : NULL
[13:35:21.614]  $ ...future.elements_ii    :List of 2
[13:35:21.614]   ..$ :List of 2
[13:35:21.614]   .. ..$ : int 1
[13:35:21.614]   .. ..$ : int 0
[13:35:21.614]   ..$ :List of 2
[13:35:21.614]   .. ..$ : int 0
[13:35:21.614]   .. ..$ : int 1
[13:35:21.614]  $ ...future.seeds_ii       : NULL
[13:35:21.614]  $ ...future.globals.maxSize: NULL
[13:35:21.614]  - attr(*, "where")=List of 5
[13:35:21.614]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:21.614]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:35:21.614]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:21.614]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:21.614]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:21.614]  - attr(*, "resolved")= logi FALSE
[13:35:21.614]  - attr(*, "total_size")= num 6480
[13:35:21.614]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:21.614]  - attr(*, "already-done")= logi TRUE
[13:35:21.619] - reassign environment for ‘...future.FUN’
[13:35:21.619] - copied ‘...future.FUN’ to environment
[13:35:21.619] - copied ‘MoreArgs’ to environment
[13:35:21.619] - copied ‘...future.elements_ii’ to environment
[13:35:21.620] - copied ‘...future.seeds_ii’ to environment
[13:35:21.620] - copied ‘...future.globals.maxSize’ to environment
[13:35:21.620] assign_globals() ... done
[13:35:21.620] plan(): Setting new future strategy stack:
[13:35:21.620] List of future strategies:
[13:35:21.620] 1. sequential:
[13:35:21.620]    - args: function (..., envir = parent.frame())
[13:35:21.620]    - tweaked: FALSE
[13:35:21.620]    - call: NULL
[13:35:21.620] plan(): nbrOfWorkers() = 1
[13:35:22.122] plan(): Setting new future strategy stack:
[13:35:22.122] List of future strategies:
[13:35:22.122] 1. sequential:
[13:35:22.122]    - args: function (..., envir = parent.frame())
[13:35:22.122]    - tweaked: FALSE
[13:35:22.122]    - call: plan(strategy)
[13:35:22.123] plan(): nbrOfWorkers() = 1
[13:35:22.123] SequentialFuture started (and completed)
[13:35:22.123] - Launch lazy future ... done
[13:35:22.123] run() for ‘SequentialFuture’ ... done
[13:35:22.124] Created future:
[13:35:22.124] SequentialFuture:
[13:35:22.124] Label: ‘future_mapply-1’
[13:35:22.124] Expression:
[13:35:22.124] {
[13:35:22.124]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:22.124]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:22.124]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:22.124]         on.exit(options(oopts), add = TRUE)
[13:35:22.124]     }
[13:35:22.124]     {
[13:35:22.124]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:22.124]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:35:22.124]         do.call(mapply, args = args)
[13:35:22.124]     }
[13:35:22.124] }
[13:35:22.124] Lazy evaluation: FALSE
[13:35:22.124] Asynchronous evaluation: FALSE
[13:35:22.124] Local evaluation: TRUE
[13:35:22.124] Environment: R_GlobalEnv
[13:35:22.124] Capture standard output: FALSE
[13:35:22.124] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:22.124] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:22.124] Packages: <none>
[13:35:22.124] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:22.124] Resolved: TRUE
[13:35:22.124] Value: 224 bytes of class ‘list’
[13:35:22.124] Early signaling: FALSE
[13:35:22.124] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:22.124] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:22.125] Chunk #1 of 1 ... DONE
[13:35:22.125] Launching 1 futures (chunks) ... DONE
[13:35:22.125] Resolving 1 futures (chunks) ...
[13:35:22.125] resolve() on list ...
[13:35:22.125]  recursive: 0
[13:35:22.125]  length: 1
[13:35:22.125] 
[13:35:22.125] resolved() for ‘SequentialFuture’ ...
[13:35:22.125] - state: ‘finished’
[13:35:22.126] - run: TRUE
[13:35:22.126] - result: ‘FutureResult’
[13:35:22.126] resolved() for ‘SequentialFuture’ ... done
[13:35:22.126] Future #1
[13:35:22.126] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:22.126] - nx: 1
[13:35:22.126] - relay: TRUE
[13:35:22.126] - stdout: TRUE
[13:35:22.126] - signal: TRUE
[13:35:22.128] - resignal: FALSE
[13:35:22.128] - force: TRUE
[13:35:22.128] - relayed: [n=1] FALSE
[13:35:22.128] - queued futures: [n=1] FALSE
[13:35:22.129]  - until=1
[13:35:22.129]  - relaying element #1
[13:35:22.129] - relayed: [n=1] TRUE
[13:35:22.129] - queued futures: [n=1] TRUE
[13:35:22.129] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:22.129]  length: 0 (resolved future 1)
[13:35:22.129] Relaying remaining futures
[13:35:22.129] signalConditionsASAP(NULL, pos=0) ...
[13:35:22.129] - nx: 1
[13:35:22.129] - relay: TRUE
[13:35:22.130] - stdout: TRUE
[13:35:22.130] - signal: TRUE
[13:35:22.130] - resignal: FALSE
[13:35:22.130] - force: TRUE
[13:35:22.130] - relayed: [n=1] TRUE
[13:35:22.130] - queued futures: [n=1] TRUE
 - flush all
[13:35:22.130] - relayed: [n=1] TRUE
[13:35:22.130] - queued futures: [n=1] TRUE
[13:35:22.130] signalConditionsASAP(NULL, pos=0) ... done
[13:35:22.130] resolve() on list ... DONE
[13:35:22.131]  - Number of value chunks collected: 1
[13:35:22.131] Resolving 1 futures (chunks) ... DONE
[13:35:22.131] Reducing values from 1 chunks ...
[13:35:22.131]  - Number of values collected after concatenation: 2
[13:35:22.131]  - Number of values expected: 2
[13:35:22.131] Reducing values from 1 chunks ... DONE
[13:35:22.131] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[13:35:22.132] future_mapply() ...
[13:35:22.132] Number of chunks: 1
[13:35:22.132] getGlobalsAndPackagesXApply() ...
[13:35:22.132]  - future.globals: TRUE
[13:35:22.132] getGlobalsAndPackages() ...
[13:35:22.132] Searching for globals...
[13:35:22.134] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:35:22.134] Searching for globals ... DONE
[13:35:22.134] Resolving globals: FALSE
[13:35:22.134] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:35:22.135] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:35:22.135] - globals: [1] ‘FUN’
[13:35:22.135] 
[13:35:22.135] getGlobalsAndPackages() ... DONE
[13:35:22.135]  - globals found/used: [n=1] ‘FUN’
[13:35:22.135]  - needed namespaces: [n=0] 
[13:35:22.135] Finding globals ... DONE
[13:35:22.135] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:35:22.136] List of 2
[13:35:22.136]  $ ...future.FUN:function (x, y)  
[13:35:22.136]  $ MoreArgs     : NULL
[13:35:22.136]  - attr(*, "where")=List of 2
[13:35:22.136]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:22.136]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:35:22.136]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:22.136]  - attr(*, "resolved")= logi FALSE
[13:35:22.136]  - attr(*, "total_size")= num NA
[13:35:22.138] Packages to be attached in all futures: [n=0] 
[13:35:22.138] getGlobalsAndPackagesXApply() ... DONE
[13:35:22.138] Number of futures (= number of chunks): 1
[13:35:22.138] Launching 1 futures (chunks) ...
[13:35:22.139] Chunk #1 of 1 ...
[13:35:22.139]  - Finding globals in '...' for chunk #1 ...
[13:35:22.139] getGlobalsAndPackages() ...
[13:35:22.139] Searching for globals...
[13:35:22.139] 
[13:35:22.139] Searching for globals ... DONE
[13:35:22.139] - globals: [0] <none>
[13:35:22.139] getGlobalsAndPackages() ... DONE
[13:35:22.140]    + additional globals found: [n=0] 
[13:35:22.140]    + additional namespaces needed: [n=0] 
[13:35:22.140]  - Finding globals in '...' for chunk #1 ... DONE
[13:35:22.140]  - seeds: <none>
[13:35:22.140]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:22.140] getGlobalsAndPackages() ...
[13:35:22.140] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:22.140] Resolving globals: FALSE
[13:35:22.141] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:35:22.141] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:35:22.141] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:22.141] 
[13:35:22.141] getGlobalsAndPackages() ... DONE
[13:35:22.142] run() for ‘Future’ ...
[13:35:22.142] - state: ‘created’
[13:35:22.142] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:35:22.142] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:22.142] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:22.142]   - Field: ‘label’
[13:35:22.142]   - Field: ‘local’
[13:35:22.143]   - Field: ‘owner’
[13:35:22.143]   - Field: ‘envir’
[13:35:22.143]   - Field: ‘packages’
[13:35:22.143]   - Field: ‘gc’
[13:35:22.143]   - Field: ‘conditions’
[13:35:22.143]   - Field: ‘expr’
[13:35:22.143]   - Field: ‘uuid’
[13:35:22.143]   - Field: ‘seed’
[13:35:22.143]   - Field: ‘version’
[13:35:22.143]   - Field: ‘result’
[13:35:22.143]   - Field: ‘asynchronous’
[13:35:22.144]   - Field: ‘calls’
[13:35:22.144]   - Field: ‘globals’
[13:35:22.144]   - Field: ‘stdout’
[13:35:22.144]   - Field: ‘earlySignal’
[13:35:22.144]   - Field: ‘lazy’
[13:35:22.144]   - Field: ‘state’
[13:35:22.144] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:22.144] - Launch lazy future ...
[13:35:22.144] Packages needed by the future expression (n = 0): <none>
[13:35:22.144] Packages needed by future strategies (n = 0): <none>
[13:35:22.145] {
[13:35:22.145]     {
[13:35:22.145]         {
[13:35:22.145]             ...future.startTime <- base::Sys.time()
[13:35:22.145]             {
[13:35:22.145]                 {
[13:35:22.145]                   {
[13:35:22.145]                     base::local({
[13:35:22.145]                       has_future <- base::requireNamespace("future", 
[13:35:22.145]                         quietly = TRUE)
[13:35:22.145]                       if (has_future) {
[13:35:22.145]                         ns <- base::getNamespace("future")
[13:35:22.145]                         version <- ns[[".package"]][["version"]]
[13:35:22.145]                         if (is.null(version)) 
[13:35:22.145]                           version <- utils::packageVersion("future")
[13:35:22.145]                       }
[13:35:22.145]                       else {
[13:35:22.145]                         version <- NULL
[13:35:22.145]                       }
[13:35:22.145]                       if (!has_future || version < "1.8.0") {
[13:35:22.145]                         info <- base::c(r_version = base::gsub("R version ", 
[13:35:22.145]                           "", base::R.version$version.string), 
[13:35:22.145]                           platform = base::sprintf("%s (%s-bit)", 
[13:35:22.145]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:22.145]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:22.145]                             "release", "version")], collapse = " "), 
[13:35:22.145]                           hostname = base::Sys.info()[["nodename"]])
[13:35:22.145]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:35:22.145]                           info)
[13:35:22.145]                         info <- base::paste(info, collapse = "; ")
[13:35:22.145]                         if (!has_future) {
[13:35:22.145]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:22.145]                             info)
[13:35:22.145]                         }
[13:35:22.145]                         else {
[13:35:22.145]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:22.145]                             info, version)
[13:35:22.145]                         }
[13:35:22.145]                         base::stop(msg)
[13:35:22.145]                       }
[13:35:22.145]                     })
[13:35:22.145]                   }
[13:35:22.145]                   ...future.strategy.old <- future::plan("list")
[13:35:22.145]                   options(future.plan = NULL)
[13:35:22.145]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:22.145]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:22.145]                 }
[13:35:22.145]                 ...future.workdir <- getwd()
[13:35:22.145]             }
[13:35:22.145]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:22.145]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:22.145]         }
[13:35:22.145]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:22.145]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:22.145]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:22.145]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:22.145]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:22.145]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:22.145]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:22.145]             base::names(...future.oldOptions))
[13:35:22.145]     }
[13:35:22.145]     if (FALSE) {
[13:35:22.145]     }
[13:35:22.145]     else {
[13:35:22.145]         if (TRUE) {
[13:35:22.145]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:22.145]                 open = "w")
[13:35:22.145]         }
[13:35:22.145]         else {
[13:35:22.145]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:22.145]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:22.145]         }
[13:35:22.145]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:22.145]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:22.145]             base::sink(type = "output", split = FALSE)
[13:35:22.145]             base::close(...future.stdout)
[13:35:22.145]         }, add = TRUE)
[13:35:22.145]     }
[13:35:22.145]     ...future.frame <- base::sys.nframe()
[13:35:22.145]     ...future.conditions <- base::list()
[13:35:22.145]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:22.145]     if (FALSE) {
[13:35:22.145]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:22.145]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:22.145]     }
[13:35:22.145]     ...future.result <- base::tryCatch({
[13:35:22.145]         base::withCallingHandlers({
[13:35:22.145]             ...future.value <- base::withVisible(base::local({
[13:35:22.145]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:22.145]                 if (!identical(...future.globals.maxSize.org, 
[13:35:22.145]                   ...future.globals.maxSize)) {
[13:35:22.145]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:22.145]                   on.exit(options(oopts), add = TRUE)
[13:35:22.145]                 }
[13:35:22.145]                 {
[13:35:22.145]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:22.145]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:35:22.145]                     USE.NAMES = FALSE)
[13:35:22.145]                   do.call(mapply, args = args)
[13:35:22.145]                 }
[13:35:22.145]             }))
[13:35:22.145]             future::FutureResult(value = ...future.value$value, 
[13:35:22.145]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:22.145]                   ...future.rng), globalenv = if (FALSE) 
[13:35:22.145]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:22.145]                     ...future.globalenv.names))
[13:35:22.145]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:22.145]         }, condition = base::local({
[13:35:22.145]             c <- base::c
[13:35:22.145]             inherits <- base::inherits
[13:35:22.145]             invokeRestart <- base::invokeRestart
[13:35:22.145]             length <- base::length
[13:35:22.145]             list <- base::list
[13:35:22.145]             seq.int <- base::seq.int
[13:35:22.145]             signalCondition <- base::signalCondition
[13:35:22.145]             sys.calls <- base::sys.calls
[13:35:22.145]             `[[` <- base::`[[`
[13:35:22.145]             `+` <- base::`+`
[13:35:22.145]             `<<-` <- base::`<<-`
[13:35:22.145]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:22.145]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:22.145]                   3L)]
[13:35:22.145]             }
[13:35:22.145]             function(cond) {
[13:35:22.145]                 is_error <- inherits(cond, "error")
[13:35:22.145]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:22.145]                   NULL)
[13:35:22.145]                 if (is_error) {
[13:35:22.145]                   sessionInformation <- function() {
[13:35:22.145]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:22.145]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:22.145]                       search = base::search(), system = base::Sys.info())
[13:35:22.145]                   }
[13:35:22.145]                   ...future.conditions[[length(...future.conditions) + 
[13:35:22.145]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:22.145]                     cond$call), session = sessionInformation(), 
[13:35:22.145]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:22.145]                   signalCondition(cond)
[13:35:22.145]                 }
[13:35:22.145]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:22.145]                 "immediateCondition"))) {
[13:35:22.145]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:22.145]                   ...future.conditions[[length(...future.conditions) + 
[13:35:22.145]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:22.145]                   if (TRUE && !signal) {
[13:35:22.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:22.145]                     {
[13:35:22.145]                       inherits <- base::inherits
[13:35:22.145]                       invokeRestart <- base::invokeRestart
[13:35:22.145]                       is.null <- base::is.null
[13:35:22.145]                       muffled <- FALSE
[13:35:22.145]                       if (inherits(cond, "message")) {
[13:35:22.145]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:22.145]                         if (muffled) 
[13:35:22.145]                           invokeRestart("muffleMessage")
[13:35:22.145]                       }
[13:35:22.145]                       else if (inherits(cond, "warning")) {
[13:35:22.145]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:22.145]                         if (muffled) 
[13:35:22.145]                           invokeRestart("muffleWarning")
[13:35:22.145]                       }
[13:35:22.145]                       else if (inherits(cond, "condition")) {
[13:35:22.145]                         if (!is.null(pattern)) {
[13:35:22.145]                           computeRestarts <- base::computeRestarts
[13:35:22.145]                           grepl <- base::grepl
[13:35:22.145]                           restarts <- computeRestarts(cond)
[13:35:22.145]                           for (restart in restarts) {
[13:35:22.145]                             name <- restart$name
[13:35:22.145]                             if (is.null(name)) 
[13:35:22.145]                               next
[13:35:22.145]                             if (!grepl(pattern, name)) 
[13:35:22.145]                               next
[13:35:22.145]                             invokeRestart(restart)
[13:35:22.145]                             muffled <- TRUE
[13:35:22.145]                             break
[13:35:22.145]                           }
[13:35:22.145]                         }
[13:35:22.145]                       }
[13:35:22.145]                       invisible(muffled)
[13:35:22.145]                     }
[13:35:22.145]                     muffleCondition(cond, pattern = "^muffle")
[13:35:22.145]                   }
[13:35:22.145]                 }
[13:35:22.145]                 else {
[13:35:22.145]                   if (TRUE) {
[13:35:22.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:22.145]                     {
[13:35:22.145]                       inherits <- base::inherits
[13:35:22.145]                       invokeRestart <- base::invokeRestart
[13:35:22.145]                       is.null <- base::is.null
[13:35:22.145]                       muffled <- FALSE
[13:35:22.145]                       if (inherits(cond, "message")) {
[13:35:22.145]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:22.145]                         if (muffled) 
[13:35:22.145]                           invokeRestart("muffleMessage")
[13:35:22.145]                       }
[13:35:22.145]                       else if (inherits(cond, "warning")) {
[13:35:22.145]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:22.145]                         if (muffled) 
[13:35:22.145]                           invokeRestart("muffleWarning")
[13:35:22.145]                       }
[13:35:22.145]                       else if (inherits(cond, "condition")) {
[13:35:22.145]                         if (!is.null(pattern)) {
[13:35:22.145]                           computeRestarts <- base::computeRestarts
[13:35:22.145]                           grepl <- base::grepl
[13:35:22.145]                           restarts <- computeRestarts(cond)
[13:35:22.145]                           for (restart in restarts) {
[13:35:22.145]                             name <- restart$name
[13:35:22.145]                             if (is.null(name)) 
[13:35:22.145]                               next
[13:35:22.145]                             if (!grepl(pattern, name)) 
[13:35:22.145]                               next
[13:35:22.145]                             invokeRestart(restart)
[13:35:22.145]                             muffled <- TRUE
[13:35:22.145]                             break
[13:35:22.145]                           }
[13:35:22.145]                         }
[13:35:22.145]                       }
[13:35:22.145]                       invisible(muffled)
[13:35:22.145]                     }
[13:35:22.145]                     muffleCondition(cond, pattern = "^muffle")
[13:35:22.145]                   }
[13:35:22.145]                 }
[13:35:22.145]             }
[13:35:22.145]         }))
[13:35:22.145]     }, error = function(ex) {
[13:35:22.145]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:22.145]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:22.145]                 ...future.rng), started = ...future.startTime, 
[13:35:22.145]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:22.145]             version = "1.8"), class = "FutureResult")
[13:35:22.145]     }, finally = {
[13:35:22.145]         if (!identical(...future.workdir, getwd())) 
[13:35:22.145]             setwd(...future.workdir)
[13:35:22.145]         {
[13:35:22.145]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:22.145]                 ...future.oldOptions$nwarnings <- NULL
[13:35:22.145]             }
[13:35:22.145]             base::options(...future.oldOptions)
[13:35:22.145]             if (.Platform$OS.type == "windows") {
[13:35:22.145]                 old_names <- names(...future.oldEnvVars)
[13:35:22.145]                 envs <- base::Sys.getenv()
[13:35:22.145]                 names <- names(envs)
[13:35:22.145]                 common <- intersect(names, old_names)
[13:35:22.145]                 added <- setdiff(names, old_names)
[13:35:22.145]                 removed <- setdiff(old_names, names)
[13:35:22.145]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:22.145]                   envs[common]]
[13:35:22.145]                 NAMES <- toupper(changed)
[13:35:22.145]                 args <- list()
[13:35:22.145]                 for (kk in seq_along(NAMES)) {
[13:35:22.145]                   name <- changed[[kk]]
[13:35:22.145]                   NAME <- NAMES[[kk]]
[13:35:22.145]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:22.145]                     next
[13:35:22.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:22.145]                 }
[13:35:22.145]                 NAMES <- toupper(added)
[13:35:22.145]                 for (kk in seq_along(NAMES)) {
[13:35:22.145]                   name <- added[[kk]]
[13:35:22.145]                   NAME <- NAMES[[kk]]
[13:35:22.145]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:22.145]                     next
[13:35:22.145]                   args[[name]] <- ""
[13:35:22.145]                 }
[13:35:22.145]                 NAMES <- toupper(removed)
[13:35:22.145]                 for (kk in seq_along(NAMES)) {
[13:35:22.145]                   name <- removed[[kk]]
[13:35:22.145]                   NAME <- NAMES[[kk]]
[13:35:22.145]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:22.145]                     next
[13:35:22.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:22.145]                 }
[13:35:22.145]                 if (length(args) > 0) 
[13:35:22.145]                   base::do.call(base::Sys.setenv, args = args)
[13:35:22.145]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:22.145]             }
[13:35:22.145]             else {
[13:35:22.145]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:22.145]             }
[13:35:22.145]             {
[13:35:22.145]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:22.145]                   0L) {
[13:35:22.145]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:22.145]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:22.145]                   base::options(opts)
[13:35:22.145]                 }
[13:35:22.145]                 {
[13:35:22.145]                   {
[13:35:22.145]                     NULL
[13:35:22.145]                     RNGkind("Mersenne-Twister")
[13:35:22.145]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:22.145]                       inherits = FALSE)
[13:35:22.145]                   }
[13:35:22.145]                   options(future.plan = NULL)
[13:35:22.145]                   if (is.na(NA_character_)) 
[13:35:22.145]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:22.145]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:22.145]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:22.145]                     .init = FALSE)
[13:35:22.145]                 }
[13:35:22.145]             }
[13:35:22.145]         }
[13:35:22.145]     })
[13:35:22.145]     if (TRUE) {
[13:35:22.145]         base::sink(type = "output", split = FALSE)
[13:35:22.145]         if (TRUE) {
[13:35:22.145]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:22.145]         }
[13:35:22.145]         else {
[13:35:22.145]             ...future.result["stdout"] <- base::list(NULL)
[13:35:22.145]         }
[13:35:22.145]         base::close(...future.stdout)
[13:35:22.145]         ...future.stdout <- NULL
[13:35:22.145]     }
[13:35:22.145]     ...future.result$conditions <- ...future.conditions
[13:35:22.145]     ...future.result$finished <- base::Sys.time()
[13:35:22.145]     ...future.result
[13:35:22.145] }
[13:35:22.147] assign_globals() ...
[13:35:22.147] List of 5
[13:35:22.147]  $ ...future.FUN            :function (x, y)  
[13:35:22.147]  $ MoreArgs                 : NULL
[13:35:22.147]  $ ...future.elements_ii    :List of 2
[13:35:22.147]   ..$ :List of 2
[13:35:22.147]   .. ..$ : int 1
[13:35:22.147]   .. ..$ : int 0
[13:35:22.147]   ..$ :List of 2
[13:35:22.147]   .. ..$ : int 0
[13:35:22.147]   .. ..$ : int 1
[13:35:22.147]  $ ...future.seeds_ii       : NULL
[13:35:22.147]  $ ...future.globals.maxSize: NULL
[13:35:22.147]  - attr(*, "where")=List of 5
[13:35:22.147]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:22.147]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:35:22.147]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:22.147]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:22.147]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:22.147]  - attr(*, "resolved")= logi FALSE
[13:35:22.147]  - attr(*, "total_size")= num 6480
[13:35:22.147]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:22.147]  - attr(*, "already-done")= logi TRUE
[13:35:22.153] - reassign environment for ‘...future.FUN’
[13:35:22.153] - copied ‘...future.FUN’ to environment
[13:35:22.153] - copied ‘MoreArgs’ to environment
[13:35:22.153] - copied ‘...future.elements_ii’ to environment
[13:35:22.154] - copied ‘...future.seeds_ii’ to environment
[13:35:22.154] - copied ‘...future.globals.maxSize’ to environment
[13:35:22.154] assign_globals() ... done
[13:35:22.154] plan(): Setting new future strategy stack:
[13:35:22.154] List of future strategies:
[13:35:22.154] 1. sequential:
[13:35:22.154]    - args: function (..., envir = parent.frame())
[13:35:22.154]    - tweaked: FALSE
[13:35:22.154]    - call: NULL
[13:35:22.154] plan(): nbrOfWorkers() = 1
[13:35:22.656] plan(): Setting new future strategy stack:
[13:35:22.656] List of future strategies:
[13:35:22.656] 1. sequential:
[13:35:22.656]    - args: function (..., envir = parent.frame())
[13:35:22.656]    - tweaked: FALSE
[13:35:22.656]    - call: plan(strategy)
[13:35:22.657] plan(): nbrOfWorkers() = 1
[13:35:22.657] SequentialFuture started (and completed)
[13:35:22.657] - Launch lazy future ... done
[13:35:22.657] run() for ‘SequentialFuture’ ... done
[13:35:22.657] Created future:
[13:35:22.657] SequentialFuture:
[13:35:22.657] Label: ‘future_mapply-1’
[13:35:22.657] Expression:
[13:35:22.657] {
[13:35:22.657]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:22.657]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:22.657]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:22.657]         on.exit(options(oopts), add = TRUE)
[13:35:22.657]     }
[13:35:22.657]     {
[13:35:22.657]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:22.657]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:35:22.657]         do.call(mapply, args = args)
[13:35:22.657]     }
[13:35:22.657] }
[13:35:22.657] Lazy evaluation: FALSE
[13:35:22.657] Asynchronous evaluation: FALSE
[13:35:22.657] Local evaluation: TRUE
[13:35:22.657] Environment: R_GlobalEnv
[13:35:22.657] Capture standard output: TRUE
[13:35:22.657] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:22.657] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:22.657] Packages: <none>
[13:35:22.657] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:22.657] Resolved: TRUE
[13:35:22.657] Value: 224 bytes of class ‘list’
[13:35:22.657] Early signaling: FALSE
[13:35:22.657] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:22.657] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:22.658] Chunk #1 of 1 ... DONE
[13:35:22.659] Launching 1 futures (chunks) ... DONE
[13:35:22.659] Resolving 1 futures (chunks) ...
[13:35:22.659] resolve() on list ...
[13:35:22.659]  recursive: 0
[13:35:22.659]  length: 1
[13:35:22.659] 
[13:35:22.659] resolved() for ‘SequentialFuture’ ...
[13:35:22.659] - state: ‘finished’
[13:35:22.659] - run: TRUE
[13:35:22.659] - result: ‘FutureResult’
[13:35:22.660] resolved() for ‘SequentialFuture’ ... done
[13:35:22.660] Future #1
[13:35:22.660] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:22.660] - nx: 1
[13:35:22.660] - relay: TRUE
[13:35:22.660] - stdout: TRUE
[13:35:22.660] - signal: TRUE
[13:35:22.660] - resignal: FALSE
[13:35:22.660] - force: TRUE
[13:35:22.660] - relayed: [n=1] FALSE
[13:35:22.660] - queued futures: [n=1] FALSE
[13:35:22.661]  - until=1
[13:35:22.661]  - relaying element #1
[13:35:22.661] - relayed: [n=1] TRUE
[13:35:22.661] - queued futures: [n=1] TRUE
[13:35:22.661] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:22.661]  length: 0 (resolved future 1)
[13:35:22.661] Relaying remaining futures
[13:35:22.661] signalConditionsASAP(NULL, pos=0) ...
[13:35:22.662] - nx: 1
[13:35:22.662] - relay: TRUE
[13:35:22.662] - stdout: TRUE
[13:35:22.662] - signal: TRUE
[13:35:22.662] - resignal: FALSE
[13:35:22.662] - force: TRUE
[13:35:22.662] - relayed: [n=1] TRUE
[13:35:22.662] - queued futures: [n=1] TRUE
 - flush all
[13:35:22.662] - relayed: [n=1] TRUE
[13:35:22.662] - queued futures: [n=1] TRUE
[13:35:22.662] signalConditionsASAP(NULL, pos=0) ... done
[13:35:22.663] resolve() on list ... DONE
[13:35:22.663]  - Number of value chunks collected: 1
[13:35:22.663] Resolving 1 futures (chunks) ... DONE
[13:35:22.663] Reducing values from 1 chunks ...
[13:35:22.663]  - Number of values collected after concatenation: 2
[13:35:22.663]  - Number of values expected: 2
[13:35:22.663] Reducing values from 1 chunks ... DONE
[13:35:22.663] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[13:35:22.664] future_mapply() ...
[13:35:22.664] Number of chunks: 1
[13:35:22.664] getGlobalsAndPackagesXApply() ...
[13:35:22.664]  - future.globals: TRUE
[13:35:22.664] getGlobalsAndPackages() ...
[13:35:22.664] Searching for globals...
[13:35:22.666] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:35:22.666] Searching for globals ... DONE
[13:35:22.666] Resolving globals: FALSE
[13:35:22.666] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:35:22.667] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:35:22.667] - globals: [1] ‘FUN’
[13:35:22.667] 
[13:35:22.667] getGlobalsAndPackages() ... DONE
[13:35:22.667]  - globals found/used: [n=1] ‘FUN’
[13:35:22.667]  - needed namespaces: [n=0] 
[13:35:22.667] Finding globals ... DONE
[13:35:22.668] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:35:22.668] List of 2
[13:35:22.668]  $ ...future.FUN:function (x, y)  
[13:35:22.668]  $ MoreArgs     : NULL
[13:35:22.668]  - attr(*, "where")=List of 2
[13:35:22.668]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:22.668]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:35:22.668]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:22.668]  - attr(*, "resolved")= logi FALSE
[13:35:22.668]  - attr(*, "total_size")= num NA
[13:35:22.670] Packages to be attached in all futures: [n=0] 
[13:35:22.670] getGlobalsAndPackagesXApply() ... DONE
[13:35:22.670] Number of futures (= number of chunks): 1
[13:35:22.671] Launching 1 futures (chunks) ...
[13:35:22.671] Chunk #1 of 1 ...
[13:35:22.671]  - Finding globals in '...' for chunk #1 ...
[13:35:22.671] getGlobalsAndPackages() ...
[13:35:22.671] Searching for globals...
[13:35:22.671] 
[13:35:22.671] Searching for globals ... DONE
[13:35:22.672] - globals: [0] <none>
[13:35:22.672] getGlobalsAndPackages() ... DONE
[13:35:22.672]    + additional globals found: [n=0] 
[13:35:22.672]    + additional namespaces needed: [n=0] 
[13:35:22.672]  - Finding globals in '...' for chunk #1 ... DONE
[13:35:22.672]  - seeds: <none>
[13:35:22.672]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:22.672] getGlobalsAndPackages() ...
[13:35:22.672] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:22.672] Resolving globals: FALSE
[13:35:22.673] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:35:22.673] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:35:22.673] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:22.673] 
[13:35:22.674] getGlobalsAndPackages() ... DONE
[13:35:22.674] run() for ‘Future’ ...
[13:35:22.674] - state: ‘created’
[13:35:22.674] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:35:22.674] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:22.674] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:22.675]   - Field: ‘label’
[13:35:22.675]   - Field: ‘local’
[13:35:22.675]   - Field: ‘owner’
[13:35:22.675]   - Field: ‘envir’
[13:35:22.675]   - Field: ‘packages’
[13:35:22.675]   - Field: ‘gc’
[13:35:22.675]   - Field: ‘conditions’
[13:35:22.675]   - Field: ‘expr’
[13:35:22.675]   - Field: ‘uuid’
[13:35:22.675]   - Field: ‘seed’
[13:35:22.676]   - Field: ‘version’
[13:35:22.676]   - Field: ‘result’
[13:35:22.676]   - Field: ‘asynchronous’
[13:35:22.676]   - Field: ‘calls’
[13:35:22.676]   - Field: ‘globals’
[13:35:22.676]   - Field: ‘stdout’
[13:35:22.676]   - Field: ‘earlySignal’
[13:35:22.676]   - Field: ‘lazy’
[13:35:22.676]   - Field: ‘state’
[13:35:22.676] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:22.676] - Launch lazy future ...
[13:35:22.678] Packages needed by the future expression (n = 0): <none>
[13:35:22.678] Packages needed by future strategies (n = 0): <none>
[13:35:22.679] {
[13:35:22.679]     {
[13:35:22.679]         {
[13:35:22.679]             ...future.startTime <- base::Sys.time()
[13:35:22.679]             {
[13:35:22.679]                 {
[13:35:22.679]                   {
[13:35:22.679]                     base::local({
[13:35:22.679]                       has_future <- base::requireNamespace("future", 
[13:35:22.679]                         quietly = TRUE)
[13:35:22.679]                       if (has_future) {
[13:35:22.679]                         ns <- base::getNamespace("future")
[13:35:22.679]                         version <- ns[[".package"]][["version"]]
[13:35:22.679]                         if (is.null(version)) 
[13:35:22.679]                           version <- utils::packageVersion("future")
[13:35:22.679]                       }
[13:35:22.679]                       else {
[13:35:22.679]                         version <- NULL
[13:35:22.679]                       }
[13:35:22.679]                       if (!has_future || version < "1.8.0") {
[13:35:22.679]                         info <- base::c(r_version = base::gsub("R version ", 
[13:35:22.679]                           "", base::R.version$version.string), 
[13:35:22.679]                           platform = base::sprintf("%s (%s-bit)", 
[13:35:22.679]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:22.679]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:22.679]                             "release", "version")], collapse = " "), 
[13:35:22.679]                           hostname = base::Sys.info()[["nodename"]])
[13:35:22.679]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:35:22.679]                           info)
[13:35:22.679]                         info <- base::paste(info, collapse = "; ")
[13:35:22.679]                         if (!has_future) {
[13:35:22.679]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:22.679]                             info)
[13:35:22.679]                         }
[13:35:22.679]                         else {
[13:35:22.679]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:22.679]                             info, version)
[13:35:22.679]                         }
[13:35:22.679]                         base::stop(msg)
[13:35:22.679]                       }
[13:35:22.679]                     })
[13:35:22.679]                   }
[13:35:22.679]                   ...future.strategy.old <- future::plan("list")
[13:35:22.679]                   options(future.plan = NULL)
[13:35:22.679]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:22.679]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:22.679]                 }
[13:35:22.679]                 ...future.workdir <- getwd()
[13:35:22.679]             }
[13:35:22.679]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:22.679]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:22.679]         }
[13:35:22.679]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:22.679]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:22.679]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:22.679]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:22.679]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:22.679]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:22.679]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:22.679]             base::names(...future.oldOptions))
[13:35:22.679]     }
[13:35:22.679]     if (TRUE) {
[13:35:22.679]     }
[13:35:22.679]     else {
[13:35:22.679]         if (NA) {
[13:35:22.679]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:22.679]                 open = "w")
[13:35:22.679]         }
[13:35:22.679]         else {
[13:35:22.679]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:22.679]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:22.679]         }
[13:35:22.679]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:22.679]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:22.679]             base::sink(type = "output", split = FALSE)
[13:35:22.679]             base::close(...future.stdout)
[13:35:22.679]         }, add = TRUE)
[13:35:22.679]     }
[13:35:22.679]     ...future.frame <- base::sys.nframe()
[13:35:22.679]     ...future.conditions <- base::list()
[13:35:22.679]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:22.679]     if (FALSE) {
[13:35:22.679]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:22.679]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:22.679]     }
[13:35:22.679]     ...future.result <- base::tryCatch({
[13:35:22.679]         base::withCallingHandlers({
[13:35:22.679]             ...future.value <- base::withVisible(base::local({
[13:35:22.679]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:22.679]                 if (!identical(...future.globals.maxSize.org, 
[13:35:22.679]                   ...future.globals.maxSize)) {
[13:35:22.679]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:22.679]                   on.exit(options(oopts), add = TRUE)
[13:35:22.679]                 }
[13:35:22.679]                 {
[13:35:22.679]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:22.679]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:35:22.679]                     USE.NAMES = FALSE)
[13:35:22.679]                   do.call(mapply, args = args)
[13:35:22.679]                 }
[13:35:22.679]             }))
[13:35:22.679]             future::FutureResult(value = ...future.value$value, 
[13:35:22.679]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:22.679]                   ...future.rng), globalenv = if (FALSE) 
[13:35:22.679]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:22.679]                     ...future.globalenv.names))
[13:35:22.679]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:22.679]         }, condition = base::local({
[13:35:22.679]             c <- base::c
[13:35:22.679]             inherits <- base::inherits
[13:35:22.679]             invokeRestart <- base::invokeRestart
[13:35:22.679]             length <- base::length
[13:35:22.679]             list <- base::list
[13:35:22.679]             seq.int <- base::seq.int
[13:35:22.679]             signalCondition <- base::signalCondition
[13:35:22.679]             sys.calls <- base::sys.calls
[13:35:22.679]             `[[` <- base::`[[`
[13:35:22.679]             `+` <- base::`+`
[13:35:22.679]             `<<-` <- base::`<<-`
[13:35:22.679]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:22.679]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:22.679]                   3L)]
[13:35:22.679]             }
[13:35:22.679]             function(cond) {
[13:35:22.679]                 is_error <- inherits(cond, "error")
[13:35:22.679]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:22.679]                   NULL)
[13:35:22.679]                 if (is_error) {
[13:35:22.679]                   sessionInformation <- function() {
[13:35:22.679]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:22.679]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:22.679]                       search = base::search(), system = base::Sys.info())
[13:35:22.679]                   }
[13:35:22.679]                   ...future.conditions[[length(...future.conditions) + 
[13:35:22.679]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:22.679]                     cond$call), session = sessionInformation(), 
[13:35:22.679]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:22.679]                   signalCondition(cond)
[13:35:22.679]                 }
[13:35:22.679]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:22.679]                 "immediateCondition"))) {
[13:35:22.679]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:22.679]                   ...future.conditions[[length(...future.conditions) + 
[13:35:22.679]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:22.679]                   if (TRUE && !signal) {
[13:35:22.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:22.679]                     {
[13:35:22.679]                       inherits <- base::inherits
[13:35:22.679]                       invokeRestart <- base::invokeRestart
[13:35:22.679]                       is.null <- base::is.null
[13:35:22.679]                       muffled <- FALSE
[13:35:22.679]                       if (inherits(cond, "message")) {
[13:35:22.679]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:22.679]                         if (muffled) 
[13:35:22.679]                           invokeRestart("muffleMessage")
[13:35:22.679]                       }
[13:35:22.679]                       else if (inherits(cond, "warning")) {
[13:35:22.679]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:22.679]                         if (muffled) 
[13:35:22.679]                           invokeRestart("muffleWarning")
[13:35:22.679]                       }
[13:35:22.679]                       else if (inherits(cond, "condition")) {
[13:35:22.679]                         if (!is.null(pattern)) {
[13:35:22.679]                           computeRestarts <- base::computeRestarts
[13:35:22.679]                           grepl <- base::grepl
[13:35:22.679]                           restarts <- computeRestarts(cond)
[13:35:22.679]                           for (restart in restarts) {
[13:35:22.679]                             name <- restart$name
[13:35:22.679]                             if (is.null(name)) 
[13:35:22.679]                               next
[13:35:22.679]                             if (!grepl(pattern, name)) 
[13:35:22.679]                               next
[13:35:22.679]                             invokeRestart(restart)
[13:35:22.679]                             muffled <- TRUE
[13:35:22.679]                             break
[13:35:22.679]                           }
[13:35:22.679]                         }
[13:35:22.679]                       }
[13:35:22.679]                       invisible(muffled)
[13:35:22.679]                     }
[13:35:22.679]                     muffleCondition(cond, pattern = "^muffle")
[13:35:22.679]                   }
[13:35:22.679]                 }
[13:35:22.679]                 else {
[13:35:22.679]                   if (TRUE) {
[13:35:22.679]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:22.679]                     {
[13:35:22.679]                       inherits <- base::inherits
[13:35:22.679]                       invokeRestart <- base::invokeRestart
[13:35:22.679]                       is.null <- base::is.null
[13:35:22.679]                       muffled <- FALSE
[13:35:22.679]                       if (inherits(cond, "message")) {
[13:35:22.679]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:22.679]                         if (muffled) 
[13:35:22.679]                           invokeRestart("muffleMessage")
[13:35:22.679]                       }
[13:35:22.679]                       else if (inherits(cond, "warning")) {
[13:35:22.679]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:22.679]                         if (muffled) 
[13:35:22.679]                           invokeRestart("muffleWarning")
[13:35:22.679]                       }
[13:35:22.679]                       else if (inherits(cond, "condition")) {
[13:35:22.679]                         if (!is.null(pattern)) {
[13:35:22.679]                           computeRestarts <- base::computeRestarts
[13:35:22.679]                           grepl <- base::grepl
[13:35:22.679]                           restarts <- computeRestarts(cond)
[13:35:22.679]                           for (restart in restarts) {
[13:35:22.679]                             name <- restart$name
[13:35:22.679]                             if (is.null(name)) 
[13:35:22.679]                               next
[13:35:22.679]                             if (!grepl(pattern, name)) 
[13:35:22.679]                               next
[13:35:22.679]                             invokeRestart(restart)
[13:35:22.679]                             muffled <- TRUE
[13:35:22.679]                             break
[13:35:22.679]                           }
[13:35:22.679]                         }
[13:35:22.679]                       }
[13:35:22.679]                       invisible(muffled)
[13:35:22.679]                     }
[13:35:22.679]                     muffleCondition(cond, pattern = "^muffle")
[13:35:22.679]                   }
[13:35:22.679]                 }
[13:35:22.679]             }
[13:35:22.679]         }))
[13:35:22.679]     }, error = function(ex) {
[13:35:22.679]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:22.679]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:22.679]                 ...future.rng), started = ...future.startTime, 
[13:35:22.679]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:22.679]             version = "1.8"), class = "FutureResult")
[13:35:22.679]     }, finally = {
[13:35:22.679]         if (!identical(...future.workdir, getwd())) 
[13:35:22.679]             setwd(...future.workdir)
[13:35:22.679]         {
[13:35:22.679]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:22.679]                 ...future.oldOptions$nwarnings <- NULL
[13:35:22.679]             }
[13:35:22.679]             base::options(...future.oldOptions)
[13:35:22.679]             if (.Platform$OS.type == "windows") {
[13:35:22.679]                 old_names <- names(...future.oldEnvVars)
[13:35:22.679]                 envs <- base::Sys.getenv()
[13:35:22.679]                 names <- names(envs)
[13:35:22.679]                 common <- intersect(names, old_names)
[13:35:22.679]                 added <- setdiff(names, old_names)
[13:35:22.679]                 removed <- setdiff(old_names, names)
[13:35:22.679]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:22.679]                   envs[common]]
[13:35:22.679]                 NAMES <- toupper(changed)
[13:35:22.679]                 args <- list()
[13:35:22.679]                 for (kk in seq_along(NAMES)) {
[13:35:22.679]                   name <- changed[[kk]]
[13:35:22.679]                   NAME <- NAMES[[kk]]
[13:35:22.679]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:22.679]                     next
[13:35:22.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:22.679]                 }
[13:35:22.679]                 NAMES <- toupper(added)
[13:35:22.679]                 for (kk in seq_along(NAMES)) {
[13:35:22.679]                   name <- added[[kk]]
[13:35:22.679]                   NAME <- NAMES[[kk]]
[13:35:22.679]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:22.679]                     next
[13:35:22.679]                   args[[name]] <- ""
[13:35:22.679]                 }
[13:35:22.679]                 NAMES <- toupper(removed)
[13:35:22.679]                 for (kk in seq_along(NAMES)) {
[13:35:22.679]                   name <- removed[[kk]]
[13:35:22.679]                   NAME <- NAMES[[kk]]
[13:35:22.679]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:22.679]                     next
[13:35:22.679]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:22.679]                 }
[13:35:22.679]                 if (length(args) > 0) 
[13:35:22.679]                   base::do.call(base::Sys.setenv, args = args)
[13:35:22.679]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:22.679]             }
[13:35:22.679]             else {
[13:35:22.679]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:22.679]             }
[13:35:22.679]             {
[13:35:22.679]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:22.679]                   0L) {
[13:35:22.679]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:22.679]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:22.679]                   base::options(opts)
[13:35:22.679]                 }
[13:35:22.679]                 {
[13:35:22.679]                   {
[13:35:22.679]                     NULL
[13:35:22.679]                     RNGkind("Mersenne-Twister")
[13:35:22.679]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:22.679]                       inherits = FALSE)
[13:35:22.679]                   }
[13:35:22.679]                   options(future.plan = NULL)
[13:35:22.679]                   if (is.na(NA_character_)) 
[13:35:22.679]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:22.679]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:22.679]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:22.679]                     .init = FALSE)
[13:35:22.679]                 }
[13:35:22.679]             }
[13:35:22.679]         }
[13:35:22.679]     })
[13:35:22.679]     if (FALSE) {
[13:35:22.679]         base::sink(type = "output", split = FALSE)
[13:35:22.679]         if (NA) {
[13:35:22.679]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:22.679]         }
[13:35:22.679]         else {
[13:35:22.679]             ...future.result["stdout"] <- base::list(NULL)
[13:35:22.679]         }
[13:35:22.679]         base::close(...future.stdout)
[13:35:22.679]         ...future.stdout <- NULL
[13:35:22.679]     }
[13:35:22.679]     ...future.result$conditions <- ...future.conditions
[13:35:22.679]     ...future.result$finished <- base::Sys.time()
[13:35:22.679]     ...future.result
[13:35:22.679] }
[13:35:22.681] assign_globals() ...
[13:35:22.681] List of 5
[13:35:22.681]  $ ...future.FUN            :function (x, y)  
[13:35:22.681]  $ MoreArgs                 : NULL
[13:35:22.681]  $ ...future.elements_ii    :List of 2
[13:35:22.681]   ..$ :List of 2
[13:35:22.681]   .. ..$ : int 1
[13:35:22.681]   .. ..$ : int 0
[13:35:22.681]   ..$ :List of 2
[13:35:22.681]   .. ..$ : int 0
[13:35:22.681]   .. ..$ : int 1
[13:35:22.681]  $ ...future.seeds_ii       : NULL
[13:35:22.681]  $ ...future.globals.maxSize: NULL
[13:35:22.681]  - attr(*, "where")=List of 5
[13:35:22.681]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:22.681]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:35:22.681]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:22.681]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:22.681]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:22.681]  - attr(*, "resolved")= logi FALSE
[13:35:22.681]  - attr(*, "total_size")= num 6480
[13:35:22.681]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:22.681]  - attr(*, "already-done")= logi TRUE
[13:35:22.686] - reassign environment for ‘...future.FUN’
[13:35:22.686] - copied ‘...future.FUN’ to environment
[13:35:22.686] - copied ‘MoreArgs’ to environment
[13:35:22.686] - copied ‘...future.elements_ii’ to environment
[13:35:22.686] - copied ‘...future.seeds_ii’ to environment
[13:35:22.687] - copied ‘...future.globals.maxSize’ to environment
[13:35:22.687] assign_globals() ... done
[13:35:22.687] plan(): Setting new future strategy stack:
[13:35:22.687] List of future strategies:
[13:35:22.687] 1. sequential:
[13:35:22.687]    - args: function (..., envir = parent.frame())
[13:35:22.687]    - tweaked: FALSE
[13:35:22.687]    - call: NULL
[13:35:22.687] plan(): nbrOfWorkers() = 1
[13:35:23.189] plan(): Setting new future strategy stack:
[13:35:23.189] List of future strategies:
[13:35:23.189] 1. sequential:
[13:35:23.189]    - args: function (..., envir = parent.frame())
[13:35:23.189]    - tweaked: FALSE
[13:35:23.189]    - call: plan(strategy)
[13:35:23.189] plan(): nbrOfWorkers() = 1
[13:35:23.190] SequentialFuture started (and completed)
[13:35:23.190] - Launch lazy future ... done
[13:35:23.190] run() for ‘SequentialFuture’ ... done
[13:35:23.190] Created future:
[13:35:23.190] SequentialFuture:
[13:35:23.190] Label: ‘future_mapply-1’
[13:35:23.190] Expression:
[13:35:23.190] {
[13:35:23.190]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:23.190]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:23.190]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:23.190]         on.exit(options(oopts), add = TRUE)
[13:35:23.190]     }
[13:35:23.190]     {
[13:35:23.190]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:23.190]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:35:23.190]         do.call(mapply, args = args)
[13:35:23.190]     }
[13:35:23.190] }
[13:35:23.190] Lazy evaluation: FALSE
[13:35:23.190] Asynchronous evaluation: FALSE
[13:35:23.190] Local evaluation: TRUE
[13:35:23.190] Environment: R_GlobalEnv
[13:35:23.190] Capture standard output: NA
[13:35:23.190] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:23.190] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:23.190] Packages: <none>
[13:35:23.190] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:23.190] Resolved: TRUE
[13:35:23.190] Value: 224 bytes of class ‘list’
[13:35:23.190] Early signaling: FALSE
[13:35:23.190] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:23.190] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:23.191] Chunk #1 of 1 ... DONE
[13:35:23.191] Launching 1 futures (chunks) ... DONE
[13:35:23.191] Resolving 1 futures (chunks) ...
[13:35:23.191] resolve() on list ...
[13:35:23.191]  recursive: 0
[13:35:23.191]  length: 1
[13:35:23.192] 
[13:35:23.192] resolved() for ‘SequentialFuture’ ...
[13:35:23.192] - state: ‘finished’
[13:35:23.192] - run: TRUE
[13:35:23.192] - result: ‘FutureResult’
[13:35:23.192] resolved() for ‘SequentialFuture’ ... done
[13:35:23.192] Future #1
[13:35:23.192] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:23.192] - nx: 1
[13:35:23.192] - relay: TRUE
[13:35:23.193] - stdout: TRUE
[13:35:23.193] - signal: TRUE
[13:35:23.193] - resignal: FALSE
[13:35:23.193] - force: TRUE
[13:35:23.193] - relayed: [n=1] FALSE
[13:35:23.193] - queued futures: [n=1] FALSE
[13:35:23.193]  - until=1
[13:35:23.193]  - relaying element #1
[13:35:23.193] - relayed: [n=1] TRUE
[13:35:23.193] - queued futures: [n=1] TRUE
[13:35:23.193] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:23.194]  length: 0 (resolved future 1)
[13:35:23.194] Relaying remaining futures
[13:35:23.194] signalConditionsASAP(NULL, pos=0) ...
[13:35:23.194] - nx: 1
[13:35:23.194] - relay: TRUE
[13:35:23.194] - stdout: TRUE
[13:35:23.194] - signal: TRUE
[13:35:23.194] - resignal: FALSE
[13:35:23.194] - force: TRUE
[13:35:23.194] - relayed: [n=1] TRUE
[13:35:23.194] - queued futures: [n=1] TRUE
 - flush all
[13:35:23.195] - relayed: [n=1] TRUE
[13:35:23.195] - queued futures: [n=1] TRUE
[13:35:23.195] signalConditionsASAP(NULL, pos=0) ... done
[13:35:23.195] resolve() on list ... DONE
[13:35:23.195]  - Number of value chunks collected: 1
[13:35:23.195] Resolving 1 futures (chunks) ... DONE
[13:35:23.195] Reducing values from 1 chunks ...
[13:35:23.195]  - Number of values collected after concatenation: 2
[13:35:23.195]  - Number of values expected: 2
[13:35:23.195] Reducing values from 1 chunks ... DONE
[13:35:23.195] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('sequential') ... DONE
* plan('multicore') ...
[13:35:23.196] plan(): Setting new future strategy stack:
[13:35:23.196] List of future strategies:
[13:35:23.196] 1. multicore:
[13:35:23.196]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:23.196]    - tweaked: FALSE
[13:35:23.196]    - call: plan(strategy)
[13:35:23.200] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[13:35:23.200] future_lapply() ...
[13:35:23.204] Number of chunks: 1
[13:35:23.204] getGlobalsAndPackagesXApply() ...
[13:35:23.204]  - future.globals: TRUE
[13:35:23.204] getGlobalsAndPackages() ...
[13:35:23.205] Searching for globals...
[13:35:23.206] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:35:23.206] Searching for globals ... DONE
[13:35:23.206] Resolving globals: FALSE
[13:35:23.207] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:35:23.207] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:35:23.207] - globals: [1] ‘FUN’
[13:35:23.207] 
[13:35:23.207] getGlobalsAndPackages() ... DONE
[13:35:23.209]  - globals found/used: [n=1] ‘FUN’
[13:35:23.209]  - needed namespaces: [n=0] 
[13:35:23.209] Finding globals ... DONE
[13:35:23.209]  - use_args: TRUE
[13:35:23.209]  - Getting '...' globals ...
[13:35:23.210] resolve() on list ...
[13:35:23.210]  recursive: 0
[13:35:23.210]  length: 1
[13:35:23.210]  elements: ‘...’
[13:35:23.210]  length: 0 (resolved future 1)
[13:35:23.210] resolve() on list ... DONE
[13:35:23.210]    - '...' content: [n=0] 
[13:35:23.210] List of 1
[13:35:23.210]  $ ...: list()
[13:35:23.210]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:23.210]  - attr(*, "where")=List of 1
[13:35:23.210]   ..$ ...:<environment: 0x558d38766078> 
[13:35:23.210]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:23.210]  - attr(*, "resolved")= logi TRUE
[13:35:23.210]  - attr(*, "total_size")= num NA
[13:35:23.213]  - Getting '...' globals ... DONE
[13:35:23.213] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:35:23.213] List of 2
[13:35:23.213]  $ ...future.FUN:function (x)  
[13:35:23.213]  $ ...          : list()
[13:35:23.213]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:23.213]  - attr(*, "where")=List of 2
[13:35:23.213]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:23.213]   ..$ ...          :<environment: 0x558d38766078> 
[13:35:23.213]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:23.213]  - attr(*, "resolved")= logi FALSE
[13:35:23.213]  - attr(*, "total_size")= num 4720
[13:35:23.216] Packages to be attached in all futures: [n=0] 
[13:35:23.216] getGlobalsAndPackagesXApply() ... DONE
[13:35:23.216] Number of futures (= number of chunks): 1
[13:35:23.216] Launching 1 futures (chunks) ...
[13:35:23.216] Chunk #1 of 1 ...
[13:35:23.217]  - Finding globals in 'X' for chunk #1 ...
[13:35:23.217] getGlobalsAndPackages() ...
[13:35:23.217] Searching for globals...
[13:35:23.217] 
[13:35:23.217] Searching for globals ... DONE
[13:35:23.217] - globals: [0] <none>
[13:35:23.217] getGlobalsAndPackages() ... DONE
[13:35:23.217]    + additional globals found: [n=0] 
[13:35:23.217]    + additional namespaces needed: [n=0] 
[13:35:23.218]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:23.218]  - seeds: <none>
[13:35:23.218]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:23.218] getGlobalsAndPackages() ...
[13:35:23.218] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:23.218] Resolving globals: FALSE
[13:35:23.218] Tweak future expression to call with '...' arguments ...
[13:35:23.218] {
[13:35:23.218]     do.call(function(...) {
[13:35:23.218]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:23.218]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:23.218]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:23.218]             on.exit(options(oopts), add = TRUE)
[13:35:23.218]         }
[13:35:23.218]         {
[13:35:23.218]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:23.218]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:23.218]                 ...future.FUN(...future.X_jj, ...)
[13:35:23.218]             })
[13:35:23.218]         }
[13:35:23.218]     }, args = future.call.arguments)
[13:35:23.218] }
[13:35:23.219] Tweak future expression to call with '...' arguments ... DONE
[13:35:23.219] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:23.219] 
[13:35:23.219] getGlobalsAndPackages() ... DONE
[13:35:23.219] run() for ‘Future’ ...
[13:35:23.219] - state: ‘created’
[13:35:23.220] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:23.223] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:23.223] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:23.223]   - Field: ‘label’
[13:35:23.223]   - Field: ‘local’
[13:35:23.224]   - Field: ‘owner’
[13:35:23.224]   - Field: ‘envir’
[13:35:23.224]   - Field: ‘packages’
[13:35:23.224]   - Field: ‘gc’
[13:35:23.224]   - Field: ‘conditions’
[13:35:23.224]   - Field: ‘expr’
[13:35:23.224]   - Field: ‘uuid’
[13:35:23.224]   - Field: ‘seed’
[13:35:23.224]   - Field: ‘version’
[13:35:23.224]   - Field: ‘result’
[13:35:23.224]   - Field: ‘asynchronous’
[13:35:23.225]   - Field: ‘calls’
[13:35:23.225]   - Field: ‘globals’
[13:35:23.225]   - Field: ‘stdout’
[13:35:23.225]   - Field: ‘earlySignal’
[13:35:23.225]   - Field: ‘lazy’
[13:35:23.225]   - Field: ‘state’
[13:35:23.225] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:23.225] - Launch lazy future ...
[13:35:23.225] Packages needed by the future expression (n = 0): <none>
[13:35:23.225] Packages needed by future strategies (n = 0): <none>
[13:35:23.226] {
[13:35:23.226]     {
[13:35:23.226]         {
[13:35:23.226]             ...future.startTime <- base::Sys.time()
[13:35:23.226]             {
[13:35:23.226]                 {
[13:35:23.226]                   {
[13:35:23.226]                     base::local({
[13:35:23.226]                       has_future <- base::requireNamespace("future", 
[13:35:23.226]                         quietly = TRUE)
[13:35:23.226]                       if (has_future) {
[13:35:23.226]                         ns <- base::getNamespace("future")
[13:35:23.226]                         version <- ns[[".package"]][["version"]]
[13:35:23.226]                         if (is.null(version)) 
[13:35:23.226]                           version <- utils::packageVersion("future")
[13:35:23.226]                       }
[13:35:23.226]                       else {
[13:35:23.226]                         version <- NULL
[13:35:23.226]                       }
[13:35:23.226]                       if (!has_future || version < "1.8.0") {
[13:35:23.226]                         info <- base::c(r_version = base::gsub("R version ", 
[13:35:23.226]                           "", base::R.version$version.string), 
[13:35:23.226]                           platform = base::sprintf("%s (%s-bit)", 
[13:35:23.226]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:23.226]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:23.226]                             "release", "version")], collapse = " "), 
[13:35:23.226]                           hostname = base::Sys.info()[["nodename"]])
[13:35:23.226]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:35:23.226]                           info)
[13:35:23.226]                         info <- base::paste(info, collapse = "; ")
[13:35:23.226]                         if (!has_future) {
[13:35:23.226]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:23.226]                             info)
[13:35:23.226]                         }
[13:35:23.226]                         else {
[13:35:23.226]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:23.226]                             info, version)
[13:35:23.226]                         }
[13:35:23.226]                         base::stop(msg)
[13:35:23.226]                       }
[13:35:23.226]                     })
[13:35:23.226]                   }
[13:35:23.226]                   ...future.strategy.old <- future::plan("list")
[13:35:23.226]                   options(future.plan = NULL)
[13:35:23.226]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:23.226]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:23.226]                 }
[13:35:23.226]                 ...future.workdir <- getwd()
[13:35:23.226]             }
[13:35:23.226]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:23.226]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:23.226]         }
[13:35:23.226]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:23.226]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:23.226]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:23.226]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:23.226]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:23.226]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:23.226]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:23.226]             base::names(...future.oldOptions))
[13:35:23.226]     }
[13:35:23.226]     if (FALSE) {
[13:35:23.226]     }
[13:35:23.226]     else {
[13:35:23.226]         if (FALSE) {
[13:35:23.226]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:23.226]                 open = "w")
[13:35:23.226]         }
[13:35:23.226]         else {
[13:35:23.226]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:23.226]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:23.226]         }
[13:35:23.226]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:23.226]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:23.226]             base::sink(type = "output", split = FALSE)
[13:35:23.226]             base::close(...future.stdout)
[13:35:23.226]         }, add = TRUE)
[13:35:23.226]     }
[13:35:23.226]     ...future.frame <- base::sys.nframe()
[13:35:23.226]     ...future.conditions <- base::list()
[13:35:23.226]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:23.226]     if (FALSE) {
[13:35:23.226]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:23.226]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:23.226]     }
[13:35:23.226]     ...future.result <- base::tryCatch({
[13:35:23.226]         base::withCallingHandlers({
[13:35:23.226]             ...future.value <- base::withVisible(base::local({
[13:35:23.226]                 do.call(function(...) {
[13:35:23.226]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:23.226]                   if (!identical(...future.globals.maxSize.org, 
[13:35:23.226]                     ...future.globals.maxSize)) {
[13:35:23.226]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:23.226]                     on.exit(options(oopts), add = TRUE)
[13:35:23.226]                   }
[13:35:23.226]                   {
[13:35:23.226]                     lapply(seq_along(...future.elements_ii), 
[13:35:23.226]                       FUN = function(jj) {
[13:35:23.226]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:23.226]                         ...future.FUN(...future.X_jj, ...)
[13:35:23.226]                       })
[13:35:23.226]                   }
[13:35:23.226]                 }, args = future.call.arguments)
[13:35:23.226]             }))
[13:35:23.226]             future::FutureResult(value = ...future.value$value, 
[13:35:23.226]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:23.226]                   ...future.rng), globalenv = if (FALSE) 
[13:35:23.226]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:23.226]                     ...future.globalenv.names))
[13:35:23.226]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:23.226]         }, condition = base::local({
[13:35:23.226]             c <- base::c
[13:35:23.226]             inherits <- base::inherits
[13:35:23.226]             invokeRestart <- base::invokeRestart
[13:35:23.226]             length <- base::length
[13:35:23.226]             list <- base::list
[13:35:23.226]             seq.int <- base::seq.int
[13:35:23.226]             signalCondition <- base::signalCondition
[13:35:23.226]             sys.calls <- base::sys.calls
[13:35:23.226]             `[[` <- base::`[[`
[13:35:23.226]             `+` <- base::`+`
[13:35:23.226]             `<<-` <- base::`<<-`
[13:35:23.226]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:23.226]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:23.226]                   3L)]
[13:35:23.226]             }
[13:35:23.226]             function(cond) {
[13:35:23.226]                 is_error <- inherits(cond, "error")
[13:35:23.226]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:23.226]                   NULL)
[13:35:23.226]                 if (is_error) {
[13:35:23.226]                   sessionInformation <- function() {
[13:35:23.226]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:23.226]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:23.226]                       search = base::search(), system = base::Sys.info())
[13:35:23.226]                   }
[13:35:23.226]                   ...future.conditions[[length(...future.conditions) + 
[13:35:23.226]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:23.226]                     cond$call), session = sessionInformation(), 
[13:35:23.226]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:23.226]                   signalCondition(cond)
[13:35:23.226]                 }
[13:35:23.226]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:23.226]                 "immediateCondition"))) {
[13:35:23.226]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:23.226]                   ...future.conditions[[length(...future.conditions) + 
[13:35:23.226]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:23.226]                   if (TRUE && !signal) {
[13:35:23.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:23.226]                     {
[13:35:23.226]                       inherits <- base::inherits
[13:35:23.226]                       invokeRestart <- base::invokeRestart
[13:35:23.226]                       is.null <- base::is.null
[13:35:23.226]                       muffled <- FALSE
[13:35:23.226]                       if (inherits(cond, "message")) {
[13:35:23.226]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:23.226]                         if (muffled) 
[13:35:23.226]                           invokeRestart("muffleMessage")
[13:35:23.226]                       }
[13:35:23.226]                       else if (inherits(cond, "warning")) {
[13:35:23.226]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:23.226]                         if (muffled) 
[13:35:23.226]                           invokeRestart("muffleWarning")
[13:35:23.226]                       }
[13:35:23.226]                       else if (inherits(cond, "condition")) {
[13:35:23.226]                         if (!is.null(pattern)) {
[13:35:23.226]                           computeRestarts <- base::computeRestarts
[13:35:23.226]                           grepl <- base::grepl
[13:35:23.226]                           restarts <- computeRestarts(cond)
[13:35:23.226]                           for (restart in restarts) {
[13:35:23.226]                             name <- restart$name
[13:35:23.226]                             if (is.null(name)) 
[13:35:23.226]                               next
[13:35:23.226]                             if (!grepl(pattern, name)) 
[13:35:23.226]                               next
[13:35:23.226]                             invokeRestart(restart)
[13:35:23.226]                             muffled <- TRUE
[13:35:23.226]                             break
[13:35:23.226]                           }
[13:35:23.226]                         }
[13:35:23.226]                       }
[13:35:23.226]                       invisible(muffled)
[13:35:23.226]                     }
[13:35:23.226]                     muffleCondition(cond, pattern = "^muffle")
[13:35:23.226]                   }
[13:35:23.226]                 }
[13:35:23.226]                 else {
[13:35:23.226]                   if (TRUE) {
[13:35:23.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:23.226]                     {
[13:35:23.226]                       inherits <- base::inherits
[13:35:23.226]                       invokeRestart <- base::invokeRestart
[13:35:23.226]                       is.null <- base::is.null
[13:35:23.226]                       muffled <- FALSE
[13:35:23.226]                       if (inherits(cond, "message")) {
[13:35:23.226]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:23.226]                         if (muffled) 
[13:35:23.226]                           invokeRestart("muffleMessage")
[13:35:23.226]                       }
[13:35:23.226]                       else if (inherits(cond, "warning")) {
[13:35:23.226]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:23.226]                         if (muffled) 
[13:35:23.226]                           invokeRestart("muffleWarning")
[13:35:23.226]                       }
[13:35:23.226]                       else if (inherits(cond, "condition")) {
[13:35:23.226]                         if (!is.null(pattern)) {
[13:35:23.226]                           computeRestarts <- base::computeRestarts
[13:35:23.226]                           grepl <- base::grepl
[13:35:23.226]                           restarts <- computeRestarts(cond)
[13:35:23.226]                           for (restart in restarts) {
[13:35:23.226]                             name <- restart$name
[13:35:23.226]                             if (is.null(name)) 
[13:35:23.226]                               next
[13:35:23.226]                             if (!grepl(pattern, name)) 
[13:35:23.226]                               next
[13:35:23.226]                             invokeRestart(restart)
[13:35:23.226]                             muffled <- TRUE
[13:35:23.226]                             break
[13:35:23.226]                           }
[13:35:23.226]                         }
[13:35:23.226]                       }
[13:35:23.226]                       invisible(muffled)
[13:35:23.226]                     }
[13:35:23.226]                     muffleCondition(cond, pattern = "^muffle")
[13:35:23.226]                   }
[13:35:23.226]                 }
[13:35:23.226]             }
[13:35:23.226]         }))
[13:35:23.226]     }, error = function(ex) {
[13:35:23.226]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:23.226]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:23.226]                 ...future.rng), started = ...future.startTime, 
[13:35:23.226]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:23.226]             version = "1.8"), class = "FutureResult")
[13:35:23.226]     }, finally = {
[13:35:23.226]         if (!identical(...future.workdir, getwd())) 
[13:35:23.226]             setwd(...future.workdir)
[13:35:23.226]         {
[13:35:23.226]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:23.226]                 ...future.oldOptions$nwarnings <- NULL
[13:35:23.226]             }
[13:35:23.226]             base::options(...future.oldOptions)
[13:35:23.226]             if (.Platform$OS.type == "windows") {
[13:35:23.226]                 old_names <- names(...future.oldEnvVars)
[13:35:23.226]                 envs <- base::Sys.getenv()
[13:35:23.226]                 names <- names(envs)
[13:35:23.226]                 common <- intersect(names, old_names)
[13:35:23.226]                 added <- setdiff(names, old_names)
[13:35:23.226]                 removed <- setdiff(old_names, names)
[13:35:23.226]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:23.226]                   envs[common]]
[13:35:23.226]                 NAMES <- toupper(changed)
[13:35:23.226]                 args <- list()
[13:35:23.226]                 for (kk in seq_along(NAMES)) {
[13:35:23.226]                   name <- changed[[kk]]
[13:35:23.226]                   NAME <- NAMES[[kk]]
[13:35:23.226]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:23.226]                     next
[13:35:23.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:23.226]                 }
[13:35:23.226]                 NAMES <- toupper(added)
[13:35:23.226]                 for (kk in seq_along(NAMES)) {
[13:35:23.226]                   name <- added[[kk]]
[13:35:23.226]                   NAME <- NAMES[[kk]]
[13:35:23.226]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:23.226]                     next
[13:35:23.226]                   args[[name]] <- ""
[13:35:23.226]                 }
[13:35:23.226]                 NAMES <- toupper(removed)
[13:35:23.226]                 for (kk in seq_along(NAMES)) {
[13:35:23.226]                   name <- removed[[kk]]
[13:35:23.226]                   NAME <- NAMES[[kk]]
[13:35:23.226]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:23.226]                     next
[13:35:23.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:23.226]                 }
[13:35:23.226]                 if (length(args) > 0) 
[13:35:23.226]                   base::do.call(base::Sys.setenv, args = args)
[13:35:23.226]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:23.226]             }
[13:35:23.226]             else {
[13:35:23.226]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:23.226]             }
[13:35:23.226]             {
[13:35:23.226]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:23.226]                   0L) {
[13:35:23.226]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:23.226]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:23.226]                   base::options(opts)
[13:35:23.226]                 }
[13:35:23.226]                 {
[13:35:23.226]                   {
[13:35:23.226]                     NULL
[13:35:23.226]                     RNGkind("Mersenne-Twister")
[13:35:23.226]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:23.226]                       inherits = FALSE)
[13:35:23.226]                   }
[13:35:23.226]                   options(future.plan = NULL)
[13:35:23.226]                   if (is.na(NA_character_)) 
[13:35:23.226]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:23.226]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:23.226]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:23.226]                     .init = FALSE)
[13:35:23.226]                 }
[13:35:23.226]             }
[13:35:23.226]         }
[13:35:23.226]     })
[13:35:23.226]     if (TRUE) {
[13:35:23.226]         base::sink(type = "output", split = FALSE)
[13:35:23.226]         if (FALSE) {
[13:35:23.226]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:23.226]         }
[13:35:23.226]         else {
[13:35:23.226]             ...future.result["stdout"] <- base::list(NULL)
[13:35:23.226]         }
[13:35:23.226]         base::close(...future.stdout)
[13:35:23.226]         ...future.stdout <- NULL
[13:35:23.226]     }
[13:35:23.226]     ...future.result$conditions <- ...future.conditions
[13:35:23.226]     ...future.result$finished <- base::Sys.time()
[13:35:23.226]     ...future.result
[13:35:23.226] }
[13:35:23.228] assign_globals() ...
[13:35:23.228] List of 5
[13:35:23.228]  $ ...future.FUN            :function (x)  
[13:35:23.228]  $ future.call.arguments    : list()
[13:35:23.228]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:23.228]  $ ...future.elements_ii    :List of 2
[13:35:23.228]   ..$ : int 1
[13:35:23.228]   ..$ : int 0
[13:35:23.228]  $ ...future.seeds_ii       : NULL
[13:35:23.228]  $ ...future.globals.maxSize: NULL
[13:35:23.228]  - attr(*, "where")=List of 5
[13:35:23.228]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:23.228]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:23.228]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:23.228]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:23.228]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:23.228]  - attr(*, "resolved")= logi FALSE
[13:35:23.228]  - attr(*, "total_size")= num 4720
[13:35:23.228]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:23.228]  - attr(*, "already-done")= logi TRUE
[13:35:23.232] - reassign environment for ‘...future.FUN’
[13:35:23.232] - copied ‘...future.FUN’ to environment
[13:35:23.233] - copied ‘future.call.arguments’ to environment
[13:35:23.233] - copied ‘...future.elements_ii’ to environment
[13:35:23.233] - copied ‘...future.seeds_ii’ to environment
[13:35:23.233] - copied ‘...future.globals.maxSize’ to environment
[13:35:23.233] assign_globals() ... done
[13:35:23.233] plan(): Setting new future strategy stack:
[13:35:23.233] List of future strategies:
[13:35:23.233] 1. sequential:
[13:35:23.233]    - args: function (..., envir = parent.frame())
[13:35:23.233]    - tweaked: FALSE
[13:35:23.233]    - call: NULL
[13:35:23.234] plan(): nbrOfWorkers() = 1
[13:35:23.737] plan(): Setting new future strategy stack:
[13:35:23.737] List of future strategies:
[13:35:23.737] 1. multicore:
[13:35:23.737]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:23.737]    - tweaked: FALSE
[13:35:23.737]    - call: plan(strategy)
[13:35:23.741] plan(): nbrOfWorkers() = 1
[13:35:23.741] SequentialFuture started (and completed)
[13:35:23.741] - Launch lazy future ... done
[13:35:23.742] run() for ‘SequentialFuture’ ... done
[13:35:23.742] Created future:
[13:35:23.742] SequentialFuture:
[13:35:23.742] Label: ‘future_lapply-1’
[13:35:23.742] Expression:
[13:35:23.742] {
[13:35:23.742]     do.call(function(...) {
[13:35:23.742]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:23.742]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:23.742]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:23.742]             on.exit(options(oopts), add = TRUE)
[13:35:23.742]         }
[13:35:23.742]         {
[13:35:23.742]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:23.742]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:23.742]                 ...future.FUN(...future.X_jj, ...)
[13:35:23.742]             })
[13:35:23.742]         }
[13:35:23.742]     }, args = future.call.arguments)
[13:35:23.742] }
[13:35:23.742] Lazy evaluation: FALSE
[13:35:23.742] Asynchronous evaluation: FALSE
[13:35:23.742] Local evaluation: TRUE
[13:35:23.742] Environment: R_GlobalEnv
[13:35:23.742] Capture standard output: FALSE
[13:35:23.742] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:23.742] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:23.742] Packages: <none>
[13:35:23.742] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:23.742] Resolved: TRUE
[13:35:23.742] Value: 112 bytes of class ‘list’
[13:35:23.742] Early signaling: FALSE
[13:35:23.742] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:23.742] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:23.743] Chunk #1 of 1 ... DONE
[13:35:23.743] Launching 1 futures (chunks) ... DONE
[13:35:23.743] Resolving 1 futures (chunks) ...
[13:35:23.743] resolve() on list ...
[13:35:23.743]  recursive: 0
[13:35:23.743]  length: 1
[13:35:23.743] 
[13:35:23.744] resolved() for ‘SequentialFuture’ ...
[13:35:23.744] - state: ‘finished’
[13:35:23.744] - run: TRUE
[13:35:23.744] - result: ‘FutureResult’
[13:35:23.744] resolved() for ‘SequentialFuture’ ... done
[13:35:23.744] Future #1
[13:35:23.744] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:23.744] - nx: 1
[13:35:23.744] - relay: TRUE
[13:35:23.745] - stdout: TRUE
[13:35:23.745] - signal: TRUE
[13:35:23.745] - resignal: FALSE
[13:35:23.745] - force: TRUE
[13:35:23.745] - relayed: [n=1] FALSE
[13:35:23.745] - queued futures: [n=1] FALSE
[13:35:23.745]  - until=1
[13:35:23.745]  - relaying element #1
[13:35:23.745] - relayed: [n=1] TRUE
[13:35:23.745] - queued futures: [n=1] TRUE
[13:35:23.745] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:23.746]  length: 0 (resolved future 1)
[13:35:23.746] Relaying remaining futures
[13:35:23.746] signalConditionsASAP(NULL, pos=0) ...
[13:35:23.746] - nx: 1
[13:35:23.746] - relay: TRUE
[13:35:23.746] - stdout: TRUE
[13:35:23.746] - signal: TRUE
[13:35:23.746] - resignal: FALSE
[13:35:23.746] - force: TRUE
[13:35:23.746] - relayed: [n=1] TRUE
[13:35:23.746] - queued futures: [n=1] TRUE
 - flush all
[13:35:23.747] - relayed: [n=1] TRUE
[13:35:23.747] - queued futures: [n=1] TRUE
[13:35:23.747] signalConditionsASAP(NULL, pos=0) ... done
[13:35:23.747] resolve() on list ... DONE
[13:35:23.747]  - Number of value chunks collected: 1
[13:35:23.747] Resolving 1 futures (chunks) ... DONE
[13:35:23.747] Reducing values from 1 chunks ...
[13:35:23.747]  - Number of values collected after concatenation: 2
[13:35:23.747]  - Number of values expected: 2
[13:35:23.747] Reducing values from 1 chunks ... DONE
[13:35:23.748] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[13:35:23.748] future_lapply() ...
[13:35:23.752] Number of chunks: 1
[13:35:23.752] getGlobalsAndPackagesXApply() ...
[13:35:23.752]  - future.globals: TRUE
[13:35:23.752] getGlobalsAndPackages() ...
[13:35:23.752] Searching for globals...
[13:35:23.753] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:35:23.754] Searching for globals ... DONE
[13:35:23.754] Resolving globals: FALSE
[13:35:23.754] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:35:23.754] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:35:23.755] - globals: [1] ‘FUN’
[13:35:23.755] 
[13:35:23.755] getGlobalsAndPackages() ... DONE
[13:35:23.755]  - globals found/used: [n=1] ‘FUN’
[13:35:23.755]  - needed namespaces: [n=0] 
[13:35:23.755] Finding globals ... DONE
[13:35:23.755]  - use_args: TRUE
[13:35:23.755]  - Getting '...' globals ...
[13:35:23.755] resolve() on list ...
[13:35:23.756]  recursive: 0
[13:35:23.756]  length: 1
[13:35:23.756]  elements: ‘...’
[13:35:23.756]  length: 0 (resolved future 1)
[13:35:23.756] resolve() on list ... DONE
[13:35:23.756]    - '...' content: [n=0] 
[13:35:23.756] List of 1
[13:35:23.756]  $ ...: list()
[13:35:23.756]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:23.756]  - attr(*, "where")=List of 1
[13:35:23.756]   ..$ ...:<environment: 0x558d37376f00> 
[13:35:23.756]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:23.756]  - attr(*, "resolved")= logi TRUE
[13:35:23.756]  - attr(*, "total_size")= num NA
[13:35:23.759]  - Getting '...' globals ... DONE
[13:35:23.759] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:35:23.759] List of 2
[13:35:23.759]  $ ...future.FUN:function (x)  
[13:35:23.759]  $ ...          : list()
[13:35:23.759]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:23.759]  - attr(*, "where")=List of 2
[13:35:23.759]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:23.759]   ..$ ...          :<environment: 0x558d37376f00> 
[13:35:23.759]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:23.759]  - attr(*, "resolved")= logi FALSE
[13:35:23.759]  - attr(*, "total_size")= num 4720
[13:35:23.762] Packages to be attached in all futures: [n=0] 
[13:35:23.762] getGlobalsAndPackagesXApply() ... DONE
[13:35:23.762] Number of futures (= number of chunks): 1
[13:35:23.762] Launching 1 futures (chunks) ...
[13:35:23.762] Chunk #1 of 1 ...
[13:35:23.762]  - Finding globals in 'X' for chunk #1 ...
[13:35:23.762] getGlobalsAndPackages() ...
[13:35:23.762] Searching for globals...
[13:35:23.763] 
[13:35:23.763] Searching for globals ... DONE
[13:35:23.763] - globals: [0] <none>
[13:35:23.763] getGlobalsAndPackages() ... DONE
[13:35:23.763]    + additional globals found: [n=0] 
[13:35:23.763]    + additional namespaces needed: [n=0] 
[13:35:23.763]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:23.763]  - seeds: <none>
[13:35:23.763]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:23.764] getGlobalsAndPackages() ...
[13:35:23.765] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:23.765] Resolving globals: FALSE
[13:35:23.765] Tweak future expression to call with '...' arguments ...
[13:35:23.765] {
[13:35:23.765]     do.call(function(...) {
[13:35:23.765]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:23.765]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:23.765]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:23.765]             on.exit(options(oopts), add = TRUE)
[13:35:23.765]         }
[13:35:23.765]         {
[13:35:23.765]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:23.765]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:23.765]                 ...future.FUN(...future.X_jj, ...)
[13:35:23.765]             })
[13:35:23.765]         }
[13:35:23.765]     }, args = future.call.arguments)
[13:35:23.765] }
[13:35:23.765] Tweak future expression to call with '...' arguments ... DONE
[13:35:23.766] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:23.766] 
[13:35:23.766] getGlobalsAndPackages() ... DONE
[13:35:23.766] run() for ‘Future’ ...
[13:35:23.766] - state: ‘created’
[13:35:23.767] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:23.770] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:23.770] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:23.770]   - Field: ‘label’
[13:35:23.770]   - Field: ‘local’
[13:35:23.770]   - Field: ‘owner’
[13:35:23.770]   - Field: ‘envir’
[13:35:23.771]   - Field: ‘packages’
[13:35:23.771]   - Field: ‘gc’
[13:35:23.771]   - Field: ‘conditions’
[13:35:23.771]   - Field: ‘expr’
[13:35:23.771]   - Field: ‘uuid’
[13:35:23.771]   - Field: ‘seed’
[13:35:23.771]   - Field: ‘version’
[13:35:23.771]   - Field: ‘result’
[13:35:23.771]   - Field: ‘asynchronous’
[13:35:23.771]   - Field: ‘calls’
[13:35:23.771]   - Field: ‘globals’
[13:35:23.772]   - Field: ‘stdout’
[13:35:23.772]   - Field: ‘earlySignal’
[13:35:23.772]   - Field: ‘lazy’
[13:35:23.772]   - Field: ‘state’
[13:35:23.772] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:23.772] - Launch lazy future ...
[13:35:23.772] Packages needed by the future expression (n = 0): <none>
[13:35:23.772] Packages needed by future strategies (n = 0): <none>
[13:35:23.773] {
[13:35:23.773]     {
[13:35:23.773]         {
[13:35:23.773]             ...future.startTime <- base::Sys.time()
[13:35:23.773]             {
[13:35:23.773]                 {
[13:35:23.773]                   {
[13:35:23.773]                     base::local({
[13:35:23.773]                       has_future <- base::requireNamespace("future", 
[13:35:23.773]                         quietly = TRUE)
[13:35:23.773]                       if (has_future) {
[13:35:23.773]                         ns <- base::getNamespace("future")
[13:35:23.773]                         version <- ns[[".package"]][["version"]]
[13:35:23.773]                         if (is.null(version)) 
[13:35:23.773]                           version <- utils::packageVersion("future")
[13:35:23.773]                       }
[13:35:23.773]                       else {
[13:35:23.773]                         version <- NULL
[13:35:23.773]                       }
[13:35:23.773]                       if (!has_future || version < "1.8.0") {
[13:35:23.773]                         info <- base::c(r_version = base::gsub("R version ", 
[13:35:23.773]                           "", base::R.version$version.string), 
[13:35:23.773]                           platform = base::sprintf("%s (%s-bit)", 
[13:35:23.773]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:23.773]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:23.773]                             "release", "version")], collapse = " "), 
[13:35:23.773]                           hostname = base::Sys.info()[["nodename"]])
[13:35:23.773]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:35:23.773]                           info)
[13:35:23.773]                         info <- base::paste(info, collapse = "; ")
[13:35:23.773]                         if (!has_future) {
[13:35:23.773]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:23.773]                             info)
[13:35:23.773]                         }
[13:35:23.773]                         else {
[13:35:23.773]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:23.773]                             info, version)
[13:35:23.773]                         }
[13:35:23.773]                         base::stop(msg)
[13:35:23.773]                       }
[13:35:23.773]                     })
[13:35:23.773]                   }
[13:35:23.773]                   ...future.strategy.old <- future::plan("list")
[13:35:23.773]                   options(future.plan = NULL)
[13:35:23.773]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:23.773]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:23.773]                 }
[13:35:23.773]                 ...future.workdir <- getwd()
[13:35:23.773]             }
[13:35:23.773]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:23.773]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:23.773]         }
[13:35:23.773]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:23.773]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:23.773]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:23.773]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:23.773]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:23.773]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:23.773]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:23.773]             base::names(...future.oldOptions))
[13:35:23.773]     }
[13:35:23.773]     if (FALSE) {
[13:35:23.773]     }
[13:35:23.773]     else {
[13:35:23.773]         if (TRUE) {
[13:35:23.773]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:23.773]                 open = "w")
[13:35:23.773]         }
[13:35:23.773]         else {
[13:35:23.773]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:23.773]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:23.773]         }
[13:35:23.773]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:23.773]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:23.773]             base::sink(type = "output", split = FALSE)
[13:35:23.773]             base::close(...future.stdout)
[13:35:23.773]         }, add = TRUE)
[13:35:23.773]     }
[13:35:23.773]     ...future.frame <- base::sys.nframe()
[13:35:23.773]     ...future.conditions <- base::list()
[13:35:23.773]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:23.773]     if (FALSE) {
[13:35:23.773]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:23.773]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:23.773]     }
[13:35:23.773]     ...future.result <- base::tryCatch({
[13:35:23.773]         base::withCallingHandlers({
[13:35:23.773]             ...future.value <- base::withVisible(base::local({
[13:35:23.773]                 do.call(function(...) {
[13:35:23.773]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:23.773]                   if (!identical(...future.globals.maxSize.org, 
[13:35:23.773]                     ...future.globals.maxSize)) {
[13:35:23.773]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:23.773]                     on.exit(options(oopts), add = TRUE)
[13:35:23.773]                   }
[13:35:23.773]                   {
[13:35:23.773]                     lapply(seq_along(...future.elements_ii), 
[13:35:23.773]                       FUN = function(jj) {
[13:35:23.773]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:23.773]                         ...future.FUN(...future.X_jj, ...)
[13:35:23.773]                       })
[13:35:23.773]                   }
[13:35:23.773]                 }, args = future.call.arguments)
[13:35:23.773]             }))
[13:35:23.773]             future::FutureResult(value = ...future.value$value, 
[13:35:23.773]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:23.773]                   ...future.rng), globalenv = if (FALSE) 
[13:35:23.773]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:23.773]                     ...future.globalenv.names))
[13:35:23.773]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:23.773]         }, condition = base::local({
[13:35:23.773]             c <- base::c
[13:35:23.773]             inherits <- base::inherits
[13:35:23.773]             invokeRestart <- base::invokeRestart
[13:35:23.773]             length <- base::length
[13:35:23.773]             list <- base::list
[13:35:23.773]             seq.int <- base::seq.int
[13:35:23.773]             signalCondition <- base::signalCondition
[13:35:23.773]             sys.calls <- base::sys.calls
[13:35:23.773]             `[[` <- base::`[[`
[13:35:23.773]             `+` <- base::`+`
[13:35:23.773]             `<<-` <- base::`<<-`
[13:35:23.773]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:23.773]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:23.773]                   3L)]
[13:35:23.773]             }
[13:35:23.773]             function(cond) {
[13:35:23.773]                 is_error <- inherits(cond, "error")
[13:35:23.773]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:23.773]                   NULL)
[13:35:23.773]                 if (is_error) {
[13:35:23.773]                   sessionInformation <- function() {
[13:35:23.773]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:23.773]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:23.773]                       search = base::search(), system = base::Sys.info())
[13:35:23.773]                   }
[13:35:23.773]                   ...future.conditions[[length(...future.conditions) + 
[13:35:23.773]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:23.773]                     cond$call), session = sessionInformation(), 
[13:35:23.773]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:23.773]                   signalCondition(cond)
[13:35:23.773]                 }
[13:35:23.773]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:23.773]                 "immediateCondition"))) {
[13:35:23.773]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:23.773]                   ...future.conditions[[length(...future.conditions) + 
[13:35:23.773]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:23.773]                   if (TRUE && !signal) {
[13:35:23.773]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:23.773]                     {
[13:35:23.773]                       inherits <- base::inherits
[13:35:23.773]                       invokeRestart <- base::invokeRestart
[13:35:23.773]                       is.null <- base::is.null
[13:35:23.773]                       muffled <- FALSE
[13:35:23.773]                       if (inherits(cond, "message")) {
[13:35:23.773]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:23.773]                         if (muffled) 
[13:35:23.773]                           invokeRestart("muffleMessage")
[13:35:23.773]                       }
[13:35:23.773]                       else if (inherits(cond, "warning")) {
[13:35:23.773]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:23.773]                         if (muffled) 
[13:35:23.773]                           invokeRestart("muffleWarning")
[13:35:23.773]                       }
[13:35:23.773]                       else if (inherits(cond, "condition")) {
[13:35:23.773]                         if (!is.null(pattern)) {
[13:35:23.773]                           computeRestarts <- base::computeRestarts
[13:35:23.773]                           grepl <- base::grepl
[13:35:23.773]                           restarts <- computeRestarts(cond)
[13:35:23.773]                           for (restart in restarts) {
[13:35:23.773]                             name <- restart$name
[13:35:23.773]                             if (is.null(name)) 
[13:35:23.773]                               next
[13:35:23.773]                             if (!grepl(pattern, name)) 
[13:35:23.773]                               next
[13:35:23.773]                             invokeRestart(restart)
[13:35:23.773]                             muffled <- TRUE
[13:35:23.773]                             break
[13:35:23.773]                           }
[13:35:23.773]                         }
[13:35:23.773]                       }
[13:35:23.773]                       invisible(muffled)
[13:35:23.773]                     }
[13:35:23.773]                     muffleCondition(cond, pattern = "^muffle")
[13:35:23.773]                   }
[13:35:23.773]                 }
[13:35:23.773]                 else {
[13:35:23.773]                   if (TRUE) {
[13:35:23.773]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:23.773]                     {
[13:35:23.773]                       inherits <- base::inherits
[13:35:23.773]                       invokeRestart <- base::invokeRestart
[13:35:23.773]                       is.null <- base::is.null
[13:35:23.773]                       muffled <- FALSE
[13:35:23.773]                       if (inherits(cond, "message")) {
[13:35:23.773]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:23.773]                         if (muffled) 
[13:35:23.773]                           invokeRestart("muffleMessage")
[13:35:23.773]                       }
[13:35:23.773]                       else if (inherits(cond, "warning")) {
[13:35:23.773]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:23.773]                         if (muffled) 
[13:35:23.773]                           invokeRestart("muffleWarning")
[13:35:23.773]                       }
[13:35:23.773]                       else if (inherits(cond, "condition")) {
[13:35:23.773]                         if (!is.null(pattern)) {
[13:35:23.773]                           computeRestarts <- base::computeRestarts
[13:35:23.773]                           grepl <- base::grepl
[13:35:23.773]                           restarts <- computeRestarts(cond)
[13:35:23.773]                           for (restart in restarts) {
[13:35:23.773]                             name <- restart$name
[13:35:23.773]                             if (is.null(name)) 
[13:35:23.773]                               next
[13:35:23.773]                             if (!grepl(pattern, name)) 
[13:35:23.773]                               next
[13:35:23.773]                             invokeRestart(restart)
[13:35:23.773]                             muffled <- TRUE
[13:35:23.773]                             break
[13:35:23.773]                           }
[13:35:23.773]                         }
[13:35:23.773]                       }
[13:35:23.773]                       invisible(muffled)
[13:35:23.773]                     }
[13:35:23.773]                     muffleCondition(cond, pattern = "^muffle")
[13:35:23.773]                   }
[13:35:23.773]                 }
[13:35:23.773]             }
[13:35:23.773]         }))
[13:35:23.773]     }, error = function(ex) {
[13:35:23.773]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:23.773]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:23.773]                 ...future.rng), started = ...future.startTime, 
[13:35:23.773]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:23.773]             version = "1.8"), class = "FutureResult")
[13:35:23.773]     }, finally = {
[13:35:23.773]         if (!identical(...future.workdir, getwd())) 
[13:35:23.773]             setwd(...future.workdir)
[13:35:23.773]         {
[13:35:23.773]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:23.773]                 ...future.oldOptions$nwarnings <- NULL
[13:35:23.773]             }
[13:35:23.773]             base::options(...future.oldOptions)
[13:35:23.773]             if (.Platform$OS.type == "windows") {
[13:35:23.773]                 old_names <- names(...future.oldEnvVars)
[13:35:23.773]                 envs <- base::Sys.getenv()
[13:35:23.773]                 names <- names(envs)
[13:35:23.773]                 common <- intersect(names, old_names)
[13:35:23.773]                 added <- setdiff(names, old_names)
[13:35:23.773]                 removed <- setdiff(old_names, names)
[13:35:23.773]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:23.773]                   envs[common]]
[13:35:23.773]                 NAMES <- toupper(changed)
[13:35:23.773]                 args <- list()
[13:35:23.773]                 for (kk in seq_along(NAMES)) {
[13:35:23.773]                   name <- changed[[kk]]
[13:35:23.773]                   NAME <- NAMES[[kk]]
[13:35:23.773]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:23.773]                     next
[13:35:23.773]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:23.773]                 }
[13:35:23.773]                 NAMES <- toupper(added)
[13:35:23.773]                 for (kk in seq_along(NAMES)) {
[13:35:23.773]                   name <- added[[kk]]
[13:35:23.773]                   NAME <- NAMES[[kk]]
[13:35:23.773]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:23.773]                     next
[13:35:23.773]                   args[[name]] <- ""
[13:35:23.773]                 }
[13:35:23.773]                 NAMES <- toupper(removed)
[13:35:23.773]                 for (kk in seq_along(NAMES)) {
[13:35:23.773]                   name <- removed[[kk]]
[13:35:23.773]                   NAME <- NAMES[[kk]]
[13:35:23.773]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:23.773]                     next
[13:35:23.773]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:23.773]                 }
[13:35:23.773]                 if (length(args) > 0) 
[13:35:23.773]                   base::do.call(base::Sys.setenv, args = args)
[13:35:23.773]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:23.773]             }
[13:35:23.773]             else {
[13:35:23.773]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:23.773]             }
[13:35:23.773]             {
[13:35:23.773]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:23.773]                   0L) {
[13:35:23.773]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:23.773]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:23.773]                   base::options(opts)
[13:35:23.773]                 }
[13:35:23.773]                 {
[13:35:23.773]                   {
[13:35:23.773]                     NULL
[13:35:23.773]                     RNGkind("Mersenne-Twister")
[13:35:23.773]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:23.773]                       inherits = FALSE)
[13:35:23.773]                   }
[13:35:23.773]                   options(future.plan = NULL)
[13:35:23.773]                   if (is.na(NA_character_)) 
[13:35:23.773]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:23.773]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:23.773]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:23.773]                     .init = FALSE)
[13:35:23.773]                 }
[13:35:23.773]             }
[13:35:23.773]         }
[13:35:23.773]     })
[13:35:23.773]     if (TRUE) {
[13:35:23.773]         base::sink(type = "output", split = FALSE)
[13:35:23.773]         if (TRUE) {
[13:35:23.773]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:23.773]         }
[13:35:23.773]         else {
[13:35:23.773]             ...future.result["stdout"] <- base::list(NULL)
[13:35:23.773]         }
[13:35:23.773]         base::close(...future.stdout)
[13:35:23.773]         ...future.stdout <- NULL
[13:35:23.773]     }
[13:35:23.773]     ...future.result$conditions <- ...future.conditions
[13:35:23.773]     ...future.result$finished <- base::Sys.time()
[13:35:23.773]     ...future.result
[13:35:23.773] }
[13:35:23.774] assign_globals() ...
[13:35:23.774] List of 5
[13:35:23.774]  $ ...future.FUN            :function (x)  
[13:35:23.774]  $ future.call.arguments    : list()
[13:35:23.774]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:23.774]  $ ...future.elements_ii    :List of 2
[13:35:23.774]   ..$ : int 1
[13:35:23.774]   ..$ : int 0
[13:35:23.774]  $ ...future.seeds_ii       : NULL
[13:35:23.774]  $ ...future.globals.maxSize: NULL
[13:35:23.774]  - attr(*, "where")=List of 5
[13:35:23.774]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:23.774]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:23.774]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:23.774]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:23.774]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:23.774]  - attr(*, "resolved")= logi FALSE
[13:35:23.774]  - attr(*, "total_size")= num 4720
[13:35:23.774]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:23.774]  - attr(*, "already-done")= logi TRUE
[13:35:23.779] - reassign environment for ‘...future.FUN’
[13:35:23.779] - copied ‘...future.FUN’ to environment
[13:35:23.779] - copied ‘future.call.arguments’ to environment
[13:35:23.779] - copied ‘...future.elements_ii’ to environment
[13:35:23.779] - copied ‘...future.seeds_ii’ to environment
[13:35:23.779] - copied ‘...future.globals.maxSize’ to environment
[13:35:23.780] assign_globals() ... done
[13:35:23.780] plan(): Setting new future strategy stack:
[13:35:23.780] List of future strategies:
[13:35:23.780] 1. sequential:
[13:35:23.780]    - args: function (..., envir = parent.frame())
[13:35:23.780]    - tweaked: FALSE
[13:35:23.780]    - call: NULL
[13:35:23.780] plan(): nbrOfWorkers() = 1
[13:35:24.282] plan(): Setting new future strategy stack:
[13:35:24.282] List of future strategies:
[13:35:24.282] 1. multicore:
[13:35:24.282]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:24.282]    - tweaked: FALSE
[13:35:24.282]    - call: plan(strategy)
[13:35:24.286] plan(): nbrOfWorkers() = 1
[13:35:24.286] SequentialFuture started (and completed)
[13:35:24.286] - Launch lazy future ... done
[13:35:24.286] run() for ‘SequentialFuture’ ... done
[13:35:24.286] Created future:
[13:35:24.286] SequentialFuture:
[13:35:24.286] Label: ‘future_lapply-1’
[13:35:24.286] Expression:
[13:35:24.286] {
[13:35:24.286]     do.call(function(...) {
[13:35:24.286]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:24.286]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:24.286]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:24.286]             on.exit(options(oopts), add = TRUE)
[13:35:24.286]         }
[13:35:24.286]         {
[13:35:24.286]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:24.286]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:24.286]                 ...future.FUN(...future.X_jj, ...)
[13:35:24.286]             })
[13:35:24.286]         }
[13:35:24.286]     }, args = future.call.arguments)
[13:35:24.286] }
[13:35:24.286] Lazy evaluation: FALSE
[13:35:24.286] Asynchronous evaluation: FALSE
[13:35:24.286] Local evaluation: TRUE
[13:35:24.286] Environment: R_GlobalEnv
[13:35:24.286] Capture standard output: TRUE
[13:35:24.286] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:24.286] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:24.286] Packages: <none>
[13:35:24.286] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:24.286] Resolved: TRUE
[13:35:24.286] Value: 112 bytes of class ‘list’
[13:35:24.286] Early signaling: FALSE
[13:35:24.286] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:24.286] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:24.287] Chunk #1 of 1 ... DONE
[13:35:24.288] Launching 1 futures (chunks) ... DONE
[13:35:24.288] Resolving 1 futures (chunks) ...
[13:35:24.288] resolve() on list ...
[13:35:24.288]  recursive: 0
[13:35:24.288]  length: 1
[13:35:24.288] 
[13:35:24.288] resolved() for ‘SequentialFuture’ ...
[13:35:24.288] - state: ‘finished’
[13:35:24.288] - run: TRUE
[13:35:24.288] - result: ‘FutureResult’
[13:35:24.289] resolved() for ‘SequentialFuture’ ... done
[13:35:24.289] Future #1
[13:35:24.289] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:24.289] - nx: 1
[13:35:24.289] - relay: TRUE
[13:35:24.289] - stdout: TRUE
[13:35:24.289] - signal: TRUE
[13:35:24.289] - resignal: FALSE
[13:35:24.289] - force: TRUE
[13:35:24.289] - relayed: [n=1] FALSE
[13:35:24.289] - queued futures: [n=1] FALSE
[13:35:24.290]  - until=1
[13:35:24.290]  - relaying element #1
[13:35:24.290] - relayed: [n=1] TRUE
[13:35:24.290] - queued futures: [n=1] TRUE
[13:35:24.290] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:24.290]  length: 0 (resolved future 1)
[13:35:24.290] Relaying remaining futures
[13:35:24.290] signalConditionsASAP(NULL, pos=0) ...
[13:35:24.290] - nx: 1
[13:35:24.291] - relay: TRUE
[13:35:24.291] - stdout: TRUE
[13:35:24.291] - signal: TRUE
[13:35:24.291] - resignal: FALSE
[13:35:24.291] - force: TRUE
[13:35:24.291] - relayed: [n=1] TRUE
[13:35:24.291] - queued futures: [n=1] TRUE
 - flush all
[13:35:24.291] - relayed: [n=1] TRUE
[13:35:24.291] - queued futures: [n=1] TRUE
[13:35:24.291] signalConditionsASAP(NULL, pos=0) ... done
[13:35:24.291] resolve() on list ... DONE
[13:35:24.292]  - Number of value chunks collected: 1
[13:35:24.292] Resolving 1 futures (chunks) ... DONE
[13:35:24.292] Reducing values from 1 chunks ...
[13:35:24.292]  - Number of values collected after concatenation: 2
[13:35:24.292]  - Number of values expected: 2
[13:35:24.292] Reducing values from 1 chunks ... DONE
[13:35:24.292] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[13:35:24.292] future_lapply() ...
[13:35:24.298] Number of chunks: 1
[13:35:24.298] getGlobalsAndPackagesXApply() ...
[13:35:24.298]  - future.globals: TRUE
[13:35:24.298] getGlobalsAndPackages() ...
[13:35:24.299] Searching for globals...
[13:35:24.300] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:35:24.300] Searching for globals ... DONE
[13:35:24.300] Resolving globals: FALSE
[13:35:24.301] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:35:24.301] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:35:24.301] - globals: [1] ‘FUN’
[13:35:24.301] 
[13:35:24.301] getGlobalsAndPackages() ... DONE
[13:35:24.301]  - globals found/used: [n=1] ‘FUN’
[13:35:24.301]  - needed namespaces: [n=0] 
[13:35:24.301] Finding globals ... DONE
[13:35:24.302]  - use_args: TRUE
[13:35:24.302]  - Getting '...' globals ...
[13:35:24.302] resolve() on list ...
[13:35:24.302]  recursive: 0
[13:35:24.302]  length: 1
[13:35:24.302]  elements: ‘...’
[13:35:24.302]  length: 0 (resolved future 1)
[13:35:24.302] resolve() on list ... DONE
[13:35:24.303]    - '...' content: [n=0] 
[13:35:24.303] List of 1
[13:35:24.303]  $ ...: list()
[13:35:24.303]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:24.303]  - attr(*, "where")=List of 1
[13:35:24.303]   ..$ ...:<environment: 0x558d38ab1780> 
[13:35:24.303]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:24.303]  - attr(*, "resolved")= logi TRUE
[13:35:24.303]  - attr(*, "total_size")= num NA
[13:35:24.305]  - Getting '...' globals ... DONE
[13:35:24.305] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:35:24.305] List of 2
[13:35:24.305]  $ ...future.FUN:function (x)  
[13:35:24.305]  $ ...          : list()
[13:35:24.305]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:24.305]  - attr(*, "where")=List of 2
[13:35:24.305]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:24.305]   ..$ ...          :<environment: 0x558d38ab1780> 
[13:35:24.305]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:24.305]  - attr(*, "resolved")= logi FALSE
[13:35:24.305]  - attr(*, "total_size")= num 4720
[13:35:24.308] Packages to be attached in all futures: [n=0] 
[13:35:24.308] getGlobalsAndPackagesXApply() ... DONE
[13:35:24.308] Number of futures (= number of chunks): 1
[13:35:24.308] Launching 1 futures (chunks) ...
[13:35:24.308] Chunk #1 of 1 ...
[13:35:24.309]  - Finding globals in 'X' for chunk #1 ...
[13:35:24.309] getGlobalsAndPackages() ...
[13:35:24.309] Searching for globals...
[13:35:24.309] 
[13:35:24.309] Searching for globals ... DONE
[13:35:24.309] - globals: [0] <none>
[13:35:24.309] getGlobalsAndPackages() ... DONE
[13:35:24.309]    + additional globals found: [n=0] 
[13:35:24.309]    + additional namespaces needed: [n=0] 
[13:35:24.310]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:24.310]  - seeds: <none>
[13:35:24.310]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:24.310] getGlobalsAndPackages() ...
[13:35:24.310] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:24.310] Resolving globals: FALSE
[13:35:24.310] Tweak future expression to call with '...' arguments ...
[13:35:24.310] {
[13:35:24.310]     do.call(function(...) {
[13:35:24.310]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:24.310]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:24.310]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:24.310]             on.exit(options(oopts), add = TRUE)
[13:35:24.310]         }
[13:35:24.310]         {
[13:35:24.310]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:24.310]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:24.310]                 ...future.FUN(...future.X_jj, ...)
[13:35:24.310]             })
[13:35:24.310]         }
[13:35:24.310]     }, args = future.call.arguments)
[13:35:24.310] }
[13:35:24.311] Tweak future expression to call with '...' arguments ... DONE
[13:35:24.311] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:24.311] 
[13:35:24.311] getGlobalsAndPackages() ... DONE
[13:35:24.311] run() for ‘Future’ ...
[13:35:24.311] - state: ‘created’
[13:35:24.312] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:24.315] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:24.315] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:24.315]   - Field: ‘label’
[13:35:24.315]   - Field: ‘local’
[13:35:24.315]   - Field: ‘owner’
[13:35:24.316]   - Field: ‘envir’
[13:35:24.316]   - Field: ‘packages’
[13:35:24.316]   - Field: ‘gc’
[13:35:24.316]   - Field: ‘conditions’
[13:35:24.316]   - Field: ‘expr’
[13:35:24.316]   - Field: ‘uuid’
[13:35:24.316]   - Field: ‘seed’
[13:35:24.316]   - Field: ‘version’
[13:35:24.316]   - Field: ‘result’
[13:35:24.316]   - Field: ‘asynchronous’
[13:35:24.316]   - Field: ‘calls’
[13:35:24.317]   - Field: ‘globals’
[13:35:24.317]   - Field: ‘stdout’
[13:35:24.317]   - Field: ‘earlySignal’
[13:35:24.317]   - Field: ‘lazy’
[13:35:24.317]   - Field: ‘state’
[13:35:24.317] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:24.317] - Launch lazy future ...
[13:35:24.317] Packages needed by the future expression (n = 0): <none>
[13:35:24.317] Packages needed by future strategies (n = 0): <none>
[13:35:24.318] {
[13:35:24.318]     {
[13:35:24.318]         {
[13:35:24.318]             ...future.startTime <- base::Sys.time()
[13:35:24.318]             {
[13:35:24.318]                 {
[13:35:24.318]                   {
[13:35:24.318]                     base::local({
[13:35:24.318]                       has_future <- base::requireNamespace("future", 
[13:35:24.318]                         quietly = TRUE)
[13:35:24.318]                       if (has_future) {
[13:35:24.318]                         ns <- base::getNamespace("future")
[13:35:24.318]                         version <- ns[[".package"]][["version"]]
[13:35:24.318]                         if (is.null(version)) 
[13:35:24.318]                           version <- utils::packageVersion("future")
[13:35:24.318]                       }
[13:35:24.318]                       else {
[13:35:24.318]                         version <- NULL
[13:35:24.318]                       }
[13:35:24.318]                       if (!has_future || version < "1.8.0") {
[13:35:24.318]                         info <- base::c(r_version = base::gsub("R version ", 
[13:35:24.318]                           "", base::R.version$version.string), 
[13:35:24.318]                           platform = base::sprintf("%s (%s-bit)", 
[13:35:24.318]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:24.318]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:24.318]                             "release", "version")], collapse = " "), 
[13:35:24.318]                           hostname = base::Sys.info()[["nodename"]])
[13:35:24.318]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:35:24.318]                           info)
[13:35:24.318]                         info <- base::paste(info, collapse = "; ")
[13:35:24.318]                         if (!has_future) {
[13:35:24.318]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:24.318]                             info)
[13:35:24.318]                         }
[13:35:24.318]                         else {
[13:35:24.318]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:24.318]                             info, version)
[13:35:24.318]                         }
[13:35:24.318]                         base::stop(msg)
[13:35:24.318]                       }
[13:35:24.318]                     })
[13:35:24.318]                   }
[13:35:24.318]                   ...future.strategy.old <- future::plan("list")
[13:35:24.318]                   options(future.plan = NULL)
[13:35:24.318]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:24.318]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:24.318]                 }
[13:35:24.318]                 ...future.workdir <- getwd()
[13:35:24.318]             }
[13:35:24.318]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:24.318]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:24.318]         }
[13:35:24.318]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:24.318]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:24.318]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:24.318]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:24.318]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:24.318]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:24.318]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:24.318]             base::names(...future.oldOptions))
[13:35:24.318]     }
[13:35:24.318]     if (TRUE) {
[13:35:24.318]     }
[13:35:24.318]     else {
[13:35:24.318]         if (NA) {
[13:35:24.318]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:24.318]                 open = "w")
[13:35:24.318]         }
[13:35:24.318]         else {
[13:35:24.318]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:24.318]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:24.318]         }
[13:35:24.318]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:24.318]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:24.318]             base::sink(type = "output", split = FALSE)
[13:35:24.318]             base::close(...future.stdout)
[13:35:24.318]         }, add = TRUE)
[13:35:24.318]     }
[13:35:24.318]     ...future.frame <- base::sys.nframe()
[13:35:24.318]     ...future.conditions <- base::list()
[13:35:24.318]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:24.318]     if (FALSE) {
[13:35:24.318]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:24.318]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:24.318]     }
[13:35:24.318]     ...future.result <- base::tryCatch({
[13:35:24.318]         base::withCallingHandlers({
[13:35:24.318]             ...future.value <- base::withVisible(base::local({
[13:35:24.318]                 do.call(function(...) {
[13:35:24.318]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:24.318]                   if (!identical(...future.globals.maxSize.org, 
[13:35:24.318]                     ...future.globals.maxSize)) {
[13:35:24.318]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:24.318]                     on.exit(options(oopts), add = TRUE)
[13:35:24.318]                   }
[13:35:24.318]                   {
[13:35:24.318]                     lapply(seq_along(...future.elements_ii), 
[13:35:24.318]                       FUN = function(jj) {
[13:35:24.318]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:24.318]                         ...future.FUN(...future.X_jj, ...)
[13:35:24.318]                       })
[13:35:24.318]                   }
[13:35:24.318]                 }, args = future.call.arguments)
[13:35:24.318]             }))
[13:35:24.318]             future::FutureResult(value = ...future.value$value, 
[13:35:24.318]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:24.318]                   ...future.rng), globalenv = if (FALSE) 
[13:35:24.318]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:24.318]                     ...future.globalenv.names))
[13:35:24.318]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:24.318]         }, condition = base::local({
[13:35:24.318]             c <- base::c
[13:35:24.318]             inherits <- base::inherits
[13:35:24.318]             invokeRestart <- base::invokeRestart
[13:35:24.318]             length <- base::length
[13:35:24.318]             list <- base::list
[13:35:24.318]             seq.int <- base::seq.int
[13:35:24.318]             signalCondition <- base::signalCondition
[13:35:24.318]             sys.calls <- base::sys.calls
[13:35:24.318]             `[[` <- base::`[[`
[13:35:24.318]             `+` <- base::`+`
[13:35:24.318]             `<<-` <- base::`<<-`
[13:35:24.318]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:24.318]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:24.318]                   3L)]
[13:35:24.318]             }
[13:35:24.318]             function(cond) {
[13:35:24.318]                 is_error <- inherits(cond, "error")
[13:35:24.318]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:24.318]                   NULL)
[13:35:24.318]                 if (is_error) {
[13:35:24.318]                   sessionInformation <- function() {
[13:35:24.318]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:24.318]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:24.318]                       search = base::search(), system = base::Sys.info())
[13:35:24.318]                   }
[13:35:24.318]                   ...future.conditions[[length(...future.conditions) + 
[13:35:24.318]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:24.318]                     cond$call), session = sessionInformation(), 
[13:35:24.318]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:24.318]                   signalCondition(cond)
[13:35:24.318]                 }
[13:35:24.318]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:24.318]                 "immediateCondition"))) {
[13:35:24.318]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:24.318]                   ...future.conditions[[length(...future.conditions) + 
[13:35:24.318]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:24.318]                   if (TRUE && !signal) {
[13:35:24.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:24.318]                     {
[13:35:24.318]                       inherits <- base::inherits
[13:35:24.318]                       invokeRestart <- base::invokeRestart
[13:35:24.318]                       is.null <- base::is.null
[13:35:24.318]                       muffled <- FALSE
[13:35:24.318]                       if (inherits(cond, "message")) {
[13:35:24.318]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:24.318]                         if (muffled) 
[13:35:24.318]                           invokeRestart("muffleMessage")
[13:35:24.318]                       }
[13:35:24.318]                       else if (inherits(cond, "warning")) {
[13:35:24.318]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:24.318]                         if (muffled) 
[13:35:24.318]                           invokeRestart("muffleWarning")
[13:35:24.318]                       }
[13:35:24.318]                       else if (inherits(cond, "condition")) {
[13:35:24.318]                         if (!is.null(pattern)) {
[13:35:24.318]                           computeRestarts <- base::computeRestarts
[13:35:24.318]                           grepl <- base::grepl
[13:35:24.318]                           restarts <- computeRestarts(cond)
[13:35:24.318]                           for (restart in restarts) {
[13:35:24.318]                             name <- restart$name
[13:35:24.318]                             if (is.null(name)) 
[13:35:24.318]                               next
[13:35:24.318]                             if (!grepl(pattern, name)) 
[13:35:24.318]                               next
[13:35:24.318]                             invokeRestart(restart)
[13:35:24.318]                             muffled <- TRUE
[13:35:24.318]                             break
[13:35:24.318]                           }
[13:35:24.318]                         }
[13:35:24.318]                       }
[13:35:24.318]                       invisible(muffled)
[13:35:24.318]                     }
[13:35:24.318]                     muffleCondition(cond, pattern = "^muffle")
[13:35:24.318]                   }
[13:35:24.318]                 }
[13:35:24.318]                 else {
[13:35:24.318]                   if (TRUE) {
[13:35:24.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:24.318]                     {
[13:35:24.318]                       inherits <- base::inherits
[13:35:24.318]                       invokeRestart <- base::invokeRestart
[13:35:24.318]                       is.null <- base::is.null
[13:35:24.318]                       muffled <- FALSE
[13:35:24.318]                       if (inherits(cond, "message")) {
[13:35:24.318]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:24.318]                         if (muffled) 
[13:35:24.318]                           invokeRestart("muffleMessage")
[13:35:24.318]                       }
[13:35:24.318]                       else if (inherits(cond, "warning")) {
[13:35:24.318]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:24.318]                         if (muffled) 
[13:35:24.318]                           invokeRestart("muffleWarning")
[13:35:24.318]                       }
[13:35:24.318]                       else if (inherits(cond, "condition")) {
[13:35:24.318]                         if (!is.null(pattern)) {
[13:35:24.318]                           computeRestarts <- base::computeRestarts
[13:35:24.318]                           grepl <- base::grepl
[13:35:24.318]                           restarts <- computeRestarts(cond)
[13:35:24.318]                           for (restart in restarts) {
[13:35:24.318]                             name <- restart$name
[13:35:24.318]                             if (is.null(name)) 
[13:35:24.318]                               next
[13:35:24.318]                             if (!grepl(pattern, name)) 
[13:35:24.318]                               next
[13:35:24.318]                             invokeRestart(restart)
[13:35:24.318]                             muffled <- TRUE
[13:35:24.318]                             break
[13:35:24.318]                           }
[13:35:24.318]                         }
[13:35:24.318]                       }
[13:35:24.318]                       invisible(muffled)
[13:35:24.318]                     }
[13:35:24.318]                     muffleCondition(cond, pattern = "^muffle")
[13:35:24.318]                   }
[13:35:24.318]                 }
[13:35:24.318]             }
[13:35:24.318]         }))
[13:35:24.318]     }, error = function(ex) {
[13:35:24.318]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:24.318]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:24.318]                 ...future.rng), started = ...future.startTime, 
[13:35:24.318]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:24.318]             version = "1.8"), class = "FutureResult")
[13:35:24.318]     }, finally = {
[13:35:24.318]         if (!identical(...future.workdir, getwd())) 
[13:35:24.318]             setwd(...future.workdir)
[13:35:24.318]         {
[13:35:24.318]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:24.318]                 ...future.oldOptions$nwarnings <- NULL
[13:35:24.318]             }
[13:35:24.318]             base::options(...future.oldOptions)
[13:35:24.318]             if (.Platform$OS.type == "windows") {
[13:35:24.318]                 old_names <- names(...future.oldEnvVars)
[13:35:24.318]                 envs <- base::Sys.getenv()
[13:35:24.318]                 names <- names(envs)
[13:35:24.318]                 common <- intersect(names, old_names)
[13:35:24.318]                 added <- setdiff(names, old_names)
[13:35:24.318]                 removed <- setdiff(old_names, names)
[13:35:24.318]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:24.318]                   envs[common]]
[13:35:24.318]                 NAMES <- toupper(changed)
[13:35:24.318]                 args <- list()
[13:35:24.318]                 for (kk in seq_along(NAMES)) {
[13:35:24.318]                   name <- changed[[kk]]
[13:35:24.318]                   NAME <- NAMES[[kk]]
[13:35:24.318]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:24.318]                     next
[13:35:24.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:24.318]                 }
[13:35:24.318]                 NAMES <- toupper(added)
[13:35:24.318]                 for (kk in seq_along(NAMES)) {
[13:35:24.318]                   name <- added[[kk]]
[13:35:24.318]                   NAME <- NAMES[[kk]]
[13:35:24.318]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:24.318]                     next
[13:35:24.318]                   args[[name]] <- ""
[13:35:24.318]                 }
[13:35:24.318]                 NAMES <- toupper(removed)
[13:35:24.318]                 for (kk in seq_along(NAMES)) {
[13:35:24.318]                   name <- removed[[kk]]
[13:35:24.318]                   NAME <- NAMES[[kk]]
[13:35:24.318]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:24.318]                     next
[13:35:24.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:24.318]                 }
[13:35:24.318]                 if (length(args) > 0) 
[13:35:24.318]                   base::do.call(base::Sys.setenv, args = args)
[13:35:24.318]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:24.318]             }
[13:35:24.318]             else {
[13:35:24.318]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:24.318]             }
[13:35:24.318]             {
[13:35:24.318]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:24.318]                   0L) {
[13:35:24.318]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:24.318]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:24.318]                   base::options(opts)
[13:35:24.318]                 }
[13:35:24.318]                 {
[13:35:24.318]                   {
[13:35:24.318]                     NULL
[13:35:24.318]                     RNGkind("Mersenne-Twister")
[13:35:24.318]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:24.318]                       inherits = FALSE)
[13:35:24.318]                   }
[13:35:24.318]                   options(future.plan = NULL)
[13:35:24.318]                   if (is.na(NA_character_)) 
[13:35:24.318]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:24.318]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:24.318]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:24.318]                     .init = FALSE)
[13:35:24.318]                 }
[13:35:24.318]             }
[13:35:24.318]         }
[13:35:24.318]     })
[13:35:24.318]     if (FALSE) {
[13:35:24.318]         base::sink(type = "output", split = FALSE)
[13:35:24.318]         if (NA) {
[13:35:24.318]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:24.318]         }
[13:35:24.318]         else {
[13:35:24.318]             ...future.result["stdout"] <- base::list(NULL)
[13:35:24.318]         }
[13:35:24.318]         base::close(...future.stdout)
[13:35:24.318]         ...future.stdout <- NULL
[13:35:24.318]     }
[13:35:24.318]     ...future.result$conditions <- ...future.conditions
[13:35:24.318]     ...future.result$finished <- base::Sys.time()
[13:35:24.318]     ...future.result
[13:35:24.318] }
[13:35:24.319] assign_globals() ...
[13:35:24.320] List of 5
[13:35:24.320]  $ ...future.FUN            :function (x)  
[13:35:24.320]  $ future.call.arguments    : list()
[13:35:24.320]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:24.320]  $ ...future.elements_ii    :List of 2
[13:35:24.320]   ..$ : int 1
[13:35:24.320]   ..$ : int 0
[13:35:24.320]  $ ...future.seeds_ii       : NULL
[13:35:24.320]  $ ...future.globals.maxSize: NULL
[13:35:24.320]  - attr(*, "where")=List of 5
[13:35:24.320]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:24.320]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:24.320]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:24.320]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:24.320]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:24.320]  - attr(*, "resolved")= logi FALSE
[13:35:24.320]  - attr(*, "total_size")= num 4720
[13:35:24.320]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:24.320]  - attr(*, "already-done")= logi TRUE
[13:35:24.325] - reassign environment for ‘...future.FUN’
[13:35:24.326] - copied ‘...future.FUN’ to environment
[13:35:24.326] - copied ‘future.call.arguments’ to environment
[13:35:24.326] - copied ‘...future.elements_ii’ to environment
[13:35:24.326] - copied ‘...future.seeds_ii’ to environment
[13:35:24.326] - copied ‘...future.globals.maxSize’ to environment
[13:35:24.326] assign_globals() ... done
[13:35:24.326] plan(): Setting new future strategy stack:
[13:35:24.326] List of future strategies:
[13:35:24.326] 1. sequential:
[13:35:24.326]    - args: function (..., envir = parent.frame())
[13:35:24.326]    - tweaked: FALSE
[13:35:24.326]    - call: NULL
[13:35:24.327] plan(): nbrOfWorkers() = 1
[13:35:24.828] plan(): Setting new future strategy stack:
[13:35:24.828] List of future strategies:
[13:35:24.828] 1. multicore:
[13:35:24.828]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:24.828]    - tweaked: FALSE
[13:35:24.828]    - call: plan(strategy)
[13:35:24.833] plan(): nbrOfWorkers() = 1
[13:35:24.833] SequentialFuture started (and completed)
[13:35:24.833] - Launch lazy future ... done
[13:35:24.833] run() for ‘SequentialFuture’ ... done
[13:35:24.833] Created future:
[13:35:24.833] SequentialFuture:
[13:35:24.833] Label: ‘future_lapply-1’
[13:35:24.833] Expression:
[13:35:24.833] {
[13:35:24.833]     do.call(function(...) {
[13:35:24.833]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:24.833]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:24.833]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:24.833]             on.exit(options(oopts), add = TRUE)
[13:35:24.833]         }
[13:35:24.833]         {
[13:35:24.833]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:24.833]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:24.833]                 ...future.FUN(...future.X_jj, ...)
[13:35:24.833]             })
[13:35:24.833]         }
[13:35:24.833]     }, args = future.call.arguments)
[13:35:24.833] }
[13:35:24.833] Lazy evaluation: FALSE
[13:35:24.833] Asynchronous evaluation: FALSE
[13:35:24.833] Local evaluation: TRUE
[13:35:24.833] Environment: R_GlobalEnv
[13:35:24.833] Capture standard output: NA
[13:35:24.833] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:24.833] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:24.833] Packages: <none>
[13:35:24.833] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:24.833] Resolved: TRUE
[13:35:24.833] Value: 112 bytes of class ‘list’
[13:35:24.833] Early signaling: FALSE
[13:35:24.833] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:24.833] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:24.835] Chunk #1 of 1 ... DONE
[13:35:24.835] Launching 1 futures (chunks) ... DONE
[13:35:24.835] Resolving 1 futures (chunks) ...
[13:35:24.835] resolve() on list ...
[13:35:24.835]  recursive: 0
[13:35:24.835]  length: 1
[13:35:24.835] 
[13:35:24.835] resolved() for ‘SequentialFuture’ ...
[13:35:24.836] - state: ‘finished’
[13:35:24.836] - run: TRUE
[13:35:24.836] - result: ‘FutureResult’
[13:35:24.836] resolved() for ‘SequentialFuture’ ... done
[13:35:24.836] Future #1
[13:35:24.836] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:24.836] - nx: 1
[13:35:24.836] - relay: TRUE
[13:35:24.836] - stdout: TRUE
[13:35:24.836] - signal: TRUE
[13:35:24.837] - resignal: FALSE
[13:35:24.837] - force: TRUE
[13:35:24.837] - relayed: [n=1] FALSE
[13:35:24.837] - queued futures: [n=1] FALSE
[13:35:24.837]  - until=1
[13:35:24.837]  - relaying element #1
[13:35:24.837] - relayed: [n=1] TRUE
[13:35:24.837] - queued futures: [n=1] TRUE
[13:35:24.837] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:24.837]  length: 0 (resolved future 1)
[13:35:24.838] Relaying remaining futures
[13:35:24.838] signalConditionsASAP(NULL, pos=0) ...
[13:35:24.838] - nx: 1
[13:35:24.838] - relay: TRUE
[13:35:24.838] - stdout: TRUE
[13:35:24.838] - signal: TRUE
[13:35:24.838] - resignal: FALSE
[13:35:24.838] - force: TRUE
[13:35:24.838] - relayed: [n=1] TRUE
[13:35:24.838] - queued futures: [n=1] TRUE
 - flush all
[13:35:24.838] - relayed: [n=1] TRUE
[13:35:24.839] - queued futures: [n=1] TRUE
[13:35:24.839] signalConditionsASAP(NULL, pos=0) ... done
[13:35:24.839] resolve() on list ... DONE
[13:35:24.839]  - Number of value chunks collected: 1
[13:35:24.839] Resolving 1 futures (chunks) ... DONE
[13:35:24.839] Reducing values from 1 chunks ...
[13:35:24.839]  - Number of values collected after concatenation: 2
[13:35:24.839]  - Number of values expected: 2
[13:35:24.839] Reducing values from 1 chunks ... DONE
[13:35:24.839] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[13:35:24.840] future_mapply() ...
[13:35:24.843] Number of chunks: 1
[13:35:24.843] getGlobalsAndPackagesXApply() ...
[13:35:24.843]  - future.globals: TRUE
[13:35:24.843] getGlobalsAndPackages() ...
[13:35:24.843] Searching for globals...
[13:35:24.845] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:35:24.845] Searching for globals ... DONE
[13:35:24.845] Resolving globals: FALSE
[13:35:24.846] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:35:24.846] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:35:24.846] - globals: [1] ‘FUN’
[13:35:24.846] 
[13:35:24.846] getGlobalsAndPackages() ... DONE
[13:35:24.846]  - globals found/used: [n=1] ‘FUN’
[13:35:24.847]  - needed namespaces: [n=0] 
[13:35:24.847] Finding globals ... DONE
[13:35:24.847] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:35:24.847] List of 2
[13:35:24.847]  $ ...future.FUN:function (x, y)  
[13:35:24.847]  $ MoreArgs     : NULL
[13:35:24.847]  - attr(*, "where")=List of 2
[13:35:24.847]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:24.847]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:35:24.847]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:24.847]  - attr(*, "resolved")= logi FALSE
[13:35:24.847]  - attr(*, "total_size")= num NA
[13:35:24.849] Packages to be attached in all futures: [n=0] 
[13:35:24.850] getGlobalsAndPackagesXApply() ... DONE
[13:35:24.850] Number of futures (= number of chunks): 1
[13:35:24.850] Launching 1 futures (chunks) ...
[13:35:24.850] Chunk #1 of 1 ...
[13:35:24.850]  - Finding globals in '...' for chunk #1 ...
[13:35:24.850] getGlobalsAndPackages() ...
[13:35:24.850] Searching for globals...
[13:35:24.851] 
[13:35:24.851] Searching for globals ... DONE
[13:35:24.851] - globals: [0] <none>
[13:35:24.851] getGlobalsAndPackages() ... DONE
[13:35:24.851]    + additional globals found: [n=0] 
[13:35:24.851]    + additional namespaces needed: [n=0] 
[13:35:24.851]  - Finding globals in '...' for chunk #1 ... DONE
[13:35:24.851]  - seeds: <none>
[13:35:24.853]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:24.853] getGlobalsAndPackages() ...
[13:35:24.853] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:24.853] Resolving globals: FALSE
[13:35:24.854] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:35:24.854] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:35:24.854] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:24.855] 
[13:35:24.855] getGlobalsAndPackages() ... DONE
[13:35:24.855] run() for ‘Future’ ...
[13:35:24.855] - state: ‘created’
[13:35:24.855] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:24.859] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:24.859] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:24.859]   - Field: ‘label’
[13:35:24.859]   - Field: ‘local’
[13:35:24.859]   - Field: ‘owner’
[13:35:24.859]   - Field: ‘envir’
[13:35:24.859]   - Field: ‘packages’
[13:35:24.859]   - Field: ‘gc’
[13:35:24.859]   - Field: ‘conditions’
[13:35:24.859]   - Field: ‘expr’
[13:35:24.860]   - Field: ‘uuid’
[13:35:24.860]   - Field: ‘seed’
[13:35:24.860]   - Field: ‘version’
[13:35:24.860]   - Field: ‘result’
[13:35:24.860]   - Field: ‘asynchronous’
[13:35:24.860]   - Field: ‘calls’
[13:35:24.860]   - Field: ‘globals’
[13:35:24.860]   - Field: ‘stdout’
[13:35:24.860]   - Field: ‘earlySignal’
[13:35:24.860]   - Field: ‘lazy’
[13:35:24.860]   - Field: ‘state’
[13:35:24.861] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:24.861] - Launch lazy future ...
[13:35:24.861] Packages needed by the future expression (n = 0): <none>
[13:35:24.861] Packages needed by future strategies (n = 0): <none>
[13:35:24.861] {
[13:35:24.861]     {
[13:35:24.861]         {
[13:35:24.861]             ...future.startTime <- base::Sys.time()
[13:35:24.861]             {
[13:35:24.861]                 {
[13:35:24.861]                   {
[13:35:24.861]                     base::local({
[13:35:24.861]                       has_future <- base::requireNamespace("future", 
[13:35:24.861]                         quietly = TRUE)
[13:35:24.861]                       if (has_future) {
[13:35:24.861]                         ns <- base::getNamespace("future")
[13:35:24.861]                         version <- ns[[".package"]][["version"]]
[13:35:24.861]                         if (is.null(version)) 
[13:35:24.861]                           version <- utils::packageVersion("future")
[13:35:24.861]                       }
[13:35:24.861]                       else {
[13:35:24.861]                         version <- NULL
[13:35:24.861]                       }
[13:35:24.861]                       if (!has_future || version < "1.8.0") {
[13:35:24.861]                         info <- base::c(r_version = base::gsub("R version ", 
[13:35:24.861]                           "", base::R.version$version.string), 
[13:35:24.861]                           platform = base::sprintf("%s (%s-bit)", 
[13:35:24.861]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:24.861]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:24.861]                             "release", "version")], collapse = " "), 
[13:35:24.861]                           hostname = base::Sys.info()[["nodename"]])
[13:35:24.861]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:35:24.861]                           info)
[13:35:24.861]                         info <- base::paste(info, collapse = "; ")
[13:35:24.861]                         if (!has_future) {
[13:35:24.861]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:24.861]                             info)
[13:35:24.861]                         }
[13:35:24.861]                         else {
[13:35:24.861]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:24.861]                             info, version)
[13:35:24.861]                         }
[13:35:24.861]                         base::stop(msg)
[13:35:24.861]                       }
[13:35:24.861]                     })
[13:35:24.861]                   }
[13:35:24.861]                   ...future.strategy.old <- future::plan("list")
[13:35:24.861]                   options(future.plan = NULL)
[13:35:24.861]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:24.861]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:24.861]                 }
[13:35:24.861]                 ...future.workdir <- getwd()
[13:35:24.861]             }
[13:35:24.861]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:24.861]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:24.861]         }
[13:35:24.861]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:24.861]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:24.861]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:24.861]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:24.861]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:24.861]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:24.861]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:24.861]             base::names(...future.oldOptions))
[13:35:24.861]     }
[13:35:24.861]     if (FALSE) {
[13:35:24.861]     }
[13:35:24.861]     else {
[13:35:24.861]         if (FALSE) {
[13:35:24.861]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:24.861]                 open = "w")
[13:35:24.861]         }
[13:35:24.861]         else {
[13:35:24.861]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:24.861]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:24.861]         }
[13:35:24.861]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:24.861]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:24.861]             base::sink(type = "output", split = FALSE)
[13:35:24.861]             base::close(...future.stdout)
[13:35:24.861]         }, add = TRUE)
[13:35:24.861]     }
[13:35:24.861]     ...future.frame <- base::sys.nframe()
[13:35:24.861]     ...future.conditions <- base::list()
[13:35:24.861]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:24.861]     if (FALSE) {
[13:35:24.861]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:24.861]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:24.861]     }
[13:35:24.861]     ...future.result <- base::tryCatch({
[13:35:24.861]         base::withCallingHandlers({
[13:35:24.861]             ...future.value <- base::withVisible(base::local({
[13:35:24.861]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:24.861]                 if (!identical(...future.globals.maxSize.org, 
[13:35:24.861]                   ...future.globals.maxSize)) {
[13:35:24.861]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:24.861]                   on.exit(options(oopts), add = TRUE)
[13:35:24.861]                 }
[13:35:24.861]                 {
[13:35:24.861]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:24.861]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:35:24.861]                     USE.NAMES = FALSE)
[13:35:24.861]                   do.call(mapply, args = args)
[13:35:24.861]                 }
[13:35:24.861]             }))
[13:35:24.861]             future::FutureResult(value = ...future.value$value, 
[13:35:24.861]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:24.861]                   ...future.rng), globalenv = if (FALSE) 
[13:35:24.861]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:24.861]                     ...future.globalenv.names))
[13:35:24.861]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:24.861]         }, condition = base::local({
[13:35:24.861]             c <- base::c
[13:35:24.861]             inherits <- base::inherits
[13:35:24.861]             invokeRestart <- base::invokeRestart
[13:35:24.861]             length <- base::length
[13:35:24.861]             list <- base::list
[13:35:24.861]             seq.int <- base::seq.int
[13:35:24.861]             signalCondition <- base::signalCondition
[13:35:24.861]             sys.calls <- base::sys.calls
[13:35:24.861]             `[[` <- base::`[[`
[13:35:24.861]             `+` <- base::`+`
[13:35:24.861]             `<<-` <- base::`<<-`
[13:35:24.861]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:24.861]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:24.861]                   3L)]
[13:35:24.861]             }
[13:35:24.861]             function(cond) {
[13:35:24.861]                 is_error <- inherits(cond, "error")
[13:35:24.861]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:24.861]                   NULL)
[13:35:24.861]                 if (is_error) {
[13:35:24.861]                   sessionInformation <- function() {
[13:35:24.861]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:24.861]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:24.861]                       search = base::search(), system = base::Sys.info())
[13:35:24.861]                   }
[13:35:24.861]                   ...future.conditions[[length(...future.conditions) + 
[13:35:24.861]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:24.861]                     cond$call), session = sessionInformation(), 
[13:35:24.861]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:24.861]                   signalCondition(cond)
[13:35:24.861]                 }
[13:35:24.861]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:24.861]                 "immediateCondition"))) {
[13:35:24.861]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:24.861]                   ...future.conditions[[length(...future.conditions) + 
[13:35:24.861]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:24.861]                   if (TRUE && !signal) {
[13:35:24.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:24.861]                     {
[13:35:24.861]                       inherits <- base::inherits
[13:35:24.861]                       invokeRestart <- base::invokeRestart
[13:35:24.861]                       is.null <- base::is.null
[13:35:24.861]                       muffled <- FALSE
[13:35:24.861]                       if (inherits(cond, "message")) {
[13:35:24.861]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:24.861]                         if (muffled) 
[13:35:24.861]                           invokeRestart("muffleMessage")
[13:35:24.861]                       }
[13:35:24.861]                       else if (inherits(cond, "warning")) {
[13:35:24.861]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:24.861]                         if (muffled) 
[13:35:24.861]                           invokeRestart("muffleWarning")
[13:35:24.861]                       }
[13:35:24.861]                       else if (inherits(cond, "condition")) {
[13:35:24.861]                         if (!is.null(pattern)) {
[13:35:24.861]                           computeRestarts <- base::computeRestarts
[13:35:24.861]                           grepl <- base::grepl
[13:35:24.861]                           restarts <- computeRestarts(cond)
[13:35:24.861]                           for (restart in restarts) {
[13:35:24.861]                             name <- restart$name
[13:35:24.861]                             if (is.null(name)) 
[13:35:24.861]                               next
[13:35:24.861]                             if (!grepl(pattern, name)) 
[13:35:24.861]                               next
[13:35:24.861]                             invokeRestart(restart)
[13:35:24.861]                             muffled <- TRUE
[13:35:24.861]                             break
[13:35:24.861]                           }
[13:35:24.861]                         }
[13:35:24.861]                       }
[13:35:24.861]                       invisible(muffled)
[13:35:24.861]                     }
[13:35:24.861]                     muffleCondition(cond, pattern = "^muffle")
[13:35:24.861]                   }
[13:35:24.861]                 }
[13:35:24.861]                 else {
[13:35:24.861]                   if (TRUE) {
[13:35:24.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:24.861]                     {
[13:35:24.861]                       inherits <- base::inherits
[13:35:24.861]                       invokeRestart <- base::invokeRestart
[13:35:24.861]                       is.null <- base::is.null
[13:35:24.861]                       muffled <- FALSE
[13:35:24.861]                       if (inherits(cond, "message")) {
[13:35:24.861]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:24.861]                         if (muffled) 
[13:35:24.861]                           invokeRestart("muffleMessage")
[13:35:24.861]                       }
[13:35:24.861]                       else if (inherits(cond, "warning")) {
[13:35:24.861]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:24.861]                         if (muffled) 
[13:35:24.861]                           invokeRestart("muffleWarning")
[13:35:24.861]                       }
[13:35:24.861]                       else if (inherits(cond, "condition")) {
[13:35:24.861]                         if (!is.null(pattern)) {
[13:35:24.861]                           computeRestarts <- base::computeRestarts
[13:35:24.861]                           grepl <- base::grepl
[13:35:24.861]                           restarts <- computeRestarts(cond)
[13:35:24.861]                           for (restart in restarts) {
[13:35:24.861]                             name <- restart$name
[13:35:24.861]                             if (is.null(name)) 
[13:35:24.861]                               next
[13:35:24.861]                             if (!grepl(pattern, name)) 
[13:35:24.861]                               next
[13:35:24.861]                             invokeRestart(restart)
[13:35:24.861]                             muffled <- TRUE
[13:35:24.861]                             break
[13:35:24.861]                           }
[13:35:24.861]                         }
[13:35:24.861]                       }
[13:35:24.861]                       invisible(muffled)
[13:35:24.861]                     }
[13:35:24.861]                     muffleCondition(cond, pattern = "^muffle")
[13:35:24.861]                   }
[13:35:24.861]                 }
[13:35:24.861]             }
[13:35:24.861]         }))
[13:35:24.861]     }, error = function(ex) {
[13:35:24.861]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:24.861]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:24.861]                 ...future.rng), started = ...future.startTime, 
[13:35:24.861]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:24.861]             version = "1.8"), class = "FutureResult")
[13:35:24.861]     }, finally = {
[13:35:24.861]         if (!identical(...future.workdir, getwd())) 
[13:35:24.861]             setwd(...future.workdir)
[13:35:24.861]         {
[13:35:24.861]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:24.861]                 ...future.oldOptions$nwarnings <- NULL
[13:35:24.861]             }
[13:35:24.861]             base::options(...future.oldOptions)
[13:35:24.861]             if (.Platform$OS.type == "windows") {
[13:35:24.861]                 old_names <- names(...future.oldEnvVars)
[13:35:24.861]                 envs <- base::Sys.getenv()
[13:35:24.861]                 names <- names(envs)
[13:35:24.861]                 common <- intersect(names, old_names)
[13:35:24.861]                 added <- setdiff(names, old_names)
[13:35:24.861]                 removed <- setdiff(old_names, names)
[13:35:24.861]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:24.861]                   envs[common]]
[13:35:24.861]                 NAMES <- toupper(changed)
[13:35:24.861]                 args <- list()
[13:35:24.861]                 for (kk in seq_along(NAMES)) {
[13:35:24.861]                   name <- changed[[kk]]
[13:35:24.861]                   NAME <- NAMES[[kk]]
[13:35:24.861]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:24.861]                     next
[13:35:24.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:24.861]                 }
[13:35:24.861]                 NAMES <- toupper(added)
[13:35:24.861]                 for (kk in seq_along(NAMES)) {
[13:35:24.861]                   name <- added[[kk]]
[13:35:24.861]                   NAME <- NAMES[[kk]]
[13:35:24.861]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:24.861]                     next
[13:35:24.861]                   args[[name]] <- ""
[13:35:24.861]                 }
[13:35:24.861]                 NAMES <- toupper(removed)
[13:35:24.861]                 for (kk in seq_along(NAMES)) {
[13:35:24.861]                   name <- removed[[kk]]
[13:35:24.861]                   NAME <- NAMES[[kk]]
[13:35:24.861]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:24.861]                     next
[13:35:24.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:24.861]                 }
[13:35:24.861]                 if (length(args) > 0) 
[13:35:24.861]                   base::do.call(base::Sys.setenv, args = args)
[13:35:24.861]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:24.861]             }
[13:35:24.861]             else {
[13:35:24.861]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:24.861]             }
[13:35:24.861]             {
[13:35:24.861]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:24.861]                   0L) {
[13:35:24.861]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:24.861]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:24.861]                   base::options(opts)
[13:35:24.861]                 }
[13:35:24.861]                 {
[13:35:24.861]                   {
[13:35:24.861]                     NULL
[13:35:24.861]                     RNGkind("Mersenne-Twister")
[13:35:24.861]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:24.861]                       inherits = FALSE)
[13:35:24.861]                   }
[13:35:24.861]                   options(future.plan = NULL)
[13:35:24.861]                   if (is.na(NA_character_)) 
[13:35:24.861]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:24.861]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:24.861]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:24.861]                     .init = FALSE)
[13:35:24.861]                 }
[13:35:24.861]             }
[13:35:24.861]         }
[13:35:24.861]     })
[13:35:24.861]     if (TRUE) {
[13:35:24.861]         base::sink(type = "output", split = FALSE)
[13:35:24.861]         if (FALSE) {
[13:35:24.861]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:24.861]         }
[13:35:24.861]         else {
[13:35:24.861]             ...future.result["stdout"] <- base::list(NULL)
[13:35:24.861]         }
[13:35:24.861]         base::close(...future.stdout)
[13:35:24.861]         ...future.stdout <- NULL
[13:35:24.861]     }
[13:35:24.861]     ...future.result$conditions <- ...future.conditions
[13:35:24.861]     ...future.result$finished <- base::Sys.time()
[13:35:24.861]     ...future.result
[13:35:24.861] }
[13:35:24.863] assign_globals() ...
[13:35:24.863] List of 5
[13:35:24.863]  $ ...future.FUN            :function (x, y)  
[13:35:24.863]  $ MoreArgs                 : NULL
[13:35:24.863]  $ ...future.elements_ii    :List of 2
[13:35:24.863]   ..$ :List of 2
[13:35:24.863]   .. ..$ : int 1
[13:35:24.863]   .. ..$ : int 0
[13:35:24.863]   ..$ :List of 2
[13:35:24.863]   .. ..$ : int 0
[13:35:24.863]   .. ..$ : int 1
[13:35:24.863]  $ ...future.seeds_ii       : NULL
[13:35:24.863]  $ ...future.globals.maxSize: NULL
[13:35:24.863]  - attr(*, "where")=List of 5
[13:35:24.863]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:24.863]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:35:24.863]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:24.863]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:24.863]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:24.863]  - attr(*, "resolved")= logi FALSE
[13:35:24.863]  - attr(*, "total_size")= num 6480
[13:35:24.863]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:24.863]  - attr(*, "already-done")= logi TRUE
[13:35:24.868] - reassign environment for ‘...future.FUN’
[13:35:24.869] - copied ‘...future.FUN’ to environment
[13:35:24.869] - copied ‘MoreArgs’ to environment
[13:35:24.869] - copied ‘...future.elements_ii’ to environment
[13:35:24.869] - copied ‘...future.seeds_ii’ to environment
[13:35:24.869] - copied ‘...future.globals.maxSize’ to environment
[13:35:24.869] assign_globals() ... done
[13:35:24.869] plan(): Setting new future strategy stack:
[13:35:24.869] List of future strategies:
[13:35:24.869] 1. sequential:
[13:35:24.869]    - args: function (..., envir = parent.frame())
[13:35:24.869]    - tweaked: FALSE
[13:35:24.869]    - call: NULL
[13:35:24.870] plan(): nbrOfWorkers() = 1
[13:35:25.371] plan(): Setting new future strategy stack:
[13:35:25.371] List of future strategies:
[13:35:25.371] 1. multicore:
[13:35:25.371]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:25.371]    - tweaked: FALSE
[13:35:25.371]    - call: plan(strategy)
[13:35:25.376] plan(): nbrOfWorkers() = 1
[13:35:25.376] SequentialFuture started (and completed)
[13:35:25.376] - Launch lazy future ... done
[13:35:25.376] run() for ‘SequentialFuture’ ... done
[13:35:25.376] Created future:
[13:35:25.376] SequentialFuture:
[13:35:25.376] Label: ‘future_mapply-1’
[13:35:25.376] Expression:
[13:35:25.376] {
[13:35:25.376]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:25.376]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:25.376]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:25.376]         on.exit(options(oopts), add = TRUE)
[13:35:25.376]     }
[13:35:25.376]     {
[13:35:25.376]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:25.376]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:35:25.376]         do.call(mapply, args = args)
[13:35:25.376]     }
[13:35:25.376] }
[13:35:25.376] Lazy evaluation: FALSE
[13:35:25.376] Asynchronous evaluation: FALSE
[13:35:25.376] Local evaluation: TRUE
[13:35:25.376] Environment: R_GlobalEnv
[13:35:25.376] Capture standard output: FALSE
[13:35:25.376] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:25.376] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:25.376] Packages: <none>
[13:35:25.376] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:25.376] Resolved: TRUE
[13:35:25.376] Value: 224 bytes of class ‘list’
[13:35:25.376] Early signaling: FALSE
[13:35:25.376] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:25.376] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:25.378] Chunk #1 of 1 ... DONE
[13:35:25.378] Launching 1 futures (chunks) ... DONE
[13:35:25.378] Resolving 1 futures (chunks) ...
[13:35:25.378] resolve() on list ...
[13:35:25.378]  recursive: 0
[13:35:25.378]  length: 1
[13:35:25.378] 
[13:35:25.378] resolved() for ‘SequentialFuture’ ...
[13:35:25.379] - state: ‘finished’
[13:35:25.379] - run: TRUE
[13:35:25.379] - result: ‘FutureResult’
[13:35:25.379] resolved() for ‘SequentialFuture’ ... done
[13:35:25.379] Future #1
[13:35:25.379] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:25.379] - nx: 1
[13:35:25.379] - relay: TRUE
[13:35:25.379] - stdout: TRUE
[13:35:25.379] - signal: TRUE
[13:35:25.380] - resignal: FALSE
[13:35:25.380] - force: TRUE
[13:35:25.380] - relayed: [n=1] FALSE
[13:35:25.380] - queued futures: [n=1] FALSE
[13:35:25.380]  - until=1
[13:35:25.380]  - relaying element #1
[13:35:25.380] - relayed: [n=1] TRUE
[13:35:25.380] - queued futures: [n=1] TRUE
[13:35:25.380] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:25.381]  length: 0 (resolved future 1)
[13:35:25.381] Relaying remaining futures
[13:35:25.381] signalConditionsASAP(NULL, pos=0) ...
[13:35:25.381] - nx: 1
[13:35:25.381] - relay: TRUE
[13:35:25.381] - stdout: TRUE
[13:35:25.381] - signal: TRUE
[13:35:25.381] - resignal: FALSE
[13:35:25.381] - force: TRUE
[13:35:25.381] - relayed: [n=1] TRUE
[13:35:25.381] - queued futures: [n=1] TRUE
 - flush all
[13:35:25.381] - relayed: [n=1] TRUE
[13:35:25.382] - queued futures: [n=1] TRUE
[13:35:25.382] signalConditionsASAP(NULL, pos=0) ... done
[13:35:25.382] resolve() on list ... DONE
[13:35:25.382]  - Number of value chunks collected: 1
[13:35:25.382] Resolving 1 futures (chunks) ... DONE
[13:35:25.382] Reducing values from 1 chunks ...
[13:35:25.384]  - Number of values collected after concatenation: 2
[13:35:25.384]  - Number of values expected: 2
[13:35:25.384] Reducing values from 1 chunks ... DONE
[13:35:25.385] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[13:35:25.385] future_mapply() ...
[13:35:25.388] Number of chunks: 1
[13:35:25.388] getGlobalsAndPackagesXApply() ...
[13:35:25.388]  - future.globals: TRUE
[13:35:25.388] getGlobalsAndPackages() ...
[13:35:25.389] Searching for globals...
[13:35:25.390] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:35:25.390] Searching for globals ... DONE
[13:35:25.390] Resolving globals: FALSE
[13:35:25.391] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:35:25.391] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:35:25.391] - globals: [1] ‘FUN’
[13:35:25.391] 
[13:35:25.391] getGlobalsAndPackages() ... DONE
[13:35:25.392]  - globals found/used: [n=1] ‘FUN’
[13:35:25.392]  - needed namespaces: [n=0] 
[13:35:25.392] Finding globals ... DONE
[13:35:25.392] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:35:25.392] List of 2
[13:35:25.392]  $ ...future.FUN:function (x, y)  
[13:35:25.392]  $ MoreArgs     : NULL
[13:35:25.392]  - attr(*, "where")=List of 2
[13:35:25.392]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:25.392]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:35:25.392]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:25.392]  - attr(*, "resolved")= logi FALSE
[13:35:25.392]  - attr(*, "total_size")= num NA
[13:35:25.395] Packages to be attached in all futures: [n=0] 
[13:35:25.395] getGlobalsAndPackagesXApply() ... DONE
[13:35:25.395] Number of futures (= number of chunks): 1
[13:35:25.395] Launching 1 futures (chunks) ...
[13:35:25.395] Chunk #1 of 1 ...
[13:35:25.395]  - Finding globals in '...' for chunk #1 ...
[13:35:25.395] getGlobalsAndPackages() ...
[13:35:25.395] Searching for globals...
[13:35:25.396] 
[13:35:25.396] Searching for globals ... DONE
[13:35:25.396] - globals: [0] <none>
[13:35:25.396] getGlobalsAndPackages() ... DONE
[13:35:25.396]    + additional globals found: [n=0] 
[13:35:25.396]    + additional namespaces needed: [n=0] 
[13:35:25.396]  - Finding globals in '...' for chunk #1 ... DONE
[13:35:25.396]  - seeds: <none>
[13:35:25.396]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:25.396] getGlobalsAndPackages() ...
[13:35:25.397] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:25.397] Resolving globals: FALSE
[13:35:25.397] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:35:25.398] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:35:25.398] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:25.398] 
[13:35:25.398] getGlobalsAndPackages() ... DONE
[13:35:25.398] run() for ‘Future’ ...
[13:35:25.398] - state: ‘created’
[13:35:25.398] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:25.402] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:25.402] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:25.402]   - Field: ‘label’
[13:35:25.402]   - Field: ‘local’
[13:35:25.402]   - Field: ‘owner’
[13:35:25.402]   - Field: ‘envir’
[13:35:25.402]   - Field: ‘packages’
[13:35:25.403]   - Field: ‘gc’
[13:35:25.403]   - Field: ‘conditions’
[13:35:25.403]   - Field: ‘expr’
[13:35:25.403]   - Field: ‘uuid’
[13:35:25.403]   - Field: ‘seed’
[13:35:25.403]   - Field: ‘version’
[13:35:25.403]   - Field: ‘result’
[13:35:25.403]   - Field: ‘asynchronous’
[13:35:25.403]   - Field: ‘calls’
[13:35:25.403]   - Field: ‘globals’
[13:35:25.403]   - Field: ‘stdout’
[13:35:25.404]   - Field: ‘earlySignal’
[13:35:25.404]   - Field: ‘lazy’
[13:35:25.404]   - Field: ‘state’
[13:35:25.404] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:25.404] - Launch lazy future ...
[13:35:25.404] Packages needed by the future expression (n = 0): <none>
[13:35:25.404] Packages needed by future strategies (n = 0): <none>
[13:35:25.405] {
[13:35:25.405]     {
[13:35:25.405]         {
[13:35:25.405]             ...future.startTime <- base::Sys.time()
[13:35:25.405]             {
[13:35:25.405]                 {
[13:35:25.405]                   {
[13:35:25.405]                     base::local({
[13:35:25.405]                       has_future <- base::requireNamespace("future", 
[13:35:25.405]                         quietly = TRUE)
[13:35:25.405]                       if (has_future) {
[13:35:25.405]                         ns <- base::getNamespace("future")
[13:35:25.405]                         version <- ns[[".package"]][["version"]]
[13:35:25.405]                         if (is.null(version)) 
[13:35:25.405]                           version <- utils::packageVersion("future")
[13:35:25.405]                       }
[13:35:25.405]                       else {
[13:35:25.405]                         version <- NULL
[13:35:25.405]                       }
[13:35:25.405]                       if (!has_future || version < "1.8.0") {
[13:35:25.405]                         info <- base::c(r_version = base::gsub("R version ", 
[13:35:25.405]                           "", base::R.version$version.string), 
[13:35:25.405]                           platform = base::sprintf("%s (%s-bit)", 
[13:35:25.405]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:25.405]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:25.405]                             "release", "version")], collapse = " "), 
[13:35:25.405]                           hostname = base::Sys.info()[["nodename"]])
[13:35:25.405]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:35:25.405]                           info)
[13:35:25.405]                         info <- base::paste(info, collapse = "; ")
[13:35:25.405]                         if (!has_future) {
[13:35:25.405]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:25.405]                             info)
[13:35:25.405]                         }
[13:35:25.405]                         else {
[13:35:25.405]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:25.405]                             info, version)
[13:35:25.405]                         }
[13:35:25.405]                         base::stop(msg)
[13:35:25.405]                       }
[13:35:25.405]                     })
[13:35:25.405]                   }
[13:35:25.405]                   ...future.strategy.old <- future::plan("list")
[13:35:25.405]                   options(future.plan = NULL)
[13:35:25.405]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:25.405]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:25.405]                 }
[13:35:25.405]                 ...future.workdir <- getwd()
[13:35:25.405]             }
[13:35:25.405]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:25.405]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:25.405]         }
[13:35:25.405]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:25.405]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:25.405]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:25.405]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:25.405]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:25.405]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:25.405]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:25.405]             base::names(...future.oldOptions))
[13:35:25.405]     }
[13:35:25.405]     if (FALSE) {
[13:35:25.405]     }
[13:35:25.405]     else {
[13:35:25.405]         if (TRUE) {
[13:35:25.405]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:25.405]                 open = "w")
[13:35:25.405]         }
[13:35:25.405]         else {
[13:35:25.405]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:25.405]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:25.405]         }
[13:35:25.405]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:25.405]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:25.405]             base::sink(type = "output", split = FALSE)
[13:35:25.405]             base::close(...future.stdout)
[13:35:25.405]         }, add = TRUE)
[13:35:25.405]     }
[13:35:25.405]     ...future.frame <- base::sys.nframe()
[13:35:25.405]     ...future.conditions <- base::list()
[13:35:25.405]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:25.405]     if (FALSE) {
[13:35:25.405]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:25.405]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:25.405]     }
[13:35:25.405]     ...future.result <- base::tryCatch({
[13:35:25.405]         base::withCallingHandlers({
[13:35:25.405]             ...future.value <- base::withVisible(base::local({
[13:35:25.405]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:25.405]                 if (!identical(...future.globals.maxSize.org, 
[13:35:25.405]                   ...future.globals.maxSize)) {
[13:35:25.405]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:25.405]                   on.exit(options(oopts), add = TRUE)
[13:35:25.405]                 }
[13:35:25.405]                 {
[13:35:25.405]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:25.405]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:35:25.405]                     USE.NAMES = FALSE)
[13:35:25.405]                   do.call(mapply, args = args)
[13:35:25.405]                 }
[13:35:25.405]             }))
[13:35:25.405]             future::FutureResult(value = ...future.value$value, 
[13:35:25.405]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:25.405]                   ...future.rng), globalenv = if (FALSE) 
[13:35:25.405]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:25.405]                     ...future.globalenv.names))
[13:35:25.405]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:25.405]         }, condition = base::local({
[13:35:25.405]             c <- base::c
[13:35:25.405]             inherits <- base::inherits
[13:35:25.405]             invokeRestart <- base::invokeRestart
[13:35:25.405]             length <- base::length
[13:35:25.405]             list <- base::list
[13:35:25.405]             seq.int <- base::seq.int
[13:35:25.405]             signalCondition <- base::signalCondition
[13:35:25.405]             sys.calls <- base::sys.calls
[13:35:25.405]             `[[` <- base::`[[`
[13:35:25.405]             `+` <- base::`+`
[13:35:25.405]             `<<-` <- base::`<<-`
[13:35:25.405]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:25.405]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:25.405]                   3L)]
[13:35:25.405]             }
[13:35:25.405]             function(cond) {
[13:35:25.405]                 is_error <- inherits(cond, "error")
[13:35:25.405]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:25.405]                   NULL)
[13:35:25.405]                 if (is_error) {
[13:35:25.405]                   sessionInformation <- function() {
[13:35:25.405]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:25.405]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:25.405]                       search = base::search(), system = base::Sys.info())
[13:35:25.405]                   }
[13:35:25.405]                   ...future.conditions[[length(...future.conditions) + 
[13:35:25.405]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:25.405]                     cond$call), session = sessionInformation(), 
[13:35:25.405]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:25.405]                   signalCondition(cond)
[13:35:25.405]                 }
[13:35:25.405]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:25.405]                 "immediateCondition"))) {
[13:35:25.405]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:25.405]                   ...future.conditions[[length(...future.conditions) + 
[13:35:25.405]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:25.405]                   if (TRUE && !signal) {
[13:35:25.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:25.405]                     {
[13:35:25.405]                       inherits <- base::inherits
[13:35:25.405]                       invokeRestart <- base::invokeRestart
[13:35:25.405]                       is.null <- base::is.null
[13:35:25.405]                       muffled <- FALSE
[13:35:25.405]                       if (inherits(cond, "message")) {
[13:35:25.405]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:25.405]                         if (muffled) 
[13:35:25.405]                           invokeRestart("muffleMessage")
[13:35:25.405]                       }
[13:35:25.405]                       else if (inherits(cond, "warning")) {
[13:35:25.405]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:25.405]                         if (muffled) 
[13:35:25.405]                           invokeRestart("muffleWarning")
[13:35:25.405]                       }
[13:35:25.405]                       else if (inherits(cond, "condition")) {
[13:35:25.405]                         if (!is.null(pattern)) {
[13:35:25.405]                           computeRestarts <- base::computeRestarts
[13:35:25.405]                           grepl <- base::grepl
[13:35:25.405]                           restarts <- computeRestarts(cond)
[13:35:25.405]                           for (restart in restarts) {
[13:35:25.405]                             name <- restart$name
[13:35:25.405]                             if (is.null(name)) 
[13:35:25.405]                               next
[13:35:25.405]                             if (!grepl(pattern, name)) 
[13:35:25.405]                               next
[13:35:25.405]                             invokeRestart(restart)
[13:35:25.405]                             muffled <- TRUE
[13:35:25.405]                             break
[13:35:25.405]                           }
[13:35:25.405]                         }
[13:35:25.405]                       }
[13:35:25.405]                       invisible(muffled)
[13:35:25.405]                     }
[13:35:25.405]                     muffleCondition(cond, pattern = "^muffle")
[13:35:25.405]                   }
[13:35:25.405]                 }
[13:35:25.405]                 else {
[13:35:25.405]                   if (TRUE) {
[13:35:25.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:25.405]                     {
[13:35:25.405]                       inherits <- base::inherits
[13:35:25.405]                       invokeRestart <- base::invokeRestart
[13:35:25.405]                       is.null <- base::is.null
[13:35:25.405]                       muffled <- FALSE
[13:35:25.405]                       if (inherits(cond, "message")) {
[13:35:25.405]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:25.405]                         if (muffled) 
[13:35:25.405]                           invokeRestart("muffleMessage")
[13:35:25.405]                       }
[13:35:25.405]                       else if (inherits(cond, "warning")) {
[13:35:25.405]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:25.405]                         if (muffled) 
[13:35:25.405]                           invokeRestart("muffleWarning")
[13:35:25.405]                       }
[13:35:25.405]                       else if (inherits(cond, "condition")) {
[13:35:25.405]                         if (!is.null(pattern)) {
[13:35:25.405]                           computeRestarts <- base::computeRestarts
[13:35:25.405]                           grepl <- base::grepl
[13:35:25.405]                           restarts <- computeRestarts(cond)
[13:35:25.405]                           for (restart in restarts) {
[13:35:25.405]                             name <- restart$name
[13:35:25.405]                             if (is.null(name)) 
[13:35:25.405]                               next
[13:35:25.405]                             if (!grepl(pattern, name)) 
[13:35:25.405]                               next
[13:35:25.405]                             invokeRestart(restart)
[13:35:25.405]                             muffled <- TRUE
[13:35:25.405]                             break
[13:35:25.405]                           }
[13:35:25.405]                         }
[13:35:25.405]                       }
[13:35:25.405]                       invisible(muffled)
[13:35:25.405]                     }
[13:35:25.405]                     muffleCondition(cond, pattern = "^muffle")
[13:35:25.405]                   }
[13:35:25.405]                 }
[13:35:25.405]             }
[13:35:25.405]         }))
[13:35:25.405]     }, error = function(ex) {
[13:35:25.405]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:25.405]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:25.405]                 ...future.rng), started = ...future.startTime, 
[13:35:25.405]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:25.405]             version = "1.8"), class = "FutureResult")
[13:35:25.405]     }, finally = {
[13:35:25.405]         if (!identical(...future.workdir, getwd())) 
[13:35:25.405]             setwd(...future.workdir)
[13:35:25.405]         {
[13:35:25.405]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:25.405]                 ...future.oldOptions$nwarnings <- NULL
[13:35:25.405]             }
[13:35:25.405]             base::options(...future.oldOptions)
[13:35:25.405]             if (.Platform$OS.type == "windows") {
[13:35:25.405]                 old_names <- names(...future.oldEnvVars)
[13:35:25.405]                 envs <- base::Sys.getenv()
[13:35:25.405]                 names <- names(envs)
[13:35:25.405]                 common <- intersect(names, old_names)
[13:35:25.405]                 added <- setdiff(names, old_names)
[13:35:25.405]                 removed <- setdiff(old_names, names)
[13:35:25.405]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:25.405]                   envs[common]]
[13:35:25.405]                 NAMES <- toupper(changed)
[13:35:25.405]                 args <- list()
[13:35:25.405]                 for (kk in seq_along(NAMES)) {
[13:35:25.405]                   name <- changed[[kk]]
[13:35:25.405]                   NAME <- NAMES[[kk]]
[13:35:25.405]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:25.405]                     next
[13:35:25.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:25.405]                 }
[13:35:25.405]                 NAMES <- toupper(added)
[13:35:25.405]                 for (kk in seq_along(NAMES)) {
[13:35:25.405]                   name <- added[[kk]]
[13:35:25.405]                   NAME <- NAMES[[kk]]
[13:35:25.405]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:25.405]                     next
[13:35:25.405]                   args[[name]] <- ""
[13:35:25.405]                 }
[13:35:25.405]                 NAMES <- toupper(removed)
[13:35:25.405]                 for (kk in seq_along(NAMES)) {
[13:35:25.405]                   name <- removed[[kk]]
[13:35:25.405]                   NAME <- NAMES[[kk]]
[13:35:25.405]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:25.405]                     next
[13:35:25.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:25.405]                 }
[13:35:25.405]                 if (length(args) > 0) 
[13:35:25.405]                   base::do.call(base::Sys.setenv, args = args)
[13:35:25.405]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:25.405]             }
[13:35:25.405]             else {
[13:35:25.405]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:25.405]             }
[13:35:25.405]             {
[13:35:25.405]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:25.405]                   0L) {
[13:35:25.405]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:25.405]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:25.405]                   base::options(opts)
[13:35:25.405]                 }
[13:35:25.405]                 {
[13:35:25.405]                   {
[13:35:25.405]                     NULL
[13:35:25.405]                     RNGkind("Mersenne-Twister")
[13:35:25.405]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:25.405]                       inherits = FALSE)
[13:35:25.405]                   }
[13:35:25.405]                   options(future.plan = NULL)
[13:35:25.405]                   if (is.na(NA_character_)) 
[13:35:25.405]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:25.405]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:25.405]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:25.405]                     .init = FALSE)
[13:35:25.405]                 }
[13:35:25.405]             }
[13:35:25.405]         }
[13:35:25.405]     })
[13:35:25.405]     if (TRUE) {
[13:35:25.405]         base::sink(type = "output", split = FALSE)
[13:35:25.405]         if (TRUE) {
[13:35:25.405]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:25.405]         }
[13:35:25.405]         else {
[13:35:25.405]             ...future.result["stdout"] <- base::list(NULL)
[13:35:25.405]         }
[13:35:25.405]         base::close(...future.stdout)
[13:35:25.405]         ...future.stdout <- NULL
[13:35:25.405]     }
[13:35:25.405]     ...future.result$conditions <- ...future.conditions
[13:35:25.405]     ...future.result$finished <- base::Sys.time()
[13:35:25.405]     ...future.result
[13:35:25.405] }
[13:35:25.406] assign_globals() ...
[13:35:25.406] List of 5
[13:35:25.406]  $ ...future.FUN            :function (x, y)  
[13:35:25.406]  $ MoreArgs                 : NULL
[13:35:25.406]  $ ...future.elements_ii    :List of 2
[13:35:25.406]   ..$ :List of 2
[13:35:25.406]   .. ..$ : int 1
[13:35:25.406]   .. ..$ : int 0
[13:35:25.406]   ..$ :List of 2
[13:35:25.406]   .. ..$ : int 0
[13:35:25.406]   .. ..$ : int 1
[13:35:25.406]  $ ...future.seeds_ii       : NULL
[13:35:25.406]  $ ...future.globals.maxSize: NULL
[13:35:25.406]  - attr(*, "where")=List of 5
[13:35:25.406]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:25.406]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:35:25.406]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:25.406]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:25.406]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:25.406]  - attr(*, "resolved")= logi FALSE
[13:35:25.406]  - attr(*, "total_size")= num 6480
[13:35:25.406]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:25.406]  - attr(*, "already-done")= logi TRUE
[13:35:25.413] - reassign environment for ‘...future.FUN’
[13:35:25.413] - copied ‘...future.FUN’ to environment
[13:35:25.413] - copied ‘MoreArgs’ to environment
[13:35:25.413] - copied ‘...future.elements_ii’ to environment
[13:35:25.414] - copied ‘...future.seeds_ii’ to environment
[13:35:25.414] - copied ‘...future.globals.maxSize’ to environment
[13:35:25.414] assign_globals() ... done
[13:35:25.414] plan(): Setting new future strategy stack:
[13:35:25.414] List of future strategies:
[13:35:25.414] 1. sequential:
[13:35:25.414]    - args: function (..., envir = parent.frame())
[13:35:25.414]    - tweaked: FALSE
[13:35:25.414]    - call: NULL
[13:35:25.414] plan(): nbrOfWorkers() = 1
[13:35:25.916] plan(): Setting new future strategy stack:
[13:35:25.916] List of future strategies:
[13:35:25.916] 1. multicore:
[13:35:25.916]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:25.916]    - tweaked: FALSE
[13:35:25.916]    - call: plan(strategy)
[13:35:25.920] plan(): nbrOfWorkers() = 1
[13:35:25.920] SequentialFuture started (and completed)
[13:35:25.920] - Launch lazy future ... done
[13:35:25.921] run() for ‘SequentialFuture’ ... done
[13:35:25.921] Created future:
[13:35:25.921] SequentialFuture:
[13:35:25.921] Label: ‘future_mapply-1’
[13:35:25.921] Expression:
[13:35:25.921] {
[13:35:25.921]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:25.921]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:25.921]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:25.921]         on.exit(options(oopts), add = TRUE)
[13:35:25.921]     }
[13:35:25.921]     {
[13:35:25.921]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:25.921]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:35:25.921]         do.call(mapply, args = args)
[13:35:25.921]     }
[13:35:25.921] }
[13:35:25.921] Lazy evaluation: FALSE
[13:35:25.921] Asynchronous evaluation: FALSE
[13:35:25.921] Local evaluation: TRUE
[13:35:25.921] Environment: R_GlobalEnv
[13:35:25.921] Capture standard output: TRUE
[13:35:25.921] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:25.921] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:25.921] Packages: <none>
[13:35:25.921] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:25.921] Resolved: TRUE
[13:35:25.921] Value: 224 bytes of class ‘list’
[13:35:25.921] Early signaling: FALSE
[13:35:25.921] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:25.921] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:25.922] Chunk #1 of 1 ... DONE
[13:35:25.922] Launching 1 futures (chunks) ... DONE
[13:35:25.922] Resolving 1 futures (chunks) ...
[13:35:25.922] resolve() on list ...
[13:35:25.922]  recursive: 0
[13:35:25.922]  length: 1
[13:35:25.922] 
[13:35:25.923] resolved() for ‘SequentialFuture’ ...
[13:35:25.923] - state: ‘finished’
[13:35:25.923] - run: TRUE
[13:35:25.923] - result: ‘FutureResult’
[13:35:25.923] resolved() for ‘SequentialFuture’ ... done
[13:35:25.923] Future #1
[13:35:25.923] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:25.923] - nx: 1
[13:35:25.923] - relay: TRUE
[13:35:25.923] - stdout: TRUE
[13:35:25.923] - signal: TRUE
[13:35:25.924] - resignal: FALSE
[13:35:25.924] - force: TRUE
[13:35:25.924] - relayed: [n=1] FALSE
[13:35:25.924] - queued futures: [n=1] FALSE
[13:35:25.924]  - until=1
[13:35:25.924]  - relaying element #1
[13:35:25.924] - relayed: [n=1] TRUE
[13:35:25.924] - queued futures: [n=1] TRUE
[13:35:25.924] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:25.925]  length: 0 (resolved future 1)
[13:35:25.925] Relaying remaining futures
[13:35:25.925] signalConditionsASAP(NULL, pos=0) ...
[13:35:25.925] - nx: 1
[13:35:25.925] - relay: TRUE
[13:35:25.925] - stdout: TRUE
[13:35:25.925] - signal: TRUE
[13:35:25.925] - resignal: FALSE
[13:35:25.925] - force: TRUE
[13:35:25.925] - relayed: [n=1] TRUE
[13:35:25.925] - queued futures: [n=1] TRUE
 - flush all
[13:35:25.925] - relayed: [n=1] TRUE
[13:35:25.926] - queued futures: [n=1] TRUE
[13:35:25.926] signalConditionsASAP(NULL, pos=0) ... done
[13:35:25.926] resolve() on list ... DONE
[13:35:25.926]  - Number of value chunks collected: 1
[13:35:25.926] Resolving 1 futures (chunks) ... DONE
[13:35:25.926] Reducing values from 1 chunks ...
[13:35:25.926]  - Number of values collected after concatenation: 2
[13:35:25.926]  - Number of values expected: 2
[13:35:25.926] Reducing values from 1 chunks ... DONE
[13:35:25.926] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[13:35:25.927] future_mapply() ...
[13:35:25.930] Number of chunks: 1
[13:35:25.930] getGlobalsAndPackagesXApply() ...
[13:35:25.930]  - future.globals: TRUE
[13:35:25.930] getGlobalsAndPackages() ...
[13:35:25.930] Searching for globals...
[13:35:25.932] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:35:25.932] Searching for globals ... DONE
[13:35:25.932] Resolving globals: FALSE
[13:35:25.933] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:35:25.933] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:35:25.933] - globals: [1] ‘FUN’
[13:35:25.933] 
[13:35:25.933] getGlobalsAndPackages() ... DONE
[13:35:25.933]  - globals found/used: [n=1] ‘FUN’
[13:35:25.933]  - needed namespaces: [n=0] 
[13:35:25.934] Finding globals ... DONE
[13:35:25.934] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:35:25.934] List of 2
[13:35:25.934]  $ ...future.FUN:function (x, y)  
[13:35:25.934]  $ MoreArgs     : NULL
[13:35:25.934]  - attr(*, "where")=List of 2
[13:35:25.934]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:25.934]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:35:25.934]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:25.934]  - attr(*, "resolved")= logi FALSE
[13:35:25.934]  - attr(*, "total_size")= num NA
[13:35:25.936] Packages to be attached in all futures: [n=0] 
[13:35:25.936] getGlobalsAndPackagesXApply() ... DONE
[13:35:25.937] Number of futures (= number of chunks): 1
[13:35:25.937] Launching 1 futures (chunks) ...
[13:35:25.937] Chunk #1 of 1 ...
[13:35:25.937]  - Finding globals in '...' for chunk #1 ...
[13:35:25.937] getGlobalsAndPackages() ...
[13:35:25.937] Searching for globals...
[13:35:25.937] 
[13:35:25.938] Searching for globals ... DONE
[13:35:25.938] - globals: [0] <none>
[13:35:25.938] getGlobalsAndPackages() ... DONE
[13:35:25.938]    + additional globals found: [n=0] 
[13:35:25.938]    + additional namespaces needed: [n=0] 
[13:35:25.938]  - Finding globals in '...' for chunk #1 ... DONE
[13:35:25.938]  - seeds: <none>
[13:35:25.938]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:25.938] getGlobalsAndPackages() ...
[13:35:25.938] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:25.939] Resolving globals: FALSE
[13:35:25.939] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:35:25.941] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:35:25.942] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:25.942] 
[13:35:25.942] getGlobalsAndPackages() ... DONE
[13:35:25.942] run() for ‘Future’ ...
[13:35:25.942] - state: ‘created’
[13:35:25.942] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:25.946] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:25.946] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:25.946]   - Field: ‘label’
[13:35:25.946]   - Field: ‘local’
[13:35:25.946]   - Field: ‘owner’
[13:35:25.946]   - Field: ‘envir’
[13:35:25.946]   - Field: ‘packages’
[13:35:25.946]   - Field: ‘gc’
[13:35:25.947]   - Field: ‘conditions’
[13:35:25.947]   - Field: ‘expr’
[13:35:25.947]   - Field: ‘uuid’
[13:35:25.947]   - Field: ‘seed’
[13:35:25.947]   - Field: ‘version’
[13:35:25.947]   - Field: ‘result’
[13:35:25.947]   - Field: ‘asynchronous’
[13:35:25.947]   - Field: ‘calls’
[13:35:25.947]   - Field: ‘globals’
[13:35:25.947]   - Field: ‘stdout’
[13:35:25.947]   - Field: ‘earlySignal’
[13:35:25.948]   - Field: ‘lazy’
[13:35:25.948]   - Field: ‘state’
[13:35:25.948] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:25.948] - Launch lazy future ...
[13:35:25.948] Packages needed by the future expression (n = 0): <none>
[13:35:25.948] Packages needed by future strategies (n = 0): <none>
[13:35:25.949] {
[13:35:25.949]     {
[13:35:25.949]         {
[13:35:25.949]             ...future.startTime <- base::Sys.time()
[13:35:25.949]             {
[13:35:25.949]                 {
[13:35:25.949]                   {
[13:35:25.949]                     base::local({
[13:35:25.949]                       has_future <- base::requireNamespace("future", 
[13:35:25.949]                         quietly = TRUE)
[13:35:25.949]                       if (has_future) {
[13:35:25.949]                         ns <- base::getNamespace("future")
[13:35:25.949]                         version <- ns[[".package"]][["version"]]
[13:35:25.949]                         if (is.null(version)) 
[13:35:25.949]                           version <- utils::packageVersion("future")
[13:35:25.949]                       }
[13:35:25.949]                       else {
[13:35:25.949]                         version <- NULL
[13:35:25.949]                       }
[13:35:25.949]                       if (!has_future || version < "1.8.0") {
[13:35:25.949]                         info <- base::c(r_version = base::gsub("R version ", 
[13:35:25.949]                           "", base::R.version$version.string), 
[13:35:25.949]                           platform = base::sprintf("%s (%s-bit)", 
[13:35:25.949]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:25.949]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:25.949]                             "release", "version")], collapse = " "), 
[13:35:25.949]                           hostname = base::Sys.info()[["nodename"]])
[13:35:25.949]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:35:25.949]                           info)
[13:35:25.949]                         info <- base::paste(info, collapse = "; ")
[13:35:25.949]                         if (!has_future) {
[13:35:25.949]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:25.949]                             info)
[13:35:25.949]                         }
[13:35:25.949]                         else {
[13:35:25.949]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:25.949]                             info, version)
[13:35:25.949]                         }
[13:35:25.949]                         base::stop(msg)
[13:35:25.949]                       }
[13:35:25.949]                     })
[13:35:25.949]                   }
[13:35:25.949]                   ...future.strategy.old <- future::plan("list")
[13:35:25.949]                   options(future.plan = NULL)
[13:35:25.949]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:25.949]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:25.949]                 }
[13:35:25.949]                 ...future.workdir <- getwd()
[13:35:25.949]             }
[13:35:25.949]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:25.949]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:25.949]         }
[13:35:25.949]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:25.949]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:25.949]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:25.949]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:25.949]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:25.949]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:25.949]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:25.949]             base::names(...future.oldOptions))
[13:35:25.949]     }
[13:35:25.949]     if (TRUE) {
[13:35:25.949]     }
[13:35:25.949]     else {
[13:35:25.949]         if (NA) {
[13:35:25.949]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:25.949]                 open = "w")
[13:35:25.949]         }
[13:35:25.949]         else {
[13:35:25.949]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:25.949]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:25.949]         }
[13:35:25.949]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:25.949]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:25.949]             base::sink(type = "output", split = FALSE)
[13:35:25.949]             base::close(...future.stdout)
[13:35:25.949]         }, add = TRUE)
[13:35:25.949]     }
[13:35:25.949]     ...future.frame <- base::sys.nframe()
[13:35:25.949]     ...future.conditions <- base::list()
[13:35:25.949]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:25.949]     if (FALSE) {
[13:35:25.949]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:25.949]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:25.949]     }
[13:35:25.949]     ...future.result <- base::tryCatch({
[13:35:25.949]         base::withCallingHandlers({
[13:35:25.949]             ...future.value <- base::withVisible(base::local({
[13:35:25.949]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:25.949]                 if (!identical(...future.globals.maxSize.org, 
[13:35:25.949]                   ...future.globals.maxSize)) {
[13:35:25.949]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:25.949]                   on.exit(options(oopts), add = TRUE)
[13:35:25.949]                 }
[13:35:25.949]                 {
[13:35:25.949]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:25.949]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:35:25.949]                     USE.NAMES = FALSE)
[13:35:25.949]                   do.call(mapply, args = args)
[13:35:25.949]                 }
[13:35:25.949]             }))
[13:35:25.949]             future::FutureResult(value = ...future.value$value, 
[13:35:25.949]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:25.949]                   ...future.rng), globalenv = if (FALSE) 
[13:35:25.949]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:25.949]                     ...future.globalenv.names))
[13:35:25.949]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:25.949]         }, condition = base::local({
[13:35:25.949]             c <- base::c
[13:35:25.949]             inherits <- base::inherits
[13:35:25.949]             invokeRestart <- base::invokeRestart
[13:35:25.949]             length <- base::length
[13:35:25.949]             list <- base::list
[13:35:25.949]             seq.int <- base::seq.int
[13:35:25.949]             signalCondition <- base::signalCondition
[13:35:25.949]             sys.calls <- base::sys.calls
[13:35:25.949]             `[[` <- base::`[[`
[13:35:25.949]             `+` <- base::`+`
[13:35:25.949]             `<<-` <- base::`<<-`
[13:35:25.949]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:25.949]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:25.949]                   3L)]
[13:35:25.949]             }
[13:35:25.949]             function(cond) {
[13:35:25.949]                 is_error <- inherits(cond, "error")
[13:35:25.949]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:25.949]                   NULL)
[13:35:25.949]                 if (is_error) {
[13:35:25.949]                   sessionInformation <- function() {
[13:35:25.949]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:25.949]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:25.949]                       search = base::search(), system = base::Sys.info())
[13:35:25.949]                   }
[13:35:25.949]                   ...future.conditions[[length(...future.conditions) + 
[13:35:25.949]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:25.949]                     cond$call), session = sessionInformation(), 
[13:35:25.949]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:25.949]                   signalCondition(cond)
[13:35:25.949]                 }
[13:35:25.949]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:25.949]                 "immediateCondition"))) {
[13:35:25.949]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:25.949]                   ...future.conditions[[length(...future.conditions) + 
[13:35:25.949]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:25.949]                   if (TRUE && !signal) {
[13:35:25.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:25.949]                     {
[13:35:25.949]                       inherits <- base::inherits
[13:35:25.949]                       invokeRestart <- base::invokeRestart
[13:35:25.949]                       is.null <- base::is.null
[13:35:25.949]                       muffled <- FALSE
[13:35:25.949]                       if (inherits(cond, "message")) {
[13:35:25.949]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:25.949]                         if (muffled) 
[13:35:25.949]                           invokeRestart("muffleMessage")
[13:35:25.949]                       }
[13:35:25.949]                       else if (inherits(cond, "warning")) {
[13:35:25.949]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:25.949]                         if (muffled) 
[13:35:25.949]                           invokeRestart("muffleWarning")
[13:35:25.949]                       }
[13:35:25.949]                       else if (inherits(cond, "condition")) {
[13:35:25.949]                         if (!is.null(pattern)) {
[13:35:25.949]                           computeRestarts <- base::computeRestarts
[13:35:25.949]                           grepl <- base::grepl
[13:35:25.949]                           restarts <- computeRestarts(cond)
[13:35:25.949]                           for (restart in restarts) {
[13:35:25.949]                             name <- restart$name
[13:35:25.949]                             if (is.null(name)) 
[13:35:25.949]                               next
[13:35:25.949]                             if (!grepl(pattern, name)) 
[13:35:25.949]                               next
[13:35:25.949]                             invokeRestart(restart)
[13:35:25.949]                             muffled <- TRUE
[13:35:25.949]                             break
[13:35:25.949]                           }
[13:35:25.949]                         }
[13:35:25.949]                       }
[13:35:25.949]                       invisible(muffled)
[13:35:25.949]                     }
[13:35:25.949]                     muffleCondition(cond, pattern = "^muffle")
[13:35:25.949]                   }
[13:35:25.949]                 }
[13:35:25.949]                 else {
[13:35:25.949]                   if (TRUE) {
[13:35:25.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:25.949]                     {
[13:35:25.949]                       inherits <- base::inherits
[13:35:25.949]                       invokeRestart <- base::invokeRestart
[13:35:25.949]                       is.null <- base::is.null
[13:35:25.949]                       muffled <- FALSE
[13:35:25.949]                       if (inherits(cond, "message")) {
[13:35:25.949]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:25.949]                         if (muffled) 
[13:35:25.949]                           invokeRestart("muffleMessage")
[13:35:25.949]                       }
[13:35:25.949]                       else if (inherits(cond, "warning")) {
[13:35:25.949]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:25.949]                         if (muffled) 
[13:35:25.949]                           invokeRestart("muffleWarning")
[13:35:25.949]                       }
[13:35:25.949]                       else if (inherits(cond, "condition")) {
[13:35:25.949]                         if (!is.null(pattern)) {
[13:35:25.949]                           computeRestarts <- base::computeRestarts
[13:35:25.949]                           grepl <- base::grepl
[13:35:25.949]                           restarts <- computeRestarts(cond)
[13:35:25.949]                           for (restart in restarts) {
[13:35:25.949]                             name <- restart$name
[13:35:25.949]                             if (is.null(name)) 
[13:35:25.949]                               next
[13:35:25.949]                             if (!grepl(pattern, name)) 
[13:35:25.949]                               next
[13:35:25.949]                             invokeRestart(restart)
[13:35:25.949]                             muffled <- TRUE
[13:35:25.949]                             break
[13:35:25.949]                           }
[13:35:25.949]                         }
[13:35:25.949]                       }
[13:35:25.949]                       invisible(muffled)
[13:35:25.949]                     }
[13:35:25.949]                     muffleCondition(cond, pattern = "^muffle")
[13:35:25.949]                   }
[13:35:25.949]                 }
[13:35:25.949]             }
[13:35:25.949]         }))
[13:35:25.949]     }, error = function(ex) {
[13:35:25.949]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:25.949]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:25.949]                 ...future.rng), started = ...future.startTime, 
[13:35:25.949]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:25.949]             version = "1.8"), class = "FutureResult")
[13:35:25.949]     }, finally = {
[13:35:25.949]         if (!identical(...future.workdir, getwd())) 
[13:35:25.949]             setwd(...future.workdir)
[13:35:25.949]         {
[13:35:25.949]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:25.949]                 ...future.oldOptions$nwarnings <- NULL
[13:35:25.949]             }
[13:35:25.949]             base::options(...future.oldOptions)
[13:35:25.949]             if (.Platform$OS.type == "windows") {
[13:35:25.949]                 old_names <- names(...future.oldEnvVars)
[13:35:25.949]                 envs <- base::Sys.getenv()
[13:35:25.949]                 names <- names(envs)
[13:35:25.949]                 common <- intersect(names, old_names)
[13:35:25.949]                 added <- setdiff(names, old_names)
[13:35:25.949]                 removed <- setdiff(old_names, names)
[13:35:25.949]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:25.949]                   envs[common]]
[13:35:25.949]                 NAMES <- toupper(changed)
[13:35:25.949]                 args <- list()
[13:35:25.949]                 for (kk in seq_along(NAMES)) {
[13:35:25.949]                   name <- changed[[kk]]
[13:35:25.949]                   NAME <- NAMES[[kk]]
[13:35:25.949]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:25.949]                     next
[13:35:25.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:25.949]                 }
[13:35:25.949]                 NAMES <- toupper(added)
[13:35:25.949]                 for (kk in seq_along(NAMES)) {
[13:35:25.949]                   name <- added[[kk]]
[13:35:25.949]                   NAME <- NAMES[[kk]]
[13:35:25.949]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:25.949]                     next
[13:35:25.949]                   args[[name]] <- ""
[13:35:25.949]                 }
[13:35:25.949]                 NAMES <- toupper(removed)
[13:35:25.949]                 for (kk in seq_along(NAMES)) {
[13:35:25.949]                   name <- removed[[kk]]
[13:35:25.949]                   NAME <- NAMES[[kk]]
[13:35:25.949]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:25.949]                     next
[13:35:25.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:25.949]                 }
[13:35:25.949]                 if (length(args) > 0) 
[13:35:25.949]                   base::do.call(base::Sys.setenv, args = args)
[13:35:25.949]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:25.949]             }
[13:35:25.949]             else {
[13:35:25.949]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:25.949]             }
[13:35:25.949]             {
[13:35:25.949]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:25.949]                   0L) {
[13:35:25.949]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:25.949]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:25.949]                   base::options(opts)
[13:35:25.949]                 }
[13:35:25.949]                 {
[13:35:25.949]                   {
[13:35:25.949]                     NULL
[13:35:25.949]                     RNGkind("Mersenne-Twister")
[13:35:25.949]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:25.949]                       inherits = FALSE)
[13:35:25.949]                   }
[13:35:25.949]                   options(future.plan = NULL)
[13:35:25.949]                   if (is.na(NA_character_)) 
[13:35:25.949]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:25.949]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:25.949]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:25.949]                     .init = FALSE)
[13:35:25.949]                 }
[13:35:25.949]             }
[13:35:25.949]         }
[13:35:25.949]     })
[13:35:25.949]     if (FALSE) {
[13:35:25.949]         base::sink(type = "output", split = FALSE)
[13:35:25.949]         if (NA) {
[13:35:25.949]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:25.949]         }
[13:35:25.949]         else {
[13:35:25.949]             ...future.result["stdout"] <- base::list(NULL)
[13:35:25.949]         }
[13:35:25.949]         base::close(...future.stdout)
[13:35:25.949]         ...future.stdout <- NULL
[13:35:25.949]     }
[13:35:25.949]     ...future.result$conditions <- ...future.conditions
[13:35:25.949]     ...future.result$finished <- base::Sys.time()
[13:35:25.949]     ...future.result
[13:35:25.949] }
[13:35:25.950] assign_globals() ...
[13:35:25.950] List of 5
[13:35:25.950]  $ ...future.FUN            :function (x, y)  
[13:35:25.950]  $ MoreArgs                 : NULL
[13:35:25.950]  $ ...future.elements_ii    :List of 2
[13:35:25.950]   ..$ :List of 2
[13:35:25.950]   .. ..$ : int 1
[13:35:25.950]   .. ..$ : int 0
[13:35:25.950]   ..$ :List of 2
[13:35:25.950]   .. ..$ : int 0
[13:35:25.950]   .. ..$ : int 1
[13:35:25.950]  $ ...future.seeds_ii       : NULL
[13:35:25.950]  $ ...future.globals.maxSize: NULL
[13:35:25.950]  - attr(*, "where")=List of 5
[13:35:25.950]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:25.950]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:35:25.950]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:25.950]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:25.950]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:25.950]  - attr(*, "resolved")= logi FALSE
[13:35:25.950]  - attr(*, "total_size")= num 6480
[13:35:25.950]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:25.950]  - attr(*, "already-done")= logi TRUE
[13:35:25.956] - reassign environment for ‘...future.FUN’
[13:35:25.956] - copied ‘...future.FUN’ to environment
[13:35:25.956] - copied ‘MoreArgs’ to environment
[13:35:25.956] - copied ‘...future.elements_ii’ to environment
[13:35:25.956] - copied ‘...future.seeds_ii’ to environment
[13:35:25.956] - copied ‘...future.globals.maxSize’ to environment
[13:35:25.956] assign_globals() ... done
[13:35:25.956] plan(): Setting new future strategy stack:
[13:35:25.957] List of future strategies:
[13:35:25.957] 1. sequential:
[13:35:25.957]    - args: function (..., envir = parent.frame())
[13:35:25.957]    - tweaked: FALSE
[13:35:25.957]    - call: NULL
[13:35:25.957] plan(): nbrOfWorkers() = 1
[13:35:26.458] plan(): Setting new future strategy stack:
[13:35:26.459] List of future strategies:
[13:35:26.459] 1. multicore:
[13:35:26.459]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:26.459]    - tweaked: FALSE
[13:35:26.459]    - call: plan(strategy)
[13:35:26.462] plan(): nbrOfWorkers() = 1
[13:35:26.463] SequentialFuture started (and completed)
[13:35:26.463] - Launch lazy future ... done
[13:35:26.463] run() for ‘SequentialFuture’ ... done
[13:35:26.463] Created future:
[13:35:26.463] SequentialFuture:
[13:35:26.463] Label: ‘future_mapply-1’
[13:35:26.463] Expression:
[13:35:26.463] {
[13:35:26.463]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:26.463]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:26.463]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:26.463]         on.exit(options(oopts), add = TRUE)
[13:35:26.463]     }
[13:35:26.463]     {
[13:35:26.463]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:26.463]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:35:26.463]         do.call(mapply, args = args)
[13:35:26.463]     }
[13:35:26.463] }
[13:35:26.463] Lazy evaluation: FALSE
[13:35:26.463] Asynchronous evaluation: FALSE
[13:35:26.463] Local evaluation: TRUE
[13:35:26.463] Environment: R_GlobalEnv
[13:35:26.463] Capture standard output: NA
[13:35:26.463] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:26.463] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:26.463] Packages: <none>
[13:35:26.463] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:26.463] Resolved: TRUE
[13:35:26.463] Value: 224 bytes of class ‘list’
[13:35:26.463] Early signaling: FALSE
[13:35:26.463] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:26.463] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:26.464] Chunk #1 of 1 ... DONE
[13:35:26.464] Launching 1 futures (chunks) ... DONE
[13:35:26.464] Resolving 1 futures (chunks) ...
[13:35:26.464] resolve() on list ...
[13:35:26.464]  recursive: 0
[13:35:26.464]  length: 1
[13:35:26.465] 
[13:35:26.465] resolved() for ‘SequentialFuture’ ...
[13:35:26.465] - state: ‘finished’
[13:35:26.465] - run: TRUE
[13:35:26.465] - result: ‘FutureResult’
[13:35:26.465] resolved() for ‘SequentialFuture’ ... done
[13:35:26.465] Future #1
[13:35:26.465] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:26.465] - nx: 1
[13:35:26.465] - relay: TRUE
[13:35:26.466] - stdout: TRUE
[13:35:26.466] - signal: TRUE
[13:35:26.466] - resignal: FALSE
[13:35:26.466] - force: TRUE
[13:35:26.466] - relayed: [n=1] FALSE
[13:35:26.466] - queued futures: [n=1] FALSE
[13:35:26.466]  - until=1
[13:35:26.466]  - relaying element #1
[13:35:26.466] - relayed: [n=1] TRUE
[13:35:26.466] - queued futures: [n=1] TRUE
[13:35:26.467] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:26.467]  length: 0 (resolved future 1)
[13:35:26.467] Relaying remaining futures
[13:35:26.467] signalConditionsASAP(NULL, pos=0) ...
[13:35:26.467] - nx: 1
[13:35:26.467] - relay: TRUE
[13:35:26.467] - stdout: TRUE
[13:35:26.467] - signal: TRUE
[13:35:26.467] - resignal: FALSE
[13:35:26.467] - force: TRUE
[13:35:26.467] - relayed: [n=1] TRUE
[13:35:26.467] - queued futures: [n=1] TRUE
 - flush all
[13:35:26.468] - relayed: [n=1] TRUE
[13:35:26.468] - queued futures: [n=1] TRUE
[13:35:26.468] signalConditionsASAP(NULL, pos=0) ... done
[13:35:26.468] resolve() on list ... DONE
[13:35:26.468]  - Number of value chunks collected: 1
[13:35:26.468] Resolving 1 futures (chunks) ... DONE
[13:35:26.468] Reducing values from 1 chunks ...
[13:35:26.468]  - Number of values collected after concatenation: 2
[13:35:26.468]  - Number of values expected: 2
[13:35:26.468] Reducing values from 1 chunks ... DONE
[13:35:26.469] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[13:35:26.495] plan(): Setting new future strategy stack:
[13:35:26.495] List of future strategies:
[13:35:26.495] 1. multisession:
[13:35:26.495]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:35:26.495]    - tweaked: FALSE
[13:35:26.495]    - call: plan(strategy)
[13:35:26.495] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:35:26.495] multisession:
[13:35:26.495] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:35:26.495] - tweaked: FALSE
[13:35:26.495] - call: plan(strategy)
[13:35:26.500] getGlobalsAndPackages() ...
[13:35:26.500] Not searching for globals
[13:35:26.500] - globals: [0] <none>
[13:35:26.500] getGlobalsAndPackages() ... DONE
[13:35:26.501] Packages needed by the future expression (n = 0): <none>
[13:35:26.501] Packages needed by future strategies (n = 0): <none>
[13:35:26.501] {
[13:35:26.501]     {
[13:35:26.501]         {
[13:35:26.501]             ...future.startTime <- base::Sys.time()
[13:35:26.501]             {
[13:35:26.501]                 {
[13:35:26.501]                   {
[13:35:26.501]                     base::local({
[13:35:26.501]                       has_future <- base::requireNamespace("future", 
[13:35:26.501]                         quietly = TRUE)
[13:35:26.501]                       if (has_future) {
[13:35:26.501]                         ns <- base::getNamespace("future")
[13:35:26.501]                         version <- ns[[".package"]][["version"]]
[13:35:26.501]                         if (is.null(version)) 
[13:35:26.501]                           version <- utils::packageVersion("future")
[13:35:26.501]                       }
[13:35:26.501]                       else {
[13:35:26.501]                         version <- NULL
[13:35:26.501]                       }
[13:35:26.501]                       if (!has_future || version < "1.8.0") {
[13:35:26.501]                         info <- base::c(r_version = base::gsub("R version ", 
[13:35:26.501]                           "", base::R.version$version.string), 
[13:35:26.501]                           platform = base::sprintf("%s (%s-bit)", 
[13:35:26.501]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:26.501]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:26.501]                             "release", "version")], collapse = " "), 
[13:35:26.501]                           hostname = base::Sys.info()[["nodename"]])
[13:35:26.501]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:35:26.501]                           info)
[13:35:26.501]                         info <- base::paste(info, collapse = "; ")
[13:35:26.501]                         if (!has_future) {
[13:35:26.501]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:26.501]                             info)
[13:35:26.501]                         }
[13:35:26.501]                         else {
[13:35:26.501]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:26.501]                             info, version)
[13:35:26.501]                         }
[13:35:26.501]                         base::stop(msg)
[13:35:26.501]                       }
[13:35:26.501]                     })
[13:35:26.501]                   }
[13:35:26.501]                   ...future.strategy.old <- future::plan("list")
[13:35:26.501]                   options(future.plan = NULL)
[13:35:26.501]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:26.501]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:26.501]                 }
[13:35:26.501]                 ...future.workdir <- getwd()
[13:35:26.501]             }
[13:35:26.501]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:26.501]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:26.501]         }
[13:35:26.501]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:26.501]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:26.501]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:26.501]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:26.501]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:26.501]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:26.501]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:26.501]             base::names(...future.oldOptions))
[13:35:26.501]     }
[13:35:26.501]     if (FALSE) {
[13:35:26.501]     }
[13:35:26.501]     else {
[13:35:26.501]         if (TRUE) {
[13:35:26.501]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:26.501]                 open = "w")
[13:35:26.501]         }
[13:35:26.501]         else {
[13:35:26.501]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:26.501]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:26.501]         }
[13:35:26.501]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:26.501]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:26.501]             base::sink(type = "output", split = FALSE)
[13:35:26.501]             base::close(...future.stdout)
[13:35:26.501]         }, add = TRUE)
[13:35:26.501]     }
[13:35:26.501]     ...future.frame <- base::sys.nframe()
[13:35:26.501]     ...future.conditions <- base::list()
[13:35:26.501]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:26.501]     if (FALSE) {
[13:35:26.501]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:26.501]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:26.501]     }
[13:35:26.501]     ...future.result <- base::tryCatch({
[13:35:26.501]         base::withCallingHandlers({
[13:35:26.501]             ...future.value <- base::withVisible(base::local(NA))
[13:35:26.501]             future::FutureResult(value = ...future.value$value, 
[13:35:26.501]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:26.501]                   ...future.rng), globalenv = if (FALSE) 
[13:35:26.501]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:26.501]                     ...future.globalenv.names))
[13:35:26.501]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:26.501]         }, condition = base::local({
[13:35:26.501]             c <- base::c
[13:35:26.501]             inherits <- base::inherits
[13:35:26.501]             invokeRestart <- base::invokeRestart
[13:35:26.501]             length <- base::length
[13:35:26.501]             list <- base::list
[13:35:26.501]             seq.int <- base::seq.int
[13:35:26.501]             signalCondition <- base::signalCondition
[13:35:26.501]             sys.calls <- base::sys.calls
[13:35:26.501]             `[[` <- base::`[[`
[13:35:26.501]             `+` <- base::`+`
[13:35:26.501]             `<<-` <- base::`<<-`
[13:35:26.501]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:26.501]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:26.501]                   3L)]
[13:35:26.501]             }
[13:35:26.501]             function(cond) {
[13:35:26.501]                 is_error <- inherits(cond, "error")
[13:35:26.501]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:26.501]                   NULL)
[13:35:26.501]                 if (is_error) {
[13:35:26.501]                   sessionInformation <- function() {
[13:35:26.501]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:26.501]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:26.501]                       search = base::search(), system = base::Sys.info())
[13:35:26.501]                   }
[13:35:26.501]                   ...future.conditions[[length(...future.conditions) + 
[13:35:26.501]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:26.501]                     cond$call), session = sessionInformation(), 
[13:35:26.501]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:26.501]                   signalCondition(cond)
[13:35:26.501]                 }
[13:35:26.501]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:26.501]                 "immediateCondition"))) {
[13:35:26.501]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:26.501]                   ...future.conditions[[length(...future.conditions) + 
[13:35:26.501]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:26.501]                   if (TRUE && !signal) {
[13:35:26.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:26.501]                     {
[13:35:26.501]                       inherits <- base::inherits
[13:35:26.501]                       invokeRestart <- base::invokeRestart
[13:35:26.501]                       is.null <- base::is.null
[13:35:26.501]                       muffled <- FALSE
[13:35:26.501]                       if (inherits(cond, "message")) {
[13:35:26.501]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:26.501]                         if (muffled) 
[13:35:26.501]                           invokeRestart("muffleMessage")
[13:35:26.501]                       }
[13:35:26.501]                       else if (inherits(cond, "warning")) {
[13:35:26.501]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:26.501]                         if (muffled) 
[13:35:26.501]                           invokeRestart("muffleWarning")
[13:35:26.501]                       }
[13:35:26.501]                       else if (inherits(cond, "condition")) {
[13:35:26.501]                         if (!is.null(pattern)) {
[13:35:26.501]                           computeRestarts <- base::computeRestarts
[13:35:26.501]                           grepl <- base::grepl
[13:35:26.501]                           restarts <- computeRestarts(cond)
[13:35:26.501]                           for (restart in restarts) {
[13:35:26.501]                             name <- restart$name
[13:35:26.501]                             if (is.null(name)) 
[13:35:26.501]                               next
[13:35:26.501]                             if (!grepl(pattern, name)) 
[13:35:26.501]                               next
[13:35:26.501]                             invokeRestart(restart)
[13:35:26.501]                             muffled <- TRUE
[13:35:26.501]                             break
[13:35:26.501]                           }
[13:35:26.501]                         }
[13:35:26.501]                       }
[13:35:26.501]                       invisible(muffled)
[13:35:26.501]                     }
[13:35:26.501]                     muffleCondition(cond, pattern = "^muffle")
[13:35:26.501]                   }
[13:35:26.501]                 }
[13:35:26.501]                 else {
[13:35:26.501]                   if (TRUE) {
[13:35:26.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:26.501]                     {
[13:35:26.501]                       inherits <- base::inherits
[13:35:26.501]                       invokeRestart <- base::invokeRestart
[13:35:26.501]                       is.null <- base::is.null
[13:35:26.501]                       muffled <- FALSE
[13:35:26.501]                       if (inherits(cond, "message")) {
[13:35:26.501]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:26.501]                         if (muffled) 
[13:35:26.501]                           invokeRestart("muffleMessage")
[13:35:26.501]                       }
[13:35:26.501]                       else if (inherits(cond, "warning")) {
[13:35:26.501]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:26.501]                         if (muffled) 
[13:35:26.501]                           invokeRestart("muffleWarning")
[13:35:26.501]                       }
[13:35:26.501]                       else if (inherits(cond, "condition")) {
[13:35:26.501]                         if (!is.null(pattern)) {
[13:35:26.501]                           computeRestarts <- base::computeRestarts
[13:35:26.501]                           grepl <- base::grepl
[13:35:26.501]                           restarts <- computeRestarts(cond)
[13:35:26.501]                           for (restart in restarts) {
[13:35:26.501]                             name <- restart$name
[13:35:26.501]                             if (is.null(name)) 
[13:35:26.501]                               next
[13:35:26.501]                             if (!grepl(pattern, name)) 
[13:35:26.501]                               next
[13:35:26.501]                             invokeRestart(restart)
[13:35:26.501]                             muffled <- TRUE
[13:35:26.501]                             break
[13:35:26.501]                           }
[13:35:26.501]                         }
[13:35:26.501]                       }
[13:35:26.501]                       invisible(muffled)
[13:35:26.501]                     }
[13:35:26.501]                     muffleCondition(cond, pattern = "^muffle")
[13:35:26.501]                   }
[13:35:26.501]                 }
[13:35:26.501]             }
[13:35:26.501]         }))
[13:35:26.501]     }, error = function(ex) {
[13:35:26.501]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:26.501]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:26.501]                 ...future.rng), started = ...future.startTime, 
[13:35:26.501]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:26.501]             version = "1.8"), class = "FutureResult")
[13:35:26.501]     }, finally = {
[13:35:26.501]         if (!identical(...future.workdir, getwd())) 
[13:35:26.501]             setwd(...future.workdir)
[13:35:26.501]         {
[13:35:26.501]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:26.501]                 ...future.oldOptions$nwarnings <- NULL
[13:35:26.501]             }
[13:35:26.501]             base::options(...future.oldOptions)
[13:35:26.501]             if (.Platform$OS.type == "windows") {
[13:35:26.501]                 old_names <- names(...future.oldEnvVars)
[13:35:26.501]                 envs <- base::Sys.getenv()
[13:35:26.501]                 names <- names(envs)
[13:35:26.501]                 common <- intersect(names, old_names)
[13:35:26.501]                 added <- setdiff(names, old_names)
[13:35:26.501]                 removed <- setdiff(old_names, names)
[13:35:26.501]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:26.501]                   envs[common]]
[13:35:26.501]                 NAMES <- toupper(changed)
[13:35:26.501]                 args <- list()
[13:35:26.501]                 for (kk in seq_along(NAMES)) {
[13:35:26.501]                   name <- changed[[kk]]
[13:35:26.501]                   NAME <- NAMES[[kk]]
[13:35:26.501]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:26.501]                     next
[13:35:26.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:26.501]                 }
[13:35:26.501]                 NAMES <- toupper(added)
[13:35:26.501]                 for (kk in seq_along(NAMES)) {
[13:35:26.501]                   name <- added[[kk]]
[13:35:26.501]                   NAME <- NAMES[[kk]]
[13:35:26.501]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:26.501]                     next
[13:35:26.501]                   args[[name]] <- ""
[13:35:26.501]                 }
[13:35:26.501]                 NAMES <- toupper(removed)
[13:35:26.501]                 for (kk in seq_along(NAMES)) {
[13:35:26.501]                   name <- removed[[kk]]
[13:35:26.501]                   NAME <- NAMES[[kk]]
[13:35:26.501]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:26.501]                     next
[13:35:26.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:26.501]                 }
[13:35:26.501]                 if (length(args) > 0) 
[13:35:26.501]                   base::do.call(base::Sys.setenv, args = args)
[13:35:26.501]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:26.501]             }
[13:35:26.501]             else {
[13:35:26.501]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:26.501]             }
[13:35:26.501]             {
[13:35:26.501]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:26.501]                   0L) {
[13:35:26.501]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:26.501]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:26.501]                   base::options(opts)
[13:35:26.501]                 }
[13:35:26.501]                 {
[13:35:26.501]                   {
[13:35:26.501]                     NULL
[13:35:26.501]                     RNGkind("Mersenne-Twister")
[13:35:26.501]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:26.501]                       inherits = FALSE)
[13:35:26.501]                   }
[13:35:26.501]                   options(future.plan = NULL)
[13:35:26.501]                   if (is.na(NA_character_)) 
[13:35:26.501]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:26.501]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:26.501]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:26.501]                     .init = FALSE)
[13:35:26.501]                 }
[13:35:26.501]             }
[13:35:26.501]         }
[13:35:26.501]     })
[13:35:26.501]     if (TRUE) {
[13:35:26.501]         base::sink(type = "output", split = FALSE)
[13:35:26.501]         if (TRUE) {
[13:35:26.501]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:26.501]         }
[13:35:26.501]         else {
[13:35:26.501]             ...future.result["stdout"] <- base::list(NULL)
[13:35:26.501]         }
[13:35:26.501]         base::close(...future.stdout)
[13:35:26.501]         ...future.stdout <- NULL
[13:35:26.501]     }
[13:35:26.501]     ...future.result$conditions <- ...future.conditions
[13:35:26.501]     ...future.result$finished <- base::Sys.time()
[13:35:26.501]     ...future.result
[13:35:26.501] }
[13:35:26.503] plan(): Setting new future strategy stack:
[13:35:26.503] List of future strategies:
[13:35:26.503] 1. sequential:
[13:35:26.503]    - args: function (..., envir = parent.frame())
[13:35:26.503]    - tweaked: FALSE
[13:35:26.503]    - call: NULL
[13:35:26.504] plan(): nbrOfWorkers() = 1
[13:35:26.504] plan(): Setting new future strategy stack:
[13:35:26.504] List of future strategies:
[13:35:26.504] 1. multisession:
[13:35:26.504]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:35:26.504]    - tweaked: FALSE
[13:35:26.504]    - call: plan(strategy)
[13:35:26.508] plan(): nbrOfWorkers() = 1
[13:35:26.508] SequentialFuture started (and completed)
[13:35:26.508] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:35:26.511] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[13:35:26.511] future_lapply() ...
[13:35:26.515] Number of chunks: 1
[13:35:26.515] getGlobalsAndPackagesXApply() ...
[13:35:26.515]  - future.globals: TRUE
[13:35:26.515] getGlobalsAndPackages() ...
[13:35:26.515] Searching for globals...
[13:35:26.517] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:35:26.517] Searching for globals ... DONE
[13:35:26.517] Resolving globals: FALSE
[13:35:26.517] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:35:26.518] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:35:26.518] - globals: [1] ‘FUN’
[13:35:26.518] 
[13:35:26.518] getGlobalsAndPackages() ... DONE
[13:35:26.518]  - globals found/used: [n=1] ‘FUN’
[13:35:26.518]  - needed namespaces: [n=0] 
[13:35:26.518] Finding globals ... DONE
[13:35:26.518]  - use_args: TRUE
[13:35:26.518]  - Getting '...' globals ...
[13:35:26.519] resolve() on list ...
[13:35:26.519]  recursive: 0
[13:35:26.519]  length: 1
[13:35:26.519]  elements: ‘...’
[13:35:26.519]  length: 0 (resolved future 1)
[13:35:26.519] resolve() on list ... DONE
[13:35:26.519]    - '...' content: [n=0] 
[13:35:26.519] List of 1
[13:35:26.519]  $ ...: list()
[13:35:26.519]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:26.519]  - attr(*, "where")=List of 1
[13:35:26.519]   ..$ ...:<environment: 0x558d3652dc28> 
[13:35:26.519]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:26.519]  - attr(*, "resolved")= logi TRUE
[13:35:26.519]  - attr(*, "total_size")= num NA
[13:35:26.522]  - Getting '...' globals ... DONE
[13:35:26.522] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:35:26.522] List of 2
[13:35:26.522]  $ ...future.FUN:function (x)  
[13:35:26.522]  $ ...          : list()
[13:35:26.522]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:26.522]  - attr(*, "where")=List of 2
[13:35:26.522]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:26.522]   ..$ ...          :<environment: 0x558d3652dc28> 
[13:35:26.522]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:26.522]  - attr(*, "resolved")= logi FALSE
[13:35:26.522]  - attr(*, "total_size")= num 4720
[13:35:26.525] Packages to be attached in all futures: [n=0] 
[13:35:26.525] getGlobalsAndPackagesXApply() ... DONE
[13:35:26.525] Number of futures (= number of chunks): 1
[13:35:26.525] Launching 1 futures (chunks) ...
[13:35:26.525] Chunk #1 of 1 ...
[13:35:26.526]  - Finding globals in 'X' for chunk #1 ...
[13:35:26.526] getGlobalsAndPackages() ...
[13:35:26.526] Searching for globals...
[13:35:26.526] 
[13:35:26.526] Searching for globals ... DONE
[13:35:26.526] - globals: [0] <none>
[13:35:26.526] getGlobalsAndPackages() ... DONE
[13:35:26.526]    + additional globals found: [n=0] 
[13:35:26.526]    + additional namespaces needed: [n=0] 
[13:35:26.527]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:26.527]  - seeds: <none>
[13:35:26.527]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:26.527] getGlobalsAndPackages() ...
[13:35:26.527] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:26.527] Resolving globals: FALSE
[13:35:26.527] Tweak future expression to call with '...' arguments ...
[13:35:26.527] {
[13:35:26.527]     do.call(function(...) {
[13:35:26.527]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:26.527]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:26.527]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:26.527]             on.exit(options(oopts), add = TRUE)
[13:35:26.527]         }
[13:35:26.527]         {
[13:35:26.527]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:26.527]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:26.527]                 ...future.FUN(...future.X_jj, ...)
[13:35:26.527]             })
[13:35:26.527]         }
[13:35:26.527]     }, args = future.call.arguments)
[13:35:26.527] }
[13:35:26.527] Tweak future expression to call with '...' arguments ... DONE
[13:35:26.528] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:26.528] 
[13:35:26.528] getGlobalsAndPackages() ... DONE
[13:35:26.528] run() for ‘Future’ ...
[13:35:26.528] - state: ‘created’
[13:35:26.528] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:26.532] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:26.532] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:26.532]   - Field: ‘label’
[13:35:26.532]   - Field: ‘local’
[13:35:26.532]   - Field: ‘owner’
[13:35:26.533]   - Field: ‘envir’
[13:35:26.534]   - Field: ‘packages’
[13:35:26.534]   - Field: ‘gc’
[13:35:26.534]   - Field: ‘conditions’
[13:35:26.534]   - Field: ‘expr’
[13:35:26.534]   - Field: ‘uuid’
[13:35:26.534]   - Field: ‘seed’
[13:35:26.534]   - Field: ‘version’
[13:35:26.534]   - Field: ‘result’
[13:35:26.534]   - Field: ‘asynchronous’
[13:35:26.534]   - Field: ‘calls’
[13:35:26.535]   - Field: ‘globals’
[13:35:26.535]   - Field: ‘stdout’
[13:35:26.535]   - Field: ‘earlySignal’
[13:35:26.535]   - Field: ‘lazy’
[13:35:26.535]   - Field: ‘state’
[13:35:26.535] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:26.535] - Launch lazy future ...
[13:35:26.535] Packages needed by the future expression (n = 0): <none>
[13:35:26.535] Packages needed by future strategies (n = 0): <none>
[13:35:26.536] {
[13:35:26.536]     {
[13:35:26.536]         {
[13:35:26.536]             ...future.startTime <- base::Sys.time()
[13:35:26.536]             {
[13:35:26.536]                 {
[13:35:26.536]                   {
[13:35:26.536]                     base::local({
[13:35:26.536]                       has_future <- base::requireNamespace("future", 
[13:35:26.536]                         quietly = TRUE)
[13:35:26.536]                       if (has_future) {
[13:35:26.536]                         ns <- base::getNamespace("future")
[13:35:26.536]                         version <- ns[[".package"]][["version"]]
[13:35:26.536]                         if (is.null(version)) 
[13:35:26.536]                           version <- utils::packageVersion("future")
[13:35:26.536]                       }
[13:35:26.536]                       else {
[13:35:26.536]                         version <- NULL
[13:35:26.536]                       }
[13:35:26.536]                       if (!has_future || version < "1.8.0") {
[13:35:26.536]                         info <- base::c(r_version = base::gsub("R version ", 
[13:35:26.536]                           "", base::R.version$version.string), 
[13:35:26.536]                           platform = base::sprintf("%s (%s-bit)", 
[13:35:26.536]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:26.536]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:26.536]                             "release", "version")], collapse = " "), 
[13:35:26.536]                           hostname = base::Sys.info()[["nodename"]])
[13:35:26.536]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:35:26.536]                           info)
[13:35:26.536]                         info <- base::paste(info, collapse = "; ")
[13:35:26.536]                         if (!has_future) {
[13:35:26.536]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:26.536]                             info)
[13:35:26.536]                         }
[13:35:26.536]                         else {
[13:35:26.536]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:26.536]                             info, version)
[13:35:26.536]                         }
[13:35:26.536]                         base::stop(msg)
[13:35:26.536]                       }
[13:35:26.536]                     })
[13:35:26.536]                   }
[13:35:26.536]                   ...future.strategy.old <- future::plan("list")
[13:35:26.536]                   options(future.plan = NULL)
[13:35:26.536]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:26.536]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:26.536]                 }
[13:35:26.536]                 ...future.workdir <- getwd()
[13:35:26.536]             }
[13:35:26.536]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:26.536]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:26.536]         }
[13:35:26.536]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:26.536]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:26.536]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:26.536]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:26.536]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:26.536]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:26.536]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:26.536]             base::names(...future.oldOptions))
[13:35:26.536]     }
[13:35:26.536]     if (FALSE) {
[13:35:26.536]     }
[13:35:26.536]     else {
[13:35:26.536]         if (FALSE) {
[13:35:26.536]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:26.536]                 open = "w")
[13:35:26.536]         }
[13:35:26.536]         else {
[13:35:26.536]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:26.536]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:26.536]         }
[13:35:26.536]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:26.536]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:26.536]             base::sink(type = "output", split = FALSE)
[13:35:26.536]             base::close(...future.stdout)
[13:35:26.536]         }, add = TRUE)
[13:35:26.536]     }
[13:35:26.536]     ...future.frame <- base::sys.nframe()
[13:35:26.536]     ...future.conditions <- base::list()
[13:35:26.536]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:26.536]     if (FALSE) {
[13:35:26.536]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:26.536]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:26.536]     }
[13:35:26.536]     ...future.result <- base::tryCatch({
[13:35:26.536]         base::withCallingHandlers({
[13:35:26.536]             ...future.value <- base::withVisible(base::local({
[13:35:26.536]                 do.call(function(...) {
[13:35:26.536]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:26.536]                   if (!identical(...future.globals.maxSize.org, 
[13:35:26.536]                     ...future.globals.maxSize)) {
[13:35:26.536]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:26.536]                     on.exit(options(oopts), add = TRUE)
[13:35:26.536]                   }
[13:35:26.536]                   {
[13:35:26.536]                     lapply(seq_along(...future.elements_ii), 
[13:35:26.536]                       FUN = function(jj) {
[13:35:26.536]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:26.536]                         ...future.FUN(...future.X_jj, ...)
[13:35:26.536]                       })
[13:35:26.536]                   }
[13:35:26.536]                 }, args = future.call.arguments)
[13:35:26.536]             }))
[13:35:26.536]             future::FutureResult(value = ...future.value$value, 
[13:35:26.536]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:26.536]                   ...future.rng), globalenv = if (FALSE) 
[13:35:26.536]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:26.536]                     ...future.globalenv.names))
[13:35:26.536]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:26.536]         }, condition = base::local({
[13:35:26.536]             c <- base::c
[13:35:26.536]             inherits <- base::inherits
[13:35:26.536]             invokeRestart <- base::invokeRestart
[13:35:26.536]             length <- base::length
[13:35:26.536]             list <- base::list
[13:35:26.536]             seq.int <- base::seq.int
[13:35:26.536]             signalCondition <- base::signalCondition
[13:35:26.536]             sys.calls <- base::sys.calls
[13:35:26.536]             `[[` <- base::`[[`
[13:35:26.536]             `+` <- base::`+`
[13:35:26.536]             `<<-` <- base::`<<-`
[13:35:26.536]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:26.536]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:26.536]                   3L)]
[13:35:26.536]             }
[13:35:26.536]             function(cond) {
[13:35:26.536]                 is_error <- inherits(cond, "error")
[13:35:26.536]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:26.536]                   NULL)
[13:35:26.536]                 if (is_error) {
[13:35:26.536]                   sessionInformation <- function() {
[13:35:26.536]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:26.536]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:26.536]                       search = base::search(), system = base::Sys.info())
[13:35:26.536]                   }
[13:35:26.536]                   ...future.conditions[[length(...future.conditions) + 
[13:35:26.536]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:26.536]                     cond$call), session = sessionInformation(), 
[13:35:26.536]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:26.536]                   signalCondition(cond)
[13:35:26.536]                 }
[13:35:26.536]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:26.536]                 "immediateCondition"))) {
[13:35:26.536]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:26.536]                   ...future.conditions[[length(...future.conditions) + 
[13:35:26.536]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:26.536]                   if (TRUE && !signal) {
[13:35:26.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:26.536]                     {
[13:35:26.536]                       inherits <- base::inherits
[13:35:26.536]                       invokeRestart <- base::invokeRestart
[13:35:26.536]                       is.null <- base::is.null
[13:35:26.536]                       muffled <- FALSE
[13:35:26.536]                       if (inherits(cond, "message")) {
[13:35:26.536]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:26.536]                         if (muffled) 
[13:35:26.536]                           invokeRestart("muffleMessage")
[13:35:26.536]                       }
[13:35:26.536]                       else if (inherits(cond, "warning")) {
[13:35:26.536]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:26.536]                         if (muffled) 
[13:35:26.536]                           invokeRestart("muffleWarning")
[13:35:26.536]                       }
[13:35:26.536]                       else if (inherits(cond, "condition")) {
[13:35:26.536]                         if (!is.null(pattern)) {
[13:35:26.536]                           computeRestarts <- base::computeRestarts
[13:35:26.536]                           grepl <- base::grepl
[13:35:26.536]                           restarts <- computeRestarts(cond)
[13:35:26.536]                           for (restart in restarts) {
[13:35:26.536]                             name <- restart$name
[13:35:26.536]                             if (is.null(name)) 
[13:35:26.536]                               next
[13:35:26.536]                             if (!grepl(pattern, name)) 
[13:35:26.536]                               next
[13:35:26.536]                             invokeRestart(restart)
[13:35:26.536]                             muffled <- TRUE
[13:35:26.536]                             break
[13:35:26.536]                           }
[13:35:26.536]                         }
[13:35:26.536]                       }
[13:35:26.536]                       invisible(muffled)
[13:35:26.536]                     }
[13:35:26.536]                     muffleCondition(cond, pattern = "^muffle")
[13:35:26.536]                   }
[13:35:26.536]                 }
[13:35:26.536]                 else {
[13:35:26.536]                   if (TRUE) {
[13:35:26.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:26.536]                     {
[13:35:26.536]                       inherits <- base::inherits
[13:35:26.536]                       invokeRestart <- base::invokeRestart
[13:35:26.536]                       is.null <- base::is.null
[13:35:26.536]                       muffled <- FALSE
[13:35:26.536]                       if (inherits(cond, "message")) {
[13:35:26.536]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:26.536]                         if (muffled) 
[13:35:26.536]                           invokeRestart("muffleMessage")
[13:35:26.536]                       }
[13:35:26.536]                       else if (inherits(cond, "warning")) {
[13:35:26.536]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:26.536]                         if (muffled) 
[13:35:26.536]                           invokeRestart("muffleWarning")
[13:35:26.536]                       }
[13:35:26.536]                       else if (inherits(cond, "condition")) {
[13:35:26.536]                         if (!is.null(pattern)) {
[13:35:26.536]                           computeRestarts <- base::computeRestarts
[13:35:26.536]                           grepl <- base::grepl
[13:35:26.536]                           restarts <- computeRestarts(cond)
[13:35:26.536]                           for (restart in restarts) {
[13:35:26.536]                             name <- restart$name
[13:35:26.536]                             if (is.null(name)) 
[13:35:26.536]                               next
[13:35:26.536]                             if (!grepl(pattern, name)) 
[13:35:26.536]                               next
[13:35:26.536]                             invokeRestart(restart)
[13:35:26.536]                             muffled <- TRUE
[13:35:26.536]                             break
[13:35:26.536]                           }
[13:35:26.536]                         }
[13:35:26.536]                       }
[13:35:26.536]                       invisible(muffled)
[13:35:26.536]                     }
[13:35:26.536]                     muffleCondition(cond, pattern = "^muffle")
[13:35:26.536]                   }
[13:35:26.536]                 }
[13:35:26.536]             }
[13:35:26.536]         }))
[13:35:26.536]     }, error = function(ex) {
[13:35:26.536]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:26.536]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:26.536]                 ...future.rng), started = ...future.startTime, 
[13:35:26.536]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:26.536]             version = "1.8"), class = "FutureResult")
[13:35:26.536]     }, finally = {
[13:35:26.536]         if (!identical(...future.workdir, getwd())) 
[13:35:26.536]             setwd(...future.workdir)
[13:35:26.536]         {
[13:35:26.536]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:26.536]                 ...future.oldOptions$nwarnings <- NULL
[13:35:26.536]             }
[13:35:26.536]             base::options(...future.oldOptions)
[13:35:26.536]             if (.Platform$OS.type == "windows") {
[13:35:26.536]                 old_names <- names(...future.oldEnvVars)
[13:35:26.536]                 envs <- base::Sys.getenv()
[13:35:26.536]                 names <- names(envs)
[13:35:26.536]                 common <- intersect(names, old_names)
[13:35:26.536]                 added <- setdiff(names, old_names)
[13:35:26.536]                 removed <- setdiff(old_names, names)
[13:35:26.536]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:26.536]                   envs[common]]
[13:35:26.536]                 NAMES <- toupper(changed)
[13:35:26.536]                 args <- list()
[13:35:26.536]                 for (kk in seq_along(NAMES)) {
[13:35:26.536]                   name <- changed[[kk]]
[13:35:26.536]                   NAME <- NAMES[[kk]]
[13:35:26.536]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:26.536]                     next
[13:35:26.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:26.536]                 }
[13:35:26.536]                 NAMES <- toupper(added)
[13:35:26.536]                 for (kk in seq_along(NAMES)) {
[13:35:26.536]                   name <- added[[kk]]
[13:35:26.536]                   NAME <- NAMES[[kk]]
[13:35:26.536]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:26.536]                     next
[13:35:26.536]                   args[[name]] <- ""
[13:35:26.536]                 }
[13:35:26.536]                 NAMES <- toupper(removed)
[13:35:26.536]                 for (kk in seq_along(NAMES)) {
[13:35:26.536]                   name <- removed[[kk]]
[13:35:26.536]                   NAME <- NAMES[[kk]]
[13:35:26.536]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:26.536]                     next
[13:35:26.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:26.536]                 }
[13:35:26.536]                 if (length(args) > 0) 
[13:35:26.536]                   base::do.call(base::Sys.setenv, args = args)
[13:35:26.536]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:26.536]             }
[13:35:26.536]             else {
[13:35:26.536]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:26.536]             }
[13:35:26.536]             {
[13:35:26.536]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:26.536]                   0L) {
[13:35:26.536]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:26.536]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:26.536]                   base::options(opts)
[13:35:26.536]                 }
[13:35:26.536]                 {
[13:35:26.536]                   {
[13:35:26.536]                     NULL
[13:35:26.536]                     RNGkind("Mersenne-Twister")
[13:35:26.536]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:26.536]                       inherits = FALSE)
[13:35:26.536]                   }
[13:35:26.536]                   options(future.plan = NULL)
[13:35:26.536]                   if (is.na(NA_character_)) 
[13:35:26.536]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:26.536]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:26.536]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:26.536]                     .init = FALSE)
[13:35:26.536]                 }
[13:35:26.536]             }
[13:35:26.536]         }
[13:35:26.536]     })
[13:35:26.536]     if (TRUE) {
[13:35:26.536]         base::sink(type = "output", split = FALSE)
[13:35:26.536]         if (FALSE) {
[13:35:26.536]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:26.536]         }
[13:35:26.536]         else {
[13:35:26.536]             ...future.result["stdout"] <- base::list(NULL)
[13:35:26.536]         }
[13:35:26.536]         base::close(...future.stdout)
[13:35:26.536]         ...future.stdout <- NULL
[13:35:26.536]     }
[13:35:26.536]     ...future.result$conditions <- ...future.conditions
[13:35:26.536]     ...future.result$finished <- base::Sys.time()
[13:35:26.536]     ...future.result
[13:35:26.536] }
[13:35:26.537] assign_globals() ...
[13:35:26.538] List of 5
[13:35:26.538]  $ ...future.FUN            :function (x)  
[13:35:26.538]  $ future.call.arguments    : list()
[13:35:26.538]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:26.538]  $ ...future.elements_ii    :List of 2
[13:35:26.538]   ..$ : int 1
[13:35:26.538]   ..$ : int 0
[13:35:26.538]  $ ...future.seeds_ii       : NULL
[13:35:26.538]  $ ...future.globals.maxSize: NULL
[13:35:26.538]  - attr(*, "where")=List of 5
[13:35:26.538]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:26.538]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:26.538]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:26.538]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:26.538]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:26.538]  - attr(*, "resolved")= logi FALSE
[13:35:26.538]  - attr(*, "total_size")= num 4720
[13:35:26.538]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:26.538]  - attr(*, "already-done")= logi TRUE
[13:35:26.542] - reassign environment for ‘...future.FUN’
[13:35:26.542] - copied ‘...future.FUN’ to environment
[13:35:26.542] - copied ‘future.call.arguments’ to environment
[13:35:26.542] - copied ‘...future.elements_ii’ to environment
[13:35:26.543] - copied ‘...future.seeds_ii’ to environment
[13:35:26.543] - copied ‘...future.globals.maxSize’ to environment
[13:35:26.543] assign_globals() ... done
[13:35:26.543] plan(): Setting new future strategy stack:
[13:35:26.543] List of future strategies:
[13:35:26.543] 1. sequential:
[13:35:26.543]    - args: function (..., envir = parent.frame())
[13:35:26.543]    - tweaked: FALSE
[13:35:26.543]    - call: NULL
[13:35:26.543] plan(): nbrOfWorkers() = 1
[13:35:27.045] plan(): Setting new future strategy stack:
[13:35:27.045] List of future strategies:
[13:35:27.045] 1. multisession:
[13:35:27.045]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:35:27.045]    - tweaked: FALSE
[13:35:27.045]    - call: plan(strategy)
[13:35:27.049] plan(): nbrOfWorkers() = 1
[13:35:27.049] SequentialFuture started (and completed)
[13:35:27.049] - Launch lazy future ... done
[13:35:27.049] run() for ‘SequentialFuture’ ... done
[13:35:27.049] Created future:
[13:35:27.049] SequentialFuture:
[13:35:27.049] Label: ‘future_lapply-1’
[13:35:27.049] Expression:
[13:35:27.049] {
[13:35:27.049]     do.call(function(...) {
[13:35:27.049]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:27.049]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:27.049]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:27.049]             on.exit(options(oopts), add = TRUE)
[13:35:27.049]         }
[13:35:27.049]         {
[13:35:27.049]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:27.049]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:27.049]                 ...future.FUN(...future.X_jj, ...)
[13:35:27.049]             })
[13:35:27.049]         }
[13:35:27.049]     }, args = future.call.arguments)
[13:35:27.049] }
[13:35:27.049] Lazy evaluation: FALSE
[13:35:27.049] Asynchronous evaluation: FALSE
[13:35:27.049] Local evaluation: TRUE
[13:35:27.049] Environment: R_GlobalEnv
[13:35:27.049] Capture standard output: FALSE
[13:35:27.049] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:27.049] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:27.049] Packages: <none>
[13:35:27.049] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:27.049] Resolved: TRUE
[13:35:27.049] Value: 112 bytes of class ‘list’
[13:35:27.049] Early signaling: FALSE
[13:35:27.049] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:27.049] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:27.050] Chunk #1 of 1 ... DONE
[13:35:27.051] Launching 1 futures (chunks) ... DONE
[13:35:27.051] Resolving 1 futures (chunks) ...
[13:35:27.051] resolve() on list ...
[13:35:27.051]  recursive: 0
[13:35:27.051]  length: 1
[13:35:27.051] 
[13:35:27.051] resolved() for ‘SequentialFuture’ ...
[13:35:27.051] - state: ‘finished’
[13:35:27.051] - run: TRUE
[13:35:27.051] - result: ‘FutureResult’
[13:35:27.052] resolved() for ‘SequentialFuture’ ... done
[13:35:27.052] Future #1
[13:35:27.052] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:27.052] - nx: 1
[13:35:27.052] - relay: TRUE
[13:35:27.052] - stdout: TRUE
[13:35:27.052] - signal: TRUE
[13:35:27.052] - resignal: FALSE
[13:35:27.052] - force: TRUE
[13:35:27.052] - relayed: [n=1] FALSE
[13:35:27.052] - queued futures: [n=1] FALSE
[13:35:27.053]  - until=1
[13:35:27.053]  - relaying element #1
[13:35:27.053] - relayed: [n=1] TRUE
[13:35:27.053] - queued futures: [n=1] TRUE
[13:35:27.053] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:27.053]  length: 0 (resolved future 1)
[13:35:27.053] Relaying remaining futures
[13:35:27.053] signalConditionsASAP(NULL, pos=0) ...
[13:35:27.053] - nx: 1
[13:35:27.053] - relay: TRUE
[13:35:27.054] - stdout: TRUE
[13:35:27.054] - signal: TRUE
[13:35:27.054] - resignal: FALSE
[13:35:27.054] - force: TRUE
[13:35:27.054] - relayed: [n=1] TRUE
[13:35:27.054] - queued futures: [n=1] TRUE
 - flush all
[13:35:27.054] - relayed: [n=1] TRUE
[13:35:27.054] - queued futures: [n=1] TRUE
[13:35:27.054] signalConditionsASAP(NULL, pos=0) ... done
[13:35:27.054] resolve() on list ... DONE
[13:35:27.055]  - Number of value chunks collected: 1
[13:35:27.055] Resolving 1 futures (chunks) ... DONE
[13:35:27.055] Reducing values from 1 chunks ...
[13:35:27.055]  - Number of values collected after concatenation: 2
[13:35:27.055]  - Number of values expected: 2
[13:35:27.055] Reducing values from 1 chunks ... DONE
[13:35:27.055] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[13:35:27.055] future_lapply() ...
[13:35:27.059] Number of chunks: 1
[13:35:27.059] getGlobalsAndPackagesXApply() ...
[13:35:27.059]  - future.globals: TRUE
[13:35:27.059] getGlobalsAndPackages() ...
[13:35:27.060] Searching for globals...
[13:35:27.061] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:35:27.061] Searching for globals ... DONE
[13:35:27.061] Resolving globals: FALSE
[13:35:27.061] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:35:27.062] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:35:27.062] - globals: [1] ‘FUN’
[13:35:27.062] 
[13:35:27.062] getGlobalsAndPackages() ... DONE
[13:35:27.062]  - globals found/used: [n=1] ‘FUN’
[13:35:27.062]  - needed namespaces: [n=0] 
[13:35:27.062] Finding globals ... DONE
[13:35:27.063]  - use_args: TRUE
[13:35:27.063]  - Getting '...' globals ...
[13:35:27.063] resolve() on list ...
[13:35:27.063]  recursive: 0
[13:35:27.063]  length: 1
[13:35:27.063]  elements: ‘...’
[13:35:27.063]  length: 0 (resolved future 1)
[13:35:27.063] resolve() on list ... DONE
[13:35:27.063]    - '...' content: [n=0] 
[13:35:27.064] List of 1
[13:35:27.064]  $ ...: list()
[13:35:27.064]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:27.064]  - attr(*, "where")=List of 1
[13:35:27.064]   ..$ ...:<environment: 0x558d385e9b98> 
[13:35:27.064]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:27.064]  - attr(*, "resolved")= logi TRUE
[13:35:27.064]  - attr(*, "total_size")= num NA
[13:35:27.068]  - Getting '...' globals ... DONE
[13:35:27.068] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:35:27.068] List of 2
[13:35:27.068]  $ ...future.FUN:function (x)  
[13:35:27.068]  $ ...          : list()
[13:35:27.068]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:27.068]  - attr(*, "where")=List of 2
[13:35:27.068]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:27.068]   ..$ ...          :<environment: 0x558d385e9b98> 
[13:35:27.068]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:27.068]  - attr(*, "resolved")= logi FALSE
[13:35:27.068]  - attr(*, "total_size")= num 4720
[13:35:27.071] Packages to be attached in all futures: [n=0] 
[13:35:27.071] getGlobalsAndPackagesXApply() ... DONE
[13:35:27.071] Number of futures (= number of chunks): 1
[13:35:27.071] Launching 1 futures (chunks) ...
[13:35:27.072] Chunk #1 of 1 ...
[13:35:27.072]  - Finding globals in 'X' for chunk #1 ...
[13:35:27.072] getGlobalsAndPackages() ...
[13:35:27.072] Searching for globals...
[13:35:27.072] 
[13:35:27.072] Searching for globals ... DONE
[13:35:27.072] - globals: [0] <none>
[13:35:27.072] getGlobalsAndPackages() ... DONE
[13:35:27.072]    + additional globals found: [n=0] 
[13:35:27.073]    + additional namespaces needed: [n=0] 
[13:35:27.073]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:27.073]  - seeds: <none>
[13:35:27.073]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:27.073] getGlobalsAndPackages() ...
[13:35:27.073] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:27.073] Resolving globals: FALSE
[13:35:27.073] Tweak future expression to call with '...' arguments ...
[13:35:27.073] {
[13:35:27.073]     do.call(function(...) {
[13:35:27.073]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:27.073]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:27.073]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:27.073]             on.exit(options(oopts), add = TRUE)
[13:35:27.073]         }
[13:35:27.073]         {
[13:35:27.073]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:27.073]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:27.073]                 ...future.FUN(...future.X_jj, ...)
[13:35:27.073]             })
[13:35:27.073]         }
[13:35:27.073]     }, args = future.call.arguments)
[13:35:27.073] }
[13:35:27.074] Tweak future expression to call with '...' arguments ... DONE
[13:35:27.074] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:27.074] 
[13:35:27.074] getGlobalsAndPackages() ... DONE
[13:35:27.074] run() for ‘Future’ ...
[13:35:27.075] - state: ‘created’
[13:35:27.075] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:27.078] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:27.078] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:27.078]   - Field: ‘label’
[13:35:27.078]   - Field: ‘local’
[13:35:27.078]   - Field: ‘owner’
[13:35:27.078]   - Field: ‘envir’
[13:35:27.078]   - Field: ‘packages’
[13:35:27.079]   - Field: ‘gc’
[13:35:27.079]   - Field: ‘conditions’
[13:35:27.079]   - Field: ‘expr’
[13:35:27.079]   - Field: ‘uuid’
[13:35:27.079]   - Field: ‘seed’
[13:35:27.079]   - Field: ‘version’
[13:35:27.079]   - Field: ‘result’
[13:35:27.079]   - Field: ‘asynchronous’
[13:35:27.079]   - Field: ‘calls’
[13:35:27.079]   - Field: ‘globals’
[13:35:27.079]   - Field: ‘stdout’
[13:35:27.079]   - Field: ‘earlySignal’
[13:35:27.080]   - Field: ‘lazy’
[13:35:27.080]   - Field: ‘state’
[13:35:27.080] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:27.080] - Launch lazy future ...
[13:35:27.080] Packages needed by the future expression (n = 0): <none>
[13:35:27.080] Packages needed by future strategies (n = 0): <none>
[13:35:27.081] {
[13:35:27.081]     {
[13:35:27.081]         {
[13:35:27.081]             ...future.startTime <- base::Sys.time()
[13:35:27.081]             {
[13:35:27.081]                 {
[13:35:27.081]                   {
[13:35:27.081]                     base::local({
[13:35:27.081]                       has_future <- base::requireNamespace("future", 
[13:35:27.081]                         quietly = TRUE)
[13:35:27.081]                       if (has_future) {
[13:35:27.081]                         ns <- base::getNamespace("future")
[13:35:27.081]                         version <- ns[[".package"]][["version"]]
[13:35:27.081]                         if (is.null(version)) 
[13:35:27.081]                           version <- utils::packageVersion("future")
[13:35:27.081]                       }
[13:35:27.081]                       else {
[13:35:27.081]                         version <- NULL
[13:35:27.081]                       }
[13:35:27.081]                       if (!has_future || version < "1.8.0") {
[13:35:27.081]                         info <- base::c(r_version = base::gsub("R version ", 
[13:35:27.081]                           "", base::R.version$version.string), 
[13:35:27.081]                           platform = base::sprintf("%s (%s-bit)", 
[13:35:27.081]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:27.081]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:27.081]                             "release", "version")], collapse = " "), 
[13:35:27.081]                           hostname = base::Sys.info()[["nodename"]])
[13:35:27.081]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:35:27.081]                           info)
[13:35:27.081]                         info <- base::paste(info, collapse = "; ")
[13:35:27.081]                         if (!has_future) {
[13:35:27.081]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:27.081]                             info)
[13:35:27.081]                         }
[13:35:27.081]                         else {
[13:35:27.081]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:27.081]                             info, version)
[13:35:27.081]                         }
[13:35:27.081]                         base::stop(msg)
[13:35:27.081]                       }
[13:35:27.081]                     })
[13:35:27.081]                   }
[13:35:27.081]                   ...future.strategy.old <- future::plan("list")
[13:35:27.081]                   options(future.plan = NULL)
[13:35:27.081]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:27.081]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:27.081]                 }
[13:35:27.081]                 ...future.workdir <- getwd()
[13:35:27.081]             }
[13:35:27.081]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:27.081]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:27.081]         }
[13:35:27.081]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:27.081]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:27.081]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:27.081]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:27.081]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:27.081]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:27.081]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:27.081]             base::names(...future.oldOptions))
[13:35:27.081]     }
[13:35:27.081]     if (FALSE) {
[13:35:27.081]     }
[13:35:27.081]     else {
[13:35:27.081]         if (TRUE) {
[13:35:27.081]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:27.081]                 open = "w")
[13:35:27.081]         }
[13:35:27.081]         else {
[13:35:27.081]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:27.081]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:27.081]         }
[13:35:27.081]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:27.081]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:27.081]             base::sink(type = "output", split = FALSE)
[13:35:27.081]             base::close(...future.stdout)
[13:35:27.081]         }, add = TRUE)
[13:35:27.081]     }
[13:35:27.081]     ...future.frame <- base::sys.nframe()
[13:35:27.081]     ...future.conditions <- base::list()
[13:35:27.081]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:27.081]     if (FALSE) {
[13:35:27.081]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:27.081]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:27.081]     }
[13:35:27.081]     ...future.result <- base::tryCatch({
[13:35:27.081]         base::withCallingHandlers({
[13:35:27.081]             ...future.value <- base::withVisible(base::local({
[13:35:27.081]                 do.call(function(...) {
[13:35:27.081]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:27.081]                   if (!identical(...future.globals.maxSize.org, 
[13:35:27.081]                     ...future.globals.maxSize)) {
[13:35:27.081]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:27.081]                     on.exit(options(oopts), add = TRUE)
[13:35:27.081]                   }
[13:35:27.081]                   {
[13:35:27.081]                     lapply(seq_along(...future.elements_ii), 
[13:35:27.081]                       FUN = function(jj) {
[13:35:27.081]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:27.081]                         ...future.FUN(...future.X_jj, ...)
[13:35:27.081]                       })
[13:35:27.081]                   }
[13:35:27.081]                 }, args = future.call.arguments)
[13:35:27.081]             }))
[13:35:27.081]             future::FutureResult(value = ...future.value$value, 
[13:35:27.081]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:27.081]                   ...future.rng), globalenv = if (FALSE) 
[13:35:27.081]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:27.081]                     ...future.globalenv.names))
[13:35:27.081]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:27.081]         }, condition = base::local({
[13:35:27.081]             c <- base::c
[13:35:27.081]             inherits <- base::inherits
[13:35:27.081]             invokeRestart <- base::invokeRestart
[13:35:27.081]             length <- base::length
[13:35:27.081]             list <- base::list
[13:35:27.081]             seq.int <- base::seq.int
[13:35:27.081]             signalCondition <- base::signalCondition
[13:35:27.081]             sys.calls <- base::sys.calls
[13:35:27.081]             `[[` <- base::`[[`
[13:35:27.081]             `+` <- base::`+`
[13:35:27.081]             `<<-` <- base::`<<-`
[13:35:27.081]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:27.081]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:27.081]                   3L)]
[13:35:27.081]             }
[13:35:27.081]             function(cond) {
[13:35:27.081]                 is_error <- inherits(cond, "error")
[13:35:27.081]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:27.081]                   NULL)
[13:35:27.081]                 if (is_error) {
[13:35:27.081]                   sessionInformation <- function() {
[13:35:27.081]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:27.081]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:27.081]                       search = base::search(), system = base::Sys.info())
[13:35:27.081]                   }
[13:35:27.081]                   ...future.conditions[[length(...future.conditions) + 
[13:35:27.081]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:27.081]                     cond$call), session = sessionInformation(), 
[13:35:27.081]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:27.081]                   signalCondition(cond)
[13:35:27.081]                 }
[13:35:27.081]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:27.081]                 "immediateCondition"))) {
[13:35:27.081]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:27.081]                   ...future.conditions[[length(...future.conditions) + 
[13:35:27.081]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:27.081]                   if (TRUE && !signal) {
[13:35:27.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:27.081]                     {
[13:35:27.081]                       inherits <- base::inherits
[13:35:27.081]                       invokeRestart <- base::invokeRestart
[13:35:27.081]                       is.null <- base::is.null
[13:35:27.081]                       muffled <- FALSE
[13:35:27.081]                       if (inherits(cond, "message")) {
[13:35:27.081]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:27.081]                         if (muffled) 
[13:35:27.081]                           invokeRestart("muffleMessage")
[13:35:27.081]                       }
[13:35:27.081]                       else if (inherits(cond, "warning")) {
[13:35:27.081]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:27.081]                         if (muffled) 
[13:35:27.081]                           invokeRestart("muffleWarning")
[13:35:27.081]                       }
[13:35:27.081]                       else if (inherits(cond, "condition")) {
[13:35:27.081]                         if (!is.null(pattern)) {
[13:35:27.081]                           computeRestarts <- base::computeRestarts
[13:35:27.081]                           grepl <- base::grepl
[13:35:27.081]                           restarts <- computeRestarts(cond)
[13:35:27.081]                           for (restart in restarts) {
[13:35:27.081]                             name <- restart$name
[13:35:27.081]                             if (is.null(name)) 
[13:35:27.081]                               next
[13:35:27.081]                             if (!grepl(pattern, name)) 
[13:35:27.081]                               next
[13:35:27.081]                             invokeRestart(restart)
[13:35:27.081]                             muffled <- TRUE
[13:35:27.081]                             break
[13:35:27.081]                           }
[13:35:27.081]                         }
[13:35:27.081]                       }
[13:35:27.081]                       invisible(muffled)
[13:35:27.081]                     }
[13:35:27.081]                     muffleCondition(cond, pattern = "^muffle")
[13:35:27.081]                   }
[13:35:27.081]                 }
[13:35:27.081]                 else {
[13:35:27.081]                   if (TRUE) {
[13:35:27.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:27.081]                     {
[13:35:27.081]                       inherits <- base::inherits
[13:35:27.081]                       invokeRestart <- base::invokeRestart
[13:35:27.081]                       is.null <- base::is.null
[13:35:27.081]                       muffled <- FALSE
[13:35:27.081]                       if (inherits(cond, "message")) {
[13:35:27.081]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:27.081]                         if (muffled) 
[13:35:27.081]                           invokeRestart("muffleMessage")
[13:35:27.081]                       }
[13:35:27.081]                       else if (inherits(cond, "warning")) {
[13:35:27.081]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:27.081]                         if (muffled) 
[13:35:27.081]                           invokeRestart("muffleWarning")
[13:35:27.081]                       }
[13:35:27.081]                       else if (inherits(cond, "condition")) {
[13:35:27.081]                         if (!is.null(pattern)) {
[13:35:27.081]                           computeRestarts <- base::computeRestarts
[13:35:27.081]                           grepl <- base::grepl
[13:35:27.081]                           restarts <- computeRestarts(cond)
[13:35:27.081]                           for (restart in restarts) {
[13:35:27.081]                             name <- restart$name
[13:35:27.081]                             if (is.null(name)) 
[13:35:27.081]                               next
[13:35:27.081]                             if (!grepl(pattern, name)) 
[13:35:27.081]                               next
[13:35:27.081]                             invokeRestart(restart)
[13:35:27.081]                             muffled <- TRUE
[13:35:27.081]                             break
[13:35:27.081]                           }
[13:35:27.081]                         }
[13:35:27.081]                       }
[13:35:27.081]                       invisible(muffled)
[13:35:27.081]                     }
[13:35:27.081]                     muffleCondition(cond, pattern = "^muffle")
[13:35:27.081]                   }
[13:35:27.081]                 }
[13:35:27.081]             }
[13:35:27.081]         }))
[13:35:27.081]     }, error = function(ex) {
[13:35:27.081]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:27.081]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:27.081]                 ...future.rng), started = ...future.startTime, 
[13:35:27.081]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:27.081]             version = "1.8"), class = "FutureResult")
[13:35:27.081]     }, finally = {
[13:35:27.081]         if (!identical(...future.workdir, getwd())) 
[13:35:27.081]             setwd(...future.workdir)
[13:35:27.081]         {
[13:35:27.081]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:27.081]                 ...future.oldOptions$nwarnings <- NULL
[13:35:27.081]             }
[13:35:27.081]             base::options(...future.oldOptions)
[13:35:27.081]             if (.Platform$OS.type == "windows") {
[13:35:27.081]                 old_names <- names(...future.oldEnvVars)
[13:35:27.081]                 envs <- base::Sys.getenv()
[13:35:27.081]                 names <- names(envs)
[13:35:27.081]                 common <- intersect(names, old_names)
[13:35:27.081]                 added <- setdiff(names, old_names)
[13:35:27.081]                 removed <- setdiff(old_names, names)
[13:35:27.081]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:27.081]                   envs[common]]
[13:35:27.081]                 NAMES <- toupper(changed)
[13:35:27.081]                 args <- list()
[13:35:27.081]                 for (kk in seq_along(NAMES)) {
[13:35:27.081]                   name <- changed[[kk]]
[13:35:27.081]                   NAME <- NAMES[[kk]]
[13:35:27.081]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:27.081]                     next
[13:35:27.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:27.081]                 }
[13:35:27.081]                 NAMES <- toupper(added)
[13:35:27.081]                 for (kk in seq_along(NAMES)) {
[13:35:27.081]                   name <- added[[kk]]
[13:35:27.081]                   NAME <- NAMES[[kk]]
[13:35:27.081]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:27.081]                     next
[13:35:27.081]                   args[[name]] <- ""
[13:35:27.081]                 }
[13:35:27.081]                 NAMES <- toupper(removed)
[13:35:27.081]                 for (kk in seq_along(NAMES)) {
[13:35:27.081]                   name <- removed[[kk]]
[13:35:27.081]                   NAME <- NAMES[[kk]]
[13:35:27.081]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:27.081]                     next
[13:35:27.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:27.081]                 }
[13:35:27.081]                 if (length(args) > 0) 
[13:35:27.081]                   base::do.call(base::Sys.setenv, args = args)
[13:35:27.081]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:27.081]             }
[13:35:27.081]             else {
[13:35:27.081]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:27.081]             }
[13:35:27.081]             {
[13:35:27.081]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:27.081]                   0L) {
[13:35:27.081]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:27.081]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:27.081]                   base::options(opts)
[13:35:27.081]                 }
[13:35:27.081]                 {
[13:35:27.081]                   {
[13:35:27.081]                     NULL
[13:35:27.081]                     RNGkind("Mersenne-Twister")
[13:35:27.081]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:27.081]                       inherits = FALSE)
[13:35:27.081]                   }
[13:35:27.081]                   options(future.plan = NULL)
[13:35:27.081]                   if (is.na(NA_character_)) 
[13:35:27.081]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:27.081]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:27.081]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:27.081]                     .init = FALSE)
[13:35:27.081]                 }
[13:35:27.081]             }
[13:35:27.081]         }
[13:35:27.081]     })
[13:35:27.081]     if (TRUE) {
[13:35:27.081]         base::sink(type = "output", split = FALSE)
[13:35:27.081]         if (TRUE) {
[13:35:27.081]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:27.081]         }
[13:35:27.081]         else {
[13:35:27.081]             ...future.result["stdout"] <- base::list(NULL)
[13:35:27.081]         }
[13:35:27.081]         base::close(...future.stdout)
[13:35:27.081]         ...future.stdout <- NULL
[13:35:27.081]     }
[13:35:27.081]     ...future.result$conditions <- ...future.conditions
[13:35:27.081]     ...future.result$finished <- base::Sys.time()
[13:35:27.081]     ...future.result
[13:35:27.081] }
[13:35:27.082] assign_globals() ...
[13:35:27.082] List of 5
[13:35:27.082]  $ ...future.FUN            :function (x)  
[13:35:27.082]  $ future.call.arguments    : list()
[13:35:27.082]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:27.082]  $ ...future.elements_ii    :List of 2
[13:35:27.082]   ..$ : int 1
[13:35:27.082]   ..$ : int 0
[13:35:27.082]  $ ...future.seeds_ii       : NULL
[13:35:27.082]  $ ...future.globals.maxSize: NULL
[13:35:27.082]  - attr(*, "where")=List of 5
[13:35:27.082]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:27.082]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:27.082]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:27.082]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:27.082]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:27.082]  - attr(*, "resolved")= logi FALSE
[13:35:27.082]  - attr(*, "total_size")= num 4720
[13:35:27.082]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:27.082]  - attr(*, "already-done")= logi TRUE
[13:35:27.087] - reassign environment for ‘...future.FUN’
[13:35:27.087] - copied ‘...future.FUN’ to environment
[13:35:27.087] - copied ‘future.call.arguments’ to environment
[13:35:27.087] - copied ‘...future.elements_ii’ to environment
[13:35:27.087] - copied ‘...future.seeds_ii’ to environment
[13:35:27.087] - copied ‘...future.globals.maxSize’ to environment
[13:35:27.088] assign_globals() ... done
[13:35:27.088] plan(): Setting new future strategy stack:
[13:35:27.088] List of future strategies:
[13:35:27.088] 1. sequential:
[13:35:27.088]    - args: function (..., envir = parent.frame())
[13:35:27.088]    - tweaked: FALSE
[13:35:27.088]    - call: NULL
[13:35:27.088] plan(): nbrOfWorkers() = 1
[13:35:27.590] plan(): Setting new future strategy stack:
[13:35:27.590] List of future strategies:
[13:35:27.590] 1. multisession:
[13:35:27.590]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:35:27.590]    - tweaked: FALSE
[13:35:27.590]    - call: plan(strategy)
[13:35:27.594] plan(): nbrOfWorkers() = 1
[13:35:27.594] SequentialFuture started (and completed)
[13:35:27.594] - Launch lazy future ... done
[13:35:27.595] run() for ‘SequentialFuture’ ... done
[13:35:27.595] Created future:
[13:35:27.595] SequentialFuture:
[13:35:27.595] Label: ‘future_lapply-1’
[13:35:27.595] Expression:
[13:35:27.595] {
[13:35:27.595]     do.call(function(...) {
[13:35:27.595]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:27.595]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:27.595]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:27.595]             on.exit(options(oopts), add = TRUE)
[13:35:27.595]         }
[13:35:27.595]         {
[13:35:27.595]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:27.595]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:27.595]                 ...future.FUN(...future.X_jj, ...)
[13:35:27.595]             })
[13:35:27.595]         }
[13:35:27.595]     }, args = future.call.arguments)
[13:35:27.595] }
[13:35:27.595] Lazy evaluation: FALSE
[13:35:27.595] Asynchronous evaluation: FALSE
[13:35:27.595] Local evaluation: TRUE
[13:35:27.595] Environment: R_GlobalEnv
[13:35:27.595] Capture standard output: TRUE
[13:35:27.595] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:27.595] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:27.595] Packages: <none>
[13:35:27.595] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:27.595] Resolved: TRUE
[13:35:27.595] Value: 112 bytes of class ‘list’
[13:35:27.595] Early signaling: FALSE
[13:35:27.595] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:27.595] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:27.596] Chunk #1 of 1 ... DONE
[13:35:27.596] Launching 1 futures (chunks) ... DONE
[13:35:27.596] Resolving 1 futures (chunks) ...
[13:35:27.596] resolve() on list ...
[13:35:27.598]  recursive: 0
[13:35:27.598]  length: 1
[13:35:27.598] 
[13:35:27.598] resolved() for ‘SequentialFuture’ ...
[13:35:27.598] - state: ‘finished’
[13:35:27.598] - run: TRUE
[13:35:27.599] - result: ‘FutureResult’
[13:35:27.599] resolved() for ‘SequentialFuture’ ... done
[13:35:27.599] Future #1
[13:35:27.599] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:27.599] - nx: 1
[13:35:27.599] - relay: TRUE
[13:35:27.599] - stdout: TRUE
[13:35:27.599] - signal: TRUE
[13:35:27.600] - resignal: FALSE
[13:35:27.600] - force: TRUE
[13:35:27.600] - relayed: [n=1] FALSE
[13:35:27.600] - queued futures: [n=1] FALSE
[13:35:27.600]  - until=1
[13:35:27.600]  - relaying element #1
[13:35:27.600] - relayed: [n=1] TRUE
[13:35:27.600] - queued futures: [n=1] TRUE
[13:35:27.600] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:27.601]  length: 0 (resolved future 1)
[13:35:27.601] Relaying remaining futures
[13:35:27.601] signalConditionsASAP(NULL, pos=0) ...
[13:35:27.601] - nx: 1
[13:35:27.601] - relay: TRUE
[13:35:27.601] - stdout: TRUE
[13:35:27.601] - signal: TRUE
[13:35:27.601] - resignal: FALSE
[13:35:27.601] - force: TRUE
[13:35:27.601] - relayed: [n=1] TRUE
[13:35:27.601] - queued futures: [n=1] TRUE
 - flush all
[13:35:27.602] - relayed: [n=1] TRUE
[13:35:27.602] - queued futures: [n=1] TRUE
[13:35:27.602] signalConditionsASAP(NULL, pos=0) ... done
[13:35:27.602] resolve() on list ... DONE
[13:35:27.602]  - Number of value chunks collected: 1
[13:35:27.602] Resolving 1 futures (chunks) ... DONE
[13:35:27.602] Reducing values from 1 chunks ...
[13:35:27.602]  - Number of values collected after concatenation: 2
[13:35:27.602]  - Number of values expected: 2
[13:35:27.602] Reducing values from 1 chunks ... DONE
[13:35:27.603] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[13:35:27.603] future_lapply() ...
[13:35:27.607] Number of chunks: 1
[13:35:27.607] getGlobalsAndPackagesXApply() ...
[13:35:27.607]  - future.globals: TRUE
[13:35:27.607] getGlobalsAndPackages() ...
[13:35:27.607] Searching for globals...
[13:35:27.608] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:35:27.608] Searching for globals ... DONE
[13:35:27.609] Resolving globals: FALSE
[13:35:27.609] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:35:27.609] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:35:27.609] - globals: [1] ‘FUN’
[13:35:27.610] 
[13:35:27.610] getGlobalsAndPackages() ... DONE
[13:35:27.610]  - globals found/used: [n=1] ‘FUN’
[13:35:27.610]  - needed namespaces: [n=0] 
[13:35:27.610] Finding globals ... DONE
[13:35:27.610]  - use_args: TRUE
[13:35:27.610]  - Getting '...' globals ...
[13:35:27.610] resolve() on list ...
[13:35:27.611]  recursive: 0
[13:35:27.611]  length: 1
[13:35:27.611]  elements: ‘...’
[13:35:27.611]  length: 0 (resolved future 1)
[13:35:27.611] resolve() on list ... DONE
[13:35:27.611]    - '...' content: [n=0] 
[13:35:27.611] List of 1
[13:35:27.611]  $ ...: list()
[13:35:27.611]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:27.611]  - attr(*, "where")=List of 1
[13:35:27.611]   ..$ ...:<environment: 0x558d36f740b0> 
[13:35:27.611]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:27.611]  - attr(*, "resolved")= logi TRUE
[13:35:27.611]  - attr(*, "total_size")= num NA
[13:35:27.614]  - Getting '...' globals ... DONE
[13:35:27.614] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:35:27.614] List of 2
[13:35:27.614]  $ ...future.FUN:function (x)  
[13:35:27.614]  $ ...          : list()
[13:35:27.614]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:27.614]  - attr(*, "where")=List of 2
[13:35:27.614]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:27.614]   ..$ ...          :<environment: 0x558d36f740b0> 
[13:35:27.614]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:27.614]  - attr(*, "resolved")= logi FALSE
[13:35:27.614]  - attr(*, "total_size")= num 4720
[13:35:27.616] Packages to be attached in all futures: [n=0] 
[13:35:27.617] getGlobalsAndPackagesXApply() ... DONE
[13:35:27.617] Number of futures (= number of chunks): 1
[13:35:27.617] Launching 1 futures (chunks) ...
[13:35:27.617] Chunk #1 of 1 ...
[13:35:27.617]  - Finding globals in 'X' for chunk #1 ...
[13:35:27.617] getGlobalsAndPackages() ...
[13:35:27.617] Searching for globals...
[13:35:27.618] 
[13:35:27.618] Searching for globals ... DONE
[13:35:27.618] - globals: [0] <none>
[13:35:27.618] getGlobalsAndPackages() ... DONE
[13:35:27.618]    + additional globals found: [n=0] 
[13:35:27.618]    + additional namespaces needed: [n=0] 
[13:35:27.618]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:27.618]  - seeds: <none>
[13:35:27.618]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:27.618] getGlobalsAndPackages() ...
[13:35:27.619] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:27.619] Resolving globals: FALSE
[13:35:27.619] Tweak future expression to call with '...' arguments ...
[13:35:27.619] {
[13:35:27.619]     do.call(function(...) {
[13:35:27.619]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:27.619]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:27.619]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:27.619]             on.exit(options(oopts), add = TRUE)
[13:35:27.619]         }
[13:35:27.619]         {
[13:35:27.619]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:27.619]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:27.619]                 ...future.FUN(...future.X_jj, ...)
[13:35:27.619]             })
[13:35:27.619]         }
[13:35:27.619]     }, args = future.call.arguments)
[13:35:27.619] }
[13:35:27.619] Tweak future expression to call with '...' arguments ... DONE
[13:35:27.619] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:27.620] 
[13:35:27.620] getGlobalsAndPackages() ... DONE
[13:35:27.620] run() for ‘Future’ ...
[13:35:27.620] - state: ‘created’
[13:35:27.620] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:27.623] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:27.624] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:27.624]   - Field: ‘label’
[13:35:27.624]   - Field: ‘local’
[13:35:27.624]   - Field: ‘owner’
[13:35:27.624]   - Field: ‘envir’
[13:35:27.624]   - Field: ‘packages’
[13:35:27.624]   - Field: ‘gc’
[13:35:27.624]   - Field: ‘conditions’
[13:35:27.624]   - Field: ‘expr’
[13:35:27.624]   - Field: ‘uuid’
[13:35:27.625]   - Field: ‘seed’
[13:35:27.625]   - Field: ‘version’
[13:35:27.625]   - Field: ‘result’
[13:35:27.625]   - Field: ‘asynchronous’
[13:35:27.625]   - Field: ‘calls’
[13:35:27.625]   - Field: ‘globals’
[13:35:27.625]   - Field: ‘stdout’
[13:35:27.625]   - Field: ‘earlySignal’
[13:35:27.625]   - Field: ‘lazy’
[13:35:27.625]   - Field: ‘state’
[13:35:27.625] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:27.626] - Launch lazy future ...
[13:35:27.627] Packages needed by the future expression (n = 0): <none>
[13:35:27.627] Packages needed by future strategies (n = 0): <none>
[13:35:27.628] {
[13:35:27.628]     {
[13:35:27.628]         {
[13:35:27.628]             ...future.startTime <- base::Sys.time()
[13:35:27.628]             {
[13:35:27.628]                 {
[13:35:27.628]                   {
[13:35:27.628]                     base::local({
[13:35:27.628]                       has_future <- base::requireNamespace("future", 
[13:35:27.628]                         quietly = TRUE)
[13:35:27.628]                       if (has_future) {
[13:35:27.628]                         ns <- base::getNamespace("future")
[13:35:27.628]                         version <- ns[[".package"]][["version"]]
[13:35:27.628]                         if (is.null(version)) 
[13:35:27.628]                           version <- utils::packageVersion("future")
[13:35:27.628]                       }
[13:35:27.628]                       else {
[13:35:27.628]                         version <- NULL
[13:35:27.628]                       }
[13:35:27.628]                       if (!has_future || version < "1.8.0") {
[13:35:27.628]                         info <- base::c(r_version = base::gsub("R version ", 
[13:35:27.628]                           "", base::R.version$version.string), 
[13:35:27.628]                           platform = base::sprintf("%s (%s-bit)", 
[13:35:27.628]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:27.628]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:27.628]                             "release", "version")], collapse = " "), 
[13:35:27.628]                           hostname = base::Sys.info()[["nodename"]])
[13:35:27.628]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:35:27.628]                           info)
[13:35:27.628]                         info <- base::paste(info, collapse = "; ")
[13:35:27.628]                         if (!has_future) {
[13:35:27.628]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:27.628]                             info)
[13:35:27.628]                         }
[13:35:27.628]                         else {
[13:35:27.628]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:27.628]                             info, version)
[13:35:27.628]                         }
[13:35:27.628]                         base::stop(msg)
[13:35:27.628]                       }
[13:35:27.628]                     })
[13:35:27.628]                   }
[13:35:27.628]                   ...future.strategy.old <- future::plan("list")
[13:35:27.628]                   options(future.plan = NULL)
[13:35:27.628]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:27.628]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:27.628]                 }
[13:35:27.628]                 ...future.workdir <- getwd()
[13:35:27.628]             }
[13:35:27.628]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:27.628]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:27.628]         }
[13:35:27.628]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:27.628]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:27.628]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:27.628]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:27.628]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:27.628]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:27.628]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:27.628]             base::names(...future.oldOptions))
[13:35:27.628]     }
[13:35:27.628]     if (TRUE) {
[13:35:27.628]     }
[13:35:27.628]     else {
[13:35:27.628]         if (NA) {
[13:35:27.628]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:27.628]                 open = "w")
[13:35:27.628]         }
[13:35:27.628]         else {
[13:35:27.628]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:27.628]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:27.628]         }
[13:35:27.628]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:27.628]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:27.628]             base::sink(type = "output", split = FALSE)
[13:35:27.628]             base::close(...future.stdout)
[13:35:27.628]         }, add = TRUE)
[13:35:27.628]     }
[13:35:27.628]     ...future.frame <- base::sys.nframe()
[13:35:27.628]     ...future.conditions <- base::list()
[13:35:27.628]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:27.628]     if (FALSE) {
[13:35:27.628]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:27.628]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:27.628]     }
[13:35:27.628]     ...future.result <- base::tryCatch({
[13:35:27.628]         base::withCallingHandlers({
[13:35:27.628]             ...future.value <- base::withVisible(base::local({
[13:35:27.628]                 do.call(function(...) {
[13:35:27.628]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:27.628]                   if (!identical(...future.globals.maxSize.org, 
[13:35:27.628]                     ...future.globals.maxSize)) {
[13:35:27.628]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:27.628]                     on.exit(options(oopts), add = TRUE)
[13:35:27.628]                   }
[13:35:27.628]                   {
[13:35:27.628]                     lapply(seq_along(...future.elements_ii), 
[13:35:27.628]                       FUN = function(jj) {
[13:35:27.628]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:27.628]                         ...future.FUN(...future.X_jj, ...)
[13:35:27.628]                       })
[13:35:27.628]                   }
[13:35:27.628]                 }, args = future.call.arguments)
[13:35:27.628]             }))
[13:35:27.628]             future::FutureResult(value = ...future.value$value, 
[13:35:27.628]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:27.628]                   ...future.rng), globalenv = if (FALSE) 
[13:35:27.628]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:27.628]                     ...future.globalenv.names))
[13:35:27.628]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:27.628]         }, condition = base::local({
[13:35:27.628]             c <- base::c
[13:35:27.628]             inherits <- base::inherits
[13:35:27.628]             invokeRestart <- base::invokeRestart
[13:35:27.628]             length <- base::length
[13:35:27.628]             list <- base::list
[13:35:27.628]             seq.int <- base::seq.int
[13:35:27.628]             signalCondition <- base::signalCondition
[13:35:27.628]             sys.calls <- base::sys.calls
[13:35:27.628]             `[[` <- base::`[[`
[13:35:27.628]             `+` <- base::`+`
[13:35:27.628]             `<<-` <- base::`<<-`
[13:35:27.628]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:27.628]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:27.628]                   3L)]
[13:35:27.628]             }
[13:35:27.628]             function(cond) {
[13:35:27.628]                 is_error <- inherits(cond, "error")
[13:35:27.628]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:27.628]                   NULL)
[13:35:27.628]                 if (is_error) {
[13:35:27.628]                   sessionInformation <- function() {
[13:35:27.628]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:27.628]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:27.628]                       search = base::search(), system = base::Sys.info())
[13:35:27.628]                   }
[13:35:27.628]                   ...future.conditions[[length(...future.conditions) + 
[13:35:27.628]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:27.628]                     cond$call), session = sessionInformation(), 
[13:35:27.628]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:27.628]                   signalCondition(cond)
[13:35:27.628]                 }
[13:35:27.628]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:27.628]                 "immediateCondition"))) {
[13:35:27.628]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:27.628]                   ...future.conditions[[length(...future.conditions) + 
[13:35:27.628]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:27.628]                   if (TRUE && !signal) {
[13:35:27.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:27.628]                     {
[13:35:27.628]                       inherits <- base::inherits
[13:35:27.628]                       invokeRestart <- base::invokeRestart
[13:35:27.628]                       is.null <- base::is.null
[13:35:27.628]                       muffled <- FALSE
[13:35:27.628]                       if (inherits(cond, "message")) {
[13:35:27.628]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:27.628]                         if (muffled) 
[13:35:27.628]                           invokeRestart("muffleMessage")
[13:35:27.628]                       }
[13:35:27.628]                       else if (inherits(cond, "warning")) {
[13:35:27.628]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:27.628]                         if (muffled) 
[13:35:27.628]                           invokeRestart("muffleWarning")
[13:35:27.628]                       }
[13:35:27.628]                       else if (inherits(cond, "condition")) {
[13:35:27.628]                         if (!is.null(pattern)) {
[13:35:27.628]                           computeRestarts <- base::computeRestarts
[13:35:27.628]                           grepl <- base::grepl
[13:35:27.628]                           restarts <- computeRestarts(cond)
[13:35:27.628]                           for (restart in restarts) {
[13:35:27.628]                             name <- restart$name
[13:35:27.628]                             if (is.null(name)) 
[13:35:27.628]                               next
[13:35:27.628]                             if (!grepl(pattern, name)) 
[13:35:27.628]                               next
[13:35:27.628]                             invokeRestart(restart)
[13:35:27.628]                             muffled <- TRUE
[13:35:27.628]                             break
[13:35:27.628]                           }
[13:35:27.628]                         }
[13:35:27.628]                       }
[13:35:27.628]                       invisible(muffled)
[13:35:27.628]                     }
[13:35:27.628]                     muffleCondition(cond, pattern = "^muffle")
[13:35:27.628]                   }
[13:35:27.628]                 }
[13:35:27.628]                 else {
[13:35:27.628]                   if (TRUE) {
[13:35:27.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:27.628]                     {
[13:35:27.628]                       inherits <- base::inherits
[13:35:27.628]                       invokeRestart <- base::invokeRestart
[13:35:27.628]                       is.null <- base::is.null
[13:35:27.628]                       muffled <- FALSE
[13:35:27.628]                       if (inherits(cond, "message")) {
[13:35:27.628]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:27.628]                         if (muffled) 
[13:35:27.628]                           invokeRestart("muffleMessage")
[13:35:27.628]                       }
[13:35:27.628]                       else if (inherits(cond, "warning")) {
[13:35:27.628]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:27.628]                         if (muffled) 
[13:35:27.628]                           invokeRestart("muffleWarning")
[13:35:27.628]                       }
[13:35:27.628]                       else if (inherits(cond, "condition")) {
[13:35:27.628]                         if (!is.null(pattern)) {
[13:35:27.628]                           computeRestarts <- base::computeRestarts
[13:35:27.628]                           grepl <- base::grepl
[13:35:27.628]                           restarts <- computeRestarts(cond)
[13:35:27.628]                           for (restart in restarts) {
[13:35:27.628]                             name <- restart$name
[13:35:27.628]                             if (is.null(name)) 
[13:35:27.628]                               next
[13:35:27.628]                             if (!grepl(pattern, name)) 
[13:35:27.628]                               next
[13:35:27.628]                             invokeRestart(restart)
[13:35:27.628]                             muffled <- TRUE
[13:35:27.628]                             break
[13:35:27.628]                           }
[13:35:27.628]                         }
[13:35:27.628]                       }
[13:35:27.628]                       invisible(muffled)
[13:35:27.628]                     }
[13:35:27.628]                     muffleCondition(cond, pattern = "^muffle")
[13:35:27.628]                   }
[13:35:27.628]                 }
[13:35:27.628]             }
[13:35:27.628]         }))
[13:35:27.628]     }, error = function(ex) {
[13:35:27.628]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:27.628]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:27.628]                 ...future.rng), started = ...future.startTime, 
[13:35:27.628]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:27.628]             version = "1.8"), class = "FutureResult")
[13:35:27.628]     }, finally = {
[13:35:27.628]         if (!identical(...future.workdir, getwd())) 
[13:35:27.628]             setwd(...future.workdir)
[13:35:27.628]         {
[13:35:27.628]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:27.628]                 ...future.oldOptions$nwarnings <- NULL
[13:35:27.628]             }
[13:35:27.628]             base::options(...future.oldOptions)
[13:35:27.628]             if (.Platform$OS.type == "windows") {
[13:35:27.628]                 old_names <- names(...future.oldEnvVars)
[13:35:27.628]                 envs <- base::Sys.getenv()
[13:35:27.628]                 names <- names(envs)
[13:35:27.628]                 common <- intersect(names, old_names)
[13:35:27.628]                 added <- setdiff(names, old_names)
[13:35:27.628]                 removed <- setdiff(old_names, names)
[13:35:27.628]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:27.628]                   envs[common]]
[13:35:27.628]                 NAMES <- toupper(changed)
[13:35:27.628]                 args <- list()
[13:35:27.628]                 for (kk in seq_along(NAMES)) {
[13:35:27.628]                   name <- changed[[kk]]
[13:35:27.628]                   NAME <- NAMES[[kk]]
[13:35:27.628]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:27.628]                     next
[13:35:27.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:27.628]                 }
[13:35:27.628]                 NAMES <- toupper(added)
[13:35:27.628]                 for (kk in seq_along(NAMES)) {
[13:35:27.628]                   name <- added[[kk]]
[13:35:27.628]                   NAME <- NAMES[[kk]]
[13:35:27.628]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:27.628]                     next
[13:35:27.628]                   args[[name]] <- ""
[13:35:27.628]                 }
[13:35:27.628]                 NAMES <- toupper(removed)
[13:35:27.628]                 for (kk in seq_along(NAMES)) {
[13:35:27.628]                   name <- removed[[kk]]
[13:35:27.628]                   NAME <- NAMES[[kk]]
[13:35:27.628]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:27.628]                     next
[13:35:27.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:27.628]                 }
[13:35:27.628]                 if (length(args) > 0) 
[13:35:27.628]                   base::do.call(base::Sys.setenv, args = args)
[13:35:27.628]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:27.628]             }
[13:35:27.628]             else {
[13:35:27.628]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:27.628]             }
[13:35:27.628]             {
[13:35:27.628]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:27.628]                   0L) {
[13:35:27.628]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:27.628]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:27.628]                   base::options(opts)
[13:35:27.628]                 }
[13:35:27.628]                 {
[13:35:27.628]                   {
[13:35:27.628]                     NULL
[13:35:27.628]                     RNGkind("Mersenne-Twister")
[13:35:27.628]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:27.628]                       inherits = FALSE)
[13:35:27.628]                   }
[13:35:27.628]                   options(future.plan = NULL)
[13:35:27.628]                   if (is.na(NA_character_)) 
[13:35:27.628]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:27.628]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:27.628]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:27.628]                     .init = FALSE)
[13:35:27.628]                 }
[13:35:27.628]             }
[13:35:27.628]         }
[13:35:27.628]     })
[13:35:27.628]     if (FALSE) {
[13:35:27.628]         base::sink(type = "output", split = FALSE)
[13:35:27.628]         if (NA) {
[13:35:27.628]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:27.628]         }
[13:35:27.628]         else {
[13:35:27.628]             ...future.result["stdout"] <- base::list(NULL)
[13:35:27.628]         }
[13:35:27.628]         base::close(...future.stdout)
[13:35:27.628]         ...future.stdout <- NULL
[13:35:27.628]     }
[13:35:27.628]     ...future.result$conditions <- ...future.conditions
[13:35:27.628]     ...future.result$finished <- base::Sys.time()
[13:35:27.628]     ...future.result
[13:35:27.628] }
[13:35:27.629] assign_globals() ...
[13:35:27.629] List of 5
[13:35:27.629]  $ ...future.FUN            :function (x)  
[13:35:27.629]  $ future.call.arguments    : list()
[13:35:27.629]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:27.629]  $ ...future.elements_ii    :List of 2
[13:35:27.629]   ..$ : int 1
[13:35:27.629]   ..$ : int 0
[13:35:27.629]  $ ...future.seeds_ii       : NULL
[13:35:27.629]  $ ...future.globals.maxSize: NULL
[13:35:27.629]  - attr(*, "where")=List of 5
[13:35:27.629]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:27.629]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:27.629]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:27.629]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:27.629]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:27.629]  - attr(*, "resolved")= logi FALSE
[13:35:27.629]  - attr(*, "total_size")= num 4720
[13:35:27.629]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:27.629]  - attr(*, "already-done")= logi TRUE
[13:35:27.634] - reassign environment for ‘...future.FUN’
[13:35:27.634] - copied ‘...future.FUN’ to environment
[13:35:27.634] - copied ‘future.call.arguments’ to environment
[13:35:27.635] - copied ‘...future.elements_ii’ to environment
[13:35:27.635] - copied ‘...future.seeds_ii’ to environment
[13:35:27.635] - copied ‘...future.globals.maxSize’ to environment
[13:35:27.635] assign_globals() ... done
[13:35:27.635] plan(): Setting new future strategy stack:
[13:35:27.635] List of future strategies:
[13:35:27.635] 1. sequential:
[13:35:27.635]    - args: function (..., envir = parent.frame())
[13:35:27.635]    - tweaked: FALSE
[13:35:27.635]    - call: NULL
[13:35:27.635] plan(): nbrOfWorkers() = 1
[13:35:28.137] plan(): Setting new future strategy stack:
[13:35:28.137] List of future strategies:
[13:35:28.137] 1. multisession:
[13:35:28.137]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:35:28.137]    - tweaked: FALSE
[13:35:28.137]    - call: plan(strategy)
[13:35:28.141] plan(): nbrOfWorkers() = 1
[13:35:28.141] SequentialFuture started (and completed)
[13:35:28.142] - Launch lazy future ... done
[13:35:28.142] run() for ‘SequentialFuture’ ... done
[13:35:28.142] Created future:
[13:35:28.142] SequentialFuture:
[13:35:28.142] Label: ‘future_lapply-1’
[13:35:28.142] Expression:
[13:35:28.142] {
[13:35:28.142]     do.call(function(...) {
[13:35:28.142]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:28.142]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:28.142]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:28.142]             on.exit(options(oopts), add = TRUE)
[13:35:28.142]         }
[13:35:28.142]         {
[13:35:28.142]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:28.142]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:28.142]                 ...future.FUN(...future.X_jj, ...)
[13:35:28.142]             })
[13:35:28.142]         }
[13:35:28.142]     }, args = future.call.arguments)
[13:35:28.142] }
[13:35:28.142] Lazy evaluation: FALSE
[13:35:28.142] Asynchronous evaluation: FALSE
[13:35:28.142] Local evaluation: TRUE
[13:35:28.142] Environment: R_GlobalEnv
[13:35:28.142] Capture standard output: NA
[13:35:28.142] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:28.142] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:28.142] Packages: <none>
[13:35:28.142] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:28.142] Resolved: TRUE
[13:35:28.142] Value: 112 bytes of class ‘list’
[13:35:28.142] Early signaling: FALSE
[13:35:28.142] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:28.142] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:28.143] Chunk #1 of 1 ... DONE
[13:35:28.143] Launching 1 futures (chunks) ... DONE
[13:35:28.143] Resolving 1 futures (chunks) ...
[13:35:28.143] resolve() on list ...
[13:35:28.143]  recursive: 0
[13:35:28.143]  length: 1
[13:35:28.144] 
[13:35:28.144] resolved() for ‘SequentialFuture’ ...
[13:35:28.144] - state: ‘finished’
[13:35:28.144] - run: TRUE
[13:35:28.144] - result: ‘FutureResult’
[13:35:28.144] resolved() for ‘SequentialFuture’ ... done
[13:35:28.144] Future #1
[13:35:28.144] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:28.144] - nx: 1
[13:35:28.144] - relay: TRUE
[13:35:28.145] - stdout: TRUE
[13:35:28.145] - signal: TRUE
[13:35:28.145] - resignal: FALSE
[13:35:28.145] - force: TRUE
[13:35:28.145] - relayed: [n=1] FALSE
[13:35:28.145] - queued futures: [n=1] FALSE
[13:35:28.145]  - until=1
[13:35:28.145]  - relaying element #1
[13:35:28.145] - relayed: [n=1] TRUE
[13:35:28.145] - queued futures: [n=1] TRUE
[13:35:28.146] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:28.146]  length: 0 (resolved future 1)
[13:35:28.146] Relaying remaining futures
[13:35:28.146] signalConditionsASAP(NULL, pos=0) ...
[13:35:28.146] - nx: 1
[13:35:28.146] - relay: TRUE
[13:35:28.146] - stdout: TRUE
[13:35:28.146] - signal: TRUE
[13:35:28.146] - resignal: FALSE
[13:35:28.146] - force: TRUE
[13:35:28.146] - relayed: [n=1] TRUE
[13:35:28.146] - queued futures: [n=1] TRUE
 - flush all
[13:35:28.147] - relayed: [n=1] TRUE
[13:35:28.147] - queued futures: [n=1] TRUE
[13:35:28.147] signalConditionsASAP(NULL, pos=0) ... done
[13:35:28.147] resolve() on list ... DONE
[13:35:28.147]  - Number of value chunks collected: 1
[13:35:28.147] Resolving 1 futures (chunks) ... DONE
[13:35:28.147] Reducing values from 1 chunks ...
[13:35:28.147]  - Number of values collected after concatenation: 2
[13:35:28.147]  - Number of values expected: 2
[13:35:28.148] Reducing values from 1 chunks ... DONE
[13:35:28.148] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[13:35:28.148] future_mapply() ...
[13:35:28.151] Number of chunks: 1
[13:35:28.151] getGlobalsAndPackagesXApply() ...
[13:35:28.151]  - future.globals: TRUE
[13:35:28.151] getGlobalsAndPackages() ...
[13:35:28.152] Searching for globals...
[13:35:28.153] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:35:28.153] Searching for globals ... DONE
[13:35:28.153] Resolving globals: FALSE
[13:35:28.154] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:35:28.154] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:35:28.154] - globals: [1] ‘FUN’
[13:35:28.155] 
[13:35:28.155] getGlobalsAndPackages() ... DONE
[13:35:28.155]  - globals found/used: [n=1] ‘FUN’
[13:35:28.155]  - needed namespaces: [n=0] 
[13:35:28.155] Finding globals ... DONE
[13:35:28.155] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:35:28.155] List of 2
[13:35:28.155]  $ ...future.FUN:function (x, y)  
[13:35:28.155]  $ MoreArgs     : NULL
[13:35:28.155]  - attr(*, "where")=List of 2
[13:35:28.155]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:28.155]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:35:28.155]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:28.155]  - attr(*, "resolved")= logi FALSE
[13:35:28.155]  - attr(*, "total_size")= num NA
[13:35:28.158] Packages to be attached in all futures: [n=0] 
[13:35:28.158] getGlobalsAndPackagesXApply() ... DONE
[13:35:28.158] Number of futures (= number of chunks): 1
[13:35:28.160] Launching 1 futures (chunks) ...
[13:35:28.160] Chunk #1 of 1 ...
[13:35:28.160]  - Finding globals in '...' for chunk #1 ...
[13:35:28.160] getGlobalsAndPackages() ...
[13:35:28.160] Searching for globals...
[13:35:28.161] 
[13:35:28.161] Searching for globals ... DONE
[13:35:28.161] - globals: [0] <none>
[13:35:28.161] getGlobalsAndPackages() ... DONE
[13:35:28.161]    + additional globals found: [n=0] 
[13:35:28.161]    + additional namespaces needed: [n=0] 
[13:35:28.161]  - Finding globals in '...' for chunk #1 ... DONE
[13:35:28.161]  - seeds: <none>
[13:35:28.162]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:28.162] getGlobalsAndPackages() ...
[13:35:28.162] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:28.162] Resolving globals: FALSE
[13:35:28.162] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:35:28.163] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:35:28.163] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:28.163] 
[13:35:28.163] getGlobalsAndPackages() ... DONE
[13:35:28.164] run() for ‘Future’ ...
[13:35:28.164] - state: ‘created’
[13:35:28.164] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:28.167] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:28.167] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:28.167]   - Field: ‘label’
[13:35:28.167]   - Field: ‘local’
[13:35:28.167]   - Field: ‘owner’
[13:35:28.168]   - Field: ‘envir’
[13:35:28.168]   - Field: ‘packages’
[13:35:28.168]   - Field: ‘gc’
[13:35:28.168]   - Field: ‘conditions’
[13:35:28.168]   - Field: ‘expr’
[13:35:28.168]   - Field: ‘uuid’
[13:35:28.168]   - Field: ‘seed’
[13:35:28.168]   - Field: ‘version’
[13:35:28.168]   - Field: ‘result’
[13:35:28.168]   - Field: ‘asynchronous’
[13:35:28.168]   - Field: ‘calls’
[13:35:28.169]   - Field: ‘globals’
[13:35:28.169]   - Field: ‘stdout’
[13:35:28.169]   - Field: ‘earlySignal’
[13:35:28.169]   - Field: ‘lazy’
[13:35:28.169]   - Field: ‘state’
[13:35:28.169] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:28.169] - Launch lazy future ...
[13:35:28.169] Packages needed by the future expression (n = 0): <none>
[13:35:28.169] Packages needed by future strategies (n = 0): <none>
[13:35:28.170] {
[13:35:28.170]     {
[13:35:28.170]         {
[13:35:28.170]             ...future.startTime <- base::Sys.time()
[13:35:28.170]             {
[13:35:28.170]                 {
[13:35:28.170]                   {
[13:35:28.170]                     base::local({
[13:35:28.170]                       has_future <- base::requireNamespace("future", 
[13:35:28.170]                         quietly = TRUE)
[13:35:28.170]                       if (has_future) {
[13:35:28.170]                         ns <- base::getNamespace("future")
[13:35:28.170]                         version <- ns[[".package"]][["version"]]
[13:35:28.170]                         if (is.null(version)) 
[13:35:28.170]                           version <- utils::packageVersion("future")
[13:35:28.170]                       }
[13:35:28.170]                       else {
[13:35:28.170]                         version <- NULL
[13:35:28.170]                       }
[13:35:28.170]                       if (!has_future || version < "1.8.0") {
[13:35:28.170]                         info <- base::c(r_version = base::gsub("R version ", 
[13:35:28.170]                           "", base::R.version$version.string), 
[13:35:28.170]                           platform = base::sprintf("%s (%s-bit)", 
[13:35:28.170]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:28.170]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:28.170]                             "release", "version")], collapse = " "), 
[13:35:28.170]                           hostname = base::Sys.info()[["nodename"]])
[13:35:28.170]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:35:28.170]                           info)
[13:35:28.170]                         info <- base::paste(info, collapse = "; ")
[13:35:28.170]                         if (!has_future) {
[13:35:28.170]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:28.170]                             info)
[13:35:28.170]                         }
[13:35:28.170]                         else {
[13:35:28.170]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:28.170]                             info, version)
[13:35:28.170]                         }
[13:35:28.170]                         base::stop(msg)
[13:35:28.170]                       }
[13:35:28.170]                     })
[13:35:28.170]                   }
[13:35:28.170]                   ...future.strategy.old <- future::plan("list")
[13:35:28.170]                   options(future.plan = NULL)
[13:35:28.170]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:28.170]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:28.170]                 }
[13:35:28.170]                 ...future.workdir <- getwd()
[13:35:28.170]             }
[13:35:28.170]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:28.170]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:28.170]         }
[13:35:28.170]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:28.170]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:28.170]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:28.170]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:28.170]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:28.170]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:28.170]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:28.170]             base::names(...future.oldOptions))
[13:35:28.170]     }
[13:35:28.170]     if (FALSE) {
[13:35:28.170]     }
[13:35:28.170]     else {
[13:35:28.170]         if (FALSE) {
[13:35:28.170]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:28.170]                 open = "w")
[13:35:28.170]         }
[13:35:28.170]         else {
[13:35:28.170]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:28.170]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:28.170]         }
[13:35:28.170]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:28.170]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:28.170]             base::sink(type = "output", split = FALSE)
[13:35:28.170]             base::close(...future.stdout)
[13:35:28.170]         }, add = TRUE)
[13:35:28.170]     }
[13:35:28.170]     ...future.frame <- base::sys.nframe()
[13:35:28.170]     ...future.conditions <- base::list()
[13:35:28.170]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:28.170]     if (FALSE) {
[13:35:28.170]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:28.170]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:28.170]     }
[13:35:28.170]     ...future.result <- base::tryCatch({
[13:35:28.170]         base::withCallingHandlers({
[13:35:28.170]             ...future.value <- base::withVisible(base::local({
[13:35:28.170]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:28.170]                 if (!identical(...future.globals.maxSize.org, 
[13:35:28.170]                   ...future.globals.maxSize)) {
[13:35:28.170]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:28.170]                   on.exit(options(oopts), add = TRUE)
[13:35:28.170]                 }
[13:35:28.170]                 {
[13:35:28.170]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:28.170]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:35:28.170]                     USE.NAMES = FALSE)
[13:35:28.170]                   do.call(mapply, args = args)
[13:35:28.170]                 }
[13:35:28.170]             }))
[13:35:28.170]             future::FutureResult(value = ...future.value$value, 
[13:35:28.170]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:28.170]                   ...future.rng), globalenv = if (FALSE) 
[13:35:28.170]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:28.170]                     ...future.globalenv.names))
[13:35:28.170]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:28.170]         }, condition = base::local({
[13:35:28.170]             c <- base::c
[13:35:28.170]             inherits <- base::inherits
[13:35:28.170]             invokeRestart <- base::invokeRestart
[13:35:28.170]             length <- base::length
[13:35:28.170]             list <- base::list
[13:35:28.170]             seq.int <- base::seq.int
[13:35:28.170]             signalCondition <- base::signalCondition
[13:35:28.170]             sys.calls <- base::sys.calls
[13:35:28.170]             `[[` <- base::`[[`
[13:35:28.170]             `+` <- base::`+`
[13:35:28.170]             `<<-` <- base::`<<-`
[13:35:28.170]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:28.170]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:28.170]                   3L)]
[13:35:28.170]             }
[13:35:28.170]             function(cond) {
[13:35:28.170]                 is_error <- inherits(cond, "error")
[13:35:28.170]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:28.170]                   NULL)
[13:35:28.170]                 if (is_error) {
[13:35:28.170]                   sessionInformation <- function() {
[13:35:28.170]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:28.170]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:28.170]                       search = base::search(), system = base::Sys.info())
[13:35:28.170]                   }
[13:35:28.170]                   ...future.conditions[[length(...future.conditions) + 
[13:35:28.170]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:28.170]                     cond$call), session = sessionInformation(), 
[13:35:28.170]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:28.170]                   signalCondition(cond)
[13:35:28.170]                 }
[13:35:28.170]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:28.170]                 "immediateCondition"))) {
[13:35:28.170]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:28.170]                   ...future.conditions[[length(...future.conditions) + 
[13:35:28.170]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:28.170]                   if (TRUE && !signal) {
[13:35:28.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:28.170]                     {
[13:35:28.170]                       inherits <- base::inherits
[13:35:28.170]                       invokeRestart <- base::invokeRestart
[13:35:28.170]                       is.null <- base::is.null
[13:35:28.170]                       muffled <- FALSE
[13:35:28.170]                       if (inherits(cond, "message")) {
[13:35:28.170]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:28.170]                         if (muffled) 
[13:35:28.170]                           invokeRestart("muffleMessage")
[13:35:28.170]                       }
[13:35:28.170]                       else if (inherits(cond, "warning")) {
[13:35:28.170]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:28.170]                         if (muffled) 
[13:35:28.170]                           invokeRestart("muffleWarning")
[13:35:28.170]                       }
[13:35:28.170]                       else if (inherits(cond, "condition")) {
[13:35:28.170]                         if (!is.null(pattern)) {
[13:35:28.170]                           computeRestarts <- base::computeRestarts
[13:35:28.170]                           grepl <- base::grepl
[13:35:28.170]                           restarts <- computeRestarts(cond)
[13:35:28.170]                           for (restart in restarts) {
[13:35:28.170]                             name <- restart$name
[13:35:28.170]                             if (is.null(name)) 
[13:35:28.170]                               next
[13:35:28.170]                             if (!grepl(pattern, name)) 
[13:35:28.170]                               next
[13:35:28.170]                             invokeRestart(restart)
[13:35:28.170]                             muffled <- TRUE
[13:35:28.170]                             break
[13:35:28.170]                           }
[13:35:28.170]                         }
[13:35:28.170]                       }
[13:35:28.170]                       invisible(muffled)
[13:35:28.170]                     }
[13:35:28.170]                     muffleCondition(cond, pattern = "^muffle")
[13:35:28.170]                   }
[13:35:28.170]                 }
[13:35:28.170]                 else {
[13:35:28.170]                   if (TRUE) {
[13:35:28.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:28.170]                     {
[13:35:28.170]                       inherits <- base::inherits
[13:35:28.170]                       invokeRestart <- base::invokeRestart
[13:35:28.170]                       is.null <- base::is.null
[13:35:28.170]                       muffled <- FALSE
[13:35:28.170]                       if (inherits(cond, "message")) {
[13:35:28.170]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:28.170]                         if (muffled) 
[13:35:28.170]                           invokeRestart("muffleMessage")
[13:35:28.170]                       }
[13:35:28.170]                       else if (inherits(cond, "warning")) {
[13:35:28.170]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:28.170]                         if (muffled) 
[13:35:28.170]                           invokeRestart("muffleWarning")
[13:35:28.170]                       }
[13:35:28.170]                       else if (inherits(cond, "condition")) {
[13:35:28.170]                         if (!is.null(pattern)) {
[13:35:28.170]                           computeRestarts <- base::computeRestarts
[13:35:28.170]                           grepl <- base::grepl
[13:35:28.170]                           restarts <- computeRestarts(cond)
[13:35:28.170]                           for (restart in restarts) {
[13:35:28.170]                             name <- restart$name
[13:35:28.170]                             if (is.null(name)) 
[13:35:28.170]                               next
[13:35:28.170]                             if (!grepl(pattern, name)) 
[13:35:28.170]                               next
[13:35:28.170]                             invokeRestart(restart)
[13:35:28.170]                             muffled <- TRUE
[13:35:28.170]                             break
[13:35:28.170]                           }
[13:35:28.170]                         }
[13:35:28.170]                       }
[13:35:28.170]                       invisible(muffled)
[13:35:28.170]                     }
[13:35:28.170]                     muffleCondition(cond, pattern = "^muffle")
[13:35:28.170]                   }
[13:35:28.170]                 }
[13:35:28.170]             }
[13:35:28.170]         }))
[13:35:28.170]     }, error = function(ex) {
[13:35:28.170]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:28.170]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:28.170]                 ...future.rng), started = ...future.startTime, 
[13:35:28.170]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:28.170]             version = "1.8"), class = "FutureResult")
[13:35:28.170]     }, finally = {
[13:35:28.170]         if (!identical(...future.workdir, getwd())) 
[13:35:28.170]             setwd(...future.workdir)
[13:35:28.170]         {
[13:35:28.170]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:28.170]                 ...future.oldOptions$nwarnings <- NULL
[13:35:28.170]             }
[13:35:28.170]             base::options(...future.oldOptions)
[13:35:28.170]             if (.Platform$OS.type == "windows") {
[13:35:28.170]                 old_names <- names(...future.oldEnvVars)
[13:35:28.170]                 envs <- base::Sys.getenv()
[13:35:28.170]                 names <- names(envs)
[13:35:28.170]                 common <- intersect(names, old_names)
[13:35:28.170]                 added <- setdiff(names, old_names)
[13:35:28.170]                 removed <- setdiff(old_names, names)
[13:35:28.170]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:28.170]                   envs[common]]
[13:35:28.170]                 NAMES <- toupper(changed)
[13:35:28.170]                 args <- list()
[13:35:28.170]                 for (kk in seq_along(NAMES)) {
[13:35:28.170]                   name <- changed[[kk]]
[13:35:28.170]                   NAME <- NAMES[[kk]]
[13:35:28.170]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:28.170]                     next
[13:35:28.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:28.170]                 }
[13:35:28.170]                 NAMES <- toupper(added)
[13:35:28.170]                 for (kk in seq_along(NAMES)) {
[13:35:28.170]                   name <- added[[kk]]
[13:35:28.170]                   NAME <- NAMES[[kk]]
[13:35:28.170]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:28.170]                     next
[13:35:28.170]                   args[[name]] <- ""
[13:35:28.170]                 }
[13:35:28.170]                 NAMES <- toupper(removed)
[13:35:28.170]                 for (kk in seq_along(NAMES)) {
[13:35:28.170]                   name <- removed[[kk]]
[13:35:28.170]                   NAME <- NAMES[[kk]]
[13:35:28.170]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:28.170]                     next
[13:35:28.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:28.170]                 }
[13:35:28.170]                 if (length(args) > 0) 
[13:35:28.170]                   base::do.call(base::Sys.setenv, args = args)
[13:35:28.170]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:28.170]             }
[13:35:28.170]             else {
[13:35:28.170]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:28.170]             }
[13:35:28.170]             {
[13:35:28.170]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:28.170]                   0L) {
[13:35:28.170]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:28.170]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:28.170]                   base::options(opts)
[13:35:28.170]                 }
[13:35:28.170]                 {
[13:35:28.170]                   {
[13:35:28.170]                     NULL
[13:35:28.170]                     RNGkind("Mersenne-Twister")
[13:35:28.170]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:28.170]                       inherits = FALSE)
[13:35:28.170]                   }
[13:35:28.170]                   options(future.plan = NULL)
[13:35:28.170]                   if (is.na(NA_character_)) 
[13:35:28.170]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:28.170]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:28.170]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:28.170]                     .init = FALSE)
[13:35:28.170]                 }
[13:35:28.170]             }
[13:35:28.170]         }
[13:35:28.170]     })
[13:35:28.170]     if (TRUE) {
[13:35:28.170]         base::sink(type = "output", split = FALSE)
[13:35:28.170]         if (FALSE) {
[13:35:28.170]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:28.170]         }
[13:35:28.170]         else {
[13:35:28.170]             ...future.result["stdout"] <- base::list(NULL)
[13:35:28.170]         }
[13:35:28.170]         base::close(...future.stdout)
[13:35:28.170]         ...future.stdout <- NULL
[13:35:28.170]     }
[13:35:28.170]     ...future.result$conditions <- ...future.conditions
[13:35:28.170]     ...future.result$finished <- base::Sys.time()
[13:35:28.170]     ...future.result
[13:35:28.170] }
[13:35:28.171] assign_globals() ...
[13:35:28.172] List of 5
[13:35:28.172]  $ ...future.FUN            :function (x, y)  
[13:35:28.172]  $ MoreArgs                 : NULL
[13:35:28.172]  $ ...future.elements_ii    :List of 2
[13:35:28.172]   ..$ :List of 2
[13:35:28.172]   .. ..$ : int 1
[13:35:28.172]   .. ..$ : int 0
[13:35:28.172]   ..$ :List of 2
[13:35:28.172]   .. ..$ : int 0
[13:35:28.172]   .. ..$ : int 1
[13:35:28.172]  $ ...future.seeds_ii       : NULL
[13:35:28.172]  $ ...future.globals.maxSize: NULL
[13:35:28.172]  - attr(*, "where")=List of 5
[13:35:28.172]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:28.172]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:35:28.172]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:28.172]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:28.172]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:28.172]  - attr(*, "resolved")= logi FALSE
[13:35:28.172]  - attr(*, "total_size")= num 6480
[13:35:28.172]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:28.172]  - attr(*, "already-done")= logi TRUE
[13:35:28.177] - reassign environment for ‘...future.FUN’
[13:35:28.177] - copied ‘...future.FUN’ to environment
[13:35:28.177] - copied ‘MoreArgs’ to environment
[13:35:28.177] - copied ‘...future.elements_ii’ to environment
[13:35:28.177] - copied ‘...future.seeds_ii’ to environment
[13:35:28.177] - copied ‘...future.globals.maxSize’ to environment
[13:35:28.178] assign_globals() ... done
[13:35:28.178] plan(): Setting new future strategy stack:
[13:35:28.178] List of future strategies:
[13:35:28.178] 1. sequential:
[13:35:28.178]    - args: function (..., envir = parent.frame())
[13:35:28.178]    - tweaked: FALSE
[13:35:28.178]    - call: NULL
[13:35:28.178] plan(): nbrOfWorkers() = 1
[13:35:28.680] plan(): Setting new future strategy stack:
[13:35:28.680] List of future strategies:
[13:35:28.680] 1. multisession:
[13:35:28.680]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:35:28.680]    - tweaked: FALSE
[13:35:28.680]    - call: plan(strategy)
[13:35:28.684] plan(): nbrOfWorkers() = 1
[13:35:28.684] SequentialFuture started (and completed)
[13:35:28.684] - Launch lazy future ... done
[13:35:28.684] run() for ‘SequentialFuture’ ... done
[13:35:28.685] Created future:
[13:35:28.685] SequentialFuture:
[13:35:28.685] Label: ‘future_mapply-1’
[13:35:28.685] Expression:
[13:35:28.685] {
[13:35:28.685]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:28.685]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:28.685]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:28.685]         on.exit(options(oopts), add = TRUE)
[13:35:28.685]     }
[13:35:28.685]     {
[13:35:28.685]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:28.685]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:35:28.685]         do.call(mapply, args = args)
[13:35:28.685]     }
[13:35:28.685] }
[13:35:28.685] Lazy evaluation: FALSE
[13:35:28.685] Asynchronous evaluation: FALSE
[13:35:28.685] Local evaluation: TRUE
[13:35:28.685] Environment: R_GlobalEnv
[13:35:28.685] Capture standard output: FALSE
[13:35:28.685] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:28.685] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:28.685] Packages: <none>
[13:35:28.685] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:28.685] Resolved: TRUE
[13:35:28.685] Value: 224 bytes of class ‘list’
[13:35:28.685] Early signaling: FALSE
[13:35:28.685] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:28.685] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:28.686] Chunk #1 of 1 ... DONE
[13:35:28.686] Launching 1 futures (chunks) ... DONE
[13:35:28.686] Resolving 1 futures (chunks) ...
[13:35:28.686] resolve() on list ...
[13:35:28.686]  recursive: 0
[13:35:28.686]  length: 1
[13:35:28.686] 
[13:35:28.686] resolved() for ‘SequentialFuture’ ...
[13:35:28.686] - state: ‘finished’
[13:35:28.687] - run: TRUE
[13:35:28.687] - result: ‘FutureResult’
[13:35:28.687] resolved() for ‘SequentialFuture’ ... done
[13:35:28.687] Future #1
[13:35:28.687] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:28.687] - nx: 1
[13:35:28.687] - relay: TRUE
[13:35:28.687] - stdout: TRUE
[13:35:28.687] - signal: TRUE
[13:35:28.687] - resignal: FALSE
[13:35:28.687] - force: TRUE
[13:35:28.688] - relayed: [n=1] FALSE
[13:35:28.688] - queued futures: [n=1] FALSE
[13:35:28.688]  - until=1
[13:35:28.688]  - relaying element #1
[13:35:28.688] - relayed: [n=1] TRUE
[13:35:28.688] - queued futures: [n=1] TRUE
[13:35:28.688] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:28.688]  length: 0 (resolved future 1)
[13:35:28.688] Relaying remaining futures
[13:35:28.688] signalConditionsASAP(NULL, pos=0) ...
[13:35:28.689] - nx: 1
[13:35:28.689] - relay: TRUE
[13:35:28.689] - stdout: TRUE
[13:35:28.689] - signal: TRUE
[13:35:28.689] - resignal: FALSE
[13:35:28.689] - force: TRUE
[13:35:28.689] - relayed: [n=1] TRUE
[13:35:28.689] - queued futures: [n=1] TRUE
 - flush all
[13:35:28.689] - relayed: [n=1] TRUE
[13:35:28.689] - queued futures: [n=1] TRUE
[13:35:28.689] signalConditionsASAP(NULL, pos=0) ... done
[13:35:28.690] resolve() on list ... DONE
[13:35:28.690]  - Number of value chunks collected: 1
[13:35:28.690] Resolving 1 futures (chunks) ... DONE
[13:35:28.690] Reducing values from 1 chunks ...
[13:35:28.690]  - Number of values collected after concatenation: 2
[13:35:28.690]  - Number of values expected: 2
[13:35:28.690] Reducing values from 1 chunks ... DONE
[13:35:28.690] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[13:35:28.692] future_mapply() ...
[13:35:28.696] Number of chunks: 1
[13:35:28.696] getGlobalsAndPackagesXApply() ...
[13:35:28.696]  - future.globals: TRUE
[13:35:28.696] getGlobalsAndPackages() ...
[13:35:28.696] Searching for globals...
[13:35:28.698] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:35:28.698] Searching for globals ... DONE
[13:35:28.698] Resolving globals: FALSE
[13:35:28.698] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:35:28.699] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:35:28.699] - globals: [1] ‘FUN’
[13:35:28.699] 
[13:35:28.699] getGlobalsAndPackages() ... DONE
[13:35:28.699]  - globals found/used: [n=1] ‘FUN’
[13:35:28.699]  - needed namespaces: [n=0] 
[13:35:28.699] Finding globals ... DONE
[13:35:28.699] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:35:28.700] List of 2
[13:35:28.700]  $ ...future.FUN:function (x, y)  
[13:35:28.700]  $ MoreArgs     : NULL
[13:35:28.700]  - attr(*, "where")=List of 2
[13:35:28.700]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:28.700]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:35:28.700]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:28.700]  - attr(*, "resolved")= logi FALSE
[13:35:28.700]  - attr(*, "total_size")= num NA
[13:35:28.702] Packages to be attached in all futures: [n=0] 
[13:35:28.702] getGlobalsAndPackagesXApply() ... DONE
[13:35:28.702] Number of futures (= number of chunks): 1
[13:35:28.702] Launching 1 futures (chunks) ...
[13:35:28.703] Chunk #1 of 1 ...
[13:35:28.703]  - Finding globals in '...' for chunk #1 ...
[13:35:28.703] getGlobalsAndPackages() ...
[13:35:28.703] Searching for globals...
[13:35:28.703] 
[13:35:28.703] Searching for globals ... DONE
[13:35:28.703] - globals: [0] <none>
[13:35:28.704] getGlobalsAndPackages() ... DONE
[13:35:28.704]    + additional globals found: [n=0] 
[13:35:28.704]    + additional namespaces needed: [n=0] 
[13:35:28.704]  - Finding globals in '...' for chunk #1 ... DONE
[13:35:28.704]  - seeds: <none>
[13:35:28.704]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:28.704] getGlobalsAndPackages() ...
[13:35:28.704] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:28.704] Resolving globals: FALSE
[13:35:28.705] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:35:28.705] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:35:28.705] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:28.705] 
[13:35:28.706] getGlobalsAndPackages() ... DONE
[13:35:28.706] run() for ‘Future’ ...
[13:35:28.706] - state: ‘created’
[13:35:28.706] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:28.709] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:28.709] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:28.710]   - Field: ‘label’
[13:35:28.710]   - Field: ‘local’
[13:35:28.710]   - Field: ‘owner’
[13:35:28.710]   - Field: ‘envir’
[13:35:28.710]   - Field: ‘packages’
[13:35:28.710]   - Field: ‘gc’
[13:35:28.710]   - Field: ‘conditions’
[13:35:28.710]   - Field: ‘expr’
[13:35:28.710]   - Field: ‘uuid’
[13:35:28.710]   - Field: ‘seed’
[13:35:28.711]   - Field: ‘version’
[13:35:28.711]   - Field: ‘result’
[13:35:28.711]   - Field: ‘asynchronous’
[13:35:28.711]   - Field: ‘calls’
[13:35:28.711]   - Field: ‘globals’
[13:35:28.711]   - Field: ‘stdout’
[13:35:28.711]   - Field: ‘earlySignal’
[13:35:28.711]   - Field: ‘lazy’
[13:35:28.711]   - Field: ‘state’
[13:35:28.711] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:28.711] - Launch lazy future ...
[13:35:28.712] Packages needed by the future expression (n = 0): <none>
[13:35:28.712] Packages needed by future strategies (n = 0): <none>
[13:35:28.712] {
[13:35:28.712]     {
[13:35:28.712]         {
[13:35:28.712]             ...future.startTime <- base::Sys.time()
[13:35:28.712]             {
[13:35:28.712]                 {
[13:35:28.712]                   {
[13:35:28.712]                     base::local({
[13:35:28.712]                       has_future <- base::requireNamespace("future", 
[13:35:28.712]                         quietly = TRUE)
[13:35:28.712]                       if (has_future) {
[13:35:28.712]                         ns <- base::getNamespace("future")
[13:35:28.712]                         version <- ns[[".package"]][["version"]]
[13:35:28.712]                         if (is.null(version)) 
[13:35:28.712]                           version <- utils::packageVersion("future")
[13:35:28.712]                       }
[13:35:28.712]                       else {
[13:35:28.712]                         version <- NULL
[13:35:28.712]                       }
[13:35:28.712]                       if (!has_future || version < "1.8.0") {
[13:35:28.712]                         info <- base::c(r_version = base::gsub("R version ", 
[13:35:28.712]                           "", base::R.version$version.string), 
[13:35:28.712]                           platform = base::sprintf("%s (%s-bit)", 
[13:35:28.712]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:28.712]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:28.712]                             "release", "version")], collapse = " "), 
[13:35:28.712]                           hostname = base::Sys.info()[["nodename"]])
[13:35:28.712]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:35:28.712]                           info)
[13:35:28.712]                         info <- base::paste(info, collapse = "; ")
[13:35:28.712]                         if (!has_future) {
[13:35:28.712]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:28.712]                             info)
[13:35:28.712]                         }
[13:35:28.712]                         else {
[13:35:28.712]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:28.712]                             info, version)
[13:35:28.712]                         }
[13:35:28.712]                         base::stop(msg)
[13:35:28.712]                       }
[13:35:28.712]                     })
[13:35:28.712]                   }
[13:35:28.712]                   ...future.strategy.old <- future::plan("list")
[13:35:28.712]                   options(future.plan = NULL)
[13:35:28.712]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:28.712]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:28.712]                 }
[13:35:28.712]                 ...future.workdir <- getwd()
[13:35:28.712]             }
[13:35:28.712]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:28.712]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:28.712]         }
[13:35:28.712]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:28.712]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:28.712]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:28.712]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:28.712]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:28.712]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:28.712]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:28.712]             base::names(...future.oldOptions))
[13:35:28.712]     }
[13:35:28.712]     if (FALSE) {
[13:35:28.712]     }
[13:35:28.712]     else {
[13:35:28.712]         if (TRUE) {
[13:35:28.712]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:28.712]                 open = "w")
[13:35:28.712]         }
[13:35:28.712]         else {
[13:35:28.712]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:28.712]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:28.712]         }
[13:35:28.712]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:28.712]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:28.712]             base::sink(type = "output", split = FALSE)
[13:35:28.712]             base::close(...future.stdout)
[13:35:28.712]         }, add = TRUE)
[13:35:28.712]     }
[13:35:28.712]     ...future.frame <- base::sys.nframe()
[13:35:28.712]     ...future.conditions <- base::list()
[13:35:28.712]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:28.712]     if (FALSE) {
[13:35:28.712]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:28.712]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:28.712]     }
[13:35:28.712]     ...future.result <- base::tryCatch({
[13:35:28.712]         base::withCallingHandlers({
[13:35:28.712]             ...future.value <- base::withVisible(base::local({
[13:35:28.712]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:28.712]                 if (!identical(...future.globals.maxSize.org, 
[13:35:28.712]                   ...future.globals.maxSize)) {
[13:35:28.712]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:28.712]                   on.exit(options(oopts), add = TRUE)
[13:35:28.712]                 }
[13:35:28.712]                 {
[13:35:28.712]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:28.712]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:35:28.712]                     USE.NAMES = FALSE)
[13:35:28.712]                   do.call(mapply, args = args)
[13:35:28.712]                 }
[13:35:28.712]             }))
[13:35:28.712]             future::FutureResult(value = ...future.value$value, 
[13:35:28.712]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:28.712]                   ...future.rng), globalenv = if (FALSE) 
[13:35:28.712]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:28.712]                     ...future.globalenv.names))
[13:35:28.712]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:28.712]         }, condition = base::local({
[13:35:28.712]             c <- base::c
[13:35:28.712]             inherits <- base::inherits
[13:35:28.712]             invokeRestart <- base::invokeRestart
[13:35:28.712]             length <- base::length
[13:35:28.712]             list <- base::list
[13:35:28.712]             seq.int <- base::seq.int
[13:35:28.712]             signalCondition <- base::signalCondition
[13:35:28.712]             sys.calls <- base::sys.calls
[13:35:28.712]             `[[` <- base::`[[`
[13:35:28.712]             `+` <- base::`+`
[13:35:28.712]             `<<-` <- base::`<<-`
[13:35:28.712]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:28.712]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:28.712]                   3L)]
[13:35:28.712]             }
[13:35:28.712]             function(cond) {
[13:35:28.712]                 is_error <- inherits(cond, "error")
[13:35:28.712]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:28.712]                   NULL)
[13:35:28.712]                 if (is_error) {
[13:35:28.712]                   sessionInformation <- function() {
[13:35:28.712]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:28.712]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:28.712]                       search = base::search(), system = base::Sys.info())
[13:35:28.712]                   }
[13:35:28.712]                   ...future.conditions[[length(...future.conditions) + 
[13:35:28.712]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:28.712]                     cond$call), session = sessionInformation(), 
[13:35:28.712]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:28.712]                   signalCondition(cond)
[13:35:28.712]                 }
[13:35:28.712]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:28.712]                 "immediateCondition"))) {
[13:35:28.712]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:28.712]                   ...future.conditions[[length(...future.conditions) + 
[13:35:28.712]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:28.712]                   if (TRUE && !signal) {
[13:35:28.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:28.712]                     {
[13:35:28.712]                       inherits <- base::inherits
[13:35:28.712]                       invokeRestart <- base::invokeRestart
[13:35:28.712]                       is.null <- base::is.null
[13:35:28.712]                       muffled <- FALSE
[13:35:28.712]                       if (inherits(cond, "message")) {
[13:35:28.712]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:28.712]                         if (muffled) 
[13:35:28.712]                           invokeRestart("muffleMessage")
[13:35:28.712]                       }
[13:35:28.712]                       else if (inherits(cond, "warning")) {
[13:35:28.712]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:28.712]                         if (muffled) 
[13:35:28.712]                           invokeRestart("muffleWarning")
[13:35:28.712]                       }
[13:35:28.712]                       else if (inherits(cond, "condition")) {
[13:35:28.712]                         if (!is.null(pattern)) {
[13:35:28.712]                           computeRestarts <- base::computeRestarts
[13:35:28.712]                           grepl <- base::grepl
[13:35:28.712]                           restarts <- computeRestarts(cond)
[13:35:28.712]                           for (restart in restarts) {
[13:35:28.712]                             name <- restart$name
[13:35:28.712]                             if (is.null(name)) 
[13:35:28.712]                               next
[13:35:28.712]                             if (!grepl(pattern, name)) 
[13:35:28.712]                               next
[13:35:28.712]                             invokeRestart(restart)
[13:35:28.712]                             muffled <- TRUE
[13:35:28.712]                             break
[13:35:28.712]                           }
[13:35:28.712]                         }
[13:35:28.712]                       }
[13:35:28.712]                       invisible(muffled)
[13:35:28.712]                     }
[13:35:28.712]                     muffleCondition(cond, pattern = "^muffle")
[13:35:28.712]                   }
[13:35:28.712]                 }
[13:35:28.712]                 else {
[13:35:28.712]                   if (TRUE) {
[13:35:28.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:28.712]                     {
[13:35:28.712]                       inherits <- base::inherits
[13:35:28.712]                       invokeRestart <- base::invokeRestart
[13:35:28.712]                       is.null <- base::is.null
[13:35:28.712]                       muffled <- FALSE
[13:35:28.712]                       if (inherits(cond, "message")) {
[13:35:28.712]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:28.712]                         if (muffled) 
[13:35:28.712]                           invokeRestart("muffleMessage")
[13:35:28.712]                       }
[13:35:28.712]                       else if (inherits(cond, "warning")) {
[13:35:28.712]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:28.712]                         if (muffled) 
[13:35:28.712]                           invokeRestart("muffleWarning")
[13:35:28.712]                       }
[13:35:28.712]                       else if (inherits(cond, "condition")) {
[13:35:28.712]                         if (!is.null(pattern)) {
[13:35:28.712]                           computeRestarts <- base::computeRestarts
[13:35:28.712]                           grepl <- base::grepl
[13:35:28.712]                           restarts <- computeRestarts(cond)
[13:35:28.712]                           for (restart in restarts) {
[13:35:28.712]                             name <- restart$name
[13:35:28.712]                             if (is.null(name)) 
[13:35:28.712]                               next
[13:35:28.712]                             if (!grepl(pattern, name)) 
[13:35:28.712]                               next
[13:35:28.712]                             invokeRestart(restart)
[13:35:28.712]                             muffled <- TRUE
[13:35:28.712]                             break
[13:35:28.712]                           }
[13:35:28.712]                         }
[13:35:28.712]                       }
[13:35:28.712]                       invisible(muffled)
[13:35:28.712]                     }
[13:35:28.712]                     muffleCondition(cond, pattern = "^muffle")
[13:35:28.712]                   }
[13:35:28.712]                 }
[13:35:28.712]             }
[13:35:28.712]         }))
[13:35:28.712]     }, error = function(ex) {
[13:35:28.712]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:28.712]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:28.712]                 ...future.rng), started = ...future.startTime, 
[13:35:28.712]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:28.712]             version = "1.8"), class = "FutureResult")
[13:35:28.712]     }, finally = {
[13:35:28.712]         if (!identical(...future.workdir, getwd())) 
[13:35:28.712]             setwd(...future.workdir)
[13:35:28.712]         {
[13:35:28.712]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:28.712]                 ...future.oldOptions$nwarnings <- NULL
[13:35:28.712]             }
[13:35:28.712]             base::options(...future.oldOptions)
[13:35:28.712]             if (.Platform$OS.type == "windows") {
[13:35:28.712]                 old_names <- names(...future.oldEnvVars)
[13:35:28.712]                 envs <- base::Sys.getenv()
[13:35:28.712]                 names <- names(envs)
[13:35:28.712]                 common <- intersect(names, old_names)
[13:35:28.712]                 added <- setdiff(names, old_names)
[13:35:28.712]                 removed <- setdiff(old_names, names)
[13:35:28.712]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:28.712]                   envs[common]]
[13:35:28.712]                 NAMES <- toupper(changed)
[13:35:28.712]                 args <- list()
[13:35:28.712]                 for (kk in seq_along(NAMES)) {
[13:35:28.712]                   name <- changed[[kk]]
[13:35:28.712]                   NAME <- NAMES[[kk]]
[13:35:28.712]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:28.712]                     next
[13:35:28.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:28.712]                 }
[13:35:28.712]                 NAMES <- toupper(added)
[13:35:28.712]                 for (kk in seq_along(NAMES)) {
[13:35:28.712]                   name <- added[[kk]]
[13:35:28.712]                   NAME <- NAMES[[kk]]
[13:35:28.712]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:28.712]                     next
[13:35:28.712]                   args[[name]] <- ""
[13:35:28.712]                 }
[13:35:28.712]                 NAMES <- toupper(removed)
[13:35:28.712]                 for (kk in seq_along(NAMES)) {
[13:35:28.712]                   name <- removed[[kk]]
[13:35:28.712]                   NAME <- NAMES[[kk]]
[13:35:28.712]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:28.712]                     next
[13:35:28.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:28.712]                 }
[13:35:28.712]                 if (length(args) > 0) 
[13:35:28.712]                   base::do.call(base::Sys.setenv, args = args)
[13:35:28.712]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:28.712]             }
[13:35:28.712]             else {
[13:35:28.712]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:28.712]             }
[13:35:28.712]             {
[13:35:28.712]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:28.712]                   0L) {
[13:35:28.712]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:28.712]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:28.712]                   base::options(opts)
[13:35:28.712]                 }
[13:35:28.712]                 {
[13:35:28.712]                   {
[13:35:28.712]                     NULL
[13:35:28.712]                     RNGkind("Mersenne-Twister")
[13:35:28.712]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:28.712]                       inherits = FALSE)
[13:35:28.712]                   }
[13:35:28.712]                   options(future.plan = NULL)
[13:35:28.712]                   if (is.na(NA_character_)) 
[13:35:28.712]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:28.712]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:28.712]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:28.712]                     .init = FALSE)
[13:35:28.712]                 }
[13:35:28.712]             }
[13:35:28.712]         }
[13:35:28.712]     })
[13:35:28.712]     if (TRUE) {
[13:35:28.712]         base::sink(type = "output", split = FALSE)
[13:35:28.712]         if (TRUE) {
[13:35:28.712]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:28.712]         }
[13:35:28.712]         else {
[13:35:28.712]             ...future.result["stdout"] <- base::list(NULL)
[13:35:28.712]         }
[13:35:28.712]         base::close(...future.stdout)
[13:35:28.712]         ...future.stdout <- NULL
[13:35:28.712]     }
[13:35:28.712]     ...future.result$conditions <- ...future.conditions
[13:35:28.712]     ...future.result$finished <- base::Sys.time()
[13:35:28.712]     ...future.result
[13:35:28.712] }
[13:35:28.714] assign_globals() ...
[13:35:28.714] List of 5
[13:35:28.714]  $ ...future.FUN            :function (x, y)  
[13:35:28.714]  $ MoreArgs                 : NULL
[13:35:28.714]  $ ...future.elements_ii    :List of 2
[13:35:28.714]   ..$ :List of 2
[13:35:28.714]   .. ..$ : int 1
[13:35:28.714]   .. ..$ : int 0
[13:35:28.714]   ..$ :List of 2
[13:35:28.714]   .. ..$ : int 0
[13:35:28.714]   .. ..$ : int 1
[13:35:28.714]  $ ...future.seeds_ii       : NULL
[13:35:28.714]  $ ...future.globals.maxSize: NULL
[13:35:28.714]  - attr(*, "where")=List of 5
[13:35:28.714]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:28.714]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:35:28.714]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:28.714]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:28.714]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:28.714]  - attr(*, "resolved")= logi FALSE
[13:35:28.714]  - attr(*, "total_size")= num 6480
[13:35:28.714]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:28.714]  - attr(*, "already-done")= logi TRUE
[13:35:28.719] - reassign environment for ‘...future.FUN’
[13:35:28.719] - copied ‘...future.FUN’ to environment
[13:35:28.720] - copied ‘MoreArgs’ to environment
[13:35:28.720] - copied ‘...future.elements_ii’ to environment
[13:35:28.720] - copied ‘...future.seeds_ii’ to environment
[13:35:28.720] - copied ‘...future.globals.maxSize’ to environment
[13:35:28.720] assign_globals() ... done
[13:35:28.720] plan(): Setting new future strategy stack:
[13:35:28.720] List of future strategies:
[13:35:28.720] 1. sequential:
[13:35:28.720]    - args: function (..., envir = parent.frame())
[13:35:28.720]    - tweaked: FALSE
[13:35:28.720]    - call: NULL
[13:35:28.721] plan(): nbrOfWorkers() = 1
[13:35:29.223] plan(): Setting new future strategy stack:
[13:35:29.223] List of future strategies:
[13:35:29.223] 1. multisession:
[13:35:29.223]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:35:29.223]    - tweaked: FALSE
[13:35:29.223]    - call: plan(strategy)
[13:35:29.227] plan(): nbrOfWorkers() = 1
[13:35:29.227] SequentialFuture started (and completed)
[13:35:29.227] - Launch lazy future ... done
[13:35:29.227] run() for ‘SequentialFuture’ ... done
[13:35:29.228] Created future:
[13:35:29.228] SequentialFuture:
[13:35:29.228] Label: ‘future_mapply-1’
[13:35:29.228] Expression:
[13:35:29.228] {
[13:35:29.228]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:29.228]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:29.228]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:29.228]         on.exit(options(oopts), add = TRUE)
[13:35:29.228]     }
[13:35:29.228]     {
[13:35:29.228]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:29.228]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:35:29.228]         do.call(mapply, args = args)
[13:35:29.228]     }
[13:35:29.228] }
[13:35:29.228] Lazy evaluation: FALSE
[13:35:29.228] Asynchronous evaluation: FALSE
[13:35:29.228] Local evaluation: TRUE
[13:35:29.228] Environment: R_GlobalEnv
[13:35:29.228] Capture standard output: TRUE
[13:35:29.228] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:29.228] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:29.228] Packages: <none>
[13:35:29.228] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:29.228] Resolved: TRUE
[13:35:29.228] Value: 224 bytes of class ‘list’
[13:35:29.228] Early signaling: FALSE
[13:35:29.228] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:29.228] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:29.229] Chunk #1 of 1 ... DONE
[13:35:29.229] Launching 1 futures (chunks) ... DONE
[13:35:29.229] Resolving 1 futures (chunks) ...
[13:35:29.229] resolve() on list ...
[13:35:29.229]  recursive: 0
[13:35:29.229]  length: 1
[13:35:29.229] 
[13:35:29.229] resolved() for ‘SequentialFuture’ ...
[13:35:29.229] - state: ‘finished’
[13:35:29.229] - run: TRUE
[13:35:29.230] - result: ‘FutureResult’
[13:35:29.230] resolved() for ‘SequentialFuture’ ... done
[13:35:29.230] Future #1
[13:35:29.230] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:29.230] - nx: 1
[13:35:29.230] - relay: TRUE
[13:35:29.230] - stdout: TRUE
[13:35:29.230] - signal: TRUE
[13:35:29.230] - resignal: FALSE
[13:35:29.230] - force: TRUE
[13:35:29.231] - relayed: [n=1] FALSE
[13:35:29.231] - queued futures: [n=1] FALSE
[13:35:29.231]  - until=1
[13:35:29.231]  - relaying element #1
[13:35:29.231] - relayed: [n=1] TRUE
[13:35:29.231] - queued futures: [n=1] TRUE
[13:35:29.231] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:29.231]  length: 0 (resolved future 1)
[13:35:29.231] Relaying remaining futures
[13:35:29.232] signalConditionsASAP(NULL, pos=0) ...
[13:35:29.232] - nx: 1
[13:35:29.232] - relay: TRUE
[13:35:29.232] - stdout: TRUE
[13:35:29.232] - signal: TRUE
[13:35:29.232] - resignal: FALSE
[13:35:29.232] - force: TRUE
[13:35:29.232] - relayed: [n=1] TRUE
[13:35:29.232] - queued futures: [n=1] TRUE
 - flush all
[13:35:29.232] - relayed: [n=1] TRUE
[13:35:29.232] - queued futures: [n=1] TRUE
[13:35:29.232] signalConditionsASAP(NULL, pos=0) ... done
[13:35:29.233] resolve() on list ... DONE
[13:35:29.233]  - Number of value chunks collected: 1
[13:35:29.233] Resolving 1 futures (chunks) ... DONE
[13:35:29.233] Reducing values from 1 chunks ...
[13:35:29.233]  - Number of values collected after concatenation: 2
[13:35:29.233]  - Number of values expected: 2
[13:35:29.233] Reducing values from 1 chunks ... DONE
[13:35:29.233] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[13:35:29.234] future_mapply() ...
[13:35:29.237] Number of chunks: 1
[13:35:29.237] getGlobalsAndPackagesXApply() ...
[13:35:29.237]  - future.globals: TRUE
[13:35:29.237] getGlobalsAndPackages() ...
[13:35:29.237] Searching for globals...
[13:35:29.239] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:35:29.239] Searching for globals ... DONE
[13:35:29.239] Resolving globals: FALSE
[13:35:29.239] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:35:29.240] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:35:29.240] - globals: [1] ‘FUN’
[13:35:29.240] 
[13:35:29.240] getGlobalsAndPackages() ... DONE
[13:35:29.240]  - globals found/used: [n=1] ‘FUN’
[13:35:29.240]  - needed namespaces: [n=0] 
[13:35:29.240] Finding globals ... DONE
[13:35:29.240] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:35:29.241] List of 2
[13:35:29.241]  $ ...future.FUN:function (x, y)  
[13:35:29.241]  $ MoreArgs     : NULL
[13:35:29.241]  - attr(*, "where")=List of 2
[13:35:29.241]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:29.241]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:35:29.241]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:29.241]  - attr(*, "resolved")= logi FALSE
[13:35:29.241]  - attr(*, "total_size")= num NA
[13:35:29.243] Packages to be attached in all futures: [n=0] 
[13:35:29.243] getGlobalsAndPackagesXApply() ... DONE
[13:35:29.243] Number of futures (= number of chunks): 1
[13:35:29.243] Launching 1 futures (chunks) ...
[13:35:29.243] Chunk #1 of 1 ...
[13:35:29.244]  - Finding globals in '...' for chunk #1 ...
[13:35:29.244] getGlobalsAndPackages() ...
[13:35:29.244] Searching for globals...
[13:35:29.244] 
[13:35:29.244] Searching for globals ... DONE
[13:35:29.244] - globals: [0] <none>
[13:35:29.244] getGlobalsAndPackages() ... DONE
[13:35:29.244]    + additional globals found: [n=0] 
[13:35:29.245]    + additional namespaces needed: [n=0] 
[13:35:29.245]  - Finding globals in '...' for chunk #1 ... DONE
[13:35:29.245]  - seeds: <none>
[13:35:29.245]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:29.245] getGlobalsAndPackages() ...
[13:35:29.245] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:29.245] Resolving globals: FALSE
[13:35:29.246] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[13:35:29.246] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:35:29.246] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:29.246] 
[13:35:29.246] getGlobalsAndPackages() ... DONE
[13:35:29.247] run() for ‘Future’ ...
[13:35:29.247] - state: ‘created’
[13:35:29.247] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:29.250] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:29.250] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:29.250]   - Field: ‘label’
[13:35:29.250]   - Field: ‘local’
[13:35:29.250]   - Field: ‘owner’
[13:35:29.250]   - Field: ‘envir’
[13:35:29.251]   - Field: ‘packages’
[13:35:29.251]   - Field: ‘gc’
[13:35:29.251]   - Field: ‘conditions’
[13:35:29.251]   - Field: ‘expr’
[13:35:29.251]   - Field: ‘uuid’
[13:35:29.251]   - Field: ‘seed’
[13:35:29.251]   - Field: ‘version’
[13:35:29.251]   - Field: ‘result’
[13:35:29.251]   - Field: ‘asynchronous’
[13:35:29.251]   - Field: ‘calls’
[13:35:29.251]   - Field: ‘globals’
[13:35:29.252]   - Field: ‘stdout’
[13:35:29.252]   - Field: ‘earlySignal’
[13:35:29.252]   - Field: ‘lazy’
[13:35:29.252]   - Field: ‘state’
[13:35:29.252] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:29.252] - Launch lazy future ...
[13:35:29.252] Packages needed by the future expression (n = 0): <none>
[13:35:29.252] Packages needed by future strategies (n = 0): <none>
[13:35:29.254] {
[13:35:29.254]     {
[13:35:29.254]         {
[13:35:29.254]             ...future.startTime <- base::Sys.time()
[13:35:29.254]             {
[13:35:29.254]                 {
[13:35:29.254]                   {
[13:35:29.254]                     base::local({
[13:35:29.254]                       has_future <- base::requireNamespace("future", 
[13:35:29.254]                         quietly = TRUE)
[13:35:29.254]                       if (has_future) {
[13:35:29.254]                         ns <- base::getNamespace("future")
[13:35:29.254]                         version <- ns[[".package"]][["version"]]
[13:35:29.254]                         if (is.null(version)) 
[13:35:29.254]                           version <- utils::packageVersion("future")
[13:35:29.254]                       }
[13:35:29.254]                       else {
[13:35:29.254]                         version <- NULL
[13:35:29.254]                       }
[13:35:29.254]                       if (!has_future || version < "1.8.0") {
[13:35:29.254]                         info <- base::c(r_version = base::gsub("R version ", 
[13:35:29.254]                           "", base::R.version$version.string), 
[13:35:29.254]                           platform = base::sprintf("%s (%s-bit)", 
[13:35:29.254]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:29.254]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:29.254]                             "release", "version")], collapse = " "), 
[13:35:29.254]                           hostname = base::Sys.info()[["nodename"]])
[13:35:29.254]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:35:29.254]                           info)
[13:35:29.254]                         info <- base::paste(info, collapse = "; ")
[13:35:29.254]                         if (!has_future) {
[13:35:29.254]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:29.254]                             info)
[13:35:29.254]                         }
[13:35:29.254]                         else {
[13:35:29.254]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:29.254]                             info, version)
[13:35:29.254]                         }
[13:35:29.254]                         base::stop(msg)
[13:35:29.254]                       }
[13:35:29.254]                     })
[13:35:29.254]                   }
[13:35:29.254]                   ...future.strategy.old <- future::plan("list")
[13:35:29.254]                   options(future.plan = NULL)
[13:35:29.254]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:29.254]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:29.254]                 }
[13:35:29.254]                 ...future.workdir <- getwd()
[13:35:29.254]             }
[13:35:29.254]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:29.254]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:29.254]         }
[13:35:29.254]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:29.254]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:29.254]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:29.254]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:29.254]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:29.254]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:29.254]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:29.254]             base::names(...future.oldOptions))
[13:35:29.254]     }
[13:35:29.254]     if (TRUE) {
[13:35:29.254]     }
[13:35:29.254]     else {
[13:35:29.254]         if (NA) {
[13:35:29.254]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:29.254]                 open = "w")
[13:35:29.254]         }
[13:35:29.254]         else {
[13:35:29.254]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:29.254]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:29.254]         }
[13:35:29.254]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:29.254]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:29.254]             base::sink(type = "output", split = FALSE)
[13:35:29.254]             base::close(...future.stdout)
[13:35:29.254]         }, add = TRUE)
[13:35:29.254]     }
[13:35:29.254]     ...future.frame <- base::sys.nframe()
[13:35:29.254]     ...future.conditions <- base::list()
[13:35:29.254]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:29.254]     if (FALSE) {
[13:35:29.254]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:29.254]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:29.254]     }
[13:35:29.254]     ...future.result <- base::tryCatch({
[13:35:29.254]         base::withCallingHandlers({
[13:35:29.254]             ...future.value <- base::withVisible(base::local({
[13:35:29.254]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:29.254]                 if (!identical(...future.globals.maxSize.org, 
[13:35:29.254]                   ...future.globals.maxSize)) {
[13:35:29.254]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:29.254]                   on.exit(options(oopts), add = TRUE)
[13:35:29.254]                 }
[13:35:29.254]                 {
[13:35:29.254]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:29.254]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:35:29.254]                     USE.NAMES = FALSE)
[13:35:29.254]                   do.call(mapply, args = args)
[13:35:29.254]                 }
[13:35:29.254]             }))
[13:35:29.254]             future::FutureResult(value = ...future.value$value, 
[13:35:29.254]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:29.254]                   ...future.rng), globalenv = if (FALSE) 
[13:35:29.254]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:29.254]                     ...future.globalenv.names))
[13:35:29.254]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:29.254]         }, condition = base::local({
[13:35:29.254]             c <- base::c
[13:35:29.254]             inherits <- base::inherits
[13:35:29.254]             invokeRestart <- base::invokeRestart
[13:35:29.254]             length <- base::length
[13:35:29.254]             list <- base::list
[13:35:29.254]             seq.int <- base::seq.int
[13:35:29.254]             signalCondition <- base::signalCondition
[13:35:29.254]             sys.calls <- base::sys.calls
[13:35:29.254]             `[[` <- base::`[[`
[13:35:29.254]             `+` <- base::`+`
[13:35:29.254]             `<<-` <- base::`<<-`
[13:35:29.254]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:29.254]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:29.254]                   3L)]
[13:35:29.254]             }
[13:35:29.254]             function(cond) {
[13:35:29.254]                 is_error <- inherits(cond, "error")
[13:35:29.254]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:29.254]                   NULL)
[13:35:29.254]                 if (is_error) {
[13:35:29.254]                   sessionInformation <- function() {
[13:35:29.254]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:29.254]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:29.254]                       search = base::search(), system = base::Sys.info())
[13:35:29.254]                   }
[13:35:29.254]                   ...future.conditions[[length(...future.conditions) + 
[13:35:29.254]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:29.254]                     cond$call), session = sessionInformation(), 
[13:35:29.254]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:29.254]                   signalCondition(cond)
[13:35:29.254]                 }
[13:35:29.254]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:29.254]                 "immediateCondition"))) {
[13:35:29.254]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:29.254]                   ...future.conditions[[length(...future.conditions) + 
[13:35:29.254]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:29.254]                   if (TRUE && !signal) {
[13:35:29.254]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:29.254]                     {
[13:35:29.254]                       inherits <- base::inherits
[13:35:29.254]                       invokeRestart <- base::invokeRestart
[13:35:29.254]                       is.null <- base::is.null
[13:35:29.254]                       muffled <- FALSE
[13:35:29.254]                       if (inherits(cond, "message")) {
[13:35:29.254]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:29.254]                         if (muffled) 
[13:35:29.254]                           invokeRestart("muffleMessage")
[13:35:29.254]                       }
[13:35:29.254]                       else if (inherits(cond, "warning")) {
[13:35:29.254]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:29.254]                         if (muffled) 
[13:35:29.254]                           invokeRestart("muffleWarning")
[13:35:29.254]                       }
[13:35:29.254]                       else if (inherits(cond, "condition")) {
[13:35:29.254]                         if (!is.null(pattern)) {
[13:35:29.254]                           computeRestarts <- base::computeRestarts
[13:35:29.254]                           grepl <- base::grepl
[13:35:29.254]                           restarts <- computeRestarts(cond)
[13:35:29.254]                           for (restart in restarts) {
[13:35:29.254]                             name <- restart$name
[13:35:29.254]                             if (is.null(name)) 
[13:35:29.254]                               next
[13:35:29.254]                             if (!grepl(pattern, name)) 
[13:35:29.254]                               next
[13:35:29.254]                             invokeRestart(restart)
[13:35:29.254]                             muffled <- TRUE
[13:35:29.254]                             break
[13:35:29.254]                           }
[13:35:29.254]                         }
[13:35:29.254]                       }
[13:35:29.254]                       invisible(muffled)
[13:35:29.254]                     }
[13:35:29.254]                     muffleCondition(cond, pattern = "^muffle")
[13:35:29.254]                   }
[13:35:29.254]                 }
[13:35:29.254]                 else {
[13:35:29.254]                   if (TRUE) {
[13:35:29.254]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:29.254]                     {
[13:35:29.254]                       inherits <- base::inherits
[13:35:29.254]                       invokeRestart <- base::invokeRestart
[13:35:29.254]                       is.null <- base::is.null
[13:35:29.254]                       muffled <- FALSE
[13:35:29.254]                       if (inherits(cond, "message")) {
[13:35:29.254]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:29.254]                         if (muffled) 
[13:35:29.254]                           invokeRestart("muffleMessage")
[13:35:29.254]                       }
[13:35:29.254]                       else if (inherits(cond, "warning")) {
[13:35:29.254]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:29.254]                         if (muffled) 
[13:35:29.254]                           invokeRestart("muffleWarning")
[13:35:29.254]                       }
[13:35:29.254]                       else if (inherits(cond, "condition")) {
[13:35:29.254]                         if (!is.null(pattern)) {
[13:35:29.254]                           computeRestarts <- base::computeRestarts
[13:35:29.254]                           grepl <- base::grepl
[13:35:29.254]                           restarts <- computeRestarts(cond)
[13:35:29.254]                           for (restart in restarts) {
[13:35:29.254]                             name <- restart$name
[13:35:29.254]                             if (is.null(name)) 
[13:35:29.254]                               next
[13:35:29.254]                             if (!grepl(pattern, name)) 
[13:35:29.254]                               next
[13:35:29.254]                             invokeRestart(restart)
[13:35:29.254]                             muffled <- TRUE
[13:35:29.254]                             break
[13:35:29.254]                           }
[13:35:29.254]                         }
[13:35:29.254]                       }
[13:35:29.254]                       invisible(muffled)
[13:35:29.254]                     }
[13:35:29.254]                     muffleCondition(cond, pattern = "^muffle")
[13:35:29.254]                   }
[13:35:29.254]                 }
[13:35:29.254]             }
[13:35:29.254]         }))
[13:35:29.254]     }, error = function(ex) {
[13:35:29.254]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:29.254]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:29.254]                 ...future.rng), started = ...future.startTime, 
[13:35:29.254]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:29.254]             version = "1.8"), class = "FutureResult")
[13:35:29.254]     }, finally = {
[13:35:29.254]         if (!identical(...future.workdir, getwd())) 
[13:35:29.254]             setwd(...future.workdir)
[13:35:29.254]         {
[13:35:29.254]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:29.254]                 ...future.oldOptions$nwarnings <- NULL
[13:35:29.254]             }
[13:35:29.254]             base::options(...future.oldOptions)
[13:35:29.254]             if (.Platform$OS.type == "windows") {
[13:35:29.254]                 old_names <- names(...future.oldEnvVars)
[13:35:29.254]                 envs <- base::Sys.getenv()
[13:35:29.254]                 names <- names(envs)
[13:35:29.254]                 common <- intersect(names, old_names)
[13:35:29.254]                 added <- setdiff(names, old_names)
[13:35:29.254]                 removed <- setdiff(old_names, names)
[13:35:29.254]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:29.254]                   envs[common]]
[13:35:29.254]                 NAMES <- toupper(changed)
[13:35:29.254]                 args <- list()
[13:35:29.254]                 for (kk in seq_along(NAMES)) {
[13:35:29.254]                   name <- changed[[kk]]
[13:35:29.254]                   NAME <- NAMES[[kk]]
[13:35:29.254]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:29.254]                     next
[13:35:29.254]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:29.254]                 }
[13:35:29.254]                 NAMES <- toupper(added)
[13:35:29.254]                 for (kk in seq_along(NAMES)) {
[13:35:29.254]                   name <- added[[kk]]
[13:35:29.254]                   NAME <- NAMES[[kk]]
[13:35:29.254]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:29.254]                     next
[13:35:29.254]                   args[[name]] <- ""
[13:35:29.254]                 }
[13:35:29.254]                 NAMES <- toupper(removed)
[13:35:29.254]                 for (kk in seq_along(NAMES)) {
[13:35:29.254]                   name <- removed[[kk]]
[13:35:29.254]                   NAME <- NAMES[[kk]]
[13:35:29.254]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:29.254]                     next
[13:35:29.254]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:29.254]                 }
[13:35:29.254]                 if (length(args) > 0) 
[13:35:29.254]                   base::do.call(base::Sys.setenv, args = args)
[13:35:29.254]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:29.254]             }
[13:35:29.254]             else {
[13:35:29.254]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:29.254]             }
[13:35:29.254]             {
[13:35:29.254]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:29.254]                   0L) {
[13:35:29.254]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:29.254]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:29.254]                   base::options(opts)
[13:35:29.254]                 }
[13:35:29.254]                 {
[13:35:29.254]                   {
[13:35:29.254]                     NULL
[13:35:29.254]                     RNGkind("Mersenne-Twister")
[13:35:29.254]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:29.254]                       inherits = FALSE)
[13:35:29.254]                   }
[13:35:29.254]                   options(future.plan = NULL)
[13:35:29.254]                   if (is.na(NA_character_)) 
[13:35:29.254]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:29.254]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:29.254]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:29.254]                     .init = FALSE)
[13:35:29.254]                 }
[13:35:29.254]             }
[13:35:29.254]         }
[13:35:29.254]     })
[13:35:29.254]     if (FALSE) {
[13:35:29.254]         base::sink(type = "output", split = FALSE)
[13:35:29.254]         if (NA) {
[13:35:29.254]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:29.254]         }
[13:35:29.254]         else {
[13:35:29.254]             ...future.result["stdout"] <- base::list(NULL)
[13:35:29.254]         }
[13:35:29.254]         base::close(...future.stdout)
[13:35:29.254]         ...future.stdout <- NULL
[13:35:29.254]     }
[13:35:29.254]     ...future.result$conditions <- ...future.conditions
[13:35:29.254]     ...future.result$finished <- base::Sys.time()
[13:35:29.254]     ...future.result
[13:35:29.254] }
[13:35:29.256] assign_globals() ...
[13:35:29.256] List of 5
[13:35:29.256]  $ ...future.FUN            :function (x, y)  
[13:35:29.256]  $ MoreArgs                 : NULL
[13:35:29.256]  $ ...future.elements_ii    :List of 2
[13:35:29.256]   ..$ :List of 2
[13:35:29.256]   .. ..$ : int 1
[13:35:29.256]   .. ..$ : int 0
[13:35:29.256]   ..$ :List of 2
[13:35:29.256]   .. ..$ : int 0
[13:35:29.256]   .. ..$ : int 1
[13:35:29.256]  $ ...future.seeds_ii       : NULL
[13:35:29.256]  $ ...future.globals.maxSize: NULL
[13:35:29.256]  - attr(*, "where")=List of 5
[13:35:29.256]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:29.256]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:35:29.256]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:29.256]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:29.256]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:29.256]  - attr(*, "resolved")= logi FALSE
[13:35:29.256]  - attr(*, "total_size")= num 6480
[13:35:29.256]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:29.256]  - attr(*, "already-done")= logi TRUE
[13:35:29.262] - reassign environment for ‘...future.FUN’
[13:35:29.262] - copied ‘...future.FUN’ to environment
[13:35:29.262] - copied ‘MoreArgs’ to environment
[13:35:29.262] - copied ‘...future.elements_ii’ to environment
[13:35:29.262] - copied ‘...future.seeds_ii’ to environment
[13:35:29.262] - copied ‘...future.globals.maxSize’ to environment
[13:35:29.262] assign_globals() ... done
[13:35:29.263] plan(): Setting new future strategy stack:
[13:35:29.263] List of future strategies:
[13:35:29.263] 1. sequential:
[13:35:29.263]    - args: function (..., envir = parent.frame())
[13:35:29.263]    - tweaked: FALSE
[13:35:29.263]    - call: NULL
[13:35:29.263] plan(): nbrOfWorkers() = 1
[13:35:29.765] plan(): Setting new future strategy stack:
[13:35:29.765] List of future strategies:
[13:35:29.765] 1. multisession:
[13:35:29.765]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:35:29.765]    - tweaked: FALSE
[13:35:29.765]    - call: plan(strategy)
[13:35:29.769] plan(): nbrOfWorkers() = 1
[13:35:29.769] SequentialFuture started (and completed)
[13:35:29.769] - Launch lazy future ... done
[13:35:29.769] run() for ‘SequentialFuture’ ... done
[13:35:29.769] Created future:
[13:35:29.769] SequentialFuture:
[13:35:29.769] Label: ‘future_mapply-1’
[13:35:29.769] Expression:
[13:35:29.769] {
[13:35:29.769]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:29.769]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:29.769]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:29.769]         on.exit(options(oopts), add = TRUE)
[13:35:29.769]     }
[13:35:29.769]     {
[13:35:29.769]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:29.769]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:35:29.769]         do.call(mapply, args = args)
[13:35:29.769]     }
[13:35:29.769] }
[13:35:29.769] Lazy evaluation: FALSE
[13:35:29.769] Asynchronous evaluation: FALSE
[13:35:29.769] Local evaluation: TRUE
[13:35:29.769] Environment: R_GlobalEnv
[13:35:29.769] Capture standard output: NA
[13:35:29.769] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:29.769] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:29.769] Packages: <none>
[13:35:29.769] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:29.769] Resolved: TRUE
[13:35:29.769] Value: 224 bytes of class ‘list’
[13:35:29.769] Early signaling: FALSE
[13:35:29.769] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:29.769] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:29.770] Chunk #1 of 1 ... DONE
[13:35:29.770] Launching 1 futures (chunks) ... DONE
[13:35:29.771] Resolving 1 futures (chunks) ...
[13:35:29.771] resolve() on list ...
[13:35:29.771]  recursive: 0
[13:35:29.771]  length: 1
[13:35:29.771] 
[13:35:29.771] resolved() for ‘SequentialFuture’ ...
[13:35:29.771] - state: ‘finished’
[13:35:29.771] - run: TRUE
[13:35:29.771] - result: ‘FutureResult’
[13:35:29.771] resolved() for ‘SequentialFuture’ ... done
[13:35:29.772] Future #1
[13:35:29.772] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:29.772] - nx: 1
[13:35:29.772] - relay: TRUE
[13:35:29.772] - stdout: TRUE
[13:35:29.772] - signal: TRUE
[13:35:29.772] - resignal: FALSE
[13:35:29.772] - force: TRUE
[13:35:29.772] - relayed: [n=1] FALSE
[13:35:29.772] - queued futures: [n=1] FALSE
[13:35:29.773]  - until=1
[13:35:29.773]  - relaying element #1
[13:35:29.773] - relayed: [n=1] TRUE
[13:35:29.773] - queued futures: [n=1] TRUE
[13:35:29.773] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:29.773]  length: 0 (resolved future 1)
[13:35:29.773] Relaying remaining futures
[13:35:29.773] signalConditionsASAP(NULL, pos=0) ...
[13:35:29.773] - nx: 1
[13:35:29.773] - relay: TRUE
[13:35:29.773] - stdout: TRUE
[13:35:29.774] - signal: TRUE
[13:35:29.774] - resignal: FALSE
[13:35:29.774] - force: TRUE
[13:35:29.774] - relayed: [n=1] TRUE
[13:35:29.774] - queued futures: [n=1] TRUE
 - flush all
[13:35:29.774] - relayed: [n=1] TRUE
[13:35:29.774] - queued futures: [n=1] TRUE
[13:35:29.774] signalConditionsASAP(NULL, pos=0) ... done
[13:35:29.774] resolve() on list ... DONE
[13:35:29.775]  - Number of value chunks collected: 1
[13:35:29.775] Resolving 1 futures (chunks) ... DONE
[13:35:29.775] Reducing values from 1 chunks ...
[13:35:29.775]  - Number of values collected after concatenation: 2
[13:35:29.775]  - Number of values expected: 2
[13:35:29.775] Reducing values from 1 chunks ... DONE
[13:35:29.775] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 1 cores ... DONE
  - Testing with 2 cores ...
* plan('multicore') ...
[13:35:29.779] plan(): Setting new future strategy stack:
[13:35:29.779] List of future strategies:
[13:35:29.779] 1. multicore:
[13:35:29.779]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:29.779]    - tweaked: FALSE
[13:35:29.779]    - call: plan(strategy)
[13:35:29.783] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[13:35:29.783] future_lapply() ...
[13:35:29.790] Number of chunks: 2
[13:35:29.790] getGlobalsAndPackagesXApply() ...
[13:35:29.791]  - future.globals: TRUE
[13:35:29.791] getGlobalsAndPackages() ...
[13:35:29.791] Searching for globals...
[13:35:29.792] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:35:29.792] Searching for globals ... DONE
[13:35:29.792] Resolving globals: FALSE
[13:35:29.793] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:35:29.793] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:35:29.793] - globals: [1] ‘FUN’
[13:35:29.793] 
[13:35:29.793] getGlobalsAndPackages() ... DONE
[13:35:29.794]  - globals found/used: [n=1] ‘FUN’
[13:35:29.794]  - needed namespaces: [n=0] 
[13:35:29.794] Finding globals ... DONE
[13:35:29.794]  - use_args: TRUE
[13:35:29.794]  - Getting '...' globals ...
[13:35:29.794] resolve() on list ...
[13:35:29.794]  recursive: 0
[13:35:29.794]  length: 1
[13:35:29.795]  elements: ‘...’
[13:35:29.795]  length: 0 (resolved future 1)
[13:35:29.795] resolve() on list ... DONE
[13:35:29.795]    - '...' content: [n=0] 
[13:35:29.795] List of 1
[13:35:29.795]  $ ...: list()
[13:35:29.795]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:29.795]  - attr(*, "where")=List of 1
[13:35:29.795]   ..$ ...:<environment: 0x558d38ab2f68> 
[13:35:29.795]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:29.795]  - attr(*, "resolved")= logi TRUE
[13:35:29.795]  - attr(*, "total_size")= num NA
[13:35:29.797]  - Getting '...' globals ... DONE
[13:35:29.798] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:35:29.798] List of 2
[13:35:29.798]  $ ...future.FUN:function (x)  
[13:35:29.798]  $ ...          : list()
[13:35:29.798]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:29.798]  - attr(*, "where")=List of 2
[13:35:29.798]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:29.798]   ..$ ...          :<environment: 0x558d38ab2f68> 
[13:35:29.798]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:29.798]  - attr(*, "resolved")= logi FALSE
[13:35:29.798]  - attr(*, "total_size")= num 4720
[13:35:29.800] Packages to be attached in all futures: [n=0] 
[13:35:29.801] getGlobalsAndPackagesXApply() ... DONE
[13:35:29.801] Number of futures (= number of chunks): 2
[13:35:29.801] Launching 2 futures (chunks) ...
[13:35:29.801] Chunk #1 of 2 ...
[13:35:29.801]  - Finding globals in 'X' for chunk #1 ...
[13:35:29.801] getGlobalsAndPackages() ...
[13:35:29.801] Searching for globals...
[13:35:29.801] 
[13:35:29.802] Searching for globals ... DONE
[13:35:29.802] - globals: [0] <none>
[13:35:29.802] getGlobalsAndPackages() ... DONE
[13:35:29.802]    + additional globals found: [n=0] 
[13:35:29.802]    + additional namespaces needed: [n=0] 
[13:35:29.802]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:29.802]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:29.802]  - seeds: <none>
[13:35:29.802]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:29.802] getGlobalsAndPackages() ...
[13:35:29.803] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:29.803] Resolving globals: FALSE
[13:35:29.803] Tweak future expression to call with '...' arguments ...
[13:35:29.803] {
[13:35:29.803]     do.call(function(...) {
[13:35:29.803]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:29.803]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:29.803]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:29.803]             on.exit(options(oopts), add = TRUE)
[13:35:29.803]         }
[13:35:29.803]         {
[13:35:29.803]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:29.803]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:29.803]                 ...future.FUN(...future.X_jj, ...)
[13:35:29.803]             })
[13:35:29.803]         }
[13:35:29.803]     }, args = future.call.arguments)
[13:35:29.803] }
[13:35:29.803] Tweak future expression to call with '...' arguments ... DONE
[13:35:29.803] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:29.804] 
[13:35:29.804] getGlobalsAndPackages() ... DONE
[13:35:29.804] run() for ‘Future’ ...
[13:35:29.804] - state: ‘created’
[13:35:29.804] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:29.808] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:29.808] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:29.808]   - Field: ‘label’
[13:35:29.808]   - Field: ‘local’
[13:35:29.808]   - Field: ‘owner’
[13:35:29.808]   - Field: ‘envir’
[13:35:29.808]   - Field: ‘workers’
[13:35:29.808]   - Field: ‘packages’
[13:35:29.809]   - Field: ‘gc’
[13:35:29.809]   - Field: ‘job’
[13:35:29.809]   - Field: ‘conditions’
[13:35:29.809]   - Field: ‘expr’
[13:35:29.809]   - Field: ‘uuid’
[13:35:29.809]   - Field: ‘seed’
[13:35:29.809]   - Field: ‘version’
[13:35:29.809]   - Field: ‘result’
[13:35:29.809]   - Field: ‘asynchronous’
[13:35:29.809]   - Field: ‘calls’
[13:35:29.809]   - Field: ‘globals’
[13:35:29.810]   - Field: ‘stdout’
[13:35:29.810]   - Field: ‘earlySignal’
[13:35:29.810]   - Field: ‘lazy’
[13:35:29.810]   - Field: ‘state’
[13:35:29.810] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:29.810] - Launch lazy future ...
[13:35:29.811] Packages needed by the future expression (n = 0): <none>
[13:35:29.811] Packages needed by future strategies (n = 0): <none>
[13:35:29.812] {
[13:35:29.812]     {
[13:35:29.812]         {
[13:35:29.812]             ...future.startTime <- base::Sys.time()
[13:35:29.812]             {
[13:35:29.812]                 {
[13:35:29.812]                   {
[13:35:29.812]                     {
[13:35:29.812]                       base::local({
[13:35:29.812]                         has_future <- base::requireNamespace("future", 
[13:35:29.812]                           quietly = TRUE)
[13:35:29.812]                         if (has_future) {
[13:35:29.812]                           ns <- base::getNamespace("future")
[13:35:29.812]                           version <- ns[[".package"]][["version"]]
[13:35:29.812]                           if (is.null(version)) 
[13:35:29.812]                             version <- utils::packageVersion("future")
[13:35:29.812]                         }
[13:35:29.812]                         else {
[13:35:29.812]                           version <- NULL
[13:35:29.812]                         }
[13:35:29.812]                         if (!has_future || version < "1.8.0") {
[13:35:29.812]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:29.812]                             "", base::R.version$version.string), 
[13:35:29.812]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:29.812]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:29.812]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:29.812]                               "release", "version")], collapse = " "), 
[13:35:29.812]                             hostname = base::Sys.info()[["nodename"]])
[13:35:29.812]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:29.812]                             info)
[13:35:29.812]                           info <- base::paste(info, collapse = "; ")
[13:35:29.812]                           if (!has_future) {
[13:35:29.812]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:29.812]                               info)
[13:35:29.812]                           }
[13:35:29.812]                           else {
[13:35:29.812]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:29.812]                               info, version)
[13:35:29.812]                           }
[13:35:29.812]                           base::stop(msg)
[13:35:29.812]                         }
[13:35:29.812]                       })
[13:35:29.812]                     }
[13:35:29.812]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:29.812]                     base::options(mc.cores = 1L)
[13:35:29.812]                   }
[13:35:29.812]                   ...future.strategy.old <- future::plan("list")
[13:35:29.812]                   options(future.plan = NULL)
[13:35:29.812]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:29.812]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:29.812]                 }
[13:35:29.812]                 ...future.workdir <- getwd()
[13:35:29.812]             }
[13:35:29.812]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:29.812]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:29.812]         }
[13:35:29.812]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:29.812]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:29.812]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:29.812]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:29.812]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:29.812]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:29.812]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:29.812]             base::names(...future.oldOptions))
[13:35:29.812]     }
[13:35:29.812]     if (FALSE) {
[13:35:29.812]     }
[13:35:29.812]     else {
[13:35:29.812]         if (FALSE) {
[13:35:29.812]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:29.812]                 open = "w")
[13:35:29.812]         }
[13:35:29.812]         else {
[13:35:29.812]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:29.812]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:29.812]         }
[13:35:29.812]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:29.812]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:29.812]             base::sink(type = "output", split = FALSE)
[13:35:29.812]             base::close(...future.stdout)
[13:35:29.812]         }, add = TRUE)
[13:35:29.812]     }
[13:35:29.812]     ...future.frame <- base::sys.nframe()
[13:35:29.812]     ...future.conditions <- base::list()
[13:35:29.812]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:29.812]     if (FALSE) {
[13:35:29.812]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:29.812]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:29.812]     }
[13:35:29.812]     ...future.result <- base::tryCatch({
[13:35:29.812]         base::withCallingHandlers({
[13:35:29.812]             ...future.value <- base::withVisible(base::local({
[13:35:29.812]                 withCallingHandlers({
[13:35:29.812]                   {
[13:35:29.812]                     do.call(function(...) {
[13:35:29.812]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:29.812]                       if (!identical(...future.globals.maxSize.org, 
[13:35:29.812]                         ...future.globals.maxSize)) {
[13:35:29.812]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:29.812]                         on.exit(options(oopts), add = TRUE)
[13:35:29.812]                       }
[13:35:29.812]                       {
[13:35:29.812]                         lapply(seq_along(...future.elements_ii), 
[13:35:29.812]                           FUN = function(jj) {
[13:35:29.812]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:29.812]                             ...future.FUN(...future.X_jj, ...)
[13:35:29.812]                           })
[13:35:29.812]                       }
[13:35:29.812]                     }, args = future.call.arguments)
[13:35:29.812]                   }
[13:35:29.812]                 }, immediateCondition = function(cond) {
[13:35:29.812]                   save_rds <- function (object, pathname, ...) 
[13:35:29.812]                   {
[13:35:29.812]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:29.812]                     if (file_test("-f", pathname_tmp)) {
[13:35:29.812]                       fi_tmp <- file.info(pathname_tmp)
[13:35:29.812]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:29.812]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:29.812]                         fi_tmp[["mtime"]])
[13:35:29.812]                     }
[13:35:29.812]                     tryCatch({
[13:35:29.812]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:29.812]                     }, error = function(ex) {
[13:35:29.812]                       msg <- conditionMessage(ex)
[13:35:29.812]                       fi_tmp <- file.info(pathname_tmp)
[13:35:29.812]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:29.812]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:29.812]                         fi_tmp[["mtime"]], msg)
[13:35:29.812]                       ex$message <- msg
[13:35:29.812]                       stop(ex)
[13:35:29.812]                     })
[13:35:29.812]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:29.812]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:29.812]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:29.812]                       fi_tmp <- file.info(pathname_tmp)
[13:35:29.812]                       fi <- file.info(pathname)
[13:35:29.812]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:29.812]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:29.812]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:29.812]                         fi[["size"]], fi[["mtime"]])
[13:35:29.812]                       stop(msg)
[13:35:29.812]                     }
[13:35:29.812]                     invisible(pathname)
[13:35:29.812]                   }
[13:35:29.812]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:29.812]                     rootPath = tempdir()) 
[13:35:29.812]                   {
[13:35:29.812]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:29.812]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:29.812]                       tmpdir = path, fileext = ".rds")
[13:35:29.812]                     save_rds(obj, file)
[13:35:29.812]                   }
[13:35:29.812]                   saveImmediateCondition(cond, path = "/tmp/RtmpghgvGN/.future/immediateConditions")
[13:35:29.812]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:29.812]                   {
[13:35:29.812]                     inherits <- base::inherits
[13:35:29.812]                     invokeRestart <- base::invokeRestart
[13:35:29.812]                     is.null <- base::is.null
[13:35:29.812]                     muffled <- FALSE
[13:35:29.812]                     if (inherits(cond, "message")) {
[13:35:29.812]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:29.812]                       if (muffled) 
[13:35:29.812]                         invokeRestart("muffleMessage")
[13:35:29.812]                     }
[13:35:29.812]                     else if (inherits(cond, "warning")) {
[13:35:29.812]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:29.812]                       if (muffled) 
[13:35:29.812]                         invokeRestart("muffleWarning")
[13:35:29.812]                     }
[13:35:29.812]                     else if (inherits(cond, "condition")) {
[13:35:29.812]                       if (!is.null(pattern)) {
[13:35:29.812]                         computeRestarts <- base::computeRestarts
[13:35:29.812]                         grepl <- base::grepl
[13:35:29.812]                         restarts <- computeRestarts(cond)
[13:35:29.812]                         for (restart in restarts) {
[13:35:29.812]                           name <- restart$name
[13:35:29.812]                           if (is.null(name)) 
[13:35:29.812]                             next
[13:35:29.812]                           if (!grepl(pattern, name)) 
[13:35:29.812]                             next
[13:35:29.812]                           invokeRestart(restart)
[13:35:29.812]                           muffled <- TRUE
[13:35:29.812]                           break
[13:35:29.812]                         }
[13:35:29.812]                       }
[13:35:29.812]                     }
[13:35:29.812]                     invisible(muffled)
[13:35:29.812]                   }
[13:35:29.812]                   muffleCondition(cond)
[13:35:29.812]                 })
[13:35:29.812]             }))
[13:35:29.812]             future::FutureResult(value = ...future.value$value, 
[13:35:29.812]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:29.812]                   ...future.rng), globalenv = if (FALSE) 
[13:35:29.812]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:29.812]                     ...future.globalenv.names))
[13:35:29.812]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:29.812]         }, condition = base::local({
[13:35:29.812]             c <- base::c
[13:35:29.812]             inherits <- base::inherits
[13:35:29.812]             invokeRestart <- base::invokeRestart
[13:35:29.812]             length <- base::length
[13:35:29.812]             list <- base::list
[13:35:29.812]             seq.int <- base::seq.int
[13:35:29.812]             signalCondition <- base::signalCondition
[13:35:29.812]             sys.calls <- base::sys.calls
[13:35:29.812]             `[[` <- base::`[[`
[13:35:29.812]             `+` <- base::`+`
[13:35:29.812]             `<<-` <- base::`<<-`
[13:35:29.812]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:29.812]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:29.812]                   3L)]
[13:35:29.812]             }
[13:35:29.812]             function(cond) {
[13:35:29.812]                 is_error <- inherits(cond, "error")
[13:35:29.812]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:29.812]                   NULL)
[13:35:29.812]                 if (is_error) {
[13:35:29.812]                   sessionInformation <- function() {
[13:35:29.812]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:29.812]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:29.812]                       search = base::search(), system = base::Sys.info())
[13:35:29.812]                   }
[13:35:29.812]                   ...future.conditions[[length(...future.conditions) + 
[13:35:29.812]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:29.812]                     cond$call), session = sessionInformation(), 
[13:35:29.812]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:29.812]                   signalCondition(cond)
[13:35:29.812]                 }
[13:35:29.812]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:29.812]                 "immediateCondition"))) {
[13:35:29.812]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:29.812]                   ...future.conditions[[length(...future.conditions) + 
[13:35:29.812]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:29.812]                   if (TRUE && !signal) {
[13:35:29.812]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:29.812]                     {
[13:35:29.812]                       inherits <- base::inherits
[13:35:29.812]                       invokeRestart <- base::invokeRestart
[13:35:29.812]                       is.null <- base::is.null
[13:35:29.812]                       muffled <- FALSE
[13:35:29.812]                       if (inherits(cond, "message")) {
[13:35:29.812]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:29.812]                         if (muffled) 
[13:35:29.812]                           invokeRestart("muffleMessage")
[13:35:29.812]                       }
[13:35:29.812]                       else if (inherits(cond, "warning")) {
[13:35:29.812]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:29.812]                         if (muffled) 
[13:35:29.812]                           invokeRestart("muffleWarning")
[13:35:29.812]                       }
[13:35:29.812]                       else if (inherits(cond, "condition")) {
[13:35:29.812]                         if (!is.null(pattern)) {
[13:35:29.812]                           computeRestarts <- base::computeRestarts
[13:35:29.812]                           grepl <- base::grepl
[13:35:29.812]                           restarts <- computeRestarts(cond)
[13:35:29.812]                           for (restart in restarts) {
[13:35:29.812]                             name <- restart$name
[13:35:29.812]                             if (is.null(name)) 
[13:35:29.812]                               next
[13:35:29.812]                             if (!grepl(pattern, name)) 
[13:35:29.812]                               next
[13:35:29.812]                             invokeRestart(restart)
[13:35:29.812]                             muffled <- TRUE
[13:35:29.812]                             break
[13:35:29.812]                           }
[13:35:29.812]                         }
[13:35:29.812]                       }
[13:35:29.812]                       invisible(muffled)
[13:35:29.812]                     }
[13:35:29.812]                     muffleCondition(cond, pattern = "^muffle")
[13:35:29.812]                   }
[13:35:29.812]                 }
[13:35:29.812]                 else {
[13:35:29.812]                   if (TRUE) {
[13:35:29.812]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:29.812]                     {
[13:35:29.812]                       inherits <- base::inherits
[13:35:29.812]                       invokeRestart <- base::invokeRestart
[13:35:29.812]                       is.null <- base::is.null
[13:35:29.812]                       muffled <- FALSE
[13:35:29.812]                       if (inherits(cond, "message")) {
[13:35:29.812]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:29.812]                         if (muffled) 
[13:35:29.812]                           invokeRestart("muffleMessage")
[13:35:29.812]                       }
[13:35:29.812]                       else if (inherits(cond, "warning")) {
[13:35:29.812]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:29.812]                         if (muffled) 
[13:35:29.812]                           invokeRestart("muffleWarning")
[13:35:29.812]                       }
[13:35:29.812]                       else if (inherits(cond, "condition")) {
[13:35:29.812]                         if (!is.null(pattern)) {
[13:35:29.812]                           computeRestarts <- base::computeRestarts
[13:35:29.812]                           grepl <- base::grepl
[13:35:29.812]                           restarts <- computeRestarts(cond)
[13:35:29.812]                           for (restart in restarts) {
[13:35:29.812]                             name <- restart$name
[13:35:29.812]                             if (is.null(name)) 
[13:35:29.812]                               next
[13:35:29.812]                             if (!grepl(pattern, name)) 
[13:35:29.812]                               next
[13:35:29.812]                             invokeRestart(restart)
[13:35:29.812]                             muffled <- TRUE
[13:35:29.812]                             break
[13:35:29.812]                           }
[13:35:29.812]                         }
[13:35:29.812]                       }
[13:35:29.812]                       invisible(muffled)
[13:35:29.812]                     }
[13:35:29.812]                     muffleCondition(cond, pattern = "^muffle")
[13:35:29.812]                   }
[13:35:29.812]                 }
[13:35:29.812]             }
[13:35:29.812]         }))
[13:35:29.812]     }, error = function(ex) {
[13:35:29.812]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:29.812]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:29.812]                 ...future.rng), started = ...future.startTime, 
[13:35:29.812]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:29.812]             version = "1.8"), class = "FutureResult")
[13:35:29.812]     }, finally = {
[13:35:29.812]         if (!identical(...future.workdir, getwd())) 
[13:35:29.812]             setwd(...future.workdir)
[13:35:29.812]         {
[13:35:29.812]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:29.812]                 ...future.oldOptions$nwarnings <- NULL
[13:35:29.812]             }
[13:35:29.812]             base::options(...future.oldOptions)
[13:35:29.812]             if (.Platform$OS.type == "windows") {
[13:35:29.812]                 old_names <- names(...future.oldEnvVars)
[13:35:29.812]                 envs <- base::Sys.getenv()
[13:35:29.812]                 names <- names(envs)
[13:35:29.812]                 common <- intersect(names, old_names)
[13:35:29.812]                 added <- setdiff(names, old_names)
[13:35:29.812]                 removed <- setdiff(old_names, names)
[13:35:29.812]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:29.812]                   envs[common]]
[13:35:29.812]                 NAMES <- toupper(changed)
[13:35:29.812]                 args <- list()
[13:35:29.812]                 for (kk in seq_along(NAMES)) {
[13:35:29.812]                   name <- changed[[kk]]
[13:35:29.812]                   NAME <- NAMES[[kk]]
[13:35:29.812]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:29.812]                     next
[13:35:29.812]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:29.812]                 }
[13:35:29.812]                 NAMES <- toupper(added)
[13:35:29.812]                 for (kk in seq_along(NAMES)) {
[13:35:29.812]                   name <- added[[kk]]
[13:35:29.812]                   NAME <- NAMES[[kk]]
[13:35:29.812]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:29.812]                     next
[13:35:29.812]                   args[[name]] <- ""
[13:35:29.812]                 }
[13:35:29.812]                 NAMES <- toupper(removed)
[13:35:29.812]                 for (kk in seq_along(NAMES)) {
[13:35:29.812]                   name <- removed[[kk]]
[13:35:29.812]                   NAME <- NAMES[[kk]]
[13:35:29.812]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:29.812]                     next
[13:35:29.812]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:29.812]                 }
[13:35:29.812]                 if (length(args) > 0) 
[13:35:29.812]                   base::do.call(base::Sys.setenv, args = args)
[13:35:29.812]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:29.812]             }
[13:35:29.812]             else {
[13:35:29.812]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:29.812]             }
[13:35:29.812]             {
[13:35:29.812]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:29.812]                   0L) {
[13:35:29.812]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:29.812]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:29.812]                   base::options(opts)
[13:35:29.812]                 }
[13:35:29.812]                 {
[13:35:29.812]                   {
[13:35:29.812]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:29.812]                     NULL
[13:35:29.812]                   }
[13:35:29.812]                   options(future.plan = NULL)
[13:35:29.812]                   if (is.na(NA_character_)) 
[13:35:29.812]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:29.812]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:29.812]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:29.812]                     .init = FALSE)
[13:35:29.812]                 }
[13:35:29.812]             }
[13:35:29.812]         }
[13:35:29.812]     })
[13:35:29.812]     if (TRUE) {
[13:35:29.812]         base::sink(type = "output", split = FALSE)
[13:35:29.812]         if (FALSE) {
[13:35:29.812]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:29.812]         }
[13:35:29.812]         else {
[13:35:29.812]             ...future.result["stdout"] <- base::list(NULL)
[13:35:29.812]         }
[13:35:29.812]         base::close(...future.stdout)
[13:35:29.812]         ...future.stdout <- NULL
[13:35:29.812]     }
[13:35:29.812]     ...future.result$conditions <- ...future.conditions
[13:35:29.812]     ...future.result$finished <- base::Sys.time()
[13:35:29.812]     ...future.result
[13:35:29.812] }
[13:35:29.814] assign_globals() ...
[13:35:29.814] List of 5
[13:35:29.814]  $ ...future.FUN            :function (x)  
[13:35:29.814]  $ future.call.arguments    : list()
[13:35:29.814]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:29.814]  $ ...future.elements_ii    :List of 1
[13:35:29.814]   ..$ : int 1
[13:35:29.814]  $ ...future.seeds_ii       : NULL
[13:35:29.814]  $ ...future.globals.maxSize: NULL
[13:35:29.814]  - attr(*, "where")=List of 5
[13:35:29.814]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:29.814]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:29.814]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:29.814]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:29.814]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:29.814]  - attr(*, "resolved")= logi FALSE
[13:35:29.814]  - attr(*, "total_size")= num 4720
[13:35:29.814]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:29.814]  - attr(*, "already-done")= logi TRUE
[13:35:29.820] - reassign environment for ‘...future.FUN’
[13:35:29.820] - copied ‘...future.FUN’ to environment
[13:35:29.820] - copied ‘future.call.arguments’ to environment
[13:35:29.820] - copied ‘...future.elements_ii’ to environment
[13:35:29.820] - copied ‘...future.seeds_ii’ to environment
[13:35:29.820] - copied ‘...future.globals.maxSize’ to environment
[13:35:29.820] assign_globals() ... done
[13:35:29.821] requestCore(): workers = 2
[13:35:29.824] MulticoreFuture started
[13:35:29.824] - Launch lazy future ... done
[13:35:29.825] plan(): Setting new future strategy stack:
[13:35:29.825] run() for ‘MulticoreFuture’ ... done
[13:35:29.825] Created future:
[13:35:29.825] List of future strategies:
[13:35:29.825] 1. sequential:
[13:35:29.825]    - args: function (..., envir = parent.frame())
[13:35:29.825]    - tweaked: FALSE
[13:35:29.825]    - call: NULL
[13:35:29.826] plan(): nbrOfWorkers() = 1
[13:35:29.826] MulticoreFuture:
[13:35:29.826] Label: ‘future_lapply-1’
[13:35:29.826] Expression:
[13:35:29.826] {
[13:35:29.826]     do.call(function(...) {
[13:35:29.826]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:29.826]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:29.826]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:29.826]             on.exit(options(oopts), add = TRUE)
[13:35:29.826]         }
[13:35:29.826]         {
[13:35:29.826]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:29.826]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:29.826]                 ...future.FUN(...future.X_jj, ...)
[13:35:29.826]             })
[13:35:29.826]         }
[13:35:29.826]     }, args = future.call.arguments)
[13:35:29.826] }
[13:35:29.826] Lazy evaluation: FALSE
[13:35:29.826] Asynchronous evaluation: TRUE
[13:35:29.826] Local evaluation: TRUE
[13:35:29.826] Environment: R_GlobalEnv
[13:35:29.826] Capture standard output: FALSE
[13:35:29.826] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:29.826] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:29.826] Packages: <none>
[13:35:29.826] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:29.826] Resolved: FALSE
[13:35:29.826] Value: <not collected>
[13:35:29.826] Conditions captured: <none>
[13:35:29.826] Early signaling: FALSE
[13:35:29.826] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:29.826] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:29.842] Chunk #1 of 2 ... DONE
[13:35:29.842] Chunk #2 of 2 ...
[13:35:29.842]  - Finding globals in 'X' for chunk #2 ...
[13:35:29.843] getGlobalsAndPackages() ...
[13:35:29.843] Searching for globals...
[13:35:29.843] 
[13:35:29.844] Searching for globals ... DONE
[13:35:29.844] - globals: [0] <none>
[13:35:29.844] getGlobalsAndPackages() ... DONE
[13:35:29.844]    + additional globals found: [n=0] 
[13:35:29.844]    + additional namespaces needed: [n=0] 
[13:35:29.845]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:29.845]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:29.845]  - seeds: <none>
[13:35:29.845]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:29.845] getGlobalsAndPackages() ...
[13:35:29.846] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:29.846] Resolving globals: FALSE
[13:35:29.846] Tweak future expression to call with '...' arguments ...
[13:35:29.846] {
[13:35:29.846]     do.call(function(...) {
[13:35:29.846]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:29.846]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:29.846]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:29.846]             on.exit(options(oopts), add = TRUE)
[13:35:29.846]         }
[13:35:29.846]         {
[13:35:29.846]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:29.846]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:29.846]                 ...future.FUN(...future.X_jj, ...)
[13:35:29.846]             })
[13:35:29.846]         }
[13:35:29.846]     }, args = future.call.arguments)
[13:35:29.846] }
[13:35:29.847] Tweak future expression to call with '...' arguments ... DONE
[13:35:29.848] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:29.848] 
[13:35:29.848] getGlobalsAndPackages() ... DONE
[13:35:29.849] run() for ‘Future’ ...
[13:35:29.849] - state: ‘created’
[13:35:29.849] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:29.854] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:29.854] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:29.854]   - Field: ‘label’
[13:35:29.855]   - Field: ‘local’
[13:35:29.855]   - Field: ‘owner’
[13:35:29.855]   - Field: ‘envir’
[13:35:29.855]   - Field: ‘workers’
[13:35:29.855]   - Field: ‘packages’
[13:35:29.855]   - Field: ‘gc’
[13:35:29.855]   - Field: ‘job’
[13:35:29.856]   - Field: ‘conditions’
[13:35:29.856]   - Field: ‘expr’
[13:35:29.856]   - Field: ‘uuid’
[13:35:29.856]   - Field: ‘seed’
[13:35:29.856]   - Field: ‘version’
[13:35:29.856]   - Field: ‘result’
[13:35:29.856]   - Field: ‘asynchronous’
[13:35:29.857]   - Field: ‘calls’
[13:35:29.857]   - Field: ‘globals’
[13:35:29.857]   - Field: ‘stdout’
[13:35:29.857]   - Field: ‘earlySignal’
[13:35:29.857]   - Field: ‘lazy’
[13:35:29.857]   - Field: ‘state’
[13:35:29.857] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:29.858] - Launch lazy future ...
[13:35:29.858] Packages needed by the future expression (n = 0): <none>
[13:35:29.858] Packages needed by future strategies (n = 0): <none>
[13:35:29.859] {
[13:35:29.859]     {
[13:35:29.859]         {
[13:35:29.859]             ...future.startTime <- base::Sys.time()
[13:35:29.859]             {
[13:35:29.859]                 {
[13:35:29.859]                   {
[13:35:29.859]                     {
[13:35:29.859]                       base::local({
[13:35:29.859]                         has_future <- base::requireNamespace("future", 
[13:35:29.859]                           quietly = TRUE)
[13:35:29.859]                         if (has_future) {
[13:35:29.859]                           ns <- base::getNamespace("future")
[13:35:29.859]                           version <- ns[[".package"]][["version"]]
[13:35:29.859]                           if (is.null(version)) 
[13:35:29.859]                             version <- utils::packageVersion("future")
[13:35:29.859]                         }
[13:35:29.859]                         else {
[13:35:29.859]                           version <- NULL
[13:35:29.859]                         }
[13:35:29.859]                         if (!has_future || version < "1.8.0") {
[13:35:29.859]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:29.859]                             "", base::R.version$version.string), 
[13:35:29.859]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:29.859]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:29.859]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:29.859]                               "release", "version")], collapse = " "), 
[13:35:29.859]                             hostname = base::Sys.info()[["nodename"]])
[13:35:29.859]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:29.859]                             info)
[13:35:29.859]                           info <- base::paste(info, collapse = "; ")
[13:35:29.859]                           if (!has_future) {
[13:35:29.859]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:29.859]                               info)
[13:35:29.859]                           }
[13:35:29.859]                           else {
[13:35:29.859]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:29.859]                               info, version)
[13:35:29.859]                           }
[13:35:29.859]                           base::stop(msg)
[13:35:29.859]                         }
[13:35:29.859]                       })
[13:35:29.859]                     }
[13:35:29.859]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:29.859]                     base::options(mc.cores = 1L)
[13:35:29.859]                   }
[13:35:29.859]                   ...future.strategy.old <- future::plan("list")
[13:35:29.859]                   options(future.plan = NULL)
[13:35:29.859]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:29.859]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:29.859]                 }
[13:35:29.859]                 ...future.workdir <- getwd()
[13:35:29.859]             }
[13:35:29.859]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:29.859]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:29.859]         }
[13:35:29.859]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:29.859]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:29.859]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:29.859]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:29.859]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:29.859]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:29.859]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:29.859]             base::names(...future.oldOptions))
[13:35:29.859]     }
[13:35:29.859]     if (FALSE) {
[13:35:29.859]     }
[13:35:29.859]     else {
[13:35:29.859]         if (FALSE) {
[13:35:29.859]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:29.859]                 open = "w")
[13:35:29.859]         }
[13:35:29.859]         else {
[13:35:29.859]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:29.859]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:29.859]         }
[13:35:29.859]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:29.859]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:29.859]             base::sink(type = "output", split = FALSE)
[13:35:29.859]             base::close(...future.stdout)
[13:35:29.859]         }, add = TRUE)
[13:35:29.859]     }
[13:35:29.859]     ...future.frame <- base::sys.nframe()
[13:35:29.859]     ...future.conditions <- base::list()
[13:35:29.859]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:29.859]     if (FALSE) {
[13:35:29.859]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:29.859]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:29.859]     }
[13:35:29.859]     ...future.result <- base::tryCatch({
[13:35:29.859]         base::withCallingHandlers({
[13:35:29.859]             ...future.value <- base::withVisible(base::local({
[13:35:29.859]                 withCallingHandlers({
[13:35:29.859]                   {
[13:35:29.859]                     do.call(function(...) {
[13:35:29.859]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:29.859]                       if (!identical(...future.globals.maxSize.org, 
[13:35:29.859]                         ...future.globals.maxSize)) {
[13:35:29.859]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:29.859]                         on.exit(options(oopts), add = TRUE)
[13:35:29.859]                       }
[13:35:29.859]                       {
[13:35:29.859]                         lapply(seq_along(...future.elements_ii), 
[13:35:29.859]                           FUN = function(jj) {
[13:35:29.859]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:29.859]                             ...future.FUN(...future.X_jj, ...)
[13:35:29.859]                           })
[13:35:29.859]                       }
[13:35:29.859]                     }, args = future.call.arguments)
[13:35:29.859]                   }
[13:35:29.859]                 }, immediateCondition = function(cond) {
[13:35:29.859]                   save_rds <- function (object, pathname, ...) 
[13:35:29.859]                   {
[13:35:29.859]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:29.859]                     if (file_test("-f", pathname_tmp)) {
[13:35:29.859]                       fi_tmp <- file.info(pathname_tmp)
[13:35:29.859]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:29.859]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:29.859]                         fi_tmp[["mtime"]])
[13:35:29.859]                     }
[13:35:29.859]                     tryCatch({
[13:35:29.859]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:29.859]                     }, error = function(ex) {
[13:35:29.859]                       msg <- conditionMessage(ex)
[13:35:29.859]                       fi_tmp <- file.info(pathname_tmp)
[13:35:29.859]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:29.859]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:29.859]                         fi_tmp[["mtime"]], msg)
[13:35:29.859]                       ex$message <- msg
[13:35:29.859]                       stop(ex)
[13:35:29.859]                     })
[13:35:29.859]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:29.859]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:29.859]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:29.859]                       fi_tmp <- file.info(pathname_tmp)
[13:35:29.859]                       fi <- file.info(pathname)
[13:35:29.859]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:29.859]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:29.859]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:29.859]                         fi[["size"]], fi[["mtime"]])
[13:35:29.859]                       stop(msg)
[13:35:29.859]                     }
[13:35:29.859]                     invisible(pathname)
[13:35:29.859]                   }
[13:35:29.859]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:29.859]                     rootPath = tempdir()) 
[13:35:29.859]                   {
[13:35:29.859]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:29.859]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:29.859]                       tmpdir = path, fileext = ".rds")
[13:35:29.859]                     save_rds(obj, file)
[13:35:29.859]                   }
[13:35:29.859]                   saveImmediateCondition(cond, path = "/tmp/RtmpghgvGN/.future/immediateConditions")
[13:35:29.859]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:29.859]                   {
[13:35:29.859]                     inherits <- base::inherits
[13:35:29.859]                     invokeRestart <- base::invokeRestart
[13:35:29.859]                     is.null <- base::is.null
[13:35:29.859]                     muffled <- FALSE
[13:35:29.859]                     if (inherits(cond, "message")) {
[13:35:29.859]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:29.859]                       if (muffled) 
[13:35:29.859]                         invokeRestart("muffleMessage")
[13:35:29.859]                     }
[13:35:29.859]                     else if (inherits(cond, "warning")) {
[13:35:29.859]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:29.859]                       if (muffled) 
[13:35:29.859]                         invokeRestart("muffleWarning")
[13:35:29.859]                     }
[13:35:29.859]                     else if (inherits(cond, "condition")) {
[13:35:29.859]                       if (!is.null(pattern)) {
[13:35:29.859]                         computeRestarts <- base::computeRestarts
[13:35:29.859]                         grepl <- base::grepl
[13:35:29.859]                         restarts <- computeRestarts(cond)
[13:35:29.859]                         for (restart in restarts) {
[13:35:29.859]                           name <- restart$name
[13:35:29.859]                           if (is.null(name)) 
[13:35:29.859]                             next
[13:35:29.859]                           if (!grepl(pattern, name)) 
[13:35:29.859]                             next
[13:35:29.859]                           invokeRestart(restart)
[13:35:29.859]                           muffled <- TRUE
[13:35:29.859]                           break
[13:35:29.859]                         }
[13:35:29.859]                       }
[13:35:29.859]                     }
[13:35:29.859]                     invisible(muffled)
[13:35:29.859]                   }
[13:35:29.859]                   muffleCondition(cond)
[13:35:29.859]                 })
[13:35:29.859]             }))
[13:35:29.859]             future::FutureResult(value = ...future.value$value, 
[13:35:29.859]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:29.859]                   ...future.rng), globalenv = if (FALSE) 
[13:35:29.859]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:29.859]                     ...future.globalenv.names))
[13:35:29.859]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:29.859]         }, condition = base::local({
[13:35:29.859]             c <- base::c
[13:35:29.859]             inherits <- base::inherits
[13:35:29.859]             invokeRestart <- base::invokeRestart
[13:35:29.859]             length <- base::length
[13:35:29.859]             list <- base::list
[13:35:29.859]             seq.int <- base::seq.int
[13:35:29.859]             signalCondition <- base::signalCondition
[13:35:29.859]             sys.calls <- base::sys.calls
[13:35:29.859]             `[[` <- base::`[[`
[13:35:29.859]             `+` <- base::`+`
[13:35:29.859]             `<<-` <- base::`<<-`
[13:35:29.859]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:29.859]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:29.859]                   3L)]
[13:35:29.859]             }
[13:35:29.859]             function(cond) {
[13:35:29.859]                 is_error <- inherits(cond, "error")
[13:35:29.859]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:29.859]                   NULL)
[13:35:29.859]                 if (is_error) {
[13:35:29.859]                   sessionInformation <- function() {
[13:35:29.859]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:29.859]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:29.859]                       search = base::search(), system = base::Sys.info())
[13:35:29.859]                   }
[13:35:29.859]                   ...future.conditions[[length(...future.conditions) + 
[13:35:29.859]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:29.859]                     cond$call), session = sessionInformation(), 
[13:35:29.859]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:29.859]                   signalCondition(cond)
[13:35:29.859]                 }
[13:35:29.859]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:29.859]                 "immediateCondition"))) {
[13:35:29.859]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:29.859]                   ...future.conditions[[length(...future.conditions) + 
[13:35:29.859]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:29.859]                   if (TRUE && !signal) {
[13:35:29.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:29.859]                     {
[13:35:29.859]                       inherits <- base::inherits
[13:35:29.859]                       invokeRestart <- base::invokeRestart
[13:35:29.859]                       is.null <- base::is.null
[13:35:29.859]                       muffled <- FALSE
[13:35:29.859]                       if (inherits(cond, "message")) {
[13:35:29.859]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:29.859]                         if (muffled) 
[13:35:29.859]                           invokeRestart("muffleMessage")
[13:35:29.859]                       }
[13:35:29.859]                       else if (inherits(cond, "warning")) {
[13:35:29.859]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:29.859]                         if (muffled) 
[13:35:29.859]                           invokeRestart("muffleWarning")
[13:35:29.859]                       }
[13:35:29.859]                       else if (inherits(cond, "condition")) {
[13:35:29.859]                         if (!is.null(pattern)) {
[13:35:29.859]                           computeRestarts <- base::computeRestarts
[13:35:29.859]                           grepl <- base::grepl
[13:35:29.859]                           restarts <- computeRestarts(cond)
[13:35:29.859]                           for (restart in restarts) {
[13:35:29.859]                             name <- restart$name
[13:35:29.859]                             if (is.null(name)) 
[13:35:29.859]                               next
[13:35:29.859]                             if (!grepl(pattern, name)) 
[13:35:29.859]                               next
[13:35:29.859]                             invokeRestart(restart)
[13:35:29.859]                             muffled <- TRUE
[13:35:29.859]                             break
[13:35:29.859]                           }
[13:35:29.859]                         }
[13:35:29.859]                       }
[13:35:29.859]                       invisible(muffled)
[13:35:29.859]                     }
[13:35:29.859]                     muffleCondition(cond, pattern = "^muffle")
[13:35:29.859]                   }
[13:35:29.859]                 }
[13:35:29.859]                 else {
[13:35:29.859]                   if (TRUE) {
[13:35:29.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:29.859]                     {
[13:35:29.859]                       inherits <- base::inherits
[13:35:29.859]                       invokeRestart <- base::invokeRestart
[13:35:29.859]                       is.null <- base::is.null
[13:35:29.859]                       muffled <- FALSE
[13:35:29.859]                       if (inherits(cond, "message")) {
[13:35:29.859]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:29.859]                         if (muffled) 
[13:35:29.859]                           invokeRestart("muffleMessage")
[13:35:29.859]                       }
[13:35:29.859]                       else if (inherits(cond, "warning")) {
[13:35:29.859]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:29.859]                         if (muffled) 
[13:35:29.859]                           invokeRestart("muffleWarning")
[13:35:29.859]                       }
[13:35:29.859]                       else if (inherits(cond, "condition")) {
[13:35:29.859]                         if (!is.null(pattern)) {
[13:35:29.859]                           computeRestarts <- base::computeRestarts
[13:35:29.859]                           grepl <- base::grepl
[13:35:29.859]                           restarts <- computeRestarts(cond)
[13:35:29.859]                           for (restart in restarts) {
[13:35:29.859]                             name <- restart$name
[13:35:29.859]                             if (is.null(name)) 
[13:35:29.859]                               next
[13:35:29.859]                             if (!grepl(pattern, name)) 
[13:35:29.859]                               next
[13:35:29.859]                             invokeRestart(restart)
[13:35:29.859]                             muffled <- TRUE
[13:35:29.859]                             break
[13:35:29.859]                           }
[13:35:29.859]                         }
[13:35:29.859]                       }
[13:35:29.859]                       invisible(muffled)
[13:35:29.859]                     }
[13:35:29.859]                     muffleCondition(cond, pattern = "^muffle")
[13:35:29.859]                   }
[13:35:29.859]                 }
[13:35:29.859]             }
[13:35:29.859]         }))
[13:35:29.859]     }, error = function(ex) {
[13:35:29.859]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:29.859]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:29.859]                 ...future.rng), started = ...future.startTime, 
[13:35:29.859]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:29.859]             version = "1.8"), class = "FutureResult")
[13:35:29.859]     }, finally = {
[13:35:29.859]         if (!identical(...future.workdir, getwd())) 
[13:35:29.859]             setwd(...future.workdir)
[13:35:29.859]         {
[13:35:29.859]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:29.859]                 ...future.oldOptions$nwarnings <- NULL
[13:35:29.859]             }
[13:35:29.859]             base::options(...future.oldOptions)
[13:35:29.859]             if (.Platform$OS.type == "windows") {
[13:35:29.859]                 old_names <- names(...future.oldEnvVars)
[13:35:29.859]                 envs <- base::Sys.getenv()
[13:35:29.859]                 names <- names(envs)
[13:35:29.859]                 common <- intersect(names, old_names)
[13:35:29.859]                 added <- setdiff(names, old_names)
[13:35:29.859]                 removed <- setdiff(old_names, names)
[13:35:29.859]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:29.859]                   envs[common]]
[13:35:29.859]                 NAMES <- toupper(changed)
[13:35:29.859]                 args <- list()
[13:35:29.859]                 for (kk in seq_along(NAMES)) {
[13:35:29.859]                   name <- changed[[kk]]
[13:35:29.859]                   NAME <- NAMES[[kk]]
[13:35:29.859]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:29.859]                     next
[13:35:29.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:29.859]                 }
[13:35:29.859]                 NAMES <- toupper(added)
[13:35:29.859]                 for (kk in seq_along(NAMES)) {
[13:35:29.859]                   name <- added[[kk]]
[13:35:29.859]                   NAME <- NAMES[[kk]]
[13:35:29.859]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:29.859]                     next
[13:35:29.859]                   args[[name]] <- ""
[13:35:29.859]                 }
[13:35:29.859]                 NAMES <- toupper(removed)
[13:35:29.859]                 for (kk in seq_along(NAMES)) {
[13:35:29.859]                   name <- removed[[kk]]
[13:35:29.859]                   NAME <- NAMES[[kk]]
[13:35:29.859]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:29.859]                     next
[13:35:29.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:29.859]                 }
[13:35:29.859]                 if (length(args) > 0) 
[13:35:29.859]                   base::do.call(base::Sys.setenv, args = args)
[13:35:29.859]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:29.859]             }
[13:35:29.859]             else {
[13:35:29.859]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:29.859]             }
[13:35:29.859]             {
[13:35:29.859]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:29.859]                   0L) {
[13:35:29.859]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:29.859]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:29.859]                   base::options(opts)
[13:35:29.859]                 }
[13:35:29.859]                 {
[13:35:29.859]                   {
[13:35:29.859]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:29.859]                     NULL
[13:35:29.859]                   }
[13:35:29.859]                   options(future.plan = NULL)
[13:35:29.859]                   if (is.na(NA_character_)) 
[13:35:29.859]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:29.859]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:29.859]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:29.859]                     .init = FALSE)
[13:35:29.859]                 }
[13:35:29.859]             }
[13:35:29.859]         }
[13:35:29.859]     })
[13:35:29.859]     if (TRUE) {
[13:35:29.859]         base::sink(type = "output", split = FALSE)
[13:35:29.859]         if (FALSE) {
[13:35:29.859]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:29.859]         }
[13:35:29.859]         else {
[13:35:29.859]             ...future.result["stdout"] <- base::list(NULL)
[13:35:29.859]         }
[13:35:29.859]         base::close(...future.stdout)
[13:35:29.859]         ...future.stdout <- NULL
[13:35:29.859]     }
[13:35:29.859]     ...future.result$conditions <- ...future.conditions
[13:35:29.859]     ...future.result$finished <- base::Sys.time()
[13:35:29.859]     ...future.result
[13:35:29.859] }
[13:35:29.862] assign_globals() ...
[13:35:29.862] List of 5
[13:35:29.862]  $ ...future.FUN            :function (x)  
[13:35:29.862]  $ future.call.arguments    : list()
[13:35:29.862]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:29.862]  $ ...future.elements_ii    :List of 1
[13:35:29.862]   ..$ : int 0
[13:35:29.862]  $ ...future.seeds_ii       : NULL
[13:35:29.862]  $ ...future.globals.maxSize: NULL
[13:35:29.862]  - attr(*, "where")=List of 5
[13:35:29.862]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:29.862]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:29.862]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:29.862]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:29.862]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:29.862]  - attr(*, "resolved")= logi FALSE
[13:35:29.862]  - attr(*, "total_size")= num 4720
[13:35:29.862]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:29.862]  - attr(*, "already-done")= logi TRUE
[13:35:29.869] - reassign environment for ‘...future.FUN’
[13:35:29.869] - copied ‘...future.FUN’ to environment
[13:35:29.870] - copied ‘future.call.arguments’ to environment
[13:35:29.870] - copied ‘...future.elements_ii’ to environment
[13:35:29.870] - copied ‘...future.seeds_ii’ to environment
[13:35:29.870] - copied ‘...future.globals.maxSize’ to environment
[13:35:29.870] assign_globals() ... done
[13:35:29.870] requestCore(): workers = 2
[13:35:29.880] MulticoreFuture started
[13:35:29.880] - Launch lazy future ... done
[13:35:29.881] plan(): Setting new future strategy stack:
[13:35:29.881] run() for ‘MulticoreFuture’ ... done
[13:35:29.881] Created future:
[13:35:29.881] List of future strategies:
[13:35:29.881] 1. sequential:
[13:35:29.881]    - args: function (..., envir = parent.frame())
[13:35:29.881]    - tweaked: FALSE
[13:35:29.881]    - call: NULL
[13:35:29.883] plan(): nbrOfWorkers() = 1
[13:35:29.885] plan(): Setting new future strategy stack:
[13:35:29.885] List of future strategies:
[13:35:29.885] 1. multicore:
[13:35:29.885]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:29.885]    - tweaked: FALSE
[13:35:29.885]    - call: plan(strategy)
[13:35:29.891] plan(): nbrOfWorkers() = 2
[13:35:29.882] MulticoreFuture:
[13:35:29.882] Label: ‘future_lapply-2’
[13:35:29.882] Expression:
[13:35:29.882] {
[13:35:29.882]     do.call(function(...) {
[13:35:29.882]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:29.882]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:29.882]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:29.882]             on.exit(options(oopts), add = TRUE)
[13:35:29.882]         }
[13:35:29.882]         {
[13:35:29.882]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:29.882]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:29.882]                 ...future.FUN(...future.X_jj, ...)
[13:35:29.882]             })
[13:35:29.882]         }
[13:35:29.882]     }, args = future.call.arguments)
[13:35:29.882] }
[13:35:29.882] Lazy evaluation: FALSE
[13:35:29.882] Asynchronous evaluation: TRUE
[13:35:29.882] Local evaluation: TRUE
[13:35:29.882] Environment: R_GlobalEnv
[13:35:29.882] Capture standard output: FALSE
[13:35:29.882] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:29.882] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:29.882] Packages: <none>
[13:35:29.882] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:29.882] Resolved: TRUE
[13:35:29.882] Value: <not collected>
[13:35:29.882] Conditions captured: <none>
[13:35:29.882] Early signaling: FALSE
[13:35:29.882] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:29.882] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:29.892] Chunk #2 of 2 ... DONE
[13:35:29.892] Launching 2 futures (chunks) ... DONE
[13:35:29.892] Resolving 2 futures (chunks) ...
[13:35:29.892] resolve() on list ...
[13:35:29.893]  recursive: 0
[13:35:29.893]  length: 2
[13:35:29.893] 
[13:35:29.904] Future #2
[13:35:29.905] result() for MulticoreFuture ...
[13:35:29.907] result() for MulticoreFuture ...
[13:35:29.907] result() for MulticoreFuture ... done
[13:35:29.907] result() for MulticoreFuture ... done
[13:35:29.907] result() for MulticoreFuture ...
[13:35:29.908] result() for MulticoreFuture ... done
[13:35:29.908] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:35:29.908] - nx: 2
[13:35:29.908] - relay: TRUE
[13:35:29.908] - stdout: TRUE
[13:35:29.908] - signal: TRUE
[13:35:29.908] - resignal: FALSE
[13:35:29.908] - force: TRUE
[13:35:29.909] - relayed: [n=2] FALSE, FALSE
[13:35:29.909] - queued futures: [n=2] FALSE, FALSE
[13:35:29.909]  - until=1
[13:35:29.909]  - relaying element #1
[13:35:29.909] - relayed: [n=2] FALSE, FALSE
[13:35:29.909] - queued futures: [n=2] FALSE, TRUE
[13:35:29.909] signalConditionsASAP(NULL, pos=2) ... done
[13:35:29.910]  length: 1 (resolved future 2)
[13:35:30.329] plan(): Setting new future strategy stack:
[13:35:30.329] List of future strategies:
[13:35:30.329] 1. multicore:
[13:35:30.329]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:30.329]    - tweaked: FALSE
[13:35:30.329]    - call: plan(strategy)
[13:35:30.334] plan(): nbrOfWorkers() = 2
[13:35:30.334] Future #1
[13:35:30.335] result() for MulticoreFuture ...
[13:35:30.335] result() for MulticoreFuture ...
[13:35:30.336] result() for MulticoreFuture ... done
[13:35:30.336] result() for MulticoreFuture ... done
[13:35:30.336] result() for MulticoreFuture ...
[13:35:30.336] result() for MulticoreFuture ... done
[13:35:30.336] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:35:30.336] - nx: 2
[13:35:30.336] - relay: TRUE
[13:35:30.336] - stdout: TRUE
[13:35:30.336] - signal: TRUE
[13:35:30.337] - resignal: FALSE
[13:35:30.337] - force: TRUE
[13:35:30.337] - relayed: [n=2] FALSE, FALSE
[13:35:30.337] - queued futures: [n=2] FALSE, TRUE
[13:35:30.337]  - until=1
[13:35:30.337]  - relaying element #1
[13:35:30.337] result() for MulticoreFuture ...
[13:35:30.337] result() for MulticoreFuture ... done
[13:35:30.337] result() for MulticoreFuture ...
[13:35:30.338] result() for MulticoreFuture ... done
[13:35:30.338] result() for MulticoreFuture ...
[13:35:30.338] result() for MulticoreFuture ... done
[13:35:30.338] result() for MulticoreFuture ...
[13:35:30.338] result() for MulticoreFuture ... done
[13:35:30.338] - relayed: [n=2] TRUE, FALSE
[13:35:30.338] - queued futures: [n=2] TRUE, TRUE
[13:35:30.338] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:35:30.339]  length: 0 (resolved future 1)
[13:35:30.339] Relaying remaining futures
[13:35:30.339] signalConditionsASAP(NULL, pos=0) ...
[13:35:30.339] - nx: 2
[13:35:30.339] - relay: TRUE
[13:35:30.339] - stdout: TRUE
[13:35:30.339] - signal: TRUE
[13:35:30.339] - resignal: FALSE
[13:35:30.339] - force: TRUE
[13:35:30.339] - relayed: [n=2] TRUE, FALSE
[13:35:30.340] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:30.340]  - relaying element #2
[13:35:30.340] result() for MulticoreFuture ...
[13:35:30.340] result() for MulticoreFuture ... done
[13:35:30.340] result() for MulticoreFuture ...
[13:35:30.340] result() for MulticoreFuture ... done
[13:35:30.340] result() for MulticoreFuture ...
[13:35:30.340] result() for MulticoreFuture ... done
[13:35:30.341] result() for MulticoreFuture ...
[13:35:30.341] result() for MulticoreFuture ... done
[13:35:30.341] - relayed: [n=2] TRUE, TRUE
[13:35:30.341] - queued futures: [n=2] TRUE, TRUE
[13:35:30.341] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[13:35:30.341] resolve() on list ... DONE
[13:35:30.341] result() for MulticoreFuture ...
[13:35:30.341] result() for MulticoreFuture ... done
[13:35:30.341] result() for MulticoreFuture ...
[13:35:30.342] result() for MulticoreFuture ... done
[13:35:30.342] result() for MulticoreFuture ...
[13:35:30.342] result() for MulticoreFuture ... done
[13:35:30.342] result() for MulticoreFuture ...
[13:35:30.342] result() for MulticoreFuture ... done
[13:35:30.342]  - Number of value chunks collected: 2
[13:35:30.342] Resolving 2 futures (chunks) ... DONE
[13:35:30.342] Reducing values from 2 chunks ...
[13:35:30.343]  - Number of values collected after concatenation: 2
[13:35:30.343]  - Number of values expected: 2
[13:35:30.343] Reducing values from 2 chunks ... DONE
[13:35:30.343] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[13:35:30.343] future_lapply() ...
[13:35:30.348] Number of chunks: 2
[13:35:30.348] getGlobalsAndPackagesXApply() ...
[13:35:30.349]  - future.globals: TRUE
[13:35:30.349] getGlobalsAndPackages() ...
[13:35:30.349] Searching for globals...
[13:35:30.350] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:35:30.351] Searching for globals ... DONE
[13:35:30.351] Resolving globals: FALSE
[13:35:30.351] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:35:30.352] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:35:30.352] - globals: [1] ‘FUN’
[13:35:30.352] 
[13:35:30.352] getGlobalsAndPackages() ... DONE
[13:35:30.352]  - globals found/used: [n=1] ‘FUN’
[13:35:30.352]  - needed namespaces: [n=0] 
[13:35:30.352] Finding globals ... DONE
[13:35:30.352]  - use_args: TRUE
[13:35:30.352]  - Getting '...' globals ...
[13:35:30.353] resolve() on list ...
[13:35:30.353]  recursive: 0
[13:35:30.353]  length: 1
[13:35:30.353]  elements: ‘...’
[13:35:30.353]  length: 0 (resolved future 1)
[13:35:30.353] resolve() on list ... DONE
[13:35:30.353]    - '...' content: [n=0] 
[13:35:30.354] List of 1
[13:35:30.354]  $ ...: list()
[13:35:30.354]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:30.354]  - attr(*, "where")=List of 1
[13:35:30.354]   ..$ ...:<environment: 0x558d38433fd0> 
[13:35:30.354]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:30.354]  - attr(*, "resolved")= logi TRUE
[13:35:30.354]  - attr(*, "total_size")= num NA
[13:35:30.359]  - Getting '...' globals ... DONE
[13:35:30.359] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:35:30.359] List of 2
[13:35:30.359]  $ ...future.FUN:function (x)  
[13:35:30.359]  $ ...          : list()
[13:35:30.359]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:30.359]  - attr(*, "where")=List of 2
[13:35:30.359]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:30.359]   ..$ ...          :<environment: 0x558d38433fd0> 
[13:35:30.359]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:30.359]  - attr(*, "resolved")= logi FALSE
[13:35:30.359]  - attr(*, "total_size")= num 4720
[13:35:30.362] Packages to be attached in all futures: [n=0] 
[13:35:30.362] getGlobalsAndPackagesXApply() ... DONE
[13:35:30.362] Number of futures (= number of chunks): 2
[13:35:30.362] Launching 2 futures (chunks) ...
[13:35:30.362] Chunk #1 of 2 ...
[13:35:30.362]  - Finding globals in 'X' for chunk #1 ...
[13:35:30.362] getGlobalsAndPackages() ...
[13:35:30.363] Searching for globals...
[13:35:30.363] 
[13:35:30.363] Searching for globals ... DONE
[13:35:30.363] - globals: [0] <none>
[13:35:30.363] getGlobalsAndPackages() ... DONE
[13:35:30.363]    + additional globals found: [n=0] 
[13:35:30.363]    + additional namespaces needed: [n=0] 
[13:35:30.363]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:30.363]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:30.363]  - seeds: <none>
[13:35:30.364]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:30.364] getGlobalsAndPackages() ...
[13:35:30.364] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:30.364] Resolving globals: FALSE
[13:35:30.364] Tweak future expression to call with '...' arguments ...
[13:35:30.364] {
[13:35:30.364]     do.call(function(...) {
[13:35:30.364]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:30.364]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:30.364]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:30.364]             on.exit(options(oopts), add = TRUE)
[13:35:30.364]         }
[13:35:30.364]         {
[13:35:30.364]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:30.364]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:30.364]                 ...future.FUN(...future.X_jj, ...)
[13:35:30.364]             })
[13:35:30.364]         }
[13:35:30.364]     }, args = future.call.arguments)
[13:35:30.364] }
[13:35:30.364] Tweak future expression to call with '...' arguments ... DONE
[13:35:30.365] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:30.365] 
[13:35:30.365] getGlobalsAndPackages() ... DONE
[13:35:30.365] run() for ‘Future’ ...
[13:35:30.365] - state: ‘created’
[13:35:30.365] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:30.369] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:30.369] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:30.369]   - Field: ‘label’
[13:35:30.369]   - Field: ‘local’
[13:35:30.369]   - Field: ‘owner’
[13:35:30.369]   - Field: ‘envir’
[13:35:30.370]   - Field: ‘workers’
[13:35:30.370]   - Field: ‘packages’
[13:35:30.370]   - Field: ‘gc’
[13:35:30.370]   - Field: ‘job’
[13:35:30.370]   - Field: ‘conditions’
[13:35:30.370]   - Field: ‘expr’
[13:35:30.370]   - Field: ‘uuid’
[13:35:30.370]   - Field: ‘seed’
[13:35:30.370]   - Field: ‘version’
[13:35:30.370]   - Field: ‘result’
[13:35:30.371]   - Field: ‘asynchronous’
[13:35:30.371]   - Field: ‘calls’
[13:35:30.371]   - Field: ‘globals’
[13:35:30.371]   - Field: ‘stdout’
[13:35:30.371]   - Field: ‘earlySignal’
[13:35:30.371]   - Field: ‘lazy’
[13:35:30.371]   - Field: ‘state’
[13:35:30.371] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:30.371] - Launch lazy future ...
[13:35:30.372] Packages needed by the future expression (n = 0): <none>
[13:35:30.372] Packages needed by future strategies (n = 0): <none>
[13:35:30.372] {
[13:35:30.372]     {
[13:35:30.372]         {
[13:35:30.372]             ...future.startTime <- base::Sys.time()
[13:35:30.372]             {
[13:35:30.372]                 {
[13:35:30.372]                   {
[13:35:30.372]                     {
[13:35:30.372]                       base::local({
[13:35:30.372]                         has_future <- base::requireNamespace("future", 
[13:35:30.372]                           quietly = TRUE)
[13:35:30.372]                         if (has_future) {
[13:35:30.372]                           ns <- base::getNamespace("future")
[13:35:30.372]                           version <- ns[[".package"]][["version"]]
[13:35:30.372]                           if (is.null(version)) 
[13:35:30.372]                             version <- utils::packageVersion("future")
[13:35:30.372]                         }
[13:35:30.372]                         else {
[13:35:30.372]                           version <- NULL
[13:35:30.372]                         }
[13:35:30.372]                         if (!has_future || version < "1.8.0") {
[13:35:30.372]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:30.372]                             "", base::R.version$version.string), 
[13:35:30.372]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:30.372]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:30.372]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:30.372]                               "release", "version")], collapse = " "), 
[13:35:30.372]                             hostname = base::Sys.info()[["nodename"]])
[13:35:30.372]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:30.372]                             info)
[13:35:30.372]                           info <- base::paste(info, collapse = "; ")
[13:35:30.372]                           if (!has_future) {
[13:35:30.372]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:30.372]                               info)
[13:35:30.372]                           }
[13:35:30.372]                           else {
[13:35:30.372]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:30.372]                               info, version)
[13:35:30.372]                           }
[13:35:30.372]                           base::stop(msg)
[13:35:30.372]                         }
[13:35:30.372]                       })
[13:35:30.372]                     }
[13:35:30.372]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:30.372]                     base::options(mc.cores = 1L)
[13:35:30.372]                   }
[13:35:30.372]                   ...future.strategy.old <- future::plan("list")
[13:35:30.372]                   options(future.plan = NULL)
[13:35:30.372]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:30.372]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:30.372]                 }
[13:35:30.372]                 ...future.workdir <- getwd()
[13:35:30.372]             }
[13:35:30.372]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:30.372]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:30.372]         }
[13:35:30.372]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:30.372]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:30.372]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:30.372]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:30.372]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:30.372]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:30.372]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:30.372]             base::names(...future.oldOptions))
[13:35:30.372]     }
[13:35:30.372]     if (FALSE) {
[13:35:30.372]     }
[13:35:30.372]     else {
[13:35:30.372]         if (TRUE) {
[13:35:30.372]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:30.372]                 open = "w")
[13:35:30.372]         }
[13:35:30.372]         else {
[13:35:30.372]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:30.372]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:30.372]         }
[13:35:30.372]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:30.372]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:30.372]             base::sink(type = "output", split = FALSE)
[13:35:30.372]             base::close(...future.stdout)
[13:35:30.372]         }, add = TRUE)
[13:35:30.372]     }
[13:35:30.372]     ...future.frame <- base::sys.nframe()
[13:35:30.372]     ...future.conditions <- base::list()
[13:35:30.372]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:30.372]     if (FALSE) {
[13:35:30.372]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:30.372]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:30.372]     }
[13:35:30.372]     ...future.result <- base::tryCatch({
[13:35:30.372]         base::withCallingHandlers({
[13:35:30.372]             ...future.value <- base::withVisible(base::local({
[13:35:30.372]                 withCallingHandlers({
[13:35:30.372]                   {
[13:35:30.372]                     do.call(function(...) {
[13:35:30.372]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:30.372]                       if (!identical(...future.globals.maxSize.org, 
[13:35:30.372]                         ...future.globals.maxSize)) {
[13:35:30.372]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:30.372]                         on.exit(options(oopts), add = TRUE)
[13:35:30.372]                       }
[13:35:30.372]                       {
[13:35:30.372]                         lapply(seq_along(...future.elements_ii), 
[13:35:30.372]                           FUN = function(jj) {
[13:35:30.372]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:30.372]                             ...future.FUN(...future.X_jj, ...)
[13:35:30.372]                           })
[13:35:30.372]                       }
[13:35:30.372]                     }, args = future.call.arguments)
[13:35:30.372]                   }
[13:35:30.372]                 }, immediateCondition = function(cond) {
[13:35:30.372]                   save_rds <- function (object, pathname, ...) 
[13:35:30.372]                   {
[13:35:30.372]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:30.372]                     if (file_test("-f", pathname_tmp)) {
[13:35:30.372]                       fi_tmp <- file.info(pathname_tmp)
[13:35:30.372]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:30.372]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:30.372]                         fi_tmp[["mtime"]])
[13:35:30.372]                     }
[13:35:30.372]                     tryCatch({
[13:35:30.372]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:30.372]                     }, error = function(ex) {
[13:35:30.372]                       msg <- conditionMessage(ex)
[13:35:30.372]                       fi_tmp <- file.info(pathname_tmp)
[13:35:30.372]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:30.372]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:30.372]                         fi_tmp[["mtime"]], msg)
[13:35:30.372]                       ex$message <- msg
[13:35:30.372]                       stop(ex)
[13:35:30.372]                     })
[13:35:30.372]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:30.372]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:30.372]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:30.372]                       fi_tmp <- file.info(pathname_tmp)
[13:35:30.372]                       fi <- file.info(pathname)
[13:35:30.372]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:30.372]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:30.372]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:30.372]                         fi[["size"]], fi[["mtime"]])
[13:35:30.372]                       stop(msg)
[13:35:30.372]                     }
[13:35:30.372]                     invisible(pathname)
[13:35:30.372]                   }
[13:35:30.372]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:30.372]                     rootPath = tempdir()) 
[13:35:30.372]                   {
[13:35:30.372]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:30.372]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:30.372]                       tmpdir = path, fileext = ".rds")
[13:35:30.372]                     save_rds(obj, file)
[13:35:30.372]                   }
[13:35:30.372]                   saveImmediateCondition(cond, path = "/tmp/RtmpghgvGN/.future/immediateConditions")
[13:35:30.372]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:30.372]                   {
[13:35:30.372]                     inherits <- base::inherits
[13:35:30.372]                     invokeRestart <- base::invokeRestart
[13:35:30.372]                     is.null <- base::is.null
[13:35:30.372]                     muffled <- FALSE
[13:35:30.372]                     if (inherits(cond, "message")) {
[13:35:30.372]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:30.372]                       if (muffled) 
[13:35:30.372]                         invokeRestart("muffleMessage")
[13:35:30.372]                     }
[13:35:30.372]                     else if (inherits(cond, "warning")) {
[13:35:30.372]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:30.372]                       if (muffled) 
[13:35:30.372]                         invokeRestart("muffleWarning")
[13:35:30.372]                     }
[13:35:30.372]                     else if (inherits(cond, "condition")) {
[13:35:30.372]                       if (!is.null(pattern)) {
[13:35:30.372]                         computeRestarts <- base::computeRestarts
[13:35:30.372]                         grepl <- base::grepl
[13:35:30.372]                         restarts <- computeRestarts(cond)
[13:35:30.372]                         for (restart in restarts) {
[13:35:30.372]                           name <- restart$name
[13:35:30.372]                           if (is.null(name)) 
[13:35:30.372]                             next
[13:35:30.372]                           if (!grepl(pattern, name)) 
[13:35:30.372]                             next
[13:35:30.372]                           invokeRestart(restart)
[13:35:30.372]                           muffled <- TRUE
[13:35:30.372]                           break
[13:35:30.372]                         }
[13:35:30.372]                       }
[13:35:30.372]                     }
[13:35:30.372]                     invisible(muffled)
[13:35:30.372]                   }
[13:35:30.372]                   muffleCondition(cond)
[13:35:30.372]                 })
[13:35:30.372]             }))
[13:35:30.372]             future::FutureResult(value = ...future.value$value, 
[13:35:30.372]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:30.372]                   ...future.rng), globalenv = if (FALSE) 
[13:35:30.372]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:30.372]                     ...future.globalenv.names))
[13:35:30.372]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:30.372]         }, condition = base::local({
[13:35:30.372]             c <- base::c
[13:35:30.372]             inherits <- base::inherits
[13:35:30.372]             invokeRestart <- base::invokeRestart
[13:35:30.372]             length <- base::length
[13:35:30.372]             list <- base::list
[13:35:30.372]             seq.int <- base::seq.int
[13:35:30.372]             signalCondition <- base::signalCondition
[13:35:30.372]             sys.calls <- base::sys.calls
[13:35:30.372]             `[[` <- base::`[[`
[13:35:30.372]             `+` <- base::`+`
[13:35:30.372]             `<<-` <- base::`<<-`
[13:35:30.372]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:30.372]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:30.372]                   3L)]
[13:35:30.372]             }
[13:35:30.372]             function(cond) {
[13:35:30.372]                 is_error <- inherits(cond, "error")
[13:35:30.372]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:30.372]                   NULL)
[13:35:30.372]                 if (is_error) {
[13:35:30.372]                   sessionInformation <- function() {
[13:35:30.372]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:30.372]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:30.372]                       search = base::search(), system = base::Sys.info())
[13:35:30.372]                   }
[13:35:30.372]                   ...future.conditions[[length(...future.conditions) + 
[13:35:30.372]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:30.372]                     cond$call), session = sessionInformation(), 
[13:35:30.372]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:30.372]                   signalCondition(cond)
[13:35:30.372]                 }
[13:35:30.372]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:30.372]                 "immediateCondition"))) {
[13:35:30.372]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:30.372]                   ...future.conditions[[length(...future.conditions) + 
[13:35:30.372]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:30.372]                   if (TRUE && !signal) {
[13:35:30.372]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:30.372]                     {
[13:35:30.372]                       inherits <- base::inherits
[13:35:30.372]                       invokeRestart <- base::invokeRestart
[13:35:30.372]                       is.null <- base::is.null
[13:35:30.372]                       muffled <- FALSE
[13:35:30.372]                       if (inherits(cond, "message")) {
[13:35:30.372]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:30.372]                         if (muffled) 
[13:35:30.372]                           invokeRestart("muffleMessage")
[13:35:30.372]                       }
[13:35:30.372]                       else if (inherits(cond, "warning")) {
[13:35:30.372]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:30.372]                         if (muffled) 
[13:35:30.372]                           invokeRestart("muffleWarning")
[13:35:30.372]                       }
[13:35:30.372]                       else if (inherits(cond, "condition")) {
[13:35:30.372]                         if (!is.null(pattern)) {
[13:35:30.372]                           computeRestarts <- base::computeRestarts
[13:35:30.372]                           grepl <- base::grepl
[13:35:30.372]                           restarts <- computeRestarts(cond)
[13:35:30.372]                           for (restart in restarts) {
[13:35:30.372]                             name <- restart$name
[13:35:30.372]                             if (is.null(name)) 
[13:35:30.372]                               next
[13:35:30.372]                             if (!grepl(pattern, name)) 
[13:35:30.372]                               next
[13:35:30.372]                             invokeRestart(restart)
[13:35:30.372]                             muffled <- TRUE
[13:35:30.372]                             break
[13:35:30.372]                           }
[13:35:30.372]                         }
[13:35:30.372]                       }
[13:35:30.372]                       invisible(muffled)
[13:35:30.372]                     }
[13:35:30.372]                     muffleCondition(cond, pattern = "^muffle")
[13:35:30.372]                   }
[13:35:30.372]                 }
[13:35:30.372]                 else {
[13:35:30.372]                   if (TRUE) {
[13:35:30.372]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:30.372]                     {
[13:35:30.372]                       inherits <- base::inherits
[13:35:30.372]                       invokeRestart <- base::invokeRestart
[13:35:30.372]                       is.null <- base::is.null
[13:35:30.372]                       muffled <- FALSE
[13:35:30.372]                       if (inherits(cond, "message")) {
[13:35:30.372]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:30.372]                         if (muffled) 
[13:35:30.372]                           invokeRestart("muffleMessage")
[13:35:30.372]                       }
[13:35:30.372]                       else if (inherits(cond, "warning")) {
[13:35:30.372]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:30.372]                         if (muffled) 
[13:35:30.372]                           invokeRestart("muffleWarning")
[13:35:30.372]                       }
[13:35:30.372]                       else if (inherits(cond, "condition")) {
[13:35:30.372]                         if (!is.null(pattern)) {
[13:35:30.372]                           computeRestarts <- base::computeRestarts
[13:35:30.372]                           grepl <- base::grepl
[13:35:30.372]                           restarts <- computeRestarts(cond)
[13:35:30.372]                           for (restart in restarts) {
[13:35:30.372]                             name <- restart$name
[13:35:30.372]                             if (is.null(name)) 
[13:35:30.372]                               next
[13:35:30.372]                             if (!grepl(pattern, name)) 
[13:35:30.372]                               next
[13:35:30.372]                             invokeRestart(restart)
[13:35:30.372]                             muffled <- TRUE
[13:35:30.372]                             break
[13:35:30.372]                           }
[13:35:30.372]                         }
[13:35:30.372]                       }
[13:35:30.372]                       invisible(muffled)
[13:35:30.372]                     }
[13:35:30.372]                     muffleCondition(cond, pattern = "^muffle")
[13:35:30.372]                   }
[13:35:30.372]                 }
[13:35:30.372]             }
[13:35:30.372]         }))
[13:35:30.372]     }, error = function(ex) {
[13:35:30.372]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:30.372]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:30.372]                 ...future.rng), started = ...future.startTime, 
[13:35:30.372]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:30.372]             version = "1.8"), class = "FutureResult")
[13:35:30.372]     }, finally = {
[13:35:30.372]         if (!identical(...future.workdir, getwd())) 
[13:35:30.372]             setwd(...future.workdir)
[13:35:30.372]         {
[13:35:30.372]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:30.372]                 ...future.oldOptions$nwarnings <- NULL
[13:35:30.372]             }
[13:35:30.372]             base::options(...future.oldOptions)
[13:35:30.372]             if (.Platform$OS.type == "windows") {
[13:35:30.372]                 old_names <- names(...future.oldEnvVars)
[13:35:30.372]                 envs <- base::Sys.getenv()
[13:35:30.372]                 names <- names(envs)
[13:35:30.372]                 common <- intersect(names, old_names)
[13:35:30.372]                 added <- setdiff(names, old_names)
[13:35:30.372]                 removed <- setdiff(old_names, names)
[13:35:30.372]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:30.372]                   envs[common]]
[13:35:30.372]                 NAMES <- toupper(changed)
[13:35:30.372]                 args <- list()
[13:35:30.372]                 for (kk in seq_along(NAMES)) {
[13:35:30.372]                   name <- changed[[kk]]
[13:35:30.372]                   NAME <- NAMES[[kk]]
[13:35:30.372]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:30.372]                     next
[13:35:30.372]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:30.372]                 }
[13:35:30.372]                 NAMES <- toupper(added)
[13:35:30.372]                 for (kk in seq_along(NAMES)) {
[13:35:30.372]                   name <- added[[kk]]
[13:35:30.372]                   NAME <- NAMES[[kk]]
[13:35:30.372]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:30.372]                     next
[13:35:30.372]                   args[[name]] <- ""
[13:35:30.372]                 }
[13:35:30.372]                 NAMES <- toupper(removed)
[13:35:30.372]                 for (kk in seq_along(NAMES)) {
[13:35:30.372]                   name <- removed[[kk]]
[13:35:30.372]                   NAME <- NAMES[[kk]]
[13:35:30.372]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:30.372]                     next
[13:35:30.372]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:30.372]                 }
[13:35:30.372]                 if (length(args) > 0) 
[13:35:30.372]                   base::do.call(base::Sys.setenv, args = args)
[13:35:30.372]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:30.372]             }
[13:35:30.372]             else {
[13:35:30.372]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:30.372]             }
[13:35:30.372]             {
[13:35:30.372]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:30.372]                   0L) {
[13:35:30.372]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:30.372]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:30.372]                   base::options(opts)
[13:35:30.372]                 }
[13:35:30.372]                 {
[13:35:30.372]                   {
[13:35:30.372]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:30.372]                     NULL
[13:35:30.372]                   }
[13:35:30.372]                   options(future.plan = NULL)
[13:35:30.372]                   if (is.na(NA_character_)) 
[13:35:30.372]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:30.372]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:30.372]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:30.372]                     .init = FALSE)
[13:35:30.372]                 }
[13:35:30.372]             }
[13:35:30.372]         }
[13:35:30.372]     })
[13:35:30.372]     if (TRUE) {
[13:35:30.372]         base::sink(type = "output", split = FALSE)
[13:35:30.372]         if (TRUE) {
[13:35:30.372]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:30.372]         }
[13:35:30.372]         else {
[13:35:30.372]             ...future.result["stdout"] <- base::list(NULL)
[13:35:30.372]         }
[13:35:30.372]         base::close(...future.stdout)
[13:35:30.372]         ...future.stdout <- NULL
[13:35:30.372]     }
[13:35:30.372]     ...future.result$conditions <- ...future.conditions
[13:35:30.372]     ...future.result$finished <- base::Sys.time()
[13:35:30.372]     ...future.result
[13:35:30.372] }
[13:35:30.375] assign_globals() ...
[13:35:30.375] List of 5
[13:35:30.375]  $ ...future.FUN            :function (x)  
[13:35:30.375]  $ future.call.arguments    : list()
[13:35:30.375]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:30.375]  $ ...future.elements_ii    :List of 1
[13:35:30.375]   ..$ : int 1
[13:35:30.375]  $ ...future.seeds_ii       : NULL
[13:35:30.375]  $ ...future.globals.maxSize: NULL
[13:35:30.375]  - attr(*, "where")=List of 5
[13:35:30.375]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:30.375]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:30.375]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:30.375]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:30.375]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:30.375]  - attr(*, "resolved")= logi FALSE
[13:35:30.375]  - attr(*, "total_size")= num 4720
[13:35:30.375]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:30.375]  - attr(*, "already-done")= logi TRUE
[13:35:30.379] - reassign environment for ‘...future.FUN’
[13:35:30.379] - copied ‘...future.FUN’ to environment
[13:35:30.379] - copied ‘future.call.arguments’ to environment
[13:35:30.379] - copied ‘...future.elements_ii’ to environment
[13:35:30.380] - copied ‘...future.seeds_ii’ to environment
[13:35:30.380] - copied ‘...future.globals.maxSize’ to environment
[13:35:30.380] assign_globals() ... done
[13:35:30.380] requestCore(): workers = 2
[13:35:30.382] MulticoreFuture started
[13:35:30.382] - Launch lazy future ... done
[13:35:30.383] run() for ‘MulticoreFuture’ ... done
[13:35:30.383] Created future:
[13:35:30.383] plan(): Setting new future strategy stack:
[13:35:30.383] List of future strategies:
[13:35:30.383] 1. sequential:
[13:35:30.383]    - args: function (..., envir = parent.frame())
[13:35:30.383]    - tweaked: FALSE
[13:35:30.383]    - call: NULL
[13:35:30.384] plan(): nbrOfWorkers() = 1
[13:35:30.383] MulticoreFuture:
[13:35:30.383] Label: ‘future_lapply-1’
[13:35:30.383] Expression:
[13:35:30.383] {
[13:35:30.383]     do.call(function(...) {
[13:35:30.383]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:30.383]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:30.383]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:30.383]             on.exit(options(oopts), add = TRUE)
[13:35:30.383]         }
[13:35:30.383]         {
[13:35:30.383]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:30.383]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:30.383]                 ...future.FUN(...future.X_jj, ...)
[13:35:30.383]             })
[13:35:30.383]         }
[13:35:30.383]     }, args = future.call.arguments)
[13:35:30.383] }
[13:35:30.383] Lazy evaluation: FALSE
[13:35:30.383] Asynchronous evaluation: TRUE
[13:35:30.383] Local evaluation: TRUE
[13:35:30.383] Environment: R_GlobalEnv
[13:35:30.383] Capture standard output: TRUE
[13:35:30.383] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:30.383] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:30.383] Packages: <none>
[13:35:30.383] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:30.383] Resolved: FALSE
[13:35:30.383] Value: <not collected>
[13:35:30.383] Conditions captured: <none>
[13:35:30.383] Early signaling: FALSE
[13:35:30.383] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:30.383] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:30.400] Chunk #1 of 2 ... DONE
[13:35:30.400] Chunk #2 of 2 ...
[13:35:30.401]  - Finding globals in 'X' for chunk #2 ...
[13:35:30.401] getGlobalsAndPackages() ...
[13:35:30.402] Searching for globals...
[13:35:30.403] 
[13:35:30.403] Searching for globals ... DONE
[13:35:30.404] - globals: [0] <none>
[13:35:30.404] getGlobalsAndPackages() ... DONE
[13:35:30.404]    + additional globals found: [n=0] 
[13:35:30.404]    + additional namespaces needed: [n=0] 
[13:35:30.405]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:30.405]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:30.405]  - seeds: <none>
[13:35:30.405]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:30.405] getGlobalsAndPackages() ...
[13:35:30.406] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:30.406] Resolving globals: FALSE
[13:35:30.406] Tweak future expression to call with '...' arguments ...
[13:35:30.406] {
[13:35:30.406]     do.call(function(...) {
[13:35:30.406]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:30.406]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:30.406]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:30.406]             on.exit(options(oopts), add = TRUE)
[13:35:30.406]         }
[13:35:30.406]         {
[13:35:30.406]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:30.406]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:30.406]                 ...future.FUN(...future.X_jj, ...)
[13:35:30.406]             })
[13:35:30.406]         }
[13:35:30.406]     }, args = future.call.arguments)
[13:35:30.406] }
[13:35:30.407] Tweak future expression to call with '...' arguments ... DONE
[13:35:30.407] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:30.408] 
[13:35:30.408] getGlobalsAndPackages() ... DONE
[13:35:30.408] run() for ‘Future’ ...
[13:35:30.409] - state: ‘created’
[13:35:30.409] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:30.414] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:30.414] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:30.415]   - Field: ‘label’
[13:35:30.415]   - Field: ‘local’
[13:35:30.415]   - Field: ‘owner’
[13:35:30.415]   - Field: ‘envir’
[13:35:30.415]   - Field: ‘workers’
[13:35:30.415]   - Field: ‘packages’
[13:35:30.416]   - Field: ‘gc’
[13:35:30.416]   - Field: ‘job’
[13:35:30.416]   - Field: ‘conditions’
[13:35:30.416]   - Field: ‘expr’
[13:35:30.416]   - Field: ‘uuid’
[13:35:30.416]   - Field: ‘seed’
[13:35:30.416]   - Field: ‘version’
[13:35:30.417]   - Field: ‘result’
[13:35:30.417]   - Field: ‘asynchronous’
[13:35:30.417]   - Field: ‘calls’
[13:35:30.417]   - Field: ‘globals’
[13:35:30.417]   - Field: ‘stdout’
[13:35:30.417]   - Field: ‘earlySignal’
[13:35:30.417]   - Field: ‘lazy’
[13:35:30.418]   - Field: ‘state’
[13:35:30.418] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:30.418] - Launch lazy future ...
[13:35:30.418] Packages needed by the future expression (n = 0): <none>
[13:35:30.418] Packages needed by future strategies (n = 0): <none>
[13:35:30.419] {
[13:35:30.419]     {
[13:35:30.419]         {
[13:35:30.419]             ...future.startTime <- base::Sys.time()
[13:35:30.419]             {
[13:35:30.419]                 {
[13:35:30.419]                   {
[13:35:30.419]                     {
[13:35:30.419]                       base::local({
[13:35:30.419]                         has_future <- base::requireNamespace("future", 
[13:35:30.419]                           quietly = TRUE)
[13:35:30.419]                         if (has_future) {
[13:35:30.419]                           ns <- base::getNamespace("future")
[13:35:30.419]                           version <- ns[[".package"]][["version"]]
[13:35:30.419]                           if (is.null(version)) 
[13:35:30.419]                             version <- utils::packageVersion("future")
[13:35:30.419]                         }
[13:35:30.419]                         else {
[13:35:30.419]                           version <- NULL
[13:35:30.419]                         }
[13:35:30.419]                         if (!has_future || version < "1.8.0") {
[13:35:30.419]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:30.419]                             "", base::R.version$version.string), 
[13:35:30.419]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:30.419]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:30.419]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:30.419]                               "release", "version")], collapse = " "), 
[13:35:30.419]                             hostname = base::Sys.info()[["nodename"]])
[13:35:30.419]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:30.419]                             info)
[13:35:30.419]                           info <- base::paste(info, collapse = "; ")
[13:35:30.419]                           if (!has_future) {
[13:35:30.419]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:30.419]                               info)
[13:35:30.419]                           }
[13:35:30.419]                           else {
[13:35:30.419]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:30.419]                               info, version)
[13:35:30.419]                           }
[13:35:30.419]                           base::stop(msg)
[13:35:30.419]                         }
[13:35:30.419]                       })
[13:35:30.419]                     }
[13:35:30.419]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:30.419]                     base::options(mc.cores = 1L)
[13:35:30.419]                   }
[13:35:30.419]                   ...future.strategy.old <- future::plan("list")
[13:35:30.419]                   options(future.plan = NULL)
[13:35:30.419]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:30.419]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:30.419]                 }
[13:35:30.419]                 ...future.workdir <- getwd()
[13:35:30.419]             }
[13:35:30.419]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:30.419]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:30.419]         }
[13:35:30.419]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:30.419]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:30.419]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:30.419]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:30.419]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:30.419]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:30.419]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:30.419]             base::names(...future.oldOptions))
[13:35:30.419]     }
[13:35:30.419]     if (FALSE) {
[13:35:30.419]     }
[13:35:30.419]     else {
[13:35:30.419]         if (TRUE) {
[13:35:30.419]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:30.419]                 open = "w")
[13:35:30.419]         }
[13:35:30.419]         else {
[13:35:30.419]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:30.419]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:30.419]         }
[13:35:30.419]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:30.419]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:30.419]             base::sink(type = "output", split = FALSE)
[13:35:30.419]             base::close(...future.stdout)
[13:35:30.419]         }, add = TRUE)
[13:35:30.419]     }
[13:35:30.419]     ...future.frame <- base::sys.nframe()
[13:35:30.419]     ...future.conditions <- base::list()
[13:35:30.419]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:30.419]     if (FALSE) {
[13:35:30.419]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:30.419]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:30.419]     }
[13:35:30.419]     ...future.result <- base::tryCatch({
[13:35:30.419]         base::withCallingHandlers({
[13:35:30.419]             ...future.value <- base::withVisible(base::local({
[13:35:30.419]                 withCallingHandlers({
[13:35:30.419]                   {
[13:35:30.419]                     do.call(function(...) {
[13:35:30.419]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:30.419]                       if (!identical(...future.globals.maxSize.org, 
[13:35:30.419]                         ...future.globals.maxSize)) {
[13:35:30.419]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:30.419]                         on.exit(options(oopts), add = TRUE)
[13:35:30.419]                       }
[13:35:30.419]                       {
[13:35:30.419]                         lapply(seq_along(...future.elements_ii), 
[13:35:30.419]                           FUN = function(jj) {
[13:35:30.419]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:30.419]                             ...future.FUN(...future.X_jj, ...)
[13:35:30.419]                           })
[13:35:30.419]                       }
[13:35:30.419]                     }, args = future.call.arguments)
[13:35:30.419]                   }
[13:35:30.419]                 }, immediateCondition = function(cond) {
[13:35:30.419]                   save_rds <- function (object, pathname, ...) 
[13:35:30.419]                   {
[13:35:30.419]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:30.419]                     if (file_test("-f", pathname_tmp)) {
[13:35:30.419]                       fi_tmp <- file.info(pathname_tmp)
[13:35:30.419]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:30.419]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:30.419]                         fi_tmp[["mtime"]])
[13:35:30.419]                     }
[13:35:30.419]                     tryCatch({
[13:35:30.419]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:30.419]                     }, error = function(ex) {
[13:35:30.419]                       msg <- conditionMessage(ex)
[13:35:30.419]                       fi_tmp <- file.info(pathname_tmp)
[13:35:30.419]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:30.419]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:30.419]                         fi_tmp[["mtime"]], msg)
[13:35:30.419]                       ex$message <- msg
[13:35:30.419]                       stop(ex)
[13:35:30.419]                     })
[13:35:30.419]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:30.419]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:30.419]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:30.419]                       fi_tmp <- file.info(pathname_tmp)
[13:35:30.419]                       fi <- file.info(pathname)
[13:35:30.419]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:30.419]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:30.419]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:30.419]                         fi[["size"]], fi[["mtime"]])
[13:35:30.419]                       stop(msg)
[13:35:30.419]                     }
[13:35:30.419]                     invisible(pathname)
[13:35:30.419]                   }
[13:35:30.419]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:30.419]                     rootPath = tempdir()) 
[13:35:30.419]                   {
[13:35:30.419]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:30.419]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:30.419]                       tmpdir = path, fileext = ".rds")
[13:35:30.419]                     save_rds(obj, file)
[13:35:30.419]                   }
[13:35:30.419]                   saveImmediateCondition(cond, path = "/tmp/RtmpghgvGN/.future/immediateConditions")
[13:35:30.419]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:30.419]                   {
[13:35:30.419]                     inherits <- base::inherits
[13:35:30.419]                     invokeRestart <- base::invokeRestart
[13:35:30.419]                     is.null <- base::is.null
[13:35:30.419]                     muffled <- FALSE
[13:35:30.419]                     if (inherits(cond, "message")) {
[13:35:30.419]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:30.419]                       if (muffled) 
[13:35:30.419]                         invokeRestart("muffleMessage")
[13:35:30.419]                     }
[13:35:30.419]                     else if (inherits(cond, "warning")) {
[13:35:30.419]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:30.419]                       if (muffled) 
[13:35:30.419]                         invokeRestart("muffleWarning")
[13:35:30.419]                     }
[13:35:30.419]                     else if (inherits(cond, "condition")) {
[13:35:30.419]                       if (!is.null(pattern)) {
[13:35:30.419]                         computeRestarts <- base::computeRestarts
[13:35:30.419]                         grepl <- base::grepl
[13:35:30.419]                         restarts <- computeRestarts(cond)
[13:35:30.419]                         for (restart in restarts) {
[13:35:30.419]                           name <- restart$name
[13:35:30.419]                           if (is.null(name)) 
[13:35:30.419]                             next
[13:35:30.419]                           if (!grepl(pattern, name)) 
[13:35:30.419]                             next
[13:35:30.419]                           invokeRestart(restart)
[13:35:30.419]                           muffled <- TRUE
[13:35:30.419]                           break
[13:35:30.419]                         }
[13:35:30.419]                       }
[13:35:30.419]                     }
[13:35:30.419]                     invisible(muffled)
[13:35:30.419]                   }
[13:35:30.419]                   muffleCondition(cond)
[13:35:30.419]                 })
[13:35:30.419]             }))
[13:35:30.419]             future::FutureResult(value = ...future.value$value, 
[13:35:30.419]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:30.419]                   ...future.rng), globalenv = if (FALSE) 
[13:35:30.419]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:30.419]                     ...future.globalenv.names))
[13:35:30.419]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:30.419]         }, condition = base::local({
[13:35:30.419]             c <- base::c
[13:35:30.419]             inherits <- base::inherits
[13:35:30.419]             invokeRestart <- base::invokeRestart
[13:35:30.419]             length <- base::length
[13:35:30.419]             list <- base::list
[13:35:30.419]             seq.int <- base::seq.int
[13:35:30.419]             signalCondition <- base::signalCondition
[13:35:30.419]             sys.calls <- base::sys.calls
[13:35:30.419]             `[[` <- base::`[[`
[13:35:30.419]             `+` <- base::`+`
[13:35:30.419]             `<<-` <- base::`<<-`
[13:35:30.419]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:30.419]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:30.419]                   3L)]
[13:35:30.419]             }
[13:35:30.419]             function(cond) {
[13:35:30.419]                 is_error <- inherits(cond, "error")
[13:35:30.419]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:30.419]                   NULL)
[13:35:30.419]                 if (is_error) {
[13:35:30.419]                   sessionInformation <- function() {
[13:35:30.419]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:30.419]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:30.419]                       search = base::search(), system = base::Sys.info())
[13:35:30.419]                   }
[13:35:30.419]                   ...future.conditions[[length(...future.conditions) + 
[13:35:30.419]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:30.419]                     cond$call), session = sessionInformation(), 
[13:35:30.419]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:30.419]                   signalCondition(cond)
[13:35:30.419]                 }
[13:35:30.419]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:30.419]                 "immediateCondition"))) {
[13:35:30.419]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:30.419]                   ...future.conditions[[length(...future.conditions) + 
[13:35:30.419]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:30.419]                   if (TRUE && !signal) {
[13:35:30.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:30.419]                     {
[13:35:30.419]                       inherits <- base::inherits
[13:35:30.419]                       invokeRestart <- base::invokeRestart
[13:35:30.419]                       is.null <- base::is.null
[13:35:30.419]                       muffled <- FALSE
[13:35:30.419]                       if (inherits(cond, "message")) {
[13:35:30.419]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:30.419]                         if (muffled) 
[13:35:30.419]                           invokeRestart("muffleMessage")
[13:35:30.419]                       }
[13:35:30.419]                       else if (inherits(cond, "warning")) {
[13:35:30.419]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:30.419]                         if (muffled) 
[13:35:30.419]                           invokeRestart("muffleWarning")
[13:35:30.419]                       }
[13:35:30.419]                       else if (inherits(cond, "condition")) {
[13:35:30.419]                         if (!is.null(pattern)) {
[13:35:30.419]                           computeRestarts <- base::computeRestarts
[13:35:30.419]                           grepl <- base::grepl
[13:35:30.419]                           restarts <- computeRestarts(cond)
[13:35:30.419]                           for (restart in restarts) {
[13:35:30.419]                             name <- restart$name
[13:35:30.419]                             if (is.null(name)) 
[13:35:30.419]                               next
[13:35:30.419]                             if (!grepl(pattern, name)) 
[13:35:30.419]                               next
[13:35:30.419]                             invokeRestart(restart)
[13:35:30.419]                             muffled <- TRUE
[13:35:30.419]                             break
[13:35:30.419]                           }
[13:35:30.419]                         }
[13:35:30.419]                       }
[13:35:30.419]                       invisible(muffled)
[13:35:30.419]                     }
[13:35:30.419]                     muffleCondition(cond, pattern = "^muffle")
[13:35:30.419]                   }
[13:35:30.419]                 }
[13:35:30.419]                 else {
[13:35:30.419]                   if (TRUE) {
[13:35:30.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:30.419]                     {
[13:35:30.419]                       inherits <- base::inherits
[13:35:30.419]                       invokeRestart <- base::invokeRestart
[13:35:30.419]                       is.null <- base::is.null
[13:35:30.419]                       muffled <- FALSE
[13:35:30.419]                       if (inherits(cond, "message")) {
[13:35:30.419]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:30.419]                         if (muffled) 
[13:35:30.419]                           invokeRestart("muffleMessage")
[13:35:30.419]                       }
[13:35:30.419]                       else if (inherits(cond, "warning")) {
[13:35:30.419]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:30.419]                         if (muffled) 
[13:35:30.419]                           invokeRestart("muffleWarning")
[13:35:30.419]                       }
[13:35:30.419]                       else if (inherits(cond, "condition")) {
[13:35:30.419]                         if (!is.null(pattern)) {
[13:35:30.419]                           computeRestarts <- base::computeRestarts
[13:35:30.419]                           grepl <- base::grepl
[13:35:30.419]                           restarts <- computeRestarts(cond)
[13:35:30.419]                           for (restart in restarts) {
[13:35:30.419]                             name <- restart$name
[13:35:30.419]                             if (is.null(name)) 
[13:35:30.419]                               next
[13:35:30.419]                             if (!grepl(pattern, name)) 
[13:35:30.419]                               next
[13:35:30.419]                             invokeRestart(restart)
[13:35:30.419]                             muffled <- TRUE
[13:35:30.419]                             break
[13:35:30.419]                           }
[13:35:30.419]                         }
[13:35:30.419]                       }
[13:35:30.419]                       invisible(muffled)
[13:35:30.419]                     }
[13:35:30.419]                     muffleCondition(cond, pattern = "^muffle")
[13:35:30.419]                   }
[13:35:30.419]                 }
[13:35:30.419]             }
[13:35:30.419]         }))
[13:35:30.419]     }, error = function(ex) {
[13:35:30.419]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:30.419]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:30.419]                 ...future.rng), started = ...future.startTime, 
[13:35:30.419]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:30.419]             version = "1.8"), class = "FutureResult")
[13:35:30.419]     }, finally = {
[13:35:30.419]         if (!identical(...future.workdir, getwd())) 
[13:35:30.419]             setwd(...future.workdir)
[13:35:30.419]         {
[13:35:30.419]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:30.419]                 ...future.oldOptions$nwarnings <- NULL
[13:35:30.419]             }
[13:35:30.419]             base::options(...future.oldOptions)
[13:35:30.419]             if (.Platform$OS.type == "windows") {
[13:35:30.419]                 old_names <- names(...future.oldEnvVars)
[13:35:30.419]                 envs <- base::Sys.getenv()
[13:35:30.419]                 names <- names(envs)
[13:35:30.419]                 common <- intersect(names, old_names)
[13:35:30.419]                 added <- setdiff(names, old_names)
[13:35:30.419]                 removed <- setdiff(old_names, names)
[13:35:30.419]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:30.419]                   envs[common]]
[13:35:30.419]                 NAMES <- toupper(changed)
[13:35:30.419]                 args <- list()
[13:35:30.419]                 for (kk in seq_along(NAMES)) {
[13:35:30.419]                   name <- changed[[kk]]
[13:35:30.419]                   NAME <- NAMES[[kk]]
[13:35:30.419]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:30.419]                     next
[13:35:30.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:30.419]                 }
[13:35:30.419]                 NAMES <- toupper(added)
[13:35:30.419]                 for (kk in seq_along(NAMES)) {
[13:35:30.419]                   name <- added[[kk]]
[13:35:30.419]                   NAME <- NAMES[[kk]]
[13:35:30.419]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:30.419]                     next
[13:35:30.419]                   args[[name]] <- ""
[13:35:30.419]                 }
[13:35:30.419]                 NAMES <- toupper(removed)
[13:35:30.419]                 for (kk in seq_along(NAMES)) {
[13:35:30.419]                   name <- removed[[kk]]
[13:35:30.419]                   NAME <- NAMES[[kk]]
[13:35:30.419]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:30.419]                     next
[13:35:30.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:30.419]                 }
[13:35:30.419]                 if (length(args) > 0) 
[13:35:30.419]                   base::do.call(base::Sys.setenv, args = args)
[13:35:30.419]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:30.419]             }
[13:35:30.419]             else {
[13:35:30.419]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:30.419]             }
[13:35:30.419]             {
[13:35:30.419]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:30.419]                   0L) {
[13:35:30.419]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:30.419]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:30.419]                   base::options(opts)
[13:35:30.419]                 }
[13:35:30.419]                 {
[13:35:30.419]                   {
[13:35:30.419]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:30.419]                     NULL
[13:35:30.419]                   }
[13:35:30.419]                   options(future.plan = NULL)
[13:35:30.419]                   if (is.na(NA_character_)) 
[13:35:30.419]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:30.419]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:30.419]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:30.419]                     .init = FALSE)
[13:35:30.419]                 }
[13:35:30.419]             }
[13:35:30.419]         }
[13:35:30.419]     })
[13:35:30.419]     if (TRUE) {
[13:35:30.419]         base::sink(type = "output", split = FALSE)
[13:35:30.419]         if (TRUE) {
[13:35:30.419]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:30.419]         }
[13:35:30.419]         else {
[13:35:30.419]             ...future.result["stdout"] <- base::list(NULL)
[13:35:30.419]         }
[13:35:30.419]         base::close(...future.stdout)
[13:35:30.419]         ...future.stdout <- NULL
[13:35:30.419]     }
[13:35:30.419]     ...future.result$conditions <- ...future.conditions
[13:35:30.419]     ...future.result$finished <- base::Sys.time()
[13:35:30.419]     ...future.result
[13:35:30.419] }
[13:35:30.422] assign_globals() ...
[13:35:30.422] List of 5
[13:35:30.422]  $ ...future.FUN            :function (x)  
[13:35:30.422]  $ future.call.arguments    : list()
[13:35:30.422]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:30.422]  $ ...future.elements_ii    :List of 1
[13:35:30.422]   ..$ : int 0
[13:35:30.422]  $ ...future.seeds_ii       : NULL
[13:35:30.422]  $ ...future.globals.maxSize: NULL
[13:35:30.422]  - attr(*, "where")=List of 5
[13:35:30.422]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:30.422]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:30.422]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:30.422]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:30.422]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:30.422]  - attr(*, "resolved")= logi FALSE
[13:35:30.422]  - attr(*, "total_size")= num 4720
[13:35:30.422]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:30.422]  - attr(*, "already-done")= logi TRUE
[13:35:30.428] - reassign environment for ‘...future.FUN’
[13:35:30.429] - copied ‘...future.FUN’ to environment
[13:35:30.429] - copied ‘future.call.arguments’ to environment
[13:35:30.429] - copied ‘...future.elements_ii’ to environment
[13:35:30.429] - copied ‘...future.seeds_ii’ to environment
[13:35:30.429] - copied ‘...future.globals.maxSize’ to environment
[13:35:30.429] assign_globals() ... done
[13:35:30.429] requestCore(): workers = 2
[13:35:30.432] MulticoreFuture started
[13:35:30.432] - Launch lazy future ... done
[13:35:30.432] run() for ‘MulticoreFuture’ ... done
[13:35:30.432] Created future:
[13:35:30.433] plan(): Setting new future strategy stack:
[13:35:30.433] List of future strategies:
[13:35:30.433] 1. sequential:
[13:35:30.433]    - args: function (..., envir = parent.frame())
[13:35:30.433]    - tweaked: FALSE
[13:35:30.433]    - call: NULL
[13:35:30.434] plan(): nbrOfWorkers() = 1
[13:35:30.436] plan(): Setting new future strategy stack:
[13:35:30.436] List of future strategies:
[13:35:30.436] 1. multicore:
[13:35:30.436]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:30.436]    - tweaked: FALSE
[13:35:30.436]    - call: plan(strategy)
[13:35:30.441] plan(): nbrOfWorkers() = 2
[13:35:30.433] MulticoreFuture:
[13:35:30.433] Label: ‘future_lapply-2’
[13:35:30.433] Expression:
[13:35:30.433] {
[13:35:30.433]     do.call(function(...) {
[13:35:30.433]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:30.433]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:30.433]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:30.433]             on.exit(options(oopts), add = TRUE)
[13:35:30.433]         }
[13:35:30.433]         {
[13:35:30.433]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:30.433]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:30.433]                 ...future.FUN(...future.X_jj, ...)
[13:35:30.433]             })
[13:35:30.433]         }
[13:35:30.433]     }, args = future.call.arguments)
[13:35:30.433] }
[13:35:30.433] Lazy evaluation: FALSE
[13:35:30.433] Asynchronous evaluation: TRUE
[13:35:30.433] Local evaluation: TRUE
[13:35:30.433] Environment: R_GlobalEnv
[13:35:30.433] Capture standard output: TRUE
[13:35:30.433] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:30.433] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:30.433] Packages: <none>
[13:35:30.433] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:30.433] Resolved: TRUE
[13:35:30.433] Value: <not collected>
[13:35:30.433] Conditions captured: <none>
[13:35:30.433] Early signaling: FALSE
[13:35:30.433] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:30.433] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:30.442] Chunk #2 of 2 ... DONE
[13:35:30.442] Launching 2 futures (chunks) ... DONE
[13:35:30.442] Resolving 2 futures (chunks) ...
[13:35:30.443] resolve() on list ...
[13:35:30.443]  recursive: 0
[13:35:30.443]  length: 2
[13:35:30.443] 
[13:35:30.454] Future #2
[13:35:30.454] result() for MulticoreFuture ...
[13:35:30.455] result() for MulticoreFuture ...
[13:35:30.455] result() for MulticoreFuture ... done
[13:35:30.455] result() for MulticoreFuture ... done
[13:35:30.455] result() for MulticoreFuture ...
[13:35:30.456] result() for MulticoreFuture ... done
[13:35:30.456] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:35:30.456] - nx: 2
[13:35:30.456] - relay: TRUE
[13:35:30.456] - stdout: TRUE
[13:35:30.456] - signal: TRUE
[13:35:30.457] - resignal: FALSE
[13:35:30.457] - force: TRUE
[13:35:30.457] - relayed: [n=2] FALSE, FALSE
[13:35:30.457] - queued futures: [n=2] FALSE, FALSE
[13:35:30.457]  - until=1
[13:35:30.457]  - relaying element #1
[13:35:30.457] - relayed: [n=2] FALSE, FALSE
[13:35:30.457] - queued futures: [n=2] FALSE, TRUE
[13:35:30.458] signalConditionsASAP(NULL, pos=2) ... done
[13:35:30.458]  length: 1 (resolved future 2)
[13:35:30.890] plan(): Setting new future strategy stack:
[13:35:30.891] List of future strategies:
[13:35:30.891] 1. multicore:
[13:35:30.891]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:30.891]    - tweaked: FALSE
[13:35:30.891]    - call: plan(strategy)
[13:35:30.896] plan(): nbrOfWorkers() = 2
[13:35:30.896] Future #1
[13:35:30.897] result() for MulticoreFuture ...
[13:35:30.897] result() for MulticoreFuture ...
[13:35:30.898] result() for MulticoreFuture ... done
[13:35:30.900] result() for MulticoreFuture ... done
[13:35:30.900] result() for MulticoreFuture ...
[13:35:30.901] result() for MulticoreFuture ... done
[13:35:30.901] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:35:30.901] - nx: 2
[13:35:30.901] - relay: TRUE
[13:35:30.901] - stdout: TRUE
[13:35:30.901] - signal: TRUE
[13:35:30.902] - resignal: FALSE
[13:35:30.902] - force: TRUE
[13:35:30.902] - relayed: [n=2] FALSE, FALSE
[13:35:30.902] - queued futures: [n=2] FALSE, TRUE
[13:35:30.902]  - until=1
[13:35:30.903]  - relaying element #1
[13:35:30.903] result() for MulticoreFuture ...
[13:35:30.903] result() for MulticoreFuture ... done
[13:35:30.903] result() for MulticoreFuture ...
[13:35:30.903] result() for MulticoreFuture ... done
[13:35:30.903] result() for MulticoreFuture ...
[13:35:30.903] result() for MulticoreFuture ... done
[13:35:30.903] result() for MulticoreFuture ...
[13:35:30.904] result() for MulticoreFuture ... done
[13:35:30.904] - relayed: [n=2] TRUE, FALSE
[13:35:30.904] - queued futures: [n=2] TRUE, TRUE
[13:35:30.904] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:35:30.904]  length: 0 (resolved future 1)
[13:35:30.904] Relaying remaining futures
[13:35:30.904] signalConditionsASAP(NULL, pos=0) ...
[13:35:30.904] - nx: 2
[13:35:30.905] - relay: TRUE
[13:35:30.905] - stdout: TRUE
[13:35:30.905] - signal: TRUE
[13:35:30.905] - resignal: FALSE
[13:35:30.905] - force: TRUE
[13:35:30.905] - relayed: [n=2] TRUE, FALSE
[13:35:30.905] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:30.905]  - relaying element #2
[13:35:30.905] result() for MulticoreFuture ...
[13:35:30.906] result() for MulticoreFuture ... done
[13:35:30.906] result() for MulticoreFuture ...
[13:35:30.906] result() for MulticoreFuture ... done
[13:35:30.906] result() for MulticoreFuture ...
[13:35:30.906] result() for MulticoreFuture ... done
[13:35:30.906] result() for MulticoreFuture ...
[13:35:30.906] result() for MulticoreFuture ... done
[13:35:30.906] - relayed: [n=2] TRUE, TRUE
[13:35:30.907] - queued futures: [n=2] TRUE, TRUE
[13:35:30.907] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[13:35:30.907] resolve() on list ... DONE
[13:35:30.907] result() for MulticoreFuture ...
[13:35:30.907] result() for MulticoreFuture ... done
[13:35:30.907] result() for MulticoreFuture ...
[13:35:30.907] result() for MulticoreFuture ... done
[13:35:30.908] result() for MulticoreFuture ...
[13:35:30.908] result() for MulticoreFuture ... done
[13:35:30.908] result() for MulticoreFuture ...
[13:35:30.908] result() for MulticoreFuture ... done
[13:35:30.908]  - Number of value chunks collected: 2
[13:35:30.908] Resolving 2 futures (chunks) ... DONE
[13:35:30.908] Reducing values from 2 chunks ...
[13:35:30.908]  - Number of values collected after concatenation: 2
[13:35:30.909]  - Number of values expected: 2
[13:35:30.909] Reducing values from 2 chunks ... DONE
[13:35:30.909] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[13:35:30.909] future_lapply() ...
[13:35:30.914] Number of chunks: 2
[13:35:30.914] getGlobalsAndPackagesXApply() ...
[13:35:30.914]  - future.globals: TRUE
[13:35:30.914] getGlobalsAndPackages() ...
[13:35:30.914] Searching for globals...
[13:35:30.916] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:35:30.916] Searching for globals ... DONE
[13:35:30.916] Resolving globals: FALSE
[13:35:30.917] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:35:30.917] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:35:30.917] - globals: [1] ‘FUN’
[13:35:30.917] 
[13:35:30.917] getGlobalsAndPackages() ... DONE
[13:35:30.917]  - globals found/used: [n=1] ‘FUN’
[13:35:30.918]  - needed namespaces: [n=0] 
[13:35:30.918] Finding globals ... DONE
[13:35:30.918]  - use_args: TRUE
[13:35:30.918]  - Getting '...' globals ...
[13:35:30.918] resolve() on list ...
[13:35:30.918]  recursive: 0
[13:35:30.918]  length: 1
[13:35:30.919]  elements: ‘...’
[13:35:30.919]  length: 0 (resolved future 1)
[13:35:30.919] resolve() on list ... DONE
[13:35:30.919]    - '...' content: [n=0] 
[13:35:30.919] List of 1
[13:35:30.919]  $ ...: list()
[13:35:30.919]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:30.919]  - attr(*, "where")=List of 1
[13:35:30.919]   ..$ ...:<environment: 0x558d362777e0> 
[13:35:30.919]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:30.919]  - attr(*, "resolved")= logi TRUE
[13:35:30.919]  - attr(*, "total_size")= num NA
[13:35:30.922]  - Getting '...' globals ... DONE
[13:35:30.922] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:35:30.922] List of 2
[13:35:30.922]  $ ...future.FUN:function (x)  
[13:35:30.922]  $ ...          : list()
[13:35:30.922]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:30.922]  - attr(*, "where")=List of 2
[13:35:30.922]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:30.922]   ..$ ...          :<environment: 0x558d362777e0> 
[13:35:30.922]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:30.922]  - attr(*, "resolved")= logi FALSE
[13:35:30.922]  - attr(*, "total_size")= num 4720
[13:35:30.925] Packages to be attached in all futures: [n=0] 
[13:35:30.925] getGlobalsAndPackagesXApply() ... DONE
[13:35:30.925] Number of futures (= number of chunks): 2
[13:35:30.925] Launching 2 futures (chunks) ...
[13:35:30.925] Chunk #1 of 2 ...
[13:35:30.926]  - Finding globals in 'X' for chunk #1 ...
[13:35:30.926] getGlobalsAndPackages() ...
[13:35:30.926] Searching for globals...
[13:35:30.926] 
[13:35:30.926] Searching for globals ... DONE
[13:35:30.926] - globals: [0] <none>
[13:35:30.926] getGlobalsAndPackages() ... DONE
[13:35:30.926]    + additional globals found: [n=0] 
[13:35:30.926]    + additional namespaces needed: [n=0] 
[13:35:30.928]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:30.928]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:30.928]  - seeds: <none>
[13:35:30.928]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:30.928] getGlobalsAndPackages() ...
[13:35:30.928] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:30.928] Resolving globals: FALSE
[13:35:30.928] Tweak future expression to call with '...' arguments ...
[13:35:30.929] {
[13:35:30.929]     do.call(function(...) {
[13:35:30.929]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:30.929]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:30.929]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:30.929]             on.exit(options(oopts), add = TRUE)
[13:35:30.929]         }
[13:35:30.929]         {
[13:35:30.929]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:30.929]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:30.929]                 ...future.FUN(...future.X_jj, ...)
[13:35:30.929]             })
[13:35:30.929]         }
[13:35:30.929]     }, args = future.call.arguments)
[13:35:30.929] }
[13:35:30.929] Tweak future expression to call with '...' arguments ... DONE
[13:35:30.929] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:30.929] 
[13:35:30.929] getGlobalsAndPackages() ... DONE
[13:35:30.930] run() for ‘Future’ ...
[13:35:30.930] - state: ‘created’
[13:35:30.930] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:30.933] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:30.933] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:30.934]   - Field: ‘label’
[13:35:30.934]   - Field: ‘local’
[13:35:30.934]   - Field: ‘owner’
[13:35:30.934]   - Field: ‘envir’
[13:35:30.934]   - Field: ‘workers’
[13:35:30.934]   - Field: ‘packages’
[13:35:30.934]   - Field: ‘gc’
[13:35:30.934]   - Field: ‘job’
[13:35:30.934]   - Field: ‘conditions’
[13:35:30.934]   - Field: ‘expr’
[13:35:30.935]   - Field: ‘uuid’
[13:35:30.935]   - Field: ‘seed’
[13:35:30.935]   - Field: ‘version’
[13:35:30.935]   - Field: ‘result’
[13:35:30.935]   - Field: ‘asynchronous’
[13:35:30.935]   - Field: ‘calls’
[13:35:30.935]   - Field: ‘globals’
[13:35:30.935]   - Field: ‘stdout’
[13:35:30.935]   - Field: ‘earlySignal’
[13:35:30.935]   - Field: ‘lazy’
[13:35:30.935]   - Field: ‘state’
[13:35:30.936] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:30.936] - Launch lazy future ...
[13:35:30.936] Packages needed by the future expression (n = 0): <none>
[13:35:30.936] Packages needed by future strategies (n = 0): <none>
[13:35:30.936] {
[13:35:30.936]     {
[13:35:30.936]         {
[13:35:30.936]             ...future.startTime <- base::Sys.time()
[13:35:30.936]             {
[13:35:30.936]                 {
[13:35:30.936]                   {
[13:35:30.936]                     {
[13:35:30.936]                       base::local({
[13:35:30.936]                         has_future <- base::requireNamespace("future", 
[13:35:30.936]                           quietly = TRUE)
[13:35:30.936]                         if (has_future) {
[13:35:30.936]                           ns <- base::getNamespace("future")
[13:35:30.936]                           version <- ns[[".package"]][["version"]]
[13:35:30.936]                           if (is.null(version)) 
[13:35:30.936]                             version <- utils::packageVersion("future")
[13:35:30.936]                         }
[13:35:30.936]                         else {
[13:35:30.936]                           version <- NULL
[13:35:30.936]                         }
[13:35:30.936]                         if (!has_future || version < "1.8.0") {
[13:35:30.936]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:30.936]                             "", base::R.version$version.string), 
[13:35:30.936]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:30.936]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:30.936]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:30.936]                               "release", "version")], collapse = " "), 
[13:35:30.936]                             hostname = base::Sys.info()[["nodename"]])
[13:35:30.936]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:30.936]                             info)
[13:35:30.936]                           info <- base::paste(info, collapse = "; ")
[13:35:30.936]                           if (!has_future) {
[13:35:30.936]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:30.936]                               info)
[13:35:30.936]                           }
[13:35:30.936]                           else {
[13:35:30.936]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:30.936]                               info, version)
[13:35:30.936]                           }
[13:35:30.936]                           base::stop(msg)
[13:35:30.936]                         }
[13:35:30.936]                       })
[13:35:30.936]                     }
[13:35:30.936]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:30.936]                     base::options(mc.cores = 1L)
[13:35:30.936]                   }
[13:35:30.936]                   ...future.strategy.old <- future::plan("list")
[13:35:30.936]                   options(future.plan = NULL)
[13:35:30.936]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:30.936]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:30.936]                 }
[13:35:30.936]                 ...future.workdir <- getwd()
[13:35:30.936]             }
[13:35:30.936]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:30.936]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:30.936]         }
[13:35:30.936]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:30.936]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:30.936]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:30.936]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:30.936]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:30.936]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:30.936]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:30.936]             base::names(...future.oldOptions))
[13:35:30.936]     }
[13:35:30.936]     if (TRUE) {
[13:35:30.936]     }
[13:35:30.936]     else {
[13:35:30.936]         if (NA) {
[13:35:30.936]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:30.936]                 open = "w")
[13:35:30.936]         }
[13:35:30.936]         else {
[13:35:30.936]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:30.936]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:30.936]         }
[13:35:30.936]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:30.936]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:30.936]             base::sink(type = "output", split = FALSE)
[13:35:30.936]             base::close(...future.stdout)
[13:35:30.936]         }, add = TRUE)
[13:35:30.936]     }
[13:35:30.936]     ...future.frame <- base::sys.nframe()
[13:35:30.936]     ...future.conditions <- base::list()
[13:35:30.936]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:30.936]     if (FALSE) {
[13:35:30.936]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:30.936]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:30.936]     }
[13:35:30.936]     ...future.result <- base::tryCatch({
[13:35:30.936]         base::withCallingHandlers({
[13:35:30.936]             ...future.value <- base::withVisible(base::local({
[13:35:30.936]                 withCallingHandlers({
[13:35:30.936]                   {
[13:35:30.936]                     do.call(function(...) {
[13:35:30.936]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:30.936]                       if (!identical(...future.globals.maxSize.org, 
[13:35:30.936]                         ...future.globals.maxSize)) {
[13:35:30.936]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:30.936]                         on.exit(options(oopts), add = TRUE)
[13:35:30.936]                       }
[13:35:30.936]                       {
[13:35:30.936]                         lapply(seq_along(...future.elements_ii), 
[13:35:30.936]                           FUN = function(jj) {
[13:35:30.936]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:30.936]                             ...future.FUN(...future.X_jj, ...)
[13:35:30.936]                           })
[13:35:30.936]                       }
[13:35:30.936]                     }, args = future.call.arguments)
[13:35:30.936]                   }
[13:35:30.936]                 }, immediateCondition = function(cond) {
[13:35:30.936]                   save_rds <- function (object, pathname, ...) 
[13:35:30.936]                   {
[13:35:30.936]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:30.936]                     if (file_test("-f", pathname_tmp)) {
[13:35:30.936]                       fi_tmp <- file.info(pathname_tmp)
[13:35:30.936]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:30.936]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:30.936]                         fi_tmp[["mtime"]])
[13:35:30.936]                     }
[13:35:30.936]                     tryCatch({
[13:35:30.936]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:30.936]                     }, error = function(ex) {
[13:35:30.936]                       msg <- conditionMessage(ex)
[13:35:30.936]                       fi_tmp <- file.info(pathname_tmp)
[13:35:30.936]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:30.936]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:30.936]                         fi_tmp[["mtime"]], msg)
[13:35:30.936]                       ex$message <- msg
[13:35:30.936]                       stop(ex)
[13:35:30.936]                     })
[13:35:30.936]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:30.936]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:30.936]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:30.936]                       fi_tmp <- file.info(pathname_tmp)
[13:35:30.936]                       fi <- file.info(pathname)
[13:35:30.936]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:30.936]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:30.936]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:30.936]                         fi[["size"]], fi[["mtime"]])
[13:35:30.936]                       stop(msg)
[13:35:30.936]                     }
[13:35:30.936]                     invisible(pathname)
[13:35:30.936]                   }
[13:35:30.936]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:30.936]                     rootPath = tempdir()) 
[13:35:30.936]                   {
[13:35:30.936]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:30.936]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:30.936]                       tmpdir = path, fileext = ".rds")
[13:35:30.936]                     save_rds(obj, file)
[13:35:30.936]                   }
[13:35:30.936]                   saveImmediateCondition(cond, path = "/tmp/RtmpghgvGN/.future/immediateConditions")
[13:35:30.936]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:30.936]                   {
[13:35:30.936]                     inherits <- base::inherits
[13:35:30.936]                     invokeRestart <- base::invokeRestart
[13:35:30.936]                     is.null <- base::is.null
[13:35:30.936]                     muffled <- FALSE
[13:35:30.936]                     if (inherits(cond, "message")) {
[13:35:30.936]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:30.936]                       if (muffled) 
[13:35:30.936]                         invokeRestart("muffleMessage")
[13:35:30.936]                     }
[13:35:30.936]                     else if (inherits(cond, "warning")) {
[13:35:30.936]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:30.936]                       if (muffled) 
[13:35:30.936]                         invokeRestart("muffleWarning")
[13:35:30.936]                     }
[13:35:30.936]                     else if (inherits(cond, "condition")) {
[13:35:30.936]                       if (!is.null(pattern)) {
[13:35:30.936]                         computeRestarts <- base::computeRestarts
[13:35:30.936]                         grepl <- base::grepl
[13:35:30.936]                         restarts <- computeRestarts(cond)
[13:35:30.936]                         for (restart in restarts) {
[13:35:30.936]                           name <- restart$name
[13:35:30.936]                           if (is.null(name)) 
[13:35:30.936]                             next
[13:35:30.936]                           if (!grepl(pattern, name)) 
[13:35:30.936]                             next
[13:35:30.936]                           invokeRestart(restart)
[13:35:30.936]                           muffled <- TRUE
[13:35:30.936]                           break
[13:35:30.936]                         }
[13:35:30.936]                       }
[13:35:30.936]                     }
[13:35:30.936]                     invisible(muffled)
[13:35:30.936]                   }
[13:35:30.936]                   muffleCondition(cond)
[13:35:30.936]                 })
[13:35:30.936]             }))
[13:35:30.936]             future::FutureResult(value = ...future.value$value, 
[13:35:30.936]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:30.936]                   ...future.rng), globalenv = if (FALSE) 
[13:35:30.936]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:30.936]                     ...future.globalenv.names))
[13:35:30.936]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:30.936]         }, condition = base::local({
[13:35:30.936]             c <- base::c
[13:35:30.936]             inherits <- base::inherits
[13:35:30.936]             invokeRestart <- base::invokeRestart
[13:35:30.936]             length <- base::length
[13:35:30.936]             list <- base::list
[13:35:30.936]             seq.int <- base::seq.int
[13:35:30.936]             signalCondition <- base::signalCondition
[13:35:30.936]             sys.calls <- base::sys.calls
[13:35:30.936]             `[[` <- base::`[[`
[13:35:30.936]             `+` <- base::`+`
[13:35:30.936]             `<<-` <- base::`<<-`
[13:35:30.936]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:30.936]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:30.936]                   3L)]
[13:35:30.936]             }
[13:35:30.936]             function(cond) {
[13:35:30.936]                 is_error <- inherits(cond, "error")
[13:35:30.936]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:30.936]                   NULL)
[13:35:30.936]                 if (is_error) {
[13:35:30.936]                   sessionInformation <- function() {
[13:35:30.936]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:30.936]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:30.936]                       search = base::search(), system = base::Sys.info())
[13:35:30.936]                   }
[13:35:30.936]                   ...future.conditions[[length(...future.conditions) + 
[13:35:30.936]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:30.936]                     cond$call), session = sessionInformation(), 
[13:35:30.936]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:30.936]                   signalCondition(cond)
[13:35:30.936]                 }
[13:35:30.936]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:30.936]                 "immediateCondition"))) {
[13:35:30.936]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:30.936]                   ...future.conditions[[length(...future.conditions) + 
[13:35:30.936]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:30.936]                   if (TRUE && !signal) {
[13:35:30.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:30.936]                     {
[13:35:30.936]                       inherits <- base::inherits
[13:35:30.936]                       invokeRestart <- base::invokeRestart
[13:35:30.936]                       is.null <- base::is.null
[13:35:30.936]                       muffled <- FALSE
[13:35:30.936]                       if (inherits(cond, "message")) {
[13:35:30.936]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:30.936]                         if (muffled) 
[13:35:30.936]                           invokeRestart("muffleMessage")
[13:35:30.936]                       }
[13:35:30.936]                       else if (inherits(cond, "warning")) {
[13:35:30.936]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:30.936]                         if (muffled) 
[13:35:30.936]                           invokeRestart("muffleWarning")
[13:35:30.936]                       }
[13:35:30.936]                       else if (inherits(cond, "condition")) {
[13:35:30.936]                         if (!is.null(pattern)) {
[13:35:30.936]                           computeRestarts <- base::computeRestarts
[13:35:30.936]                           grepl <- base::grepl
[13:35:30.936]                           restarts <- computeRestarts(cond)
[13:35:30.936]                           for (restart in restarts) {
[13:35:30.936]                             name <- restart$name
[13:35:30.936]                             if (is.null(name)) 
[13:35:30.936]                               next
[13:35:30.936]                             if (!grepl(pattern, name)) 
[13:35:30.936]                               next
[13:35:30.936]                             invokeRestart(restart)
[13:35:30.936]                             muffled <- TRUE
[13:35:30.936]                             break
[13:35:30.936]                           }
[13:35:30.936]                         }
[13:35:30.936]                       }
[13:35:30.936]                       invisible(muffled)
[13:35:30.936]                     }
[13:35:30.936]                     muffleCondition(cond, pattern = "^muffle")
[13:35:30.936]                   }
[13:35:30.936]                 }
[13:35:30.936]                 else {
[13:35:30.936]                   if (TRUE) {
[13:35:30.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:30.936]                     {
[13:35:30.936]                       inherits <- base::inherits
[13:35:30.936]                       invokeRestart <- base::invokeRestart
[13:35:30.936]                       is.null <- base::is.null
[13:35:30.936]                       muffled <- FALSE
[13:35:30.936]                       if (inherits(cond, "message")) {
[13:35:30.936]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:30.936]                         if (muffled) 
[13:35:30.936]                           invokeRestart("muffleMessage")
[13:35:30.936]                       }
[13:35:30.936]                       else if (inherits(cond, "warning")) {
[13:35:30.936]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:30.936]                         if (muffled) 
[13:35:30.936]                           invokeRestart("muffleWarning")
[13:35:30.936]                       }
[13:35:30.936]                       else if (inherits(cond, "condition")) {
[13:35:30.936]                         if (!is.null(pattern)) {
[13:35:30.936]                           computeRestarts <- base::computeRestarts
[13:35:30.936]                           grepl <- base::grepl
[13:35:30.936]                           restarts <- computeRestarts(cond)
[13:35:30.936]                           for (restart in restarts) {
[13:35:30.936]                             name <- restart$name
[13:35:30.936]                             if (is.null(name)) 
[13:35:30.936]                               next
[13:35:30.936]                             if (!grepl(pattern, name)) 
[13:35:30.936]                               next
[13:35:30.936]                             invokeRestart(restart)
[13:35:30.936]                             muffled <- TRUE
[13:35:30.936]                             break
[13:35:30.936]                           }
[13:35:30.936]                         }
[13:35:30.936]                       }
[13:35:30.936]                       invisible(muffled)
[13:35:30.936]                     }
[13:35:30.936]                     muffleCondition(cond, pattern = "^muffle")
[13:35:30.936]                   }
[13:35:30.936]                 }
[13:35:30.936]             }
[13:35:30.936]         }))
[13:35:30.936]     }, error = function(ex) {
[13:35:30.936]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:30.936]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:30.936]                 ...future.rng), started = ...future.startTime, 
[13:35:30.936]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:30.936]             version = "1.8"), class = "FutureResult")
[13:35:30.936]     }, finally = {
[13:35:30.936]         if (!identical(...future.workdir, getwd())) 
[13:35:30.936]             setwd(...future.workdir)
[13:35:30.936]         {
[13:35:30.936]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:30.936]                 ...future.oldOptions$nwarnings <- NULL
[13:35:30.936]             }
[13:35:30.936]             base::options(...future.oldOptions)
[13:35:30.936]             if (.Platform$OS.type == "windows") {
[13:35:30.936]                 old_names <- names(...future.oldEnvVars)
[13:35:30.936]                 envs <- base::Sys.getenv()
[13:35:30.936]                 names <- names(envs)
[13:35:30.936]                 common <- intersect(names, old_names)
[13:35:30.936]                 added <- setdiff(names, old_names)
[13:35:30.936]                 removed <- setdiff(old_names, names)
[13:35:30.936]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:30.936]                   envs[common]]
[13:35:30.936]                 NAMES <- toupper(changed)
[13:35:30.936]                 args <- list()
[13:35:30.936]                 for (kk in seq_along(NAMES)) {
[13:35:30.936]                   name <- changed[[kk]]
[13:35:30.936]                   NAME <- NAMES[[kk]]
[13:35:30.936]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:30.936]                     next
[13:35:30.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:30.936]                 }
[13:35:30.936]                 NAMES <- toupper(added)
[13:35:30.936]                 for (kk in seq_along(NAMES)) {
[13:35:30.936]                   name <- added[[kk]]
[13:35:30.936]                   NAME <- NAMES[[kk]]
[13:35:30.936]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:30.936]                     next
[13:35:30.936]                   args[[name]] <- ""
[13:35:30.936]                 }
[13:35:30.936]                 NAMES <- toupper(removed)
[13:35:30.936]                 for (kk in seq_along(NAMES)) {
[13:35:30.936]                   name <- removed[[kk]]
[13:35:30.936]                   NAME <- NAMES[[kk]]
[13:35:30.936]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:30.936]                     next
[13:35:30.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:30.936]                 }
[13:35:30.936]                 if (length(args) > 0) 
[13:35:30.936]                   base::do.call(base::Sys.setenv, args = args)
[13:35:30.936]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:30.936]             }
[13:35:30.936]             else {
[13:35:30.936]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:30.936]             }
[13:35:30.936]             {
[13:35:30.936]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:30.936]                   0L) {
[13:35:30.936]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:30.936]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:30.936]                   base::options(opts)
[13:35:30.936]                 }
[13:35:30.936]                 {
[13:35:30.936]                   {
[13:35:30.936]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:30.936]                     NULL
[13:35:30.936]                   }
[13:35:30.936]                   options(future.plan = NULL)
[13:35:30.936]                   if (is.na(NA_character_)) 
[13:35:30.936]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:30.936]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:30.936]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:30.936]                     .init = FALSE)
[13:35:30.936]                 }
[13:35:30.936]             }
[13:35:30.936]         }
[13:35:30.936]     })
[13:35:30.936]     if (FALSE) {
[13:35:30.936]         base::sink(type = "output", split = FALSE)
[13:35:30.936]         if (NA) {
[13:35:30.936]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:30.936]         }
[13:35:30.936]         else {
[13:35:30.936]             ...future.result["stdout"] <- base::list(NULL)
[13:35:30.936]         }
[13:35:30.936]         base::close(...future.stdout)
[13:35:30.936]         ...future.stdout <- NULL
[13:35:30.936]     }
[13:35:30.936]     ...future.result$conditions <- ...future.conditions
[13:35:30.936]     ...future.result$finished <- base::Sys.time()
[13:35:30.936]     ...future.result
[13:35:30.936] }
[13:35:30.939] assign_globals() ...
[13:35:30.939] List of 5
[13:35:30.939]  $ ...future.FUN            :function (x)  
[13:35:30.939]  $ future.call.arguments    : list()
[13:35:30.939]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:30.939]  $ ...future.elements_ii    :List of 1
[13:35:30.939]   ..$ : int 1
[13:35:30.939]  $ ...future.seeds_ii       : NULL
[13:35:30.939]  $ ...future.globals.maxSize: NULL
[13:35:30.939]  - attr(*, "where")=List of 5
[13:35:30.939]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:30.939]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:30.939]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:30.939]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:30.939]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:30.939]  - attr(*, "resolved")= logi FALSE
[13:35:30.939]  - attr(*, "total_size")= num 4720
[13:35:30.939]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:30.939]  - attr(*, "already-done")= logi TRUE
[13:35:30.943] - reassign environment for ‘...future.FUN’
[13:35:30.943] - copied ‘...future.FUN’ to environment
[13:35:30.943] - copied ‘future.call.arguments’ to environment
[13:35:30.943] - copied ‘...future.elements_ii’ to environment
[13:35:30.944] - copied ‘...future.seeds_ii’ to environment
[13:35:30.944] - copied ‘...future.globals.maxSize’ to environment
[13:35:30.944] assign_globals() ... done
[13:35:30.944] requestCore(): workers = 2
[13:35:30.946] MulticoreFuture started
[13:35:30.946] - Launch lazy future ... done
[13:35:30.946] run() for ‘MulticoreFuture’ ... done
[13:35:30.947] Created future:
[13:35:30.947] plan(): Setting new future strategy stack:
[13:35:30.947] List of future strategies:
[13:35:30.947] 1. sequential:
[13:35:30.947]    - args: function (..., envir = parent.frame())
[13:35:30.947]    - tweaked: FALSE
[13:35:30.947]    - call: NULL
[13:35:30.948] plan(): nbrOfWorkers() = 1
[13:35:30.947] MulticoreFuture:
[13:35:30.947] Label: ‘future_lapply-1’
[13:35:30.947] Expression:
[13:35:30.947] {
[13:35:30.947]     do.call(function(...) {
[13:35:30.947]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:30.947]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:30.947]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:30.947]             on.exit(options(oopts), add = TRUE)
[13:35:30.947]         }
[13:35:30.947]         {
[13:35:30.947]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:30.947]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:30.947]                 ...future.FUN(...future.X_jj, ...)
[13:35:30.947]             })
[13:35:30.947]         }
[13:35:30.947]     }, args = future.call.arguments)
[13:35:30.947] }
[13:35:30.947] Lazy evaluation: FALSE
[13:35:30.947] Asynchronous evaluation: TRUE
[13:35:30.947] Local evaluation: TRUE
[13:35:30.947] Environment: R_GlobalEnv
[13:35:30.947] Capture standard output: NA
[13:35:30.947] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:30.947] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:30.947] Packages: <none>
[13:35:30.947] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:30.947] Resolved: FALSE
[13:35:30.947] Value: <not collected>
[13:35:30.947] Conditions captured: <none>
[13:35:30.947] Early signaling: FALSE
[13:35:30.947] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:30.947] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:30.960] Chunk #1 of 2 ... DONE
[13:35:30.960] Chunk #2 of 2 ...
[13:35:30.960]  - Finding globals in 'X' for chunk #2 ...
[13:35:30.960] getGlobalsAndPackages() ...
[13:35:30.960] Searching for globals...
[13:35:30.961] 
[13:35:30.961] Searching for globals ... DONE
[13:35:30.961] - globals: [0] <none>
[13:35:30.961] getGlobalsAndPackages() ... DONE
[13:35:30.962]    + additional globals found: [n=0] 
[13:35:30.962]    + additional namespaces needed: [n=0] 
[13:35:30.962]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:30.962]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:30.962]  - seeds: <none>
[13:35:30.962]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:30.963] getGlobalsAndPackages() ...
[13:35:30.963] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:30.963] Resolving globals: FALSE
[13:35:30.963] Tweak future expression to call with '...' arguments ...
[13:35:30.963] {
[13:35:30.963]     do.call(function(...) {
[13:35:30.963]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:30.963]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:30.963]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:30.963]             on.exit(options(oopts), add = TRUE)
[13:35:30.963]         }
[13:35:30.963]         {
[13:35:30.963]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:30.963]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:30.963]                 ...future.FUN(...future.X_jj, ...)
[13:35:30.963]             })
[13:35:30.963]         }
[13:35:30.963]     }, args = future.call.arguments)
[13:35:30.963] }
[13:35:30.964] Tweak future expression to call with '...' arguments ... DONE
[13:35:30.964] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:30.965] 
[13:35:30.965] getGlobalsAndPackages() ... DONE
[13:35:30.965] run() for ‘Future’ ...
[13:35:30.965] - state: ‘created’
[13:35:30.966] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:30.971] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:30.971] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:30.971]   - Field: ‘label’
[13:35:30.971]   - Field: ‘local’
[13:35:30.971]   - Field: ‘owner’
[13:35:30.972]   - Field: ‘envir’
[13:35:30.972]   - Field: ‘workers’
[13:35:30.972]   - Field: ‘packages’
[13:35:30.972]   - Field: ‘gc’
[13:35:30.972]   - Field: ‘job’
[13:35:30.972]   - Field: ‘conditions’
[13:35:30.972]   - Field: ‘expr’
[13:35:30.973]   - Field: ‘uuid’
[13:35:30.973]   - Field: ‘seed’
[13:35:30.973]   - Field: ‘version’
[13:35:30.973]   - Field: ‘result’
[13:35:30.973]   - Field: ‘asynchronous’
[13:35:30.973]   - Field: ‘calls’
[13:35:30.974]   - Field: ‘globals’
[13:35:30.977]   - Field: ‘stdout’
[13:35:30.977]   - Field: ‘earlySignal’
[13:35:30.978]   - Field: ‘lazy’
[13:35:30.978]   - Field: ‘state’
[13:35:30.978] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:30.979] - Launch lazy future ...
[13:35:30.979] Packages needed by the future expression (n = 0): <none>
[13:35:30.980] Packages needed by future strategies (n = 0): <none>
[13:35:30.981] {
[13:35:30.981]     {
[13:35:30.981]         {
[13:35:30.981]             ...future.startTime <- base::Sys.time()
[13:35:30.981]             {
[13:35:30.981]                 {
[13:35:30.981]                   {
[13:35:30.981]                     {
[13:35:30.981]                       base::local({
[13:35:30.981]                         has_future <- base::requireNamespace("future", 
[13:35:30.981]                           quietly = TRUE)
[13:35:30.981]                         if (has_future) {
[13:35:30.981]                           ns <- base::getNamespace("future")
[13:35:30.981]                           version <- ns[[".package"]][["version"]]
[13:35:30.981]                           if (is.null(version)) 
[13:35:30.981]                             version <- utils::packageVersion("future")
[13:35:30.981]                         }
[13:35:30.981]                         else {
[13:35:30.981]                           version <- NULL
[13:35:30.981]                         }
[13:35:30.981]                         if (!has_future || version < "1.8.0") {
[13:35:30.981]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:30.981]                             "", base::R.version$version.string), 
[13:35:30.981]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:30.981]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:30.981]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:30.981]                               "release", "version")], collapse = " "), 
[13:35:30.981]                             hostname = base::Sys.info()[["nodename"]])
[13:35:30.981]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:30.981]                             info)
[13:35:30.981]                           info <- base::paste(info, collapse = "; ")
[13:35:30.981]                           if (!has_future) {
[13:35:30.981]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:30.981]                               info)
[13:35:30.981]                           }
[13:35:30.981]                           else {
[13:35:30.981]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:30.981]                               info, version)
[13:35:30.981]                           }
[13:35:30.981]                           base::stop(msg)
[13:35:30.981]                         }
[13:35:30.981]                       })
[13:35:30.981]                     }
[13:35:30.981]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:30.981]                     base::options(mc.cores = 1L)
[13:35:30.981]                   }
[13:35:30.981]                   ...future.strategy.old <- future::plan("list")
[13:35:30.981]                   options(future.plan = NULL)
[13:35:30.981]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:30.981]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:30.981]                 }
[13:35:30.981]                 ...future.workdir <- getwd()
[13:35:30.981]             }
[13:35:30.981]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:30.981]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:30.981]         }
[13:35:30.981]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:30.981]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:30.981]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:30.981]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:30.981]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:30.981]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:30.981]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:30.981]             base::names(...future.oldOptions))
[13:35:30.981]     }
[13:35:30.981]     if (TRUE) {
[13:35:30.981]     }
[13:35:30.981]     else {
[13:35:30.981]         if (NA) {
[13:35:30.981]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:30.981]                 open = "w")
[13:35:30.981]         }
[13:35:30.981]         else {
[13:35:30.981]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:30.981]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:30.981]         }
[13:35:30.981]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:30.981]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:30.981]             base::sink(type = "output", split = FALSE)
[13:35:30.981]             base::close(...future.stdout)
[13:35:30.981]         }, add = TRUE)
[13:35:30.981]     }
[13:35:30.981]     ...future.frame <- base::sys.nframe()
[13:35:30.981]     ...future.conditions <- base::list()
[13:35:30.981]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:30.981]     if (FALSE) {
[13:35:30.981]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:30.981]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:30.981]     }
[13:35:30.981]     ...future.result <- base::tryCatch({
[13:35:30.981]         base::withCallingHandlers({
[13:35:30.981]             ...future.value <- base::withVisible(base::local({
[13:35:30.981]                 withCallingHandlers({
[13:35:30.981]                   {
[13:35:30.981]                     do.call(function(...) {
[13:35:30.981]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:30.981]                       if (!identical(...future.globals.maxSize.org, 
[13:35:30.981]                         ...future.globals.maxSize)) {
[13:35:30.981]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:30.981]                         on.exit(options(oopts), add = TRUE)
[13:35:30.981]                       }
[13:35:30.981]                       {
[13:35:30.981]                         lapply(seq_along(...future.elements_ii), 
[13:35:30.981]                           FUN = function(jj) {
[13:35:30.981]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:30.981]                             ...future.FUN(...future.X_jj, ...)
[13:35:30.981]                           })
[13:35:30.981]                       }
[13:35:30.981]                     }, args = future.call.arguments)
[13:35:30.981]                   }
[13:35:30.981]                 }, immediateCondition = function(cond) {
[13:35:30.981]                   save_rds <- function (object, pathname, ...) 
[13:35:30.981]                   {
[13:35:30.981]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:30.981]                     if (file_test("-f", pathname_tmp)) {
[13:35:30.981]                       fi_tmp <- file.info(pathname_tmp)
[13:35:30.981]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:30.981]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:30.981]                         fi_tmp[["mtime"]])
[13:35:30.981]                     }
[13:35:30.981]                     tryCatch({
[13:35:30.981]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:30.981]                     }, error = function(ex) {
[13:35:30.981]                       msg <- conditionMessage(ex)
[13:35:30.981]                       fi_tmp <- file.info(pathname_tmp)
[13:35:30.981]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:30.981]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:30.981]                         fi_tmp[["mtime"]], msg)
[13:35:30.981]                       ex$message <- msg
[13:35:30.981]                       stop(ex)
[13:35:30.981]                     })
[13:35:30.981]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:30.981]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:30.981]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:30.981]                       fi_tmp <- file.info(pathname_tmp)
[13:35:30.981]                       fi <- file.info(pathname)
[13:35:30.981]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:30.981]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:30.981]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:30.981]                         fi[["size"]], fi[["mtime"]])
[13:35:30.981]                       stop(msg)
[13:35:30.981]                     }
[13:35:30.981]                     invisible(pathname)
[13:35:30.981]                   }
[13:35:30.981]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:30.981]                     rootPath = tempdir()) 
[13:35:30.981]                   {
[13:35:30.981]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:30.981]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:30.981]                       tmpdir = path, fileext = ".rds")
[13:35:30.981]                     save_rds(obj, file)
[13:35:30.981]                   }
[13:35:30.981]                   saveImmediateCondition(cond, path = "/tmp/RtmpghgvGN/.future/immediateConditions")
[13:35:30.981]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:30.981]                   {
[13:35:30.981]                     inherits <- base::inherits
[13:35:30.981]                     invokeRestart <- base::invokeRestart
[13:35:30.981]                     is.null <- base::is.null
[13:35:30.981]                     muffled <- FALSE
[13:35:30.981]                     if (inherits(cond, "message")) {
[13:35:30.981]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:30.981]                       if (muffled) 
[13:35:30.981]                         invokeRestart("muffleMessage")
[13:35:30.981]                     }
[13:35:30.981]                     else if (inherits(cond, "warning")) {
[13:35:30.981]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:30.981]                       if (muffled) 
[13:35:30.981]                         invokeRestart("muffleWarning")
[13:35:30.981]                     }
[13:35:30.981]                     else if (inherits(cond, "condition")) {
[13:35:30.981]                       if (!is.null(pattern)) {
[13:35:30.981]                         computeRestarts <- base::computeRestarts
[13:35:30.981]                         grepl <- base::grepl
[13:35:30.981]                         restarts <- computeRestarts(cond)
[13:35:30.981]                         for (restart in restarts) {
[13:35:30.981]                           name <- restart$name
[13:35:30.981]                           if (is.null(name)) 
[13:35:30.981]                             next
[13:35:30.981]                           if (!grepl(pattern, name)) 
[13:35:30.981]                             next
[13:35:30.981]                           invokeRestart(restart)
[13:35:30.981]                           muffled <- TRUE
[13:35:30.981]                           break
[13:35:30.981]                         }
[13:35:30.981]                       }
[13:35:30.981]                     }
[13:35:30.981]                     invisible(muffled)
[13:35:30.981]                   }
[13:35:30.981]                   muffleCondition(cond)
[13:35:30.981]                 })
[13:35:30.981]             }))
[13:35:30.981]             future::FutureResult(value = ...future.value$value, 
[13:35:30.981]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:30.981]                   ...future.rng), globalenv = if (FALSE) 
[13:35:30.981]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:30.981]                     ...future.globalenv.names))
[13:35:30.981]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:30.981]         }, condition = base::local({
[13:35:30.981]             c <- base::c
[13:35:30.981]             inherits <- base::inherits
[13:35:30.981]             invokeRestart <- base::invokeRestart
[13:35:30.981]             length <- base::length
[13:35:30.981]             list <- base::list
[13:35:30.981]             seq.int <- base::seq.int
[13:35:30.981]             signalCondition <- base::signalCondition
[13:35:30.981]             sys.calls <- base::sys.calls
[13:35:30.981]             `[[` <- base::`[[`
[13:35:30.981]             `+` <- base::`+`
[13:35:30.981]             `<<-` <- base::`<<-`
[13:35:30.981]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:30.981]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:30.981]                   3L)]
[13:35:30.981]             }
[13:35:30.981]             function(cond) {
[13:35:30.981]                 is_error <- inherits(cond, "error")
[13:35:30.981]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:30.981]                   NULL)
[13:35:30.981]                 if (is_error) {
[13:35:30.981]                   sessionInformation <- function() {
[13:35:30.981]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:30.981]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:30.981]                       search = base::search(), system = base::Sys.info())
[13:35:30.981]                   }
[13:35:30.981]                   ...future.conditions[[length(...future.conditions) + 
[13:35:30.981]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:30.981]                     cond$call), session = sessionInformation(), 
[13:35:30.981]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:30.981]                   signalCondition(cond)
[13:35:30.981]                 }
[13:35:30.981]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:30.981]                 "immediateCondition"))) {
[13:35:30.981]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:30.981]                   ...future.conditions[[length(...future.conditions) + 
[13:35:30.981]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:30.981]                   if (TRUE && !signal) {
[13:35:30.981]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:30.981]                     {
[13:35:30.981]                       inherits <- base::inherits
[13:35:30.981]                       invokeRestart <- base::invokeRestart
[13:35:30.981]                       is.null <- base::is.null
[13:35:30.981]                       muffled <- FALSE
[13:35:30.981]                       if (inherits(cond, "message")) {
[13:35:30.981]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:30.981]                         if (muffled) 
[13:35:30.981]                           invokeRestart("muffleMessage")
[13:35:30.981]                       }
[13:35:30.981]                       else if (inherits(cond, "warning")) {
[13:35:30.981]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:30.981]                         if (muffled) 
[13:35:30.981]                           invokeRestart("muffleWarning")
[13:35:30.981]                       }
[13:35:30.981]                       else if (inherits(cond, "condition")) {
[13:35:30.981]                         if (!is.null(pattern)) {
[13:35:30.981]                           computeRestarts <- base::computeRestarts
[13:35:30.981]                           grepl <- base::grepl
[13:35:30.981]                           restarts <- computeRestarts(cond)
[13:35:30.981]                           for (restart in restarts) {
[13:35:30.981]                             name <- restart$name
[13:35:30.981]                             if (is.null(name)) 
[13:35:30.981]                               next
[13:35:30.981]                             if (!grepl(pattern, name)) 
[13:35:30.981]                               next
[13:35:30.981]                             invokeRestart(restart)
[13:35:30.981]                             muffled <- TRUE
[13:35:30.981]                             break
[13:35:30.981]                           }
[13:35:30.981]                         }
[13:35:30.981]                       }
[13:35:30.981]                       invisible(muffled)
[13:35:30.981]                     }
[13:35:30.981]                     muffleCondition(cond, pattern = "^muffle")
[13:35:30.981]                   }
[13:35:30.981]                 }
[13:35:30.981]                 else {
[13:35:30.981]                   if (TRUE) {
[13:35:30.981]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:30.981]                     {
[13:35:30.981]                       inherits <- base::inherits
[13:35:30.981]                       invokeRestart <- base::invokeRestart
[13:35:30.981]                       is.null <- base::is.null
[13:35:30.981]                       muffled <- FALSE
[13:35:30.981]                       if (inherits(cond, "message")) {
[13:35:30.981]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:30.981]                         if (muffled) 
[13:35:30.981]                           invokeRestart("muffleMessage")
[13:35:30.981]                       }
[13:35:30.981]                       else if (inherits(cond, "warning")) {
[13:35:30.981]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:30.981]                         if (muffled) 
[13:35:30.981]                           invokeRestart("muffleWarning")
[13:35:30.981]                       }
[13:35:30.981]                       else if (inherits(cond, "condition")) {
[13:35:30.981]                         if (!is.null(pattern)) {
[13:35:30.981]                           computeRestarts <- base::computeRestarts
[13:35:30.981]                           grepl <- base::grepl
[13:35:30.981]                           restarts <- computeRestarts(cond)
[13:35:30.981]                           for (restart in restarts) {
[13:35:30.981]                             name <- restart$name
[13:35:30.981]                             if (is.null(name)) 
[13:35:30.981]                               next
[13:35:30.981]                             if (!grepl(pattern, name)) 
[13:35:30.981]                               next
[13:35:30.981]                             invokeRestart(restart)
[13:35:30.981]                             muffled <- TRUE
[13:35:30.981]                             break
[13:35:30.981]                           }
[13:35:30.981]                         }
[13:35:30.981]                       }
[13:35:30.981]                       invisible(muffled)
[13:35:30.981]                     }
[13:35:30.981]                     muffleCondition(cond, pattern = "^muffle")
[13:35:30.981]                   }
[13:35:30.981]                 }
[13:35:30.981]             }
[13:35:30.981]         }))
[13:35:30.981]     }, error = function(ex) {
[13:35:30.981]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:30.981]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:30.981]                 ...future.rng), started = ...future.startTime, 
[13:35:30.981]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:30.981]             version = "1.8"), class = "FutureResult")
[13:35:30.981]     }, finally = {
[13:35:30.981]         if (!identical(...future.workdir, getwd())) 
[13:35:30.981]             setwd(...future.workdir)
[13:35:30.981]         {
[13:35:30.981]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:30.981]                 ...future.oldOptions$nwarnings <- NULL
[13:35:30.981]             }
[13:35:30.981]             base::options(...future.oldOptions)
[13:35:30.981]             if (.Platform$OS.type == "windows") {
[13:35:30.981]                 old_names <- names(...future.oldEnvVars)
[13:35:30.981]                 envs <- base::Sys.getenv()
[13:35:30.981]                 names <- names(envs)
[13:35:30.981]                 common <- intersect(names, old_names)
[13:35:30.981]                 added <- setdiff(names, old_names)
[13:35:30.981]                 removed <- setdiff(old_names, names)
[13:35:30.981]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:30.981]                   envs[common]]
[13:35:30.981]                 NAMES <- toupper(changed)
[13:35:30.981]                 args <- list()
[13:35:30.981]                 for (kk in seq_along(NAMES)) {
[13:35:30.981]                   name <- changed[[kk]]
[13:35:30.981]                   NAME <- NAMES[[kk]]
[13:35:30.981]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:30.981]                     next
[13:35:30.981]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:30.981]                 }
[13:35:30.981]                 NAMES <- toupper(added)
[13:35:30.981]                 for (kk in seq_along(NAMES)) {
[13:35:30.981]                   name <- added[[kk]]
[13:35:30.981]                   NAME <- NAMES[[kk]]
[13:35:30.981]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:30.981]                     next
[13:35:30.981]                   args[[name]] <- ""
[13:35:30.981]                 }
[13:35:30.981]                 NAMES <- toupper(removed)
[13:35:30.981]                 for (kk in seq_along(NAMES)) {
[13:35:30.981]                   name <- removed[[kk]]
[13:35:30.981]                   NAME <- NAMES[[kk]]
[13:35:30.981]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:30.981]                     next
[13:35:30.981]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:30.981]                 }
[13:35:30.981]                 if (length(args) > 0) 
[13:35:30.981]                   base::do.call(base::Sys.setenv, args = args)
[13:35:30.981]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:30.981]             }
[13:35:30.981]             else {
[13:35:30.981]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:30.981]             }
[13:35:30.981]             {
[13:35:30.981]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:30.981]                   0L) {
[13:35:30.981]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:30.981]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:30.981]                   base::options(opts)
[13:35:30.981]                 }
[13:35:30.981]                 {
[13:35:30.981]                   {
[13:35:30.981]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:30.981]                     NULL
[13:35:30.981]                   }
[13:35:30.981]                   options(future.plan = NULL)
[13:35:30.981]                   if (is.na(NA_character_)) 
[13:35:30.981]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:30.981]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:30.981]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:30.981]                     .init = FALSE)
[13:35:30.981]                 }
[13:35:30.981]             }
[13:35:30.981]         }
[13:35:30.981]     })
[13:35:30.981]     if (FALSE) {
[13:35:30.981]         base::sink(type = "output", split = FALSE)
[13:35:30.981]         if (NA) {
[13:35:30.981]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:30.981]         }
[13:35:30.981]         else {
[13:35:30.981]             ...future.result["stdout"] <- base::list(NULL)
[13:35:30.981]         }
[13:35:30.981]         base::close(...future.stdout)
[13:35:30.981]         ...future.stdout <- NULL
[13:35:30.981]     }
[13:35:30.981]     ...future.result$conditions <- ...future.conditions
[13:35:30.981]     ...future.result$finished <- base::Sys.time()
[13:35:30.981]     ...future.result
[13:35:30.981] }
[13:35:30.984] assign_globals() ...
[13:35:30.984] List of 5
[13:35:30.984]  $ ...future.FUN            :function (x)  
[13:35:30.984]  $ future.call.arguments    : list()
[13:35:30.984]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:30.984]  $ ...future.elements_ii    :List of 1
[13:35:30.984]   ..$ : int 0
[13:35:30.984]  $ ...future.seeds_ii       : NULL
[13:35:30.984]  $ ...future.globals.maxSize: NULL
[13:35:30.984]  - attr(*, "where")=List of 5
[13:35:30.984]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:30.984]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:30.984]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:30.984]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:30.984]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:30.984]  - attr(*, "resolved")= logi FALSE
[13:35:30.984]  - attr(*, "total_size")= num 4720
[13:35:30.984]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:30.984]  - attr(*, "already-done")= logi TRUE
[13:35:30.992] - reassign environment for ‘...future.FUN’
[13:35:30.992] - copied ‘...future.FUN’ to environment
[13:35:30.992] - copied ‘future.call.arguments’ to environment
[13:35:30.992] - copied ‘...future.elements_ii’ to environment
[13:35:30.992] - copied ‘...future.seeds_ii’ to environment
[13:35:30.992] - copied ‘...future.globals.maxSize’ to environment
[13:35:30.993] assign_globals() ... done
[13:35:30.993] requestCore(): workers = 2
[13:35:30.995] MulticoreFuture started
[13:35:30.995] - Launch lazy future ... done
[13:35:30.995] run() for ‘MulticoreFuture’ ... done
[13:35:30.996] Created future:
[13:35:30.996] plan(): Setting new future strategy stack:
[13:35:30.996] List of future strategies:
[13:35:30.996] 1. sequential:
[13:35:30.996]    - args: function (..., envir = parent.frame())
[13:35:30.996]    - tweaked: FALSE
[13:35:30.996]    - call: NULL
[13:35:30.997] plan(): nbrOfWorkers() = 1
[13:35:30.999] plan(): Setting new future strategy stack:
[13:35:30.999] List of future strategies:
[13:35:30.999] 1. multicore:
[13:35:30.999]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:30.999]    - tweaked: FALSE
[13:35:30.999]    - call: plan(strategy)
[13:35:31.004] plan(): nbrOfWorkers() = 2
[13:35:30.996] MulticoreFuture:
[13:35:30.996] Label: ‘future_lapply-2’
[13:35:30.996] Expression:
[13:35:30.996] {
[13:35:30.996]     do.call(function(...) {
[13:35:30.996]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:30.996]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:30.996]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:30.996]             on.exit(options(oopts), add = TRUE)
[13:35:30.996]         }
[13:35:30.996]         {
[13:35:30.996]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:30.996]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:30.996]                 ...future.FUN(...future.X_jj, ...)
[13:35:30.996]             })
[13:35:30.996]         }
[13:35:30.996]     }, args = future.call.arguments)
[13:35:30.996] }
[13:35:30.996] Lazy evaluation: FALSE
[13:35:30.996] Asynchronous evaluation: TRUE
[13:35:30.996] Local evaluation: TRUE
[13:35:30.996] Environment: R_GlobalEnv
[13:35:30.996] Capture standard output: NA
[13:35:30.996] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:30.996] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:30.996] Packages: <none>
[13:35:30.996] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:30.996] Resolved: TRUE
[13:35:30.996] Value: <not collected>
[13:35:30.996] Conditions captured: <none>
[13:35:30.996] Early signaling: FALSE
[13:35:30.996] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:30.996] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:31.005] Chunk #2 of 2 ... DONE
[13:35:31.005] Launching 2 futures (chunks) ... DONE
[13:35:31.006] Resolving 2 futures (chunks) ...
[13:35:31.006] resolve() on list ...
[13:35:31.006]  recursive: 0
[13:35:31.006]  length: 2
[13:35:31.006] 
[13:35:31.017] Future #2
[13:35:31.017] result() for MulticoreFuture ...
[13:35:31.018] result() for MulticoreFuture ...
[13:35:31.018] result() for MulticoreFuture ... done
[13:35:31.019] result() for MulticoreFuture ... done
[13:35:31.019] result() for MulticoreFuture ...
[13:35:31.019] result() for MulticoreFuture ... done
[13:35:31.019] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:35:31.019] - nx: 2
[13:35:31.019] - relay: TRUE
[13:35:31.020] - stdout: TRUE
[13:35:31.020] - signal: TRUE
[13:35:31.020] - resignal: FALSE
[13:35:31.020] - force: TRUE
[13:35:31.020] - relayed: [n=2] FALSE, FALSE
[13:35:31.020] - queued futures: [n=2] FALSE, FALSE
[13:35:31.020]  - until=1
[13:35:31.020]  - relaying element #1
[13:35:31.021] - relayed: [n=2] FALSE, FALSE
[13:35:31.021] - queued futures: [n=2] FALSE, TRUE
[13:35:31.021] signalConditionsASAP(NULL, pos=2) ... done
[13:35:31.021]  length: 1 (resolved future 2)
[13:35:31.451] plan(): Setting new future strategy stack:
[13:35:31.451] List of future strategies:
[13:35:31.451] 1. multicore:
[13:35:31.451]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:31.451]    - tweaked: FALSE
[13:35:31.451]    - call: plan(strategy)
[13:35:31.456] plan(): nbrOfWorkers() = 2
[13:35:31.459] Future #1
[13:35:31.459] result() for MulticoreFuture ...
[13:35:31.460] result() for MulticoreFuture ...
[13:35:31.460] result() for MulticoreFuture ... done
[13:35:31.460] result() for MulticoreFuture ... done
[13:35:31.461] result() for MulticoreFuture ...
[13:35:31.461] result() for MulticoreFuture ... done
[13:35:31.461] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:35:31.461] - nx: 2
[13:35:31.461] - relay: TRUE
[13:35:31.461] - stdout: TRUE
[13:35:31.461] - signal: TRUE
[13:35:31.461] - resignal: FALSE
[13:35:31.461] - force: TRUE
[13:35:31.462] - relayed: [n=2] FALSE, FALSE
[13:35:31.462] - queued futures: [n=2] FALSE, TRUE
[13:35:31.462]  - until=1
[13:35:31.462]  - relaying element #1
[13:35:31.462] result() for MulticoreFuture ...
[13:35:31.462] result() for MulticoreFuture ... done
[13:35:31.462] result() for MulticoreFuture ...
[13:35:31.462] result() for MulticoreFuture ... done
[13:35:31.463] result() for MulticoreFuture ...
[13:35:31.463] result() for MulticoreFuture ... done
[13:35:31.463] result() for MulticoreFuture ...
[13:35:31.463] result() for MulticoreFuture ... done
[13:35:31.463] - relayed: [n=2] TRUE, FALSE
[13:35:31.463] - queued futures: [n=2] TRUE, TRUE
[13:35:31.463] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:35:31.464]  length: 0 (resolved future 1)
[13:35:31.464] Relaying remaining futures
[13:35:31.464] signalConditionsASAP(NULL, pos=0) ...
[13:35:31.464] - nx: 2
[13:35:31.464] - relay: TRUE
[13:35:31.464] - stdout: TRUE
[13:35:31.464] - signal: TRUE
[13:35:31.464] - resignal: FALSE
[13:35:31.464] - force: TRUE
[13:35:31.464] - relayed: [n=2] TRUE, FALSE
[13:35:31.465] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:31.465]  - relaying element #2
[13:35:31.465] result() for MulticoreFuture ...
[13:35:31.465] result() for MulticoreFuture ... done
[13:35:31.465] result() for MulticoreFuture ...
[13:35:31.465] result() for MulticoreFuture ... done
[13:35:31.465] result() for MulticoreFuture ...
[13:35:31.466] result() for MulticoreFuture ... done
[13:35:31.466] result() for MulticoreFuture ...
[13:35:31.466] result() for MulticoreFuture ... done
[13:35:31.466] - relayed: [n=2] TRUE, TRUE
[13:35:31.466] - queued futures: [n=2] TRUE, TRUE
[13:35:31.466] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[13:35:31.466] resolve() on list ... DONE
[13:35:31.466] result() for MulticoreFuture ...
[13:35:31.466] result() for MulticoreFuture ... done
[13:35:31.467] result() for MulticoreFuture ...
[13:35:31.467] result() for MulticoreFuture ... done
[13:35:31.467] result() for MulticoreFuture ...
[13:35:31.467] result() for MulticoreFuture ... done
[13:35:31.467] result() for MulticoreFuture ...
[13:35:31.467] result() for MulticoreFuture ... done
[13:35:31.467]  - Number of value chunks collected: 2
[13:35:31.467] Resolving 2 futures (chunks) ... DONE
[13:35:31.467] Reducing values from 2 chunks ...
[13:35:31.468]  - Number of values collected after concatenation: 2
[13:35:31.470]  - Number of values expected: 2
[13:35:31.471] Reducing values from 2 chunks ... DONE
[13:35:31.471] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[13:35:31.472] future_mapply() ...
[13:35:31.476] Number of chunks: 2
[13:35:31.476] getGlobalsAndPackagesXApply() ...
[13:35:31.476]  - future.globals: TRUE
[13:35:31.476] getGlobalsAndPackages() ...
[13:35:31.477] Searching for globals...
[13:35:31.479] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:35:31.479] Searching for globals ... DONE
[13:35:31.479] Resolving globals: FALSE
[13:35:31.480] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:35:31.480] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:35:31.480] - globals: [1] ‘FUN’
[13:35:31.480] 
[13:35:31.480] getGlobalsAndPackages() ... DONE
[13:35:31.481]  - globals found/used: [n=1] ‘FUN’
[13:35:31.481]  - needed namespaces: [n=0] 
[13:35:31.481] Finding globals ... DONE
[13:35:31.481] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:35:31.481] List of 2
[13:35:31.481]  $ ...future.FUN:function (x, y)  
[13:35:31.481]  $ MoreArgs     : NULL
[13:35:31.481]  - attr(*, "where")=List of 2
[13:35:31.481]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:31.481]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:35:31.481]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:31.481]  - attr(*, "resolved")= logi FALSE
[13:35:31.481]  - attr(*, "total_size")= num NA
[13:35:31.484] Packages to be attached in all futures: [n=0] 
[13:35:31.484] getGlobalsAndPackagesXApply() ... DONE
[13:35:31.484] Number of futures (= number of chunks): 2
[13:35:31.485] Launching 2 futures (chunks) ...
[13:35:31.485] Chunk #1 of 2 ...
[13:35:31.485]  - Finding globals in '...' for chunk #1 ...
[13:35:31.485] getGlobalsAndPackages() ...
[13:35:31.485] Searching for globals...
[13:35:31.485] 
[13:35:31.485] Searching for globals ... DONE
[13:35:31.486] - globals: [0] <none>
[13:35:31.486] getGlobalsAndPackages() ... DONE
[13:35:31.486]    + additional globals found: [n=0] 
[13:35:31.486]    + additional namespaces needed: [n=0] 
[13:35:31.486]  - Finding globals in '...' for chunk #1 ... DONE
[13:35:31.486]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:31.486]  - seeds: <none>
[13:35:31.486]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:31.486] getGlobalsAndPackages() ...
[13:35:31.486] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:31.487] Resolving globals: FALSE
[13:35:31.487] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:35:31.488] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:35:31.488] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:31.488] 
[13:35:31.488] getGlobalsAndPackages() ... DONE
[13:35:31.488] run() for ‘Future’ ...
[13:35:31.488] - state: ‘created’
[13:35:31.488] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:31.492] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:31.492] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:31.492]   - Field: ‘label’
[13:35:31.492]   - Field: ‘local’
[13:35:31.492]   - Field: ‘owner’
[13:35:31.493]   - Field: ‘envir’
[13:35:31.493]   - Field: ‘workers’
[13:35:31.493]   - Field: ‘packages’
[13:35:31.493]   - Field: ‘gc’
[13:35:31.493]   - Field: ‘job’
[13:35:31.493]   - Field: ‘conditions’
[13:35:31.493]   - Field: ‘expr’
[13:35:31.493]   - Field: ‘uuid’
[13:35:31.493]   - Field: ‘seed’
[13:35:31.493]   - Field: ‘version’
[13:35:31.493]   - Field: ‘result’
[13:35:31.494]   - Field: ‘asynchronous’
[13:35:31.494]   - Field: ‘calls’
[13:35:31.494]   - Field: ‘globals’
[13:35:31.494]   - Field: ‘stdout’
[13:35:31.494]   - Field: ‘earlySignal’
[13:35:31.494]   - Field: ‘lazy’
[13:35:31.494]   - Field: ‘state’
[13:35:31.494] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:31.494] - Launch lazy future ...
[13:35:31.495] Packages needed by the future expression (n = 0): <none>
[13:35:31.495] Packages needed by future strategies (n = 0): <none>
[13:35:31.495] {
[13:35:31.495]     {
[13:35:31.495]         {
[13:35:31.495]             ...future.startTime <- base::Sys.time()
[13:35:31.495]             {
[13:35:31.495]                 {
[13:35:31.495]                   {
[13:35:31.495]                     {
[13:35:31.495]                       base::local({
[13:35:31.495]                         has_future <- base::requireNamespace("future", 
[13:35:31.495]                           quietly = TRUE)
[13:35:31.495]                         if (has_future) {
[13:35:31.495]                           ns <- base::getNamespace("future")
[13:35:31.495]                           version <- ns[[".package"]][["version"]]
[13:35:31.495]                           if (is.null(version)) 
[13:35:31.495]                             version <- utils::packageVersion("future")
[13:35:31.495]                         }
[13:35:31.495]                         else {
[13:35:31.495]                           version <- NULL
[13:35:31.495]                         }
[13:35:31.495]                         if (!has_future || version < "1.8.0") {
[13:35:31.495]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:31.495]                             "", base::R.version$version.string), 
[13:35:31.495]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:31.495]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:31.495]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:31.495]                               "release", "version")], collapse = " "), 
[13:35:31.495]                             hostname = base::Sys.info()[["nodename"]])
[13:35:31.495]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:31.495]                             info)
[13:35:31.495]                           info <- base::paste(info, collapse = "; ")
[13:35:31.495]                           if (!has_future) {
[13:35:31.495]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:31.495]                               info)
[13:35:31.495]                           }
[13:35:31.495]                           else {
[13:35:31.495]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:31.495]                               info, version)
[13:35:31.495]                           }
[13:35:31.495]                           base::stop(msg)
[13:35:31.495]                         }
[13:35:31.495]                       })
[13:35:31.495]                     }
[13:35:31.495]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:31.495]                     base::options(mc.cores = 1L)
[13:35:31.495]                   }
[13:35:31.495]                   ...future.strategy.old <- future::plan("list")
[13:35:31.495]                   options(future.plan = NULL)
[13:35:31.495]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:31.495]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:31.495]                 }
[13:35:31.495]                 ...future.workdir <- getwd()
[13:35:31.495]             }
[13:35:31.495]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:31.495]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:31.495]         }
[13:35:31.495]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:31.495]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:31.495]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:31.495]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:31.495]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:31.495]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:31.495]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:31.495]             base::names(...future.oldOptions))
[13:35:31.495]     }
[13:35:31.495]     if (FALSE) {
[13:35:31.495]     }
[13:35:31.495]     else {
[13:35:31.495]         if (FALSE) {
[13:35:31.495]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:31.495]                 open = "w")
[13:35:31.495]         }
[13:35:31.495]         else {
[13:35:31.495]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:31.495]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:31.495]         }
[13:35:31.495]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:31.495]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:31.495]             base::sink(type = "output", split = FALSE)
[13:35:31.495]             base::close(...future.stdout)
[13:35:31.495]         }, add = TRUE)
[13:35:31.495]     }
[13:35:31.495]     ...future.frame <- base::sys.nframe()
[13:35:31.495]     ...future.conditions <- base::list()
[13:35:31.495]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:31.495]     if (FALSE) {
[13:35:31.495]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:31.495]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:31.495]     }
[13:35:31.495]     ...future.result <- base::tryCatch({
[13:35:31.495]         base::withCallingHandlers({
[13:35:31.495]             ...future.value <- base::withVisible(base::local({
[13:35:31.495]                 withCallingHandlers({
[13:35:31.495]                   {
[13:35:31.495]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:31.495]                     if (!identical(...future.globals.maxSize.org, 
[13:35:31.495]                       ...future.globals.maxSize)) {
[13:35:31.495]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:31.495]                       on.exit(options(oopts), add = TRUE)
[13:35:31.495]                     }
[13:35:31.495]                     {
[13:35:31.495]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:31.495]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:35:31.495]                         USE.NAMES = FALSE)
[13:35:31.495]                       do.call(mapply, args = args)
[13:35:31.495]                     }
[13:35:31.495]                   }
[13:35:31.495]                 }, immediateCondition = function(cond) {
[13:35:31.495]                   save_rds <- function (object, pathname, ...) 
[13:35:31.495]                   {
[13:35:31.495]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:31.495]                     if (file_test("-f", pathname_tmp)) {
[13:35:31.495]                       fi_tmp <- file.info(pathname_tmp)
[13:35:31.495]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:31.495]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:31.495]                         fi_tmp[["mtime"]])
[13:35:31.495]                     }
[13:35:31.495]                     tryCatch({
[13:35:31.495]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:31.495]                     }, error = function(ex) {
[13:35:31.495]                       msg <- conditionMessage(ex)
[13:35:31.495]                       fi_tmp <- file.info(pathname_tmp)
[13:35:31.495]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:31.495]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:31.495]                         fi_tmp[["mtime"]], msg)
[13:35:31.495]                       ex$message <- msg
[13:35:31.495]                       stop(ex)
[13:35:31.495]                     })
[13:35:31.495]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:31.495]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:31.495]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:31.495]                       fi_tmp <- file.info(pathname_tmp)
[13:35:31.495]                       fi <- file.info(pathname)
[13:35:31.495]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:31.495]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:31.495]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:31.495]                         fi[["size"]], fi[["mtime"]])
[13:35:31.495]                       stop(msg)
[13:35:31.495]                     }
[13:35:31.495]                     invisible(pathname)
[13:35:31.495]                   }
[13:35:31.495]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:31.495]                     rootPath = tempdir()) 
[13:35:31.495]                   {
[13:35:31.495]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:31.495]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:31.495]                       tmpdir = path, fileext = ".rds")
[13:35:31.495]                     save_rds(obj, file)
[13:35:31.495]                   }
[13:35:31.495]                   saveImmediateCondition(cond, path = "/tmp/RtmpghgvGN/.future/immediateConditions")
[13:35:31.495]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:31.495]                   {
[13:35:31.495]                     inherits <- base::inherits
[13:35:31.495]                     invokeRestart <- base::invokeRestart
[13:35:31.495]                     is.null <- base::is.null
[13:35:31.495]                     muffled <- FALSE
[13:35:31.495]                     if (inherits(cond, "message")) {
[13:35:31.495]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:31.495]                       if (muffled) 
[13:35:31.495]                         invokeRestart("muffleMessage")
[13:35:31.495]                     }
[13:35:31.495]                     else if (inherits(cond, "warning")) {
[13:35:31.495]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:31.495]                       if (muffled) 
[13:35:31.495]                         invokeRestart("muffleWarning")
[13:35:31.495]                     }
[13:35:31.495]                     else if (inherits(cond, "condition")) {
[13:35:31.495]                       if (!is.null(pattern)) {
[13:35:31.495]                         computeRestarts <- base::computeRestarts
[13:35:31.495]                         grepl <- base::grepl
[13:35:31.495]                         restarts <- computeRestarts(cond)
[13:35:31.495]                         for (restart in restarts) {
[13:35:31.495]                           name <- restart$name
[13:35:31.495]                           if (is.null(name)) 
[13:35:31.495]                             next
[13:35:31.495]                           if (!grepl(pattern, name)) 
[13:35:31.495]                             next
[13:35:31.495]                           invokeRestart(restart)
[13:35:31.495]                           muffled <- TRUE
[13:35:31.495]                           break
[13:35:31.495]                         }
[13:35:31.495]                       }
[13:35:31.495]                     }
[13:35:31.495]                     invisible(muffled)
[13:35:31.495]                   }
[13:35:31.495]                   muffleCondition(cond)
[13:35:31.495]                 })
[13:35:31.495]             }))
[13:35:31.495]             future::FutureResult(value = ...future.value$value, 
[13:35:31.495]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:31.495]                   ...future.rng), globalenv = if (FALSE) 
[13:35:31.495]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:31.495]                     ...future.globalenv.names))
[13:35:31.495]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:31.495]         }, condition = base::local({
[13:35:31.495]             c <- base::c
[13:35:31.495]             inherits <- base::inherits
[13:35:31.495]             invokeRestart <- base::invokeRestart
[13:35:31.495]             length <- base::length
[13:35:31.495]             list <- base::list
[13:35:31.495]             seq.int <- base::seq.int
[13:35:31.495]             signalCondition <- base::signalCondition
[13:35:31.495]             sys.calls <- base::sys.calls
[13:35:31.495]             `[[` <- base::`[[`
[13:35:31.495]             `+` <- base::`+`
[13:35:31.495]             `<<-` <- base::`<<-`
[13:35:31.495]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:31.495]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:31.495]                   3L)]
[13:35:31.495]             }
[13:35:31.495]             function(cond) {
[13:35:31.495]                 is_error <- inherits(cond, "error")
[13:35:31.495]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:31.495]                   NULL)
[13:35:31.495]                 if (is_error) {
[13:35:31.495]                   sessionInformation <- function() {
[13:35:31.495]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:31.495]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:31.495]                       search = base::search(), system = base::Sys.info())
[13:35:31.495]                   }
[13:35:31.495]                   ...future.conditions[[length(...future.conditions) + 
[13:35:31.495]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:31.495]                     cond$call), session = sessionInformation(), 
[13:35:31.495]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:31.495]                   signalCondition(cond)
[13:35:31.495]                 }
[13:35:31.495]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:31.495]                 "immediateCondition"))) {
[13:35:31.495]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:31.495]                   ...future.conditions[[length(...future.conditions) + 
[13:35:31.495]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:31.495]                   if (TRUE && !signal) {
[13:35:31.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:31.495]                     {
[13:35:31.495]                       inherits <- base::inherits
[13:35:31.495]                       invokeRestart <- base::invokeRestart
[13:35:31.495]                       is.null <- base::is.null
[13:35:31.495]                       muffled <- FALSE
[13:35:31.495]                       if (inherits(cond, "message")) {
[13:35:31.495]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:31.495]                         if (muffled) 
[13:35:31.495]                           invokeRestart("muffleMessage")
[13:35:31.495]                       }
[13:35:31.495]                       else if (inherits(cond, "warning")) {
[13:35:31.495]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:31.495]                         if (muffled) 
[13:35:31.495]                           invokeRestart("muffleWarning")
[13:35:31.495]                       }
[13:35:31.495]                       else if (inherits(cond, "condition")) {
[13:35:31.495]                         if (!is.null(pattern)) {
[13:35:31.495]                           computeRestarts <- base::computeRestarts
[13:35:31.495]                           grepl <- base::grepl
[13:35:31.495]                           restarts <- computeRestarts(cond)
[13:35:31.495]                           for (restart in restarts) {
[13:35:31.495]                             name <- restart$name
[13:35:31.495]                             if (is.null(name)) 
[13:35:31.495]                               next
[13:35:31.495]                             if (!grepl(pattern, name)) 
[13:35:31.495]                               next
[13:35:31.495]                             invokeRestart(restart)
[13:35:31.495]                             muffled <- TRUE
[13:35:31.495]                             break
[13:35:31.495]                           }
[13:35:31.495]                         }
[13:35:31.495]                       }
[13:35:31.495]                       invisible(muffled)
[13:35:31.495]                     }
[13:35:31.495]                     muffleCondition(cond, pattern = "^muffle")
[13:35:31.495]                   }
[13:35:31.495]                 }
[13:35:31.495]                 else {
[13:35:31.495]                   if (TRUE) {
[13:35:31.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:31.495]                     {
[13:35:31.495]                       inherits <- base::inherits
[13:35:31.495]                       invokeRestart <- base::invokeRestart
[13:35:31.495]                       is.null <- base::is.null
[13:35:31.495]                       muffled <- FALSE
[13:35:31.495]                       if (inherits(cond, "message")) {
[13:35:31.495]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:31.495]                         if (muffled) 
[13:35:31.495]                           invokeRestart("muffleMessage")
[13:35:31.495]                       }
[13:35:31.495]                       else if (inherits(cond, "warning")) {
[13:35:31.495]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:31.495]                         if (muffled) 
[13:35:31.495]                           invokeRestart("muffleWarning")
[13:35:31.495]                       }
[13:35:31.495]                       else if (inherits(cond, "condition")) {
[13:35:31.495]                         if (!is.null(pattern)) {
[13:35:31.495]                           computeRestarts <- base::computeRestarts
[13:35:31.495]                           grepl <- base::grepl
[13:35:31.495]                           restarts <- computeRestarts(cond)
[13:35:31.495]                           for (restart in restarts) {
[13:35:31.495]                             name <- restart$name
[13:35:31.495]                             if (is.null(name)) 
[13:35:31.495]                               next
[13:35:31.495]                             if (!grepl(pattern, name)) 
[13:35:31.495]                               next
[13:35:31.495]                             invokeRestart(restart)
[13:35:31.495]                             muffled <- TRUE
[13:35:31.495]                             break
[13:35:31.495]                           }
[13:35:31.495]                         }
[13:35:31.495]                       }
[13:35:31.495]                       invisible(muffled)
[13:35:31.495]                     }
[13:35:31.495]                     muffleCondition(cond, pattern = "^muffle")
[13:35:31.495]                   }
[13:35:31.495]                 }
[13:35:31.495]             }
[13:35:31.495]         }))
[13:35:31.495]     }, error = function(ex) {
[13:35:31.495]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:31.495]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:31.495]                 ...future.rng), started = ...future.startTime, 
[13:35:31.495]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:31.495]             version = "1.8"), class = "FutureResult")
[13:35:31.495]     }, finally = {
[13:35:31.495]         if (!identical(...future.workdir, getwd())) 
[13:35:31.495]             setwd(...future.workdir)
[13:35:31.495]         {
[13:35:31.495]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:31.495]                 ...future.oldOptions$nwarnings <- NULL
[13:35:31.495]             }
[13:35:31.495]             base::options(...future.oldOptions)
[13:35:31.495]             if (.Platform$OS.type == "windows") {
[13:35:31.495]                 old_names <- names(...future.oldEnvVars)
[13:35:31.495]                 envs <- base::Sys.getenv()
[13:35:31.495]                 names <- names(envs)
[13:35:31.495]                 common <- intersect(names, old_names)
[13:35:31.495]                 added <- setdiff(names, old_names)
[13:35:31.495]                 removed <- setdiff(old_names, names)
[13:35:31.495]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:31.495]                   envs[common]]
[13:35:31.495]                 NAMES <- toupper(changed)
[13:35:31.495]                 args <- list()
[13:35:31.495]                 for (kk in seq_along(NAMES)) {
[13:35:31.495]                   name <- changed[[kk]]
[13:35:31.495]                   NAME <- NAMES[[kk]]
[13:35:31.495]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:31.495]                     next
[13:35:31.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:31.495]                 }
[13:35:31.495]                 NAMES <- toupper(added)
[13:35:31.495]                 for (kk in seq_along(NAMES)) {
[13:35:31.495]                   name <- added[[kk]]
[13:35:31.495]                   NAME <- NAMES[[kk]]
[13:35:31.495]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:31.495]                     next
[13:35:31.495]                   args[[name]] <- ""
[13:35:31.495]                 }
[13:35:31.495]                 NAMES <- toupper(removed)
[13:35:31.495]                 for (kk in seq_along(NAMES)) {
[13:35:31.495]                   name <- removed[[kk]]
[13:35:31.495]                   NAME <- NAMES[[kk]]
[13:35:31.495]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:31.495]                     next
[13:35:31.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:31.495]                 }
[13:35:31.495]                 if (length(args) > 0) 
[13:35:31.495]                   base::do.call(base::Sys.setenv, args = args)
[13:35:31.495]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:31.495]             }
[13:35:31.495]             else {
[13:35:31.495]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:31.495]             }
[13:35:31.495]             {
[13:35:31.495]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:31.495]                   0L) {
[13:35:31.495]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:31.495]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:31.495]                   base::options(opts)
[13:35:31.495]                 }
[13:35:31.495]                 {
[13:35:31.495]                   {
[13:35:31.495]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:31.495]                     NULL
[13:35:31.495]                   }
[13:35:31.495]                   options(future.plan = NULL)
[13:35:31.495]                   if (is.na(NA_character_)) 
[13:35:31.495]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:31.495]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:31.495]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:31.495]                     .init = FALSE)
[13:35:31.495]                 }
[13:35:31.495]             }
[13:35:31.495]         }
[13:35:31.495]     })
[13:35:31.495]     if (TRUE) {
[13:35:31.495]         base::sink(type = "output", split = FALSE)
[13:35:31.495]         if (FALSE) {
[13:35:31.495]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:31.495]         }
[13:35:31.495]         else {
[13:35:31.495]             ...future.result["stdout"] <- base::list(NULL)
[13:35:31.495]         }
[13:35:31.495]         base::close(...future.stdout)
[13:35:31.495]         ...future.stdout <- NULL
[13:35:31.495]     }
[13:35:31.495]     ...future.result$conditions <- ...future.conditions
[13:35:31.495]     ...future.result$finished <- base::Sys.time()
[13:35:31.495]     ...future.result
[13:35:31.495] }
[13:35:31.497] assign_globals() ...
[13:35:31.498] List of 5
[13:35:31.498]  $ ...future.FUN            :function (x, y)  
[13:35:31.498]  $ MoreArgs                 : NULL
[13:35:31.498]  $ ...future.elements_ii    :List of 2
[13:35:31.498]   ..$ :List of 1
[13:35:31.498]   .. ..$ : int 1
[13:35:31.498]   ..$ :List of 1
[13:35:31.498]   .. ..$ : int 0
[13:35:31.498]  $ ...future.seeds_ii       : NULL
[13:35:31.498]  $ ...future.globals.maxSize: NULL
[13:35:31.498]  - attr(*, "where")=List of 5
[13:35:31.498]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:31.498]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:35:31.498]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:31.498]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:31.498]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:31.498]  - attr(*, "resolved")= logi FALSE
[13:35:31.498]  - attr(*, "total_size")= num 6368
[13:35:31.498]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:31.498]  - attr(*, "already-done")= logi TRUE
[13:35:31.505] - reassign environment for ‘...future.FUN’
[13:35:31.505] - copied ‘...future.FUN’ to environment
[13:35:31.505] - copied ‘MoreArgs’ to environment
[13:35:31.505] - copied ‘...future.elements_ii’ to environment
[13:35:31.505] - copied ‘...future.seeds_ii’ to environment
[13:35:31.505] - copied ‘...future.globals.maxSize’ to environment
[13:35:31.505] assign_globals() ... done
[13:35:31.505] requestCore(): workers = 2
[13:35:31.507] MulticoreFuture started
[13:35:31.508] - Launch lazy future ... done
[13:35:31.508] run() for ‘MulticoreFuture’ ... done
[13:35:31.509] Created future:
[13:35:31.509] plan(): Setting new future strategy stack:
[13:35:31.509] List of future strategies:
[13:35:31.509] 1. sequential:
[13:35:31.509]    - args: function (..., envir = parent.frame())
[13:35:31.509]    - tweaked: FALSE
[13:35:31.509]    - call: NULL
[13:35:31.510] plan(): nbrOfWorkers() = 1
[13:35:31.509] MulticoreFuture:
[13:35:31.509] Label: ‘future_mapply-1’
[13:35:31.509] Expression:
[13:35:31.509] {
[13:35:31.509]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:31.509]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:31.509]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:31.509]         on.exit(options(oopts), add = TRUE)
[13:35:31.509]     }
[13:35:31.509]     {
[13:35:31.509]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:31.509]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:35:31.509]         do.call(mapply, args = args)
[13:35:31.509]     }
[13:35:31.509] }
[13:35:31.509] Lazy evaluation: FALSE
[13:35:31.509] Asynchronous evaluation: TRUE
[13:35:31.509] Local evaluation: TRUE
[13:35:31.509] Environment: R_GlobalEnv
[13:35:31.509] Capture standard output: FALSE
[13:35:31.509] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:31.509] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:31.509] Packages: <none>
[13:35:31.509] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:31.509] Resolved: FALSE
[13:35:31.509] Value: <not collected>
[13:35:31.509] Conditions captured: <none>
[13:35:31.509] Early signaling: FALSE
[13:35:31.509] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:31.509] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:31.522] Chunk #1 of 2 ... DONE
[13:35:31.522] Chunk #2 of 2 ...
[13:35:31.523]  - Finding globals in '...' for chunk #2 ...
[13:35:31.523] getGlobalsAndPackages() ...
[13:35:31.523] Searching for globals...
[13:35:31.524] 
[13:35:31.525] Searching for globals ... DONE
[13:35:31.525] - globals: [0] <none>
[13:35:31.525] getGlobalsAndPackages() ... DONE
[13:35:31.525]    + additional globals found: [n=0] 
[13:35:31.525]    + additional namespaces needed: [n=0] 
[13:35:31.525]  - Finding globals in '...' for chunk #2 ... DONE
[13:35:31.526]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:31.526]  - seeds: <none>
[13:35:31.526]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:31.526] getGlobalsAndPackages() ...
[13:35:31.526] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:31.527] Resolving globals: FALSE
[13:35:31.527] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:35:31.528] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:35:31.528] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:31.529] 
[13:35:31.529] getGlobalsAndPackages() ... DONE
[13:35:31.529] run() for ‘Future’ ...
[13:35:31.529] - state: ‘created’
[13:35:31.530] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:31.534] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:31.535] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:31.535]   - Field: ‘label’
[13:35:31.535]   - Field: ‘local’
[13:35:31.535]   - Field: ‘owner’
[13:35:31.535]   - Field: ‘envir’
[13:35:31.535]   - Field: ‘workers’
[13:35:31.535]   - Field: ‘packages’
[13:35:31.536]   - Field: ‘gc’
[13:35:31.536]   - Field: ‘job’
[13:35:31.536]   - Field: ‘conditions’
[13:35:31.536]   - Field: ‘expr’
[13:35:31.536]   - Field: ‘uuid’
[13:35:31.536]   - Field: ‘seed’
[13:35:31.537]   - Field: ‘version’
[13:35:31.537]   - Field: ‘result’
[13:35:31.537]   - Field: ‘asynchronous’
[13:35:31.537]   - Field: ‘calls’
[13:35:31.537]   - Field: ‘globals’
[13:35:31.537]   - Field: ‘stdout’
[13:35:31.537]   - Field: ‘earlySignal’
[13:35:31.538]   - Field: ‘lazy’
[13:35:31.538]   - Field: ‘state’
[13:35:31.538] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:31.538] - Launch lazy future ...
[13:35:31.538] Packages needed by the future expression (n = 0): <none>
[13:35:31.539] Packages needed by future strategies (n = 0): <none>
[13:35:31.539] {
[13:35:31.539]     {
[13:35:31.539]         {
[13:35:31.539]             ...future.startTime <- base::Sys.time()
[13:35:31.539]             {
[13:35:31.539]                 {
[13:35:31.539]                   {
[13:35:31.539]                     {
[13:35:31.539]                       base::local({
[13:35:31.539]                         has_future <- base::requireNamespace("future", 
[13:35:31.539]                           quietly = TRUE)
[13:35:31.539]                         if (has_future) {
[13:35:31.539]                           ns <- base::getNamespace("future")
[13:35:31.539]                           version <- ns[[".package"]][["version"]]
[13:35:31.539]                           if (is.null(version)) 
[13:35:31.539]                             version <- utils::packageVersion("future")
[13:35:31.539]                         }
[13:35:31.539]                         else {
[13:35:31.539]                           version <- NULL
[13:35:31.539]                         }
[13:35:31.539]                         if (!has_future || version < "1.8.0") {
[13:35:31.539]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:31.539]                             "", base::R.version$version.string), 
[13:35:31.539]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:31.539]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:31.539]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:31.539]                               "release", "version")], collapse = " "), 
[13:35:31.539]                             hostname = base::Sys.info()[["nodename"]])
[13:35:31.539]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:31.539]                             info)
[13:35:31.539]                           info <- base::paste(info, collapse = "; ")
[13:35:31.539]                           if (!has_future) {
[13:35:31.539]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:31.539]                               info)
[13:35:31.539]                           }
[13:35:31.539]                           else {
[13:35:31.539]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:31.539]                               info, version)
[13:35:31.539]                           }
[13:35:31.539]                           base::stop(msg)
[13:35:31.539]                         }
[13:35:31.539]                       })
[13:35:31.539]                     }
[13:35:31.539]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:31.539]                     base::options(mc.cores = 1L)
[13:35:31.539]                   }
[13:35:31.539]                   ...future.strategy.old <- future::plan("list")
[13:35:31.539]                   options(future.plan = NULL)
[13:35:31.539]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:31.539]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:31.539]                 }
[13:35:31.539]                 ...future.workdir <- getwd()
[13:35:31.539]             }
[13:35:31.539]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:31.539]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:31.539]         }
[13:35:31.539]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:31.539]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:31.539]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:31.539]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:31.539]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:31.539]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:31.539]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:31.539]             base::names(...future.oldOptions))
[13:35:31.539]     }
[13:35:31.539]     if (FALSE) {
[13:35:31.539]     }
[13:35:31.539]     else {
[13:35:31.539]         if (FALSE) {
[13:35:31.539]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:31.539]                 open = "w")
[13:35:31.539]         }
[13:35:31.539]         else {
[13:35:31.539]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:31.539]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:31.539]         }
[13:35:31.539]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:31.539]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:31.539]             base::sink(type = "output", split = FALSE)
[13:35:31.539]             base::close(...future.stdout)
[13:35:31.539]         }, add = TRUE)
[13:35:31.539]     }
[13:35:31.539]     ...future.frame <- base::sys.nframe()
[13:35:31.539]     ...future.conditions <- base::list()
[13:35:31.539]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:31.539]     if (FALSE) {
[13:35:31.539]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:31.539]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:31.539]     }
[13:35:31.539]     ...future.result <- base::tryCatch({
[13:35:31.539]         base::withCallingHandlers({
[13:35:31.539]             ...future.value <- base::withVisible(base::local({
[13:35:31.539]                 withCallingHandlers({
[13:35:31.539]                   {
[13:35:31.539]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:31.539]                     if (!identical(...future.globals.maxSize.org, 
[13:35:31.539]                       ...future.globals.maxSize)) {
[13:35:31.539]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:31.539]                       on.exit(options(oopts), add = TRUE)
[13:35:31.539]                     }
[13:35:31.539]                     {
[13:35:31.539]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:31.539]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:35:31.539]                         USE.NAMES = FALSE)
[13:35:31.539]                       do.call(mapply, args = args)
[13:35:31.539]                     }
[13:35:31.539]                   }
[13:35:31.539]                 }, immediateCondition = function(cond) {
[13:35:31.539]                   save_rds <- function (object, pathname, ...) 
[13:35:31.539]                   {
[13:35:31.539]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:31.539]                     if (file_test("-f", pathname_tmp)) {
[13:35:31.539]                       fi_tmp <- file.info(pathname_tmp)
[13:35:31.539]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:31.539]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:31.539]                         fi_tmp[["mtime"]])
[13:35:31.539]                     }
[13:35:31.539]                     tryCatch({
[13:35:31.539]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:31.539]                     }, error = function(ex) {
[13:35:31.539]                       msg <- conditionMessage(ex)
[13:35:31.539]                       fi_tmp <- file.info(pathname_tmp)
[13:35:31.539]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:31.539]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:31.539]                         fi_tmp[["mtime"]], msg)
[13:35:31.539]                       ex$message <- msg
[13:35:31.539]                       stop(ex)
[13:35:31.539]                     })
[13:35:31.539]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:31.539]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:31.539]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:31.539]                       fi_tmp <- file.info(pathname_tmp)
[13:35:31.539]                       fi <- file.info(pathname)
[13:35:31.539]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:31.539]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:31.539]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:31.539]                         fi[["size"]], fi[["mtime"]])
[13:35:31.539]                       stop(msg)
[13:35:31.539]                     }
[13:35:31.539]                     invisible(pathname)
[13:35:31.539]                   }
[13:35:31.539]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:31.539]                     rootPath = tempdir()) 
[13:35:31.539]                   {
[13:35:31.539]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:31.539]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:31.539]                       tmpdir = path, fileext = ".rds")
[13:35:31.539]                     save_rds(obj, file)
[13:35:31.539]                   }
[13:35:31.539]                   saveImmediateCondition(cond, path = "/tmp/RtmpghgvGN/.future/immediateConditions")
[13:35:31.539]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:31.539]                   {
[13:35:31.539]                     inherits <- base::inherits
[13:35:31.539]                     invokeRestart <- base::invokeRestart
[13:35:31.539]                     is.null <- base::is.null
[13:35:31.539]                     muffled <- FALSE
[13:35:31.539]                     if (inherits(cond, "message")) {
[13:35:31.539]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:31.539]                       if (muffled) 
[13:35:31.539]                         invokeRestart("muffleMessage")
[13:35:31.539]                     }
[13:35:31.539]                     else if (inherits(cond, "warning")) {
[13:35:31.539]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:31.539]                       if (muffled) 
[13:35:31.539]                         invokeRestart("muffleWarning")
[13:35:31.539]                     }
[13:35:31.539]                     else if (inherits(cond, "condition")) {
[13:35:31.539]                       if (!is.null(pattern)) {
[13:35:31.539]                         computeRestarts <- base::computeRestarts
[13:35:31.539]                         grepl <- base::grepl
[13:35:31.539]                         restarts <- computeRestarts(cond)
[13:35:31.539]                         for (restart in restarts) {
[13:35:31.539]                           name <- restart$name
[13:35:31.539]                           if (is.null(name)) 
[13:35:31.539]                             next
[13:35:31.539]                           if (!grepl(pattern, name)) 
[13:35:31.539]                             next
[13:35:31.539]                           invokeRestart(restart)
[13:35:31.539]                           muffled <- TRUE
[13:35:31.539]                           break
[13:35:31.539]                         }
[13:35:31.539]                       }
[13:35:31.539]                     }
[13:35:31.539]                     invisible(muffled)
[13:35:31.539]                   }
[13:35:31.539]                   muffleCondition(cond)
[13:35:31.539]                 })
[13:35:31.539]             }))
[13:35:31.539]             future::FutureResult(value = ...future.value$value, 
[13:35:31.539]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:31.539]                   ...future.rng), globalenv = if (FALSE) 
[13:35:31.539]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:31.539]                     ...future.globalenv.names))
[13:35:31.539]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:31.539]         }, condition = base::local({
[13:35:31.539]             c <- base::c
[13:35:31.539]             inherits <- base::inherits
[13:35:31.539]             invokeRestart <- base::invokeRestart
[13:35:31.539]             length <- base::length
[13:35:31.539]             list <- base::list
[13:35:31.539]             seq.int <- base::seq.int
[13:35:31.539]             signalCondition <- base::signalCondition
[13:35:31.539]             sys.calls <- base::sys.calls
[13:35:31.539]             `[[` <- base::`[[`
[13:35:31.539]             `+` <- base::`+`
[13:35:31.539]             `<<-` <- base::`<<-`
[13:35:31.539]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:31.539]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:31.539]                   3L)]
[13:35:31.539]             }
[13:35:31.539]             function(cond) {
[13:35:31.539]                 is_error <- inherits(cond, "error")
[13:35:31.539]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:31.539]                   NULL)
[13:35:31.539]                 if (is_error) {
[13:35:31.539]                   sessionInformation <- function() {
[13:35:31.539]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:31.539]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:31.539]                       search = base::search(), system = base::Sys.info())
[13:35:31.539]                   }
[13:35:31.539]                   ...future.conditions[[length(...future.conditions) + 
[13:35:31.539]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:31.539]                     cond$call), session = sessionInformation(), 
[13:35:31.539]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:31.539]                   signalCondition(cond)
[13:35:31.539]                 }
[13:35:31.539]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:31.539]                 "immediateCondition"))) {
[13:35:31.539]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:31.539]                   ...future.conditions[[length(...future.conditions) + 
[13:35:31.539]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:31.539]                   if (TRUE && !signal) {
[13:35:31.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:31.539]                     {
[13:35:31.539]                       inherits <- base::inherits
[13:35:31.539]                       invokeRestart <- base::invokeRestart
[13:35:31.539]                       is.null <- base::is.null
[13:35:31.539]                       muffled <- FALSE
[13:35:31.539]                       if (inherits(cond, "message")) {
[13:35:31.539]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:31.539]                         if (muffled) 
[13:35:31.539]                           invokeRestart("muffleMessage")
[13:35:31.539]                       }
[13:35:31.539]                       else if (inherits(cond, "warning")) {
[13:35:31.539]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:31.539]                         if (muffled) 
[13:35:31.539]                           invokeRestart("muffleWarning")
[13:35:31.539]                       }
[13:35:31.539]                       else if (inherits(cond, "condition")) {
[13:35:31.539]                         if (!is.null(pattern)) {
[13:35:31.539]                           computeRestarts <- base::computeRestarts
[13:35:31.539]                           grepl <- base::grepl
[13:35:31.539]                           restarts <- computeRestarts(cond)
[13:35:31.539]                           for (restart in restarts) {
[13:35:31.539]                             name <- restart$name
[13:35:31.539]                             if (is.null(name)) 
[13:35:31.539]                               next
[13:35:31.539]                             if (!grepl(pattern, name)) 
[13:35:31.539]                               next
[13:35:31.539]                             invokeRestart(restart)
[13:35:31.539]                             muffled <- TRUE
[13:35:31.539]                             break
[13:35:31.539]                           }
[13:35:31.539]                         }
[13:35:31.539]                       }
[13:35:31.539]                       invisible(muffled)
[13:35:31.539]                     }
[13:35:31.539]                     muffleCondition(cond, pattern = "^muffle")
[13:35:31.539]                   }
[13:35:31.539]                 }
[13:35:31.539]                 else {
[13:35:31.539]                   if (TRUE) {
[13:35:31.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:31.539]                     {
[13:35:31.539]                       inherits <- base::inherits
[13:35:31.539]                       invokeRestart <- base::invokeRestart
[13:35:31.539]                       is.null <- base::is.null
[13:35:31.539]                       muffled <- FALSE
[13:35:31.539]                       if (inherits(cond, "message")) {
[13:35:31.539]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:31.539]                         if (muffled) 
[13:35:31.539]                           invokeRestart("muffleMessage")
[13:35:31.539]                       }
[13:35:31.539]                       else if (inherits(cond, "warning")) {
[13:35:31.539]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:31.539]                         if (muffled) 
[13:35:31.539]                           invokeRestart("muffleWarning")
[13:35:31.539]                       }
[13:35:31.539]                       else if (inherits(cond, "condition")) {
[13:35:31.539]                         if (!is.null(pattern)) {
[13:35:31.539]                           computeRestarts <- base::computeRestarts
[13:35:31.539]                           grepl <- base::grepl
[13:35:31.539]                           restarts <- computeRestarts(cond)
[13:35:31.539]                           for (restart in restarts) {
[13:35:31.539]                             name <- restart$name
[13:35:31.539]                             if (is.null(name)) 
[13:35:31.539]                               next
[13:35:31.539]                             if (!grepl(pattern, name)) 
[13:35:31.539]                               next
[13:35:31.539]                             invokeRestart(restart)
[13:35:31.539]                             muffled <- TRUE
[13:35:31.539]                             break
[13:35:31.539]                           }
[13:35:31.539]                         }
[13:35:31.539]                       }
[13:35:31.539]                       invisible(muffled)
[13:35:31.539]                     }
[13:35:31.539]                     muffleCondition(cond, pattern = "^muffle")
[13:35:31.539]                   }
[13:35:31.539]                 }
[13:35:31.539]             }
[13:35:31.539]         }))
[13:35:31.539]     }, error = function(ex) {
[13:35:31.539]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:31.539]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:31.539]                 ...future.rng), started = ...future.startTime, 
[13:35:31.539]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:31.539]             version = "1.8"), class = "FutureResult")
[13:35:31.539]     }, finally = {
[13:35:31.539]         if (!identical(...future.workdir, getwd())) 
[13:35:31.539]             setwd(...future.workdir)
[13:35:31.539]         {
[13:35:31.539]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:31.539]                 ...future.oldOptions$nwarnings <- NULL
[13:35:31.539]             }
[13:35:31.539]             base::options(...future.oldOptions)
[13:35:31.539]             if (.Platform$OS.type == "windows") {
[13:35:31.539]                 old_names <- names(...future.oldEnvVars)
[13:35:31.539]                 envs <- base::Sys.getenv()
[13:35:31.539]                 names <- names(envs)
[13:35:31.539]                 common <- intersect(names, old_names)
[13:35:31.539]                 added <- setdiff(names, old_names)
[13:35:31.539]                 removed <- setdiff(old_names, names)
[13:35:31.539]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:31.539]                   envs[common]]
[13:35:31.539]                 NAMES <- toupper(changed)
[13:35:31.539]                 args <- list()
[13:35:31.539]                 for (kk in seq_along(NAMES)) {
[13:35:31.539]                   name <- changed[[kk]]
[13:35:31.539]                   NAME <- NAMES[[kk]]
[13:35:31.539]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:31.539]                     next
[13:35:31.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:31.539]                 }
[13:35:31.539]                 NAMES <- toupper(added)
[13:35:31.539]                 for (kk in seq_along(NAMES)) {
[13:35:31.539]                   name <- added[[kk]]
[13:35:31.539]                   NAME <- NAMES[[kk]]
[13:35:31.539]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:31.539]                     next
[13:35:31.539]                   args[[name]] <- ""
[13:35:31.539]                 }
[13:35:31.539]                 NAMES <- toupper(removed)
[13:35:31.539]                 for (kk in seq_along(NAMES)) {
[13:35:31.539]                   name <- removed[[kk]]
[13:35:31.539]                   NAME <- NAMES[[kk]]
[13:35:31.539]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:31.539]                     next
[13:35:31.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:31.539]                 }
[13:35:31.539]                 if (length(args) > 0) 
[13:35:31.539]                   base::do.call(base::Sys.setenv, args = args)
[13:35:31.539]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:31.539]             }
[13:35:31.539]             else {
[13:35:31.539]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:31.539]             }
[13:35:31.539]             {
[13:35:31.539]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:31.539]                   0L) {
[13:35:31.539]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:31.539]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:31.539]                   base::options(opts)
[13:35:31.539]                 }
[13:35:31.539]                 {
[13:35:31.539]                   {
[13:35:31.539]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:31.539]                     NULL
[13:35:31.539]                   }
[13:35:31.539]                   options(future.plan = NULL)
[13:35:31.539]                   if (is.na(NA_character_)) 
[13:35:31.539]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:31.539]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:31.539]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:31.539]                     .init = FALSE)
[13:35:31.539]                 }
[13:35:31.539]             }
[13:35:31.539]         }
[13:35:31.539]     })
[13:35:31.539]     if (TRUE) {
[13:35:31.539]         base::sink(type = "output", split = FALSE)
[13:35:31.539]         if (FALSE) {
[13:35:31.539]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:31.539]         }
[13:35:31.539]         else {
[13:35:31.539]             ...future.result["stdout"] <- base::list(NULL)
[13:35:31.539]         }
[13:35:31.539]         base::close(...future.stdout)
[13:35:31.539]         ...future.stdout <- NULL
[13:35:31.539]     }
[13:35:31.539]     ...future.result$conditions <- ...future.conditions
[13:35:31.539]     ...future.result$finished <- base::Sys.time()
[13:35:31.539]     ...future.result
[13:35:31.539] }
[13:35:31.543] assign_globals() ...
[13:35:31.543] List of 5
[13:35:31.543]  $ ...future.FUN            :function (x, y)  
[13:35:31.543]  $ MoreArgs                 : NULL
[13:35:31.543]  $ ...future.elements_ii    :List of 2
[13:35:31.543]   ..$ :List of 1
[13:35:31.543]   .. ..$ : int 0
[13:35:31.543]   ..$ :List of 1
[13:35:31.543]   .. ..$ : int 1
[13:35:31.543]  $ ...future.seeds_ii       : NULL
[13:35:31.543]  $ ...future.globals.maxSize: NULL
[13:35:31.543]  - attr(*, "where")=List of 5
[13:35:31.543]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:31.543]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:35:31.543]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:31.543]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:31.543]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:31.543]  - attr(*, "resolved")= logi FALSE
[13:35:31.543]  - attr(*, "total_size")= num 6368
[13:35:31.543]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:31.543]  - attr(*, "already-done")= logi TRUE
[13:35:31.551] - reassign environment for ‘...future.FUN’
[13:35:31.551] - copied ‘...future.FUN’ to environment
[13:35:31.551] - copied ‘MoreArgs’ to environment
[13:35:31.551] - copied ‘...future.elements_ii’ to environment
[13:35:31.552] - copied ‘...future.seeds_ii’ to environment
[13:35:31.552] - copied ‘...future.globals.maxSize’ to environment
[13:35:31.552] assign_globals() ... done
[13:35:31.552] requestCore(): workers = 2
[13:35:31.554] MulticoreFuture started
[13:35:31.555] - Launch lazy future ... done
[13:35:31.555] run() for ‘MulticoreFuture’ ... done
[13:35:31.555] Created future:
[13:35:31.555] plan(): Setting new future strategy stack:
[13:35:31.556] List of future strategies:
[13:35:31.556] 1. sequential:
[13:35:31.556]    - args: function (..., envir = parent.frame())
[13:35:31.556]    - tweaked: FALSE
[13:35:31.556]    - call: NULL
[13:35:31.560] plan(): nbrOfWorkers() = 1
[13:35:31.563] plan(): Setting new future strategy stack:
[13:35:31.563] List of future strategies:
[13:35:31.563] 1. multicore:
[13:35:31.563]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:31.563]    - tweaked: FALSE
[13:35:31.563]    - call: plan(strategy)
[13:35:31.569] plan(): nbrOfWorkers() = 2
[13:35:31.555] MulticoreFuture:
[13:35:31.555] Label: ‘future_mapply-2’
[13:35:31.555] Expression:
[13:35:31.555] {
[13:35:31.555]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:31.555]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:31.555]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:31.555]         on.exit(options(oopts), add = TRUE)
[13:35:31.555]     }
[13:35:31.555]     {
[13:35:31.555]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:31.555]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:35:31.555]         do.call(mapply, args = args)
[13:35:31.555]     }
[13:35:31.555] }
[13:35:31.555] Lazy evaluation: FALSE
[13:35:31.555] Asynchronous evaluation: TRUE
[13:35:31.555] Local evaluation: TRUE
[13:35:31.555] Environment: R_GlobalEnv
[13:35:31.555] Capture standard output: FALSE
[13:35:31.555] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:31.555] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:31.555] Packages: <none>
[13:35:31.555] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:31.555] Resolved: TRUE
[13:35:31.555] Value: <not collected>
[13:35:31.555] Conditions captured: <none>
[13:35:31.555] Early signaling: FALSE
[13:35:31.555] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:31.555] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:31.570] Chunk #2 of 2 ... DONE
[13:35:31.571] Launching 2 futures (chunks) ... DONE
[13:35:31.571] Resolving 2 futures (chunks) ...
[13:35:31.571] resolve() on list ...
[13:35:31.572]  recursive: 0
[13:35:31.572]  length: 2
[13:35:31.572] 
[13:35:31.583] Future #2
[13:35:31.583] result() for MulticoreFuture ...
[13:35:31.584] result() for MulticoreFuture ...
[13:35:31.584] result() for MulticoreFuture ... done
[13:35:31.584] result() for MulticoreFuture ... done
[13:35:31.584] result() for MulticoreFuture ...
[13:35:31.585] result() for MulticoreFuture ... done
[13:35:31.585] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:35:31.585] - nx: 2
[13:35:31.585] - relay: TRUE
[13:35:31.585] - stdout: TRUE
[13:35:31.585] - signal: TRUE
[13:35:31.585] - resignal: FALSE
[13:35:31.586] - force: TRUE
[13:35:31.586] - relayed: [n=2] FALSE, FALSE
[13:35:31.586] - queued futures: [n=2] FALSE, FALSE
[13:35:31.586]  - until=1
[13:35:31.586]  - relaying element #1
[13:35:31.586] - relayed: [n=2] FALSE, FALSE
[13:35:31.587] - queued futures: [n=2] FALSE, TRUE
[13:35:31.587] signalConditionsASAP(NULL, pos=2) ... done
[13:35:31.587]  length: 1 (resolved future 2)
[13:35:32.013] plan(): Setting new future strategy stack:
[13:35:32.013] List of future strategies:
[13:35:32.013] 1. multicore:
[13:35:32.013]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:32.013]    - tweaked: FALSE
[13:35:32.013]    - call: plan(strategy)
[13:35:32.018] plan(): nbrOfWorkers() = 2
[13:35:32.025] Future #1
[13:35:32.025] result() for MulticoreFuture ...
[13:35:32.026] result() for MulticoreFuture ...
[13:35:32.026] result() for MulticoreFuture ... done
[13:35:32.026] result() for MulticoreFuture ... done
[13:35:32.027] result() for MulticoreFuture ...
[13:35:32.027] result() for MulticoreFuture ... done
[13:35:32.027] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:35:32.027] - nx: 2
[13:35:32.027] - relay: TRUE
[13:35:32.027] - stdout: TRUE
[13:35:32.027] - signal: TRUE
[13:35:32.027] - resignal: FALSE
[13:35:32.027] - force: TRUE
[13:35:32.027] - relayed: [n=2] FALSE, FALSE
[13:35:32.028] - queued futures: [n=2] FALSE, TRUE
[13:35:32.028]  - until=1
[13:35:32.028]  - relaying element #1
[13:35:32.028] result() for MulticoreFuture ...
[13:35:32.028] result() for MulticoreFuture ... done
[13:35:32.028] result() for MulticoreFuture ...
[13:35:32.028] result() for MulticoreFuture ... done
[13:35:32.028] result() for MulticoreFuture ...
[13:35:32.029] result() for MulticoreFuture ... done
[13:35:32.029] result() for MulticoreFuture ...
[13:35:32.029] result() for MulticoreFuture ... done
[13:35:32.029] - relayed: [n=2] TRUE, FALSE
[13:35:32.029] - queued futures: [n=2] TRUE, TRUE
[13:35:32.029] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:35:32.029]  length: 0 (resolved future 1)
[13:35:32.029] Relaying remaining futures
[13:35:32.029] signalConditionsASAP(NULL, pos=0) ...
[13:35:32.030] - nx: 2
[13:35:32.030] - relay: TRUE
[13:35:32.030] - stdout: TRUE
[13:35:32.030] - signal: TRUE
[13:35:32.030] - resignal: FALSE
[13:35:32.030] - force: TRUE
[13:35:32.030] - relayed: [n=2] TRUE, FALSE
[13:35:32.030] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:32.030]  - relaying element #2
[13:35:32.031] result() for MulticoreFuture ...
[13:35:32.031] result() for MulticoreFuture ... done
[13:35:32.031] result() for MulticoreFuture ...
[13:35:32.031] result() for MulticoreFuture ... done
[13:35:32.031] result() for MulticoreFuture ...
[13:35:32.031] result() for MulticoreFuture ... done
[13:35:32.031] result() for MulticoreFuture ...
[13:35:32.031] result() for MulticoreFuture ... done
[13:35:32.031] - relayed: [n=2] TRUE, TRUE
[13:35:32.032] - queued futures: [n=2] TRUE, TRUE
[13:35:32.032] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[13:35:32.032] resolve() on list ... DONE
[13:35:32.032] result() for MulticoreFuture ...
[13:35:32.032] result() for MulticoreFuture ... done
[13:35:32.032] result() for MulticoreFuture ...
[13:35:32.032] result() for MulticoreFuture ... done
[13:35:32.032] result() for MulticoreFuture ...
[13:35:32.032] result() for MulticoreFuture ... done
[13:35:32.033] result() for MulticoreFuture ...
[13:35:32.033] result() for MulticoreFuture ... done
[13:35:32.033]  - Number of value chunks collected: 2
[13:35:32.033] Resolving 2 futures (chunks) ... DONE
[13:35:32.033] Reducing values from 2 chunks ...
[13:35:32.033]  - Number of values collected after concatenation: 2
[13:35:32.033]  - Number of values expected: 2
[13:35:32.033] Reducing values from 2 chunks ... DONE
[13:35:32.033] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[13:35:32.034] future_mapply() ...
[13:35:32.038] Number of chunks: 2
[13:35:32.038] getGlobalsAndPackagesXApply() ...
[13:35:32.038]  - future.globals: TRUE
[13:35:32.038] getGlobalsAndPackages() ...
[13:35:32.039] Searching for globals...
[13:35:32.040] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:35:32.041] Searching for globals ... DONE
[13:35:32.041] Resolving globals: FALSE
[13:35:32.041] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:35:32.042] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:35:32.042] - globals: [1] ‘FUN’
[13:35:32.042] 
[13:35:32.042] getGlobalsAndPackages() ... DONE
[13:35:32.042]  - globals found/used: [n=1] ‘FUN’
[13:35:32.042]  - needed namespaces: [n=0] 
[13:35:32.043] Finding globals ... DONE
[13:35:32.043] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:35:32.043] List of 2
[13:35:32.043]  $ ...future.FUN:function (x, y)  
[13:35:32.043]  $ MoreArgs     : NULL
[13:35:32.043]  - attr(*, "where")=List of 2
[13:35:32.043]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:32.043]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:35:32.043]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:32.043]  - attr(*, "resolved")= logi FALSE
[13:35:32.043]  - attr(*, "total_size")= num NA
[13:35:32.048] Packages to be attached in all futures: [n=0] 
[13:35:32.048] getGlobalsAndPackagesXApply() ... DONE
[13:35:32.049] Number of futures (= number of chunks): 2
[13:35:32.049] Launching 2 futures (chunks) ...
[13:35:32.049] Chunk #1 of 2 ...
[13:35:32.049]  - Finding globals in '...' for chunk #1 ...
[13:35:32.049] getGlobalsAndPackages() ...
[13:35:32.049] Searching for globals...
[13:35:32.050] 
[13:35:32.050] Searching for globals ... DONE
[13:35:32.050] - globals: [0] <none>
[13:35:32.050] getGlobalsAndPackages() ... DONE
[13:35:32.050]    + additional globals found: [n=0] 
[13:35:32.050]    + additional namespaces needed: [n=0] 
[13:35:32.050]  - Finding globals in '...' for chunk #1 ... DONE
[13:35:32.050]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:32.050]  - seeds: <none>
[13:35:32.050]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:32.051] getGlobalsAndPackages() ...
[13:35:32.051] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:32.051] Resolving globals: FALSE
[13:35:32.051] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:35:32.052] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:35:32.052] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:32.052] 
[13:35:32.052] getGlobalsAndPackages() ... DONE
[13:35:32.052] run() for ‘Future’ ...
[13:35:32.052] - state: ‘created’
[13:35:32.053] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:32.056] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:32.056] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:32.056]   - Field: ‘label’
[13:35:32.057]   - Field: ‘local’
[13:35:32.057]   - Field: ‘owner’
[13:35:32.057]   - Field: ‘envir’
[13:35:32.057]   - Field: ‘workers’
[13:35:32.057]   - Field: ‘packages’
[13:35:32.057]   - Field: ‘gc’
[13:35:32.057]   - Field: ‘job’
[13:35:32.057]   - Field: ‘conditions’
[13:35:32.057]   - Field: ‘expr’
[13:35:32.057]   - Field: ‘uuid’
[13:35:32.057]   - Field: ‘seed’
[13:35:32.058]   - Field: ‘version’
[13:35:32.058]   - Field: ‘result’
[13:35:32.058]   - Field: ‘asynchronous’
[13:35:32.058]   - Field: ‘calls’
[13:35:32.058]   - Field: ‘globals’
[13:35:32.058]   - Field: ‘stdout’
[13:35:32.058]   - Field: ‘earlySignal’
[13:35:32.058]   - Field: ‘lazy’
[13:35:32.058]   - Field: ‘state’
[13:35:32.058] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:32.059] - Launch lazy future ...
[13:35:32.059] Packages needed by the future expression (n = 0): <none>
[13:35:32.059] Packages needed by future strategies (n = 0): <none>
[13:35:32.059] {
[13:35:32.059]     {
[13:35:32.059]         {
[13:35:32.059]             ...future.startTime <- base::Sys.time()
[13:35:32.059]             {
[13:35:32.059]                 {
[13:35:32.059]                   {
[13:35:32.059]                     {
[13:35:32.059]                       base::local({
[13:35:32.059]                         has_future <- base::requireNamespace("future", 
[13:35:32.059]                           quietly = TRUE)
[13:35:32.059]                         if (has_future) {
[13:35:32.059]                           ns <- base::getNamespace("future")
[13:35:32.059]                           version <- ns[[".package"]][["version"]]
[13:35:32.059]                           if (is.null(version)) 
[13:35:32.059]                             version <- utils::packageVersion("future")
[13:35:32.059]                         }
[13:35:32.059]                         else {
[13:35:32.059]                           version <- NULL
[13:35:32.059]                         }
[13:35:32.059]                         if (!has_future || version < "1.8.0") {
[13:35:32.059]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:32.059]                             "", base::R.version$version.string), 
[13:35:32.059]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:32.059]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:32.059]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:32.059]                               "release", "version")], collapse = " "), 
[13:35:32.059]                             hostname = base::Sys.info()[["nodename"]])
[13:35:32.059]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:32.059]                             info)
[13:35:32.059]                           info <- base::paste(info, collapse = "; ")
[13:35:32.059]                           if (!has_future) {
[13:35:32.059]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:32.059]                               info)
[13:35:32.059]                           }
[13:35:32.059]                           else {
[13:35:32.059]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:32.059]                               info, version)
[13:35:32.059]                           }
[13:35:32.059]                           base::stop(msg)
[13:35:32.059]                         }
[13:35:32.059]                       })
[13:35:32.059]                     }
[13:35:32.059]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:32.059]                     base::options(mc.cores = 1L)
[13:35:32.059]                   }
[13:35:32.059]                   ...future.strategy.old <- future::plan("list")
[13:35:32.059]                   options(future.plan = NULL)
[13:35:32.059]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:32.059]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:32.059]                 }
[13:35:32.059]                 ...future.workdir <- getwd()
[13:35:32.059]             }
[13:35:32.059]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:32.059]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:32.059]         }
[13:35:32.059]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:32.059]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:32.059]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:32.059]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:32.059]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:32.059]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:32.059]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:32.059]             base::names(...future.oldOptions))
[13:35:32.059]     }
[13:35:32.059]     if (FALSE) {
[13:35:32.059]     }
[13:35:32.059]     else {
[13:35:32.059]         if (TRUE) {
[13:35:32.059]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:32.059]                 open = "w")
[13:35:32.059]         }
[13:35:32.059]         else {
[13:35:32.059]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:32.059]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:32.059]         }
[13:35:32.059]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:32.059]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:32.059]             base::sink(type = "output", split = FALSE)
[13:35:32.059]             base::close(...future.stdout)
[13:35:32.059]         }, add = TRUE)
[13:35:32.059]     }
[13:35:32.059]     ...future.frame <- base::sys.nframe()
[13:35:32.059]     ...future.conditions <- base::list()
[13:35:32.059]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:32.059]     if (FALSE) {
[13:35:32.059]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:32.059]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:32.059]     }
[13:35:32.059]     ...future.result <- base::tryCatch({
[13:35:32.059]         base::withCallingHandlers({
[13:35:32.059]             ...future.value <- base::withVisible(base::local({
[13:35:32.059]                 withCallingHandlers({
[13:35:32.059]                   {
[13:35:32.059]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:32.059]                     if (!identical(...future.globals.maxSize.org, 
[13:35:32.059]                       ...future.globals.maxSize)) {
[13:35:32.059]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:32.059]                       on.exit(options(oopts), add = TRUE)
[13:35:32.059]                     }
[13:35:32.059]                     {
[13:35:32.059]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:32.059]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:35:32.059]                         USE.NAMES = FALSE)
[13:35:32.059]                       do.call(mapply, args = args)
[13:35:32.059]                     }
[13:35:32.059]                   }
[13:35:32.059]                 }, immediateCondition = function(cond) {
[13:35:32.059]                   save_rds <- function (object, pathname, ...) 
[13:35:32.059]                   {
[13:35:32.059]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:32.059]                     if (file_test("-f", pathname_tmp)) {
[13:35:32.059]                       fi_tmp <- file.info(pathname_tmp)
[13:35:32.059]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:32.059]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:32.059]                         fi_tmp[["mtime"]])
[13:35:32.059]                     }
[13:35:32.059]                     tryCatch({
[13:35:32.059]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:32.059]                     }, error = function(ex) {
[13:35:32.059]                       msg <- conditionMessage(ex)
[13:35:32.059]                       fi_tmp <- file.info(pathname_tmp)
[13:35:32.059]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:32.059]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:32.059]                         fi_tmp[["mtime"]], msg)
[13:35:32.059]                       ex$message <- msg
[13:35:32.059]                       stop(ex)
[13:35:32.059]                     })
[13:35:32.059]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:32.059]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:32.059]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:32.059]                       fi_tmp <- file.info(pathname_tmp)
[13:35:32.059]                       fi <- file.info(pathname)
[13:35:32.059]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:32.059]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:32.059]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:32.059]                         fi[["size"]], fi[["mtime"]])
[13:35:32.059]                       stop(msg)
[13:35:32.059]                     }
[13:35:32.059]                     invisible(pathname)
[13:35:32.059]                   }
[13:35:32.059]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:32.059]                     rootPath = tempdir()) 
[13:35:32.059]                   {
[13:35:32.059]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:32.059]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:32.059]                       tmpdir = path, fileext = ".rds")
[13:35:32.059]                     save_rds(obj, file)
[13:35:32.059]                   }
[13:35:32.059]                   saveImmediateCondition(cond, path = "/tmp/RtmpghgvGN/.future/immediateConditions")
[13:35:32.059]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:32.059]                   {
[13:35:32.059]                     inherits <- base::inherits
[13:35:32.059]                     invokeRestart <- base::invokeRestart
[13:35:32.059]                     is.null <- base::is.null
[13:35:32.059]                     muffled <- FALSE
[13:35:32.059]                     if (inherits(cond, "message")) {
[13:35:32.059]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:32.059]                       if (muffled) 
[13:35:32.059]                         invokeRestart("muffleMessage")
[13:35:32.059]                     }
[13:35:32.059]                     else if (inherits(cond, "warning")) {
[13:35:32.059]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:32.059]                       if (muffled) 
[13:35:32.059]                         invokeRestart("muffleWarning")
[13:35:32.059]                     }
[13:35:32.059]                     else if (inherits(cond, "condition")) {
[13:35:32.059]                       if (!is.null(pattern)) {
[13:35:32.059]                         computeRestarts <- base::computeRestarts
[13:35:32.059]                         grepl <- base::grepl
[13:35:32.059]                         restarts <- computeRestarts(cond)
[13:35:32.059]                         for (restart in restarts) {
[13:35:32.059]                           name <- restart$name
[13:35:32.059]                           if (is.null(name)) 
[13:35:32.059]                             next
[13:35:32.059]                           if (!grepl(pattern, name)) 
[13:35:32.059]                             next
[13:35:32.059]                           invokeRestart(restart)
[13:35:32.059]                           muffled <- TRUE
[13:35:32.059]                           break
[13:35:32.059]                         }
[13:35:32.059]                       }
[13:35:32.059]                     }
[13:35:32.059]                     invisible(muffled)
[13:35:32.059]                   }
[13:35:32.059]                   muffleCondition(cond)
[13:35:32.059]                 })
[13:35:32.059]             }))
[13:35:32.059]             future::FutureResult(value = ...future.value$value, 
[13:35:32.059]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:32.059]                   ...future.rng), globalenv = if (FALSE) 
[13:35:32.059]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:32.059]                     ...future.globalenv.names))
[13:35:32.059]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:32.059]         }, condition = base::local({
[13:35:32.059]             c <- base::c
[13:35:32.059]             inherits <- base::inherits
[13:35:32.059]             invokeRestart <- base::invokeRestart
[13:35:32.059]             length <- base::length
[13:35:32.059]             list <- base::list
[13:35:32.059]             seq.int <- base::seq.int
[13:35:32.059]             signalCondition <- base::signalCondition
[13:35:32.059]             sys.calls <- base::sys.calls
[13:35:32.059]             `[[` <- base::`[[`
[13:35:32.059]             `+` <- base::`+`
[13:35:32.059]             `<<-` <- base::`<<-`
[13:35:32.059]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:32.059]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:32.059]                   3L)]
[13:35:32.059]             }
[13:35:32.059]             function(cond) {
[13:35:32.059]                 is_error <- inherits(cond, "error")
[13:35:32.059]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:32.059]                   NULL)
[13:35:32.059]                 if (is_error) {
[13:35:32.059]                   sessionInformation <- function() {
[13:35:32.059]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:32.059]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:32.059]                       search = base::search(), system = base::Sys.info())
[13:35:32.059]                   }
[13:35:32.059]                   ...future.conditions[[length(...future.conditions) + 
[13:35:32.059]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:32.059]                     cond$call), session = sessionInformation(), 
[13:35:32.059]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:32.059]                   signalCondition(cond)
[13:35:32.059]                 }
[13:35:32.059]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:32.059]                 "immediateCondition"))) {
[13:35:32.059]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:32.059]                   ...future.conditions[[length(...future.conditions) + 
[13:35:32.059]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:32.059]                   if (TRUE && !signal) {
[13:35:32.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:32.059]                     {
[13:35:32.059]                       inherits <- base::inherits
[13:35:32.059]                       invokeRestart <- base::invokeRestart
[13:35:32.059]                       is.null <- base::is.null
[13:35:32.059]                       muffled <- FALSE
[13:35:32.059]                       if (inherits(cond, "message")) {
[13:35:32.059]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:32.059]                         if (muffled) 
[13:35:32.059]                           invokeRestart("muffleMessage")
[13:35:32.059]                       }
[13:35:32.059]                       else if (inherits(cond, "warning")) {
[13:35:32.059]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:32.059]                         if (muffled) 
[13:35:32.059]                           invokeRestart("muffleWarning")
[13:35:32.059]                       }
[13:35:32.059]                       else if (inherits(cond, "condition")) {
[13:35:32.059]                         if (!is.null(pattern)) {
[13:35:32.059]                           computeRestarts <- base::computeRestarts
[13:35:32.059]                           grepl <- base::grepl
[13:35:32.059]                           restarts <- computeRestarts(cond)
[13:35:32.059]                           for (restart in restarts) {
[13:35:32.059]                             name <- restart$name
[13:35:32.059]                             if (is.null(name)) 
[13:35:32.059]                               next
[13:35:32.059]                             if (!grepl(pattern, name)) 
[13:35:32.059]                               next
[13:35:32.059]                             invokeRestart(restart)
[13:35:32.059]                             muffled <- TRUE
[13:35:32.059]                             break
[13:35:32.059]                           }
[13:35:32.059]                         }
[13:35:32.059]                       }
[13:35:32.059]                       invisible(muffled)
[13:35:32.059]                     }
[13:35:32.059]                     muffleCondition(cond, pattern = "^muffle")
[13:35:32.059]                   }
[13:35:32.059]                 }
[13:35:32.059]                 else {
[13:35:32.059]                   if (TRUE) {
[13:35:32.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:32.059]                     {
[13:35:32.059]                       inherits <- base::inherits
[13:35:32.059]                       invokeRestart <- base::invokeRestart
[13:35:32.059]                       is.null <- base::is.null
[13:35:32.059]                       muffled <- FALSE
[13:35:32.059]                       if (inherits(cond, "message")) {
[13:35:32.059]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:32.059]                         if (muffled) 
[13:35:32.059]                           invokeRestart("muffleMessage")
[13:35:32.059]                       }
[13:35:32.059]                       else if (inherits(cond, "warning")) {
[13:35:32.059]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:32.059]                         if (muffled) 
[13:35:32.059]                           invokeRestart("muffleWarning")
[13:35:32.059]                       }
[13:35:32.059]                       else if (inherits(cond, "condition")) {
[13:35:32.059]                         if (!is.null(pattern)) {
[13:35:32.059]                           computeRestarts <- base::computeRestarts
[13:35:32.059]                           grepl <- base::grepl
[13:35:32.059]                           restarts <- computeRestarts(cond)
[13:35:32.059]                           for (restart in restarts) {
[13:35:32.059]                             name <- restart$name
[13:35:32.059]                             if (is.null(name)) 
[13:35:32.059]                               next
[13:35:32.059]                             if (!grepl(pattern, name)) 
[13:35:32.059]                               next
[13:35:32.059]                             invokeRestart(restart)
[13:35:32.059]                             muffled <- TRUE
[13:35:32.059]                             break
[13:35:32.059]                           }
[13:35:32.059]                         }
[13:35:32.059]                       }
[13:35:32.059]                       invisible(muffled)
[13:35:32.059]                     }
[13:35:32.059]                     muffleCondition(cond, pattern = "^muffle")
[13:35:32.059]                   }
[13:35:32.059]                 }
[13:35:32.059]             }
[13:35:32.059]         }))
[13:35:32.059]     }, error = function(ex) {
[13:35:32.059]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:32.059]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:32.059]                 ...future.rng), started = ...future.startTime, 
[13:35:32.059]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:32.059]             version = "1.8"), class = "FutureResult")
[13:35:32.059]     }, finally = {
[13:35:32.059]         if (!identical(...future.workdir, getwd())) 
[13:35:32.059]             setwd(...future.workdir)
[13:35:32.059]         {
[13:35:32.059]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:32.059]                 ...future.oldOptions$nwarnings <- NULL
[13:35:32.059]             }
[13:35:32.059]             base::options(...future.oldOptions)
[13:35:32.059]             if (.Platform$OS.type == "windows") {
[13:35:32.059]                 old_names <- names(...future.oldEnvVars)
[13:35:32.059]                 envs <- base::Sys.getenv()
[13:35:32.059]                 names <- names(envs)
[13:35:32.059]                 common <- intersect(names, old_names)
[13:35:32.059]                 added <- setdiff(names, old_names)
[13:35:32.059]                 removed <- setdiff(old_names, names)
[13:35:32.059]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:32.059]                   envs[common]]
[13:35:32.059]                 NAMES <- toupper(changed)
[13:35:32.059]                 args <- list()
[13:35:32.059]                 for (kk in seq_along(NAMES)) {
[13:35:32.059]                   name <- changed[[kk]]
[13:35:32.059]                   NAME <- NAMES[[kk]]
[13:35:32.059]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:32.059]                     next
[13:35:32.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:32.059]                 }
[13:35:32.059]                 NAMES <- toupper(added)
[13:35:32.059]                 for (kk in seq_along(NAMES)) {
[13:35:32.059]                   name <- added[[kk]]
[13:35:32.059]                   NAME <- NAMES[[kk]]
[13:35:32.059]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:32.059]                     next
[13:35:32.059]                   args[[name]] <- ""
[13:35:32.059]                 }
[13:35:32.059]                 NAMES <- toupper(removed)
[13:35:32.059]                 for (kk in seq_along(NAMES)) {
[13:35:32.059]                   name <- removed[[kk]]
[13:35:32.059]                   NAME <- NAMES[[kk]]
[13:35:32.059]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:32.059]                     next
[13:35:32.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:32.059]                 }
[13:35:32.059]                 if (length(args) > 0) 
[13:35:32.059]                   base::do.call(base::Sys.setenv, args = args)
[13:35:32.059]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:32.059]             }
[13:35:32.059]             else {
[13:35:32.059]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:32.059]             }
[13:35:32.059]             {
[13:35:32.059]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:32.059]                   0L) {
[13:35:32.059]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:32.059]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:32.059]                   base::options(opts)
[13:35:32.059]                 }
[13:35:32.059]                 {
[13:35:32.059]                   {
[13:35:32.059]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:32.059]                     NULL
[13:35:32.059]                   }
[13:35:32.059]                   options(future.plan = NULL)
[13:35:32.059]                   if (is.na(NA_character_)) 
[13:35:32.059]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:32.059]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:32.059]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:32.059]                     .init = FALSE)
[13:35:32.059]                 }
[13:35:32.059]             }
[13:35:32.059]         }
[13:35:32.059]     })
[13:35:32.059]     if (TRUE) {
[13:35:32.059]         base::sink(type = "output", split = FALSE)
[13:35:32.059]         if (TRUE) {
[13:35:32.059]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:32.059]         }
[13:35:32.059]         else {
[13:35:32.059]             ...future.result["stdout"] <- base::list(NULL)
[13:35:32.059]         }
[13:35:32.059]         base::close(...future.stdout)
[13:35:32.059]         ...future.stdout <- NULL
[13:35:32.059]     }
[13:35:32.059]     ...future.result$conditions <- ...future.conditions
[13:35:32.059]     ...future.result$finished <- base::Sys.time()
[13:35:32.059]     ...future.result
[13:35:32.059] }
[13:35:32.062] assign_globals() ...
[13:35:32.062] List of 5
[13:35:32.062]  $ ...future.FUN            :function (x, y)  
[13:35:32.062]  $ MoreArgs                 : NULL
[13:35:32.062]  $ ...future.elements_ii    :List of 2
[13:35:32.062]   ..$ :List of 1
[13:35:32.062]   .. ..$ : int 1
[13:35:32.062]   ..$ :List of 1
[13:35:32.062]   .. ..$ : int 0
[13:35:32.062]  $ ...future.seeds_ii       : NULL
[13:35:32.062]  $ ...future.globals.maxSize: NULL
[13:35:32.062]  - attr(*, "where")=List of 5
[13:35:32.062]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:32.062]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:35:32.062]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:32.062]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:32.062]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:32.062]  - attr(*, "resolved")= logi FALSE
[13:35:32.062]  - attr(*, "total_size")= num 6368
[13:35:32.062]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:32.062]  - attr(*, "already-done")= logi TRUE
[13:35:32.067] - reassign environment for ‘...future.FUN’
[13:35:32.067] - copied ‘...future.FUN’ to environment
[13:35:32.067] - copied ‘MoreArgs’ to environment
[13:35:32.067] - copied ‘...future.elements_ii’ to environment
[13:35:32.067] - copied ‘...future.seeds_ii’ to environment
[13:35:32.067] - copied ‘...future.globals.maxSize’ to environment
[13:35:32.068] assign_globals() ... done
[13:35:32.068] requestCore(): workers = 2
[13:35:32.070] MulticoreFuture started
[13:35:32.070] - Launch lazy future ... done
[13:35:32.070] run() for ‘MulticoreFuture’ ... done
[13:35:32.071] Created future:
[13:35:32.071] plan(): Setting new future strategy stack:
[13:35:32.071] List of future strategies:
[13:35:32.071] 1. sequential:
[13:35:32.071]    - args: function (..., envir = parent.frame())
[13:35:32.071]    - tweaked: FALSE
[13:35:32.071]    - call: NULL
[13:35:32.072] plan(): nbrOfWorkers() = 1
[13:35:32.071] MulticoreFuture:
[13:35:32.071] Label: ‘future_mapply-1’
[13:35:32.071] Expression:
[13:35:32.071] {
[13:35:32.071]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:32.071]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:32.071]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:32.071]         on.exit(options(oopts), add = TRUE)
[13:35:32.071]     }
[13:35:32.071]     {
[13:35:32.071]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:32.071]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:35:32.071]         do.call(mapply, args = args)
[13:35:32.071]     }
[13:35:32.071] }
[13:35:32.071] Lazy evaluation: FALSE
[13:35:32.071] Asynchronous evaluation: TRUE
[13:35:32.071] Local evaluation: TRUE
[13:35:32.071] Environment: R_GlobalEnv
[13:35:32.071] Capture standard output: TRUE
[13:35:32.071] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:32.071] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:32.071] Packages: <none>
[13:35:32.071] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:32.071] Resolved: FALSE
[13:35:32.071] Value: <not collected>
[13:35:32.071] Conditions captured: <none>
[13:35:32.071] Early signaling: FALSE
[13:35:32.071] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:32.071] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:32.083] Chunk #1 of 2 ... DONE
[13:35:32.084] Chunk #2 of 2 ...
[13:35:32.084]  - Finding globals in '...' for chunk #2 ...
[13:35:32.084] getGlobalsAndPackages() ...
[13:35:32.084] Searching for globals...
[13:35:32.085] 
[13:35:32.085] Searching for globals ... DONE
[13:35:32.085] - globals: [0] <none>
[13:35:32.085] getGlobalsAndPackages() ... DONE
[13:35:32.085]    + additional globals found: [n=0] 
[13:35:32.086]    + additional namespaces needed: [n=0] 
[13:35:32.086]  - Finding globals in '...' for chunk #2 ... DONE
[13:35:32.086]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:32.086]  - seeds: <none>
[13:35:32.086]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:32.086] getGlobalsAndPackages() ...
[13:35:32.087] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:32.087] Resolving globals: FALSE
[13:35:32.088] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:35:32.089] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:35:32.089] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:32.089] 
[13:35:32.102] getGlobalsAndPackages() ... DONE
[13:35:32.103] run() for ‘Future’ ...
[13:35:32.103] - state: ‘created’
[13:35:32.103] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:32.108] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:32.108] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:32.108]   - Field: ‘label’
[13:35:32.109]   - Field: ‘local’
[13:35:32.109]   - Field: ‘owner’
[13:35:32.109]   - Field: ‘envir’
[13:35:32.109]   - Field: ‘workers’
[13:35:32.109]   - Field: ‘packages’
[13:35:32.109]   - Field: ‘gc’
[13:35:32.110]   - Field: ‘job’
[13:35:32.110]   - Field: ‘conditions’
[13:35:32.110]   - Field: ‘expr’
[13:35:32.110]   - Field: ‘uuid’
[13:35:32.110]   - Field: ‘seed’
[13:35:32.110]   - Field: ‘version’
[13:35:32.110]   - Field: ‘result’
[13:35:32.111]   - Field: ‘asynchronous’
[13:35:32.111]   - Field: ‘calls’
[13:35:32.111]   - Field: ‘globals’
[13:35:32.111]   - Field: ‘stdout’
[13:35:32.111]   - Field: ‘earlySignal’
[13:35:32.111]   - Field: ‘lazy’
[13:35:32.111]   - Field: ‘state’
[13:35:32.111] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:32.112] - Launch lazy future ...
[13:35:32.112] Packages needed by the future expression (n = 0): <none>
[13:35:32.112] Packages needed by future strategies (n = 0): <none>
[13:35:32.113] {
[13:35:32.113]     {
[13:35:32.113]         {
[13:35:32.113]             ...future.startTime <- base::Sys.time()
[13:35:32.113]             {
[13:35:32.113]                 {
[13:35:32.113]                   {
[13:35:32.113]                     {
[13:35:32.113]                       base::local({
[13:35:32.113]                         has_future <- base::requireNamespace("future", 
[13:35:32.113]                           quietly = TRUE)
[13:35:32.113]                         if (has_future) {
[13:35:32.113]                           ns <- base::getNamespace("future")
[13:35:32.113]                           version <- ns[[".package"]][["version"]]
[13:35:32.113]                           if (is.null(version)) 
[13:35:32.113]                             version <- utils::packageVersion("future")
[13:35:32.113]                         }
[13:35:32.113]                         else {
[13:35:32.113]                           version <- NULL
[13:35:32.113]                         }
[13:35:32.113]                         if (!has_future || version < "1.8.0") {
[13:35:32.113]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:32.113]                             "", base::R.version$version.string), 
[13:35:32.113]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:32.113]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:32.113]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:32.113]                               "release", "version")], collapse = " "), 
[13:35:32.113]                             hostname = base::Sys.info()[["nodename"]])
[13:35:32.113]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:32.113]                             info)
[13:35:32.113]                           info <- base::paste(info, collapse = "; ")
[13:35:32.113]                           if (!has_future) {
[13:35:32.113]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:32.113]                               info)
[13:35:32.113]                           }
[13:35:32.113]                           else {
[13:35:32.113]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:32.113]                               info, version)
[13:35:32.113]                           }
[13:35:32.113]                           base::stop(msg)
[13:35:32.113]                         }
[13:35:32.113]                       })
[13:35:32.113]                     }
[13:35:32.113]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:32.113]                     base::options(mc.cores = 1L)
[13:35:32.113]                   }
[13:35:32.113]                   ...future.strategy.old <- future::plan("list")
[13:35:32.113]                   options(future.plan = NULL)
[13:35:32.113]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:32.113]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:32.113]                 }
[13:35:32.113]                 ...future.workdir <- getwd()
[13:35:32.113]             }
[13:35:32.113]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:32.113]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:32.113]         }
[13:35:32.113]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:32.113]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:32.113]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:32.113]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:32.113]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:32.113]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:32.113]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:32.113]             base::names(...future.oldOptions))
[13:35:32.113]     }
[13:35:32.113]     if (FALSE) {
[13:35:32.113]     }
[13:35:32.113]     else {
[13:35:32.113]         if (TRUE) {
[13:35:32.113]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:32.113]                 open = "w")
[13:35:32.113]         }
[13:35:32.113]         else {
[13:35:32.113]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:32.113]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:32.113]         }
[13:35:32.113]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:32.113]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:32.113]             base::sink(type = "output", split = FALSE)
[13:35:32.113]             base::close(...future.stdout)
[13:35:32.113]         }, add = TRUE)
[13:35:32.113]     }
[13:35:32.113]     ...future.frame <- base::sys.nframe()
[13:35:32.113]     ...future.conditions <- base::list()
[13:35:32.113]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:32.113]     if (FALSE) {
[13:35:32.113]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:32.113]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:32.113]     }
[13:35:32.113]     ...future.result <- base::tryCatch({
[13:35:32.113]         base::withCallingHandlers({
[13:35:32.113]             ...future.value <- base::withVisible(base::local({
[13:35:32.113]                 withCallingHandlers({
[13:35:32.113]                   {
[13:35:32.113]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:32.113]                     if (!identical(...future.globals.maxSize.org, 
[13:35:32.113]                       ...future.globals.maxSize)) {
[13:35:32.113]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:32.113]                       on.exit(options(oopts), add = TRUE)
[13:35:32.113]                     }
[13:35:32.113]                     {
[13:35:32.113]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:32.113]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:35:32.113]                         USE.NAMES = FALSE)
[13:35:32.113]                       do.call(mapply, args = args)
[13:35:32.113]                     }
[13:35:32.113]                   }
[13:35:32.113]                 }, immediateCondition = function(cond) {
[13:35:32.113]                   save_rds <- function (object, pathname, ...) 
[13:35:32.113]                   {
[13:35:32.113]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:32.113]                     if (file_test("-f", pathname_tmp)) {
[13:35:32.113]                       fi_tmp <- file.info(pathname_tmp)
[13:35:32.113]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:32.113]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:32.113]                         fi_tmp[["mtime"]])
[13:35:32.113]                     }
[13:35:32.113]                     tryCatch({
[13:35:32.113]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:32.113]                     }, error = function(ex) {
[13:35:32.113]                       msg <- conditionMessage(ex)
[13:35:32.113]                       fi_tmp <- file.info(pathname_tmp)
[13:35:32.113]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:32.113]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:32.113]                         fi_tmp[["mtime"]], msg)
[13:35:32.113]                       ex$message <- msg
[13:35:32.113]                       stop(ex)
[13:35:32.113]                     })
[13:35:32.113]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:32.113]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:32.113]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:32.113]                       fi_tmp <- file.info(pathname_tmp)
[13:35:32.113]                       fi <- file.info(pathname)
[13:35:32.113]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:32.113]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:32.113]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:32.113]                         fi[["size"]], fi[["mtime"]])
[13:35:32.113]                       stop(msg)
[13:35:32.113]                     }
[13:35:32.113]                     invisible(pathname)
[13:35:32.113]                   }
[13:35:32.113]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:32.113]                     rootPath = tempdir()) 
[13:35:32.113]                   {
[13:35:32.113]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:32.113]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:32.113]                       tmpdir = path, fileext = ".rds")
[13:35:32.113]                     save_rds(obj, file)
[13:35:32.113]                   }
[13:35:32.113]                   saveImmediateCondition(cond, path = "/tmp/RtmpghgvGN/.future/immediateConditions")
[13:35:32.113]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:32.113]                   {
[13:35:32.113]                     inherits <- base::inherits
[13:35:32.113]                     invokeRestart <- base::invokeRestart
[13:35:32.113]                     is.null <- base::is.null
[13:35:32.113]                     muffled <- FALSE
[13:35:32.113]                     if (inherits(cond, "message")) {
[13:35:32.113]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:32.113]                       if (muffled) 
[13:35:32.113]                         invokeRestart("muffleMessage")
[13:35:32.113]                     }
[13:35:32.113]                     else if (inherits(cond, "warning")) {
[13:35:32.113]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:32.113]                       if (muffled) 
[13:35:32.113]                         invokeRestart("muffleWarning")
[13:35:32.113]                     }
[13:35:32.113]                     else if (inherits(cond, "condition")) {
[13:35:32.113]                       if (!is.null(pattern)) {
[13:35:32.113]                         computeRestarts <- base::computeRestarts
[13:35:32.113]                         grepl <- base::grepl
[13:35:32.113]                         restarts <- computeRestarts(cond)
[13:35:32.113]                         for (restart in restarts) {
[13:35:32.113]                           name <- restart$name
[13:35:32.113]                           if (is.null(name)) 
[13:35:32.113]                             next
[13:35:32.113]                           if (!grepl(pattern, name)) 
[13:35:32.113]                             next
[13:35:32.113]                           invokeRestart(restart)
[13:35:32.113]                           muffled <- TRUE
[13:35:32.113]                           break
[13:35:32.113]                         }
[13:35:32.113]                       }
[13:35:32.113]                     }
[13:35:32.113]                     invisible(muffled)
[13:35:32.113]                   }
[13:35:32.113]                   muffleCondition(cond)
[13:35:32.113]                 })
[13:35:32.113]             }))
[13:35:32.113]             future::FutureResult(value = ...future.value$value, 
[13:35:32.113]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:32.113]                   ...future.rng), globalenv = if (FALSE) 
[13:35:32.113]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:32.113]                     ...future.globalenv.names))
[13:35:32.113]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:32.113]         }, condition = base::local({
[13:35:32.113]             c <- base::c
[13:35:32.113]             inherits <- base::inherits
[13:35:32.113]             invokeRestart <- base::invokeRestart
[13:35:32.113]             length <- base::length
[13:35:32.113]             list <- base::list
[13:35:32.113]             seq.int <- base::seq.int
[13:35:32.113]             signalCondition <- base::signalCondition
[13:35:32.113]             sys.calls <- base::sys.calls
[13:35:32.113]             `[[` <- base::`[[`
[13:35:32.113]             `+` <- base::`+`
[13:35:32.113]             `<<-` <- base::`<<-`
[13:35:32.113]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:32.113]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:32.113]                   3L)]
[13:35:32.113]             }
[13:35:32.113]             function(cond) {
[13:35:32.113]                 is_error <- inherits(cond, "error")
[13:35:32.113]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:32.113]                   NULL)
[13:35:32.113]                 if (is_error) {
[13:35:32.113]                   sessionInformation <- function() {
[13:35:32.113]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:32.113]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:32.113]                       search = base::search(), system = base::Sys.info())
[13:35:32.113]                   }
[13:35:32.113]                   ...future.conditions[[length(...future.conditions) + 
[13:35:32.113]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:32.113]                     cond$call), session = sessionInformation(), 
[13:35:32.113]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:32.113]                   signalCondition(cond)
[13:35:32.113]                 }
[13:35:32.113]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:32.113]                 "immediateCondition"))) {
[13:35:32.113]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:32.113]                   ...future.conditions[[length(...future.conditions) + 
[13:35:32.113]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:32.113]                   if (TRUE && !signal) {
[13:35:32.113]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:32.113]                     {
[13:35:32.113]                       inherits <- base::inherits
[13:35:32.113]                       invokeRestart <- base::invokeRestart
[13:35:32.113]                       is.null <- base::is.null
[13:35:32.113]                       muffled <- FALSE
[13:35:32.113]                       if (inherits(cond, "message")) {
[13:35:32.113]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:32.113]                         if (muffled) 
[13:35:32.113]                           invokeRestart("muffleMessage")
[13:35:32.113]                       }
[13:35:32.113]                       else if (inherits(cond, "warning")) {
[13:35:32.113]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:32.113]                         if (muffled) 
[13:35:32.113]                           invokeRestart("muffleWarning")
[13:35:32.113]                       }
[13:35:32.113]                       else if (inherits(cond, "condition")) {
[13:35:32.113]                         if (!is.null(pattern)) {
[13:35:32.113]                           computeRestarts <- base::computeRestarts
[13:35:32.113]                           grepl <- base::grepl
[13:35:32.113]                           restarts <- computeRestarts(cond)
[13:35:32.113]                           for (restart in restarts) {
[13:35:32.113]                             name <- restart$name
[13:35:32.113]                             if (is.null(name)) 
[13:35:32.113]                               next
[13:35:32.113]                             if (!grepl(pattern, name)) 
[13:35:32.113]                               next
[13:35:32.113]                             invokeRestart(restart)
[13:35:32.113]                             muffled <- TRUE
[13:35:32.113]                             break
[13:35:32.113]                           }
[13:35:32.113]                         }
[13:35:32.113]                       }
[13:35:32.113]                       invisible(muffled)
[13:35:32.113]                     }
[13:35:32.113]                     muffleCondition(cond, pattern = "^muffle")
[13:35:32.113]                   }
[13:35:32.113]                 }
[13:35:32.113]                 else {
[13:35:32.113]                   if (TRUE) {
[13:35:32.113]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:32.113]                     {
[13:35:32.113]                       inherits <- base::inherits
[13:35:32.113]                       invokeRestart <- base::invokeRestart
[13:35:32.113]                       is.null <- base::is.null
[13:35:32.113]                       muffled <- FALSE
[13:35:32.113]                       if (inherits(cond, "message")) {
[13:35:32.113]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:32.113]                         if (muffled) 
[13:35:32.113]                           invokeRestart("muffleMessage")
[13:35:32.113]                       }
[13:35:32.113]                       else if (inherits(cond, "warning")) {
[13:35:32.113]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:32.113]                         if (muffled) 
[13:35:32.113]                           invokeRestart("muffleWarning")
[13:35:32.113]                       }
[13:35:32.113]                       else if (inherits(cond, "condition")) {
[13:35:32.113]                         if (!is.null(pattern)) {
[13:35:32.113]                           computeRestarts <- base::computeRestarts
[13:35:32.113]                           grepl <- base::grepl
[13:35:32.113]                           restarts <- computeRestarts(cond)
[13:35:32.113]                           for (restart in restarts) {
[13:35:32.113]                             name <- restart$name
[13:35:32.113]                             if (is.null(name)) 
[13:35:32.113]                               next
[13:35:32.113]                             if (!grepl(pattern, name)) 
[13:35:32.113]                               next
[13:35:32.113]                             invokeRestart(restart)
[13:35:32.113]                             muffled <- TRUE
[13:35:32.113]                             break
[13:35:32.113]                           }
[13:35:32.113]                         }
[13:35:32.113]                       }
[13:35:32.113]                       invisible(muffled)
[13:35:32.113]                     }
[13:35:32.113]                     muffleCondition(cond, pattern = "^muffle")
[13:35:32.113]                   }
[13:35:32.113]                 }
[13:35:32.113]             }
[13:35:32.113]         }))
[13:35:32.113]     }, error = function(ex) {
[13:35:32.113]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:32.113]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:32.113]                 ...future.rng), started = ...future.startTime, 
[13:35:32.113]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:32.113]             version = "1.8"), class = "FutureResult")
[13:35:32.113]     }, finally = {
[13:35:32.113]         if (!identical(...future.workdir, getwd())) 
[13:35:32.113]             setwd(...future.workdir)
[13:35:32.113]         {
[13:35:32.113]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:32.113]                 ...future.oldOptions$nwarnings <- NULL
[13:35:32.113]             }
[13:35:32.113]             base::options(...future.oldOptions)
[13:35:32.113]             if (.Platform$OS.type == "windows") {
[13:35:32.113]                 old_names <- names(...future.oldEnvVars)
[13:35:32.113]                 envs <- base::Sys.getenv()
[13:35:32.113]                 names <- names(envs)
[13:35:32.113]                 common <- intersect(names, old_names)
[13:35:32.113]                 added <- setdiff(names, old_names)
[13:35:32.113]                 removed <- setdiff(old_names, names)
[13:35:32.113]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:32.113]                   envs[common]]
[13:35:32.113]                 NAMES <- toupper(changed)
[13:35:32.113]                 args <- list()
[13:35:32.113]                 for (kk in seq_along(NAMES)) {
[13:35:32.113]                   name <- changed[[kk]]
[13:35:32.113]                   NAME <- NAMES[[kk]]
[13:35:32.113]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:32.113]                     next
[13:35:32.113]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:32.113]                 }
[13:35:32.113]                 NAMES <- toupper(added)
[13:35:32.113]                 for (kk in seq_along(NAMES)) {
[13:35:32.113]                   name <- added[[kk]]
[13:35:32.113]                   NAME <- NAMES[[kk]]
[13:35:32.113]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:32.113]                     next
[13:35:32.113]                   args[[name]] <- ""
[13:35:32.113]                 }
[13:35:32.113]                 NAMES <- toupper(removed)
[13:35:32.113]                 for (kk in seq_along(NAMES)) {
[13:35:32.113]                   name <- removed[[kk]]
[13:35:32.113]                   NAME <- NAMES[[kk]]
[13:35:32.113]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:32.113]                     next
[13:35:32.113]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:32.113]                 }
[13:35:32.113]                 if (length(args) > 0) 
[13:35:32.113]                   base::do.call(base::Sys.setenv, args = args)
[13:35:32.113]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:32.113]             }
[13:35:32.113]             else {
[13:35:32.113]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:32.113]             }
[13:35:32.113]             {
[13:35:32.113]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:32.113]                   0L) {
[13:35:32.113]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:32.113]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:32.113]                   base::options(opts)
[13:35:32.113]                 }
[13:35:32.113]                 {
[13:35:32.113]                   {
[13:35:32.113]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:32.113]                     NULL
[13:35:32.113]                   }
[13:35:32.113]                   options(future.plan = NULL)
[13:35:32.113]                   if (is.na(NA_character_)) 
[13:35:32.113]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:32.113]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:32.113]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:32.113]                     .init = FALSE)
[13:35:32.113]                 }
[13:35:32.113]             }
[13:35:32.113]         }
[13:35:32.113]     })
[13:35:32.113]     if (TRUE) {
[13:35:32.113]         base::sink(type = "output", split = FALSE)
[13:35:32.113]         if (TRUE) {
[13:35:32.113]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:32.113]         }
[13:35:32.113]         else {
[13:35:32.113]             ...future.result["stdout"] <- base::list(NULL)
[13:35:32.113]         }
[13:35:32.113]         base::close(...future.stdout)
[13:35:32.113]         ...future.stdout <- NULL
[13:35:32.113]     }
[13:35:32.113]     ...future.result$conditions <- ...future.conditions
[13:35:32.113]     ...future.result$finished <- base::Sys.time()
[13:35:32.113]     ...future.result
[13:35:32.113] }
[13:35:32.116] assign_globals() ...
[13:35:32.116] List of 5
[13:35:32.116]  $ ...future.FUN            :function (x, y)  
[13:35:32.116]  $ MoreArgs                 : NULL
[13:35:32.116]  $ ...future.elements_ii    :List of 2
[13:35:32.116]   ..$ :List of 1
[13:35:32.116]   .. ..$ : int 0
[13:35:32.116]   ..$ :List of 1
[13:35:32.116]   .. ..$ : int 1
[13:35:32.116]  $ ...future.seeds_ii       : NULL
[13:35:32.116]  $ ...future.globals.maxSize: NULL
[13:35:32.116]  - attr(*, "where")=List of 5
[13:35:32.116]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:32.116]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:35:32.116]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:32.116]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:32.116]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:32.116]  - attr(*, "resolved")= logi FALSE
[13:35:32.116]  - attr(*, "total_size")= num 6368
[13:35:32.116]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:32.116]  - attr(*, "already-done")= logi TRUE
[13:35:32.122] - reassign environment for ‘...future.FUN’
[13:35:32.123] - copied ‘...future.FUN’ to environment
[13:35:32.123] - copied ‘MoreArgs’ to environment
[13:35:32.123] - copied ‘...future.elements_ii’ to environment
[13:35:32.123] - copied ‘...future.seeds_ii’ to environment
[13:35:32.123] - copied ‘...future.globals.maxSize’ to environment
[13:35:32.123] assign_globals() ... done
[13:35:32.123] requestCore(): workers = 2
[13:35:32.126] MulticoreFuture started
[13:35:32.126] - Launch lazy future ... done
[13:35:32.126] run() for ‘MulticoreFuture’ ... done
[13:35:32.126] Created future:
[13:35:32.127] plan(): Setting new future strategy stack:
[13:35:32.127] List of future strategies:
[13:35:32.127] 1. sequential:
[13:35:32.127]    - args: function (..., envir = parent.frame())
[13:35:32.127]    - tweaked: FALSE
[13:35:32.127]    - call: NULL
[13:35:32.128] plan(): nbrOfWorkers() = 1
[13:35:32.130] plan(): Setting new future strategy stack:
[13:35:32.130] List of future strategies:
[13:35:32.130] 1. multicore:
[13:35:32.130]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:32.130]    - tweaked: FALSE
[13:35:32.130]    - call: plan(strategy)
[13:35:32.135] plan(): nbrOfWorkers() = 2
[13:35:32.127] MulticoreFuture:
[13:35:32.127] Label: ‘future_mapply-2’
[13:35:32.127] Expression:
[13:35:32.127] {
[13:35:32.127]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:32.127]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:32.127]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:32.127]         on.exit(options(oopts), add = TRUE)
[13:35:32.127]     }
[13:35:32.127]     {
[13:35:32.127]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:32.127]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:35:32.127]         do.call(mapply, args = args)
[13:35:32.127]     }
[13:35:32.127] }
[13:35:32.127] Lazy evaluation: FALSE
[13:35:32.127] Asynchronous evaluation: TRUE
[13:35:32.127] Local evaluation: TRUE
[13:35:32.127] Environment: R_GlobalEnv
[13:35:32.127] Capture standard output: TRUE
[13:35:32.127] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:32.127] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:32.127] Packages: <none>
[13:35:32.127] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:32.127] Resolved: TRUE
[13:35:32.127] Value: <not collected>
[13:35:32.127] Conditions captured: <none>
[13:35:32.127] Early signaling: FALSE
[13:35:32.127] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:32.127] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:32.136] Chunk #2 of 2 ... DONE
[13:35:32.137] Launching 2 futures (chunks) ... DONE
[13:35:32.137] Resolving 2 futures (chunks) ...
[13:35:32.137] resolve() on list ...
[13:35:32.137]  recursive: 0
[13:35:32.137]  length: 2
[13:35:32.137] 
[13:35:32.148] Future #2
[13:35:32.148] result() for MulticoreFuture ...
[13:35:32.149] result() for MulticoreFuture ...
[13:35:32.150] result() for MulticoreFuture ... done
[13:35:32.150] result() for MulticoreFuture ... done
[13:35:32.150] result() for MulticoreFuture ...
[13:35:32.150] result() for MulticoreFuture ... done
[13:35:32.150] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:35:32.150] - nx: 2
[13:35:32.150] - relay: TRUE
[13:35:32.151] - stdout: TRUE
[13:35:32.151] - signal: TRUE
[13:35:32.151] - resignal: FALSE
[13:35:32.151] - force: TRUE
[13:35:32.151] - relayed: [n=2] FALSE, FALSE
[13:35:32.151] - queued futures: [n=2] FALSE, FALSE
[13:35:32.151]  - until=1
[13:35:32.151]  - relaying element #1
[13:35:32.152] - relayed: [n=2] FALSE, FALSE
[13:35:32.152] - queued futures: [n=2] FALSE, TRUE
[13:35:32.152] signalConditionsASAP(NULL, pos=2) ... done
[13:35:32.152]  length: 1 (resolved future 2)
[13:35:32.575] plan(): Setting new future strategy stack:
[13:35:32.575] List of future strategies:
[13:35:32.575] 1. multicore:
[13:35:32.575]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:32.575]    - tweaked: FALSE
[13:35:32.575]    - call: plan(strategy)
[13:35:32.580] plan(): nbrOfWorkers() = 2
[13:35:32.590] Future #1
[13:35:32.590] result() for MulticoreFuture ...
[13:35:32.591] result() for MulticoreFuture ...
[13:35:32.591] result() for MulticoreFuture ... done
[13:35:32.591] result() for MulticoreFuture ... done
[13:35:32.592] result() for MulticoreFuture ...
[13:35:32.592] result() for MulticoreFuture ... done
[13:35:32.592] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:35:32.592] - nx: 2
[13:35:32.592] - relay: TRUE
[13:35:32.592] - stdout: TRUE
[13:35:32.592] - signal: TRUE
[13:35:32.592] - resignal: FALSE
[13:35:32.592] - force: TRUE
[13:35:32.593] - relayed: [n=2] FALSE, FALSE
[13:35:32.593] - queued futures: [n=2] FALSE, TRUE
[13:35:32.593]  - until=1
[13:35:32.593]  - relaying element #1
[13:35:32.593] result() for MulticoreFuture ...
[13:35:32.593] result() for MulticoreFuture ... done
[13:35:32.593] result() for MulticoreFuture ...
[13:35:32.593] result() for MulticoreFuture ... done
[13:35:32.594] result() for MulticoreFuture ...
[13:35:32.594] result() for MulticoreFuture ... done
[13:35:32.594] result() for MulticoreFuture ...
[13:35:32.594] result() for MulticoreFuture ... done
[13:35:32.594] - relayed: [n=2] TRUE, FALSE
[13:35:32.594] - queued futures: [n=2] TRUE, TRUE
[13:35:32.594] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:35:32.595]  length: 0 (resolved future 1)
[13:35:32.595] Relaying remaining futures
[13:35:32.595] signalConditionsASAP(NULL, pos=0) ...
[13:35:32.595] - nx: 2
[13:35:32.595] - relay: TRUE
[13:35:32.595] - stdout: TRUE
[13:35:32.595] - signal: TRUE
[13:35:32.598] - resignal: FALSE
[13:35:32.598] - force: TRUE
[13:35:32.598] - relayed: [n=2] TRUE, FALSE
[13:35:32.599] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:32.599]  - relaying element #2
[13:35:32.599] result() for MulticoreFuture ...
[13:35:32.599] result() for MulticoreFuture ... done
[13:35:32.599] result() for MulticoreFuture ...
[13:35:32.600] result() for MulticoreFuture ... done
[13:35:32.600] result() for MulticoreFuture ...
[13:35:32.600] result() for MulticoreFuture ... done
[13:35:32.600] result() for MulticoreFuture ...
[13:35:32.600] result() for MulticoreFuture ... done
[13:35:32.600] - relayed: [n=2] TRUE, TRUE
[13:35:32.601] - queued futures: [n=2] TRUE, TRUE
[13:35:32.601] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[13:35:32.601] resolve() on list ... DONE
[13:35:32.601] result() for MulticoreFuture ...
[13:35:32.601] result() for MulticoreFuture ... done
[13:35:32.601] result() for MulticoreFuture ...
[13:35:32.601] result() for MulticoreFuture ... done
[13:35:32.602] result() for MulticoreFuture ...
[13:35:32.602] result() for MulticoreFuture ... done
[13:35:32.602] result() for MulticoreFuture ...
[13:35:32.602] result() for MulticoreFuture ... done
[13:35:32.602]  - Number of value chunks collected: 2
[13:35:32.602] Resolving 2 futures (chunks) ... DONE
[13:35:32.603] Reducing values from 2 chunks ...
[13:35:32.603]  - Number of values collected after concatenation: 2
[13:35:32.603]  - Number of values expected: 2
[13:35:32.603] Reducing values from 2 chunks ... DONE
[13:35:32.603] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[13:35:32.603] future_mapply() ...
[13:35:32.608] Number of chunks: 2
[13:35:32.608] getGlobalsAndPackagesXApply() ...
[13:35:32.608]  - future.globals: TRUE
[13:35:32.608] getGlobalsAndPackages() ...
[13:35:32.608] Searching for globals...
[13:35:32.610] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:35:32.611] Searching for globals ... DONE
[13:35:32.611] Resolving globals: FALSE
[13:35:32.611] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:35:32.612] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:35:32.612] - globals: [1] ‘FUN’
[13:35:32.612] 
[13:35:32.612] getGlobalsAndPackages() ... DONE
[13:35:32.612]  - globals found/used: [n=1] ‘FUN’
[13:35:32.612]  - needed namespaces: [n=0] 
[13:35:32.612] Finding globals ... DONE
[13:35:32.612] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:35:32.613] List of 2
[13:35:32.613]  $ ...future.FUN:function (x, y)  
[13:35:32.613]  $ MoreArgs     : NULL
[13:35:32.613]  - attr(*, "where")=List of 2
[13:35:32.613]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:32.613]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:35:32.613]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:32.613]  - attr(*, "resolved")= logi FALSE
[13:35:32.613]  - attr(*, "total_size")= num NA
[13:35:32.616] Packages to be attached in all futures: [n=0] 
[13:35:32.616] getGlobalsAndPackagesXApply() ... DONE
[13:35:32.616] Number of futures (= number of chunks): 2
[13:35:32.616] Launching 2 futures (chunks) ...
[13:35:32.616] Chunk #1 of 2 ...
[13:35:32.616]  - Finding globals in '...' for chunk #1 ...
[13:35:32.616] getGlobalsAndPackages() ...
[13:35:32.616] Searching for globals...
[13:35:32.617] 
[13:35:32.617] Searching for globals ... DONE
[13:35:32.617] - globals: [0] <none>
[13:35:32.617] getGlobalsAndPackages() ... DONE
[13:35:32.617]    + additional globals found: [n=0] 
[13:35:32.617]    + additional namespaces needed: [n=0] 
[13:35:32.617]  - Finding globals in '...' for chunk #1 ... DONE
[13:35:32.617]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:32.618]  - seeds: <none>
[13:35:32.618]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:32.618] getGlobalsAndPackages() ...
[13:35:32.618] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:32.618] Resolving globals: FALSE
[13:35:32.618] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:35:32.619] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:35:32.619] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:32.619] 
[13:35:32.619] getGlobalsAndPackages() ... DONE
[13:35:32.620] run() for ‘Future’ ...
[13:35:32.620] - state: ‘created’
[13:35:32.620] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:32.623] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:32.623] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:32.624]   - Field: ‘label’
[13:35:32.624]   - Field: ‘local’
[13:35:32.624]   - Field: ‘owner’
[13:35:32.624]   - Field: ‘envir’
[13:35:32.624]   - Field: ‘workers’
[13:35:32.624]   - Field: ‘packages’
[13:35:32.624]   - Field: ‘gc’
[13:35:32.624]   - Field: ‘job’
[13:35:32.624]   - Field: ‘conditions’
[13:35:32.624]   - Field: ‘expr’
[13:35:32.625]   - Field: ‘uuid’
[13:35:32.625]   - Field: ‘seed’
[13:35:32.625]   - Field: ‘version’
[13:35:32.625]   - Field: ‘result’
[13:35:32.625]   - Field: ‘asynchronous’
[13:35:32.625]   - Field: ‘calls’
[13:35:32.625]   - Field: ‘globals’
[13:35:32.625]   - Field: ‘stdout’
[13:35:32.625]   - Field: ‘earlySignal’
[13:35:32.625]   - Field: ‘lazy’
[13:35:32.625]   - Field: ‘state’
[13:35:32.626] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:32.626] - Launch lazy future ...
[13:35:32.626] Packages needed by the future expression (n = 0): <none>
[13:35:32.626] Packages needed by future strategies (n = 0): <none>
[13:35:32.627] {
[13:35:32.627]     {
[13:35:32.627]         {
[13:35:32.627]             ...future.startTime <- base::Sys.time()
[13:35:32.627]             {
[13:35:32.627]                 {
[13:35:32.627]                   {
[13:35:32.627]                     {
[13:35:32.627]                       base::local({
[13:35:32.627]                         has_future <- base::requireNamespace("future", 
[13:35:32.627]                           quietly = TRUE)
[13:35:32.627]                         if (has_future) {
[13:35:32.627]                           ns <- base::getNamespace("future")
[13:35:32.627]                           version <- ns[[".package"]][["version"]]
[13:35:32.627]                           if (is.null(version)) 
[13:35:32.627]                             version <- utils::packageVersion("future")
[13:35:32.627]                         }
[13:35:32.627]                         else {
[13:35:32.627]                           version <- NULL
[13:35:32.627]                         }
[13:35:32.627]                         if (!has_future || version < "1.8.0") {
[13:35:32.627]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:32.627]                             "", base::R.version$version.string), 
[13:35:32.627]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:32.627]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:32.627]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:32.627]                               "release", "version")], collapse = " "), 
[13:35:32.627]                             hostname = base::Sys.info()[["nodename"]])
[13:35:32.627]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:32.627]                             info)
[13:35:32.627]                           info <- base::paste(info, collapse = "; ")
[13:35:32.627]                           if (!has_future) {
[13:35:32.627]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:32.627]                               info)
[13:35:32.627]                           }
[13:35:32.627]                           else {
[13:35:32.627]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:32.627]                               info, version)
[13:35:32.627]                           }
[13:35:32.627]                           base::stop(msg)
[13:35:32.627]                         }
[13:35:32.627]                       })
[13:35:32.627]                     }
[13:35:32.627]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:32.627]                     base::options(mc.cores = 1L)
[13:35:32.627]                   }
[13:35:32.627]                   ...future.strategy.old <- future::plan("list")
[13:35:32.627]                   options(future.plan = NULL)
[13:35:32.627]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:32.627]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:32.627]                 }
[13:35:32.627]                 ...future.workdir <- getwd()
[13:35:32.627]             }
[13:35:32.627]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:32.627]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:32.627]         }
[13:35:32.627]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:32.627]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:32.627]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:32.627]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:32.627]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:32.627]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:32.627]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:32.627]             base::names(...future.oldOptions))
[13:35:32.627]     }
[13:35:32.627]     if (TRUE) {
[13:35:32.627]     }
[13:35:32.627]     else {
[13:35:32.627]         if (NA) {
[13:35:32.627]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:32.627]                 open = "w")
[13:35:32.627]         }
[13:35:32.627]         else {
[13:35:32.627]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:32.627]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:32.627]         }
[13:35:32.627]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:32.627]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:32.627]             base::sink(type = "output", split = FALSE)
[13:35:32.627]             base::close(...future.stdout)
[13:35:32.627]         }, add = TRUE)
[13:35:32.627]     }
[13:35:32.627]     ...future.frame <- base::sys.nframe()
[13:35:32.627]     ...future.conditions <- base::list()
[13:35:32.627]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:32.627]     if (FALSE) {
[13:35:32.627]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:32.627]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:32.627]     }
[13:35:32.627]     ...future.result <- base::tryCatch({
[13:35:32.627]         base::withCallingHandlers({
[13:35:32.627]             ...future.value <- base::withVisible(base::local({
[13:35:32.627]                 withCallingHandlers({
[13:35:32.627]                   {
[13:35:32.627]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:32.627]                     if (!identical(...future.globals.maxSize.org, 
[13:35:32.627]                       ...future.globals.maxSize)) {
[13:35:32.627]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:32.627]                       on.exit(options(oopts), add = TRUE)
[13:35:32.627]                     }
[13:35:32.627]                     {
[13:35:32.627]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:32.627]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:35:32.627]                         USE.NAMES = FALSE)
[13:35:32.627]                       do.call(mapply, args = args)
[13:35:32.627]                     }
[13:35:32.627]                   }
[13:35:32.627]                 }, immediateCondition = function(cond) {
[13:35:32.627]                   save_rds <- function (object, pathname, ...) 
[13:35:32.627]                   {
[13:35:32.627]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:32.627]                     if (file_test("-f", pathname_tmp)) {
[13:35:32.627]                       fi_tmp <- file.info(pathname_tmp)
[13:35:32.627]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:32.627]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:32.627]                         fi_tmp[["mtime"]])
[13:35:32.627]                     }
[13:35:32.627]                     tryCatch({
[13:35:32.627]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:32.627]                     }, error = function(ex) {
[13:35:32.627]                       msg <- conditionMessage(ex)
[13:35:32.627]                       fi_tmp <- file.info(pathname_tmp)
[13:35:32.627]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:32.627]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:32.627]                         fi_tmp[["mtime"]], msg)
[13:35:32.627]                       ex$message <- msg
[13:35:32.627]                       stop(ex)
[13:35:32.627]                     })
[13:35:32.627]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:32.627]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:32.627]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:32.627]                       fi_tmp <- file.info(pathname_tmp)
[13:35:32.627]                       fi <- file.info(pathname)
[13:35:32.627]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:32.627]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:32.627]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:32.627]                         fi[["size"]], fi[["mtime"]])
[13:35:32.627]                       stop(msg)
[13:35:32.627]                     }
[13:35:32.627]                     invisible(pathname)
[13:35:32.627]                   }
[13:35:32.627]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:32.627]                     rootPath = tempdir()) 
[13:35:32.627]                   {
[13:35:32.627]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:32.627]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:32.627]                       tmpdir = path, fileext = ".rds")
[13:35:32.627]                     save_rds(obj, file)
[13:35:32.627]                   }
[13:35:32.627]                   saveImmediateCondition(cond, path = "/tmp/RtmpghgvGN/.future/immediateConditions")
[13:35:32.627]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:32.627]                   {
[13:35:32.627]                     inherits <- base::inherits
[13:35:32.627]                     invokeRestart <- base::invokeRestart
[13:35:32.627]                     is.null <- base::is.null
[13:35:32.627]                     muffled <- FALSE
[13:35:32.627]                     if (inherits(cond, "message")) {
[13:35:32.627]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:32.627]                       if (muffled) 
[13:35:32.627]                         invokeRestart("muffleMessage")
[13:35:32.627]                     }
[13:35:32.627]                     else if (inherits(cond, "warning")) {
[13:35:32.627]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:32.627]                       if (muffled) 
[13:35:32.627]                         invokeRestart("muffleWarning")
[13:35:32.627]                     }
[13:35:32.627]                     else if (inherits(cond, "condition")) {
[13:35:32.627]                       if (!is.null(pattern)) {
[13:35:32.627]                         computeRestarts <- base::computeRestarts
[13:35:32.627]                         grepl <- base::grepl
[13:35:32.627]                         restarts <- computeRestarts(cond)
[13:35:32.627]                         for (restart in restarts) {
[13:35:32.627]                           name <- restart$name
[13:35:32.627]                           if (is.null(name)) 
[13:35:32.627]                             next
[13:35:32.627]                           if (!grepl(pattern, name)) 
[13:35:32.627]                             next
[13:35:32.627]                           invokeRestart(restart)
[13:35:32.627]                           muffled <- TRUE
[13:35:32.627]                           break
[13:35:32.627]                         }
[13:35:32.627]                       }
[13:35:32.627]                     }
[13:35:32.627]                     invisible(muffled)
[13:35:32.627]                   }
[13:35:32.627]                   muffleCondition(cond)
[13:35:32.627]                 })
[13:35:32.627]             }))
[13:35:32.627]             future::FutureResult(value = ...future.value$value, 
[13:35:32.627]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:32.627]                   ...future.rng), globalenv = if (FALSE) 
[13:35:32.627]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:32.627]                     ...future.globalenv.names))
[13:35:32.627]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:32.627]         }, condition = base::local({
[13:35:32.627]             c <- base::c
[13:35:32.627]             inherits <- base::inherits
[13:35:32.627]             invokeRestart <- base::invokeRestart
[13:35:32.627]             length <- base::length
[13:35:32.627]             list <- base::list
[13:35:32.627]             seq.int <- base::seq.int
[13:35:32.627]             signalCondition <- base::signalCondition
[13:35:32.627]             sys.calls <- base::sys.calls
[13:35:32.627]             `[[` <- base::`[[`
[13:35:32.627]             `+` <- base::`+`
[13:35:32.627]             `<<-` <- base::`<<-`
[13:35:32.627]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:32.627]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:32.627]                   3L)]
[13:35:32.627]             }
[13:35:32.627]             function(cond) {
[13:35:32.627]                 is_error <- inherits(cond, "error")
[13:35:32.627]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:32.627]                   NULL)
[13:35:32.627]                 if (is_error) {
[13:35:32.627]                   sessionInformation <- function() {
[13:35:32.627]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:32.627]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:32.627]                       search = base::search(), system = base::Sys.info())
[13:35:32.627]                   }
[13:35:32.627]                   ...future.conditions[[length(...future.conditions) + 
[13:35:32.627]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:32.627]                     cond$call), session = sessionInformation(), 
[13:35:32.627]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:32.627]                   signalCondition(cond)
[13:35:32.627]                 }
[13:35:32.627]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:32.627]                 "immediateCondition"))) {
[13:35:32.627]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:32.627]                   ...future.conditions[[length(...future.conditions) + 
[13:35:32.627]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:32.627]                   if (TRUE && !signal) {
[13:35:32.627]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:32.627]                     {
[13:35:32.627]                       inherits <- base::inherits
[13:35:32.627]                       invokeRestart <- base::invokeRestart
[13:35:32.627]                       is.null <- base::is.null
[13:35:32.627]                       muffled <- FALSE
[13:35:32.627]                       if (inherits(cond, "message")) {
[13:35:32.627]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:32.627]                         if (muffled) 
[13:35:32.627]                           invokeRestart("muffleMessage")
[13:35:32.627]                       }
[13:35:32.627]                       else if (inherits(cond, "warning")) {
[13:35:32.627]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:32.627]                         if (muffled) 
[13:35:32.627]                           invokeRestart("muffleWarning")
[13:35:32.627]                       }
[13:35:32.627]                       else if (inherits(cond, "condition")) {
[13:35:32.627]                         if (!is.null(pattern)) {
[13:35:32.627]                           computeRestarts <- base::computeRestarts
[13:35:32.627]                           grepl <- base::grepl
[13:35:32.627]                           restarts <- computeRestarts(cond)
[13:35:32.627]                           for (restart in restarts) {
[13:35:32.627]                             name <- restart$name
[13:35:32.627]                             if (is.null(name)) 
[13:35:32.627]                               next
[13:35:32.627]                             if (!grepl(pattern, name)) 
[13:35:32.627]                               next
[13:35:32.627]                             invokeRestart(restart)
[13:35:32.627]                             muffled <- TRUE
[13:35:32.627]                             break
[13:35:32.627]                           }
[13:35:32.627]                         }
[13:35:32.627]                       }
[13:35:32.627]                       invisible(muffled)
[13:35:32.627]                     }
[13:35:32.627]                     muffleCondition(cond, pattern = "^muffle")
[13:35:32.627]                   }
[13:35:32.627]                 }
[13:35:32.627]                 else {
[13:35:32.627]                   if (TRUE) {
[13:35:32.627]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:32.627]                     {
[13:35:32.627]                       inherits <- base::inherits
[13:35:32.627]                       invokeRestart <- base::invokeRestart
[13:35:32.627]                       is.null <- base::is.null
[13:35:32.627]                       muffled <- FALSE
[13:35:32.627]                       if (inherits(cond, "message")) {
[13:35:32.627]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:32.627]                         if (muffled) 
[13:35:32.627]                           invokeRestart("muffleMessage")
[13:35:32.627]                       }
[13:35:32.627]                       else if (inherits(cond, "warning")) {
[13:35:32.627]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:32.627]                         if (muffled) 
[13:35:32.627]                           invokeRestart("muffleWarning")
[13:35:32.627]                       }
[13:35:32.627]                       else if (inherits(cond, "condition")) {
[13:35:32.627]                         if (!is.null(pattern)) {
[13:35:32.627]                           computeRestarts <- base::computeRestarts
[13:35:32.627]                           grepl <- base::grepl
[13:35:32.627]                           restarts <- computeRestarts(cond)
[13:35:32.627]                           for (restart in restarts) {
[13:35:32.627]                             name <- restart$name
[13:35:32.627]                             if (is.null(name)) 
[13:35:32.627]                               next
[13:35:32.627]                             if (!grepl(pattern, name)) 
[13:35:32.627]                               next
[13:35:32.627]                             invokeRestart(restart)
[13:35:32.627]                             muffled <- TRUE
[13:35:32.627]                             break
[13:35:32.627]                           }
[13:35:32.627]                         }
[13:35:32.627]                       }
[13:35:32.627]                       invisible(muffled)
[13:35:32.627]                     }
[13:35:32.627]                     muffleCondition(cond, pattern = "^muffle")
[13:35:32.627]                   }
[13:35:32.627]                 }
[13:35:32.627]             }
[13:35:32.627]         }))
[13:35:32.627]     }, error = function(ex) {
[13:35:32.627]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:32.627]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:32.627]                 ...future.rng), started = ...future.startTime, 
[13:35:32.627]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:32.627]             version = "1.8"), class = "FutureResult")
[13:35:32.627]     }, finally = {
[13:35:32.627]         if (!identical(...future.workdir, getwd())) 
[13:35:32.627]             setwd(...future.workdir)
[13:35:32.627]         {
[13:35:32.627]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:32.627]                 ...future.oldOptions$nwarnings <- NULL
[13:35:32.627]             }
[13:35:32.627]             base::options(...future.oldOptions)
[13:35:32.627]             if (.Platform$OS.type == "windows") {
[13:35:32.627]                 old_names <- names(...future.oldEnvVars)
[13:35:32.627]                 envs <- base::Sys.getenv()
[13:35:32.627]                 names <- names(envs)
[13:35:32.627]                 common <- intersect(names, old_names)
[13:35:32.627]                 added <- setdiff(names, old_names)
[13:35:32.627]                 removed <- setdiff(old_names, names)
[13:35:32.627]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:32.627]                   envs[common]]
[13:35:32.627]                 NAMES <- toupper(changed)
[13:35:32.627]                 args <- list()
[13:35:32.627]                 for (kk in seq_along(NAMES)) {
[13:35:32.627]                   name <- changed[[kk]]
[13:35:32.627]                   NAME <- NAMES[[kk]]
[13:35:32.627]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:32.627]                     next
[13:35:32.627]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:32.627]                 }
[13:35:32.627]                 NAMES <- toupper(added)
[13:35:32.627]                 for (kk in seq_along(NAMES)) {
[13:35:32.627]                   name <- added[[kk]]
[13:35:32.627]                   NAME <- NAMES[[kk]]
[13:35:32.627]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:32.627]                     next
[13:35:32.627]                   args[[name]] <- ""
[13:35:32.627]                 }
[13:35:32.627]                 NAMES <- toupper(removed)
[13:35:32.627]                 for (kk in seq_along(NAMES)) {
[13:35:32.627]                   name <- removed[[kk]]
[13:35:32.627]                   NAME <- NAMES[[kk]]
[13:35:32.627]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:32.627]                     next
[13:35:32.627]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:32.627]                 }
[13:35:32.627]                 if (length(args) > 0) 
[13:35:32.627]                   base::do.call(base::Sys.setenv, args = args)
[13:35:32.627]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:32.627]             }
[13:35:32.627]             else {
[13:35:32.627]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:32.627]             }
[13:35:32.627]             {
[13:35:32.627]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:32.627]                   0L) {
[13:35:32.627]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:32.627]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:32.627]                   base::options(opts)
[13:35:32.627]                 }
[13:35:32.627]                 {
[13:35:32.627]                   {
[13:35:32.627]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:32.627]                     NULL
[13:35:32.627]                   }
[13:35:32.627]                   options(future.plan = NULL)
[13:35:32.627]                   if (is.na(NA_character_)) 
[13:35:32.627]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:32.627]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:32.627]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:32.627]                     .init = FALSE)
[13:35:32.627]                 }
[13:35:32.627]             }
[13:35:32.627]         }
[13:35:32.627]     })
[13:35:32.627]     if (FALSE) {
[13:35:32.627]         base::sink(type = "output", split = FALSE)
[13:35:32.627]         if (NA) {
[13:35:32.627]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:32.627]         }
[13:35:32.627]         else {
[13:35:32.627]             ...future.result["stdout"] <- base::list(NULL)
[13:35:32.627]         }
[13:35:32.627]         base::close(...future.stdout)
[13:35:32.627]         ...future.stdout <- NULL
[13:35:32.627]     }
[13:35:32.627]     ...future.result$conditions <- ...future.conditions
[13:35:32.627]     ...future.result$finished <- base::Sys.time()
[13:35:32.627]     ...future.result
[13:35:32.627] }
[13:35:32.629] assign_globals() ...
[13:35:32.629] List of 5
[13:35:32.629]  $ ...future.FUN            :function (x, y)  
[13:35:32.629]  $ MoreArgs                 : NULL
[13:35:32.629]  $ ...future.elements_ii    :List of 2
[13:35:32.629]   ..$ :List of 1
[13:35:32.629]   .. ..$ : int 1
[13:35:32.629]   ..$ :List of 1
[13:35:32.629]   .. ..$ : int 0
[13:35:32.629]  $ ...future.seeds_ii       : NULL
[13:35:32.629]  $ ...future.globals.maxSize: NULL
[13:35:32.629]  - attr(*, "where")=List of 5
[13:35:32.629]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:32.629]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:35:32.629]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:32.629]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:32.629]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:32.629]  - attr(*, "resolved")= logi FALSE
[13:35:32.629]  - attr(*, "total_size")= num 6368
[13:35:32.629]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:32.629]  - attr(*, "already-done")= logi TRUE
[13:35:32.636] - reassign environment for ‘...future.FUN’
[13:35:32.636] - copied ‘...future.FUN’ to environment
[13:35:32.636] - copied ‘MoreArgs’ to environment
[13:35:32.636] - copied ‘...future.elements_ii’ to environment
[13:35:32.636] - copied ‘...future.seeds_ii’ to environment
[13:35:32.637] - copied ‘...future.globals.maxSize’ to environment
[13:35:32.637] assign_globals() ... done
[13:35:32.637] requestCore(): workers = 2
[13:35:32.639] MulticoreFuture started
[13:35:32.639] - Launch lazy future ... done
[13:35:32.640] run() for ‘MulticoreFuture’ ... done
[13:35:32.640] Created future:
[13:35:32.640] plan(): Setting new future strategy stack:
[13:35:32.641] List of future strategies:
[13:35:32.641] 1. sequential:
[13:35:32.641]    - args: function (..., envir = parent.frame())
[13:35:32.641]    - tweaked: FALSE
[13:35:32.641]    - call: NULL
[13:35:32.641] plan(): nbrOfWorkers() = 1
[13:35:32.640] MulticoreFuture:
[13:35:32.640] Label: ‘future_mapply-1’
[13:35:32.640] Expression:
[13:35:32.640] {
[13:35:32.640]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:32.640]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:32.640]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:32.640]         on.exit(options(oopts), add = TRUE)
[13:35:32.640]     }
[13:35:32.640]     {
[13:35:32.640]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:32.640]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:35:32.640]         do.call(mapply, args = args)
[13:35:32.640]     }
[13:35:32.640] }
[13:35:32.640] Lazy evaluation: FALSE
[13:35:32.640] Asynchronous evaluation: TRUE
[13:35:32.640] Local evaluation: TRUE
[13:35:32.640] Environment: R_GlobalEnv
[13:35:32.640] Capture standard output: NA
[13:35:32.640] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:32.640] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:32.640] Packages: <none>
[13:35:32.640] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:32.640] Resolved: FALSE
[13:35:32.640] Value: <not collected>
[13:35:32.640] Conditions captured: <none>
[13:35:32.640] Early signaling: FALSE
[13:35:32.640] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:32.640] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:32.654] Chunk #1 of 2 ... DONE
[13:35:32.654] Chunk #2 of 2 ...
[13:35:32.654]  - Finding globals in '...' for chunk #2 ...
[13:35:32.654] getGlobalsAndPackages() ...
[13:35:32.655] Searching for globals...
[13:35:32.655] 
[13:35:32.656] Searching for globals ... DONE
[13:35:32.656] - globals: [0] <none>
[13:35:32.656] getGlobalsAndPackages() ... DONE
[13:35:32.656]    + additional globals found: [n=0] 
[13:35:32.656]    + additional namespaces needed: [n=0] 
[13:35:32.656]  - Finding globals in '...' for chunk #2 ... DONE
[13:35:32.657]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:32.657]  - seeds: <none>
[13:35:32.657]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:32.657] getGlobalsAndPackages() ...
[13:35:32.657] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:32.657] Resolving globals: FALSE
[13:35:32.658] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:35:32.659] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:35:32.659] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:32.660] 
[13:35:32.660] getGlobalsAndPackages() ... DONE
[13:35:32.660] run() for ‘Future’ ...
[13:35:32.660] - state: ‘created’
[13:35:32.661] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:32.666] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:32.666] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:32.666]   - Field: ‘label’
[13:35:32.666]   - Field: ‘local’
[13:35:32.666]   - Field: ‘owner’
[13:35:32.666]   - Field: ‘envir’
[13:35:32.667]   - Field: ‘workers’
[13:35:32.667]   - Field: ‘packages’
[13:35:32.667]   - Field: ‘gc’
[13:35:32.667]   - Field: ‘job’
[13:35:32.667]   - Field: ‘conditions’
[13:35:32.667]   - Field: ‘expr’
[13:35:32.667]   - Field: ‘uuid’
[13:35:32.668]   - Field: ‘seed’
[13:35:32.668]   - Field: ‘version’
[13:35:32.668]   - Field: ‘result’
[13:35:32.668]   - Field: ‘asynchronous’
[13:35:32.668]   - Field: ‘calls’
[13:35:32.668]   - Field: ‘globals’
[13:35:32.668]   - Field: ‘stdout’
[13:35:32.669]   - Field: ‘earlySignal’
[13:35:32.669]   - Field: ‘lazy’
[13:35:32.669]   - Field: ‘state’
[13:35:32.669] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:32.669] - Launch lazy future ...
[13:35:32.670] Packages needed by the future expression (n = 0): <none>
[13:35:32.670] Packages needed by future strategies (n = 0): <none>
[13:35:32.671] {
[13:35:32.671]     {
[13:35:32.671]         {
[13:35:32.671]             ...future.startTime <- base::Sys.time()
[13:35:32.671]             {
[13:35:32.671]                 {
[13:35:32.671]                   {
[13:35:32.671]                     {
[13:35:32.671]                       base::local({
[13:35:32.671]                         has_future <- base::requireNamespace("future", 
[13:35:32.671]                           quietly = TRUE)
[13:35:32.671]                         if (has_future) {
[13:35:32.671]                           ns <- base::getNamespace("future")
[13:35:32.671]                           version <- ns[[".package"]][["version"]]
[13:35:32.671]                           if (is.null(version)) 
[13:35:32.671]                             version <- utils::packageVersion("future")
[13:35:32.671]                         }
[13:35:32.671]                         else {
[13:35:32.671]                           version <- NULL
[13:35:32.671]                         }
[13:35:32.671]                         if (!has_future || version < "1.8.0") {
[13:35:32.671]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:32.671]                             "", base::R.version$version.string), 
[13:35:32.671]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:32.671]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:32.671]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:32.671]                               "release", "version")], collapse = " "), 
[13:35:32.671]                             hostname = base::Sys.info()[["nodename"]])
[13:35:32.671]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:32.671]                             info)
[13:35:32.671]                           info <- base::paste(info, collapse = "; ")
[13:35:32.671]                           if (!has_future) {
[13:35:32.671]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:32.671]                               info)
[13:35:32.671]                           }
[13:35:32.671]                           else {
[13:35:32.671]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:32.671]                               info, version)
[13:35:32.671]                           }
[13:35:32.671]                           base::stop(msg)
[13:35:32.671]                         }
[13:35:32.671]                       })
[13:35:32.671]                     }
[13:35:32.671]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:32.671]                     base::options(mc.cores = 1L)
[13:35:32.671]                   }
[13:35:32.671]                   ...future.strategy.old <- future::plan("list")
[13:35:32.671]                   options(future.plan = NULL)
[13:35:32.671]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:32.671]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:32.671]                 }
[13:35:32.671]                 ...future.workdir <- getwd()
[13:35:32.671]             }
[13:35:32.671]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:32.671]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:32.671]         }
[13:35:32.671]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:32.671]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:32.671]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:32.671]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:32.671]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:32.671]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:32.671]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:32.671]             base::names(...future.oldOptions))
[13:35:32.671]     }
[13:35:32.671]     if (TRUE) {
[13:35:32.671]     }
[13:35:32.671]     else {
[13:35:32.671]         if (NA) {
[13:35:32.671]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:32.671]                 open = "w")
[13:35:32.671]         }
[13:35:32.671]         else {
[13:35:32.671]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:32.671]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:32.671]         }
[13:35:32.671]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:32.671]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:32.671]             base::sink(type = "output", split = FALSE)
[13:35:32.671]             base::close(...future.stdout)
[13:35:32.671]         }, add = TRUE)
[13:35:32.671]     }
[13:35:32.671]     ...future.frame <- base::sys.nframe()
[13:35:32.671]     ...future.conditions <- base::list()
[13:35:32.671]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:32.671]     if (FALSE) {
[13:35:32.671]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:32.671]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:32.671]     }
[13:35:32.671]     ...future.result <- base::tryCatch({
[13:35:32.671]         base::withCallingHandlers({
[13:35:32.671]             ...future.value <- base::withVisible(base::local({
[13:35:32.671]                 withCallingHandlers({
[13:35:32.671]                   {
[13:35:32.671]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:32.671]                     if (!identical(...future.globals.maxSize.org, 
[13:35:32.671]                       ...future.globals.maxSize)) {
[13:35:32.671]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:32.671]                       on.exit(options(oopts), add = TRUE)
[13:35:32.671]                     }
[13:35:32.671]                     {
[13:35:32.671]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:32.671]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:35:32.671]                         USE.NAMES = FALSE)
[13:35:32.671]                       do.call(mapply, args = args)
[13:35:32.671]                     }
[13:35:32.671]                   }
[13:35:32.671]                 }, immediateCondition = function(cond) {
[13:35:32.671]                   save_rds <- function (object, pathname, ...) 
[13:35:32.671]                   {
[13:35:32.671]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:32.671]                     if (file_test("-f", pathname_tmp)) {
[13:35:32.671]                       fi_tmp <- file.info(pathname_tmp)
[13:35:32.671]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:32.671]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:32.671]                         fi_tmp[["mtime"]])
[13:35:32.671]                     }
[13:35:32.671]                     tryCatch({
[13:35:32.671]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:32.671]                     }, error = function(ex) {
[13:35:32.671]                       msg <- conditionMessage(ex)
[13:35:32.671]                       fi_tmp <- file.info(pathname_tmp)
[13:35:32.671]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:32.671]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:32.671]                         fi_tmp[["mtime"]], msg)
[13:35:32.671]                       ex$message <- msg
[13:35:32.671]                       stop(ex)
[13:35:32.671]                     })
[13:35:32.671]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:32.671]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:32.671]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:32.671]                       fi_tmp <- file.info(pathname_tmp)
[13:35:32.671]                       fi <- file.info(pathname)
[13:35:32.671]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:32.671]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:32.671]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:32.671]                         fi[["size"]], fi[["mtime"]])
[13:35:32.671]                       stop(msg)
[13:35:32.671]                     }
[13:35:32.671]                     invisible(pathname)
[13:35:32.671]                   }
[13:35:32.671]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:32.671]                     rootPath = tempdir()) 
[13:35:32.671]                   {
[13:35:32.671]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:32.671]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:32.671]                       tmpdir = path, fileext = ".rds")
[13:35:32.671]                     save_rds(obj, file)
[13:35:32.671]                   }
[13:35:32.671]                   saveImmediateCondition(cond, path = "/tmp/RtmpghgvGN/.future/immediateConditions")
[13:35:32.671]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:32.671]                   {
[13:35:32.671]                     inherits <- base::inherits
[13:35:32.671]                     invokeRestart <- base::invokeRestart
[13:35:32.671]                     is.null <- base::is.null
[13:35:32.671]                     muffled <- FALSE
[13:35:32.671]                     if (inherits(cond, "message")) {
[13:35:32.671]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:32.671]                       if (muffled) 
[13:35:32.671]                         invokeRestart("muffleMessage")
[13:35:32.671]                     }
[13:35:32.671]                     else if (inherits(cond, "warning")) {
[13:35:32.671]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:32.671]                       if (muffled) 
[13:35:32.671]                         invokeRestart("muffleWarning")
[13:35:32.671]                     }
[13:35:32.671]                     else if (inherits(cond, "condition")) {
[13:35:32.671]                       if (!is.null(pattern)) {
[13:35:32.671]                         computeRestarts <- base::computeRestarts
[13:35:32.671]                         grepl <- base::grepl
[13:35:32.671]                         restarts <- computeRestarts(cond)
[13:35:32.671]                         for (restart in restarts) {
[13:35:32.671]                           name <- restart$name
[13:35:32.671]                           if (is.null(name)) 
[13:35:32.671]                             next
[13:35:32.671]                           if (!grepl(pattern, name)) 
[13:35:32.671]                             next
[13:35:32.671]                           invokeRestart(restart)
[13:35:32.671]                           muffled <- TRUE
[13:35:32.671]                           break
[13:35:32.671]                         }
[13:35:32.671]                       }
[13:35:32.671]                     }
[13:35:32.671]                     invisible(muffled)
[13:35:32.671]                   }
[13:35:32.671]                   muffleCondition(cond)
[13:35:32.671]                 })
[13:35:32.671]             }))
[13:35:32.671]             future::FutureResult(value = ...future.value$value, 
[13:35:32.671]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:32.671]                   ...future.rng), globalenv = if (FALSE) 
[13:35:32.671]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:32.671]                     ...future.globalenv.names))
[13:35:32.671]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:32.671]         }, condition = base::local({
[13:35:32.671]             c <- base::c
[13:35:32.671]             inherits <- base::inherits
[13:35:32.671]             invokeRestart <- base::invokeRestart
[13:35:32.671]             length <- base::length
[13:35:32.671]             list <- base::list
[13:35:32.671]             seq.int <- base::seq.int
[13:35:32.671]             signalCondition <- base::signalCondition
[13:35:32.671]             sys.calls <- base::sys.calls
[13:35:32.671]             `[[` <- base::`[[`
[13:35:32.671]             `+` <- base::`+`
[13:35:32.671]             `<<-` <- base::`<<-`
[13:35:32.671]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:32.671]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:32.671]                   3L)]
[13:35:32.671]             }
[13:35:32.671]             function(cond) {
[13:35:32.671]                 is_error <- inherits(cond, "error")
[13:35:32.671]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:32.671]                   NULL)
[13:35:32.671]                 if (is_error) {
[13:35:32.671]                   sessionInformation <- function() {
[13:35:32.671]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:32.671]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:32.671]                       search = base::search(), system = base::Sys.info())
[13:35:32.671]                   }
[13:35:32.671]                   ...future.conditions[[length(...future.conditions) + 
[13:35:32.671]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:32.671]                     cond$call), session = sessionInformation(), 
[13:35:32.671]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:32.671]                   signalCondition(cond)
[13:35:32.671]                 }
[13:35:32.671]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:32.671]                 "immediateCondition"))) {
[13:35:32.671]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:32.671]                   ...future.conditions[[length(...future.conditions) + 
[13:35:32.671]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:32.671]                   if (TRUE && !signal) {
[13:35:32.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:32.671]                     {
[13:35:32.671]                       inherits <- base::inherits
[13:35:32.671]                       invokeRestart <- base::invokeRestart
[13:35:32.671]                       is.null <- base::is.null
[13:35:32.671]                       muffled <- FALSE
[13:35:32.671]                       if (inherits(cond, "message")) {
[13:35:32.671]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:32.671]                         if (muffled) 
[13:35:32.671]                           invokeRestart("muffleMessage")
[13:35:32.671]                       }
[13:35:32.671]                       else if (inherits(cond, "warning")) {
[13:35:32.671]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:32.671]                         if (muffled) 
[13:35:32.671]                           invokeRestart("muffleWarning")
[13:35:32.671]                       }
[13:35:32.671]                       else if (inherits(cond, "condition")) {
[13:35:32.671]                         if (!is.null(pattern)) {
[13:35:32.671]                           computeRestarts <- base::computeRestarts
[13:35:32.671]                           grepl <- base::grepl
[13:35:32.671]                           restarts <- computeRestarts(cond)
[13:35:32.671]                           for (restart in restarts) {
[13:35:32.671]                             name <- restart$name
[13:35:32.671]                             if (is.null(name)) 
[13:35:32.671]                               next
[13:35:32.671]                             if (!grepl(pattern, name)) 
[13:35:32.671]                               next
[13:35:32.671]                             invokeRestart(restart)
[13:35:32.671]                             muffled <- TRUE
[13:35:32.671]                             break
[13:35:32.671]                           }
[13:35:32.671]                         }
[13:35:32.671]                       }
[13:35:32.671]                       invisible(muffled)
[13:35:32.671]                     }
[13:35:32.671]                     muffleCondition(cond, pattern = "^muffle")
[13:35:32.671]                   }
[13:35:32.671]                 }
[13:35:32.671]                 else {
[13:35:32.671]                   if (TRUE) {
[13:35:32.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:32.671]                     {
[13:35:32.671]                       inherits <- base::inherits
[13:35:32.671]                       invokeRestart <- base::invokeRestart
[13:35:32.671]                       is.null <- base::is.null
[13:35:32.671]                       muffled <- FALSE
[13:35:32.671]                       if (inherits(cond, "message")) {
[13:35:32.671]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:32.671]                         if (muffled) 
[13:35:32.671]                           invokeRestart("muffleMessage")
[13:35:32.671]                       }
[13:35:32.671]                       else if (inherits(cond, "warning")) {
[13:35:32.671]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:32.671]                         if (muffled) 
[13:35:32.671]                           invokeRestart("muffleWarning")
[13:35:32.671]                       }
[13:35:32.671]                       else if (inherits(cond, "condition")) {
[13:35:32.671]                         if (!is.null(pattern)) {
[13:35:32.671]                           computeRestarts <- base::computeRestarts
[13:35:32.671]                           grepl <- base::grepl
[13:35:32.671]                           restarts <- computeRestarts(cond)
[13:35:32.671]                           for (restart in restarts) {
[13:35:32.671]                             name <- restart$name
[13:35:32.671]                             if (is.null(name)) 
[13:35:32.671]                               next
[13:35:32.671]                             if (!grepl(pattern, name)) 
[13:35:32.671]                               next
[13:35:32.671]                             invokeRestart(restart)
[13:35:32.671]                             muffled <- TRUE
[13:35:32.671]                             break
[13:35:32.671]                           }
[13:35:32.671]                         }
[13:35:32.671]                       }
[13:35:32.671]                       invisible(muffled)
[13:35:32.671]                     }
[13:35:32.671]                     muffleCondition(cond, pattern = "^muffle")
[13:35:32.671]                   }
[13:35:32.671]                 }
[13:35:32.671]             }
[13:35:32.671]         }))
[13:35:32.671]     }, error = function(ex) {
[13:35:32.671]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:32.671]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:32.671]                 ...future.rng), started = ...future.startTime, 
[13:35:32.671]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:32.671]             version = "1.8"), class = "FutureResult")
[13:35:32.671]     }, finally = {
[13:35:32.671]         if (!identical(...future.workdir, getwd())) 
[13:35:32.671]             setwd(...future.workdir)
[13:35:32.671]         {
[13:35:32.671]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:32.671]                 ...future.oldOptions$nwarnings <- NULL
[13:35:32.671]             }
[13:35:32.671]             base::options(...future.oldOptions)
[13:35:32.671]             if (.Platform$OS.type == "windows") {
[13:35:32.671]                 old_names <- names(...future.oldEnvVars)
[13:35:32.671]                 envs <- base::Sys.getenv()
[13:35:32.671]                 names <- names(envs)
[13:35:32.671]                 common <- intersect(names, old_names)
[13:35:32.671]                 added <- setdiff(names, old_names)
[13:35:32.671]                 removed <- setdiff(old_names, names)
[13:35:32.671]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:32.671]                   envs[common]]
[13:35:32.671]                 NAMES <- toupper(changed)
[13:35:32.671]                 args <- list()
[13:35:32.671]                 for (kk in seq_along(NAMES)) {
[13:35:32.671]                   name <- changed[[kk]]
[13:35:32.671]                   NAME <- NAMES[[kk]]
[13:35:32.671]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:32.671]                     next
[13:35:32.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:32.671]                 }
[13:35:32.671]                 NAMES <- toupper(added)
[13:35:32.671]                 for (kk in seq_along(NAMES)) {
[13:35:32.671]                   name <- added[[kk]]
[13:35:32.671]                   NAME <- NAMES[[kk]]
[13:35:32.671]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:32.671]                     next
[13:35:32.671]                   args[[name]] <- ""
[13:35:32.671]                 }
[13:35:32.671]                 NAMES <- toupper(removed)
[13:35:32.671]                 for (kk in seq_along(NAMES)) {
[13:35:32.671]                   name <- removed[[kk]]
[13:35:32.671]                   NAME <- NAMES[[kk]]
[13:35:32.671]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:32.671]                     next
[13:35:32.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:32.671]                 }
[13:35:32.671]                 if (length(args) > 0) 
[13:35:32.671]                   base::do.call(base::Sys.setenv, args = args)
[13:35:32.671]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:32.671]             }
[13:35:32.671]             else {
[13:35:32.671]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:32.671]             }
[13:35:32.671]             {
[13:35:32.671]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:32.671]                   0L) {
[13:35:32.671]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:32.671]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:32.671]                   base::options(opts)
[13:35:32.671]                 }
[13:35:32.671]                 {
[13:35:32.671]                   {
[13:35:32.671]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:32.671]                     NULL
[13:35:32.671]                   }
[13:35:32.671]                   options(future.plan = NULL)
[13:35:32.671]                   if (is.na(NA_character_)) 
[13:35:32.671]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:32.671]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:32.671]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:32.671]                     .init = FALSE)
[13:35:32.671]                 }
[13:35:32.671]             }
[13:35:32.671]         }
[13:35:32.671]     })
[13:35:32.671]     if (FALSE) {
[13:35:32.671]         base::sink(type = "output", split = FALSE)
[13:35:32.671]         if (NA) {
[13:35:32.671]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:32.671]         }
[13:35:32.671]         else {
[13:35:32.671]             ...future.result["stdout"] <- base::list(NULL)
[13:35:32.671]         }
[13:35:32.671]         base::close(...future.stdout)
[13:35:32.671]         ...future.stdout <- NULL
[13:35:32.671]     }
[13:35:32.671]     ...future.result$conditions <- ...future.conditions
[13:35:32.671]     ...future.result$finished <- base::Sys.time()
[13:35:32.671]     ...future.result
[13:35:32.671] }
[13:35:32.674] assign_globals() ...
[13:35:32.674] List of 5
[13:35:32.674]  $ ...future.FUN            :function (x, y)  
[13:35:32.674]  $ MoreArgs                 : NULL
[13:35:32.674]  $ ...future.elements_ii    :List of 2
[13:35:32.674]   ..$ :List of 1
[13:35:32.674]   .. ..$ : int 0
[13:35:32.674]   ..$ :List of 1
[13:35:32.674]   .. ..$ : int 1
[13:35:32.674]  $ ...future.seeds_ii       : NULL
[13:35:32.674]  $ ...future.globals.maxSize: NULL
[13:35:32.674]  - attr(*, "where")=List of 5
[13:35:32.674]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:32.674]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[13:35:32.674]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:32.674]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:32.674]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:32.674]  - attr(*, "resolved")= logi FALSE
[13:35:32.674]  - attr(*, "total_size")= num 6368
[13:35:32.674]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:32.674]  - attr(*, "already-done")= logi TRUE
[13:35:32.682] - reassign environment for ‘...future.FUN’
[13:35:32.682] - copied ‘...future.FUN’ to environment
[13:35:32.682] - copied ‘MoreArgs’ to environment
[13:35:32.683] - copied ‘...future.elements_ii’ to environment
[13:35:32.683] - copied ‘...future.seeds_ii’ to environment
[13:35:32.685] - copied ‘...future.globals.maxSize’ to environment
[13:35:32.685] assign_globals() ... done
[13:35:32.686] requestCore(): workers = 2
[13:35:32.688] MulticoreFuture started
[13:35:32.689] - Launch lazy future ... done
[13:35:32.690] plan(): Setting new future strategy stack:
[13:35:32.690] run() for ‘MulticoreFuture’ ... done
[13:35:32.690] Created future:
[13:35:32.690] List of future strategies:
[13:35:32.690] 1. sequential:
[13:35:32.690]    - args: function (..., envir = parent.frame())
[13:35:32.690]    - tweaked: FALSE
[13:35:32.690]    - call: NULL
[13:35:32.692] plan(): nbrOfWorkers() = 1
[13:35:32.694] plan(): Setting new future strategy stack:
[13:35:32.695] List of future strategies:
[13:35:32.695] 1. multicore:
[13:35:32.695]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:32.695]    - tweaked: FALSE
[13:35:32.695]    - call: plan(strategy)
[13:35:32.701] plan(): nbrOfWorkers() = 2
[13:35:32.691] MulticoreFuture:
[13:35:32.691] Label: ‘future_mapply-2’
[13:35:32.691] Expression:
[13:35:32.691] {
[13:35:32.691]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:32.691]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:32.691]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:32.691]         on.exit(options(oopts), add = TRUE)
[13:35:32.691]     }
[13:35:32.691]     {
[13:35:32.691]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:32.691]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:35:32.691]         do.call(mapply, args = args)
[13:35:32.691]     }
[13:35:32.691] }
[13:35:32.691] Lazy evaluation: FALSE
[13:35:32.691] Asynchronous evaluation: TRUE
[13:35:32.691] Local evaluation: TRUE
[13:35:32.691] Environment: R_GlobalEnv
[13:35:32.691] Capture standard output: NA
[13:35:32.691] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:32.691] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:32.691] Packages: <none>
[13:35:32.691] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:32.691] Resolved: TRUE
[13:35:32.691] Value: <not collected>
[13:35:32.691] Conditions captured: <none>
[13:35:32.691] Early signaling: FALSE
[13:35:32.691] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:32.691] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:32.703] Chunk #2 of 2 ... DONE
[13:35:32.703] Launching 2 futures (chunks) ... DONE
[13:35:32.703] Resolving 2 futures (chunks) ...
[13:35:32.703] resolve() on list ...
[13:35:32.704]  recursive: 0
[13:35:32.704]  length: 2
[13:35:32.704] 
[13:35:32.715] Future #2
[13:35:32.715] result() for MulticoreFuture ...
[13:35:32.716] result() for MulticoreFuture ...
[13:35:32.716] result() for MulticoreFuture ... done
[13:35:32.716] result() for MulticoreFuture ... done
[13:35:32.717] result() for MulticoreFuture ...
[13:35:32.717] result() for MulticoreFuture ... done
[13:35:32.717] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:35:32.717] - nx: 2
[13:35:32.717] - relay: TRUE
[13:35:32.717] - stdout: TRUE
[13:35:32.718] - signal: TRUE
[13:35:32.718] - resignal: FALSE
[13:35:32.718] - force: TRUE
[13:35:32.718] - relayed: [n=2] FALSE, FALSE
[13:35:32.718] - queued futures: [n=2] FALSE, FALSE
[13:35:32.718]  - until=1
[13:35:32.719]  - relaying element #1
[13:35:32.719] - relayed: [n=2] FALSE, FALSE
[13:35:32.719] - queued futures: [n=2] FALSE, TRUE
[13:35:32.719] signalConditionsASAP(NULL, pos=2) ... done
[13:35:32.719]  length: 1 (resolved future 2)
[13:35:33.144] plan(): Setting new future strategy stack:
[13:35:33.145] List of future strategies:
[13:35:33.145] 1. multicore:
[13:35:33.145]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:33.145]    - tweaked: FALSE
[13:35:33.145]    - call: plan(strategy)
[13:35:33.149] plan(): nbrOfWorkers() = 2
[13:35:33.157] Future #1
[13:35:33.158] result() for MulticoreFuture ...
[13:35:33.159] result() for MulticoreFuture ...
[13:35:33.159] result() for MulticoreFuture ... done
[13:35:33.159] result() for MulticoreFuture ... done
[13:35:33.159] result() for MulticoreFuture ...
[13:35:33.159] result() for MulticoreFuture ... done
[13:35:33.159] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:35:33.159] - nx: 2
[13:35:33.159] - relay: TRUE
[13:35:33.160] - stdout: TRUE
[13:35:33.160] - signal: TRUE
[13:35:33.160] - resignal: FALSE
[13:35:33.160] - force: TRUE
[13:35:33.160] - relayed: [n=2] FALSE, FALSE
[13:35:33.160] - queued futures: [n=2] FALSE, TRUE
[13:35:33.160]  - until=1
[13:35:33.160]  - relaying element #1
[13:35:33.160] result() for MulticoreFuture ...
[13:35:33.161] result() for MulticoreFuture ... done
[13:35:33.161] result() for MulticoreFuture ...
[13:35:33.161] result() for MulticoreFuture ... done
[13:35:33.161] result() for MulticoreFuture ...
[13:35:33.161] result() for MulticoreFuture ... done
[13:35:33.161] result() for MulticoreFuture ...
[13:35:33.161] result() for MulticoreFuture ... done
[13:35:33.161] - relayed: [n=2] TRUE, FALSE
[13:35:33.161] - queued futures: [n=2] TRUE, TRUE
[13:35:33.161] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:35:33.162]  length: 0 (resolved future 1)
[13:35:33.162] Relaying remaining futures
[13:35:33.162] signalConditionsASAP(NULL, pos=0) ...
[13:35:33.162] - nx: 2
[13:35:33.162] - relay: TRUE
[13:35:33.162] - stdout: TRUE
[13:35:33.162] - signal: TRUE
[13:35:33.162] - resignal: FALSE
[13:35:33.162] - force: TRUE
[13:35:33.163] - relayed: [n=2] TRUE, FALSE
[13:35:33.163] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:33.163]  - relaying element #2
[13:35:33.163] result() for MulticoreFuture ...
[13:35:33.163] result() for MulticoreFuture ... done
[13:35:33.163] result() for MulticoreFuture ...
[13:35:33.163] result() for MulticoreFuture ... done
[13:35:33.163] result() for MulticoreFuture ...
[13:35:33.163] result() for MulticoreFuture ... done
[13:35:33.164] result() for MulticoreFuture ...
[13:35:33.164] result() for MulticoreFuture ... done
[13:35:33.164] - relayed: [n=2] TRUE, TRUE
[13:35:33.164] - queued futures: [n=2] TRUE, TRUE
[13:35:33.164] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[13:35:33.164] resolve() on list ... DONE
[13:35:33.164] result() for MulticoreFuture ...
[13:35:33.164] result() for MulticoreFuture ... done
[13:35:33.164] result() for MulticoreFuture ...
[13:35:33.165] result() for MulticoreFuture ... done
[13:35:33.165] result() for MulticoreFuture ...
[13:35:33.165] result() for MulticoreFuture ... done
[13:35:33.165] result() for MulticoreFuture ...
[13:35:33.165] result() for MulticoreFuture ... done
[13:35:33.165]  - Number of value chunks collected: 2
[13:35:33.165] Resolving 2 futures (chunks) ... DONE
[13:35:33.165] Reducing values from 2 chunks ...
[13:35:33.165]  - Number of values collected after concatenation: 2
[13:35:33.166]  - Number of values expected: 2
[13:35:33.166] Reducing values from 2 chunks ... DONE
[13:35:33.166] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[13:35:33.166] plan(): Setting new future strategy stack:
[13:35:33.166] List of future strategies:
[13:35:33.166] 1. multisession:
[13:35:33.166]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:35:33.166]    - tweaked: FALSE
[13:35:33.166]    - call: plan(strategy)
[13:35:33.167] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:35:33.167] multisession:
[13:35:33.167] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:35:33.167] - tweaked: FALSE
[13:35:33.167] - call: plan(strategy)
[13:35:33.173] getGlobalsAndPackages() ...
[13:35:33.174] Not searching for globals
[13:35:33.174] - globals: [0] <none>
[13:35:33.174] getGlobalsAndPackages() ... DONE
[13:35:33.174] [local output] makeClusterPSOCK() ...
[13:35:33.218] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:35:33.220] [local output] Base port: 11267
[13:35:33.220] [local output] Getting setup options for 2 cluster nodes ...
[13:35:33.220] [local output]  - Node 1 of 2 ...
[13:35:33.220] [local output] localMachine=TRUE => revtunnel=FALSE

[13:35:33.221] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpghgvGN/worker.rank=1.parallelly.parent=78323.131f373ba5cdf.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpghgvGN/worker.rank=1.parallelly.parent=78323.131f373ba5cdf.pid")'’
[13:35:33.410] - Possible to infer worker's PID: TRUE
[13:35:33.411] [local output] Rscript port: 11267

[13:35:33.411] [local output]  - Node 2 of 2 ...
[13:35:33.412] [local output] localMachine=TRUE => revtunnel=FALSE

[13:35:33.412] [local output] Rscript port: 11267

[13:35:33.412] [local output] Getting setup options for 2 cluster nodes ... done
[13:35:33.413] [local output]  - Parallel setup requested for some PSOCK nodes
[13:35:33.413] [local output] Setting up PSOCK nodes in parallel
[13:35:33.413] List of 36
[13:35:33.413]  $ worker          : chr "localhost"
[13:35:33.413]   ..- attr(*, "localhost")= logi TRUE
[13:35:33.413]  $ master          : chr "localhost"
[13:35:33.413]  $ port            : int 11267
[13:35:33.413]  $ connectTimeout  : num 120
[13:35:33.413]  $ timeout         : num 2592000
[13:35:33.413]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:35:33.413]  $ homogeneous     : logi TRUE
[13:35:33.413]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:35:33.413]  $ rscript_envs    : NULL
[13:35:33.413]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:35:33.413]  $ rscript_startup : NULL
[13:35:33.413]  $ rscript_sh      : chr "sh"
[13:35:33.413]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:35:33.413]  $ methods         : logi TRUE
[13:35:33.413]  $ socketOptions   : chr "no-delay"
[13:35:33.413]  $ useXDR          : logi FALSE
[13:35:33.413]  $ outfile         : chr "/dev/null"
[13:35:33.413]  $ renice          : int NA
[13:35:33.413]  $ rshcmd          : NULL
[13:35:33.413]  $ user            : chr(0) 
[13:35:33.413]  $ revtunnel       : logi FALSE
[13:35:33.413]  $ rshlogfile      : NULL
[13:35:33.413]  $ rshopts         : chr(0) 
[13:35:33.413]  $ rank            : int 1
[13:35:33.413]  $ manual          : logi FALSE
[13:35:33.413]  $ dryrun          : logi FALSE
[13:35:33.413]  $ quiet           : logi FALSE
[13:35:33.413]  $ setup_strategy  : chr "parallel"
[13:35:33.413]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:35:33.413]  $ pidfile         : chr "/tmp/RtmpghgvGN/worker.rank=1.parallelly.parent=78323.131f373ba5cdf.pid"
[13:35:33.413]  $ rshcmd_label    : NULL
[13:35:33.413]  $ rsh_call        : NULL
[13:35:33.413]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:35:33.413]  $ localMachine    : logi TRUE
[13:35:33.413]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:35:33.413]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:35:33.413]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:35:33.413]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:35:33.413]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:35:33.413]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:35:33.413]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:35:33.413]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:35:33.413]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:35:33.413]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:35:33.413]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:35:33.413]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:35:33.413]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:35:33.413]  $ arguments       :List of 28
[13:35:33.413]   ..$ worker          : chr "localhost"
[13:35:33.413]   ..$ master          : NULL
[13:35:33.413]   ..$ port            : int 11267
[13:35:33.413]   ..$ connectTimeout  : num 120
[13:35:33.413]   ..$ timeout         : num 2592000
[13:35:33.413]   ..$ rscript         : NULL
[13:35:33.413]   ..$ homogeneous     : NULL
[13:35:33.413]   ..$ rscript_args    : NULL
[13:35:33.413]   ..$ rscript_envs    : NULL
[13:35:33.413]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:35:33.413]   ..$ rscript_startup : NULL
[13:35:33.413]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:35:33.413]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:35:33.413]   ..$ methods         : logi TRUE
[13:35:33.413]   ..$ socketOptions   : chr "no-delay"
[13:35:33.413]   ..$ useXDR          : logi FALSE
[13:35:33.413]   ..$ outfile         : chr "/dev/null"
[13:35:33.413]   ..$ renice          : int NA
[13:35:33.413]   ..$ rshcmd          : NULL
[13:35:33.413]   ..$ user            : NULL
[13:35:33.413]   ..$ revtunnel       : logi NA
[13:35:33.413]   ..$ rshlogfile      : NULL
[13:35:33.413]   ..$ rshopts         : NULL
[13:35:33.413]   ..$ rank            : int 1
[13:35:33.413]   ..$ manual          : logi FALSE
[13:35:33.413]   ..$ dryrun          : logi FALSE
[13:35:33.413]   ..$ quiet           : logi FALSE
[13:35:33.413]   ..$ setup_strategy  : chr "parallel"
[13:35:33.413]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:35:33.431] [local output] System call to launch all workers:
[13:35:33.431] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpghgvGN/worker.rank=1.parallelly.parent=78323.131f373ba5cdf.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11267 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:35:33.431] [local output] Starting PSOCK main server
[13:35:33.436] [local output] Workers launched
[13:35:33.437] [local output] Waiting for workers to connect back
[13:35:33.437]  - [local output] 0 workers out of 2 ready
[13:35:33.682]  - [local output] 0 workers out of 2 ready
[13:35:33.683]  - [local output] 1 workers out of 2 ready
[13:35:33.689]  - [local output] 1 workers out of 2 ready
[13:35:33.689]  - [local output] 2 workers out of 2 ready
[13:35:33.689] [local output] Launching of workers completed
[13:35:33.690] [local output] Collecting session information from workers
[13:35:33.690] [local output]  - Worker #1 of 2
[13:35:33.691] [local output]  - Worker #2 of 2
[13:35:33.691] [local output] makeClusterPSOCK() ... done
[13:35:33.703] Packages needed by the future expression (n = 0): <none>
[13:35:33.703] Packages needed by future strategies (n = 0): <none>
[13:35:33.703] {
[13:35:33.703]     {
[13:35:33.703]         {
[13:35:33.703]             ...future.startTime <- base::Sys.time()
[13:35:33.703]             {
[13:35:33.703]                 {
[13:35:33.703]                   {
[13:35:33.703]                     {
[13:35:33.703]                       base::local({
[13:35:33.703]                         has_future <- base::requireNamespace("future", 
[13:35:33.703]                           quietly = TRUE)
[13:35:33.703]                         if (has_future) {
[13:35:33.703]                           ns <- base::getNamespace("future")
[13:35:33.703]                           version <- ns[[".package"]][["version"]]
[13:35:33.703]                           if (is.null(version)) 
[13:35:33.703]                             version <- utils::packageVersion("future")
[13:35:33.703]                         }
[13:35:33.703]                         else {
[13:35:33.703]                           version <- NULL
[13:35:33.703]                         }
[13:35:33.703]                         if (!has_future || version < "1.8.0") {
[13:35:33.703]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:33.703]                             "", base::R.version$version.string), 
[13:35:33.703]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:33.703]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:33.703]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:33.703]                               "release", "version")], collapse = " "), 
[13:35:33.703]                             hostname = base::Sys.info()[["nodename"]])
[13:35:33.703]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:33.703]                             info)
[13:35:33.703]                           info <- base::paste(info, collapse = "; ")
[13:35:33.703]                           if (!has_future) {
[13:35:33.703]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:33.703]                               info)
[13:35:33.703]                           }
[13:35:33.703]                           else {
[13:35:33.703]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:33.703]                               info, version)
[13:35:33.703]                           }
[13:35:33.703]                           base::stop(msg)
[13:35:33.703]                         }
[13:35:33.703]                       })
[13:35:33.703]                     }
[13:35:33.703]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:33.703]                     base::options(mc.cores = 1L)
[13:35:33.703]                   }
[13:35:33.703]                   ...future.strategy.old <- future::plan("list")
[13:35:33.703]                   options(future.plan = NULL)
[13:35:33.703]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:33.703]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:33.703]                 }
[13:35:33.703]                 ...future.workdir <- getwd()
[13:35:33.703]             }
[13:35:33.703]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:33.703]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:33.703]         }
[13:35:33.703]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:33.703]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:33.703]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:33.703]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:33.703]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:33.703]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:33.703]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:33.703]             base::names(...future.oldOptions))
[13:35:33.703]     }
[13:35:33.703]     if (FALSE) {
[13:35:33.703]     }
[13:35:33.703]     else {
[13:35:33.703]         if (TRUE) {
[13:35:33.703]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:33.703]                 open = "w")
[13:35:33.703]         }
[13:35:33.703]         else {
[13:35:33.703]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:33.703]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:33.703]         }
[13:35:33.703]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:33.703]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:33.703]             base::sink(type = "output", split = FALSE)
[13:35:33.703]             base::close(...future.stdout)
[13:35:33.703]         }, add = TRUE)
[13:35:33.703]     }
[13:35:33.703]     ...future.frame <- base::sys.nframe()
[13:35:33.703]     ...future.conditions <- base::list()
[13:35:33.703]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:33.703]     if (FALSE) {
[13:35:33.703]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:33.703]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:33.703]     }
[13:35:33.703]     ...future.result <- base::tryCatch({
[13:35:33.703]         base::withCallingHandlers({
[13:35:33.703]             ...future.value <- base::withVisible(base::local({
[13:35:33.703]                 ...future.makeSendCondition <- base::local({
[13:35:33.703]                   sendCondition <- NULL
[13:35:33.703]                   function(frame = 1L) {
[13:35:33.703]                     if (is.function(sendCondition)) 
[13:35:33.703]                       return(sendCondition)
[13:35:33.703]                     ns <- getNamespace("parallel")
[13:35:33.703]                     if (exists("sendData", mode = "function", 
[13:35:33.703]                       envir = ns)) {
[13:35:33.703]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:33.703]                         envir = ns)
[13:35:33.703]                       envir <- sys.frame(frame)
[13:35:33.703]                       master <- NULL
[13:35:33.703]                       while (!identical(envir, .GlobalEnv) && 
[13:35:33.703]                         !identical(envir, emptyenv())) {
[13:35:33.703]                         if (exists("master", mode = "list", envir = envir, 
[13:35:33.703]                           inherits = FALSE)) {
[13:35:33.703]                           master <- get("master", mode = "list", 
[13:35:33.703]                             envir = envir, inherits = FALSE)
[13:35:33.703]                           if (inherits(master, c("SOCKnode", 
[13:35:33.703]                             "SOCK0node"))) {
[13:35:33.703]                             sendCondition <<- function(cond) {
[13:35:33.703]                               data <- list(type = "VALUE", value = cond, 
[13:35:33.703]                                 success = TRUE)
[13:35:33.703]                               parallel_sendData(master, data)
[13:35:33.703]                             }
[13:35:33.703]                             return(sendCondition)
[13:35:33.703]                           }
[13:35:33.703]                         }
[13:35:33.703]                         frame <- frame + 1L
[13:35:33.703]                         envir <- sys.frame(frame)
[13:35:33.703]                       }
[13:35:33.703]                     }
[13:35:33.703]                     sendCondition <<- function(cond) NULL
[13:35:33.703]                   }
[13:35:33.703]                 })
[13:35:33.703]                 withCallingHandlers({
[13:35:33.703]                   NA
[13:35:33.703]                 }, immediateCondition = function(cond) {
[13:35:33.703]                   sendCondition <- ...future.makeSendCondition()
[13:35:33.703]                   sendCondition(cond)
[13:35:33.703]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:33.703]                   {
[13:35:33.703]                     inherits <- base::inherits
[13:35:33.703]                     invokeRestart <- base::invokeRestart
[13:35:33.703]                     is.null <- base::is.null
[13:35:33.703]                     muffled <- FALSE
[13:35:33.703]                     if (inherits(cond, "message")) {
[13:35:33.703]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:33.703]                       if (muffled) 
[13:35:33.703]                         invokeRestart("muffleMessage")
[13:35:33.703]                     }
[13:35:33.703]                     else if (inherits(cond, "warning")) {
[13:35:33.703]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:33.703]                       if (muffled) 
[13:35:33.703]                         invokeRestart("muffleWarning")
[13:35:33.703]                     }
[13:35:33.703]                     else if (inherits(cond, "condition")) {
[13:35:33.703]                       if (!is.null(pattern)) {
[13:35:33.703]                         computeRestarts <- base::computeRestarts
[13:35:33.703]                         grepl <- base::grepl
[13:35:33.703]                         restarts <- computeRestarts(cond)
[13:35:33.703]                         for (restart in restarts) {
[13:35:33.703]                           name <- restart$name
[13:35:33.703]                           if (is.null(name)) 
[13:35:33.703]                             next
[13:35:33.703]                           if (!grepl(pattern, name)) 
[13:35:33.703]                             next
[13:35:33.703]                           invokeRestart(restart)
[13:35:33.703]                           muffled <- TRUE
[13:35:33.703]                           break
[13:35:33.703]                         }
[13:35:33.703]                       }
[13:35:33.703]                     }
[13:35:33.703]                     invisible(muffled)
[13:35:33.703]                   }
[13:35:33.703]                   muffleCondition(cond)
[13:35:33.703]                 })
[13:35:33.703]             }))
[13:35:33.703]             future::FutureResult(value = ...future.value$value, 
[13:35:33.703]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:33.703]                   ...future.rng), globalenv = if (FALSE) 
[13:35:33.703]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:33.703]                     ...future.globalenv.names))
[13:35:33.703]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:33.703]         }, condition = base::local({
[13:35:33.703]             c <- base::c
[13:35:33.703]             inherits <- base::inherits
[13:35:33.703]             invokeRestart <- base::invokeRestart
[13:35:33.703]             length <- base::length
[13:35:33.703]             list <- base::list
[13:35:33.703]             seq.int <- base::seq.int
[13:35:33.703]             signalCondition <- base::signalCondition
[13:35:33.703]             sys.calls <- base::sys.calls
[13:35:33.703]             `[[` <- base::`[[`
[13:35:33.703]             `+` <- base::`+`
[13:35:33.703]             `<<-` <- base::`<<-`
[13:35:33.703]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:33.703]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:33.703]                   3L)]
[13:35:33.703]             }
[13:35:33.703]             function(cond) {
[13:35:33.703]                 is_error <- inherits(cond, "error")
[13:35:33.703]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:33.703]                   NULL)
[13:35:33.703]                 if (is_error) {
[13:35:33.703]                   sessionInformation <- function() {
[13:35:33.703]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:33.703]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:33.703]                       search = base::search(), system = base::Sys.info())
[13:35:33.703]                   }
[13:35:33.703]                   ...future.conditions[[length(...future.conditions) + 
[13:35:33.703]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:33.703]                     cond$call), session = sessionInformation(), 
[13:35:33.703]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:33.703]                   signalCondition(cond)
[13:35:33.703]                 }
[13:35:33.703]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:33.703]                 "immediateCondition"))) {
[13:35:33.703]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:33.703]                   ...future.conditions[[length(...future.conditions) + 
[13:35:33.703]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:33.703]                   if (TRUE && !signal) {
[13:35:33.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:33.703]                     {
[13:35:33.703]                       inherits <- base::inherits
[13:35:33.703]                       invokeRestart <- base::invokeRestart
[13:35:33.703]                       is.null <- base::is.null
[13:35:33.703]                       muffled <- FALSE
[13:35:33.703]                       if (inherits(cond, "message")) {
[13:35:33.703]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:33.703]                         if (muffled) 
[13:35:33.703]                           invokeRestart("muffleMessage")
[13:35:33.703]                       }
[13:35:33.703]                       else if (inherits(cond, "warning")) {
[13:35:33.703]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:33.703]                         if (muffled) 
[13:35:33.703]                           invokeRestart("muffleWarning")
[13:35:33.703]                       }
[13:35:33.703]                       else if (inherits(cond, "condition")) {
[13:35:33.703]                         if (!is.null(pattern)) {
[13:35:33.703]                           computeRestarts <- base::computeRestarts
[13:35:33.703]                           grepl <- base::grepl
[13:35:33.703]                           restarts <- computeRestarts(cond)
[13:35:33.703]                           for (restart in restarts) {
[13:35:33.703]                             name <- restart$name
[13:35:33.703]                             if (is.null(name)) 
[13:35:33.703]                               next
[13:35:33.703]                             if (!grepl(pattern, name)) 
[13:35:33.703]                               next
[13:35:33.703]                             invokeRestart(restart)
[13:35:33.703]                             muffled <- TRUE
[13:35:33.703]                             break
[13:35:33.703]                           }
[13:35:33.703]                         }
[13:35:33.703]                       }
[13:35:33.703]                       invisible(muffled)
[13:35:33.703]                     }
[13:35:33.703]                     muffleCondition(cond, pattern = "^muffle")
[13:35:33.703]                   }
[13:35:33.703]                 }
[13:35:33.703]                 else {
[13:35:33.703]                   if (TRUE) {
[13:35:33.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:33.703]                     {
[13:35:33.703]                       inherits <- base::inherits
[13:35:33.703]                       invokeRestart <- base::invokeRestart
[13:35:33.703]                       is.null <- base::is.null
[13:35:33.703]                       muffled <- FALSE
[13:35:33.703]                       if (inherits(cond, "message")) {
[13:35:33.703]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:33.703]                         if (muffled) 
[13:35:33.703]                           invokeRestart("muffleMessage")
[13:35:33.703]                       }
[13:35:33.703]                       else if (inherits(cond, "warning")) {
[13:35:33.703]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:33.703]                         if (muffled) 
[13:35:33.703]                           invokeRestart("muffleWarning")
[13:35:33.703]                       }
[13:35:33.703]                       else if (inherits(cond, "condition")) {
[13:35:33.703]                         if (!is.null(pattern)) {
[13:35:33.703]                           computeRestarts <- base::computeRestarts
[13:35:33.703]                           grepl <- base::grepl
[13:35:33.703]                           restarts <- computeRestarts(cond)
[13:35:33.703]                           for (restart in restarts) {
[13:35:33.703]                             name <- restart$name
[13:35:33.703]                             if (is.null(name)) 
[13:35:33.703]                               next
[13:35:33.703]                             if (!grepl(pattern, name)) 
[13:35:33.703]                               next
[13:35:33.703]                             invokeRestart(restart)
[13:35:33.703]                             muffled <- TRUE
[13:35:33.703]                             break
[13:35:33.703]                           }
[13:35:33.703]                         }
[13:35:33.703]                       }
[13:35:33.703]                       invisible(muffled)
[13:35:33.703]                     }
[13:35:33.703]                     muffleCondition(cond, pattern = "^muffle")
[13:35:33.703]                   }
[13:35:33.703]                 }
[13:35:33.703]             }
[13:35:33.703]         }))
[13:35:33.703]     }, error = function(ex) {
[13:35:33.703]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:33.703]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:33.703]                 ...future.rng), started = ...future.startTime, 
[13:35:33.703]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:33.703]             version = "1.8"), class = "FutureResult")
[13:35:33.703]     }, finally = {
[13:35:33.703]         if (!identical(...future.workdir, getwd())) 
[13:35:33.703]             setwd(...future.workdir)
[13:35:33.703]         {
[13:35:33.703]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:33.703]                 ...future.oldOptions$nwarnings <- NULL
[13:35:33.703]             }
[13:35:33.703]             base::options(...future.oldOptions)
[13:35:33.703]             if (.Platform$OS.type == "windows") {
[13:35:33.703]                 old_names <- names(...future.oldEnvVars)
[13:35:33.703]                 envs <- base::Sys.getenv()
[13:35:33.703]                 names <- names(envs)
[13:35:33.703]                 common <- intersect(names, old_names)
[13:35:33.703]                 added <- setdiff(names, old_names)
[13:35:33.703]                 removed <- setdiff(old_names, names)
[13:35:33.703]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:33.703]                   envs[common]]
[13:35:33.703]                 NAMES <- toupper(changed)
[13:35:33.703]                 args <- list()
[13:35:33.703]                 for (kk in seq_along(NAMES)) {
[13:35:33.703]                   name <- changed[[kk]]
[13:35:33.703]                   NAME <- NAMES[[kk]]
[13:35:33.703]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:33.703]                     next
[13:35:33.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:33.703]                 }
[13:35:33.703]                 NAMES <- toupper(added)
[13:35:33.703]                 for (kk in seq_along(NAMES)) {
[13:35:33.703]                   name <- added[[kk]]
[13:35:33.703]                   NAME <- NAMES[[kk]]
[13:35:33.703]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:33.703]                     next
[13:35:33.703]                   args[[name]] <- ""
[13:35:33.703]                 }
[13:35:33.703]                 NAMES <- toupper(removed)
[13:35:33.703]                 for (kk in seq_along(NAMES)) {
[13:35:33.703]                   name <- removed[[kk]]
[13:35:33.703]                   NAME <- NAMES[[kk]]
[13:35:33.703]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:33.703]                     next
[13:35:33.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:33.703]                 }
[13:35:33.703]                 if (length(args) > 0) 
[13:35:33.703]                   base::do.call(base::Sys.setenv, args = args)
[13:35:33.703]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:33.703]             }
[13:35:33.703]             else {
[13:35:33.703]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:33.703]             }
[13:35:33.703]             {
[13:35:33.703]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:33.703]                   0L) {
[13:35:33.703]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:33.703]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:33.703]                   base::options(opts)
[13:35:33.703]                 }
[13:35:33.703]                 {
[13:35:33.703]                   {
[13:35:33.703]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:33.703]                     NULL
[13:35:33.703]                   }
[13:35:33.703]                   options(future.plan = NULL)
[13:35:33.703]                   if (is.na(NA_character_)) 
[13:35:33.703]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:33.703]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:33.703]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:33.703]                     .init = FALSE)
[13:35:33.703]                 }
[13:35:33.703]             }
[13:35:33.703]         }
[13:35:33.703]     })
[13:35:33.703]     if (TRUE) {
[13:35:33.703]         base::sink(type = "output", split = FALSE)
[13:35:33.703]         if (TRUE) {
[13:35:33.703]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:33.703]         }
[13:35:33.703]         else {
[13:35:33.703]             ...future.result["stdout"] <- base::list(NULL)
[13:35:33.703]         }
[13:35:33.703]         base::close(...future.stdout)
[13:35:33.703]         ...future.stdout <- NULL
[13:35:33.703]     }
[13:35:33.703]     ...future.result$conditions <- ...future.conditions
[13:35:33.703]     ...future.result$finished <- base::Sys.time()
[13:35:33.703]     ...future.result
[13:35:33.703] }
[13:35:33.757] MultisessionFuture started
[13:35:33.757] result() for ClusterFuture ...
[13:35:33.757] receiveMessageFromWorker() for ClusterFuture ...
[13:35:33.758] - Validating connection of MultisessionFuture
[13:35:33.790] - received message: FutureResult
[13:35:33.790] - Received FutureResult
[13:35:33.790] - Erased future from FutureRegistry
[13:35:33.790] result() for ClusterFuture ...
[13:35:33.790] - result already collected: FutureResult
[13:35:33.790] result() for ClusterFuture ... done
[13:35:33.791] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:33.791] result() for ClusterFuture ... done
[13:35:33.791] result() for ClusterFuture ...
[13:35:33.791] - result already collected: FutureResult
[13:35:33.791] result() for ClusterFuture ... done
[13:35:33.791] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:35:33.795] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[13:35:33.796] future_lapply() ...
[13:35:33.801] Number of chunks: 2
[13:35:33.801] getGlobalsAndPackagesXApply() ...
[13:35:33.801]  - future.globals: TRUE
[13:35:33.801] getGlobalsAndPackages() ...
[13:35:33.801] Searching for globals...
[13:35:33.803] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:35:33.803] Searching for globals ... DONE
[13:35:33.803] Resolving globals: FALSE
[13:35:33.804] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:35:33.804] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:35:33.804] - globals: [1] ‘FUN’
[13:35:33.804] 
[13:35:33.805] getGlobalsAndPackages() ... DONE
[13:35:33.805]  - globals found/used: [n=1] ‘FUN’
[13:35:33.805]  - needed namespaces: [n=0] 
[13:35:33.805] Finding globals ... DONE
[13:35:33.805]  - use_args: TRUE
[13:35:33.805]  - Getting '...' globals ...
[13:35:33.806] resolve() on list ...
[13:35:33.806]  recursive: 0
[13:35:33.806]  length: 1
[13:35:33.806]  elements: ‘...’
[13:35:33.806]  length: 0 (resolved future 1)
[13:35:33.806] resolve() on list ... DONE
[13:35:33.806]    - '...' content: [n=0] 
[13:35:33.806] List of 1
[13:35:33.806]  $ ...: list()
[13:35:33.806]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:33.806]  - attr(*, "where")=List of 1
[13:35:33.806]   ..$ ...:<environment: 0x558d3980c188> 
[13:35:33.806]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:33.806]  - attr(*, "resolved")= logi TRUE
[13:35:33.806]  - attr(*, "total_size")= num NA
[13:35:33.810]  - Getting '...' globals ... DONE
[13:35:33.810] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:35:33.810] List of 2
[13:35:33.810]  $ ...future.FUN:function (x)  
[13:35:33.810]  $ ...          : list()
[13:35:33.810]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:33.810]  - attr(*, "where")=List of 2
[13:35:33.810]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:33.810]   ..$ ...          :<environment: 0x558d3980c188> 
[13:35:33.810]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:33.810]  - attr(*, "resolved")= logi FALSE
[13:35:33.810]  - attr(*, "total_size")= num 4720
[13:35:33.813] Packages to be attached in all futures: [n=0] 
[13:35:33.813] getGlobalsAndPackagesXApply() ... DONE
[13:35:33.814] Number of futures (= number of chunks): 2
[13:35:33.814] Launching 2 futures (chunks) ...
[13:35:33.814] Chunk #1 of 2 ...
[13:35:33.814]  - Finding globals in 'X' for chunk #1 ...
[13:35:33.814] getGlobalsAndPackages() ...
[13:35:33.814] Searching for globals...
[13:35:33.815] 
[13:35:33.815] Searching for globals ... DONE
[13:35:33.815] - globals: [0] <none>
[13:35:33.815] getGlobalsAndPackages() ... DONE
[13:35:33.815]    + additional globals found: [n=0] 
[13:35:33.815]    + additional namespaces needed: [n=0] 
[13:35:33.815]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:33.815]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:33.816]  - seeds: <none>
[13:35:33.816]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:33.816] getGlobalsAndPackages() ...
[13:35:33.816] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:33.816] Resolving globals: FALSE
[13:35:33.816] Tweak future expression to call with '...' arguments ...
[13:35:33.816] {
[13:35:33.816]     do.call(function(...) {
[13:35:33.816]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:33.816]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:33.816]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:33.816]             on.exit(options(oopts), add = TRUE)
[13:35:33.816]         }
[13:35:33.816]         {
[13:35:33.816]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:33.816]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:33.816]                 ...future.FUN(...future.X_jj, ...)
[13:35:33.816]             })
[13:35:33.816]         }
[13:35:33.816]     }, args = future.call.arguments)
[13:35:33.816] }
[13:35:33.817] Tweak future expression to call with '...' arguments ... DONE
[13:35:33.817] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:33.817] 
[13:35:33.817] getGlobalsAndPackages() ... DONE
[13:35:33.818] run() for ‘Future’ ...
[13:35:33.818] - state: ‘created’
[13:35:33.818] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:33.833] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:33.833] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:33.833]   - Field: ‘node’
[13:35:33.833]   - Field: ‘label’
[13:35:33.833]   - Field: ‘local’
[13:35:33.833]   - Field: ‘owner’
[13:35:33.833]   - Field: ‘envir’
[13:35:33.833]   - Field: ‘workers’
[13:35:33.833]   - Field: ‘packages’
[13:35:33.833]   - Field: ‘gc’
[13:35:33.834]   - Field: ‘conditions’
[13:35:33.834]   - Field: ‘persistent’
[13:35:33.834]   - Field: ‘expr’
[13:35:33.834]   - Field: ‘uuid’
[13:35:33.834]   - Field: ‘seed’
[13:35:33.834]   - Field: ‘version’
[13:35:33.834]   - Field: ‘result’
[13:35:33.835]   - Field: ‘asynchronous’
[13:35:33.835]   - Field: ‘calls’
[13:35:33.835]   - Field: ‘globals’
[13:35:33.835]   - Field: ‘stdout’
[13:35:33.835]   - Field: ‘earlySignal’
[13:35:33.835]   - Field: ‘lazy’
[13:35:33.835]   - Field: ‘state’
[13:35:33.835] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:33.835] - Launch lazy future ...
[13:35:33.836] Packages needed by the future expression (n = 0): <none>
[13:35:33.836] Packages needed by future strategies (n = 0): <none>
[13:35:33.836] {
[13:35:33.836]     {
[13:35:33.836]         {
[13:35:33.836]             ...future.startTime <- base::Sys.time()
[13:35:33.836]             {
[13:35:33.836]                 {
[13:35:33.836]                   {
[13:35:33.836]                     {
[13:35:33.836]                       base::local({
[13:35:33.836]                         has_future <- base::requireNamespace("future", 
[13:35:33.836]                           quietly = TRUE)
[13:35:33.836]                         if (has_future) {
[13:35:33.836]                           ns <- base::getNamespace("future")
[13:35:33.836]                           version <- ns[[".package"]][["version"]]
[13:35:33.836]                           if (is.null(version)) 
[13:35:33.836]                             version <- utils::packageVersion("future")
[13:35:33.836]                         }
[13:35:33.836]                         else {
[13:35:33.836]                           version <- NULL
[13:35:33.836]                         }
[13:35:33.836]                         if (!has_future || version < "1.8.0") {
[13:35:33.836]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:33.836]                             "", base::R.version$version.string), 
[13:35:33.836]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:33.836]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:33.836]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:33.836]                               "release", "version")], collapse = " "), 
[13:35:33.836]                             hostname = base::Sys.info()[["nodename"]])
[13:35:33.836]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:33.836]                             info)
[13:35:33.836]                           info <- base::paste(info, collapse = "; ")
[13:35:33.836]                           if (!has_future) {
[13:35:33.836]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:33.836]                               info)
[13:35:33.836]                           }
[13:35:33.836]                           else {
[13:35:33.836]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:33.836]                               info, version)
[13:35:33.836]                           }
[13:35:33.836]                           base::stop(msg)
[13:35:33.836]                         }
[13:35:33.836]                       })
[13:35:33.836]                     }
[13:35:33.836]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:33.836]                     base::options(mc.cores = 1L)
[13:35:33.836]                   }
[13:35:33.836]                   ...future.strategy.old <- future::plan("list")
[13:35:33.836]                   options(future.plan = NULL)
[13:35:33.836]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:33.836]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:33.836]                 }
[13:35:33.836]                 ...future.workdir <- getwd()
[13:35:33.836]             }
[13:35:33.836]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:33.836]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:33.836]         }
[13:35:33.836]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:33.836]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:33.836]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:33.836]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:33.836]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:33.836]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:33.836]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:33.836]             base::names(...future.oldOptions))
[13:35:33.836]     }
[13:35:33.836]     if (FALSE) {
[13:35:33.836]     }
[13:35:33.836]     else {
[13:35:33.836]         if (FALSE) {
[13:35:33.836]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:33.836]                 open = "w")
[13:35:33.836]         }
[13:35:33.836]         else {
[13:35:33.836]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:33.836]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:33.836]         }
[13:35:33.836]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:33.836]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:33.836]             base::sink(type = "output", split = FALSE)
[13:35:33.836]             base::close(...future.stdout)
[13:35:33.836]         }, add = TRUE)
[13:35:33.836]     }
[13:35:33.836]     ...future.frame <- base::sys.nframe()
[13:35:33.836]     ...future.conditions <- base::list()
[13:35:33.836]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:33.836]     if (FALSE) {
[13:35:33.836]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:33.836]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:33.836]     }
[13:35:33.836]     ...future.result <- base::tryCatch({
[13:35:33.836]         base::withCallingHandlers({
[13:35:33.836]             ...future.value <- base::withVisible(base::local({
[13:35:33.836]                 ...future.makeSendCondition <- base::local({
[13:35:33.836]                   sendCondition <- NULL
[13:35:33.836]                   function(frame = 1L) {
[13:35:33.836]                     if (is.function(sendCondition)) 
[13:35:33.836]                       return(sendCondition)
[13:35:33.836]                     ns <- getNamespace("parallel")
[13:35:33.836]                     if (exists("sendData", mode = "function", 
[13:35:33.836]                       envir = ns)) {
[13:35:33.836]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:33.836]                         envir = ns)
[13:35:33.836]                       envir <- sys.frame(frame)
[13:35:33.836]                       master <- NULL
[13:35:33.836]                       while (!identical(envir, .GlobalEnv) && 
[13:35:33.836]                         !identical(envir, emptyenv())) {
[13:35:33.836]                         if (exists("master", mode = "list", envir = envir, 
[13:35:33.836]                           inherits = FALSE)) {
[13:35:33.836]                           master <- get("master", mode = "list", 
[13:35:33.836]                             envir = envir, inherits = FALSE)
[13:35:33.836]                           if (inherits(master, c("SOCKnode", 
[13:35:33.836]                             "SOCK0node"))) {
[13:35:33.836]                             sendCondition <<- function(cond) {
[13:35:33.836]                               data <- list(type = "VALUE", value = cond, 
[13:35:33.836]                                 success = TRUE)
[13:35:33.836]                               parallel_sendData(master, data)
[13:35:33.836]                             }
[13:35:33.836]                             return(sendCondition)
[13:35:33.836]                           }
[13:35:33.836]                         }
[13:35:33.836]                         frame <- frame + 1L
[13:35:33.836]                         envir <- sys.frame(frame)
[13:35:33.836]                       }
[13:35:33.836]                     }
[13:35:33.836]                     sendCondition <<- function(cond) NULL
[13:35:33.836]                   }
[13:35:33.836]                 })
[13:35:33.836]                 withCallingHandlers({
[13:35:33.836]                   {
[13:35:33.836]                     do.call(function(...) {
[13:35:33.836]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:33.836]                       if (!identical(...future.globals.maxSize.org, 
[13:35:33.836]                         ...future.globals.maxSize)) {
[13:35:33.836]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:33.836]                         on.exit(options(oopts), add = TRUE)
[13:35:33.836]                       }
[13:35:33.836]                       {
[13:35:33.836]                         lapply(seq_along(...future.elements_ii), 
[13:35:33.836]                           FUN = function(jj) {
[13:35:33.836]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:33.836]                             ...future.FUN(...future.X_jj, ...)
[13:35:33.836]                           })
[13:35:33.836]                       }
[13:35:33.836]                     }, args = future.call.arguments)
[13:35:33.836]                   }
[13:35:33.836]                 }, immediateCondition = function(cond) {
[13:35:33.836]                   sendCondition <- ...future.makeSendCondition()
[13:35:33.836]                   sendCondition(cond)
[13:35:33.836]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:33.836]                   {
[13:35:33.836]                     inherits <- base::inherits
[13:35:33.836]                     invokeRestart <- base::invokeRestart
[13:35:33.836]                     is.null <- base::is.null
[13:35:33.836]                     muffled <- FALSE
[13:35:33.836]                     if (inherits(cond, "message")) {
[13:35:33.836]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:33.836]                       if (muffled) 
[13:35:33.836]                         invokeRestart("muffleMessage")
[13:35:33.836]                     }
[13:35:33.836]                     else if (inherits(cond, "warning")) {
[13:35:33.836]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:33.836]                       if (muffled) 
[13:35:33.836]                         invokeRestart("muffleWarning")
[13:35:33.836]                     }
[13:35:33.836]                     else if (inherits(cond, "condition")) {
[13:35:33.836]                       if (!is.null(pattern)) {
[13:35:33.836]                         computeRestarts <- base::computeRestarts
[13:35:33.836]                         grepl <- base::grepl
[13:35:33.836]                         restarts <- computeRestarts(cond)
[13:35:33.836]                         for (restart in restarts) {
[13:35:33.836]                           name <- restart$name
[13:35:33.836]                           if (is.null(name)) 
[13:35:33.836]                             next
[13:35:33.836]                           if (!grepl(pattern, name)) 
[13:35:33.836]                             next
[13:35:33.836]                           invokeRestart(restart)
[13:35:33.836]                           muffled <- TRUE
[13:35:33.836]                           break
[13:35:33.836]                         }
[13:35:33.836]                       }
[13:35:33.836]                     }
[13:35:33.836]                     invisible(muffled)
[13:35:33.836]                   }
[13:35:33.836]                   muffleCondition(cond)
[13:35:33.836]                 })
[13:35:33.836]             }))
[13:35:33.836]             future::FutureResult(value = ...future.value$value, 
[13:35:33.836]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:33.836]                   ...future.rng), globalenv = if (FALSE) 
[13:35:33.836]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:33.836]                     ...future.globalenv.names))
[13:35:33.836]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:33.836]         }, condition = base::local({
[13:35:33.836]             c <- base::c
[13:35:33.836]             inherits <- base::inherits
[13:35:33.836]             invokeRestart <- base::invokeRestart
[13:35:33.836]             length <- base::length
[13:35:33.836]             list <- base::list
[13:35:33.836]             seq.int <- base::seq.int
[13:35:33.836]             signalCondition <- base::signalCondition
[13:35:33.836]             sys.calls <- base::sys.calls
[13:35:33.836]             `[[` <- base::`[[`
[13:35:33.836]             `+` <- base::`+`
[13:35:33.836]             `<<-` <- base::`<<-`
[13:35:33.836]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:33.836]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:33.836]                   3L)]
[13:35:33.836]             }
[13:35:33.836]             function(cond) {
[13:35:33.836]                 is_error <- inherits(cond, "error")
[13:35:33.836]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:33.836]                   NULL)
[13:35:33.836]                 if (is_error) {
[13:35:33.836]                   sessionInformation <- function() {
[13:35:33.836]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:33.836]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:33.836]                       search = base::search(), system = base::Sys.info())
[13:35:33.836]                   }
[13:35:33.836]                   ...future.conditions[[length(...future.conditions) + 
[13:35:33.836]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:33.836]                     cond$call), session = sessionInformation(), 
[13:35:33.836]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:33.836]                   signalCondition(cond)
[13:35:33.836]                 }
[13:35:33.836]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:33.836]                 "immediateCondition"))) {
[13:35:33.836]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:33.836]                   ...future.conditions[[length(...future.conditions) + 
[13:35:33.836]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:33.836]                   if (TRUE && !signal) {
[13:35:33.836]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:33.836]                     {
[13:35:33.836]                       inherits <- base::inherits
[13:35:33.836]                       invokeRestart <- base::invokeRestart
[13:35:33.836]                       is.null <- base::is.null
[13:35:33.836]                       muffled <- FALSE
[13:35:33.836]                       if (inherits(cond, "message")) {
[13:35:33.836]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:33.836]                         if (muffled) 
[13:35:33.836]                           invokeRestart("muffleMessage")
[13:35:33.836]                       }
[13:35:33.836]                       else if (inherits(cond, "warning")) {
[13:35:33.836]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:33.836]                         if (muffled) 
[13:35:33.836]                           invokeRestart("muffleWarning")
[13:35:33.836]                       }
[13:35:33.836]                       else if (inherits(cond, "condition")) {
[13:35:33.836]                         if (!is.null(pattern)) {
[13:35:33.836]                           computeRestarts <- base::computeRestarts
[13:35:33.836]                           grepl <- base::grepl
[13:35:33.836]                           restarts <- computeRestarts(cond)
[13:35:33.836]                           for (restart in restarts) {
[13:35:33.836]                             name <- restart$name
[13:35:33.836]                             if (is.null(name)) 
[13:35:33.836]                               next
[13:35:33.836]                             if (!grepl(pattern, name)) 
[13:35:33.836]                               next
[13:35:33.836]                             invokeRestart(restart)
[13:35:33.836]                             muffled <- TRUE
[13:35:33.836]                             break
[13:35:33.836]                           }
[13:35:33.836]                         }
[13:35:33.836]                       }
[13:35:33.836]                       invisible(muffled)
[13:35:33.836]                     }
[13:35:33.836]                     muffleCondition(cond, pattern = "^muffle")
[13:35:33.836]                   }
[13:35:33.836]                 }
[13:35:33.836]                 else {
[13:35:33.836]                   if (TRUE) {
[13:35:33.836]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:33.836]                     {
[13:35:33.836]                       inherits <- base::inherits
[13:35:33.836]                       invokeRestart <- base::invokeRestart
[13:35:33.836]                       is.null <- base::is.null
[13:35:33.836]                       muffled <- FALSE
[13:35:33.836]                       if (inherits(cond, "message")) {
[13:35:33.836]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:33.836]                         if (muffled) 
[13:35:33.836]                           invokeRestart("muffleMessage")
[13:35:33.836]                       }
[13:35:33.836]                       else if (inherits(cond, "warning")) {
[13:35:33.836]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:33.836]                         if (muffled) 
[13:35:33.836]                           invokeRestart("muffleWarning")
[13:35:33.836]                       }
[13:35:33.836]                       else if (inherits(cond, "condition")) {
[13:35:33.836]                         if (!is.null(pattern)) {
[13:35:33.836]                           computeRestarts <- base::computeRestarts
[13:35:33.836]                           grepl <- base::grepl
[13:35:33.836]                           restarts <- computeRestarts(cond)
[13:35:33.836]                           for (restart in restarts) {
[13:35:33.836]                             name <- restart$name
[13:35:33.836]                             if (is.null(name)) 
[13:35:33.836]                               next
[13:35:33.836]                             if (!grepl(pattern, name)) 
[13:35:33.836]                               next
[13:35:33.836]                             invokeRestart(restart)
[13:35:33.836]                             muffled <- TRUE
[13:35:33.836]                             break
[13:35:33.836]                           }
[13:35:33.836]                         }
[13:35:33.836]                       }
[13:35:33.836]                       invisible(muffled)
[13:35:33.836]                     }
[13:35:33.836]                     muffleCondition(cond, pattern = "^muffle")
[13:35:33.836]                   }
[13:35:33.836]                 }
[13:35:33.836]             }
[13:35:33.836]         }))
[13:35:33.836]     }, error = function(ex) {
[13:35:33.836]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:33.836]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:33.836]                 ...future.rng), started = ...future.startTime, 
[13:35:33.836]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:33.836]             version = "1.8"), class = "FutureResult")
[13:35:33.836]     }, finally = {
[13:35:33.836]         if (!identical(...future.workdir, getwd())) 
[13:35:33.836]             setwd(...future.workdir)
[13:35:33.836]         {
[13:35:33.836]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:33.836]                 ...future.oldOptions$nwarnings <- NULL
[13:35:33.836]             }
[13:35:33.836]             base::options(...future.oldOptions)
[13:35:33.836]             if (.Platform$OS.type == "windows") {
[13:35:33.836]                 old_names <- names(...future.oldEnvVars)
[13:35:33.836]                 envs <- base::Sys.getenv()
[13:35:33.836]                 names <- names(envs)
[13:35:33.836]                 common <- intersect(names, old_names)
[13:35:33.836]                 added <- setdiff(names, old_names)
[13:35:33.836]                 removed <- setdiff(old_names, names)
[13:35:33.836]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:33.836]                   envs[common]]
[13:35:33.836]                 NAMES <- toupper(changed)
[13:35:33.836]                 args <- list()
[13:35:33.836]                 for (kk in seq_along(NAMES)) {
[13:35:33.836]                   name <- changed[[kk]]
[13:35:33.836]                   NAME <- NAMES[[kk]]
[13:35:33.836]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:33.836]                     next
[13:35:33.836]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:33.836]                 }
[13:35:33.836]                 NAMES <- toupper(added)
[13:35:33.836]                 for (kk in seq_along(NAMES)) {
[13:35:33.836]                   name <- added[[kk]]
[13:35:33.836]                   NAME <- NAMES[[kk]]
[13:35:33.836]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:33.836]                     next
[13:35:33.836]                   args[[name]] <- ""
[13:35:33.836]                 }
[13:35:33.836]                 NAMES <- toupper(removed)
[13:35:33.836]                 for (kk in seq_along(NAMES)) {
[13:35:33.836]                   name <- removed[[kk]]
[13:35:33.836]                   NAME <- NAMES[[kk]]
[13:35:33.836]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:33.836]                     next
[13:35:33.836]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:33.836]                 }
[13:35:33.836]                 if (length(args) > 0) 
[13:35:33.836]                   base::do.call(base::Sys.setenv, args = args)
[13:35:33.836]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:33.836]             }
[13:35:33.836]             else {
[13:35:33.836]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:33.836]             }
[13:35:33.836]             {
[13:35:33.836]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:33.836]                   0L) {
[13:35:33.836]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:33.836]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:33.836]                   base::options(opts)
[13:35:33.836]                 }
[13:35:33.836]                 {
[13:35:33.836]                   {
[13:35:33.836]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:33.836]                     NULL
[13:35:33.836]                   }
[13:35:33.836]                   options(future.plan = NULL)
[13:35:33.836]                   if (is.na(NA_character_)) 
[13:35:33.836]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:33.836]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:33.836]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:33.836]                     .init = FALSE)
[13:35:33.836]                 }
[13:35:33.836]             }
[13:35:33.836]         }
[13:35:33.836]     })
[13:35:33.836]     if (TRUE) {
[13:35:33.836]         base::sink(type = "output", split = FALSE)
[13:35:33.836]         if (FALSE) {
[13:35:33.836]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:33.836]         }
[13:35:33.836]         else {
[13:35:33.836]             ...future.result["stdout"] <- base::list(NULL)
[13:35:33.836]         }
[13:35:33.836]         base::close(...future.stdout)
[13:35:33.836]         ...future.stdout <- NULL
[13:35:33.836]     }
[13:35:33.836]     ...future.result$conditions <- ...future.conditions
[13:35:33.836]     ...future.result$finished <- base::Sys.time()
[13:35:33.836]     ...future.result
[13:35:33.836] }
[13:35:33.839] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[13:35:33.840] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[13:35:33.840] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[13:35:33.840] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:35:33.841] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:35:33.841] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:35:33.841] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:35:33.841] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:33.842] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:33.842] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:33.842] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:33.842] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[13:35:33.843] MultisessionFuture started
[13:35:33.843] - Launch lazy future ... done
[13:35:33.843] run() for ‘MultisessionFuture’ ... done
[13:35:33.843] Created future:
[13:35:33.844] MultisessionFuture:
[13:35:33.844] Label: ‘future_lapply-1’
[13:35:33.844] Expression:
[13:35:33.844] {
[13:35:33.844]     do.call(function(...) {
[13:35:33.844]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:33.844]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:33.844]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:33.844]             on.exit(options(oopts), add = TRUE)
[13:35:33.844]         }
[13:35:33.844]         {
[13:35:33.844]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:33.844]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:33.844]                 ...future.FUN(...future.X_jj, ...)
[13:35:33.844]             })
[13:35:33.844]         }
[13:35:33.844]     }, args = future.call.arguments)
[13:35:33.844] }
[13:35:33.844] Lazy evaluation: FALSE
[13:35:33.844] Asynchronous evaluation: TRUE
[13:35:33.844] Local evaluation: TRUE
[13:35:33.844] Environment: R_GlobalEnv
[13:35:33.844] Capture standard output: FALSE
[13:35:33.844] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:33.844] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:33.844] Packages: <none>
[13:35:33.844] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:33.844] Resolved: FALSE
[13:35:33.844] Value: <not collected>
[13:35:33.844] Conditions captured: <none>
[13:35:33.844] Early signaling: FALSE
[13:35:33.844] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:33.844] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:33.856] Chunk #1 of 2 ... DONE
[13:35:33.856] Chunk #2 of 2 ...
[13:35:33.856]  - Finding globals in 'X' for chunk #2 ...
[13:35:33.856] getGlobalsAndPackages() ...
[13:35:33.856] Searching for globals...
[13:35:33.856] 
[13:35:33.856] Searching for globals ... DONE
[13:35:33.857] - globals: [0] <none>
[13:35:33.857] getGlobalsAndPackages() ... DONE
[13:35:33.857]    + additional globals found: [n=0] 
[13:35:33.857]    + additional namespaces needed: [n=0] 
[13:35:33.857]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:33.857]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:33.857]  - seeds: <none>
[13:35:33.857]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:33.858] getGlobalsAndPackages() ...
[13:35:33.858] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:33.858] Resolving globals: FALSE
[13:35:33.858] Tweak future expression to call with '...' arguments ...
[13:35:33.858] {
[13:35:33.858]     do.call(function(...) {
[13:35:33.858]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:33.858]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:33.858]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:33.858]             on.exit(options(oopts), add = TRUE)
[13:35:33.858]         }
[13:35:33.858]         {
[13:35:33.858]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:33.858]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:33.858]                 ...future.FUN(...future.X_jj, ...)
[13:35:33.858]             })
[13:35:33.858]         }
[13:35:33.858]     }, args = future.call.arguments)
[13:35:33.858] }
[13:35:33.858] Tweak future expression to call with '...' arguments ... DONE
[13:35:33.859] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:33.859] 
[13:35:33.859] getGlobalsAndPackages() ... DONE
[13:35:33.859] run() for ‘Future’ ...
[13:35:33.859] - state: ‘created’
[13:35:33.860] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:33.874] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:33.874] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:33.874]   - Field: ‘node’
[13:35:33.874]   - Field: ‘label’
[13:35:33.875]   - Field: ‘local’
[13:35:33.875]   - Field: ‘owner’
[13:35:33.875]   - Field: ‘envir’
[13:35:33.875]   - Field: ‘workers’
[13:35:33.875]   - Field: ‘packages’
[13:35:33.875]   - Field: ‘gc’
[13:35:33.875]   - Field: ‘conditions’
[13:35:33.875]   - Field: ‘persistent’
[13:35:33.875]   - Field: ‘expr’
[13:35:33.875]   - Field: ‘uuid’
[13:35:33.876]   - Field: ‘seed’
[13:35:33.876]   - Field: ‘version’
[13:35:33.876]   - Field: ‘result’
[13:35:33.876]   - Field: ‘asynchronous’
[13:35:33.876]   - Field: ‘calls’
[13:35:33.876]   - Field: ‘globals’
[13:35:33.876]   - Field: ‘stdout’
[13:35:33.876]   - Field: ‘earlySignal’
[13:35:33.876]   - Field: ‘lazy’
[13:35:33.877]   - Field: ‘state’
[13:35:33.877] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:33.877] - Launch lazy future ...
[13:35:33.877] Packages needed by the future expression (n = 0): <none>
[13:35:33.877] Packages needed by future strategies (n = 0): <none>
[13:35:33.878] {
[13:35:33.878]     {
[13:35:33.878]         {
[13:35:33.878]             ...future.startTime <- base::Sys.time()
[13:35:33.878]             {
[13:35:33.878]                 {
[13:35:33.878]                   {
[13:35:33.878]                     {
[13:35:33.878]                       base::local({
[13:35:33.878]                         has_future <- base::requireNamespace("future", 
[13:35:33.878]                           quietly = TRUE)
[13:35:33.878]                         if (has_future) {
[13:35:33.878]                           ns <- base::getNamespace("future")
[13:35:33.878]                           version <- ns[[".package"]][["version"]]
[13:35:33.878]                           if (is.null(version)) 
[13:35:33.878]                             version <- utils::packageVersion("future")
[13:35:33.878]                         }
[13:35:33.878]                         else {
[13:35:33.878]                           version <- NULL
[13:35:33.878]                         }
[13:35:33.878]                         if (!has_future || version < "1.8.0") {
[13:35:33.878]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:33.878]                             "", base::R.version$version.string), 
[13:35:33.878]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:33.878]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:33.878]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:33.878]                               "release", "version")], collapse = " "), 
[13:35:33.878]                             hostname = base::Sys.info()[["nodename"]])
[13:35:33.878]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:33.878]                             info)
[13:35:33.878]                           info <- base::paste(info, collapse = "; ")
[13:35:33.878]                           if (!has_future) {
[13:35:33.878]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:33.878]                               info)
[13:35:33.878]                           }
[13:35:33.878]                           else {
[13:35:33.878]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:33.878]                               info, version)
[13:35:33.878]                           }
[13:35:33.878]                           base::stop(msg)
[13:35:33.878]                         }
[13:35:33.878]                       })
[13:35:33.878]                     }
[13:35:33.878]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:33.878]                     base::options(mc.cores = 1L)
[13:35:33.878]                   }
[13:35:33.878]                   ...future.strategy.old <- future::plan("list")
[13:35:33.878]                   options(future.plan = NULL)
[13:35:33.878]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:33.878]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:33.878]                 }
[13:35:33.878]                 ...future.workdir <- getwd()
[13:35:33.878]             }
[13:35:33.878]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:33.878]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:33.878]         }
[13:35:33.878]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:33.878]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:33.878]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:33.878]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:33.878]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:33.878]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:33.878]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:33.878]             base::names(...future.oldOptions))
[13:35:33.878]     }
[13:35:33.878]     if (FALSE) {
[13:35:33.878]     }
[13:35:33.878]     else {
[13:35:33.878]         if (FALSE) {
[13:35:33.878]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:33.878]                 open = "w")
[13:35:33.878]         }
[13:35:33.878]         else {
[13:35:33.878]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:33.878]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:33.878]         }
[13:35:33.878]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:33.878]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:33.878]             base::sink(type = "output", split = FALSE)
[13:35:33.878]             base::close(...future.stdout)
[13:35:33.878]         }, add = TRUE)
[13:35:33.878]     }
[13:35:33.878]     ...future.frame <- base::sys.nframe()
[13:35:33.878]     ...future.conditions <- base::list()
[13:35:33.878]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:33.878]     if (FALSE) {
[13:35:33.878]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:33.878]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:33.878]     }
[13:35:33.878]     ...future.result <- base::tryCatch({
[13:35:33.878]         base::withCallingHandlers({
[13:35:33.878]             ...future.value <- base::withVisible(base::local({
[13:35:33.878]                 ...future.makeSendCondition <- base::local({
[13:35:33.878]                   sendCondition <- NULL
[13:35:33.878]                   function(frame = 1L) {
[13:35:33.878]                     if (is.function(sendCondition)) 
[13:35:33.878]                       return(sendCondition)
[13:35:33.878]                     ns <- getNamespace("parallel")
[13:35:33.878]                     if (exists("sendData", mode = "function", 
[13:35:33.878]                       envir = ns)) {
[13:35:33.878]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:33.878]                         envir = ns)
[13:35:33.878]                       envir <- sys.frame(frame)
[13:35:33.878]                       master <- NULL
[13:35:33.878]                       while (!identical(envir, .GlobalEnv) && 
[13:35:33.878]                         !identical(envir, emptyenv())) {
[13:35:33.878]                         if (exists("master", mode = "list", envir = envir, 
[13:35:33.878]                           inherits = FALSE)) {
[13:35:33.878]                           master <- get("master", mode = "list", 
[13:35:33.878]                             envir = envir, inherits = FALSE)
[13:35:33.878]                           if (inherits(master, c("SOCKnode", 
[13:35:33.878]                             "SOCK0node"))) {
[13:35:33.878]                             sendCondition <<- function(cond) {
[13:35:33.878]                               data <- list(type = "VALUE", value = cond, 
[13:35:33.878]                                 success = TRUE)
[13:35:33.878]                               parallel_sendData(master, data)
[13:35:33.878]                             }
[13:35:33.878]                             return(sendCondition)
[13:35:33.878]                           }
[13:35:33.878]                         }
[13:35:33.878]                         frame <- frame + 1L
[13:35:33.878]                         envir <- sys.frame(frame)
[13:35:33.878]                       }
[13:35:33.878]                     }
[13:35:33.878]                     sendCondition <<- function(cond) NULL
[13:35:33.878]                   }
[13:35:33.878]                 })
[13:35:33.878]                 withCallingHandlers({
[13:35:33.878]                   {
[13:35:33.878]                     do.call(function(...) {
[13:35:33.878]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:33.878]                       if (!identical(...future.globals.maxSize.org, 
[13:35:33.878]                         ...future.globals.maxSize)) {
[13:35:33.878]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:33.878]                         on.exit(options(oopts), add = TRUE)
[13:35:33.878]                       }
[13:35:33.878]                       {
[13:35:33.878]                         lapply(seq_along(...future.elements_ii), 
[13:35:33.878]                           FUN = function(jj) {
[13:35:33.878]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:33.878]                             ...future.FUN(...future.X_jj, ...)
[13:35:33.878]                           })
[13:35:33.878]                       }
[13:35:33.878]                     }, args = future.call.arguments)
[13:35:33.878]                   }
[13:35:33.878]                 }, immediateCondition = function(cond) {
[13:35:33.878]                   sendCondition <- ...future.makeSendCondition()
[13:35:33.878]                   sendCondition(cond)
[13:35:33.878]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:33.878]                   {
[13:35:33.878]                     inherits <- base::inherits
[13:35:33.878]                     invokeRestart <- base::invokeRestart
[13:35:33.878]                     is.null <- base::is.null
[13:35:33.878]                     muffled <- FALSE
[13:35:33.878]                     if (inherits(cond, "message")) {
[13:35:33.878]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:33.878]                       if (muffled) 
[13:35:33.878]                         invokeRestart("muffleMessage")
[13:35:33.878]                     }
[13:35:33.878]                     else if (inherits(cond, "warning")) {
[13:35:33.878]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:33.878]                       if (muffled) 
[13:35:33.878]                         invokeRestart("muffleWarning")
[13:35:33.878]                     }
[13:35:33.878]                     else if (inherits(cond, "condition")) {
[13:35:33.878]                       if (!is.null(pattern)) {
[13:35:33.878]                         computeRestarts <- base::computeRestarts
[13:35:33.878]                         grepl <- base::grepl
[13:35:33.878]                         restarts <- computeRestarts(cond)
[13:35:33.878]                         for (restart in restarts) {
[13:35:33.878]                           name <- restart$name
[13:35:33.878]                           if (is.null(name)) 
[13:35:33.878]                             next
[13:35:33.878]                           if (!grepl(pattern, name)) 
[13:35:33.878]                             next
[13:35:33.878]                           invokeRestart(restart)
[13:35:33.878]                           muffled <- TRUE
[13:35:33.878]                           break
[13:35:33.878]                         }
[13:35:33.878]                       }
[13:35:33.878]                     }
[13:35:33.878]                     invisible(muffled)
[13:35:33.878]                   }
[13:35:33.878]                   muffleCondition(cond)
[13:35:33.878]                 })
[13:35:33.878]             }))
[13:35:33.878]             future::FutureResult(value = ...future.value$value, 
[13:35:33.878]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:33.878]                   ...future.rng), globalenv = if (FALSE) 
[13:35:33.878]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:33.878]                     ...future.globalenv.names))
[13:35:33.878]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:33.878]         }, condition = base::local({
[13:35:33.878]             c <- base::c
[13:35:33.878]             inherits <- base::inherits
[13:35:33.878]             invokeRestart <- base::invokeRestart
[13:35:33.878]             length <- base::length
[13:35:33.878]             list <- base::list
[13:35:33.878]             seq.int <- base::seq.int
[13:35:33.878]             signalCondition <- base::signalCondition
[13:35:33.878]             sys.calls <- base::sys.calls
[13:35:33.878]             `[[` <- base::`[[`
[13:35:33.878]             `+` <- base::`+`
[13:35:33.878]             `<<-` <- base::`<<-`
[13:35:33.878]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:33.878]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:33.878]                   3L)]
[13:35:33.878]             }
[13:35:33.878]             function(cond) {
[13:35:33.878]                 is_error <- inherits(cond, "error")
[13:35:33.878]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:33.878]                   NULL)
[13:35:33.878]                 if (is_error) {
[13:35:33.878]                   sessionInformation <- function() {
[13:35:33.878]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:33.878]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:33.878]                       search = base::search(), system = base::Sys.info())
[13:35:33.878]                   }
[13:35:33.878]                   ...future.conditions[[length(...future.conditions) + 
[13:35:33.878]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:33.878]                     cond$call), session = sessionInformation(), 
[13:35:33.878]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:33.878]                   signalCondition(cond)
[13:35:33.878]                 }
[13:35:33.878]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:33.878]                 "immediateCondition"))) {
[13:35:33.878]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:33.878]                   ...future.conditions[[length(...future.conditions) + 
[13:35:33.878]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:33.878]                   if (TRUE && !signal) {
[13:35:33.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:33.878]                     {
[13:35:33.878]                       inherits <- base::inherits
[13:35:33.878]                       invokeRestart <- base::invokeRestart
[13:35:33.878]                       is.null <- base::is.null
[13:35:33.878]                       muffled <- FALSE
[13:35:33.878]                       if (inherits(cond, "message")) {
[13:35:33.878]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:33.878]                         if (muffled) 
[13:35:33.878]                           invokeRestart("muffleMessage")
[13:35:33.878]                       }
[13:35:33.878]                       else if (inherits(cond, "warning")) {
[13:35:33.878]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:33.878]                         if (muffled) 
[13:35:33.878]                           invokeRestart("muffleWarning")
[13:35:33.878]                       }
[13:35:33.878]                       else if (inherits(cond, "condition")) {
[13:35:33.878]                         if (!is.null(pattern)) {
[13:35:33.878]                           computeRestarts <- base::computeRestarts
[13:35:33.878]                           grepl <- base::grepl
[13:35:33.878]                           restarts <- computeRestarts(cond)
[13:35:33.878]                           for (restart in restarts) {
[13:35:33.878]                             name <- restart$name
[13:35:33.878]                             if (is.null(name)) 
[13:35:33.878]                               next
[13:35:33.878]                             if (!grepl(pattern, name)) 
[13:35:33.878]                               next
[13:35:33.878]                             invokeRestart(restart)
[13:35:33.878]                             muffled <- TRUE
[13:35:33.878]                             break
[13:35:33.878]                           }
[13:35:33.878]                         }
[13:35:33.878]                       }
[13:35:33.878]                       invisible(muffled)
[13:35:33.878]                     }
[13:35:33.878]                     muffleCondition(cond, pattern = "^muffle")
[13:35:33.878]                   }
[13:35:33.878]                 }
[13:35:33.878]                 else {
[13:35:33.878]                   if (TRUE) {
[13:35:33.878]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:33.878]                     {
[13:35:33.878]                       inherits <- base::inherits
[13:35:33.878]                       invokeRestart <- base::invokeRestart
[13:35:33.878]                       is.null <- base::is.null
[13:35:33.878]                       muffled <- FALSE
[13:35:33.878]                       if (inherits(cond, "message")) {
[13:35:33.878]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:33.878]                         if (muffled) 
[13:35:33.878]                           invokeRestart("muffleMessage")
[13:35:33.878]                       }
[13:35:33.878]                       else if (inherits(cond, "warning")) {
[13:35:33.878]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:33.878]                         if (muffled) 
[13:35:33.878]                           invokeRestart("muffleWarning")
[13:35:33.878]                       }
[13:35:33.878]                       else if (inherits(cond, "condition")) {
[13:35:33.878]                         if (!is.null(pattern)) {
[13:35:33.878]                           computeRestarts <- base::computeRestarts
[13:35:33.878]                           grepl <- base::grepl
[13:35:33.878]                           restarts <- computeRestarts(cond)
[13:35:33.878]                           for (restart in restarts) {
[13:35:33.878]                             name <- restart$name
[13:35:33.878]                             if (is.null(name)) 
[13:35:33.878]                               next
[13:35:33.878]                             if (!grepl(pattern, name)) 
[13:35:33.878]                               next
[13:35:33.878]                             invokeRestart(restart)
[13:35:33.878]                             muffled <- TRUE
[13:35:33.878]                             break
[13:35:33.878]                           }
[13:35:33.878]                         }
[13:35:33.878]                       }
[13:35:33.878]                       invisible(muffled)
[13:35:33.878]                     }
[13:35:33.878]                     muffleCondition(cond, pattern = "^muffle")
[13:35:33.878]                   }
[13:35:33.878]                 }
[13:35:33.878]             }
[13:35:33.878]         }))
[13:35:33.878]     }, error = function(ex) {
[13:35:33.878]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:33.878]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:33.878]                 ...future.rng), started = ...future.startTime, 
[13:35:33.878]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:33.878]             version = "1.8"), class = "FutureResult")
[13:35:33.878]     }, finally = {
[13:35:33.878]         if (!identical(...future.workdir, getwd())) 
[13:35:33.878]             setwd(...future.workdir)
[13:35:33.878]         {
[13:35:33.878]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:33.878]                 ...future.oldOptions$nwarnings <- NULL
[13:35:33.878]             }
[13:35:33.878]             base::options(...future.oldOptions)
[13:35:33.878]             if (.Platform$OS.type == "windows") {
[13:35:33.878]                 old_names <- names(...future.oldEnvVars)
[13:35:33.878]                 envs <- base::Sys.getenv()
[13:35:33.878]                 names <- names(envs)
[13:35:33.878]                 common <- intersect(names, old_names)
[13:35:33.878]                 added <- setdiff(names, old_names)
[13:35:33.878]                 removed <- setdiff(old_names, names)
[13:35:33.878]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:33.878]                   envs[common]]
[13:35:33.878]                 NAMES <- toupper(changed)
[13:35:33.878]                 args <- list()
[13:35:33.878]                 for (kk in seq_along(NAMES)) {
[13:35:33.878]                   name <- changed[[kk]]
[13:35:33.878]                   NAME <- NAMES[[kk]]
[13:35:33.878]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:33.878]                     next
[13:35:33.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:33.878]                 }
[13:35:33.878]                 NAMES <- toupper(added)
[13:35:33.878]                 for (kk in seq_along(NAMES)) {
[13:35:33.878]                   name <- added[[kk]]
[13:35:33.878]                   NAME <- NAMES[[kk]]
[13:35:33.878]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:33.878]                     next
[13:35:33.878]                   args[[name]] <- ""
[13:35:33.878]                 }
[13:35:33.878]                 NAMES <- toupper(removed)
[13:35:33.878]                 for (kk in seq_along(NAMES)) {
[13:35:33.878]                   name <- removed[[kk]]
[13:35:33.878]                   NAME <- NAMES[[kk]]
[13:35:33.878]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:33.878]                     next
[13:35:33.878]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:33.878]                 }
[13:35:33.878]                 if (length(args) > 0) 
[13:35:33.878]                   base::do.call(base::Sys.setenv, args = args)
[13:35:33.878]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:33.878]             }
[13:35:33.878]             else {
[13:35:33.878]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:33.878]             }
[13:35:33.878]             {
[13:35:33.878]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:33.878]                   0L) {
[13:35:33.878]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:33.878]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:33.878]                   base::options(opts)
[13:35:33.878]                 }
[13:35:33.878]                 {
[13:35:33.878]                   {
[13:35:33.878]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:33.878]                     NULL
[13:35:33.878]                   }
[13:35:33.878]                   options(future.plan = NULL)
[13:35:33.878]                   if (is.na(NA_character_)) 
[13:35:33.878]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:33.878]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:33.878]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:33.878]                     .init = FALSE)
[13:35:33.878]                 }
[13:35:33.878]             }
[13:35:33.878]         }
[13:35:33.878]     })
[13:35:33.878]     if (TRUE) {
[13:35:33.878]         base::sink(type = "output", split = FALSE)
[13:35:33.878]         if (FALSE) {
[13:35:33.878]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:33.878]         }
[13:35:33.878]         else {
[13:35:33.878]             ...future.result["stdout"] <- base::list(NULL)
[13:35:33.878]         }
[13:35:33.878]         base::close(...future.stdout)
[13:35:33.878]         ...future.stdout <- NULL
[13:35:33.878]     }
[13:35:33.878]     ...future.result$conditions <- ...future.conditions
[13:35:33.878]     ...future.result$finished <- base::Sys.time()
[13:35:33.878]     ...future.result
[13:35:33.878] }
[13:35:33.931] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[13:35:33.931] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[13:35:33.932] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[13:35:33.932] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:35:33.933] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:35:33.933] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[13:35:33.933] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[13:35:33.933] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:35:33.934] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:35:33.934] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:35:33.934] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:35:33.934] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[13:35:33.935] MultisessionFuture started
[13:35:33.935] - Launch lazy future ... done
[13:35:33.936] run() for ‘MultisessionFuture’ ... done
[13:35:33.936] Created future:
[13:35:33.936] MultisessionFuture:
[13:35:33.936] Label: ‘future_lapply-2’
[13:35:33.936] Expression:
[13:35:33.936] {
[13:35:33.936]     do.call(function(...) {
[13:35:33.936]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:33.936]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:33.936]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:33.936]             on.exit(options(oopts), add = TRUE)
[13:35:33.936]         }
[13:35:33.936]         {
[13:35:33.936]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:33.936]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:33.936]                 ...future.FUN(...future.X_jj, ...)
[13:35:33.936]             })
[13:35:33.936]         }
[13:35:33.936]     }, args = future.call.arguments)
[13:35:33.936] }
[13:35:33.936] Lazy evaluation: FALSE
[13:35:33.936] Asynchronous evaluation: TRUE
[13:35:33.936] Local evaluation: TRUE
[13:35:33.936] Environment: R_GlobalEnv
[13:35:33.936] Capture standard output: FALSE
[13:35:33.936] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:33.936] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:33.936] Packages: <none>
[13:35:33.936] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:33.936] Resolved: FALSE
[13:35:33.936] Value: <not collected>
[13:35:33.936] Conditions captured: <none>
[13:35:33.936] Early signaling: FALSE
[13:35:33.936] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:33.936] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:33.948] Chunk #2 of 2 ... DONE
[13:35:33.948] Launching 2 futures (chunks) ... DONE
[13:35:33.948] Resolving 2 futures (chunks) ...
[13:35:33.948] resolve() on list ...
[13:35:33.948]  recursive: 0
[13:35:33.951]  length: 2
[13:35:33.951] 
[13:35:34.024] receiveMessageFromWorker() for ClusterFuture ...
[13:35:34.024] - Validating connection of MultisessionFuture
[13:35:34.024] - received message: FutureResult
[13:35:34.025] - Received FutureResult
[13:35:34.025] - Erased future from FutureRegistry
[13:35:34.025] result() for ClusterFuture ...
[13:35:34.025] - result already collected: FutureResult
[13:35:34.025] result() for ClusterFuture ... done
[13:35:34.025] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:34.025] Future #2
[13:35:34.025] result() for ClusterFuture ...
[13:35:34.025] - result already collected: FutureResult
[13:35:34.025] result() for ClusterFuture ... done
[13:35:34.026] result() for ClusterFuture ...
[13:35:34.026] - result already collected: FutureResult
[13:35:34.026] result() for ClusterFuture ... done
[13:35:34.026] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:35:34.026] - nx: 2
[13:35:34.026] - relay: TRUE
[13:35:34.026] - stdout: TRUE
[13:35:34.026] - signal: TRUE
[13:35:34.026] - resignal: FALSE
[13:35:34.026] - force: TRUE
[13:35:34.026] - relayed: [n=2] FALSE, FALSE
[13:35:34.027] - queued futures: [n=2] FALSE, FALSE
[13:35:34.027]  - until=1
[13:35:34.027]  - relaying element #1
[13:35:34.027] - relayed: [n=2] FALSE, FALSE
[13:35:34.027] - queued futures: [n=2] FALSE, TRUE
[13:35:34.027] signalConditionsASAP(NULL, pos=2) ... done
[13:35:34.027]  length: 1 (resolved future 2)
[13:35:34.393] receiveMessageFromWorker() for ClusterFuture ...
[13:35:34.393] - Validating connection of MultisessionFuture
[13:35:34.393] - received message: FutureResult
[13:35:34.393] - Received FutureResult
[13:35:34.393] - Erased future from FutureRegistry
[13:35:34.393] result() for ClusterFuture ...
[13:35:34.393] - result already collected: FutureResult
[13:35:34.394] result() for ClusterFuture ... done
[13:35:34.394] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:34.394] Future #1
[13:35:34.394] result() for ClusterFuture ...
[13:35:34.394] - result already collected: FutureResult
[13:35:34.394] result() for ClusterFuture ... done
[13:35:34.394] result() for ClusterFuture ...
[13:35:34.394] - result already collected: FutureResult
[13:35:34.394] result() for ClusterFuture ... done
[13:35:34.394] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:35:34.395] - nx: 2
[13:35:34.395] - relay: TRUE
[13:35:34.395] - stdout: TRUE
[13:35:34.395] - signal: TRUE
[13:35:34.395] - resignal: FALSE
[13:35:34.395] - force: TRUE
[13:35:34.395] - relayed: [n=2] FALSE, FALSE
[13:35:34.395] - queued futures: [n=2] FALSE, TRUE
[13:35:34.395]  - until=1
[13:35:34.395]  - relaying element #1
[13:35:34.395] result() for ClusterFuture ...
[13:35:34.395] - result already collected: FutureResult
[13:35:34.395] result() for ClusterFuture ... done
[13:35:34.396] result() for ClusterFuture ...
[13:35:34.396] - result already collected: FutureResult
[13:35:34.396] result() for ClusterFuture ... done
[13:35:34.396] result() for ClusterFuture ...
[13:35:34.396] - result already collected: FutureResult
[13:35:34.396] result() for ClusterFuture ... done
[13:35:34.396] result() for ClusterFuture ...
[13:35:34.396] - result already collected: FutureResult
[13:35:34.396] result() for ClusterFuture ... done
[13:35:34.396] - relayed: [n=2] TRUE, FALSE
[13:35:34.396] - queued futures: [n=2] TRUE, TRUE
[13:35:34.397] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:35:34.397]  length: 0 (resolved future 1)
[13:35:34.397] Relaying remaining futures
[13:35:34.397] signalConditionsASAP(NULL, pos=0) ...
[13:35:34.397] - nx: 2
[13:35:34.397] - relay: TRUE
[13:35:34.397] - stdout: TRUE
[13:35:34.397] - signal: TRUE
[13:35:34.397] - resignal: FALSE
[13:35:34.397] - force: TRUE
[13:35:34.397] - relayed: [n=2] TRUE, FALSE
[13:35:34.397] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:34.398]  - relaying element #2
[13:35:34.398] result() for ClusterFuture ...
[13:35:34.398] - result already collected: FutureResult
[13:35:34.398] result() for ClusterFuture ... done
[13:35:34.398] result() for ClusterFuture ...
[13:35:34.398] - result already collected: FutureResult
[13:35:34.398] result() for ClusterFuture ... done
[13:35:34.398] result() for ClusterFuture ...
[13:35:34.398] - result already collected: FutureResult
[13:35:34.398] result() for ClusterFuture ... done
[13:35:34.399] result() for ClusterFuture ...
[13:35:34.399] - result already collected: FutureResult
[13:35:34.399] result() for ClusterFuture ... done
[13:35:34.399] - relayed: [n=2] TRUE, TRUE
[13:35:34.399] - queued futures: [n=2] TRUE, TRUE
[13:35:34.399] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[13:35:34.399] resolve() on list ... DONE
[13:35:34.399] result() for ClusterFuture ...
[13:35:34.399] - result already collected: FutureResult
[13:35:34.399] result() for ClusterFuture ... done
[13:35:34.399] result() for ClusterFuture ...
[13:35:34.399] - result already collected: FutureResult
[13:35:34.400] result() for ClusterFuture ... done
[13:35:34.400] result() for ClusterFuture ...
[13:35:34.400] - result already collected: FutureResult
[13:35:34.400] result() for ClusterFuture ... done
[13:35:34.400] result() for ClusterFuture ...
[13:35:34.400] - result already collected: FutureResult
[13:35:34.400] result() for ClusterFuture ... done
[13:35:34.400]  - Number of value chunks collected: 2
[13:35:34.400] Resolving 2 futures (chunks) ... DONE
[13:35:34.400] Reducing values from 2 chunks ...
[13:35:34.400]  - Number of values collected after concatenation: 2
[13:35:34.400]  - Number of values expected: 2
[13:35:34.401] Reducing values from 2 chunks ... DONE
[13:35:34.401] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[13:35:34.401] future_lapply() ...
[13:35:34.405] Number of chunks: 2
[13:35:34.406] getGlobalsAndPackagesXApply() ...
[13:35:34.406]  - future.globals: TRUE
[13:35:34.406] getGlobalsAndPackages() ...
[13:35:34.406] Searching for globals...
[13:35:34.407] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:35:34.407] Searching for globals ... DONE
[13:35:34.408] Resolving globals: FALSE
[13:35:34.408] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:35:34.408] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:35:34.408] - globals: [1] ‘FUN’
[13:35:34.409] 
[13:35:34.409] getGlobalsAndPackages() ... DONE
[13:35:34.409]  - globals found/used: [n=1] ‘FUN’
[13:35:34.409]  - needed namespaces: [n=0] 
[13:35:34.409] Finding globals ... DONE
[13:35:34.409]  - use_args: TRUE
[13:35:34.409]  - Getting '...' globals ...
[13:35:34.409] resolve() on list ...
[13:35:34.409]  recursive: 0
[13:35:34.410]  length: 1
[13:35:34.410]  elements: ‘...’
[13:35:34.410]  length: 0 (resolved future 1)
[13:35:34.410] resolve() on list ... DONE
[13:35:34.410]    - '...' content: [n=0] 
[13:35:34.410] List of 1
[13:35:34.410]  $ ...: list()
[13:35:34.410]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:34.410]  - attr(*, "where")=List of 1
[13:35:34.410]   ..$ ...:<environment: 0x558d37c330b0> 
[13:35:34.410]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:34.410]  - attr(*, "resolved")= logi TRUE
[13:35:34.410]  - attr(*, "total_size")= num NA
[13:35:34.413]  - Getting '...' globals ... DONE
[13:35:34.413] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:35:34.413] List of 2
[13:35:34.413]  $ ...future.FUN:function (x)  
[13:35:34.413]  $ ...          : list()
[13:35:34.413]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:34.413]  - attr(*, "where")=List of 2
[13:35:34.413]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:34.413]   ..$ ...          :<environment: 0x558d37c330b0> 
[13:35:34.413]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:34.413]  - attr(*, "resolved")= logi FALSE
[13:35:34.413]  - attr(*, "total_size")= num 4720
[13:35:34.416] Packages to be attached in all futures: [n=0] 
[13:35:34.416] getGlobalsAndPackagesXApply() ... DONE
[13:35:34.416] Number of futures (= number of chunks): 2
[13:35:34.416] Launching 2 futures (chunks) ...
[13:35:34.416] Chunk #1 of 2 ...
[13:35:34.416]  - Finding globals in 'X' for chunk #1 ...
[13:35:34.416] getGlobalsAndPackages() ...
[13:35:34.416] Searching for globals...
[13:35:34.417] 
[13:35:34.417] Searching for globals ... DONE
[13:35:34.417] - globals: [0] <none>
[13:35:34.417] getGlobalsAndPackages() ... DONE
[13:35:34.417]    + additional globals found: [n=0] 
[13:35:34.417]    + additional namespaces needed: [n=0] 
[13:35:34.417]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:34.417]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:34.417]  - seeds: <none>
[13:35:34.417]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:34.417] getGlobalsAndPackages() ...
[13:35:34.418] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:34.418] Resolving globals: FALSE
[13:35:34.418] Tweak future expression to call with '...' arguments ...
[13:35:34.418] {
[13:35:34.418]     do.call(function(...) {
[13:35:34.418]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:34.418]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:34.418]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:34.418]             on.exit(options(oopts), add = TRUE)
[13:35:34.418]         }
[13:35:34.418]         {
[13:35:34.418]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:34.418]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:34.418]                 ...future.FUN(...future.X_jj, ...)
[13:35:34.418]             })
[13:35:34.418]         }
[13:35:34.418]     }, args = future.call.arguments)
[13:35:34.418] }
[13:35:34.418] Tweak future expression to call with '...' arguments ... DONE
[13:35:34.419] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:34.419] 
[13:35:34.419] getGlobalsAndPackages() ... DONE
[13:35:34.419] run() for ‘Future’ ...
[13:35:34.419] - state: ‘created’
[13:35:34.419] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:34.433] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:34.433] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:34.433]   - Field: ‘node’
[13:35:34.433]   - Field: ‘label’
[13:35:34.433]   - Field: ‘local’
[13:35:34.433]   - Field: ‘owner’
[13:35:34.433]   - Field: ‘envir’
[13:35:34.434]   - Field: ‘workers’
[13:35:34.434]   - Field: ‘packages’
[13:35:34.434]   - Field: ‘gc’
[13:35:34.434]   - Field: ‘conditions’
[13:35:34.434]   - Field: ‘persistent’
[13:35:34.434]   - Field: ‘expr’
[13:35:34.434]   - Field: ‘uuid’
[13:35:34.434]   - Field: ‘seed’
[13:35:34.434]   - Field: ‘version’
[13:35:34.434]   - Field: ‘result’
[13:35:34.434]   - Field: ‘asynchronous’
[13:35:34.435]   - Field: ‘calls’
[13:35:34.435]   - Field: ‘globals’
[13:35:34.435]   - Field: ‘stdout’
[13:35:34.435]   - Field: ‘earlySignal’
[13:35:34.435]   - Field: ‘lazy’
[13:35:34.435]   - Field: ‘state’
[13:35:34.435] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:34.435] - Launch lazy future ...
[13:35:34.435] Packages needed by the future expression (n = 0): <none>
[13:35:34.436] Packages needed by future strategies (n = 0): <none>
[13:35:34.436] {
[13:35:34.436]     {
[13:35:34.436]         {
[13:35:34.436]             ...future.startTime <- base::Sys.time()
[13:35:34.436]             {
[13:35:34.436]                 {
[13:35:34.436]                   {
[13:35:34.436]                     {
[13:35:34.436]                       base::local({
[13:35:34.436]                         has_future <- base::requireNamespace("future", 
[13:35:34.436]                           quietly = TRUE)
[13:35:34.436]                         if (has_future) {
[13:35:34.436]                           ns <- base::getNamespace("future")
[13:35:34.436]                           version <- ns[[".package"]][["version"]]
[13:35:34.436]                           if (is.null(version)) 
[13:35:34.436]                             version <- utils::packageVersion("future")
[13:35:34.436]                         }
[13:35:34.436]                         else {
[13:35:34.436]                           version <- NULL
[13:35:34.436]                         }
[13:35:34.436]                         if (!has_future || version < "1.8.0") {
[13:35:34.436]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:34.436]                             "", base::R.version$version.string), 
[13:35:34.436]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:34.436]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:34.436]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:34.436]                               "release", "version")], collapse = " "), 
[13:35:34.436]                             hostname = base::Sys.info()[["nodename"]])
[13:35:34.436]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:34.436]                             info)
[13:35:34.436]                           info <- base::paste(info, collapse = "; ")
[13:35:34.436]                           if (!has_future) {
[13:35:34.436]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:34.436]                               info)
[13:35:34.436]                           }
[13:35:34.436]                           else {
[13:35:34.436]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:34.436]                               info, version)
[13:35:34.436]                           }
[13:35:34.436]                           base::stop(msg)
[13:35:34.436]                         }
[13:35:34.436]                       })
[13:35:34.436]                     }
[13:35:34.436]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:34.436]                     base::options(mc.cores = 1L)
[13:35:34.436]                   }
[13:35:34.436]                   ...future.strategy.old <- future::plan("list")
[13:35:34.436]                   options(future.plan = NULL)
[13:35:34.436]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:34.436]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:34.436]                 }
[13:35:34.436]                 ...future.workdir <- getwd()
[13:35:34.436]             }
[13:35:34.436]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:34.436]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:34.436]         }
[13:35:34.436]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:34.436]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:34.436]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:34.436]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:34.436]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:34.436]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:34.436]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:34.436]             base::names(...future.oldOptions))
[13:35:34.436]     }
[13:35:34.436]     if (FALSE) {
[13:35:34.436]     }
[13:35:34.436]     else {
[13:35:34.436]         if (TRUE) {
[13:35:34.436]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:34.436]                 open = "w")
[13:35:34.436]         }
[13:35:34.436]         else {
[13:35:34.436]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:34.436]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:34.436]         }
[13:35:34.436]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:34.436]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:34.436]             base::sink(type = "output", split = FALSE)
[13:35:34.436]             base::close(...future.stdout)
[13:35:34.436]         }, add = TRUE)
[13:35:34.436]     }
[13:35:34.436]     ...future.frame <- base::sys.nframe()
[13:35:34.436]     ...future.conditions <- base::list()
[13:35:34.436]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:34.436]     if (FALSE) {
[13:35:34.436]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:34.436]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:34.436]     }
[13:35:34.436]     ...future.result <- base::tryCatch({
[13:35:34.436]         base::withCallingHandlers({
[13:35:34.436]             ...future.value <- base::withVisible(base::local({
[13:35:34.436]                 ...future.makeSendCondition <- base::local({
[13:35:34.436]                   sendCondition <- NULL
[13:35:34.436]                   function(frame = 1L) {
[13:35:34.436]                     if (is.function(sendCondition)) 
[13:35:34.436]                       return(sendCondition)
[13:35:34.436]                     ns <- getNamespace("parallel")
[13:35:34.436]                     if (exists("sendData", mode = "function", 
[13:35:34.436]                       envir = ns)) {
[13:35:34.436]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:34.436]                         envir = ns)
[13:35:34.436]                       envir <- sys.frame(frame)
[13:35:34.436]                       master <- NULL
[13:35:34.436]                       while (!identical(envir, .GlobalEnv) && 
[13:35:34.436]                         !identical(envir, emptyenv())) {
[13:35:34.436]                         if (exists("master", mode = "list", envir = envir, 
[13:35:34.436]                           inherits = FALSE)) {
[13:35:34.436]                           master <- get("master", mode = "list", 
[13:35:34.436]                             envir = envir, inherits = FALSE)
[13:35:34.436]                           if (inherits(master, c("SOCKnode", 
[13:35:34.436]                             "SOCK0node"))) {
[13:35:34.436]                             sendCondition <<- function(cond) {
[13:35:34.436]                               data <- list(type = "VALUE", value = cond, 
[13:35:34.436]                                 success = TRUE)
[13:35:34.436]                               parallel_sendData(master, data)
[13:35:34.436]                             }
[13:35:34.436]                             return(sendCondition)
[13:35:34.436]                           }
[13:35:34.436]                         }
[13:35:34.436]                         frame <- frame + 1L
[13:35:34.436]                         envir <- sys.frame(frame)
[13:35:34.436]                       }
[13:35:34.436]                     }
[13:35:34.436]                     sendCondition <<- function(cond) NULL
[13:35:34.436]                   }
[13:35:34.436]                 })
[13:35:34.436]                 withCallingHandlers({
[13:35:34.436]                   {
[13:35:34.436]                     do.call(function(...) {
[13:35:34.436]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:34.436]                       if (!identical(...future.globals.maxSize.org, 
[13:35:34.436]                         ...future.globals.maxSize)) {
[13:35:34.436]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:34.436]                         on.exit(options(oopts), add = TRUE)
[13:35:34.436]                       }
[13:35:34.436]                       {
[13:35:34.436]                         lapply(seq_along(...future.elements_ii), 
[13:35:34.436]                           FUN = function(jj) {
[13:35:34.436]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:34.436]                             ...future.FUN(...future.X_jj, ...)
[13:35:34.436]                           })
[13:35:34.436]                       }
[13:35:34.436]                     }, args = future.call.arguments)
[13:35:34.436]                   }
[13:35:34.436]                 }, immediateCondition = function(cond) {
[13:35:34.436]                   sendCondition <- ...future.makeSendCondition()
[13:35:34.436]                   sendCondition(cond)
[13:35:34.436]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:34.436]                   {
[13:35:34.436]                     inherits <- base::inherits
[13:35:34.436]                     invokeRestart <- base::invokeRestart
[13:35:34.436]                     is.null <- base::is.null
[13:35:34.436]                     muffled <- FALSE
[13:35:34.436]                     if (inherits(cond, "message")) {
[13:35:34.436]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:34.436]                       if (muffled) 
[13:35:34.436]                         invokeRestart("muffleMessage")
[13:35:34.436]                     }
[13:35:34.436]                     else if (inherits(cond, "warning")) {
[13:35:34.436]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:34.436]                       if (muffled) 
[13:35:34.436]                         invokeRestart("muffleWarning")
[13:35:34.436]                     }
[13:35:34.436]                     else if (inherits(cond, "condition")) {
[13:35:34.436]                       if (!is.null(pattern)) {
[13:35:34.436]                         computeRestarts <- base::computeRestarts
[13:35:34.436]                         grepl <- base::grepl
[13:35:34.436]                         restarts <- computeRestarts(cond)
[13:35:34.436]                         for (restart in restarts) {
[13:35:34.436]                           name <- restart$name
[13:35:34.436]                           if (is.null(name)) 
[13:35:34.436]                             next
[13:35:34.436]                           if (!grepl(pattern, name)) 
[13:35:34.436]                             next
[13:35:34.436]                           invokeRestart(restart)
[13:35:34.436]                           muffled <- TRUE
[13:35:34.436]                           break
[13:35:34.436]                         }
[13:35:34.436]                       }
[13:35:34.436]                     }
[13:35:34.436]                     invisible(muffled)
[13:35:34.436]                   }
[13:35:34.436]                   muffleCondition(cond)
[13:35:34.436]                 })
[13:35:34.436]             }))
[13:35:34.436]             future::FutureResult(value = ...future.value$value, 
[13:35:34.436]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:34.436]                   ...future.rng), globalenv = if (FALSE) 
[13:35:34.436]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:34.436]                     ...future.globalenv.names))
[13:35:34.436]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:34.436]         }, condition = base::local({
[13:35:34.436]             c <- base::c
[13:35:34.436]             inherits <- base::inherits
[13:35:34.436]             invokeRestart <- base::invokeRestart
[13:35:34.436]             length <- base::length
[13:35:34.436]             list <- base::list
[13:35:34.436]             seq.int <- base::seq.int
[13:35:34.436]             signalCondition <- base::signalCondition
[13:35:34.436]             sys.calls <- base::sys.calls
[13:35:34.436]             `[[` <- base::`[[`
[13:35:34.436]             `+` <- base::`+`
[13:35:34.436]             `<<-` <- base::`<<-`
[13:35:34.436]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:34.436]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:34.436]                   3L)]
[13:35:34.436]             }
[13:35:34.436]             function(cond) {
[13:35:34.436]                 is_error <- inherits(cond, "error")
[13:35:34.436]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:34.436]                   NULL)
[13:35:34.436]                 if (is_error) {
[13:35:34.436]                   sessionInformation <- function() {
[13:35:34.436]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:34.436]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:34.436]                       search = base::search(), system = base::Sys.info())
[13:35:34.436]                   }
[13:35:34.436]                   ...future.conditions[[length(...future.conditions) + 
[13:35:34.436]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:34.436]                     cond$call), session = sessionInformation(), 
[13:35:34.436]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:34.436]                   signalCondition(cond)
[13:35:34.436]                 }
[13:35:34.436]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:34.436]                 "immediateCondition"))) {
[13:35:34.436]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:34.436]                   ...future.conditions[[length(...future.conditions) + 
[13:35:34.436]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:34.436]                   if (TRUE && !signal) {
[13:35:34.436]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:34.436]                     {
[13:35:34.436]                       inherits <- base::inherits
[13:35:34.436]                       invokeRestart <- base::invokeRestart
[13:35:34.436]                       is.null <- base::is.null
[13:35:34.436]                       muffled <- FALSE
[13:35:34.436]                       if (inherits(cond, "message")) {
[13:35:34.436]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:34.436]                         if (muffled) 
[13:35:34.436]                           invokeRestart("muffleMessage")
[13:35:34.436]                       }
[13:35:34.436]                       else if (inherits(cond, "warning")) {
[13:35:34.436]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:34.436]                         if (muffled) 
[13:35:34.436]                           invokeRestart("muffleWarning")
[13:35:34.436]                       }
[13:35:34.436]                       else if (inherits(cond, "condition")) {
[13:35:34.436]                         if (!is.null(pattern)) {
[13:35:34.436]                           computeRestarts <- base::computeRestarts
[13:35:34.436]                           grepl <- base::grepl
[13:35:34.436]                           restarts <- computeRestarts(cond)
[13:35:34.436]                           for (restart in restarts) {
[13:35:34.436]                             name <- restart$name
[13:35:34.436]                             if (is.null(name)) 
[13:35:34.436]                               next
[13:35:34.436]                             if (!grepl(pattern, name)) 
[13:35:34.436]                               next
[13:35:34.436]                             invokeRestart(restart)
[13:35:34.436]                             muffled <- TRUE
[13:35:34.436]                             break
[13:35:34.436]                           }
[13:35:34.436]                         }
[13:35:34.436]                       }
[13:35:34.436]                       invisible(muffled)
[13:35:34.436]                     }
[13:35:34.436]                     muffleCondition(cond, pattern = "^muffle")
[13:35:34.436]                   }
[13:35:34.436]                 }
[13:35:34.436]                 else {
[13:35:34.436]                   if (TRUE) {
[13:35:34.436]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:34.436]                     {
[13:35:34.436]                       inherits <- base::inherits
[13:35:34.436]                       invokeRestart <- base::invokeRestart
[13:35:34.436]                       is.null <- base::is.null
[13:35:34.436]                       muffled <- FALSE
[13:35:34.436]                       if (inherits(cond, "message")) {
[13:35:34.436]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:34.436]                         if (muffled) 
[13:35:34.436]                           invokeRestart("muffleMessage")
[13:35:34.436]                       }
[13:35:34.436]                       else if (inherits(cond, "warning")) {
[13:35:34.436]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:34.436]                         if (muffled) 
[13:35:34.436]                           invokeRestart("muffleWarning")
[13:35:34.436]                       }
[13:35:34.436]                       else if (inherits(cond, "condition")) {
[13:35:34.436]                         if (!is.null(pattern)) {
[13:35:34.436]                           computeRestarts <- base::computeRestarts
[13:35:34.436]                           grepl <- base::grepl
[13:35:34.436]                           restarts <- computeRestarts(cond)
[13:35:34.436]                           for (restart in restarts) {
[13:35:34.436]                             name <- restart$name
[13:35:34.436]                             if (is.null(name)) 
[13:35:34.436]                               next
[13:35:34.436]                             if (!grepl(pattern, name)) 
[13:35:34.436]                               next
[13:35:34.436]                             invokeRestart(restart)
[13:35:34.436]                             muffled <- TRUE
[13:35:34.436]                             break
[13:35:34.436]                           }
[13:35:34.436]                         }
[13:35:34.436]                       }
[13:35:34.436]                       invisible(muffled)
[13:35:34.436]                     }
[13:35:34.436]                     muffleCondition(cond, pattern = "^muffle")
[13:35:34.436]                   }
[13:35:34.436]                 }
[13:35:34.436]             }
[13:35:34.436]         }))
[13:35:34.436]     }, error = function(ex) {
[13:35:34.436]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:34.436]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:34.436]                 ...future.rng), started = ...future.startTime, 
[13:35:34.436]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:34.436]             version = "1.8"), class = "FutureResult")
[13:35:34.436]     }, finally = {
[13:35:34.436]         if (!identical(...future.workdir, getwd())) 
[13:35:34.436]             setwd(...future.workdir)
[13:35:34.436]         {
[13:35:34.436]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:34.436]                 ...future.oldOptions$nwarnings <- NULL
[13:35:34.436]             }
[13:35:34.436]             base::options(...future.oldOptions)
[13:35:34.436]             if (.Platform$OS.type == "windows") {
[13:35:34.436]                 old_names <- names(...future.oldEnvVars)
[13:35:34.436]                 envs <- base::Sys.getenv()
[13:35:34.436]                 names <- names(envs)
[13:35:34.436]                 common <- intersect(names, old_names)
[13:35:34.436]                 added <- setdiff(names, old_names)
[13:35:34.436]                 removed <- setdiff(old_names, names)
[13:35:34.436]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:34.436]                   envs[common]]
[13:35:34.436]                 NAMES <- toupper(changed)
[13:35:34.436]                 args <- list()
[13:35:34.436]                 for (kk in seq_along(NAMES)) {
[13:35:34.436]                   name <- changed[[kk]]
[13:35:34.436]                   NAME <- NAMES[[kk]]
[13:35:34.436]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:34.436]                     next
[13:35:34.436]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:34.436]                 }
[13:35:34.436]                 NAMES <- toupper(added)
[13:35:34.436]                 for (kk in seq_along(NAMES)) {
[13:35:34.436]                   name <- added[[kk]]
[13:35:34.436]                   NAME <- NAMES[[kk]]
[13:35:34.436]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:34.436]                     next
[13:35:34.436]                   args[[name]] <- ""
[13:35:34.436]                 }
[13:35:34.436]                 NAMES <- toupper(removed)
[13:35:34.436]                 for (kk in seq_along(NAMES)) {
[13:35:34.436]                   name <- removed[[kk]]
[13:35:34.436]                   NAME <- NAMES[[kk]]
[13:35:34.436]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:34.436]                     next
[13:35:34.436]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:34.436]                 }
[13:35:34.436]                 if (length(args) > 0) 
[13:35:34.436]                   base::do.call(base::Sys.setenv, args = args)
[13:35:34.436]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:34.436]             }
[13:35:34.436]             else {
[13:35:34.436]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:34.436]             }
[13:35:34.436]             {
[13:35:34.436]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:34.436]                   0L) {
[13:35:34.436]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:34.436]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:34.436]                   base::options(opts)
[13:35:34.436]                 }
[13:35:34.436]                 {
[13:35:34.436]                   {
[13:35:34.436]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:34.436]                     NULL
[13:35:34.436]                   }
[13:35:34.436]                   options(future.plan = NULL)
[13:35:34.436]                   if (is.na(NA_character_)) 
[13:35:34.436]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:34.436]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:34.436]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:34.436]                     .init = FALSE)
[13:35:34.436]                 }
[13:35:34.436]             }
[13:35:34.436]         }
[13:35:34.436]     })
[13:35:34.436]     if (TRUE) {
[13:35:34.436]         base::sink(type = "output", split = FALSE)
[13:35:34.436]         if (TRUE) {
[13:35:34.436]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:34.436]         }
[13:35:34.436]         else {
[13:35:34.436]             ...future.result["stdout"] <- base::list(NULL)
[13:35:34.436]         }
[13:35:34.436]         base::close(...future.stdout)
[13:35:34.436]         ...future.stdout <- NULL
[13:35:34.436]     }
[13:35:34.436]     ...future.result$conditions <- ...future.conditions
[13:35:34.436]     ...future.result$finished <- base::Sys.time()
[13:35:34.436]     ...future.result
[13:35:34.436] }
[13:35:34.439] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[13:35:34.439] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[13:35:34.439] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[13:35:34.440] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:35:34.440] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:35:34.440] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:35:34.440] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:35:34.441] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:34.441] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:34.441] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:34.441] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:34.441] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[13:35:34.442] MultisessionFuture started
[13:35:34.442] - Launch lazy future ... done
[13:35:34.442] run() for ‘MultisessionFuture’ ... done
[13:35:34.442] Created future:
[13:35:34.442] MultisessionFuture:
[13:35:34.442] Label: ‘future_lapply-1’
[13:35:34.442] Expression:
[13:35:34.442] {
[13:35:34.442]     do.call(function(...) {
[13:35:34.442]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:34.442]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:34.442]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:34.442]             on.exit(options(oopts), add = TRUE)
[13:35:34.442]         }
[13:35:34.442]         {
[13:35:34.442]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:34.442]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:34.442]                 ...future.FUN(...future.X_jj, ...)
[13:35:34.442]             })
[13:35:34.442]         }
[13:35:34.442]     }, args = future.call.arguments)
[13:35:34.442] }
[13:35:34.442] Lazy evaluation: FALSE
[13:35:34.442] Asynchronous evaluation: TRUE
[13:35:34.442] Local evaluation: TRUE
[13:35:34.442] Environment: R_GlobalEnv
[13:35:34.442] Capture standard output: TRUE
[13:35:34.442] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:34.442] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:34.442] Packages: <none>
[13:35:34.442] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:34.442] Resolved: FALSE
[13:35:34.442] Value: <not collected>
[13:35:34.442] Conditions captured: <none>
[13:35:34.442] Early signaling: FALSE
[13:35:34.442] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:34.442] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:34.454] Chunk #1 of 2 ... DONE
[13:35:34.454] Chunk #2 of 2 ...
[13:35:34.454]  - Finding globals in 'X' for chunk #2 ...
[13:35:34.454] getGlobalsAndPackages() ...
[13:35:34.454] Searching for globals...
[13:35:34.455] 
[13:35:34.455] Searching for globals ... DONE
[13:35:34.455] - globals: [0] <none>
[13:35:34.455] getGlobalsAndPackages() ... DONE
[13:35:34.455]    + additional globals found: [n=0] 
[13:35:34.455]    + additional namespaces needed: [n=0] 
[13:35:34.455]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:34.455]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:34.455]  - seeds: <none>
[13:35:34.455]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:34.456] getGlobalsAndPackages() ...
[13:35:34.456] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:34.456] Resolving globals: FALSE
[13:35:34.456] Tweak future expression to call with '...' arguments ...
[13:35:34.456] {
[13:35:34.456]     do.call(function(...) {
[13:35:34.456]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:34.456]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:34.456]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:34.456]             on.exit(options(oopts), add = TRUE)
[13:35:34.456]         }
[13:35:34.456]         {
[13:35:34.456]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:34.456]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:34.456]                 ...future.FUN(...future.X_jj, ...)
[13:35:34.456]             })
[13:35:34.456]         }
[13:35:34.456]     }, args = future.call.arguments)
[13:35:34.456] }
[13:35:34.456] Tweak future expression to call with '...' arguments ... DONE
[13:35:34.457] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:34.457] 
[13:35:34.457] getGlobalsAndPackages() ... DONE
[13:35:34.457] run() for ‘Future’ ...
[13:35:34.457] - state: ‘created’
[13:35:34.457] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:34.470] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:34.471] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:34.471]   - Field: ‘node’
[13:35:34.471]   - Field: ‘label’
[13:35:34.471]   - Field: ‘local’
[13:35:34.471]   - Field: ‘owner’
[13:35:34.471]   - Field: ‘envir’
[13:35:34.471]   - Field: ‘workers’
[13:35:34.471]   - Field: ‘packages’
[13:35:34.471]   - Field: ‘gc’
[13:35:34.471]   - Field: ‘conditions’
[13:35:34.472]   - Field: ‘persistent’
[13:35:34.472]   - Field: ‘expr’
[13:35:34.472]   - Field: ‘uuid’
[13:35:34.472]   - Field: ‘seed’
[13:35:34.472]   - Field: ‘version’
[13:35:34.472]   - Field: ‘result’
[13:35:34.472]   - Field: ‘asynchronous’
[13:35:34.472]   - Field: ‘calls’
[13:35:34.472]   - Field: ‘globals’
[13:35:34.472]   - Field: ‘stdout’
[13:35:34.472]   - Field: ‘earlySignal’
[13:35:34.472]   - Field: ‘lazy’
[13:35:34.473]   - Field: ‘state’
[13:35:34.473] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:34.473] - Launch lazy future ...
[13:35:34.473] Packages needed by the future expression (n = 0): <none>
[13:35:34.473] Packages needed by future strategies (n = 0): <none>
[13:35:34.474] {
[13:35:34.474]     {
[13:35:34.474]         {
[13:35:34.474]             ...future.startTime <- base::Sys.time()
[13:35:34.474]             {
[13:35:34.474]                 {
[13:35:34.474]                   {
[13:35:34.474]                     {
[13:35:34.474]                       base::local({
[13:35:34.474]                         has_future <- base::requireNamespace("future", 
[13:35:34.474]                           quietly = TRUE)
[13:35:34.474]                         if (has_future) {
[13:35:34.474]                           ns <- base::getNamespace("future")
[13:35:34.474]                           version <- ns[[".package"]][["version"]]
[13:35:34.474]                           if (is.null(version)) 
[13:35:34.474]                             version <- utils::packageVersion("future")
[13:35:34.474]                         }
[13:35:34.474]                         else {
[13:35:34.474]                           version <- NULL
[13:35:34.474]                         }
[13:35:34.474]                         if (!has_future || version < "1.8.0") {
[13:35:34.474]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:34.474]                             "", base::R.version$version.string), 
[13:35:34.474]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:34.474]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:34.474]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:34.474]                               "release", "version")], collapse = " "), 
[13:35:34.474]                             hostname = base::Sys.info()[["nodename"]])
[13:35:34.474]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:34.474]                             info)
[13:35:34.474]                           info <- base::paste(info, collapse = "; ")
[13:35:34.474]                           if (!has_future) {
[13:35:34.474]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:34.474]                               info)
[13:35:34.474]                           }
[13:35:34.474]                           else {
[13:35:34.474]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:34.474]                               info, version)
[13:35:34.474]                           }
[13:35:34.474]                           base::stop(msg)
[13:35:34.474]                         }
[13:35:34.474]                       })
[13:35:34.474]                     }
[13:35:34.474]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:34.474]                     base::options(mc.cores = 1L)
[13:35:34.474]                   }
[13:35:34.474]                   ...future.strategy.old <- future::plan("list")
[13:35:34.474]                   options(future.plan = NULL)
[13:35:34.474]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:34.474]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:34.474]                 }
[13:35:34.474]                 ...future.workdir <- getwd()
[13:35:34.474]             }
[13:35:34.474]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:34.474]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:34.474]         }
[13:35:34.474]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:34.474]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:34.474]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:34.474]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:34.474]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:34.474]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:34.474]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:34.474]             base::names(...future.oldOptions))
[13:35:34.474]     }
[13:35:34.474]     if (FALSE) {
[13:35:34.474]     }
[13:35:34.474]     else {
[13:35:34.474]         if (TRUE) {
[13:35:34.474]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:34.474]                 open = "w")
[13:35:34.474]         }
[13:35:34.474]         else {
[13:35:34.474]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:34.474]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:34.474]         }
[13:35:34.474]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:34.474]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:34.474]             base::sink(type = "output", split = FALSE)
[13:35:34.474]             base::close(...future.stdout)
[13:35:34.474]         }, add = TRUE)
[13:35:34.474]     }
[13:35:34.474]     ...future.frame <- base::sys.nframe()
[13:35:34.474]     ...future.conditions <- base::list()
[13:35:34.474]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:34.474]     if (FALSE) {
[13:35:34.474]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:34.474]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:34.474]     }
[13:35:34.474]     ...future.result <- base::tryCatch({
[13:35:34.474]         base::withCallingHandlers({
[13:35:34.474]             ...future.value <- base::withVisible(base::local({
[13:35:34.474]                 ...future.makeSendCondition <- base::local({
[13:35:34.474]                   sendCondition <- NULL
[13:35:34.474]                   function(frame = 1L) {
[13:35:34.474]                     if (is.function(sendCondition)) 
[13:35:34.474]                       return(sendCondition)
[13:35:34.474]                     ns <- getNamespace("parallel")
[13:35:34.474]                     if (exists("sendData", mode = "function", 
[13:35:34.474]                       envir = ns)) {
[13:35:34.474]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:34.474]                         envir = ns)
[13:35:34.474]                       envir <- sys.frame(frame)
[13:35:34.474]                       master <- NULL
[13:35:34.474]                       while (!identical(envir, .GlobalEnv) && 
[13:35:34.474]                         !identical(envir, emptyenv())) {
[13:35:34.474]                         if (exists("master", mode = "list", envir = envir, 
[13:35:34.474]                           inherits = FALSE)) {
[13:35:34.474]                           master <- get("master", mode = "list", 
[13:35:34.474]                             envir = envir, inherits = FALSE)
[13:35:34.474]                           if (inherits(master, c("SOCKnode", 
[13:35:34.474]                             "SOCK0node"))) {
[13:35:34.474]                             sendCondition <<- function(cond) {
[13:35:34.474]                               data <- list(type = "VALUE", value = cond, 
[13:35:34.474]                                 success = TRUE)
[13:35:34.474]                               parallel_sendData(master, data)
[13:35:34.474]                             }
[13:35:34.474]                             return(sendCondition)
[13:35:34.474]                           }
[13:35:34.474]                         }
[13:35:34.474]                         frame <- frame + 1L
[13:35:34.474]                         envir <- sys.frame(frame)
[13:35:34.474]                       }
[13:35:34.474]                     }
[13:35:34.474]                     sendCondition <<- function(cond) NULL
[13:35:34.474]                   }
[13:35:34.474]                 })
[13:35:34.474]                 withCallingHandlers({
[13:35:34.474]                   {
[13:35:34.474]                     do.call(function(...) {
[13:35:34.474]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:34.474]                       if (!identical(...future.globals.maxSize.org, 
[13:35:34.474]                         ...future.globals.maxSize)) {
[13:35:34.474]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:34.474]                         on.exit(options(oopts), add = TRUE)
[13:35:34.474]                       }
[13:35:34.474]                       {
[13:35:34.474]                         lapply(seq_along(...future.elements_ii), 
[13:35:34.474]                           FUN = function(jj) {
[13:35:34.474]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:34.474]                             ...future.FUN(...future.X_jj, ...)
[13:35:34.474]                           })
[13:35:34.474]                       }
[13:35:34.474]                     }, args = future.call.arguments)
[13:35:34.474]                   }
[13:35:34.474]                 }, immediateCondition = function(cond) {
[13:35:34.474]                   sendCondition <- ...future.makeSendCondition()
[13:35:34.474]                   sendCondition(cond)
[13:35:34.474]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:34.474]                   {
[13:35:34.474]                     inherits <- base::inherits
[13:35:34.474]                     invokeRestart <- base::invokeRestart
[13:35:34.474]                     is.null <- base::is.null
[13:35:34.474]                     muffled <- FALSE
[13:35:34.474]                     if (inherits(cond, "message")) {
[13:35:34.474]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:34.474]                       if (muffled) 
[13:35:34.474]                         invokeRestart("muffleMessage")
[13:35:34.474]                     }
[13:35:34.474]                     else if (inherits(cond, "warning")) {
[13:35:34.474]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:34.474]                       if (muffled) 
[13:35:34.474]                         invokeRestart("muffleWarning")
[13:35:34.474]                     }
[13:35:34.474]                     else if (inherits(cond, "condition")) {
[13:35:34.474]                       if (!is.null(pattern)) {
[13:35:34.474]                         computeRestarts <- base::computeRestarts
[13:35:34.474]                         grepl <- base::grepl
[13:35:34.474]                         restarts <- computeRestarts(cond)
[13:35:34.474]                         for (restart in restarts) {
[13:35:34.474]                           name <- restart$name
[13:35:34.474]                           if (is.null(name)) 
[13:35:34.474]                             next
[13:35:34.474]                           if (!grepl(pattern, name)) 
[13:35:34.474]                             next
[13:35:34.474]                           invokeRestart(restart)
[13:35:34.474]                           muffled <- TRUE
[13:35:34.474]                           break
[13:35:34.474]                         }
[13:35:34.474]                       }
[13:35:34.474]                     }
[13:35:34.474]                     invisible(muffled)
[13:35:34.474]                   }
[13:35:34.474]                   muffleCondition(cond)
[13:35:34.474]                 })
[13:35:34.474]             }))
[13:35:34.474]             future::FutureResult(value = ...future.value$value, 
[13:35:34.474]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:34.474]                   ...future.rng), globalenv = if (FALSE) 
[13:35:34.474]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:34.474]                     ...future.globalenv.names))
[13:35:34.474]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:34.474]         }, condition = base::local({
[13:35:34.474]             c <- base::c
[13:35:34.474]             inherits <- base::inherits
[13:35:34.474]             invokeRestart <- base::invokeRestart
[13:35:34.474]             length <- base::length
[13:35:34.474]             list <- base::list
[13:35:34.474]             seq.int <- base::seq.int
[13:35:34.474]             signalCondition <- base::signalCondition
[13:35:34.474]             sys.calls <- base::sys.calls
[13:35:34.474]             `[[` <- base::`[[`
[13:35:34.474]             `+` <- base::`+`
[13:35:34.474]             `<<-` <- base::`<<-`
[13:35:34.474]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:34.474]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:34.474]                   3L)]
[13:35:34.474]             }
[13:35:34.474]             function(cond) {
[13:35:34.474]                 is_error <- inherits(cond, "error")
[13:35:34.474]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:34.474]                   NULL)
[13:35:34.474]                 if (is_error) {
[13:35:34.474]                   sessionInformation <- function() {
[13:35:34.474]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:34.474]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:34.474]                       search = base::search(), system = base::Sys.info())
[13:35:34.474]                   }
[13:35:34.474]                   ...future.conditions[[length(...future.conditions) + 
[13:35:34.474]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:34.474]                     cond$call), session = sessionInformation(), 
[13:35:34.474]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:34.474]                   signalCondition(cond)
[13:35:34.474]                 }
[13:35:34.474]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:34.474]                 "immediateCondition"))) {
[13:35:34.474]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:34.474]                   ...future.conditions[[length(...future.conditions) + 
[13:35:34.474]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:34.474]                   if (TRUE && !signal) {
[13:35:34.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:34.474]                     {
[13:35:34.474]                       inherits <- base::inherits
[13:35:34.474]                       invokeRestart <- base::invokeRestart
[13:35:34.474]                       is.null <- base::is.null
[13:35:34.474]                       muffled <- FALSE
[13:35:34.474]                       if (inherits(cond, "message")) {
[13:35:34.474]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:34.474]                         if (muffled) 
[13:35:34.474]                           invokeRestart("muffleMessage")
[13:35:34.474]                       }
[13:35:34.474]                       else if (inherits(cond, "warning")) {
[13:35:34.474]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:34.474]                         if (muffled) 
[13:35:34.474]                           invokeRestart("muffleWarning")
[13:35:34.474]                       }
[13:35:34.474]                       else if (inherits(cond, "condition")) {
[13:35:34.474]                         if (!is.null(pattern)) {
[13:35:34.474]                           computeRestarts <- base::computeRestarts
[13:35:34.474]                           grepl <- base::grepl
[13:35:34.474]                           restarts <- computeRestarts(cond)
[13:35:34.474]                           for (restart in restarts) {
[13:35:34.474]                             name <- restart$name
[13:35:34.474]                             if (is.null(name)) 
[13:35:34.474]                               next
[13:35:34.474]                             if (!grepl(pattern, name)) 
[13:35:34.474]                               next
[13:35:34.474]                             invokeRestart(restart)
[13:35:34.474]                             muffled <- TRUE
[13:35:34.474]                             break
[13:35:34.474]                           }
[13:35:34.474]                         }
[13:35:34.474]                       }
[13:35:34.474]                       invisible(muffled)
[13:35:34.474]                     }
[13:35:34.474]                     muffleCondition(cond, pattern = "^muffle")
[13:35:34.474]                   }
[13:35:34.474]                 }
[13:35:34.474]                 else {
[13:35:34.474]                   if (TRUE) {
[13:35:34.474]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:34.474]                     {
[13:35:34.474]                       inherits <- base::inherits
[13:35:34.474]                       invokeRestart <- base::invokeRestart
[13:35:34.474]                       is.null <- base::is.null
[13:35:34.474]                       muffled <- FALSE
[13:35:34.474]                       if (inherits(cond, "message")) {
[13:35:34.474]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:34.474]                         if (muffled) 
[13:35:34.474]                           invokeRestart("muffleMessage")
[13:35:34.474]                       }
[13:35:34.474]                       else if (inherits(cond, "warning")) {
[13:35:34.474]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:34.474]                         if (muffled) 
[13:35:34.474]                           invokeRestart("muffleWarning")
[13:35:34.474]                       }
[13:35:34.474]                       else if (inherits(cond, "condition")) {
[13:35:34.474]                         if (!is.null(pattern)) {
[13:35:34.474]                           computeRestarts <- base::computeRestarts
[13:35:34.474]                           grepl <- base::grepl
[13:35:34.474]                           restarts <- computeRestarts(cond)
[13:35:34.474]                           for (restart in restarts) {
[13:35:34.474]                             name <- restart$name
[13:35:34.474]                             if (is.null(name)) 
[13:35:34.474]                               next
[13:35:34.474]                             if (!grepl(pattern, name)) 
[13:35:34.474]                               next
[13:35:34.474]                             invokeRestart(restart)
[13:35:34.474]                             muffled <- TRUE
[13:35:34.474]                             break
[13:35:34.474]                           }
[13:35:34.474]                         }
[13:35:34.474]                       }
[13:35:34.474]                       invisible(muffled)
[13:35:34.474]                     }
[13:35:34.474]                     muffleCondition(cond, pattern = "^muffle")
[13:35:34.474]                   }
[13:35:34.474]                 }
[13:35:34.474]             }
[13:35:34.474]         }))
[13:35:34.474]     }, error = function(ex) {
[13:35:34.474]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:34.474]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:34.474]                 ...future.rng), started = ...future.startTime, 
[13:35:34.474]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:34.474]             version = "1.8"), class = "FutureResult")
[13:35:34.474]     }, finally = {
[13:35:34.474]         if (!identical(...future.workdir, getwd())) 
[13:35:34.474]             setwd(...future.workdir)
[13:35:34.474]         {
[13:35:34.474]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:34.474]                 ...future.oldOptions$nwarnings <- NULL
[13:35:34.474]             }
[13:35:34.474]             base::options(...future.oldOptions)
[13:35:34.474]             if (.Platform$OS.type == "windows") {
[13:35:34.474]                 old_names <- names(...future.oldEnvVars)
[13:35:34.474]                 envs <- base::Sys.getenv()
[13:35:34.474]                 names <- names(envs)
[13:35:34.474]                 common <- intersect(names, old_names)
[13:35:34.474]                 added <- setdiff(names, old_names)
[13:35:34.474]                 removed <- setdiff(old_names, names)
[13:35:34.474]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:34.474]                   envs[common]]
[13:35:34.474]                 NAMES <- toupper(changed)
[13:35:34.474]                 args <- list()
[13:35:34.474]                 for (kk in seq_along(NAMES)) {
[13:35:34.474]                   name <- changed[[kk]]
[13:35:34.474]                   NAME <- NAMES[[kk]]
[13:35:34.474]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:34.474]                     next
[13:35:34.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:34.474]                 }
[13:35:34.474]                 NAMES <- toupper(added)
[13:35:34.474]                 for (kk in seq_along(NAMES)) {
[13:35:34.474]                   name <- added[[kk]]
[13:35:34.474]                   NAME <- NAMES[[kk]]
[13:35:34.474]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:34.474]                     next
[13:35:34.474]                   args[[name]] <- ""
[13:35:34.474]                 }
[13:35:34.474]                 NAMES <- toupper(removed)
[13:35:34.474]                 for (kk in seq_along(NAMES)) {
[13:35:34.474]                   name <- removed[[kk]]
[13:35:34.474]                   NAME <- NAMES[[kk]]
[13:35:34.474]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:34.474]                     next
[13:35:34.474]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:34.474]                 }
[13:35:34.474]                 if (length(args) > 0) 
[13:35:34.474]                   base::do.call(base::Sys.setenv, args = args)
[13:35:34.474]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:34.474]             }
[13:35:34.474]             else {
[13:35:34.474]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:34.474]             }
[13:35:34.474]             {
[13:35:34.474]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:34.474]                   0L) {
[13:35:34.474]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:34.474]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:34.474]                   base::options(opts)
[13:35:34.474]                 }
[13:35:34.474]                 {
[13:35:34.474]                   {
[13:35:34.474]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:34.474]                     NULL
[13:35:34.474]                   }
[13:35:34.474]                   options(future.plan = NULL)
[13:35:34.474]                   if (is.na(NA_character_)) 
[13:35:34.474]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:34.474]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:34.474]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:34.474]                     .init = FALSE)
[13:35:34.474]                 }
[13:35:34.474]             }
[13:35:34.474]         }
[13:35:34.474]     })
[13:35:34.474]     if (TRUE) {
[13:35:34.474]         base::sink(type = "output", split = FALSE)
[13:35:34.474]         if (TRUE) {
[13:35:34.474]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:34.474]         }
[13:35:34.474]         else {
[13:35:34.474]             ...future.result["stdout"] <- base::list(NULL)
[13:35:34.474]         }
[13:35:34.474]         base::close(...future.stdout)
[13:35:34.474]         ...future.stdout <- NULL
[13:35:34.474]     }
[13:35:34.474]     ...future.result$conditions <- ...future.conditions
[13:35:34.474]     ...future.result$finished <- base::Sys.time()
[13:35:34.474]     ...future.result
[13:35:34.474] }
[13:35:34.476] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[13:35:34.476] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[13:35:34.477] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[13:35:34.477] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:35:34.477] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:35:34.477] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[13:35:34.478] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[13:35:34.478] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:35:34.478] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:35:34.479] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:35:34.479] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:35:34.479] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[13:35:34.480] MultisessionFuture started
[13:35:34.480] - Launch lazy future ... done
[13:35:34.480] run() for ‘MultisessionFuture’ ... done
[13:35:34.480] Created future:
[13:35:34.480] MultisessionFuture:
[13:35:34.480] Label: ‘future_lapply-2’
[13:35:34.480] Expression:
[13:35:34.480] {
[13:35:34.480]     do.call(function(...) {
[13:35:34.480]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:34.480]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:34.480]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:34.480]             on.exit(options(oopts), add = TRUE)
[13:35:34.480]         }
[13:35:34.480]         {
[13:35:34.480]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:34.480]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:34.480]                 ...future.FUN(...future.X_jj, ...)
[13:35:34.480]             })
[13:35:34.480]         }
[13:35:34.480]     }, args = future.call.arguments)
[13:35:34.480] }
[13:35:34.480] Lazy evaluation: FALSE
[13:35:34.480] Asynchronous evaluation: TRUE
[13:35:34.480] Local evaluation: TRUE
[13:35:34.480] Environment: R_GlobalEnv
[13:35:34.480] Capture standard output: TRUE
[13:35:34.480] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:34.480] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:34.480] Packages: <none>
[13:35:34.480] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:34.480] Resolved: FALSE
[13:35:34.480] Value: <not collected>
[13:35:34.480] Conditions captured: <none>
[13:35:34.480] Early signaling: FALSE
[13:35:34.480] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:34.480] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:34.492] Chunk #2 of 2 ... DONE
[13:35:34.492] Launching 2 futures (chunks) ... DONE
[13:35:34.492] Resolving 2 futures (chunks) ...
[13:35:34.492] resolve() on list ...
[13:35:34.492]  recursive: 0
[13:35:34.492]  length: 2
[13:35:34.492] 
[13:35:34.534] receiveMessageFromWorker() for ClusterFuture ...
[13:35:34.535] - Validating connection of MultisessionFuture
[13:35:34.535] - received message: FutureResult
[13:35:34.535] - Received FutureResult
[13:35:34.535] - Erased future from FutureRegistry
[13:35:34.535] result() for ClusterFuture ...
[13:35:34.535] - result already collected: FutureResult
[13:35:34.535] result() for ClusterFuture ... done
[13:35:34.535] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:34.535] Future #2
[13:35:34.536] result() for ClusterFuture ...
[13:35:34.536] - result already collected: FutureResult
[13:35:34.536] result() for ClusterFuture ... done
[13:35:34.536] result() for ClusterFuture ...
[13:35:34.536] - result already collected: FutureResult
[13:35:34.536] result() for ClusterFuture ... done
[13:35:34.536] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:35:34.536] - nx: 2
[13:35:34.536] - relay: TRUE
[13:35:34.536] - stdout: TRUE
[13:35:34.536] - signal: TRUE
[13:35:34.536] - resignal: FALSE
[13:35:34.537] - force: TRUE
[13:35:34.537] - relayed: [n=2] FALSE, FALSE
[13:35:34.537] - queued futures: [n=2] FALSE, FALSE
[13:35:34.537]  - until=1
[13:35:34.537]  - relaying element #1
[13:35:34.537] - relayed: [n=2] FALSE, FALSE
[13:35:34.537] - queued futures: [n=2] FALSE, TRUE
[13:35:34.537] signalConditionsASAP(NULL, pos=2) ... done
[13:35:34.537]  length: 1 (resolved future 2)
[13:35:34.985] receiveMessageFromWorker() for ClusterFuture ...
[13:35:34.985] - Validating connection of MultisessionFuture
[13:35:34.985] - received message: FutureResult
[13:35:34.985] - Received FutureResult
[13:35:34.985] - Erased future from FutureRegistry
[13:35:34.986] result() for ClusterFuture ...
[13:35:34.986] - result already collected: FutureResult
[13:35:34.986] result() for ClusterFuture ... done
[13:35:34.986] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:34.986] Future #1
[13:35:34.986] result() for ClusterFuture ...
[13:35:34.986] - result already collected: FutureResult
[13:35:34.986] result() for ClusterFuture ... done
[13:35:34.986] result() for ClusterFuture ...
[13:35:34.986] - result already collected: FutureResult
[13:35:34.987] result() for ClusterFuture ... done
[13:35:34.987] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:35:34.987] - nx: 2
[13:35:34.987] - relay: TRUE
[13:35:34.987] - stdout: TRUE
[13:35:34.987] - signal: TRUE
[13:35:34.987] - resignal: FALSE
[13:35:34.987] - force: TRUE
[13:35:34.987] - relayed: [n=2] FALSE, FALSE
[13:35:34.987] - queued futures: [n=2] FALSE, TRUE
[13:35:34.987]  - until=1
[13:35:34.987]  - relaying element #1
[13:35:34.988] result() for ClusterFuture ...
[13:35:34.988] - result already collected: FutureResult
[13:35:34.988] result() for ClusterFuture ... done
[13:35:34.988] result() for ClusterFuture ...
[13:35:34.988] - result already collected: FutureResult
[13:35:34.988] result() for ClusterFuture ... done
[13:35:34.988] result() for ClusterFuture ...
[13:35:34.988] - result already collected: FutureResult
[13:35:34.988] result() for ClusterFuture ... done
[13:35:34.988] result() for ClusterFuture ...
[13:35:34.988] - result already collected: FutureResult
[13:35:34.989] result() for ClusterFuture ... done
[13:35:34.989] - relayed: [n=2] TRUE, FALSE
[13:35:34.989] - queued futures: [n=2] TRUE, TRUE
[13:35:34.989] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:35:34.989]  length: 0 (resolved future 1)
[13:35:34.989] Relaying remaining futures
[13:35:34.989] signalConditionsASAP(NULL, pos=0) ...
[13:35:34.989] - nx: 2
[13:35:34.989] - relay: TRUE
[13:35:34.991] - stdout: TRUE
[13:35:34.992] - signal: TRUE
[13:35:34.992] - resignal: FALSE
[13:35:34.992] - force: TRUE
[13:35:34.992] - relayed: [n=2] TRUE, FALSE
[13:35:34.992] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:34.992]  - relaying element #2
[13:35:34.992] result() for ClusterFuture ...
[13:35:34.992] - result already collected: FutureResult
[13:35:34.992] result() for ClusterFuture ... done
[13:35:34.992] result() for ClusterFuture ...
[13:35:34.992] - result already collected: FutureResult
[13:35:34.992] result() for ClusterFuture ... done
[13:35:34.993] result() for ClusterFuture ...
[13:35:34.993] - result already collected: FutureResult
[13:35:34.993] result() for ClusterFuture ... done
[13:35:34.993] result() for ClusterFuture ...
[13:35:34.993] - result already collected: FutureResult
[13:35:34.993] result() for ClusterFuture ... done
[13:35:34.993] - relayed: [n=2] TRUE, TRUE
[13:35:34.993] - queued futures: [n=2] TRUE, TRUE
[13:35:34.993] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[13:35:34.993] resolve() on list ... DONE
[13:35:34.993] result() for ClusterFuture ...
[13:35:34.994] - result already collected: FutureResult
[13:35:34.994] result() for ClusterFuture ... done
[13:35:34.994] result() for ClusterFuture ...
[13:35:34.994] - result already collected: FutureResult
[13:35:34.994] result() for ClusterFuture ... done
[13:35:34.994] result() for ClusterFuture ...
[13:35:34.994] - result already collected: FutureResult
[13:35:34.994] result() for ClusterFuture ... done
[13:35:34.994] result() for ClusterFuture ...
[13:35:34.994] - result already collected: FutureResult
[13:35:34.994] result() for ClusterFuture ... done
[13:35:34.994]  - Number of value chunks collected: 2
[13:35:34.995] Resolving 2 futures (chunks) ... DONE
[13:35:34.995] Reducing values from 2 chunks ...
[13:35:34.995]  - Number of values collected after concatenation: 2
[13:35:34.995]  - Number of values expected: 2
[13:35:34.995] Reducing values from 2 chunks ... DONE
[13:35:34.995] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[13:35:34.995] future_lapply() ...
[13:35:35.000] Number of chunks: 2
[13:35:35.000] getGlobalsAndPackagesXApply() ...
[13:35:35.000]  - future.globals: TRUE
[13:35:35.000] getGlobalsAndPackages() ...
[13:35:35.000] Searching for globals...
[13:35:35.001] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[13:35:35.002] Searching for globals ... DONE
[13:35:35.002] Resolving globals: FALSE
[13:35:35.002] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[13:35:35.002] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[13:35:35.003] - globals: [1] ‘FUN’
[13:35:35.003] 
[13:35:35.003] getGlobalsAndPackages() ... DONE
[13:35:35.003]  - globals found/used: [n=1] ‘FUN’
[13:35:35.003]  - needed namespaces: [n=0] 
[13:35:35.003] Finding globals ... DONE
[13:35:35.003]  - use_args: TRUE
[13:35:35.003]  - Getting '...' globals ...
[13:35:35.004] resolve() on list ...
[13:35:35.004]  recursive: 0
[13:35:35.004]  length: 1
[13:35:35.004]  elements: ‘...’
[13:35:35.004]  length: 0 (resolved future 1)
[13:35:35.004] resolve() on list ... DONE
[13:35:35.004]    - '...' content: [n=0] 
[13:35:35.004] List of 1
[13:35:35.004]  $ ...: list()
[13:35:35.004]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:35.004]  - attr(*, "where")=List of 1
[13:35:35.004]   ..$ ...:<environment: 0x558d38abcd78> 
[13:35:35.004]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:35.004]  - attr(*, "resolved")= logi TRUE
[13:35:35.004]  - attr(*, "total_size")= num NA
[13:35:35.007]  - Getting '...' globals ... DONE
[13:35:35.007] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:35:35.007] List of 2
[13:35:35.007]  $ ...future.FUN:function (x)  
[13:35:35.007]  $ ...          : list()
[13:35:35.007]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:35.007]  - attr(*, "where")=List of 2
[13:35:35.007]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:35.007]   ..$ ...          :<environment: 0x558d38abcd78> 
[13:35:35.007]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:35.007]  - attr(*, "resolved")= logi FALSE
[13:35:35.007]  - attr(*, "total_size")= num 4720
[13:35:35.010] Packages to be attached in all futures: [n=0] 
[13:35:35.010] getGlobalsAndPackagesXApply() ... DONE
[13:35:35.010] Number of futures (= number of chunks): 2
[13:35:35.010] Launching 2 futures (chunks) ...
[13:35:35.010] Chunk #1 of 2 ...
[13:35:35.010]  - Finding globals in 'X' for chunk #1 ...
[13:35:35.010] getGlobalsAndPackages() ...
[13:35:35.010] Searching for globals...
[13:35:35.011] 
[13:35:35.011] Searching for globals ... DONE
[13:35:35.011] - globals: [0] <none>
[13:35:35.011] getGlobalsAndPackages() ... DONE
[13:35:35.011]    + additional globals found: [n=0] 
[13:35:35.011]    + additional namespaces needed: [n=0] 
[13:35:35.011]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:35.011]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:35.011]  - seeds: <none>
[13:35:35.011]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:35.012] getGlobalsAndPackages() ...
[13:35:35.012] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:35.012] Resolving globals: FALSE
[13:35:35.012] Tweak future expression to call with '...' arguments ...
[13:35:35.012] {
[13:35:35.012]     do.call(function(...) {
[13:35:35.012]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:35.012]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:35.012]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:35.012]             on.exit(options(oopts), add = TRUE)
[13:35:35.012]         }
[13:35:35.012]         {
[13:35:35.012]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:35.012]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:35.012]                 ...future.FUN(...future.X_jj, ...)
[13:35:35.012]             })
[13:35:35.012]         }
[13:35:35.012]     }, args = future.call.arguments)
[13:35:35.012] }
[13:35:35.012] Tweak future expression to call with '...' arguments ... DONE
[13:35:35.012] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:35.013] 
[13:35:35.013] getGlobalsAndPackages() ... DONE
[13:35:35.013] run() for ‘Future’ ...
[13:35:35.013] - state: ‘created’
[13:35:35.013] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:35.029] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:35.029] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:35.029]   - Field: ‘node’
[13:35:35.029]   - Field: ‘label’
[13:35:35.029]   - Field: ‘local’
[13:35:35.029]   - Field: ‘owner’
[13:35:35.029]   - Field: ‘envir’
[13:35:35.029]   - Field: ‘workers’
[13:35:35.029]   - Field: ‘packages’
[13:35:35.030]   - Field: ‘gc’
[13:35:35.030]   - Field: ‘conditions’
[13:35:35.030]   - Field: ‘persistent’
[13:35:35.030]   - Field: ‘expr’
[13:35:35.030]   - Field: ‘uuid’
[13:35:35.030]   - Field: ‘seed’
[13:35:35.030]   - Field: ‘version’
[13:35:35.030]   - Field: ‘result’
[13:35:35.030]   - Field: ‘asynchronous’
[13:35:35.030]   - Field: ‘calls’
[13:35:35.030]   - Field: ‘globals’
[13:35:35.031]   - Field: ‘stdout’
[13:35:35.031]   - Field: ‘earlySignal’
[13:35:35.031]   - Field: ‘lazy’
[13:35:35.031]   - Field: ‘state’
[13:35:35.031] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:35.031] - Launch lazy future ...
[13:35:35.031] Packages needed by the future expression (n = 0): <none>
[13:35:35.031] Packages needed by future strategies (n = 0): <none>
[13:35:35.032] {
[13:35:35.032]     {
[13:35:35.032]         {
[13:35:35.032]             ...future.startTime <- base::Sys.time()
[13:35:35.032]             {
[13:35:35.032]                 {
[13:35:35.032]                   {
[13:35:35.032]                     {
[13:35:35.032]                       base::local({
[13:35:35.032]                         has_future <- base::requireNamespace("future", 
[13:35:35.032]                           quietly = TRUE)
[13:35:35.032]                         if (has_future) {
[13:35:35.032]                           ns <- base::getNamespace("future")
[13:35:35.032]                           version <- ns[[".package"]][["version"]]
[13:35:35.032]                           if (is.null(version)) 
[13:35:35.032]                             version <- utils::packageVersion("future")
[13:35:35.032]                         }
[13:35:35.032]                         else {
[13:35:35.032]                           version <- NULL
[13:35:35.032]                         }
[13:35:35.032]                         if (!has_future || version < "1.8.0") {
[13:35:35.032]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:35.032]                             "", base::R.version$version.string), 
[13:35:35.032]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:35.032]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:35.032]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:35.032]                               "release", "version")], collapse = " "), 
[13:35:35.032]                             hostname = base::Sys.info()[["nodename"]])
[13:35:35.032]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:35.032]                             info)
[13:35:35.032]                           info <- base::paste(info, collapse = "; ")
[13:35:35.032]                           if (!has_future) {
[13:35:35.032]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:35.032]                               info)
[13:35:35.032]                           }
[13:35:35.032]                           else {
[13:35:35.032]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:35.032]                               info, version)
[13:35:35.032]                           }
[13:35:35.032]                           base::stop(msg)
[13:35:35.032]                         }
[13:35:35.032]                       })
[13:35:35.032]                     }
[13:35:35.032]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:35.032]                     base::options(mc.cores = 1L)
[13:35:35.032]                   }
[13:35:35.032]                   ...future.strategy.old <- future::plan("list")
[13:35:35.032]                   options(future.plan = NULL)
[13:35:35.032]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:35.032]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:35.032]                 }
[13:35:35.032]                 ...future.workdir <- getwd()
[13:35:35.032]             }
[13:35:35.032]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:35.032]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:35.032]         }
[13:35:35.032]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:35.032]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:35.032]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:35.032]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:35.032]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:35.032]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:35.032]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:35.032]             base::names(...future.oldOptions))
[13:35:35.032]     }
[13:35:35.032]     if (TRUE) {
[13:35:35.032]     }
[13:35:35.032]     else {
[13:35:35.032]         if (NA) {
[13:35:35.032]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:35.032]                 open = "w")
[13:35:35.032]         }
[13:35:35.032]         else {
[13:35:35.032]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:35.032]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:35.032]         }
[13:35:35.032]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:35.032]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:35.032]             base::sink(type = "output", split = FALSE)
[13:35:35.032]             base::close(...future.stdout)
[13:35:35.032]         }, add = TRUE)
[13:35:35.032]     }
[13:35:35.032]     ...future.frame <- base::sys.nframe()
[13:35:35.032]     ...future.conditions <- base::list()
[13:35:35.032]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:35.032]     if (FALSE) {
[13:35:35.032]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:35.032]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:35.032]     }
[13:35:35.032]     ...future.result <- base::tryCatch({
[13:35:35.032]         base::withCallingHandlers({
[13:35:35.032]             ...future.value <- base::withVisible(base::local({
[13:35:35.032]                 ...future.makeSendCondition <- base::local({
[13:35:35.032]                   sendCondition <- NULL
[13:35:35.032]                   function(frame = 1L) {
[13:35:35.032]                     if (is.function(sendCondition)) 
[13:35:35.032]                       return(sendCondition)
[13:35:35.032]                     ns <- getNamespace("parallel")
[13:35:35.032]                     if (exists("sendData", mode = "function", 
[13:35:35.032]                       envir = ns)) {
[13:35:35.032]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:35.032]                         envir = ns)
[13:35:35.032]                       envir <- sys.frame(frame)
[13:35:35.032]                       master <- NULL
[13:35:35.032]                       while (!identical(envir, .GlobalEnv) && 
[13:35:35.032]                         !identical(envir, emptyenv())) {
[13:35:35.032]                         if (exists("master", mode = "list", envir = envir, 
[13:35:35.032]                           inherits = FALSE)) {
[13:35:35.032]                           master <- get("master", mode = "list", 
[13:35:35.032]                             envir = envir, inherits = FALSE)
[13:35:35.032]                           if (inherits(master, c("SOCKnode", 
[13:35:35.032]                             "SOCK0node"))) {
[13:35:35.032]                             sendCondition <<- function(cond) {
[13:35:35.032]                               data <- list(type = "VALUE", value = cond, 
[13:35:35.032]                                 success = TRUE)
[13:35:35.032]                               parallel_sendData(master, data)
[13:35:35.032]                             }
[13:35:35.032]                             return(sendCondition)
[13:35:35.032]                           }
[13:35:35.032]                         }
[13:35:35.032]                         frame <- frame + 1L
[13:35:35.032]                         envir <- sys.frame(frame)
[13:35:35.032]                       }
[13:35:35.032]                     }
[13:35:35.032]                     sendCondition <<- function(cond) NULL
[13:35:35.032]                   }
[13:35:35.032]                 })
[13:35:35.032]                 withCallingHandlers({
[13:35:35.032]                   {
[13:35:35.032]                     do.call(function(...) {
[13:35:35.032]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:35.032]                       if (!identical(...future.globals.maxSize.org, 
[13:35:35.032]                         ...future.globals.maxSize)) {
[13:35:35.032]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:35.032]                         on.exit(options(oopts), add = TRUE)
[13:35:35.032]                       }
[13:35:35.032]                       {
[13:35:35.032]                         lapply(seq_along(...future.elements_ii), 
[13:35:35.032]                           FUN = function(jj) {
[13:35:35.032]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:35.032]                             ...future.FUN(...future.X_jj, ...)
[13:35:35.032]                           })
[13:35:35.032]                       }
[13:35:35.032]                     }, args = future.call.arguments)
[13:35:35.032]                   }
[13:35:35.032]                 }, immediateCondition = function(cond) {
[13:35:35.032]                   sendCondition <- ...future.makeSendCondition()
[13:35:35.032]                   sendCondition(cond)
[13:35:35.032]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:35.032]                   {
[13:35:35.032]                     inherits <- base::inherits
[13:35:35.032]                     invokeRestart <- base::invokeRestart
[13:35:35.032]                     is.null <- base::is.null
[13:35:35.032]                     muffled <- FALSE
[13:35:35.032]                     if (inherits(cond, "message")) {
[13:35:35.032]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:35.032]                       if (muffled) 
[13:35:35.032]                         invokeRestart("muffleMessage")
[13:35:35.032]                     }
[13:35:35.032]                     else if (inherits(cond, "warning")) {
[13:35:35.032]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:35.032]                       if (muffled) 
[13:35:35.032]                         invokeRestart("muffleWarning")
[13:35:35.032]                     }
[13:35:35.032]                     else if (inherits(cond, "condition")) {
[13:35:35.032]                       if (!is.null(pattern)) {
[13:35:35.032]                         computeRestarts <- base::computeRestarts
[13:35:35.032]                         grepl <- base::grepl
[13:35:35.032]                         restarts <- computeRestarts(cond)
[13:35:35.032]                         for (restart in restarts) {
[13:35:35.032]                           name <- restart$name
[13:35:35.032]                           if (is.null(name)) 
[13:35:35.032]                             next
[13:35:35.032]                           if (!grepl(pattern, name)) 
[13:35:35.032]                             next
[13:35:35.032]                           invokeRestart(restart)
[13:35:35.032]                           muffled <- TRUE
[13:35:35.032]                           break
[13:35:35.032]                         }
[13:35:35.032]                       }
[13:35:35.032]                     }
[13:35:35.032]                     invisible(muffled)
[13:35:35.032]                   }
[13:35:35.032]                   muffleCondition(cond)
[13:35:35.032]                 })
[13:35:35.032]             }))
[13:35:35.032]             future::FutureResult(value = ...future.value$value, 
[13:35:35.032]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:35.032]                   ...future.rng), globalenv = if (FALSE) 
[13:35:35.032]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:35.032]                     ...future.globalenv.names))
[13:35:35.032]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:35.032]         }, condition = base::local({
[13:35:35.032]             c <- base::c
[13:35:35.032]             inherits <- base::inherits
[13:35:35.032]             invokeRestart <- base::invokeRestart
[13:35:35.032]             length <- base::length
[13:35:35.032]             list <- base::list
[13:35:35.032]             seq.int <- base::seq.int
[13:35:35.032]             signalCondition <- base::signalCondition
[13:35:35.032]             sys.calls <- base::sys.calls
[13:35:35.032]             `[[` <- base::`[[`
[13:35:35.032]             `+` <- base::`+`
[13:35:35.032]             `<<-` <- base::`<<-`
[13:35:35.032]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:35.032]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:35.032]                   3L)]
[13:35:35.032]             }
[13:35:35.032]             function(cond) {
[13:35:35.032]                 is_error <- inherits(cond, "error")
[13:35:35.032]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:35.032]                   NULL)
[13:35:35.032]                 if (is_error) {
[13:35:35.032]                   sessionInformation <- function() {
[13:35:35.032]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:35.032]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:35.032]                       search = base::search(), system = base::Sys.info())
[13:35:35.032]                   }
[13:35:35.032]                   ...future.conditions[[length(...future.conditions) + 
[13:35:35.032]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:35.032]                     cond$call), session = sessionInformation(), 
[13:35:35.032]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:35.032]                   signalCondition(cond)
[13:35:35.032]                 }
[13:35:35.032]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:35.032]                 "immediateCondition"))) {
[13:35:35.032]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:35.032]                   ...future.conditions[[length(...future.conditions) + 
[13:35:35.032]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:35.032]                   if (TRUE && !signal) {
[13:35:35.032]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:35.032]                     {
[13:35:35.032]                       inherits <- base::inherits
[13:35:35.032]                       invokeRestart <- base::invokeRestart
[13:35:35.032]                       is.null <- base::is.null
[13:35:35.032]                       muffled <- FALSE
[13:35:35.032]                       if (inherits(cond, "message")) {
[13:35:35.032]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:35.032]                         if (muffled) 
[13:35:35.032]                           invokeRestart("muffleMessage")
[13:35:35.032]                       }
[13:35:35.032]                       else if (inherits(cond, "warning")) {
[13:35:35.032]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:35.032]                         if (muffled) 
[13:35:35.032]                           invokeRestart("muffleWarning")
[13:35:35.032]                       }
[13:35:35.032]                       else if (inherits(cond, "condition")) {
[13:35:35.032]                         if (!is.null(pattern)) {
[13:35:35.032]                           computeRestarts <- base::computeRestarts
[13:35:35.032]                           grepl <- base::grepl
[13:35:35.032]                           restarts <- computeRestarts(cond)
[13:35:35.032]                           for (restart in restarts) {
[13:35:35.032]                             name <- restart$name
[13:35:35.032]                             if (is.null(name)) 
[13:35:35.032]                               next
[13:35:35.032]                             if (!grepl(pattern, name)) 
[13:35:35.032]                               next
[13:35:35.032]                             invokeRestart(restart)
[13:35:35.032]                             muffled <- TRUE
[13:35:35.032]                             break
[13:35:35.032]                           }
[13:35:35.032]                         }
[13:35:35.032]                       }
[13:35:35.032]                       invisible(muffled)
[13:35:35.032]                     }
[13:35:35.032]                     muffleCondition(cond, pattern = "^muffle")
[13:35:35.032]                   }
[13:35:35.032]                 }
[13:35:35.032]                 else {
[13:35:35.032]                   if (TRUE) {
[13:35:35.032]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:35.032]                     {
[13:35:35.032]                       inherits <- base::inherits
[13:35:35.032]                       invokeRestart <- base::invokeRestart
[13:35:35.032]                       is.null <- base::is.null
[13:35:35.032]                       muffled <- FALSE
[13:35:35.032]                       if (inherits(cond, "message")) {
[13:35:35.032]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:35.032]                         if (muffled) 
[13:35:35.032]                           invokeRestart("muffleMessage")
[13:35:35.032]                       }
[13:35:35.032]                       else if (inherits(cond, "warning")) {
[13:35:35.032]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:35.032]                         if (muffled) 
[13:35:35.032]                           invokeRestart("muffleWarning")
[13:35:35.032]                       }
[13:35:35.032]                       else if (inherits(cond, "condition")) {
[13:35:35.032]                         if (!is.null(pattern)) {
[13:35:35.032]                           computeRestarts <- base::computeRestarts
[13:35:35.032]                           grepl <- base::grepl
[13:35:35.032]                           restarts <- computeRestarts(cond)
[13:35:35.032]                           for (restart in restarts) {
[13:35:35.032]                             name <- restart$name
[13:35:35.032]                             if (is.null(name)) 
[13:35:35.032]                               next
[13:35:35.032]                             if (!grepl(pattern, name)) 
[13:35:35.032]                               next
[13:35:35.032]                             invokeRestart(restart)
[13:35:35.032]                             muffled <- TRUE
[13:35:35.032]                             break
[13:35:35.032]                           }
[13:35:35.032]                         }
[13:35:35.032]                       }
[13:35:35.032]                       invisible(muffled)
[13:35:35.032]                     }
[13:35:35.032]                     muffleCondition(cond, pattern = "^muffle")
[13:35:35.032]                   }
[13:35:35.032]                 }
[13:35:35.032]             }
[13:35:35.032]         }))
[13:35:35.032]     }, error = function(ex) {
[13:35:35.032]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:35.032]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:35.032]                 ...future.rng), started = ...future.startTime, 
[13:35:35.032]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:35.032]             version = "1.8"), class = "FutureResult")
[13:35:35.032]     }, finally = {
[13:35:35.032]         if (!identical(...future.workdir, getwd())) 
[13:35:35.032]             setwd(...future.workdir)
[13:35:35.032]         {
[13:35:35.032]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:35.032]                 ...future.oldOptions$nwarnings <- NULL
[13:35:35.032]             }
[13:35:35.032]             base::options(...future.oldOptions)
[13:35:35.032]             if (.Platform$OS.type == "windows") {
[13:35:35.032]                 old_names <- names(...future.oldEnvVars)
[13:35:35.032]                 envs <- base::Sys.getenv()
[13:35:35.032]                 names <- names(envs)
[13:35:35.032]                 common <- intersect(names, old_names)
[13:35:35.032]                 added <- setdiff(names, old_names)
[13:35:35.032]                 removed <- setdiff(old_names, names)
[13:35:35.032]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:35.032]                   envs[common]]
[13:35:35.032]                 NAMES <- toupper(changed)
[13:35:35.032]                 args <- list()
[13:35:35.032]                 for (kk in seq_along(NAMES)) {
[13:35:35.032]                   name <- changed[[kk]]
[13:35:35.032]                   NAME <- NAMES[[kk]]
[13:35:35.032]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:35.032]                     next
[13:35:35.032]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:35.032]                 }
[13:35:35.032]                 NAMES <- toupper(added)
[13:35:35.032]                 for (kk in seq_along(NAMES)) {
[13:35:35.032]                   name <- added[[kk]]
[13:35:35.032]                   NAME <- NAMES[[kk]]
[13:35:35.032]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:35.032]                     next
[13:35:35.032]                   args[[name]] <- ""
[13:35:35.032]                 }
[13:35:35.032]                 NAMES <- toupper(removed)
[13:35:35.032]                 for (kk in seq_along(NAMES)) {
[13:35:35.032]                   name <- removed[[kk]]
[13:35:35.032]                   NAME <- NAMES[[kk]]
[13:35:35.032]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:35.032]                     next
[13:35:35.032]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:35.032]                 }
[13:35:35.032]                 if (length(args) > 0) 
[13:35:35.032]                   base::do.call(base::Sys.setenv, args = args)
[13:35:35.032]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:35.032]             }
[13:35:35.032]             else {
[13:35:35.032]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:35.032]             }
[13:35:35.032]             {
[13:35:35.032]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:35.032]                   0L) {
[13:35:35.032]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:35.032]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:35.032]                   base::options(opts)
[13:35:35.032]                 }
[13:35:35.032]                 {
[13:35:35.032]                   {
[13:35:35.032]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:35.032]                     NULL
[13:35:35.032]                   }
[13:35:35.032]                   options(future.plan = NULL)
[13:35:35.032]                   if (is.na(NA_character_)) 
[13:35:35.032]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:35.032]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:35.032]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:35.032]                     .init = FALSE)
[13:35:35.032]                 }
[13:35:35.032]             }
[13:35:35.032]         }
[13:35:35.032]     })
[13:35:35.032]     if (FALSE) {
[13:35:35.032]         base::sink(type = "output", split = FALSE)
[13:35:35.032]         if (NA) {
[13:35:35.032]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:35.032]         }
[13:35:35.032]         else {
[13:35:35.032]             ...future.result["stdout"] <- base::list(NULL)
[13:35:35.032]         }
[13:35:35.032]         base::close(...future.stdout)
[13:35:35.032]         ...future.stdout <- NULL
[13:35:35.032]     }
[13:35:35.032]     ...future.result$conditions <- ...future.conditions
[13:35:35.032]     ...future.result$finished <- base::Sys.time()
[13:35:35.032]     ...future.result
[13:35:35.032] }
[13:35:35.034] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[13:35:35.035] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[13:35:35.035] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[13:35:35.035] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:35:35.035] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:35:35.036] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:35:35.036] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:35:35.036] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:35.036] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:35.037] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:35.037] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:35.037] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[13:35:35.037] MultisessionFuture started
[13:35:35.037] - Launch lazy future ... done
[13:35:35.038] run() for ‘MultisessionFuture’ ... done
[13:35:35.038] Created future:
[13:35:35.038] MultisessionFuture:
[13:35:35.038] Label: ‘future_lapply-1’
[13:35:35.038] Expression:
[13:35:35.038] {
[13:35:35.038]     do.call(function(...) {
[13:35:35.038]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:35.038]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:35.038]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:35.038]             on.exit(options(oopts), add = TRUE)
[13:35:35.038]         }
[13:35:35.038]         {
[13:35:35.038]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:35.038]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:35.038]                 ...future.FUN(...future.X_jj, ...)
[13:35:35.038]             })
[13:35:35.038]         }
[13:35:35.038]     }, args = future.call.arguments)
[13:35:35.038] }
[13:35:35.038] Lazy evaluation: FALSE
[13:35:35.038] Asynchronous evaluation: TRUE
[13:35:35.038] Local evaluation: TRUE
[13:35:35.038] Environment: R_GlobalEnv
[13:35:35.038] Capture standard output: NA
[13:35:35.038] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:35.038] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:35.038] Packages: <none>
[13:35:35.038] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:35.038] Resolved: FALSE
[13:35:35.038] Value: <not collected>
[13:35:35.038] Conditions captured: <none>
[13:35:35.038] Early signaling: FALSE
[13:35:35.038] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:35.038] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:35.049] Chunk #1 of 2 ... DONE
[13:35:35.049] Chunk #2 of 2 ...
[13:35:35.050]  - Finding globals in 'X' for chunk #2 ...
[13:35:35.050] getGlobalsAndPackages() ...
[13:35:35.050] Searching for globals...
[13:35:35.050] 
[13:35:35.050] Searching for globals ... DONE
[13:35:35.050] - globals: [0] <none>
[13:35:35.050] getGlobalsAndPackages() ... DONE
[13:35:35.050]    + additional globals found: [n=0] 
[13:35:35.050]    + additional namespaces needed: [n=0] 
[13:35:35.051]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:35.051]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:35.051]  - seeds: <none>
[13:35:35.051]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:35.051] getGlobalsAndPackages() ...
[13:35:35.051] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:35.051] Resolving globals: FALSE
[13:35:35.051] Tweak future expression to call with '...' arguments ...
[13:35:35.051] {
[13:35:35.051]     do.call(function(...) {
[13:35:35.051]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:35.051]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:35.051]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:35.051]             on.exit(options(oopts), add = TRUE)
[13:35:35.051]         }
[13:35:35.051]         {
[13:35:35.051]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:35.051]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:35.051]                 ...future.FUN(...future.X_jj, ...)
[13:35:35.051]             })
[13:35:35.051]         }
[13:35:35.051]     }, args = future.call.arguments)
[13:35:35.051] }
[13:35:35.052] Tweak future expression to call with '...' arguments ... DONE
[13:35:35.052] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:35.052] 
[13:35:35.052] getGlobalsAndPackages() ... DONE
[13:35:35.052] run() for ‘Future’ ...
[13:35:35.052] - state: ‘created’
[13:35:35.053] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:35.066] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:35.066] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:35.066]   - Field: ‘node’
[13:35:35.066]   - Field: ‘label’
[13:35:35.066]   - Field: ‘local’
[13:35:35.067]   - Field: ‘owner’
[13:35:35.067]   - Field: ‘envir’
[13:35:35.067]   - Field: ‘workers’
[13:35:35.067]   - Field: ‘packages’
[13:35:35.067]   - Field: ‘gc’
[13:35:35.067]   - Field: ‘conditions’
[13:35:35.067]   - Field: ‘persistent’
[13:35:35.067]   - Field: ‘expr’
[13:35:35.067]   - Field: ‘uuid’
[13:35:35.067]   - Field: ‘seed’
[13:35:35.067]   - Field: ‘version’
[13:35:35.068]   - Field: ‘result’
[13:35:35.068]   - Field: ‘asynchronous’
[13:35:35.068]   - Field: ‘calls’
[13:35:35.068]   - Field: ‘globals’
[13:35:35.068]   - Field: ‘stdout’
[13:35:35.068]   - Field: ‘earlySignal’
[13:35:35.068]   - Field: ‘lazy’
[13:35:35.068]   - Field: ‘state’
[13:35:35.068] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:35.068] - Launch lazy future ...
[13:35:35.069] Packages needed by the future expression (n = 0): <none>
[13:35:35.069] Packages needed by future strategies (n = 0): <none>
[13:35:35.069] {
[13:35:35.069]     {
[13:35:35.069]         {
[13:35:35.069]             ...future.startTime <- base::Sys.time()
[13:35:35.069]             {
[13:35:35.069]                 {
[13:35:35.069]                   {
[13:35:35.069]                     {
[13:35:35.069]                       base::local({
[13:35:35.069]                         has_future <- base::requireNamespace("future", 
[13:35:35.069]                           quietly = TRUE)
[13:35:35.069]                         if (has_future) {
[13:35:35.069]                           ns <- base::getNamespace("future")
[13:35:35.069]                           version <- ns[[".package"]][["version"]]
[13:35:35.069]                           if (is.null(version)) 
[13:35:35.069]                             version <- utils::packageVersion("future")
[13:35:35.069]                         }
[13:35:35.069]                         else {
[13:35:35.069]                           version <- NULL
[13:35:35.069]                         }
[13:35:35.069]                         if (!has_future || version < "1.8.0") {
[13:35:35.069]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:35.069]                             "", base::R.version$version.string), 
[13:35:35.069]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:35.069]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:35.069]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:35.069]                               "release", "version")], collapse = " "), 
[13:35:35.069]                             hostname = base::Sys.info()[["nodename"]])
[13:35:35.069]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:35.069]                             info)
[13:35:35.069]                           info <- base::paste(info, collapse = "; ")
[13:35:35.069]                           if (!has_future) {
[13:35:35.069]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:35.069]                               info)
[13:35:35.069]                           }
[13:35:35.069]                           else {
[13:35:35.069]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:35.069]                               info, version)
[13:35:35.069]                           }
[13:35:35.069]                           base::stop(msg)
[13:35:35.069]                         }
[13:35:35.069]                       })
[13:35:35.069]                     }
[13:35:35.069]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:35.069]                     base::options(mc.cores = 1L)
[13:35:35.069]                   }
[13:35:35.069]                   ...future.strategy.old <- future::plan("list")
[13:35:35.069]                   options(future.plan = NULL)
[13:35:35.069]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:35.069]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:35.069]                 }
[13:35:35.069]                 ...future.workdir <- getwd()
[13:35:35.069]             }
[13:35:35.069]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:35.069]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:35.069]         }
[13:35:35.069]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:35.069]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:35.069]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:35.069]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:35.069]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:35.069]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:35.069]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:35.069]             base::names(...future.oldOptions))
[13:35:35.069]     }
[13:35:35.069]     if (TRUE) {
[13:35:35.069]     }
[13:35:35.069]     else {
[13:35:35.069]         if (NA) {
[13:35:35.069]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:35.069]                 open = "w")
[13:35:35.069]         }
[13:35:35.069]         else {
[13:35:35.069]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:35.069]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:35.069]         }
[13:35:35.069]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:35.069]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:35.069]             base::sink(type = "output", split = FALSE)
[13:35:35.069]             base::close(...future.stdout)
[13:35:35.069]         }, add = TRUE)
[13:35:35.069]     }
[13:35:35.069]     ...future.frame <- base::sys.nframe()
[13:35:35.069]     ...future.conditions <- base::list()
[13:35:35.069]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:35.069]     if (FALSE) {
[13:35:35.069]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:35.069]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:35.069]     }
[13:35:35.069]     ...future.result <- base::tryCatch({
[13:35:35.069]         base::withCallingHandlers({
[13:35:35.069]             ...future.value <- base::withVisible(base::local({
[13:35:35.069]                 ...future.makeSendCondition <- base::local({
[13:35:35.069]                   sendCondition <- NULL
[13:35:35.069]                   function(frame = 1L) {
[13:35:35.069]                     if (is.function(sendCondition)) 
[13:35:35.069]                       return(sendCondition)
[13:35:35.069]                     ns <- getNamespace("parallel")
[13:35:35.069]                     if (exists("sendData", mode = "function", 
[13:35:35.069]                       envir = ns)) {
[13:35:35.069]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:35.069]                         envir = ns)
[13:35:35.069]                       envir <- sys.frame(frame)
[13:35:35.069]                       master <- NULL
[13:35:35.069]                       while (!identical(envir, .GlobalEnv) && 
[13:35:35.069]                         !identical(envir, emptyenv())) {
[13:35:35.069]                         if (exists("master", mode = "list", envir = envir, 
[13:35:35.069]                           inherits = FALSE)) {
[13:35:35.069]                           master <- get("master", mode = "list", 
[13:35:35.069]                             envir = envir, inherits = FALSE)
[13:35:35.069]                           if (inherits(master, c("SOCKnode", 
[13:35:35.069]                             "SOCK0node"))) {
[13:35:35.069]                             sendCondition <<- function(cond) {
[13:35:35.069]                               data <- list(type = "VALUE", value = cond, 
[13:35:35.069]                                 success = TRUE)
[13:35:35.069]                               parallel_sendData(master, data)
[13:35:35.069]                             }
[13:35:35.069]                             return(sendCondition)
[13:35:35.069]                           }
[13:35:35.069]                         }
[13:35:35.069]                         frame <- frame + 1L
[13:35:35.069]                         envir <- sys.frame(frame)
[13:35:35.069]                       }
[13:35:35.069]                     }
[13:35:35.069]                     sendCondition <<- function(cond) NULL
[13:35:35.069]                   }
[13:35:35.069]                 })
[13:35:35.069]                 withCallingHandlers({
[13:35:35.069]                   {
[13:35:35.069]                     do.call(function(...) {
[13:35:35.069]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:35.069]                       if (!identical(...future.globals.maxSize.org, 
[13:35:35.069]                         ...future.globals.maxSize)) {
[13:35:35.069]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:35.069]                         on.exit(options(oopts), add = TRUE)
[13:35:35.069]                       }
[13:35:35.069]                       {
[13:35:35.069]                         lapply(seq_along(...future.elements_ii), 
[13:35:35.069]                           FUN = function(jj) {
[13:35:35.069]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:35.069]                             ...future.FUN(...future.X_jj, ...)
[13:35:35.069]                           })
[13:35:35.069]                       }
[13:35:35.069]                     }, args = future.call.arguments)
[13:35:35.069]                   }
[13:35:35.069]                 }, immediateCondition = function(cond) {
[13:35:35.069]                   sendCondition <- ...future.makeSendCondition()
[13:35:35.069]                   sendCondition(cond)
[13:35:35.069]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:35.069]                   {
[13:35:35.069]                     inherits <- base::inherits
[13:35:35.069]                     invokeRestart <- base::invokeRestart
[13:35:35.069]                     is.null <- base::is.null
[13:35:35.069]                     muffled <- FALSE
[13:35:35.069]                     if (inherits(cond, "message")) {
[13:35:35.069]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:35.069]                       if (muffled) 
[13:35:35.069]                         invokeRestart("muffleMessage")
[13:35:35.069]                     }
[13:35:35.069]                     else if (inherits(cond, "warning")) {
[13:35:35.069]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:35.069]                       if (muffled) 
[13:35:35.069]                         invokeRestart("muffleWarning")
[13:35:35.069]                     }
[13:35:35.069]                     else if (inherits(cond, "condition")) {
[13:35:35.069]                       if (!is.null(pattern)) {
[13:35:35.069]                         computeRestarts <- base::computeRestarts
[13:35:35.069]                         grepl <- base::grepl
[13:35:35.069]                         restarts <- computeRestarts(cond)
[13:35:35.069]                         for (restart in restarts) {
[13:35:35.069]                           name <- restart$name
[13:35:35.069]                           if (is.null(name)) 
[13:35:35.069]                             next
[13:35:35.069]                           if (!grepl(pattern, name)) 
[13:35:35.069]                             next
[13:35:35.069]                           invokeRestart(restart)
[13:35:35.069]                           muffled <- TRUE
[13:35:35.069]                           break
[13:35:35.069]                         }
[13:35:35.069]                       }
[13:35:35.069]                     }
[13:35:35.069]                     invisible(muffled)
[13:35:35.069]                   }
[13:35:35.069]                   muffleCondition(cond)
[13:35:35.069]                 })
[13:35:35.069]             }))
[13:35:35.069]             future::FutureResult(value = ...future.value$value, 
[13:35:35.069]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:35.069]                   ...future.rng), globalenv = if (FALSE) 
[13:35:35.069]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:35.069]                     ...future.globalenv.names))
[13:35:35.069]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:35.069]         }, condition = base::local({
[13:35:35.069]             c <- base::c
[13:35:35.069]             inherits <- base::inherits
[13:35:35.069]             invokeRestart <- base::invokeRestart
[13:35:35.069]             length <- base::length
[13:35:35.069]             list <- base::list
[13:35:35.069]             seq.int <- base::seq.int
[13:35:35.069]             signalCondition <- base::signalCondition
[13:35:35.069]             sys.calls <- base::sys.calls
[13:35:35.069]             `[[` <- base::`[[`
[13:35:35.069]             `+` <- base::`+`
[13:35:35.069]             `<<-` <- base::`<<-`
[13:35:35.069]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:35.069]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:35.069]                   3L)]
[13:35:35.069]             }
[13:35:35.069]             function(cond) {
[13:35:35.069]                 is_error <- inherits(cond, "error")
[13:35:35.069]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:35.069]                   NULL)
[13:35:35.069]                 if (is_error) {
[13:35:35.069]                   sessionInformation <- function() {
[13:35:35.069]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:35.069]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:35.069]                       search = base::search(), system = base::Sys.info())
[13:35:35.069]                   }
[13:35:35.069]                   ...future.conditions[[length(...future.conditions) + 
[13:35:35.069]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:35.069]                     cond$call), session = sessionInformation(), 
[13:35:35.069]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:35.069]                   signalCondition(cond)
[13:35:35.069]                 }
[13:35:35.069]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:35.069]                 "immediateCondition"))) {
[13:35:35.069]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:35.069]                   ...future.conditions[[length(...future.conditions) + 
[13:35:35.069]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:35.069]                   if (TRUE && !signal) {
[13:35:35.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:35.069]                     {
[13:35:35.069]                       inherits <- base::inherits
[13:35:35.069]                       invokeRestart <- base::invokeRestart
[13:35:35.069]                       is.null <- base::is.null
[13:35:35.069]                       muffled <- FALSE
[13:35:35.069]                       if (inherits(cond, "message")) {
[13:35:35.069]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:35.069]                         if (muffled) 
[13:35:35.069]                           invokeRestart("muffleMessage")
[13:35:35.069]                       }
[13:35:35.069]                       else if (inherits(cond, "warning")) {
[13:35:35.069]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:35.069]                         if (muffled) 
[13:35:35.069]                           invokeRestart("muffleWarning")
[13:35:35.069]                       }
[13:35:35.069]                       else if (inherits(cond, "condition")) {
[13:35:35.069]                         if (!is.null(pattern)) {
[13:35:35.069]                           computeRestarts <- base::computeRestarts
[13:35:35.069]                           grepl <- base::grepl
[13:35:35.069]                           restarts <- computeRestarts(cond)
[13:35:35.069]                           for (restart in restarts) {
[13:35:35.069]                             name <- restart$name
[13:35:35.069]                             if (is.null(name)) 
[13:35:35.069]                               next
[13:35:35.069]                             if (!grepl(pattern, name)) 
[13:35:35.069]                               next
[13:35:35.069]                             invokeRestart(restart)
[13:35:35.069]                             muffled <- TRUE
[13:35:35.069]                             break
[13:35:35.069]                           }
[13:35:35.069]                         }
[13:35:35.069]                       }
[13:35:35.069]                       invisible(muffled)
[13:35:35.069]                     }
[13:35:35.069]                     muffleCondition(cond, pattern = "^muffle")
[13:35:35.069]                   }
[13:35:35.069]                 }
[13:35:35.069]                 else {
[13:35:35.069]                   if (TRUE) {
[13:35:35.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:35.069]                     {
[13:35:35.069]                       inherits <- base::inherits
[13:35:35.069]                       invokeRestart <- base::invokeRestart
[13:35:35.069]                       is.null <- base::is.null
[13:35:35.069]                       muffled <- FALSE
[13:35:35.069]                       if (inherits(cond, "message")) {
[13:35:35.069]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:35.069]                         if (muffled) 
[13:35:35.069]                           invokeRestart("muffleMessage")
[13:35:35.069]                       }
[13:35:35.069]                       else if (inherits(cond, "warning")) {
[13:35:35.069]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:35.069]                         if (muffled) 
[13:35:35.069]                           invokeRestart("muffleWarning")
[13:35:35.069]                       }
[13:35:35.069]                       else if (inherits(cond, "condition")) {
[13:35:35.069]                         if (!is.null(pattern)) {
[13:35:35.069]                           computeRestarts <- base::computeRestarts
[13:35:35.069]                           grepl <- base::grepl
[13:35:35.069]                           restarts <- computeRestarts(cond)
[13:35:35.069]                           for (restart in restarts) {
[13:35:35.069]                             name <- restart$name
[13:35:35.069]                             if (is.null(name)) 
[13:35:35.069]                               next
[13:35:35.069]                             if (!grepl(pattern, name)) 
[13:35:35.069]                               next
[13:35:35.069]                             invokeRestart(restart)
[13:35:35.069]                             muffled <- TRUE
[13:35:35.069]                             break
[13:35:35.069]                           }
[13:35:35.069]                         }
[13:35:35.069]                       }
[13:35:35.069]                       invisible(muffled)
[13:35:35.069]                     }
[13:35:35.069]                     muffleCondition(cond, pattern = "^muffle")
[13:35:35.069]                   }
[13:35:35.069]                 }
[13:35:35.069]             }
[13:35:35.069]         }))
[13:35:35.069]     }, error = function(ex) {
[13:35:35.069]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:35.069]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:35.069]                 ...future.rng), started = ...future.startTime, 
[13:35:35.069]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:35.069]             version = "1.8"), class = "FutureResult")
[13:35:35.069]     }, finally = {
[13:35:35.069]         if (!identical(...future.workdir, getwd())) 
[13:35:35.069]             setwd(...future.workdir)
[13:35:35.069]         {
[13:35:35.069]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:35.069]                 ...future.oldOptions$nwarnings <- NULL
[13:35:35.069]             }
[13:35:35.069]             base::options(...future.oldOptions)
[13:35:35.069]             if (.Platform$OS.type == "windows") {
[13:35:35.069]                 old_names <- names(...future.oldEnvVars)
[13:35:35.069]                 envs <- base::Sys.getenv()
[13:35:35.069]                 names <- names(envs)
[13:35:35.069]                 common <- intersect(names, old_names)
[13:35:35.069]                 added <- setdiff(names, old_names)
[13:35:35.069]                 removed <- setdiff(old_names, names)
[13:35:35.069]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:35.069]                   envs[common]]
[13:35:35.069]                 NAMES <- toupper(changed)
[13:35:35.069]                 args <- list()
[13:35:35.069]                 for (kk in seq_along(NAMES)) {
[13:35:35.069]                   name <- changed[[kk]]
[13:35:35.069]                   NAME <- NAMES[[kk]]
[13:35:35.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:35.069]                     next
[13:35:35.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:35.069]                 }
[13:35:35.069]                 NAMES <- toupper(added)
[13:35:35.069]                 for (kk in seq_along(NAMES)) {
[13:35:35.069]                   name <- added[[kk]]
[13:35:35.069]                   NAME <- NAMES[[kk]]
[13:35:35.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:35.069]                     next
[13:35:35.069]                   args[[name]] <- ""
[13:35:35.069]                 }
[13:35:35.069]                 NAMES <- toupper(removed)
[13:35:35.069]                 for (kk in seq_along(NAMES)) {
[13:35:35.069]                   name <- removed[[kk]]
[13:35:35.069]                   NAME <- NAMES[[kk]]
[13:35:35.069]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:35.069]                     next
[13:35:35.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:35.069]                 }
[13:35:35.069]                 if (length(args) > 0) 
[13:35:35.069]                   base::do.call(base::Sys.setenv, args = args)
[13:35:35.069]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:35.069]             }
[13:35:35.069]             else {
[13:35:35.069]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:35.069]             }
[13:35:35.069]             {
[13:35:35.069]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:35.069]                   0L) {
[13:35:35.069]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:35.069]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:35.069]                   base::options(opts)
[13:35:35.069]                 }
[13:35:35.069]                 {
[13:35:35.069]                   {
[13:35:35.069]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:35.069]                     NULL
[13:35:35.069]                   }
[13:35:35.069]                   options(future.plan = NULL)
[13:35:35.069]                   if (is.na(NA_character_)) 
[13:35:35.069]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:35.069]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:35.069]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:35.069]                     .init = FALSE)
[13:35:35.069]                 }
[13:35:35.069]             }
[13:35:35.069]         }
[13:35:35.069]     })
[13:35:35.069]     if (FALSE) {
[13:35:35.069]         base::sink(type = "output", split = FALSE)
[13:35:35.069]         if (NA) {
[13:35:35.069]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:35.069]         }
[13:35:35.069]         else {
[13:35:35.069]             ...future.result["stdout"] <- base::list(NULL)
[13:35:35.069]         }
[13:35:35.069]         base::close(...future.stdout)
[13:35:35.069]         ...future.stdout <- NULL
[13:35:35.069]     }
[13:35:35.069]     ...future.result$conditions <- ...future.conditions
[13:35:35.069]     ...future.result$finished <- base::Sys.time()
[13:35:35.069]     ...future.result
[13:35:35.069] }
[13:35:35.072] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[13:35:35.072] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[13:35:35.072] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[13:35:35.072] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:35:35.073] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:35:35.073] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[13:35:35.073] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[13:35:35.074] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:35:35.074] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:35:35.074] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:35:35.074] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:35:35.075] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[13:35:35.075] MultisessionFuture started
[13:35:35.075] - Launch lazy future ... done
[13:35:35.075] run() for ‘MultisessionFuture’ ... done
[13:35:35.075] Created future:
[13:35:35.076] MultisessionFuture:
[13:35:35.076] Label: ‘future_lapply-2’
[13:35:35.076] Expression:
[13:35:35.076] {
[13:35:35.076]     do.call(function(...) {
[13:35:35.076]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:35.076]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:35.076]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:35.076]             on.exit(options(oopts), add = TRUE)
[13:35:35.076]         }
[13:35:35.076]         {
[13:35:35.076]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:35.076]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:35.076]                 ...future.FUN(...future.X_jj, ...)
[13:35:35.076]             })
[13:35:35.076]         }
[13:35:35.076]     }, args = future.call.arguments)
[13:35:35.076] }
[13:35:35.076] Lazy evaluation: FALSE
[13:35:35.076] Asynchronous evaluation: TRUE
[13:35:35.076] Local evaluation: TRUE
[13:35:35.076] Environment: R_GlobalEnv
[13:35:35.076] Capture standard output: NA
[13:35:35.076] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:35.076] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:35.076] Packages: <none>
[13:35:35.076] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:35.076] Resolved: FALSE
[13:35:35.076] Value: <not collected>
[13:35:35.076] Conditions captured: <none>
[13:35:35.076] Early signaling: FALSE
[13:35:35.076] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:35.076] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:35.087] Chunk #2 of 2 ... DONE
[13:35:35.087] Launching 2 futures (chunks) ... DONE
[13:35:35.087] Resolving 2 futures (chunks) ...
[13:35:35.087] resolve() on list ...
[13:35:35.087]  recursive: 0
[13:35:35.088]  length: 2
[13:35:35.088] 
[13:35:35.130] receiveMessageFromWorker() for ClusterFuture ...
[13:35:35.130] - Validating connection of MultisessionFuture
[13:35:35.130] - received message: FutureResult
[13:35:35.130] - Received FutureResult
[13:35:35.131] - Erased future from FutureRegistry
[13:35:35.131] result() for ClusterFuture ...
[13:35:35.131] - result already collected: FutureResult
[13:35:35.131] result() for ClusterFuture ... done
[13:35:35.131] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:35.131] Future #2
[13:35:35.131] result() for ClusterFuture ...
[13:35:35.131] - result already collected: FutureResult
[13:35:35.131] result() for ClusterFuture ... done
[13:35:35.131] result() for ClusterFuture ...
[13:35:35.132] - result already collected: FutureResult
[13:35:35.132] result() for ClusterFuture ... done
[13:35:35.132] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:35:35.132] - nx: 2
[13:35:35.132] - relay: TRUE
[13:35:35.132] - stdout: TRUE
[13:35:35.132] - signal: TRUE
[13:35:35.132] - resignal: FALSE
[13:35:35.132] - force: TRUE
[13:35:35.132] - relayed: [n=2] FALSE, FALSE
[13:35:35.132] - queued futures: [n=2] FALSE, FALSE
[13:35:35.132]  - until=1
[13:35:35.133]  - relaying element #1
[13:35:35.133] - relayed: [n=2] FALSE, FALSE
[13:35:35.133] - queued futures: [n=2] FALSE, TRUE
[13:35:35.133] signalConditionsASAP(NULL, pos=2) ... done
[13:35:35.133]  length: 1 (resolved future 2)
[13:35:35.581] receiveMessageFromWorker() for ClusterFuture ...
[13:35:35.581] - Validating connection of MultisessionFuture
[13:35:35.581] - received message: FutureResult
[13:35:35.581] - Received FutureResult
[13:35:35.581] - Erased future from FutureRegistry
[13:35:35.582] result() for ClusterFuture ...
[13:35:35.582] - result already collected: FutureResult
[13:35:35.582] result() for ClusterFuture ... done
[13:35:35.582] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:35.582] Future #1
[13:35:35.582] result() for ClusterFuture ...
[13:35:35.582] - result already collected: FutureResult
[13:35:35.582] result() for ClusterFuture ... done
[13:35:35.582] result() for ClusterFuture ...
[13:35:35.582] - result already collected: FutureResult
[13:35:35.582] result() for ClusterFuture ... done
[13:35:35.583] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:35:35.583] - nx: 2
[13:35:35.583] - relay: TRUE
[13:35:35.583] - stdout: TRUE
[13:35:35.583] - signal: TRUE
[13:35:35.583] - resignal: FALSE
[13:35:35.583] - force: TRUE
[13:35:35.583] - relayed: [n=2] FALSE, FALSE
[13:35:35.583] - queued futures: [n=2] FALSE, TRUE
[13:35:35.583]  - until=1
[13:35:35.583]  - relaying element #1
[13:35:35.583] result() for ClusterFuture ...
[13:35:35.584] - result already collected: FutureResult
[13:35:35.584] result() for ClusterFuture ... done
[13:35:35.584] result() for ClusterFuture ...
[13:35:35.584] - result already collected: FutureResult
[13:35:35.584] result() for ClusterFuture ... done
[13:35:35.584] result() for ClusterFuture ...
[13:35:35.584] - result already collected: FutureResult
[13:35:35.584] result() for ClusterFuture ... done
[13:35:35.584] result() for ClusterFuture ...
[13:35:35.584] - result already collected: FutureResult
[13:35:35.584] result() for ClusterFuture ... done
[13:35:35.584] - relayed: [n=2] TRUE, FALSE
[13:35:35.585] - queued futures: [n=2] TRUE, TRUE
[13:35:35.585] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:35:35.585]  length: 0 (resolved future 1)
[13:35:35.585] Relaying remaining futures
[13:35:35.585] signalConditionsASAP(NULL, pos=0) ...
[13:35:35.585] - nx: 2
[13:35:35.585] - relay: TRUE
[13:35:35.585] - stdout: TRUE
[13:35:35.585] - signal: TRUE
[13:35:35.585] - resignal: FALSE
[13:35:35.585] - force: TRUE
[13:35:35.586] - relayed: [n=2] TRUE, FALSE
[13:35:35.586] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:35.586]  - relaying element #2
[13:35:35.586] result() for ClusterFuture ...
[13:35:35.586] - result already collected: FutureResult
[13:35:35.586] result() for ClusterFuture ... done
[13:35:35.586] result() for ClusterFuture ...
[13:35:35.586] - result already collected: FutureResult
[13:35:35.586] result() for ClusterFuture ... done
[13:35:35.586] result() for ClusterFuture ...
[13:35:35.586] - result already collected: FutureResult
[13:35:35.587] result() for ClusterFuture ... done
[13:35:35.587] result() for ClusterFuture ...
[13:35:35.587] - result already collected: FutureResult
[13:35:35.587] result() for ClusterFuture ... done
[13:35:35.587] - relayed: [n=2] TRUE, TRUE
[13:35:35.587] - queued futures: [n=2] TRUE, TRUE
[13:35:35.587] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[13:35:35.587] resolve() on list ... DONE
[13:35:35.587] result() for ClusterFuture ...
[13:35:35.587] - result already collected: FutureResult
[13:35:35.587] result() for ClusterFuture ... done
[13:35:35.588] result() for ClusterFuture ...
[13:35:35.588] - result already collected: FutureResult
[13:35:35.588] result() for ClusterFuture ... done
[13:35:35.588] result() for ClusterFuture ...
[13:35:35.588] - result already collected: FutureResult
[13:35:35.588] result() for ClusterFuture ... done
[13:35:35.588] result() for ClusterFuture ...
[13:35:35.588] - result already collected: FutureResult
[13:35:35.588] result() for ClusterFuture ... done
[13:35:35.588]  - Number of value chunks collected: 2
[13:35:35.588] Resolving 2 futures (chunks) ... DONE
[13:35:35.588] Reducing values from 2 chunks ...
[13:35:35.589]  - Number of values collected after concatenation: 2
[13:35:35.589]  - Number of values expected: 2
[13:35:35.589] Reducing values from 2 chunks ... DONE
[13:35:35.589] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[13:35:35.589] future_mapply() ...
[13:35:35.593] Number of chunks: 2
[13:35:35.593] getGlobalsAndPackagesXApply() ...
[13:35:35.593]  - future.globals: TRUE
[13:35:35.593] getGlobalsAndPackages() ...
[13:35:35.593] Searching for globals...
[13:35:35.595] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:35:35.595] Searching for globals ... DONE
[13:35:35.595] Resolving globals: FALSE
[13:35:35.596] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:35:35.596] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:35:35.596] - globals: [1] ‘FUN’
[13:35:35.596] 
[13:35:35.596] getGlobalsAndPackages() ... DONE
[13:35:35.596]  - globals found/used: [n=1] ‘FUN’
[13:35:35.596]  - needed namespaces: [n=0] 
[13:35:35.597] Finding globals ... DONE
[13:35:35.597] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:35:35.597] List of 2
[13:35:35.597]  $ ...future.FUN:function (x, y)  
[13:35:35.597]  $ MoreArgs     : NULL
[13:35:35.597]  - attr(*, "where")=List of 2
[13:35:35.597]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:35.597]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:35:35.597]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:35.597]  - attr(*, "resolved")= logi FALSE
[13:35:35.597]  - attr(*, "total_size")= num NA
[13:35:35.599] Packages to be attached in all futures: [n=0] 
[13:35:35.599] getGlobalsAndPackagesXApply() ... DONE
[13:35:35.600] Number of futures (= number of chunks): 2
[13:35:35.600] Launching 2 futures (chunks) ...
[13:35:35.600] Chunk #1 of 2 ...
[13:35:35.600]  - Finding globals in '...' for chunk #1 ...
[13:35:35.600] getGlobalsAndPackages() ...
[13:35:35.600] Searching for globals...
[13:35:35.600] 
[13:35:35.601] Searching for globals ... DONE
[13:35:35.601] - globals: [0] <none>
[13:35:35.603] getGlobalsAndPackages() ... DONE
[13:35:35.603]    + additional globals found: [n=0] 
[13:35:35.603]    + additional namespaces needed: [n=0] 
[13:35:35.603]  - Finding globals in '...' for chunk #1 ... DONE
[13:35:35.603]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:35.603]  - seeds: <none>
[13:35:35.604]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:35.604] getGlobalsAndPackages() ...
[13:35:35.604] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:35.604] Resolving globals: FALSE
[13:35:35.604] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:35:35.605] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:35:35.605] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:35.605] 
[13:35:35.605] getGlobalsAndPackages() ... DONE
[13:35:35.605] run() for ‘Future’ ...
[13:35:35.605] - state: ‘created’
[13:35:35.606] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:35.619] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:35.619] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:35.620]   - Field: ‘node’
[13:35:35.620]   - Field: ‘label’
[13:35:35.620]   - Field: ‘local’
[13:35:35.620]   - Field: ‘owner’
[13:35:35.620]   - Field: ‘envir’
[13:35:35.620]   - Field: ‘workers’
[13:35:35.620]   - Field: ‘packages’
[13:35:35.620]   - Field: ‘gc’
[13:35:35.620]   - Field: ‘conditions’
[13:35:35.620]   - Field: ‘persistent’
[13:35:35.620]   - Field: ‘expr’
[13:35:35.621]   - Field: ‘uuid’
[13:35:35.621]   - Field: ‘seed’
[13:35:35.621]   - Field: ‘version’
[13:35:35.621]   - Field: ‘result’
[13:35:35.621]   - Field: ‘asynchronous’
[13:35:35.621]   - Field: ‘calls’
[13:35:35.621]   - Field: ‘globals’
[13:35:35.621]   - Field: ‘stdout’
[13:35:35.621]   - Field: ‘earlySignal’
[13:35:35.621]   - Field: ‘lazy’
[13:35:35.621]   - Field: ‘state’
[13:35:35.622] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:35.622] - Launch lazy future ...
[13:35:35.622] Packages needed by the future expression (n = 0): <none>
[13:35:35.622] Packages needed by future strategies (n = 0): <none>
[13:35:35.622] {
[13:35:35.622]     {
[13:35:35.622]         {
[13:35:35.622]             ...future.startTime <- base::Sys.time()
[13:35:35.622]             {
[13:35:35.622]                 {
[13:35:35.622]                   {
[13:35:35.622]                     {
[13:35:35.622]                       base::local({
[13:35:35.622]                         has_future <- base::requireNamespace("future", 
[13:35:35.622]                           quietly = TRUE)
[13:35:35.622]                         if (has_future) {
[13:35:35.622]                           ns <- base::getNamespace("future")
[13:35:35.622]                           version <- ns[[".package"]][["version"]]
[13:35:35.622]                           if (is.null(version)) 
[13:35:35.622]                             version <- utils::packageVersion("future")
[13:35:35.622]                         }
[13:35:35.622]                         else {
[13:35:35.622]                           version <- NULL
[13:35:35.622]                         }
[13:35:35.622]                         if (!has_future || version < "1.8.0") {
[13:35:35.622]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:35.622]                             "", base::R.version$version.string), 
[13:35:35.622]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:35.622]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:35.622]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:35.622]                               "release", "version")], collapse = " "), 
[13:35:35.622]                             hostname = base::Sys.info()[["nodename"]])
[13:35:35.622]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:35.622]                             info)
[13:35:35.622]                           info <- base::paste(info, collapse = "; ")
[13:35:35.622]                           if (!has_future) {
[13:35:35.622]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:35.622]                               info)
[13:35:35.622]                           }
[13:35:35.622]                           else {
[13:35:35.622]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:35.622]                               info, version)
[13:35:35.622]                           }
[13:35:35.622]                           base::stop(msg)
[13:35:35.622]                         }
[13:35:35.622]                       })
[13:35:35.622]                     }
[13:35:35.622]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:35.622]                     base::options(mc.cores = 1L)
[13:35:35.622]                   }
[13:35:35.622]                   ...future.strategy.old <- future::plan("list")
[13:35:35.622]                   options(future.plan = NULL)
[13:35:35.622]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:35.622]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:35.622]                 }
[13:35:35.622]                 ...future.workdir <- getwd()
[13:35:35.622]             }
[13:35:35.622]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:35.622]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:35.622]         }
[13:35:35.622]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:35.622]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:35.622]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:35.622]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:35.622]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:35.622]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:35.622]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:35.622]             base::names(...future.oldOptions))
[13:35:35.622]     }
[13:35:35.622]     if (FALSE) {
[13:35:35.622]     }
[13:35:35.622]     else {
[13:35:35.622]         if (FALSE) {
[13:35:35.622]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:35.622]                 open = "w")
[13:35:35.622]         }
[13:35:35.622]         else {
[13:35:35.622]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:35.622]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:35.622]         }
[13:35:35.622]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:35.622]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:35.622]             base::sink(type = "output", split = FALSE)
[13:35:35.622]             base::close(...future.stdout)
[13:35:35.622]         }, add = TRUE)
[13:35:35.622]     }
[13:35:35.622]     ...future.frame <- base::sys.nframe()
[13:35:35.622]     ...future.conditions <- base::list()
[13:35:35.622]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:35.622]     if (FALSE) {
[13:35:35.622]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:35.622]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:35.622]     }
[13:35:35.622]     ...future.result <- base::tryCatch({
[13:35:35.622]         base::withCallingHandlers({
[13:35:35.622]             ...future.value <- base::withVisible(base::local({
[13:35:35.622]                 ...future.makeSendCondition <- base::local({
[13:35:35.622]                   sendCondition <- NULL
[13:35:35.622]                   function(frame = 1L) {
[13:35:35.622]                     if (is.function(sendCondition)) 
[13:35:35.622]                       return(sendCondition)
[13:35:35.622]                     ns <- getNamespace("parallel")
[13:35:35.622]                     if (exists("sendData", mode = "function", 
[13:35:35.622]                       envir = ns)) {
[13:35:35.622]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:35.622]                         envir = ns)
[13:35:35.622]                       envir <- sys.frame(frame)
[13:35:35.622]                       master <- NULL
[13:35:35.622]                       while (!identical(envir, .GlobalEnv) && 
[13:35:35.622]                         !identical(envir, emptyenv())) {
[13:35:35.622]                         if (exists("master", mode = "list", envir = envir, 
[13:35:35.622]                           inherits = FALSE)) {
[13:35:35.622]                           master <- get("master", mode = "list", 
[13:35:35.622]                             envir = envir, inherits = FALSE)
[13:35:35.622]                           if (inherits(master, c("SOCKnode", 
[13:35:35.622]                             "SOCK0node"))) {
[13:35:35.622]                             sendCondition <<- function(cond) {
[13:35:35.622]                               data <- list(type = "VALUE", value = cond, 
[13:35:35.622]                                 success = TRUE)
[13:35:35.622]                               parallel_sendData(master, data)
[13:35:35.622]                             }
[13:35:35.622]                             return(sendCondition)
[13:35:35.622]                           }
[13:35:35.622]                         }
[13:35:35.622]                         frame <- frame + 1L
[13:35:35.622]                         envir <- sys.frame(frame)
[13:35:35.622]                       }
[13:35:35.622]                     }
[13:35:35.622]                     sendCondition <<- function(cond) NULL
[13:35:35.622]                   }
[13:35:35.622]                 })
[13:35:35.622]                 withCallingHandlers({
[13:35:35.622]                   {
[13:35:35.622]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:35.622]                     if (!identical(...future.globals.maxSize.org, 
[13:35:35.622]                       ...future.globals.maxSize)) {
[13:35:35.622]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:35.622]                       on.exit(options(oopts), add = TRUE)
[13:35:35.622]                     }
[13:35:35.622]                     {
[13:35:35.622]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:35.622]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:35:35.622]                         USE.NAMES = FALSE)
[13:35:35.622]                       do.call(mapply, args = args)
[13:35:35.622]                     }
[13:35:35.622]                   }
[13:35:35.622]                 }, immediateCondition = function(cond) {
[13:35:35.622]                   sendCondition <- ...future.makeSendCondition()
[13:35:35.622]                   sendCondition(cond)
[13:35:35.622]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:35.622]                   {
[13:35:35.622]                     inherits <- base::inherits
[13:35:35.622]                     invokeRestart <- base::invokeRestart
[13:35:35.622]                     is.null <- base::is.null
[13:35:35.622]                     muffled <- FALSE
[13:35:35.622]                     if (inherits(cond, "message")) {
[13:35:35.622]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:35.622]                       if (muffled) 
[13:35:35.622]                         invokeRestart("muffleMessage")
[13:35:35.622]                     }
[13:35:35.622]                     else if (inherits(cond, "warning")) {
[13:35:35.622]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:35.622]                       if (muffled) 
[13:35:35.622]                         invokeRestart("muffleWarning")
[13:35:35.622]                     }
[13:35:35.622]                     else if (inherits(cond, "condition")) {
[13:35:35.622]                       if (!is.null(pattern)) {
[13:35:35.622]                         computeRestarts <- base::computeRestarts
[13:35:35.622]                         grepl <- base::grepl
[13:35:35.622]                         restarts <- computeRestarts(cond)
[13:35:35.622]                         for (restart in restarts) {
[13:35:35.622]                           name <- restart$name
[13:35:35.622]                           if (is.null(name)) 
[13:35:35.622]                             next
[13:35:35.622]                           if (!grepl(pattern, name)) 
[13:35:35.622]                             next
[13:35:35.622]                           invokeRestart(restart)
[13:35:35.622]                           muffled <- TRUE
[13:35:35.622]                           break
[13:35:35.622]                         }
[13:35:35.622]                       }
[13:35:35.622]                     }
[13:35:35.622]                     invisible(muffled)
[13:35:35.622]                   }
[13:35:35.622]                   muffleCondition(cond)
[13:35:35.622]                 })
[13:35:35.622]             }))
[13:35:35.622]             future::FutureResult(value = ...future.value$value, 
[13:35:35.622]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:35.622]                   ...future.rng), globalenv = if (FALSE) 
[13:35:35.622]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:35.622]                     ...future.globalenv.names))
[13:35:35.622]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:35.622]         }, condition = base::local({
[13:35:35.622]             c <- base::c
[13:35:35.622]             inherits <- base::inherits
[13:35:35.622]             invokeRestart <- base::invokeRestart
[13:35:35.622]             length <- base::length
[13:35:35.622]             list <- base::list
[13:35:35.622]             seq.int <- base::seq.int
[13:35:35.622]             signalCondition <- base::signalCondition
[13:35:35.622]             sys.calls <- base::sys.calls
[13:35:35.622]             `[[` <- base::`[[`
[13:35:35.622]             `+` <- base::`+`
[13:35:35.622]             `<<-` <- base::`<<-`
[13:35:35.622]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:35.622]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:35.622]                   3L)]
[13:35:35.622]             }
[13:35:35.622]             function(cond) {
[13:35:35.622]                 is_error <- inherits(cond, "error")
[13:35:35.622]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:35.622]                   NULL)
[13:35:35.622]                 if (is_error) {
[13:35:35.622]                   sessionInformation <- function() {
[13:35:35.622]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:35.622]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:35.622]                       search = base::search(), system = base::Sys.info())
[13:35:35.622]                   }
[13:35:35.622]                   ...future.conditions[[length(...future.conditions) + 
[13:35:35.622]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:35.622]                     cond$call), session = sessionInformation(), 
[13:35:35.622]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:35.622]                   signalCondition(cond)
[13:35:35.622]                 }
[13:35:35.622]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:35.622]                 "immediateCondition"))) {
[13:35:35.622]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:35.622]                   ...future.conditions[[length(...future.conditions) + 
[13:35:35.622]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:35.622]                   if (TRUE && !signal) {
[13:35:35.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:35.622]                     {
[13:35:35.622]                       inherits <- base::inherits
[13:35:35.622]                       invokeRestart <- base::invokeRestart
[13:35:35.622]                       is.null <- base::is.null
[13:35:35.622]                       muffled <- FALSE
[13:35:35.622]                       if (inherits(cond, "message")) {
[13:35:35.622]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:35.622]                         if (muffled) 
[13:35:35.622]                           invokeRestart("muffleMessage")
[13:35:35.622]                       }
[13:35:35.622]                       else if (inherits(cond, "warning")) {
[13:35:35.622]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:35.622]                         if (muffled) 
[13:35:35.622]                           invokeRestart("muffleWarning")
[13:35:35.622]                       }
[13:35:35.622]                       else if (inherits(cond, "condition")) {
[13:35:35.622]                         if (!is.null(pattern)) {
[13:35:35.622]                           computeRestarts <- base::computeRestarts
[13:35:35.622]                           grepl <- base::grepl
[13:35:35.622]                           restarts <- computeRestarts(cond)
[13:35:35.622]                           for (restart in restarts) {
[13:35:35.622]                             name <- restart$name
[13:35:35.622]                             if (is.null(name)) 
[13:35:35.622]                               next
[13:35:35.622]                             if (!grepl(pattern, name)) 
[13:35:35.622]                               next
[13:35:35.622]                             invokeRestart(restart)
[13:35:35.622]                             muffled <- TRUE
[13:35:35.622]                             break
[13:35:35.622]                           }
[13:35:35.622]                         }
[13:35:35.622]                       }
[13:35:35.622]                       invisible(muffled)
[13:35:35.622]                     }
[13:35:35.622]                     muffleCondition(cond, pattern = "^muffle")
[13:35:35.622]                   }
[13:35:35.622]                 }
[13:35:35.622]                 else {
[13:35:35.622]                   if (TRUE) {
[13:35:35.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:35.622]                     {
[13:35:35.622]                       inherits <- base::inherits
[13:35:35.622]                       invokeRestart <- base::invokeRestart
[13:35:35.622]                       is.null <- base::is.null
[13:35:35.622]                       muffled <- FALSE
[13:35:35.622]                       if (inherits(cond, "message")) {
[13:35:35.622]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:35.622]                         if (muffled) 
[13:35:35.622]                           invokeRestart("muffleMessage")
[13:35:35.622]                       }
[13:35:35.622]                       else if (inherits(cond, "warning")) {
[13:35:35.622]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:35.622]                         if (muffled) 
[13:35:35.622]                           invokeRestart("muffleWarning")
[13:35:35.622]                       }
[13:35:35.622]                       else if (inherits(cond, "condition")) {
[13:35:35.622]                         if (!is.null(pattern)) {
[13:35:35.622]                           computeRestarts <- base::computeRestarts
[13:35:35.622]                           grepl <- base::grepl
[13:35:35.622]                           restarts <- computeRestarts(cond)
[13:35:35.622]                           for (restart in restarts) {
[13:35:35.622]                             name <- restart$name
[13:35:35.622]                             if (is.null(name)) 
[13:35:35.622]                               next
[13:35:35.622]                             if (!grepl(pattern, name)) 
[13:35:35.622]                               next
[13:35:35.622]                             invokeRestart(restart)
[13:35:35.622]                             muffled <- TRUE
[13:35:35.622]                             break
[13:35:35.622]                           }
[13:35:35.622]                         }
[13:35:35.622]                       }
[13:35:35.622]                       invisible(muffled)
[13:35:35.622]                     }
[13:35:35.622]                     muffleCondition(cond, pattern = "^muffle")
[13:35:35.622]                   }
[13:35:35.622]                 }
[13:35:35.622]             }
[13:35:35.622]         }))
[13:35:35.622]     }, error = function(ex) {
[13:35:35.622]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:35.622]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:35.622]                 ...future.rng), started = ...future.startTime, 
[13:35:35.622]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:35.622]             version = "1.8"), class = "FutureResult")
[13:35:35.622]     }, finally = {
[13:35:35.622]         if (!identical(...future.workdir, getwd())) 
[13:35:35.622]             setwd(...future.workdir)
[13:35:35.622]         {
[13:35:35.622]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:35.622]                 ...future.oldOptions$nwarnings <- NULL
[13:35:35.622]             }
[13:35:35.622]             base::options(...future.oldOptions)
[13:35:35.622]             if (.Platform$OS.type == "windows") {
[13:35:35.622]                 old_names <- names(...future.oldEnvVars)
[13:35:35.622]                 envs <- base::Sys.getenv()
[13:35:35.622]                 names <- names(envs)
[13:35:35.622]                 common <- intersect(names, old_names)
[13:35:35.622]                 added <- setdiff(names, old_names)
[13:35:35.622]                 removed <- setdiff(old_names, names)
[13:35:35.622]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:35.622]                   envs[common]]
[13:35:35.622]                 NAMES <- toupper(changed)
[13:35:35.622]                 args <- list()
[13:35:35.622]                 for (kk in seq_along(NAMES)) {
[13:35:35.622]                   name <- changed[[kk]]
[13:35:35.622]                   NAME <- NAMES[[kk]]
[13:35:35.622]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:35.622]                     next
[13:35:35.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:35.622]                 }
[13:35:35.622]                 NAMES <- toupper(added)
[13:35:35.622]                 for (kk in seq_along(NAMES)) {
[13:35:35.622]                   name <- added[[kk]]
[13:35:35.622]                   NAME <- NAMES[[kk]]
[13:35:35.622]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:35.622]                     next
[13:35:35.622]                   args[[name]] <- ""
[13:35:35.622]                 }
[13:35:35.622]                 NAMES <- toupper(removed)
[13:35:35.622]                 for (kk in seq_along(NAMES)) {
[13:35:35.622]                   name <- removed[[kk]]
[13:35:35.622]                   NAME <- NAMES[[kk]]
[13:35:35.622]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:35.622]                     next
[13:35:35.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:35.622]                 }
[13:35:35.622]                 if (length(args) > 0) 
[13:35:35.622]                   base::do.call(base::Sys.setenv, args = args)
[13:35:35.622]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:35.622]             }
[13:35:35.622]             else {
[13:35:35.622]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:35.622]             }
[13:35:35.622]             {
[13:35:35.622]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:35.622]                   0L) {
[13:35:35.622]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:35.622]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:35.622]                   base::options(opts)
[13:35:35.622]                 }
[13:35:35.622]                 {
[13:35:35.622]                   {
[13:35:35.622]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:35.622]                     NULL
[13:35:35.622]                   }
[13:35:35.622]                   options(future.plan = NULL)
[13:35:35.622]                   if (is.na(NA_character_)) 
[13:35:35.622]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:35.622]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:35.622]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:35.622]                     .init = FALSE)
[13:35:35.622]                 }
[13:35:35.622]             }
[13:35:35.622]         }
[13:35:35.622]     })
[13:35:35.622]     if (TRUE) {
[13:35:35.622]         base::sink(type = "output", split = FALSE)
[13:35:35.622]         if (FALSE) {
[13:35:35.622]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:35.622]         }
[13:35:35.622]         else {
[13:35:35.622]             ...future.result["stdout"] <- base::list(NULL)
[13:35:35.622]         }
[13:35:35.622]         base::close(...future.stdout)
[13:35:35.622]         ...future.stdout <- NULL
[13:35:35.622]     }
[13:35:35.622]     ...future.result$conditions <- ...future.conditions
[13:35:35.622]     ...future.result$finished <- base::Sys.time()
[13:35:35.622]     ...future.result
[13:35:35.622] }
[13:35:35.625] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[13:35:35.625] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[13:35:35.626] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[13:35:35.626] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:35:35.626] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:35:35.626] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[13:35:35.627] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[13:35:35.627] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:35.627] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:35.627] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:35.628] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:35.628] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[13:35:35.628] MultisessionFuture started
[13:35:35.628] - Launch lazy future ... done
[13:35:35.628] run() for ‘MultisessionFuture’ ... done
[13:35:35.629] Created future:
[13:35:35.629] MultisessionFuture:
[13:35:35.629] Label: ‘future_mapply-1’
[13:35:35.629] Expression:
[13:35:35.629] {
[13:35:35.629]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:35.629]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:35.629]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:35.629]         on.exit(options(oopts), add = TRUE)
[13:35:35.629]     }
[13:35:35.629]     {
[13:35:35.629]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:35.629]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:35:35.629]         do.call(mapply, args = args)
[13:35:35.629]     }
[13:35:35.629] }
[13:35:35.629] Lazy evaluation: FALSE
[13:35:35.629] Asynchronous evaluation: TRUE
[13:35:35.629] Local evaluation: TRUE
[13:35:35.629] Environment: R_GlobalEnv
[13:35:35.629] Capture standard output: FALSE
[13:35:35.629] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:35.629] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:35.629] Packages: <none>
[13:35:35.629] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:35.629] Resolved: FALSE
[13:35:35.629] Value: <not collected>
[13:35:35.629] Conditions captured: <none>
[13:35:35.629] Early signaling: FALSE
[13:35:35.629] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:35.629] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:35.640] Chunk #1 of 2 ... DONE
[13:35:35.640] Chunk #2 of 2 ...
[13:35:35.640]  - Finding globals in '...' for chunk #2 ...
[13:35:35.640] getGlobalsAndPackages() ...
[13:35:35.640] Searching for globals...
[13:35:35.641] 
[13:35:35.641] Searching for globals ... DONE
[13:35:35.641] - globals: [0] <none>
[13:35:35.641] getGlobalsAndPackages() ... DONE
[13:35:35.641]    + additional globals found: [n=0] 
[13:35:35.641]    + additional namespaces needed: [n=0] 
[13:35:35.641]  - Finding globals in '...' for chunk #2 ... DONE
[13:35:35.641]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:35.641]  - seeds: <none>
[13:35:35.642]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:35.642] getGlobalsAndPackages() ...
[13:35:35.642] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:35.642] Resolving globals: FALSE
[13:35:35.642] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:35:35.643] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:35:35.643] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:35.643] 
[13:35:35.643] getGlobalsAndPackages() ... DONE
[13:35:35.643] run() for ‘Future’ ...
[13:35:35.643] - state: ‘created’
[13:35:35.644] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:35.658] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:35.658] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:35.658]   - Field: ‘node’
[13:35:35.658]   - Field: ‘label’
[13:35:35.658]   - Field: ‘local’
[13:35:35.658]   - Field: ‘owner’
[13:35:35.658]   - Field: ‘envir’
[13:35:35.658]   - Field: ‘workers’
[13:35:35.659]   - Field: ‘packages’
[13:35:35.659]   - Field: ‘gc’
[13:35:35.659]   - Field: ‘conditions’
[13:35:35.659]   - Field: ‘persistent’
[13:35:35.659]   - Field: ‘expr’
[13:35:35.659]   - Field: ‘uuid’
[13:35:35.659]   - Field: ‘seed’
[13:35:35.659]   - Field: ‘version’
[13:35:35.659]   - Field: ‘result’
[13:35:35.659]   - Field: ‘asynchronous’
[13:35:35.659]   - Field: ‘calls’
[13:35:35.660]   - Field: ‘globals’
[13:35:35.660]   - Field: ‘stdout’
[13:35:35.660]   - Field: ‘earlySignal’
[13:35:35.660]   - Field: ‘lazy’
[13:35:35.660]   - Field: ‘state’
[13:35:35.660] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:35.660] - Launch lazy future ...
[13:35:35.660] Packages needed by the future expression (n = 0): <none>
[13:35:35.660] Packages needed by future strategies (n = 0): <none>
[13:35:35.661] {
[13:35:35.661]     {
[13:35:35.661]         {
[13:35:35.661]             ...future.startTime <- base::Sys.time()
[13:35:35.661]             {
[13:35:35.661]                 {
[13:35:35.661]                   {
[13:35:35.661]                     {
[13:35:35.661]                       base::local({
[13:35:35.661]                         has_future <- base::requireNamespace("future", 
[13:35:35.661]                           quietly = TRUE)
[13:35:35.661]                         if (has_future) {
[13:35:35.661]                           ns <- base::getNamespace("future")
[13:35:35.661]                           version <- ns[[".package"]][["version"]]
[13:35:35.661]                           if (is.null(version)) 
[13:35:35.661]                             version <- utils::packageVersion("future")
[13:35:35.661]                         }
[13:35:35.661]                         else {
[13:35:35.661]                           version <- NULL
[13:35:35.661]                         }
[13:35:35.661]                         if (!has_future || version < "1.8.0") {
[13:35:35.661]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:35.661]                             "", base::R.version$version.string), 
[13:35:35.661]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:35.661]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:35.661]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:35.661]                               "release", "version")], collapse = " "), 
[13:35:35.661]                             hostname = base::Sys.info()[["nodename"]])
[13:35:35.661]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:35.661]                             info)
[13:35:35.661]                           info <- base::paste(info, collapse = "; ")
[13:35:35.661]                           if (!has_future) {
[13:35:35.661]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:35.661]                               info)
[13:35:35.661]                           }
[13:35:35.661]                           else {
[13:35:35.661]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:35.661]                               info, version)
[13:35:35.661]                           }
[13:35:35.661]                           base::stop(msg)
[13:35:35.661]                         }
[13:35:35.661]                       })
[13:35:35.661]                     }
[13:35:35.661]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:35.661]                     base::options(mc.cores = 1L)
[13:35:35.661]                   }
[13:35:35.661]                   ...future.strategy.old <- future::plan("list")
[13:35:35.661]                   options(future.plan = NULL)
[13:35:35.661]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:35.661]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:35.661]                 }
[13:35:35.661]                 ...future.workdir <- getwd()
[13:35:35.661]             }
[13:35:35.661]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:35.661]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:35.661]         }
[13:35:35.661]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:35.661]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:35.661]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:35.661]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:35.661]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:35.661]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:35.661]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:35.661]             base::names(...future.oldOptions))
[13:35:35.661]     }
[13:35:35.661]     if (FALSE) {
[13:35:35.661]     }
[13:35:35.661]     else {
[13:35:35.661]         if (FALSE) {
[13:35:35.661]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:35.661]                 open = "w")
[13:35:35.661]         }
[13:35:35.661]         else {
[13:35:35.661]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:35.661]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:35.661]         }
[13:35:35.661]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:35.661]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:35.661]             base::sink(type = "output", split = FALSE)
[13:35:35.661]             base::close(...future.stdout)
[13:35:35.661]         }, add = TRUE)
[13:35:35.661]     }
[13:35:35.661]     ...future.frame <- base::sys.nframe()
[13:35:35.661]     ...future.conditions <- base::list()
[13:35:35.661]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:35.661]     if (FALSE) {
[13:35:35.661]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:35.661]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:35.661]     }
[13:35:35.661]     ...future.result <- base::tryCatch({
[13:35:35.661]         base::withCallingHandlers({
[13:35:35.661]             ...future.value <- base::withVisible(base::local({
[13:35:35.661]                 ...future.makeSendCondition <- base::local({
[13:35:35.661]                   sendCondition <- NULL
[13:35:35.661]                   function(frame = 1L) {
[13:35:35.661]                     if (is.function(sendCondition)) 
[13:35:35.661]                       return(sendCondition)
[13:35:35.661]                     ns <- getNamespace("parallel")
[13:35:35.661]                     if (exists("sendData", mode = "function", 
[13:35:35.661]                       envir = ns)) {
[13:35:35.661]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:35.661]                         envir = ns)
[13:35:35.661]                       envir <- sys.frame(frame)
[13:35:35.661]                       master <- NULL
[13:35:35.661]                       while (!identical(envir, .GlobalEnv) && 
[13:35:35.661]                         !identical(envir, emptyenv())) {
[13:35:35.661]                         if (exists("master", mode = "list", envir = envir, 
[13:35:35.661]                           inherits = FALSE)) {
[13:35:35.661]                           master <- get("master", mode = "list", 
[13:35:35.661]                             envir = envir, inherits = FALSE)
[13:35:35.661]                           if (inherits(master, c("SOCKnode", 
[13:35:35.661]                             "SOCK0node"))) {
[13:35:35.661]                             sendCondition <<- function(cond) {
[13:35:35.661]                               data <- list(type = "VALUE", value = cond, 
[13:35:35.661]                                 success = TRUE)
[13:35:35.661]                               parallel_sendData(master, data)
[13:35:35.661]                             }
[13:35:35.661]                             return(sendCondition)
[13:35:35.661]                           }
[13:35:35.661]                         }
[13:35:35.661]                         frame <- frame + 1L
[13:35:35.661]                         envir <- sys.frame(frame)
[13:35:35.661]                       }
[13:35:35.661]                     }
[13:35:35.661]                     sendCondition <<- function(cond) NULL
[13:35:35.661]                   }
[13:35:35.661]                 })
[13:35:35.661]                 withCallingHandlers({
[13:35:35.661]                   {
[13:35:35.661]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:35.661]                     if (!identical(...future.globals.maxSize.org, 
[13:35:35.661]                       ...future.globals.maxSize)) {
[13:35:35.661]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:35.661]                       on.exit(options(oopts), add = TRUE)
[13:35:35.661]                     }
[13:35:35.661]                     {
[13:35:35.661]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:35.661]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:35:35.661]                         USE.NAMES = FALSE)
[13:35:35.661]                       do.call(mapply, args = args)
[13:35:35.661]                     }
[13:35:35.661]                   }
[13:35:35.661]                 }, immediateCondition = function(cond) {
[13:35:35.661]                   sendCondition <- ...future.makeSendCondition()
[13:35:35.661]                   sendCondition(cond)
[13:35:35.661]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:35.661]                   {
[13:35:35.661]                     inherits <- base::inherits
[13:35:35.661]                     invokeRestart <- base::invokeRestart
[13:35:35.661]                     is.null <- base::is.null
[13:35:35.661]                     muffled <- FALSE
[13:35:35.661]                     if (inherits(cond, "message")) {
[13:35:35.661]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:35.661]                       if (muffled) 
[13:35:35.661]                         invokeRestart("muffleMessage")
[13:35:35.661]                     }
[13:35:35.661]                     else if (inherits(cond, "warning")) {
[13:35:35.661]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:35.661]                       if (muffled) 
[13:35:35.661]                         invokeRestart("muffleWarning")
[13:35:35.661]                     }
[13:35:35.661]                     else if (inherits(cond, "condition")) {
[13:35:35.661]                       if (!is.null(pattern)) {
[13:35:35.661]                         computeRestarts <- base::computeRestarts
[13:35:35.661]                         grepl <- base::grepl
[13:35:35.661]                         restarts <- computeRestarts(cond)
[13:35:35.661]                         for (restart in restarts) {
[13:35:35.661]                           name <- restart$name
[13:35:35.661]                           if (is.null(name)) 
[13:35:35.661]                             next
[13:35:35.661]                           if (!grepl(pattern, name)) 
[13:35:35.661]                             next
[13:35:35.661]                           invokeRestart(restart)
[13:35:35.661]                           muffled <- TRUE
[13:35:35.661]                           break
[13:35:35.661]                         }
[13:35:35.661]                       }
[13:35:35.661]                     }
[13:35:35.661]                     invisible(muffled)
[13:35:35.661]                   }
[13:35:35.661]                   muffleCondition(cond)
[13:35:35.661]                 })
[13:35:35.661]             }))
[13:35:35.661]             future::FutureResult(value = ...future.value$value, 
[13:35:35.661]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:35.661]                   ...future.rng), globalenv = if (FALSE) 
[13:35:35.661]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:35.661]                     ...future.globalenv.names))
[13:35:35.661]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:35.661]         }, condition = base::local({
[13:35:35.661]             c <- base::c
[13:35:35.661]             inherits <- base::inherits
[13:35:35.661]             invokeRestart <- base::invokeRestart
[13:35:35.661]             length <- base::length
[13:35:35.661]             list <- base::list
[13:35:35.661]             seq.int <- base::seq.int
[13:35:35.661]             signalCondition <- base::signalCondition
[13:35:35.661]             sys.calls <- base::sys.calls
[13:35:35.661]             `[[` <- base::`[[`
[13:35:35.661]             `+` <- base::`+`
[13:35:35.661]             `<<-` <- base::`<<-`
[13:35:35.661]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:35.661]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:35.661]                   3L)]
[13:35:35.661]             }
[13:35:35.661]             function(cond) {
[13:35:35.661]                 is_error <- inherits(cond, "error")
[13:35:35.661]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:35.661]                   NULL)
[13:35:35.661]                 if (is_error) {
[13:35:35.661]                   sessionInformation <- function() {
[13:35:35.661]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:35.661]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:35.661]                       search = base::search(), system = base::Sys.info())
[13:35:35.661]                   }
[13:35:35.661]                   ...future.conditions[[length(...future.conditions) + 
[13:35:35.661]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:35.661]                     cond$call), session = sessionInformation(), 
[13:35:35.661]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:35.661]                   signalCondition(cond)
[13:35:35.661]                 }
[13:35:35.661]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:35.661]                 "immediateCondition"))) {
[13:35:35.661]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:35.661]                   ...future.conditions[[length(...future.conditions) + 
[13:35:35.661]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:35.661]                   if (TRUE && !signal) {
[13:35:35.661]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:35.661]                     {
[13:35:35.661]                       inherits <- base::inherits
[13:35:35.661]                       invokeRestart <- base::invokeRestart
[13:35:35.661]                       is.null <- base::is.null
[13:35:35.661]                       muffled <- FALSE
[13:35:35.661]                       if (inherits(cond, "message")) {
[13:35:35.661]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:35.661]                         if (muffled) 
[13:35:35.661]                           invokeRestart("muffleMessage")
[13:35:35.661]                       }
[13:35:35.661]                       else if (inherits(cond, "warning")) {
[13:35:35.661]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:35.661]                         if (muffled) 
[13:35:35.661]                           invokeRestart("muffleWarning")
[13:35:35.661]                       }
[13:35:35.661]                       else if (inherits(cond, "condition")) {
[13:35:35.661]                         if (!is.null(pattern)) {
[13:35:35.661]                           computeRestarts <- base::computeRestarts
[13:35:35.661]                           grepl <- base::grepl
[13:35:35.661]                           restarts <- computeRestarts(cond)
[13:35:35.661]                           for (restart in restarts) {
[13:35:35.661]                             name <- restart$name
[13:35:35.661]                             if (is.null(name)) 
[13:35:35.661]                               next
[13:35:35.661]                             if (!grepl(pattern, name)) 
[13:35:35.661]                               next
[13:35:35.661]                             invokeRestart(restart)
[13:35:35.661]                             muffled <- TRUE
[13:35:35.661]                             break
[13:35:35.661]                           }
[13:35:35.661]                         }
[13:35:35.661]                       }
[13:35:35.661]                       invisible(muffled)
[13:35:35.661]                     }
[13:35:35.661]                     muffleCondition(cond, pattern = "^muffle")
[13:35:35.661]                   }
[13:35:35.661]                 }
[13:35:35.661]                 else {
[13:35:35.661]                   if (TRUE) {
[13:35:35.661]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:35.661]                     {
[13:35:35.661]                       inherits <- base::inherits
[13:35:35.661]                       invokeRestart <- base::invokeRestart
[13:35:35.661]                       is.null <- base::is.null
[13:35:35.661]                       muffled <- FALSE
[13:35:35.661]                       if (inherits(cond, "message")) {
[13:35:35.661]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:35.661]                         if (muffled) 
[13:35:35.661]                           invokeRestart("muffleMessage")
[13:35:35.661]                       }
[13:35:35.661]                       else if (inherits(cond, "warning")) {
[13:35:35.661]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:35.661]                         if (muffled) 
[13:35:35.661]                           invokeRestart("muffleWarning")
[13:35:35.661]                       }
[13:35:35.661]                       else if (inherits(cond, "condition")) {
[13:35:35.661]                         if (!is.null(pattern)) {
[13:35:35.661]                           computeRestarts <- base::computeRestarts
[13:35:35.661]                           grepl <- base::grepl
[13:35:35.661]                           restarts <- computeRestarts(cond)
[13:35:35.661]                           for (restart in restarts) {
[13:35:35.661]                             name <- restart$name
[13:35:35.661]                             if (is.null(name)) 
[13:35:35.661]                               next
[13:35:35.661]                             if (!grepl(pattern, name)) 
[13:35:35.661]                               next
[13:35:35.661]                             invokeRestart(restart)
[13:35:35.661]                             muffled <- TRUE
[13:35:35.661]                             break
[13:35:35.661]                           }
[13:35:35.661]                         }
[13:35:35.661]                       }
[13:35:35.661]                       invisible(muffled)
[13:35:35.661]                     }
[13:35:35.661]                     muffleCondition(cond, pattern = "^muffle")
[13:35:35.661]                   }
[13:35:35.661]                 }
[13:35:35.661]             }
[13:35:35.661]         }))
[13:35:35.661]     }, error = function(ex) {
[13:35:35.661]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:35.661]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:35.661]                 ...future.rng), started = ...future.startTime, 
[13:35:35.661]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:35.661]             version = "1.8"), class = "FutureResult")
[13:35:35.661]     }, finally = {
[13:35:35.661]         if (!identical(...future.workdir, getwd())) 
[13:35:35.661]             setwd(...future.workdir)
[13:35:35.661]         {
[13:35:35.661]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:35.661]                 ...future.oldOptions$nwarnings <- NULL
[13:35:35.661]             }
[13:35:35.661]             base::options(...future.oldOptions)
[13:35:35.661]             if (.Platform$OS.type == "windows") {
[13:35:35.661]                 old_names <- names(...future.oldEnvVars)
[13:35:35.661]                 envs <- base::Sys.getenv()
[13:35:35.661]                 names <- names(envs)
[13:35:35.661]                 common <- intersect(names, old_names)
[13:35:35.661]                 added <- setdiff(names, old_names)
[13:35:35.661]                 removed <- setdiff(old_names, names)
[13:35:35.661]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:35.661]                   envs[common]]
[13:35:35.661]                 NAMES <- toupper(changed)
[13:35:35.661]                 args <- list()
[13:35:35.661]                 for (kk in seq_along(NAMES)) {
[13:35:35.661]                   name <- changed[[kk]]
[13:35:35.661]                   NAME <- NAMES[[kk]]
[13:35:35.661]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:35.661]                     next
[13:35:35.661]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:35.661]                 }
[13:35:35.661]                 NAMES <- toupper(added)
[13:35:35.661]                 for (kk in seq_along(NAMES)) {
[13:35:35.661]                   name <- added[[kk]]
[13:35:35.661]                   NAME <- NAMES[[kk]]
[13:35:35.661]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:35.661]                     next
[13:35:35.661]                   args[[name]] <- ""
[13:35:35.661]                 }
[13:35:35.661]                 NAMES <- toupper(removed)
[13:35:35.661]                 for (kk in seq_along(NAMES)) {
[13:35:35.661]                   name <- removed[[kk]]
[13:35:35.661]                   NAME <- NAMES[[kk]]
[13:35:35.661]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:35.661]                     next
[13:35:35.661]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:35.661]                 }
[13:35:35.661]                 if (length(args) > 0) 
[13:35:35.661]                   base::do.call(base::Sys.setenv, args = args)
[13:35:35.661]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:35.661]             }
[13:35:35.661]             else {
[13:35:35.661]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:35.661]             }
[13:35:35.661]             {
[13:35:35.661]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:35.661]                   0L) {
[13:35:35.661]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:35.661]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:35.661]                   base::options(opts)
[13:35:35.661]                 }
[13:35:35.661]                 {
[13:35:35.661]                   {
[13:35:35.661]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:35.661]                     NULL
[13:35:35.661]                   }
[13:35:35.661]                   options(future.plan = NULL)
[13:35:35.661]                   if (is.na(NA_character_)) 
[13:35:35.661]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:35.661]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:35.661]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:35.661]                     .init = FALSE)
[13:35:35.661]                 }
[13:35:35.661]             }
[13:35:35.661]         }
[13:35:35.661]     })
[13:35:35.661]     if (TRUE) {
[13:35:35.661]         base::sink(type = "output", split = FALSE)
[13:35:35.661]         if (FALSE) {
[13:35:35.661]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:35.661]         }
[13:35:35.661]         else {
[13:35:35.661]             ...future.result["stdout"] <- base::list(NULL)
[13:35:35.661]         }
[13:35:35.661]         base::close(...future.stdout)
[13:35:35.661]         ...future.stdout <- NULL
[13:35:35.661]     }
[13:35:35.661]     ...future.result$conditions <- ...future.conditions
[13:35:35.661]     ...future.result$finished <- base::Sys.time()
[13:35:35.661]     ...future.result
[13:35:35.661] }
[13:35:35.663] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[13:35:35.664] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[13:35:35.664] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[13:35:35.664] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[13:35:35.665] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[13:35:35.665] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[13:35:35.665] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[13:35:35.665] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:35:35.666] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:35:35.666] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:35:35.666] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:35:35.666] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[13:35:35.667] MultisessionFuture started
[13:35:35.667] - Launch lazy future ... done
[13:35:35.667] run() for ‘MultisessionFuture’ ... done
[13:35:35.667] Created future:
[13:35:35.667] MultisessionFuture:
[13:35:35.667] Label: ‘future_mapply-2’
[13:35:35.667] Expression:
[13:35:35.667] {
[13:35:35.667]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:35.667]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:35.667]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:35.667]         on.exit(options(oopts), add = TRUE)
[13:35:35.667]     }
[13:35:35.667]     {
[13:35:35.667]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:35.667]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:35:35.667]         do.call(mapply, args = args)
[13:35:35.667]     }
[13:35:35.667] }
[13:35:35.667] Lazy evaluation: FALSE
[13:35:35.667] Asynchronous evaluation: TRUE
[13:35:35.667] Local evaluation: TRUE
[13:35:35.667] Environment: R_GlobalEnv
[13:35:35.667] Capture standard output: FALSE
[13:35:35.667] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:35.667] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:35.667] Packages: <none>
[13:35:35.667] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:35.667] Resolved: FALSE
[13:35:35.667] Value: <not collected>
[13:35:35.667] Conditions captured: <none>
[13:35:35.667] Early signaling: FALSE
[13:35:35.667] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:35.667] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:35.679] Chunk #2 of 2 ... DONE
[13:35:35.679] Launching 2 futures (chunks) ... DONE
[13:35:35.679] Resolving 2 futures (chunks) ...
[13:35:35.679] resolve() on list ...
[13:35:35.679]  recursive: 0
[13:35:35.679]  length: 2
[13:35:35.679] 
[13:35:35.722] receiveMessageFromWorker() for ClusterFuture ...
[13:35:35.722] - Validating connection of MultisessionFuture
[13:35:35.722] - received message: FutureResult
[13:35:35.722] - Received FutureResult
[13:35:35.722] - Erased future from FutureRegistry
[13:35:35.722] result() for ClusterFuture ...
[13:35:35.722] - result already collected: FutureResult
[13:35:35.722] result() for ClusterFuture ... done
[13:35:35.723] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:35.723] Future #2
[13:35:35.723] result() for ClusterFuture ...
[13:35:35.723] - result already collected: FutureResult
[13:35:35.723] result() for ClusterFuture ... done
[13:35:35.723] result() for ClusterFuture ...
[13:35:35.723] - result already collected: FutureResult
[13:35:35.723] result() for ClusterFuture ... done
[13:35:35.723] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:35:35.723] - nx: 2
[13:35:35.723] - relay: TRUE
[13:35:35.724] - stdout: TRUE
[13:35:35.724] - signal: TRUE
[13:35:35.724] - resignal: FALSE
[13:35:35.724] - force: TRUE
[13:35:35.724] - relayed: [n=2] FALSE, FALSE
[13:35:35.724] - queued futures: [n=2] FALSE, FALSE
[13:35:35.724]  - until=1
[13:35:35.724]  - relaying element #1
[13:35:35.724] - relayed: [n=2] FALSE, FALSE
[13:35:35.724] - queued futures: [n=2] FALSE, TRUE
[13:35:35.724] signalConditionsASAP(NULL, pos=2) ... done
[13:35:35.724]  length: 1 (resolved future 2)
[13:35:36.173] receiveMessageFromWorker() for ClusterFuture ...
[13:35:36.173] - Validating connection of MultisessionFuture
[13:35:36.173] - received message: FutureResult
[13:35:36.173] - Received FutureResult
[13:35:36.174] - Erased future from FutureRegistry
[13:35:36.174] result() for ClusterFuture ...
[13:35:36.174] - result already collected: FutureResult
[13:35:36.174] result() for ClusterFuture ... done
[13:35:36.174] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:36.174] Future #1
[13:35:36.174] result() for ClusterFuture ...
[13:35:36.174] - result already collected: FutureResult
[13:35:36.174] result() for ClusterFuture ... done
[13:35:36.174] result() for ClusterFuture ...
[13:35:36.174] - result already collected: FutureResult
[13:35:36.175] result() for ClusterFuture ... done
[13:35:36.175] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:35:36.175] - nx: 2
[13:35:36.175] - relay: TRUE
[13:35:36.175] - stdout: TRUE
[13:35:36.175] - signal: TRUE
[13:35:36.175] - resignal: FALSE
[13:35:36.175] - force: TRUE
[13:35:36.175] - relayed: [n=2] FALSE, FALSE
[13:35:36.175] - queued futures: [n=2] FALSE, TRUE
[13:35:36.175]  - until=1
[13:35:36.176]  - relaying element #1
[13:35:36.176] result() for ClusterFuture ...
[13:35:36.176] - result already collected: FutureResult
[13:35:36.176] result() for ClusterFuture ... done
[13:35:36.176] result() for ClusterFuture ...
[13:35:36.176] - result already collected: FutureResult
[13:35:36.176] result() for ClusterFuture ... done
[13:35:36.176] result() for ClusterFuture ...
[13:35:36.176] - result already collected: FutureResult
[13:35:36.176] result() for ClusterFuture ... done
[13:35:36.176] result() for ClusterFuture ...
[13:35:36.177] - result already collected: FutureResult
[13:35:36.177] result() for ClusterFuture ... done
[13:35:36.177] - relayed: [n=2] TRUE, FALSE
[13:35:36.177] - queued futures: [n=2] TRUE, TRUE
[13:35:36.177] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:35:36.177]  length: 0 (resolved future 1)
[13:35:36.177] Relaying remaining futures
[13:35:36.177] signalConditionsASAP(NULL, pos=0) ...
[13:35:36.177] - nx: 2
[13:35:36.177] - relay: TRUE
[13:35:36.177] - stdout: TRUE
[13:35:36.177] - signal: TRUE
[13:35:36.178] - resignal: FALSE
[13:35:36.178] - force: TRUE
[13:35:36.178] - relayed: [n=2] TRUE, FALSE
[13:35:36.178] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:36.178]  - relaying element #2
[13:35:36.178] result() for ClusterFuture ...
[13:35:36.178] - result already collected: FutureResult
[13:35:36.178] result() for ClusterFuture ... done
[13:35:36.178] result() for ClusterFuture ...
[13:35:36.178] - result already collected: FutureResult
[13:35:36.178] result() for ClusterFuture ... done
[13:35:36.179] result() for ClusterFuture ...
[13:35:36.179] - result already collected: FutureResult
[13:35:36.179] result() for ClusterFuture ... done
[13:35:36.179] result() for ClusterFuture ...
[13:35:36.179] - result already collected: FutureResult
[13:35:36.179] result() for ClusterFuture ... done
[13:35:36.179] - relayed: [n=2] TRUE, TRUE
[13:35:36.179] - queued futures: [n=2] TRUE, TRUE
[13:35:36.179] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[13:35:36.179] resolve() on list ... DONE
[13:35:36.179] result() for ClusterFuture ...
[13:35:36.180] - result already collected: FutureResult
[13:35:36.180] result() for ClusterFuture ... done
[13:35:36.180] result() for ClusterFuture ...
[13:35:36.180] - result already collected: FutureResult
[13:35:36.180] result() for ClusterFuture ... done
[13:35:36.180] result() for ClusterFuture ...
[13:35:36.180] - result already collected: FutureResult
[13:35:36.180] result() for ClusterFuture ... done
[13:35:36.180] result() for ClusterFuture ...
[13:35:36.180] - result already collected: FutureResult
[13:35:36.180] result() for ClusterFuture ... done
[13:35:36.180]  - Number of value chunks collected: 2
[13:35:36.181] Resolving 2 futures (chunks) ... DONE
[13:35:36.181] Reducing values from 2 chunks ...
[13:35:36.181]  - Number of values collected after concatenation: 2
[13:35:36.181]  - Number of values expected: 2
[13:35:36.181] Reducing values from 2 chunks ... DONE
[13:35:36.181] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[13:35:36.181] future_mapply() ...
[13:35:36.185] Number of chunks: 2
[13:35:36.185] getGlobalsAndPackagesXApply() ...
[13:35:36.185]  - future.globals: TRUE
[13:35:36.186] getGlobalsAndPackages() ...
[13:35:36.186] Searching for globals...
[13:35:36.187] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:35:36.187] Searching for globals ... DONE
[13:35:36.187] Resolving globals: FALSE
[13:35:36.188] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:35:36.188] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:35:36.188] - globals: [1] ‘FUN’
[13:35:36.188] 
[13:35:36.189] getGlobalsAndPackages() ... DONE
[13:35:36.189]  - globals found/used: [n=1] ‘FUN’
[13:35:36.189]  - needed namespaces: [n=0] 
[13:35:36.189] Finding globals ... DONE
[13:35:36.189] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:35:36.189] List of 2
[13:35:36.189]  $ ...future.FUN:function (x, y)  
[13:35:36.189]  $ MoreArgs     : NULL
[13:35:36.189]  - attr(*, "where")=List of 2
[13:35:36.189]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:36.189]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:35:36.189]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:36.189]  - attr(*, "resolved")= logi FALSE
[13:35:36.189]  - attr(*, "total_size")= num NA
[13:35:36.192] Packages to be attached in all futures: [n=0] 
[13:35:36.192] getGlobalsAndPackagesXApply() ... DONE
[13:35:36.192] Number of futures (= number of chunks): 2
[13:35:36.192] Launching 2 futures (chunks) ...
[13:35:36.192] Chunk #1 of 2 ...
[13:35:36.192]  - Finding globals in '...' for chunk #1 ...
[13:35:36.192] getGlobalsAndPackages() ...
[13:35:36.192] Searching for globals...
[13:35:36.193] 
[13:35:36.193] Searching for globals ... DONE
[13:35:36.193] - globals: [0] <none>
[13:35:36.193] getGlobalsAndPackages() ... DONE
[13:35:36.193]    + additional globals found: [n=0] 
[13:35:36.193]    + additional namespaces needed: [n=0] 
[13:35:36.193]  - Finding globals in '...' for chunk #1 ... DONE
[13:35:36.193]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:36.193]  - seeds: <none>
[13:35:36.193]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:36.194] getGlobalsAndPackages() ...
[13:35:36.194] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:36.194] Resolving globals: FALSE
[13:35:36.194] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:35:36.195] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:35:36.195] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:36.195] 
[13:35:36.195] getGlobalsAndPackages() ... DONE
[13:35:36.195] run() for ‘Future’ ...
[13:35:36.195] - state: ‘created’
[13:35:36.196] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:36.209] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:36.209] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:36.209]   - Field: ‘node’
[13:35:36.209]   - Field: ‘label’
[13:35:36.209]   - Field: ‘local’
[13:35:36.210]   - Field: ‘owner’
[13:35:36.210]   - Field: ‘envir’
[13:35:36.210]   - Field: ‘workers’
[13:35:36.210]   - Field: ‘packages’
[13:35:36.210]   - Field: ‘gc’
[13:35:36.210]   - Field: ‘conditions’
[13:35:36.210]   - Field: ‘persistent’
[13:35:36.210]   - Field: ‘expr’
[13:35:36.210]   - Field: ‘uuid’
[13:35:36.210]   - Field: ‘seed’
[13:35:36.210]   - Field: ‘version’
[13:35:36.211]   - Field: ‘result’
[13:35:36.211]   - Field: ‘asynchronous’
[13:35:36.211]   - Field: ‘calls’
[13:35:36.211]   - Field: ‘globals’
[13:35:36.211]   - Field: ‘stdout’
[13:35:36.211]   - Field: ‘earlySignal’
[13:35:36.211]   - Field: ‘lazy’
[13:35:36.211]   - Field: ‘state’
[13:35:36.211] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:36.211] - Launch lazy future ...
[13:35:36.212] Packages needed by the future expression (n = 0): <none>
[13:35:36.212] Packages needed by future strategies (n = 0): <none>
[13:35:36.212] {
[13:35:36.212]     {
[13:35:36.212]         {
[13:35:36.212]             ...future.startTime <- base::Sys.time()
[13:35:36.212]             {
[13:35:36.212]                 {
[13:35:36.212]                   {
[13:35:36.212]                     {
[13:35:36.212]                       base::local({
[13:35:36.212]                         has_future <- base::requireNamespace("future", 
[13:35:36.212]                           quietly = TRUE)
[13:35:36.212]                         if (has_future) {
[13:35:36.212]                           ns <- base::getNamespace("future")
[13:35:36.212]                           version <- ns[[".package"]][["version"]]
[13:35:36.212]                           if (is.null(version)) 
[13:35:36.212]                             version <- utils::packageVersion("future")
[13:35:36.212]                         }
[13:35:36.212]                         else {
[13:35:36.212]                           version <- NULL
[13:35:36.212]                         }
[13:35:36.212]                         if (!has_future || version < "1.8.0") {
[13:35:36.212]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:36.212]                             "", base::R.version$version.string), 
[13:35:36.212]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:36.212]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:36.212]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:36.212]                               "release", "version")], collapse = " "), 
[13:35:36.212]                             hostname = base::Sys.info()[["nodename"]])
[13:35:36.212]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:36.212]                             info)
[13:35:36.212]                           info <- base::paste(info, collapse = "; ")
[13:35:36.212]                           if (!has_future) {
[13:35:36.212]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:36.212]                               info)
[13:35:36.212]                           }
[13:35:36.212]                           else {
[13:35:36.212]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:36.212]                               info, version)
[13:35:36.212]                           }
[13:35:36.212]                           base::stop(msg)
[13:35:36.212]                         }
[13:35:36.212]                       })
[13:35:36.212]                     }
[13:35:36.212]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:36.212]                     base::options(mc.cores = 1L)
[13:35:36.212]                   }
[13:35:36.212]                   ...future.strategy.old <- future::plan("list")
[13:35:36.212]                   options(future.plan = NULL)
[13:35:36.212]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:36.212]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:36.212]                 }
[13:35:36.212]                 ...future.workdir <- getwd()
[13:35:36.212]             }
[13:35:36.212]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:36.212]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:36.212]         }
[13:35:36.212]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:36.212]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:36.212]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:36.212]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:36.212]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:36.212]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:36.212]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:36.212]             base::names(...future.oldOptions))
[13:35:36.212]     }
[13:35:36.212]     if (FALSE) {
[13:35:36.212]     }
[13:35:36.212]     else {
[13:35:36.212]         if (TRUE) {
[13:35:36.212]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:36.212]                 open = "w")
[13:35:36.212]         }
[13:35:36.212]         else {
[13:35:36.212]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:36.212]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:36.212]         }
[13:35:36.212]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:36.212]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:36.212]             base::sink(type = "output", split = FALSE)
[13:35:36.212]             base::close(...future.stdout)
[13:35:36.212]         }, add = TRUE)
[13:35:36.212]     }
[13:35:36.212]     ...future.frame <- base::sys.nframe()
[13:35:36.212]     ...future.conditions <- base::list()
[13:35:36.212]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:36.212]     if (FALSE) {
[13:35:36.212]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:36.212]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:36.212]     }
[13:35:36.212]     ...future.result <- base::tryCatch({
[13:35:36.212]         base::withCallingHandlers({
[13:35:36.212]             ...future.value <- base::withVisible(base::local({
[13:35:36.212]                 ...future.makeSendCondition <- base::local({
[13:35:36.212]                   sendCondition <- NULL
[13:35:36.212]                   function(frame = 1L) {
[13:35:36.212]                     if (is.function(sendCondition)) 
[13:35:36.212]                       return(sendCondition)
[13:35:36.212]                     ns <- getNamespace("parallel")
[13:35:36.212]                     if (exists("sendData", mode = "function", 
[13:35:36.212]                       envir = ns)) {
[13:35:36.212]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:36.212]                         envir = ns)
[13:35:36.212]                       envir <- sys.frame(frame)
[13:35:36.212]                       master <- NULL
[13:35:36.212]                       while (!identical(envir, .GlobalEnv) && 
[13:35:36.212]                         !identical(envir, emptyenv())) {
[13:35:36.212]                         if (exists("master", mode = "list", envir = envir, 
[13:35:36.212]                           inherits = FALSE)) {
[13:35:36.212]                           master <- get("master", mode = "list", 
[13:35:36.212]                             envir = envir, inherits = FALSE)
[13:35:36.212]                           if (inherits(master, c("SOCKnode", 
[13:35:36.212]                             "SOCK0node"))) {
[13:35:36.212]                             sendCondition <<- function(cond) {
[13:35:36.212]                               data <- list(type = "VALUE", value = cond, 
[13:35:36.212]                                 success = TRUE)
[13:35:36.212]                               parallel_sendData(master, data)
[13:35:36.212]                             }
[13:35:36.212]                             return(sendCondition)
[13:35:36.212]                           }
[13:35:36.212]                         }
[13:35:36.212]                         frame <- frame + 1L
[13:35:36.212]                         envir <- sys.frame(frame)
[13:35:36.212]                       }
[13:35:36.212]                     }
[13:35:36.212]                     sendCondition <<- function(cond) NULL
[13:35:36.212]                   }
[13:35:36.212]                 })
[13:35:36.212]                 withCallingHandlers({
[13:35:36.212]                   {
[13:35:36.212]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:36.212]                     if (!identical(...future.globals.maxSize.org, 
[13:35:36.212]                       ...future.globals.maxSize)) {
[13:35:36.212]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:36.212]                       on.exit(options(oopts), add = TRUE)
[13:35:36.212]                     }
[13:35:36.212]                     {
[13:35:36.212]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:36.212]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:35:36.212]                         USE.NAMES = FALSE)
[13:35:36.212]                       do.call(mapply, args = args)
[13:35:36.212]                     }
[13:35:36.212]                   }
[13:35:36.212]                 }, immediateCondition = function(cond) {
[13:35:36.212]                   sendCondition <- ...future.makeSendCondition()
[13:35:36.212]                   sendCondition(cond)
[13:35:36.212]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:36.212]                   {
[13:35:36.212]                     inherits <- base::inherits
[13:35:36.212]                     invokeRestart <- base::invokeRestart
[13:35:36.212]                     is.null <- base::is.null
[13:35:36.212]                     muffled <- FALSE
[13:35:36.212]                     if (inherits(cond, "message")) {
[13:35:36.212]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:36.212]                       if (muffled) 
[13:35:36.212]                         invokeRestart("muffleMessage")
[13:35:36.212]                     }
[13:35:36.212]                     else if (inherits(cond, "warning")) {
[13:35:36.212]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:36.212]                       if (muffled) 
[13:35:36.212]                         invokeRestart("muffleWarning")
[13:35:36.212]                     }
[13:35:36.212]                     else if (inherits(cond, "condition")) {
[13:35:36.212]                       if (!is.null(pattern)) {
[13:35:36.212]                         computeRestarts <- base::computeRestarts
[13:35:36.212]                         grepl <- base::grepl
[13:35:36.212]                         restarts <- computeRestarts(cond)
[13:35:36.212]                         for (restart in restarts) {
[13:35:36.212]                           name <- restart$name
[13:35:36.212]                           if (is.null(name)) 
[13:35:36.212]                             next
[13:35:36.212]                           if (!grepl(pattern, name)) 
[13:35:36.212]                             next
[13:35:36.212]                           invokeRestart(restart)
[13:35:36.212]                           muffled <- TRUE
[13:35:36.212]                           break
[13:35:36.212]                         }
[13:35:36.212]                       }
[13:35:36.212]                     }
[13:35:36.212]                     invisible(muffled)
[13:35:36.212]                   }
[13:35:36.212]                   muffleCondition(cond)
[13:35:36.212]                 })
[13:35:36.212]             }))
[13:35:36.212]             future::FutureResult(value = ...future.value$value, 
[13:35:36.212]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:36.212]                   ...future.rng), globalenv = if (FALSE) 
[13:35:36.212]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:36.212]                     ...future.globalenv.names))
[13:35:36.212]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:36.212]         }, condition = base::local({
[13:35:36.212]             c <- base::c
[13:35:36.212]             inherits <- base::inherits
[13:35:36.212]             invokeRestart <- base::invokeRestart
[13:35:36.212]             length <- base::length
[13:35:36.212]             list <- base::list
[13:35:36.212]             seq.int <- base::seq.int
[13:35:36.212]             signalCondition <- base::signalCondition
[13:35:36.212]             sys.calls <- base::sys.calls
[13:35:36.212]             `[[` <- base::`[[`
[13:35:36.212]             `+` <- base::`+`
[13:35:36.212]             `<<-` <- base::`<<-`
[13:35:36.212]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:36.212]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:36.212]                   3L)]
[13:35:36.212]             }
[13:35:36.212]             function(cond) {
[13:35:36.212]                 is_error <- inherits(cond, "error")
[13:35:36.212]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:36.212]                   NULL)
[13:35:36.212]                 if (is_error) {
[13:35:36.212]                   sessionInformation <- function() {
[13:35:36.212]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:36.212]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:36.212]                       search = base::search(), system = base::Sys.info())
[13:35:36.212]                   }
[13:35:36.212]                   ...future.conditions[[length(...future.conditions) + 
[13:35:36.212]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:36.212]                     cond$call), session = sessionInformation(), 
[13:35:36.212]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:36.212]                   signalCondition(cond)
[13:35:36.212]                 }
[13:35:36.212]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:36.212]                 "immediateCondition"))) {
[13:35:36.212]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:36.212]                   ...future.conditions[[length(...future.conditions) + 
[13:35:36.212]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:36.212]                   if (TRUE && !signal) {
[13:35:36.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:36.212]                     {
[13:35:36.212]                       inherits <- base::inherits
[13:35:36.212]                       invokeRestart <- base::invokeRestart
[13:35:36.212]                       is.null <- base::is.null
[13:35:36.212]                       muffled <- FALSE
[13:35:36.212]                       if (inherits(cond, "message")) {
[13:35:36.212]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:36.212]                         if (muffled) 
[13:35:36.212]                           invokeRestart("muffleMessage")
[13:35:36.212]                       }
[13:35:36.212]                       else if (inherits(cond, "warning")) {
[13:35:36.212]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:36.212]                         if (muffled) 
[13:35:36.212]                           invokeRestart("muffleWarning")
[13:35:36.212]                       }
[13:35:36.212]                       else if (inherits(cond, "condition")) {
[13:35:36.212]                         if (!is.null(pattern)) {
[13:35:36.212]                           computeRestarts <- base::computeRestarts
[13:35:36.212]                           grepl <- base::grepl
[13:35:36.212]                           restarts <- computeRestarts(cond)
[13:35:36.212]                           for (restart in restarts) {
[13:35:36.212]                             name <- restart$name
[13:35:36.212]                             if (is.null(name)) 
[13:35:36.212]                               next
[13:35:36.212]                             if (!grepl(pattern, name)) 
[13:35:36.212]                               next
[13:35:36.212]                             invokeRestart(restart)
[13:35:36.212]                             muffled <- TRUE
[13:35:36.212]                             break
[13:35:36.212]                           }
[13:35:36.212]                         }
[13:35:36.212]                       }
[13:35:36.212]                       invisible(muffled)
[13:35:36.212]                     }
[13:35:36.212]                     muffleCondition(cond, pattern = "^muffle")
[13:35:36.212]                   }
[13:35:36.212]                 }
[13:35:36.212]                 else {
[13:35:36.212]                   if (TRUE) {
[13:35:36.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:36.212]                     {
[13:35:36.212]                       inherits <- base::inherits
[13:35:36.212]                       invokeRestart <- base::invokeRestart
[13:35:36.212]                       is.null <- base::is.null
[13:35:36.212]                       muffled <- FALSE
[13:35:36.212]                       if (inherits(cond, "message")) {
[13:35:36.212]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:36.212]                         if (muffled) 
[13:35:36.212]                           invokeRestart("muffleMessage")
[13:35:36.212]                       }
[13:35:36.212]                       else if (inherits(cond, "warning")) {
[13:35:36.212]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:36.212]                         if (muffled) 
[13:35:36.212]                           invokeRestart("muffleWarning")
[13:35:36.212]                       }
[13:35:36.212]                       else if (inherits(cond, "condition")) {
[13:35:36.212]                         if (!is.null(pattern)) {
[13:35:36.212]                           computeRestarts <- base::computeRestarts
[13:35:36.212]                           grepl <- base::grepl
[13:35:36.212]                           restarts <- computeRestarts(cond)
[13:35:36.212]                           for (restart in restarts) {
[13:35:36.212]                             name <- restart$name
[13:35:36.212]                             if (is.null(name)) 
[13:35:36.212]                               next
[13:35:36.212]                             if (!grepl(pattern, name)) 
[13:35:36.212]                               next
[13:35:36.212]                             invokeRestart(restart)
[13:35:36.212]                             muffled <- TRUE
[13:35:36.212]                             break
[13:35:36.212]                           }
[13:35:36.212]                         }
[13:35:36.212]                       }
[13:35:36.212]                       invisible(muffled)
[13:35:36.212]                     }
[13:35:36.212]                     muffleCondition(cond, pattern = "^muffle")
[13:35:36.212]                   }
[13:35:36.212]                 }
[13:35:36.212]             }
[13:35:36.212]         }))
[13:35:36.212]     }, error = function(ex) {
[13:35:36.212]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:36.212]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:36.212]                 ...future.rng), started = ...future.startTime, 
[13:35:36.212]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:36.212]             version = "1.8"), class = "FutureResult")
[13:35:36.212]     }, finally = {
[13:35:36.212]         if (!identical(...future.workdir, getwd())) 
[13:35:36.212]             setwd(...future.workdir)
[13:35:36.212]         {
[13:35:36.212]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:36.212]                 ...future.oldOptions$nwarnings <- NULL
[13:35:36.212]             }
[13:35:36.212]             base::options(...future.oldOptions)
[13:35:36.212]             if (.Platform$OS.type == "windows") {
[13:35:36.212]                 old_names <- names(...future.oldEnvVars)
[13:35:36.212]                 envs <- base::Sys.getenv()
[13:35:36.212]                 names <- names(envs)
[13:35:36.212]                 common <- intersect(names, old_names)
[13:35:36.212]                 added <- setdiff(names, old_names)
[13:35:36.212]                 removed <- setdiff(old_names, names)
[13:35:36.212]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:36.212]                   envs[common]]
[13:35:36.212]                 NAMES <- toupper(changed)
[13:35:36.212]                 args <- list()
[13:35:36.212]                 for (kk in seq_along(NAMES)) {
[13:35:36.212]                   name <- changed[[kk]]
[13:35:36.212]                   NAME <- NAMES[[kk]]
[13:35:36.212]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:36.212]                     next
[13:35:36.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:36.212]                 }
[13:35:36.212]                 NAMES <- toupper(added)
[13:35:36.212]                 for (kk in seq_along(NAMES)) {
[13:35:36.212]                   name <- added[[kk]]
[13:35:36.212]                   NAME <- NAMES[[kk]]
[13:35:36.212]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:36.212]                     next
[13:35:36.212]                   args[[name]] <- ""
[13:35:36.212]                 }
[13:35:36.212]                 NAMES <- toupper(removed)
[13:35:36.212]                 for (kk in seq_along(NAMES)) {
[13:35:36.212]                   name <- removed[[kk]]
[13:35:36.212]                   NAME <- NAMES[[kk]]
[13:35:36.212]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:36.212]                     next
[13:35:36.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:36.212]                 }
[13:35:36.212]                 if (length(args) > 0) 
[13:35:36.212]                   base::do.call(base::Sys.setenv, args = args)
[13:35:36.212]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:36.212]             }
[13:35:36.212]             else {
[13:35:36.212]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:36.212]             }
[13:35:36.212]             {
[13:35:36.212]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:36.212]                   0L) {
[13:35:36.212]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:36.212]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:36.212]                   base::options(opts)
[13:35:36.212]                 }
[13:35:36.212]                 {
[13:35:36.212]                   {
[13:35:36.212]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:36.212]                     NULL
[13:35:36.212]                   }
[13:35:36.212]                   options(future.plan = NULL)
[13:35:36.212]                   if (is.na(NA_character_)) 
[13:35:36.212]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:36.212]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:36.212]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:36.212]                     .init = FALSE)
[13:35:36.212]                 }
[13:35:36.212]             }
[13:35:36.212]         }
[13:35:36.212]     })
[13:35:36.212]     if (TRUE) {
[13:35:36.212]         base::sink(type = "output", split = FALSE)
[13:35:36.212]         if (TRUE) {
[13:35:36.212]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:36.212]         }
[13:35:36.212]         else {
[13:35:36.212]             ...future.result["stdout"] <- base::list(NULL)
[13:35:36.212]         }
[13:35:36.212]         base::close(...future.stdout)
[13:35:36.212]         ...future.stdout <- NULL
[13:35:36.212]     }
[13:35:36.212]     ...future.result$conditions <- ...future.conditions
[13:35:36.212]     ...future.result$finished <- base::Sys.time()
[13:35:36.212]     ...future.result
[13:35:36.212] }
[13:35:36.215] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[13:35:36.215] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[13:35:36.215] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[13:35:36.216] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:35:36.216] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:35:36.216] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[13:35:36.216] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[13:35:36.217] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:36.217] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:36.217] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:36.217] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:36.218] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[13:35:36.218] MultisessionFuture started
[13:35:36.218] - Launch lazy future ... done
[13:35:36.218] run() for ‘MultisessionFuture’ ... done
[13:35:36.219] Created future:
[13:35:36.219] MultisessionFuture:
[13:35:36.219] Label: ‘future_mapply-1’
[13:35:36.219] Expression:
[13:35:36.219] {
[13:35:36.219]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:36.219]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:36.219]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:36.219]         on.exit(options(oopts), add = TRUE)
[13:35:36.219]     }
[13:35:36.219]     {
[13:35:36.219]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:36.219]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:35:36.219]         do.call(mapply, args = args)
[13:35:36.219]     }
[13:35:36.219] }
[13:35:36.219] Lazy evaluation: FALSE
[13:35:36.219] Asynchronous evaluation: TRUE
[13:35:36.219] Local evaluation: TRUE
[13:35:36.219] Environment: R_GlobalEnv
[13:35:36.219] Capture standard output: TRUE
[13:35:36.219] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:36.219] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:36.219] Packages: <none>
[13:35:36.219] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:36.219] Resolved: FALSE
[13:35:36.219] Value: <not collected>
[13:35:36.219] Conditions captured: <none>
[13:35:36.219] Early signaling: FALSE
[13:35:36.219] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:36.219] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:36.230] Chunk #1 of 2 ... DONE
[13:35:36.230] Chunk #2 of 2 ...
[13:35:36.230]  - Finding globals in '...' for chunk #2 ...
[13:35:36.231] getGlobalsAndPackages() ...
[13:35:36.231] Searching for globals...
[13:35:36.231] 
[13:35:36.231] Searching for globals ... DONE
[13:35:36.231] - globals: [0] <none>
[13:35:36.231] getGlobalsAndPackages() ... DONE
[13:35:36.231]    + additional globals found: [n=0] 
[13:35:36.231]    + additional namespaces needed: [n=0] 
[13:35:36.232]  - Finding globals in '...' for chunk #2 ... DONE
[13:35:36.232]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:36.232]  - seeds: <none>
[13:35:36.232]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:36.232] getGlobalsAndPackages() ...
[13:35:36.232] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:36.232] Resolving globals: FALSE
[13:35:36.233] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:35:36.233] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:35:36.233] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:36.233] 
[13:35:36.233] getGlobalsAndPackages() ... DONE
[13:35:36.234] run() for ‘Future’ ...
[13:35:36.234] - state: ‘created’
[13:35:36.234] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:36.249] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:36.250] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:36.250]   - Field: ‘node’
[13:35:36.250]   - Field: ‘label’
[13:35:36.250]   - Field: ‘local’
[13:35:36.250]   - Field: ‘owner’
[13:35:36.250]   - Field: ‘envir’
[13:35:36.250]   - Field: ‘workers’
[13:35:36.250]   - Field: ‘packages’
[13:35:36.250]   - Field: ‘gc’
[13:35:36.251]   - Field: ‘conditions’
[13:35:36.251]   - Field: ‘persistent’
[13:35:36.251]   - Field: ‘expr’
[13:35:36.251]   - Field: ‘uuid’
[13:35:36.251]   - Field: ‘seed’
[13:35:36.251]   - Field: ‘version’
[13:35:36.251]   - Field: ‘result’
[13:35:36.251]   - Field: ‘asynchronous’
[13:35:36.251]   - Field: ‘calls’
[13:35:36.251]   - Field: ‘globals’
[13:35:36.251]   - Field: ‘stdout’
[13:35:36.252]   - Field: ‘earlySignal’
[13:35:36.252]   - Field: ‘lazy’
[13:35:36.252]   - Field: ‘state’
[13:35:36.252] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:36.252] - Launch lazy future ...
[13:35:36.252] Packages needed by the future expression (n = 0): <none>
[13:35:36.252] Packages needed by future strategies (n = 0): <none>
[13:35:36.253] {
[13:35:36.253]     {
[13:35:36.253]         {
[13:35:36.253]             ...future.startTime <- base::Sys.time()
[13:35:36.253]             {
[13:35:36.253]                 {
[13:35:36.253]                   {
[13:35:36.253]                     {
[13:35:36.253]                       base::local({
[13:35:36.253]                         has_future <- base::requireNamespace("future", 
[13:35:36.253]                           quietly = TRUE)
[13:35:36.253]                         if (has_future) {
[13:35:36.253]                           ns <- base::getNamespace("future")
[13:35:36.253]                           version <- ns[[".package"]][["version"]]
[13:35:36.253]                           if (is.null(version)) 
[13:35:36.253]                             version <- utils::packageVersion("future")
[13:35:36.253]                         }
[13:35:36.253]                         else {
[13:35:36.253]                           version <- NULL
[13:35:36.253]                         }
[13:35:36.253]                         if (!has_future || version < "1.8.0") {
[13:35:36.253]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:36.253]                             "", base::R.version$version.string), 
[13:35:36.253]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:36.253]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:36.253]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:36.253]                               "release", "version")], collapse = " "), 
[13:35:36.253]                             hostname = base::Sys.info()[["nodename"]])
[13:35:36.253]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:36.253]                             info)
[13:35:36.253]                           info <- base::paste(info, collapse = "; ")
[13:35:36.253]                           if (!has_future) {
[13:35:36.253]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:36.253]                               info)
[13:35:36.253]                           }
[13:35:36.253]                           else {
[13:35:36.253]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:36.253]                               info, version)
[13:35:36.253]                           }
[13:35:36.253]                           base::stop(msg)
[13:35:36.253]                         }
[13:35:36.253]                       })
[13:35:36.253]                     }
[13:35:36.253]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:36.253]                     base::options(mc.cores = 1L)
[13:35:36.253]                   }
[13:35:36.253]                   ...future.strategy.old <- future::plan("list")
[13:35:36.253]                   options(future.plan = NULL)
[13:35:36.253]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:36.253]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:36.253]                 }
[13:35:36.253]                 ...future.workdir <- getwd()
[13:35:36.253]             }
[13:35:36.253]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:36.253]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:36.253]         }
[13:35:36.253]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:36.253]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:36.253]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:36.253]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:36.253]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:36.253]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:36.253]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:36.253]             base::names(...future.oldOptions))
[13:35:36.253]     }
[13:35:36.253]     if (FALSE) {
[13:35:36.253]     }
[13:35:36.253]     else {
[13:35:36.253]         if (TRUE) {
[13:35:36.253]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:36.253]                 open = "w")
[13:35:36.253]         }
[13:35:36.253]         else {
[13:35:36.253]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:36.253]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:36.253]         }
[13:35:36.253]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:36.253]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:36.253]             base::sink(type = "output", split = FALSE)
[13:35:36.253]             base::close(...future.stdout)
[13:35:36.253]         }, add = TRUE)
[13:35:36.253]     }
[13:35:36.253]     ...future.frame <- base::sys.nframe()
[13:35:36.253]     ...future.conditions <- base::list()
[13:35:36.253]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:36.253]     if (FALSE) {
[13:35:36.253]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:36.253]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:36.253]     }
[13:35:36.253]     ...future.result <- base::tryCatch({
[13:35:36.253]         base::withCallingHandlers({
[13:35:36.253]             ...future.value <- base::withVisible(base::local({
[13:35:36.253]                 ...future.makeSendCondition <- base::local({
[13:35:36.253]                   sendCondition <- NULL
[13:35:36.253]                   function(frame = 1L) {
[13:35:36.253]                     if (is.function(sendCondition)) 
[13:35:36.253]                       return(sendCondition)
[13:35:36.253]                     ns <- getNamespace("parallel")
[13:35:36.253]                     if (exists("sendData", mode = "function", 
[13:35:36.253]                       envir = ns)) {
[13:35:36.253]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:36.253]                         envir = ns)
[13:35:36.253]                       envir <- sys.frame(frame)
[13:35:36.253]                       master <- NULL
[13:35:36.253]                       while (!identical(envir, .GlobalEnv) && 
[13:35:36.253]                         !identical(envir, emptyenv())) {
[13:35:36.253]                         if (exists("master", mode = "list", envir = envir, 
[13:35:36.253]                           inherits = FALSE)) {
[13:35:36.253]                           master <- get("master", mode = "list", 
[13:35:36.253]                             envir = envir, inherits = FALSE)
[13:35:36.253]                           if (inherits(master, c("SOCKnode", 
[13:35:36.253]                             "SOCK0node"))) {
[13:35:36.253]                             sendCondition <<- function(cond) {
[13:35:36.253]                               data <- list(type = "VALUE", value = cond, 
[13:35:36.253]                                 success = TRUE)
[13:35:36.253]                               parallel_sendData(master, data)
[13:35:36.253]                             }
[13:35:36.253]                             return(sendCondition)
[13:35:36.253]                           }
[13:35:36.253]                         }
[13:35:36.253]                         frame <- frame + 1L
[13:35:36.253]                         envir <- sys.frame(frame)
[13:35:36.253]                       }
[13:35:36.253]                     }
[13:35:36.253]                     sendCondition <<- function(cond) NULL
[13:35:36.253]                   }
[13:35:36.253]                 })
[13:35:36.253]                 withCallingHandlers({
[13:35:36.253]                   {
[13:35:36.253]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:36.253]                     if (!identical(...future.globals.maxSize.org, 
[13:35:36.253]                       ...future.globals.maxSize)) {
[13:35:36.253]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:36.253]                       on.exit(options(oopts), add = TRUE)
[13:35:36.253]                     }
[13:35:36.253]                     {
[13:35:36.253]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:36.253]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:35:36.253]                         USE.NAMES = FALSE)
[13:35:36.253]                       do.call(mapply, args = args)
[13:35:36.253]                     }
[13:35:36.253]                   }
[13:35:36.253]                 }, immediateCondition = function(cond) {
[13:35:36.253]                   sendCondition <- ...future.makeSendCondition()
[13:35:36.253]                   sendCondition(cond)
[13:35:36.253]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:36.253]                   {
[13:35:36.253]                     inherits <- base::inherits
[13:35:36.253]                     invokeRestart <- base::invokeRestart
[13:35:36.253]                     is.null <- base::is.null
[13:35:36.253]                     muffled <- FALSE
[13:35:36.253]                     if (inherits(cond, "message")) {
[13:35:36.253]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:36.253]                       if (muffled) 
[13:35:36.253]                         invokeRestart("muffleMessage")
[13:35:36.253]                     }
[13:35:36.253]                     else if (inherits(cond, "warning")) {
[13:35:36.253]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:36.253]                       if (muffled) 
[13:35:36.253]                         invokeRestart("muffleWarning")
[13:35:36.253]                     }
[13:35:36.253]                     else if (inherits(cond, "condition")) {
[13:35:36.253]                       if (!is.null(pattern)) {
[13:35:36.253]                         computeRestarts <- base::computeRestarts
[13:35:36.253]                         grepl <- base::grepl
[13:35:36.253]                         restarts <- computeRestarts(cond)
[13:35:36.253]                         for (restart in restarts) {
[13:35:36.253]                           name <- restart$name
[13:35:36.253]                           if (is.null(name)) 
[13:35:36.253]                             next
[13:35:36.253]                           if (!grepl(pattern, name)) 
[13:35:36.253]                             next
[13:35:36.253]                           invokeRestart(restart)
[13:35:36.253]                           muffled <- TRUE
[13:35:36.253]                           break
[13:35:36.253]                         }
[13:35:36.253]                       }
[13:35:36.253]                     }
[13:35:36.253]                     invisible(muffled)
[13:35:36.253]                   }
[13:35:36.253]                   muffleCondition(cond)
[13:35:36.253]                 })
[13:35:36.253]             }))
[13:35:36.253]             future::FutureResult(value = ...future.value$value, 
[13:35:36.253]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:36.253]                   ...future.rng), globalenv = if (FALSE) 
[13:35:36.253]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:36.253]                     ...future.globalenv.names))
[13:35:36.253]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:36.253]         }, condition = base::local({
[13:35:36.253]             c <- base::c
[13:35:36.253]             inherits <- base::inherits
[13:35:36.253]             invokeRestart <- base::invokeRestart
[13:35:36.253]             length <- base::length
[13:35:36.253]             list <- base::list
[13:35:36.253]             seq.int <- base::seq.int
[13:35:36.253]             signalCondition <- base::signalCondition
[13:35:36.253]             sys.calls <- base::sys.calls
[13:35:36.253]             `[[` <- base::`[[`
[13:35:36.253]             `+` <- base::`+`
[13:35:36.253]             `<<-` <- base::`<<-`
[13:35:36.253]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:36.253]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:36.253]                   3L)]
[13:35:36.253]             }
[13:35:36.253]             function(cond) {
[13:35:36.253]                 is_error <- inherits(cond, "error")
[13:35:36.253]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:36.253]                   NULL)
[13:35:36.253]                 if (is_error) {
[13:35:36.253]                   sessionInformation <- function() {
[13:35:36.253]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:36.253]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:36.253]                       search = base::search(), system = base::Sys.info())
[13:35:36.253]                   }
[13:35:36.253]                   ...future.conditions[[length(...future.conditions) + 
[13:35:36.253]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:36.253]                     cond$call), session = sessionInformation(), 
[13:35:36.253]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:36.253]                   signalCondition(cond)
[13:35:36.253]                 }
[13:35:36.253]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:36.253]                 "immediateCondition"))) {
[13:35:36.253]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:36.253]                   ...future.conditions[[length(...future.conditions) + 
[13:35:36.253]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:36.253]                   if (TRUE && !signal) {
[13:35:36.253]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:36.253]                     {
[13:35:36.253]                       inherits <- base::inherits
[13:35:36.253]                       invokeRestart <- base::invokeRestart
[13:35:36.253]                       is.null <- base::is.null
[13:35:36.253]                       muffled <- FALSE
[13:35:36.253]                       if (inherits(cond, "message")) {
[13:35:36.253]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:36.253]                         if (muffled) 
[13:35:36.253]                           invokeRestart("muffleMessage")
[13:35:36.253]                       }
[13:35:36.253]                       else if (inherits(cond, "warning")) {
[13:35:36.253]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:36.253]                         if (muffled) 
[13:35:36.253]                           invokeRestart("muffleWarning")
[13:35:36.253]                       }
[13:35:36.253]                       else if (inherits(cond, "condition")) {
[13:35:36.253]                         if (!is.null(pattern)) {
[13:35:36.253]                           computeRestarts <- base::computeRestarts
[13:35:36.253]                           grepl <- base::grepl
[13:35:36.253]                           restarts <- computeRestarts(cond)
[13:35:36.253]                           for (restart in restarts) {
[13:35:36.253]                             name <- restart$name
[13:35:36.253]                             if (is.null(name)) 
[13:35:36.253]                               next
[13:35:36.253]                             if (!grepl(pattern, name)) 
[13:35:36.253]                               next
[13:35:36.253]                             invokeRestart(restart)
[13:35:36.253]                             muffled <- TRUE
[13:35:36.253]                             break
[13:35:36.253]                           }
[13:35:36.253]                         }
[13:35:36.253]                       }
[13:35:36.253]                       invisible(muffled)
[13:35:36.253]                     }
[13:35:36.253]                     muffleCondition(cond, pattern = "^muffle")
[13:35:36.253]                   }
[13:35:36.253]                 }
[13:35:36.253]                 else {
[13:35:36.253]                   if (TRUE) {
[13:35:36.253]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:36.253]                     {
[13:35:36.253]                       inherits <- base::inherits
[13:35:36.253]                       invokeRestart <- base::invokeRestart
[13:35:36.253]                       is.null <- base::is.null
[13:35:36.253]                       muffled <- FALSE
[13:35:36.253]                       if (inherits(cond, "message")) {
[13:35:36.253]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:36.253]                         if (muffled) 
[13:35:36.253]                           invokeRestart("muffleMessage")
[13:35:36.253]                       }
[13:35:36.253]                       else if (inherits(cond, "warning")) {
[13:35:36.253]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:36.253]                         if (muffled) 
[13:35:36.253]                           invokeRestart("muffleWarning")
[13:35:36.253]                       }
[13:35:36.253]                       else if (inherits(cond, "condition")) {
[13:35:36.253]                         if (!is.null(pattern)) {
[13:35:36.253]                           computeRestarts <- base::computeRestarts
[13:35:36.253]                           grepl <- base::grepl
[13:35:36.253]                           restarts <- computeRestarts(cond)
[13:35:36.253]                           for (restart in restarts) {
[13:35:36.253]                             name <- restart$name
[13:35:36.253]                             if (is.null(name)) 
[13:35:36.253]                               next
[13:35:36.253]                             if (!grepl(pattern, name)) 
[13:35:36.253]                               next
[13:35:36.253]                             invokeRestart(restart)
[13:35:36.253]                             muffled <- TRUE
[13:35:36.253]                             break
[13:35:36.253]                           }
[13:35:36.253]                         }
[13:35:36.253]                       }
[13:35:36.253]                       invisible(muffled)
[13:35:36.253]                     }
[13:35:36.253]                     muffleCondition(cond, pattern = "^muffle")
[13:35:36.253]                   }
[13:35:36.253]                 }
[13:35:36.253]             }
[13:35:36.253]         }))
[13:35:36.253]     }, error = function(ex) {
[13:35:36.253]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:36.253]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:36.253]                 ...future.rng), started = ...future.startTime, 
[13:35:36.253]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:36.253]             version = "1.8"), class = "FutureResult")
[13:35:36.253]     }, finally = {
[13:35:36.253]         if (!identical(...future.workdir, getwd())) 
[13:35:36.253]             setwd(...future.workdir)
[13:35:36.253]         {
[13:35:36.253]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:36.253]                 ...future.oldOptions$nwarnings <- NULL
[13:35:36.253]             }
[13:35:36.253]             base::options(...future.oldOptions)
[13:35:36.253]             if (.Platform$OS.type == "windows") {
[13:35:36.253]                 old_names <- names(...future.oldEnvVars)
[13:35:36.253]                 envs <- base::Sys.getenv()
[13:35:36.253]                 names <- names(envs)
[13:35:36.253]                 common <- intersect(names, old_names)
[13:35:36.253]                 added <- setdiff(names, old_names)
[13:35:36.253]                 removed <- setdiff(old_names, names)
[13:35:36.253]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:36.253]                   envs[common]]
[13:35:36.253]                 NAMES <- toupper(changed)
[13:35:36.253]                 args <- list()
[13:35:36.253]                 for (kk in seq_along(NAMES)) {
[13:35:36.253]                   name <- changed[[kk]]
[13:35:36.253]                   NAME <- NAMES[[kk]]
[13:35:36.253]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:36.253]                     next
[13:35:36.253]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:36.253]                 }
[13:35:36.253]                 NAMES <- toupper(added)
[13:35:36.253]                 for (kk in seq_along(NAMES)) {
[13:35:36.253]                   name <- added[[kk]]
[13:35:36.253]                   NAME <- NAMES[[kk]]
[13:35:36.253]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:36.253]                     next
[13:35:36.253]                   args[[name]] <- ""
[13:35:36.253]                 }
[13:35:36.253]                 NAMES <- toupper(removed)
[13:35:36.253]                 for (kk in seq_along(NAMES)) {
[13:35:36.253]                   name <- removed[[kk]]
[13:35:36.253]                   NAME <- NAMES[[kk]]
[13:35:36.253]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:36.253]                     next
[13:35:36.253]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:36.253]                 }
[13:35:36.253]                 if (length(args) > 0) 
[13:35:36.253]                   base::do.call(base::Sys.setenv, args = args)
[13:35:36.253]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:36.253]             }
[13:35:36.253]             else {
[13:35:36.253]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:36.253]             }
[13:35:36.253]             {
[13:35:36.253]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:36.253]                   0L) {
[13:35:36.253]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:36.253]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:36.253]                   base::options(opts)
[13:35:36.253]                 }
[13:35:36.253]                 {
[13:35:36.253]                   {
[13:35:36.253]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:36.253]                     NULL
[13:35:36.253]                   }
[13:35:36.253]                   options(future.plan = NULL)
[13:35:36.253]                   if (is.na(NA_character_)) 
[13:35:36.253]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:36.253]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:36.253]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:36.253]                     .init = FALSE)
[13:35:36.253]                 }
[13:35:36.253]             }
[13:35:36.253]         }
[13:35:36.253]     })
[13:35:36.253]     if (TRUE) {
[13:35:36.253]         base::sink(type = "output", split = FALSE)
[13:35:36.253]         if (TRUE) {
[13:35:36.253]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:36.253]         }
[13:35:36.253]         else {
[13:35:36.253]             ...future.result["stdout"] <- base::list(NULL)
[13:35:36.253]         }
[13:35:36.253]         base::close(...future.stdout)
[13:35:36.253]         ...future.stdout <- NULL
[13:35:36.253]     }
[13:35:36.253]     ...future.result$conditions <- ...future.conditions
[13:35:36.253]     ...future.result$finished <- base::Sys.time()
[13:35:36.253]     ...future.result
[13:35:36.253] }
[13:35:36.255] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[13:35:36.255] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[13:35:36.256] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[13:35:36.256] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[13:35:36.256] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[13:35:36.256] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[13:35:36.257] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[13:35:36.257] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:35:36.257] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:35:36.257] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:35:36.258] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:35:36.258] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[13:35:36.258] MultisessionFuture started
[13:35:36.259] - Launch lazy future ... done
[13:35:36.259] run() for ‘MultisessionFuture’ ... done
[13:35:36.259] Created future:
[13:35:36.259] MultisessionFuture:
[13:35:36.259] Label: ‘future_mapply-2’
[13:35:36.259] Expression:
[13:35:36.259] {
[13:35:36.259]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:36.259]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:36.259]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:36.259]         on.exit(options(oopts), add = TRUE)
[13:35:36.259]     }
[13:35:36.259]     {
[13:35:36.259]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:36.259]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:35:36.259]         do.call(mapply, args = args)
[13:35:36.259]     }
[13:35:36.259] }
[13:35:36.259] Lazy evaluation: FALSE
[13:35:36.259] Asynchronous evaluation: TRUE
[13:35:36.259] Local evaluation: TRUE
[13:35:36.259] Environment: R_GlobalEnv
[13:35:36.259] Capture standard output: TRUE
[13:35:36.259] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:36.259] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:36.259] Packages: <none>
[13:35:36.259] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:36.259] Resolved: FALSE
[13:35:36.259] Value: <not collected>
[13:35:36.259] Conditions captured: <none>
[13:35:36.259] Early signaling: FALSE
[13:35:36.259] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:36.259] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:36.270] Chunk #2 of 2 ... DONE
[13:35:36.271] Launching 2 futures (chunks) ... DONE
[13:35:36.271] Resolving 2 futures (chunks) ...
[13:35:36.271] resolve() on list ...
[13:35:36.271]  recursive: 0
[13:35:36.271]  length: 2
[13:35:36.271] 
[13:35:36.313] receiveMessageFromWorker() for ClusterFuture ...
[13:35:36.313] - Validating connection of MultisessionFuture
[13:35:36.314] - received message: FutureResult
[13:35:36.314] - Received FutureResult
[13:35:36.314] - Erased future from FutureRegistry
[13:35:36.314] result() for ClusterFuture ...
[13:35:36.314] - result already collected: FutureResult
[13:35:36.314] result() for ClusterFuture ... done
[13:35:36.314] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:36.314] Future #2
[13:35:36.314] result() for ClusterFuture ...
[13:35:36.314] - result already collected: FutureResult
[13:35:36.315] result() for ClusterFuture ... done
[13:35:36.315] result() for ClusterFuture ...
[13:35:36.315] - result already collected: FutureResult
[13:35:36.315] result() for ClusterFuture ... done
[13:35:36.315] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:35:36.315] - nx: 2
[13:35:36.315] - relay: TRUE
[13:35:36.315] - stdout: TRUE
[13:35:36.315] - signal: TRUE
[13:35:36.315] - resignal: FALSE
[13:35:36.315] - force: TRUE
[13:35:36.316] - relayed: [n=2] FALSE, FALSE
[13:35:36.316] - queued futures: [n=2] FALSE, FALSE
[13:35:36.316]  - until=1
[13:35:36.316]  - relaying element #1
[13:35:36.316] - relayed: [n=2] FALSE, FALSE
[13:35:36.316] - queued futures: [n=2] FALSE, TRUE
[13:35:36.316] signalConditionsASAP(NULL, pos=2) ... done
[13:35:36.316]  length: 1 (resolved future 2)
[13:35:36.761] receiveMessageFromWorker() for ClusterFuture ...
[13:35:36.761] - Validating connection of MultisessionFuture
[13:35:36.761] - received message: FutureResult
[13:35:36.761] - Received FutureResult
[13:35:36.761] - Erased future from FutureRegistry
[13:35:36.761] result() for ClusterFuture ...
[13:35:36.762] - result already collected: FutureResult
[13:35:36.762] result() for ClusterFuture ... done
[13:35:36.762] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:36.762] Future #1
[13:35:36.762] result() for ClusterFuture ...
[13:35:36.762] - result already collected: FutureResult
[13:35:36.762] result() for ClusterFuture ... done
[13:35:36.762] result() for ClusterFuture ...
[13:35:36.762] - result already collected: FutureResult
[13:35:36.762] result() for ClusterFuture ... done
[13:35:36.763] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:35:36.763] - nx: 2
[13:35:36.763] - relay: TRUE
[13:35:36.763] - stdout: TRUE
[13:35:36.763] - signal: TRUE
[13:35:36.763] - resignal: FALSE
[13:35:36.763] - force: TRUE
[13:35:36.763] - relayed: [n=2] FALSE, FALSE
[13:35:36.763] - queued futures: [n=2] FALSE, TRUE
[13:35:36.763]  - until=1
[13:35:36.763]  - relaying element #1
[13:35:36.763] result() for ClusterFuture ...
[13:35:36.764] - result already collected: FutureResult
[13:35:36.764] result() for ClusterFuture ... done
[13:35:36.764] result() for ClusterFuture ...
[13:35:36.764] - result already collected: FutureResult
[13:35:36.764] result() for ClusterFuture ... done
[13:35:36.764] result() for ClusterFuture ...
[13:35:36.764] - result already collected: FutureResult
[13:35:36.764] result() for ClusterFuture ... done
[13:35:36.764] result() for ClusterFuture ...
[13:35:36.764] - result already collected: FutureResult
[13:35:36.764] result() for ClusterFuture ... done
[13:35:36.765] - relayed: [n=2] TRUE, FALSE
[13:35:36.765] - queued futures: [n=2] TRUE, TRUE
[13:35:36.765] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:35:36.765]  length: 0 (resolved future 1)
[13:35:36.765] Relaying remaining futures
[13:35:36.765] signalConditionsASAP(NULL, pos=0) ...
[13:35:36.765] - nx: 2
[13:35:36.765] - relay: TRUE
[13:35:36.765] - stdout: TRUE
[13:35:36.765] - signal: TRUE
[13:35:36.765] - resignal: FALSE
[13:35:36.766] - force: TRUE
[13:35:36.766] - relayed: [n=2] TRUE, FALSE
[13:35:36.766] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:36.766]  - relaying element #2
[13:35:36.766] result() for ClusterFuture ...
[13:35:36.766] - result already collected: FutureResult
[13:35:36.766] result() for ClusterFuture ... done
[13:35:36.766] result() for ClusterFuture ...
[13:35:36.766] - result already collected: FutureResult
[13:35:36.766] result() for ClusterFuture ... done
[13:35:36.767] result() for ClusterFuture ...
[13:35:36.767] - result already collected: FutureResult
[13:35:36.767] result() for ClusterFuture ... done
[13:35:36.767] result() for ClusterFuture ...
[13:35:36.767] - result already collected: FutureResult
[13:35:36.767] result() for ClusterFuture ... done
[13:35:36.767] - relayed: [n=2] TRUE, TRUE
[13:35:36.767] - queued futures: [n=2] TRUE, TRUE
[13:35:36.767] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[13:35:36.767] resolve() on list ... DONE
[13:35:36.767] result() for ClusterFuture ...
[13:35:36.767] - result already collected: FutureResult
[13:35:36.768] result() for ClusterFuture ... done
[13:35:36.768] result() for ClusterFuture ...
[13:35:36.768] - result already collected: FutureResult
[13:35:36.768] result() for ClusterFuture ... done
[13:35:36.768] result() for ClusterFuture ...
[13:35:36.768] - result already collected: FutureResult
[13:35:36.768] result() for ClusterFuture ... done
[13:35:36.768] result() for ClusterFuture ...
[13:35:36.768] - result already collected: FutureResult
[13:35:36.768] result() for ClusterFuture ... done
[13:35:36.768]  - Number of value chunks collected: 2
[13:35:36.769] Resolving 2 futures (chunks) ... DONE
[13:35:36.769] Reducing values from 2 chunks ...
[13:35:36.769]  - Number of values collected after concatenation: 2
[13:35:36.769]  - Number of values expected: 2
[13:35:36.769] Reducing values from 2 chunks ... DONE
[13:35:36.769] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[13:35:36.769] future_mapply() ...
[13:35:36.773] Number of chunks: 2
[13:35:36.773] getGlobalsAndPackagesXApply() ...
[13:35:36.774]  - future.globals: TRUE
[13:35:36.774] getGlobalsAndPackages() ...
[13:35:36.774] Searching for globals...
[13:35:36.776] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[13:35:36.776] Searching for globals ... DONE
[13:35:36.776] Resolving globals: FALSE
[13:35:36.776] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[13:35:36.777] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[13:35:36.777] - globals: [1] ‘FUN’
[13:35:36.777] 
[13:35:36.777] getGlobalsAndPackages() ... DONE
[13:35:36.777]  - globals found/used: [n=1] ‘FUN’
[13:35:36.777]  - needed namespaces: [n=0] 
[13:35:36.777] Finding globals ... DONE
[13:35:36.777] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[13:35:36.778] List of 2
[13:35:36.778]  $ ...future.FUN:function (x, y)  
[13:35:36.778]  $ MoreArgs     : NULL
[13:35:36.778]  - attr(*, "where")=List of 2
[13:35:36.778]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:36.778]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[13:35:36.778]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:36.778]  - attr(*, "resolved")= logi FALSE
[13:35:36.778]  - attr(*, "total_size")= num NA
[13:35:36.780] Packages to be attached in all futures: [n=0] 
[13:35:36.780] getGlobalsAndPackagesXApply() ... DONE
[13:35:36.780] Number of futures (= number of chunks): 2
[13:35:36.781] Launching 2 futures (chunks) ...
[13:35:36.781] Chunk #1 of 2 ...
[13:35:36.781]  - Finding globals in '...' for chunk #1 ...
[13:35:36.781] getGlobalsAndPackages() ...
[13:35:36.781] Searching for globals...
[13:35:36.781] 
[13:35:36.781] Searching for globals ... DONE
[13:35:36.781] - globals: [0] <none>
[13:35:36.781] getGlobalsAndPackages() ... DONE
[13:35:36.782]    + additional globals found: [n=0] 
[13:35:36.782]    + additional namespaces needed: [n=0] 
[13:35:36.782]  - Finding globals in '...' for chunk #1 ... DONE
[13:35:36.782]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:36.782]  - seeds: <none>
[13:35:36.782]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:36.782] getGlobalsAndPackages() ...
[13:35:36.782] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:36.782] Resolving globals: FALSE
[13:35:36.783] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:35:36.783] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:35:36.783] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:36.783] 
[13:35:36.784] getGlobalsAndPackages() ... DONE
[13:35:36.784] run() for ‘Future’ ...
[13:35:36.784] - state: ‘created’
[13:35:36.784] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:36.798] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:36.798] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:36.798]   - Field: ‘node’
[13:35:36.798]   - Field: ‘label’
[13:35:36.798]   - Field: ‘local’
[13:35:36.798]   - Field: ‘owner’
[13:35:36.798]   - Field: ‘envir’
[13:35:36.798]   - Field: ‘workers’
[13:35:36.799]   - Field: ‘packages’
[13:35:36.799]   - Field: ‘gc’
[13:35:36.799]   - Field: ‘conditions’
[13:35:36.799]   - Field: ‘persistent’
[13:35:36.799]   - Field: ‘expr’
[13:35:36.799]   - Field: ‘uuid’
[13:35:36.799]   - Field: ‘seed’
[13:35:36.799]   - Field: ‘version’
[13:35:36.799]   - Field: ‘result’
[13:35:36.799]   - Field: ‘asynchronous’
[13:35:36.799]   - Field: ‘calls’
[13:35:36.800]   - Field: ‘globals’
[13:35:36.800]   - Field: ‘stdout’
[13:35:36.800]   - Field: ‘earlySignal’
[13:35:36.800]   - Field: ‘lazy’
[13:35:36.800]   - Field: ‘state’
[13:35:36.800] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:36.800] - Launch lazy future ...
[13:35:36.800] Packages needed by the future expression (n = 0): <none>
[13:35:36.800] Packages needed by future strategies (n = 0): <none>
[13:35:36.801] {
[13:35:36.801]     {
[13:35:36.801]         {
[13:35:36.801]             ...future.startTime <- base::Sys.time()
[13:35:36.801]             {
[13:35:36.801]                 {
[13:35:36.801]                   {
[13:35:36.801]                     {
[13:35:36.801]                       base::local({
[13:35:36.801]                         has_future <- base::requireNamespace("future", 
[13:35:36.801]                           quietly = TRUE)
[13:35:36.801]                         if (has_future) {
[13:35:36.801]                           ns <- base::getNamespace("future")
[13:35:36.801]                           version <- ns[[".package"]][["version"]]
[13:35:36.801]                           if (is.null(version)) 
[13:35:36.801]                             version <- utils::packageVersion("future")
[13:35:36.801]                         }
[13:35:36.801]                         else {
[13:35:36.801]                           version <- NULL
[13:35:36.801]                         }
[13:35:36.801]                         if (!has_future || version < "1.8.0") {
[13:35:36.801]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:36.801]                             "", base::R.version$version.string), 
[13:35:36.801]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:36.801]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:36.801]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:36.801]                               "release", "version")], collapse = " "), 
[13:35:36.801]                             hostname = base::Sys.info()[["nodename"]])
[13:35:36.801]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:36.801]                             info)
[13:35:36.801]                           info <- base::paste(info, collapse = "; ")
[13:35:36.801]                           if (!has_future) {
[13:35:36.801]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:36.801]                               info)
[13:35:36.801]                           }
[13:35:36.801]                           else {
[13:35:36.801]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:36.801]                               info, version)
[13:35:36.801]                           }
[13:35:36.801]                           base::stop(msg)
[13:35:36.801]                         }
[13:35:36.801]                       })
[13:35:36.801]                     }
[13:35:36.801]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:36.801]                     base::options(mc.cores = 1L)
[13:35:36.801]                   }
[13:35:36.801]                   ...future.strategy.old <- future::plan("list")
[13:35:36.801]                   options(future.plan = NULL)
[13:35:36.801]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:36.801]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:36.801]                 }
[13:35:36.801]                 ...future.workdir <- getwd()
[13:35:36.801]             }
[13:35:36.801]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:36.801]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:36.801]         }
[13:35:36.801]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:36.801]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:36.801]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:36.801]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:36.801]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:36.801]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:36.801]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:36.801]             base::names(...future.oldOptions))
[13:35:36.801]     }
[13:35:36.801]     if (TRUE) {
[13:35:36.801]     }
[13:35:36.801]     else {
[13:35:36.801]         if (NA) {
[13:35:36.801]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:36.801]                 open = "w")
[13:35:36.801]         }
[13:35:36.801]         else {
[13:35:36.801]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:36.801]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:36.801]         }
[13:35:36.801]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:36.801]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:36.801]             base::sink(type = "output", split = FALSE)
[13:35:36.801]             base::close(...future.stdout)
[13:35:36.801]         }, add = TRUE)
[13:35:36.801]     }
[13:35:36.801]     ...future.frame <- base::sys.nframe()
[13:35:36.801]     ...future.conditions <- base::list()
[13:35:36.801]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:36.801]     if (FALSE) {
[13:35:36.801]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:36.801]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:36.801]     }
[13:35:36.801]     ...future.result <- base::tryCatch({
[13:35:36.801]         base::withCallingHandlers({
[13:35:36.801]             ...future.value <- base::withVisible(base::local({
[13:35:36.801]                 ...future.makeSendCondition <- base::local({
[13:35:36.801]                   sendCondition <- NULL
[13:35:36.801]                   function(frame = 1L) {
[13:35:36.801]                     if (is.function(sendCondition)) 
[13:35:36.801]                       return(sendCondition)
[13:35:36.801]                     ns <- getNamespace("parallel")
[13:35:36.801]                     if (exists("sendData", mode = "function", 
[13:35:36.801]                       envir = ns)) {
[13:35:36.801]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:36.801]                         envir = ns)
[13:35:36.801]                       envir <- sys.frame(frame)
[13:35:36.801]                       master <- NULL
[13:35:36.801]                       while (!identical(envir, .GlobalEnv) && 
[13:35:36.801]                         !identical(envir, emptyenv())) {
[13:35:36.801]                         if (exists("master", mode = "list", envir = envir, 
[13:35:36.801]                           inherits = FALSE)) {
[13:35:36.801]                           master <- get("master", mode = "list", 
[13:35:36.801]                             envir = envir, inherits = FALSE)
[13:35:36.801]                           if (inherits(master, c("SOCKnode", 
[13:35:36.801]                             "SOCK0node"))) {
[13:35:36.801]                             sendCondition <<- function(cond) {
[13:35:36.801]                               data <- list(type = "VALUE", value = cond, 
[13:35:36.801]                                 success = TRUE)
[13:35:36.801]                               parallel_sendData(master, data)
[13:35:36.801]                             }
[13:35:36.801]                             return(sendCondition)
[13:35:36.801]                           }
[13:35:36.801]                         }
[13:35:36.801]                         frame <- frame + 1L
[13:35:36.801]                         envir <- sys.frame(frame)
[13:35:36.801]                       }
[13:35:36.801]                     }
[13:35:36.801]                     sendCondition <<- function(cond) NULL
[13:35:36.801]                   }
[13:35:36.801]                 })
[13:35:36.801]                 withCallingHandlers({
[13:35:36.801]                   {
[13:35:36.801]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:36.801]                     if (!identical(...future.globals.maxSize.org, 
[13:35:36.801]                       ...future.globals.maxSize)) {
[13:35:36.801]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:36.801]                       on.exit(options(oopts), add = TRUE)
[13:35:36.801]                     }
[13:35:36.801]                     {
[13:35:36.801]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:36.801]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:35:36.801]                         USE.NAMES = FALSE)
[13:35:36.801]                       do.call(mapply, args = args)
[13:35:36.801]                     }
[13:35:36.801]                   }
[13:35:36.801]                 }, immediateCondition = function(cond) {
[13:35:36.801]                   sendCondition <- ...future.makeSendCondition()
[13:35:36.801]                   sendCondition(cond)
[13:35:36.801]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:36.801]                   {
[13:35:36.801]                     inherits <- base::inherits
[13:35:36.801]                     invokeRestart <- base::invokeRestart
[13:35:36.801]                     is.null <- base::is.null
[13:35:36.801]                     muffled <- FALSE
[13:35:36.801]                     if (inherits(cond, "message")) {
[13:35:36.801]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:36.801]                       if (muffled) 
[13:35:36.801]                         invokeRestart("muffleMessage")
[13:35:36.801]                     }
[13:35:36.801]                     else if (inherits(cond, "warning")) {
[13:35:36.801]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:36.801]                       if (muffled) 
[13:35:36.801]                         invokeRestart("muffleWarning")
[13:35:36.801]                     }
[13:35:36.801]                     else if (inherits(cond, "condition")) {
[13:35:36.801]                       if (!is.null(pattern)) {
[13:35:36.801]                         computeRestarts <- base::computeRestarts
[13:35:36.801]                         grepl <- base::grepl
[13:35:36.801]                         restarts <- computeRestarts(cond)
[13:35:36.801]                         for (restart in restarts) {
[13:35:36.801]                           name <- restart$name
[13:35:36.801]                           if (is.null(name)) 
[13:35:36.801]                             next
[13:35:36.801]                           if (!grepl(pattern, name)) 
[13:35:36.801]                             next
[13:35:36.801]                           invokeRestart(restart)
[13:35:36.801]                           muffled <- TRUE
[13:35:36.801]                           break
[13:35:36.801]                         }
[13:35:36.801]                       }
[13:35:36.801]                     }
[13:35:36.801]                     invisible(muffled)
[13:35:36.801]                   }
[13:35:36.801]                   muffleCondition(cond)
[13:35:36.801]                 })
[13:35:36.801]             }))
[13:35:36.801]             future::FutureResult(value = ...future.value$value, 
[13:35:36.801]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:36.801]                   ...future.rng), globalenv = if (FALSE) 
[13:35:36.801]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:36.801]                     ...future.globalenv.names))
[13:35:36.801]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:36.801]         }, condition = base::local({
[13:35:36.801]             c <- base::c
[13:35:36.801]             inherits <- base::inherits
[13:35:36.801]             invokeRestart <- base::invokeRestart
[13:35:36.801]             length <- base::length
[13:35:36.801]             list <- base::list
[13:35:36.801]             seq.int <- base::seq.int
[13:35:36.801]             signalCondition <- base::signalCondition
[13:35:36.801]             sys.calls <- base::sys.calls
[13:35:36.801]             `[[` <- base::`[[`
[13:35:36.801]             `+` <- base::`+`
[13:35:36.801]             `<<-` <- base::`<<-`
[13:35:36.801]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:36.801]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:36.801]                   3L)]
[13:35:36.801]             }
[13:35:36.801]             function(cond) {
[13:35:36.801]                 is_error <- inherits(cond, "error")
[13:35:36.801]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:36.801]                   NULL)
[13:35:36.801]                 if (is_error) {
[13:35:36.801]                   sessionInformation <- function() {
[13:35:36.801]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:36.801]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:36.801]                       search = base::search(), system = base::Sys.info())
[13:35:36.801]                   }
[13:35:36.801]                   ...future.conditions[[length(...future.conditions) + 
[13:35:36.801]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:36.801]                     cond$call), session = sessionInformation(), 
[13:35:36.801]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:36.801]                   signalCondition(cond)
[13:35:36.801]                 }
[13:35:36.801]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:36.801]                 "immediateCondition"))) {
[13:35:36.801]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:36.801]                   ...future.conditions[[length(...future.conditions) + 
[13:35:36.801]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:36.801]                   if (TRUE && !signal) {
[13:35:36.801]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:36.801]                     {
[13:35:36.801]                       inherits <- base::inherits
[13:35:36.801]                       invokeRestart <- base::invokeRestart
[13:35:36.801]                       is.null <- base::is.null
[13:35:36.801]                       muffled <- FALSE
[13:35:36.801]                       if (inherits(cond, "message")) {
[13:35:36.801]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:36.801]                         if (muffled) 
[13:35:36.801]                           invokeRestart("muffleMessage")
[13:35:36.801]                       }
[13:35:36.801]                       else if (inherits(cond, "warning")) {
[13:35:36.801]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:36.801]                         if (muffled) 
[13:35:36.801]                           invokeRestart("muffleWarning")
[13:35:36.801]                       }
[13:35:36.801]                       else if (inherits(cond, "condition")) {
[13:35:36.801]                         if (!is.null(pattern)) {
[13:35:36.801]                           computeRestarts <- base::computeRestarts
[13:35:36.801]                           grepl <- base::grepl
[13:35:36.801]                           restarts <- computeRestarts(cond)
[13:35:36.801]                           for (restart in restarts) {
[13:35:36.801]                             name <- restart$name
[13:35:36.801]                             if (is.null(name)) 
[13:35:36.801]                               next
[13:35:36.801]                             if (!grepl(pattern, name)) 
[13:35:36.801]                               next
[13:35:36.801]                             invokeRestart(restart)
[13:35:36.801]                             muffled <- TRUE
[13:35:36.801]                             break
[13:35:36.801]                           }
[13:35:36.801]                         }
[13:35:36.801]                       }
[13:35:36.801]                       invisible(muffled)
[13:35:36.801]                     }
[13:35:36.801]                     muffleCondition(cond, pattern = "^muffle")
[13:35:36.801]                   }
[13:35:36.801]                 }
[13:35:36.801]                 else {
[13:35:36.801]                   if (TRUE) {
[13:35:36.801]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:36.801]                     {
[13:35:36.801]                       inherits <- base::inherits
[13:35:36.801]                       invokeRestart <- base::invokeRestart
[13:35:36.801]                       is.null <- base::is.null
[13:35:36.801]                       muffled <- FALSE
[13:35:36.801]                       if (inherits(cond, "message")) {
[13:35:36.801]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:36.801]                         if (muffled) 
[13:35:36.801]                           invokeRestart("muffleMessage")
[13:35:36.801]                       }
[13:35:36.801]                       else if (inherits(cond, "warning")) {
[13:35:36.801]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:36.801]                         if (muffled) 
[13:35:36.801]                           invokeRestart("muffleWarning")
[13:35:36.801]                       }
[13:35:36.801]                       else if (inherits(cond, "condition")) {
[13:35:36.801]                         if (!is.null(pattern)) {
[13:35:36.801]                           computeRestarts <- base::computeRestarts
[13:35:36.801]                           grepl <- base::grepl
[13:35:36.801]                           restarts <- computeRestarts(cond)
[13:35:36.801]                           for (restart in restarts) {
[13:35:36.801]                             name <- restart$name
[13:35:36.801]                             if (is.null(name)) 
[13:35:36.801]                               next
[13:35:36.801]                             if (!grepl(pattern, name)) 
[13:35:36.801]                               next
[13:35:36.801]                             invokeRestart(restart)
[13:35:36.801]                             muffled <- TRUE
[13:35:36.801]                             break
[13:35:36.801]                           }
[13:35:36.801]                         }
[13:35:36.801]                       }
[13:35:36.801]                       invisible(muffled)
[13:35:36.801]                     }
[13:35:36.801]                     muffleCondition(cond, pattern = "^muffle")
[13:35:36.801]                   }
[13:35:36.801]                 }
[13:35:36.801]             }
[13:35:36.801]         }))
[13:35:36.801]     }, error = function(ex) {
[13:35:36.801]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:36.801]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:36.801]                 ...future.rng), started = ...future.startTime, 
[13:35:36.801]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:36.801]             version = "1.8"), class = "FutureResult")
[13:35:36.801]     }, finally = {
[13:35:36.801]         if (!identical(...future.workdir, getwd())) 
[13:35:36.801]             setwd(...future.workdir)
[13:35:36.801]         {
[13:35:36.801]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:36.801]                 ...future.oldOptions$nwarnings <- NULL
[13:35:36.801]             }
[13:35:36.801]             base::options(...future.oldOptions)
[13:35:36.801]             if (.Platform$OS.type == "windows") {
[13:35:36.801]                 old_names <- names(...future.oldEnvVars)
[13:35:36.801]                 envs <- base::Sys.getenv()
[13:35:36.801]                 names <- names(envs)
[13:35:36.801]                 common <- intersect(names, old_names)
[13:35:36.801]                 added <- setdiff(names, old_names)
[13:35:36.801]                 removed <- setdiff(old_names, names)
[13:35:36.801]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:36.801]                   envs[common]]
[13:35:36.801]                 NAMES <- toupper(changed)
[13:35:36.801]                 args <- list()
[13:35:36.801]                 for (kk in seq_along(NAMES)) {
[13:35:36.801]                   name <- changed[[kk]]
[13:35:36.801]                   NAME <- NAMES[[kk]]
[13:35:36.801]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:36.801]                     next
[13:35:36.801]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:36.801]                 }
[13:35:36.801]                 NAMES <- toupper(added)
[13:35:36.801]                 for (kk in seq_along(NAMES)) {
[13:35:36.801]                   name <- added[[kk]]
[13:35:36.801]                   NAME <- NAMES[[kk]]
[13:35:36.801]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:36.801]                     next
[13:35:36.801]                   args[[name]] <- ""
[13:35:36.801]                 }
[13:35:36.801]                 NAMES <- toupper(removed)
[13:35:36.801]                 for (kk in seq_along(NAMES)) {
[13:35:36.801]                   name <- removed[[kk]]
[13:35:36.801]                   NAME <- NAMES[[kk]]
[13:35:36.801]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:36.801]                     next
[13:35:36.801]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:36.801]                 }
[13:35:36.801]                 if (length(args) > 0) 
[13:35:36.801]                   base::do.call(base::Sys.setenv, args = args)
[13:35:36.801]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:36.801]             }
[13:35:36.801]             else {
[13:35:36.801]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:36.801]             }
[13:35:36.801]             {
[13:35:36.801]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:36.801]                   0L) {
[13:35:36.801]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:36.801]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:36.801]                   base::options(opts)
[13:35:36.801]                 }
[13:35:36.801]                 {
[13:35:36.801]                   {
[13:35:36.801]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:36.801]                     NULL
[13:35:36.801]                   }
[13:35:36.801]                   options(future.plan = NULL)
[13:35:36.801]                   if (is.na(NA_character_)) 
[13:35:36.801]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:36.801]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:36.801]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:36.801]                     .init = FALSE)
[13:35:36.801]                 }
[13:35:36.801]             }
[13:35:36.801]         }
[13:35:36.801]     })
[13:35:36.801]     if (FALSE) {
[13:35:36.801]         base::sink(type = "output", split = FALSE)
[13:35:36.801]         if (NA) {
[13:35:36.801]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:36.801]         }
[13:35:36.801]         else {
[13:35:36.801]             ...future.result["stdout"] <- base::list(NULL)
[13:35:36.801]         }
[13:35:36.801]         base::close(...future.stdout)
[13:35:36.801]         ...future.stdout <- NULL
[13:35:36.801]     }
[13:35:36.801]     ...future.result$conditions <- ...future.conditions
[13:35:36.801]     ...future.result$finished <- base::Sys.time()
[13:35:36.801]     ...future.result
[13:35:36.801] }
[13:35:36.804] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[13:35:36.804] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[13:35:36.804] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[13:35:36.804] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[13:35:36.805] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[13:35:36.805] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[13:35:36.805] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[13:35:36.805] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:36.806] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:36.806] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:36.806] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:36.806] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[13:35:36.807] MultisessionFuture started
[13:35:36.807] - Launch lazy future ... done
[13:35:36.807] run() for ‘MultisessionFuture’ ... done
[13:35:36.807] Created future:
[13:35:36.807] MultisessionFuture:
[13:35:36.807] Label: ‘future_mapply-1’
[13:35:36.807] Expression:
[13:35:36.807] {
[13:35:36.807]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:36.807]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:36.807]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:36.807]         on.exit(options(oopts), add = TRUE)
[13:35:36.807]     }
[13:35:36.807]     {
[13:35:36.807]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:36.807]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:35:36.807]         do.call(mapply, args = args)
[13:35:36.807]     }
[13:35:36.807] }
[13:35:36.807] Lazy evaluation: FALSE
[13:35:36.807] Asynchronous evaluation: TRUE
[13:35:36.807] Local evaluation: TRUE
[13:35:36.807] Environment: R_GlobalEnv
[13:35:36.807] Capture standard output: NA
[13:35:36.807] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:36.807] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:36.807] Packages: <none>
[13:35:36.807] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:36.807] Resolved: FALSE
[13:35:36.807] Value: <not collected>
[13:35:36.807] Conditions captured: <none>
[13:35:36.807] Early signaling: FALSE
[13:35:36.807] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:36.807] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:36.818] Chunk #1 of 2 ... DONE
[13:35:36.818] Chunk #2 of 2 ...
[13:35:36.819]  - Finding globals in '...' for chunk #2 ...
[13:35:36.819] getGlobalsAndPackages() ...
[13:35:36.819] Searching for globals...
[13:35:36.819] 
[13:35:36.819] Searching for globals ... DONE
[13:35:36.819] - globals: [0] <none>
[13:35:36.819] getGlobalsAndPackages() ... DONE
[13:35:36.820]    + additional globals found: [n=0] 
[13:35:36.820]    + additional namespaces needed: [n=0] 
[13:35:36.820]  - Finding globals in '...' for chunk #2 ... DONE
[13:35:36.820]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:36.820]  - seeds: <none>
[13:35:36.820]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:36.820] getGlobalsAndPackages() ...
[13:35:36.820] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:36.820] Resolving globals: FALSE
[13:35:36.821] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[13:35:36.821] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[13:35:36.821] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:36.821] 
[13:35:36.821] getGlobalsAndPackages() ... DONE
[13:35:36.822] run() for ‘Future’ ...
[13:35:36.822] - state: ‘created’
[13:35:36.822] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:36.835] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:36.835] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:36.836]   - Field: ‘node’
[13:35:36.836]   - Field: ‘label’
[13:35:36.836]   - Field: ‘local’
[13:35:36.836]   - Field: ‘owner’
[13:35:36.836]   - Field: ‘envir’
[13:35:36.836]   - Field: ‘workers’
[13:35:36.836]   - Field: ‘packages’
[13:35:36.836]   - Field: ‘gc’
[13:35:36.836]   - Field: ‘conditions’
[13:35:36.836]   - Field: ‘persistent’
[13:35:36.836]   - Field: ‘expr’
[13:35:36.837]   - Field: ‘uuid’
[13:35:36.837]   - Field: ‘seed’
[13:35:36.837]   - Field: ‘version’
[13:35:36.837]   - Field: ‘result’
[13:35:36.837]   - Field: ‘asynchronous’
[13:35:36.837]   - Field: ‘calls’
[13:35:36.837]   - Field: ‘globals’
[13:35:36.837]   - Field: ‘stdout’
[13:35:36.837]   - Field: ‘earlySignal’
[13:35:36.837]   - Field: ‘lazy’
[13:35:36.837]   - Field: ‘state’
[13:35:36.838] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:36.838] - Launch lazy future ...
[13:35:36.838] Packages needed by the future expression (n = 0): <none>
[13:35:36.838] Packages needed by future strategies (n = 0): <none>
[13:35:36.838] {
[13:35:36.838]     {
[13:35:36.838]         {
[13:35:36.838]             ...future.startTime <- base::Sys.time()
[13:35:36.838]             {
[13:35:36.838]                 {
[13:35:36.838]                   {
[13:35:36.838]                     {
[13:35:36.838]                       base::local({
[13:35:36.838]                         has_future <- base::requireNamespace("future", 
[13:35:36.838]                           quietly = TRUE)
[13:35:36.838]                         if (has_future) {
[13:35:36.838]                           ns <- base::getNamespace("future")
[13:35:36.838]                           version <- ns[[".package"]][["version"]]
[13:35:36.838]                           if (is.null(version)) 
[13:35:36.838]                             version <- utils::packageVersion("future")
[13:35:36.838]                         }
[13:35:36.838]                         else {
[13:35:36.838]                           version <- NULL
[13:35:36.838]                         }
[13:35:36.838]                         if (!has_future || version < "1.8.0") {
[13:35:36.838]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:36.838]                             "", base::R.version$version.string), 
[13:35:36.838]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:36.838]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:36.838]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:36.838]                               "release", "version")], collapse = " "), 
[13:35:36.838]                             hostname = base::Sys.info()[["nodename"]])
[13:35:36.838]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:36.838]                             info)
[13:35:36.838]                           info <- base::paste(info, collapse = "; ")
[13:35:36.838]                           if (!has_future) {
[13:35:36.838]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:36.838]                               info)
[13:35:36.838]                           }
[13:35:36.838]                           else {
[13:35:36.838]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:36.838]                               info, version)
[13:35:36.838]                           }
[13:35:36.838]                           base::stop(msg)
[13:35:36.838]                         }
[13:35:36.838]                       })
[13:35:36.838]                     }
[13:35:36.838]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:36.838]                     base::options(mc.cores = 1L)
[13:35:36.838]                   }
[13:35:36.838]                   ...future.strategy.old <- future::plan("list")
[13:35:36.838]                   options(future.plan = NULL)
[13:35:36.838]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:36.838]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:36.838]                 }
[13:35:36.838]                 ...future.workdir <- getwd()
[13:35:36.838]             }
[13:35:36.838]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:36.838]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:36.838]         }
[13:35:36.838]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:36.838]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:36.838]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:36.838]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:36.838]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:36.838]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:36.838]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:36.838]             base::names(...future.oldOptions))
[13:35:36.838]     }
[13:35:36.838]     if (TRUE) {
[13:35:36.838]     }
[13:35:36.838]     else {
[13:35:36.838]         if (NA) {
[13:35:36.838]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:36.838]                 open = "w")
[13:35:36.838]         }
[13:35:36.838]         else {
[13:35:36.838]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:36.838]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:36.838]         }
[13:35:36.838]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:36.838]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:36.838]             base::sink(type = "output", split = FALSE)
[13:35:36.838]             base::close(...future.stdout)
[13:35:36.838]         }, add = TRUE)
[13:35:36.838]     }
[13:35:36.838]     ...future.frame <- base::sys.nframe()
[13:35:36.838]     ...future.conditions <- base::list()
[13:35:36.838]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:36.838]     if (FALSE) {
[13:35:36.838]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:36.838]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:36.838]     }
[13:35:36.838]     ...future.result <- base::tryCatch({
[13:35:36.838]         base::withCallingHandlers({
[13:35:36.838]             ...future.value <- base::withVisible(base::local({
[13:35:36.838]                 ...future.makeSendCondition <- base::local({
[13:35:36.838]                   sendCondition <- NULL
[13:35:36.838]                   function(frame = 1L) {
[13:35:36.838]                     if (is.function(sendCondition)) 
[13:35:36.838]                       return(sendCondition)
[13:35:36.838]                     ns <- getNamespace("parallel")
[13:35:36.838]                     if (exists("sendData", mode = "function", 
[13:35:36.838]                       envir = ns)) {
[13:35:36.838]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:36.838]                         envir = ns)
[13:35:36.838]                       envir <- sys.frame(frame)
[13:35:36.838]                       master <- NULL
[13:35:36.838]                       while (!identical(envir, .GlobalEnv) && 
[13:35:36.838]                         !identical(envir, emptyenv())) {
[13:35:36.838]                         if (exists("master", mode = "list", envir = envir, 
[13:35:36.838]                           inherits = FALSE)) {
[13:35:36.838]                           master <- get("master", mode = "list", 
[13:35:36.838]                             envir = envir, inherits = FALSE)
[13:35:36.838]                           if (inherits(master, c("SOCKnode", 
[13:35:36.838]                             "SOCK0node"))) {
[13:35:36.838]                             sendCondition <<- function(cond) {
[13:35:36.838]                               data <- list(type = "VALUE", value = cond, 
[13:35:36.838]                                 success = TRUE)
[13:35:36.838]                               parallel_sendData(master, data)
[13:35:36.838]                             }
[13:35:36.838]                             return(sendCondition)
[13:35:36.838]                           }
[13:35:36.838]                         }
[13:35:36.838]                         frame <- frame + 1L
[13:35:36.838]                         envir <- sys.frame(frame)
[13:35:36.838]                       }
[13:35:36.838]                     }
[13:35:36.838]                     sendCondition <<- function(cond) NULL
[13:35:36.838]                   }
[13:35:36.838]                 })
[13:35:36.838]                 withCallingHandlers({
[13:35:36.838]                   {
[13:35:36.838]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:36.838]                     if (!identical(...future.globals.maxSize.org, 
[13:35:36.838]                       ...future.globals.maxSize)) {
[13:35:36.838]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:36.838]                       on.exit(options(oopts), add = TRUE)
[13:35:36.838]                     }
[13:35:36.838]                     {
[13:35:36.838]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:36.838]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[13:35:36.838]                         USE.NAMES = FALSE)
[13:35:36.838]                       do.call(mapply, args = args)
[13:35:36.838]                     }
[13:35:36.838]                   }
[13:35:36.838]                 }, immediateCondition = function(cond) {
[13:35:36.838]                   sendCondition <- ...future.makeSendCondition()
[13:35:36.838]                   sendCondition(cond)
[13:35:36.838]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:36.838]                   {
[13:35:36.838]                     inherits <- base::inherits
[13:35:36.838]                     invokeRestart <- base::invokeRestart
[13:35:36.838]                     is.null <- base::is.null
[13:35:36.838]                     muffled <- FALSE
[13:35:36.838]                     if (inherits(cond, "message")) {
[13:35:36.838]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:36.838]                       if (muffled) 
[13:35:36.838]                         invokeRestart("muffleMessage")
[13:35:36.838]                     }
[13:35:36.838]                     else if (inherits(cond, "warning")) {
[13:35:36.838]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:36.838]                       if (muffled) 
[13:35:36.838]                         invokeRestart("muffleWarning")
[13:35:36.838]                     }
[13:35:36.838]                     else if (inherits(cond, "condition")) {
[13:35:36.838]                       if (!is.null(pattern)) {
[13:35:36.838]                         computeRestarts <- base::computeRestarts
[13:35:36.838]                         grepl <- base::grepl
[13:35:36.838]                         restarts <- computeRestarts(cond)
[13:35:36.838]                         for (restart in restarts) {
[13:35:36.838]                           name <- restart$name
[13:35:36.838]                           if (is.null(name)) 
[13:35:36.838]                             next
[13:35:36.838]                           if (!grepl(pattern, name)) 
[13:35:36.838]                             next
[13:35:36.838]                           invokeRestart(restart)
[13:35:36.838]                           muffled <- TRUE
[13:35:36.838]                           break
[13:35:36.838]                         }
[13:35:36.838]                       }
[13:35:36.838]                     }
[13:35:36.838]                     invisible(muffled)
[13:35:36.838]                   }
[13:35:36.838]                   muffleCondition(cond)
[13:35:36.838]                 })
[13:35:36.838]             }))
[13:35:36.838]             future::FutureResult(value = ...future.value$value, 
[13:35:36.838]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:36.838]                   ...future.rng), globalenv = if (FALSE) 
[13:35:36.838]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:36.838]                     ...future.globalenv.names))
[13:35:36.838]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:36.838]         }, condition = base::local({
[13:35:36.838]             c <- base::c
[13:35:36.838]             inherits <- base::inherits
[13:35:36.838]             invokeRestart <- base::invokeRestart
[13:35:36.838]             length <- base::length
[13:35:36.838]             list <- base::list
[13:35:36.838]             seq.int <- base::seq.int
[13:35:36.838]             signalCondition <- base::signalCondition
[13:35:36.838]             sys.calls <- base::sys.calls
[13:35:36.838]             `[[` <- base::`[[`
[13:35:36.838]             `+` <- base::`+`
[13:35:36.838]             `<<-` <- base::`<<-`
[13:35:36.838]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:36.838]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:36.838]                   3L)]
[13:35:36.838]             }
[13:35:36.838]             function(cond) {
[13:35:36.838]                 is_error <- inherits(cond, "error")
[13:35:36.838]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:36.838]                   NULL)
[13:35:36.838]                 if (is_error) {
[13:35:36.838]                   sessionInformation <- function() {
[13:35:36.838]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:36.838]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:36.838]                       search = base::search(), system = base::Sys.info())
[13:35:36.838]                   }
[13:35:36.838]                   ...future.conditions[[length(...future.conditions) + 
[13:35:36.838]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:36.838]                     cond$call), session = sessionInformation(), 
[13:35:36.838]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:36.838]                   signalCondition(cond)
[13:35:36.838]                 }
[13:35:36.838]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:36.838]                 "immediateCondition"))) {
[13:35:36.838]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:36.838]                   ...future.conditions[[length(...future.conditions) + 
[13:35:36.838]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:36.838]                   if (TRUE && !signal) {
[13:35:36.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:36.838]                     {
[13:35:36.838]                       inherits <- base::inherits
[13:35:36.838]                       invokeRestart <- base::invokeRestart
[13:35:36.838]                       is.null <- base::is.null
[13:35:36.838]                       muffled <- FALSE
[13:35:36.838]                       if (inherits(cond, "message")) {
[13:35:36.838]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:36.838]                         if (muffled) 
[13:35:36.838]                           invokeRestart("muffleMessage")
[13:35:36.838]                       }
[13:35:36.838]                       else if (inherits(cond, "warning")) {
[13:35:36.838]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:36.838]                         if (muffled) 
[13:35:36.838]                           invokeRestart("muffleWarning")
[13:35:36.838]                       }
[13:35:36.838]                       else if (inherits(cond, "condition")) {
[13:35:36.838]                         if (!is.null(pattern)) {
[13:35:36.838]                           computeRestarts <- base::computeRestarts
[13:35:36.838]                           grepl <- base::grepl
[13:35:36.838]                           restarts <- computeRestarts(cond)
[13:35:36.838]                           for (restart in restarts) {
[13:35:36.838]                             name <- restart$name
[13:35:36.838]                             if (is.null(name)) 
[13:35:36.838]                               next
[13:35:36.838]                             if (!grepl(pattern, name)) 
[13:35:36.838]                               next
[13:35:36.838]                             invokeRestart(restart)
[13:35:36.838]                             muffled <- TRUE
[13:35:36.838]                             break
[13:35:36.838]                           }
[13:35:36.838]                         }
[13:35:36.838]                       }
[13:35:36.838]                       invisible(muffled)
[13:35:36.838]                     }
[13:35:36.838]                     muffleCondition(cond, pattern = "^muffle")
[13:35:36.838]                   }
[13:35:36.838]                 }
[13:35:36.838]                 else {
[13:35:36.838]                   if (TRUE) {
[13:35:36.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:36.838]                     {
[13:35:36.838]                       inherits <- base::inherits
[13:35:36.838]                       invokeRestart <- base::invokeRestart
[13:35:36.838]                       is.null <- base::is.null
[13:35:36.838]                       muffled <- FALSE
[13:35:36.838]                       if (inherits(cond, "message")) {
[13:35:36.838]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:36.838]                         if (muffled) 
[13:35:36.838]                           invokeRestart("muffleMessage")
[13:35:36.838]                       }
[13:35:36.838]                       else if (inherits(cond, "warning")) {
[13:35:36.838]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:36.838]                         if (muffled) 
[13:35:36.838]                           invokeRestart("muffleWarning")
[13:35:36.838]                       }
[13:35:36.838]                       else if (inherits(cond, "condition")) {
[13:35:36.838]                         if (!is.null(pattern)) {
[13:35:36.838]                           computeRestarts <- base::computeRestarts
[13:35:36.838]                           grepl <- base::grepl
[13:35:36.838]                           restarts <- computeRestarts(cond)
[13:35:36.838]                           for (restart in restarts) {
[13:35:36.838]                             name <- restart$name
[13:35:36.838]                             if (is.null(name)) 
[13:35:36.838]                               next
[13:35:36.838]                             if (!grepl(pattern, name)) 
[13:35:36.838]                               next
[13:35:36.838]                             invokeRestart(restart)
[13:35:36.838]                             muffled <- TRUE
[13:35:36.838]                             break
[13:35:36.838]                           }
[13:35:36.838]                         }
[13:35:36.838]                       }
[13:35:36.838]                       invisible(muffled)
[13:35:36.838]                     }
[13:35:36.838]                     muffleCondition(cond, pattern = "^muffle")
[13:35:36.838]                   }
[13:35:36.838]                 }
[13:35:36.838]             }
[13:35:36.838]         }))
[13:35:36.838]     }, error = function(ex) {
[13:35:36.838]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:36.838]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:36.838]                 ...future.rng), started = ...future.startTime, 
[13:35:36.838]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:36.838]             version = "1.8"), class = "FutureResult")
[13:35:36.838]     }, finally = {
[13:35:36.838]         if (!identical(...future.workdir, getwd())) 
[13:35:36.838]             setwd(...future.workdir)
[13:35:36.838]         {
[13:35:36.838]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:36.838]                 ...future.oldOptions$nwarnings <- NULL
[13:35:36.838]             }
[13:35:36.838]             base::options(...future.oldOptions)
[13:35:36.838]             if (.Platform$OS.type == "windows") {
[13:35:36.838]                 old_names <- names(...future.oldEnvVars)
[13:35:36.838]                 envs <- base::Sys.getenv()
[13:35:36.838]                 names <- names(envs)
[13:35:36.838]                 common <- intersect(names, old_names)
[13:35:36.838]                 added <- setdiff(names, old_names)
[13:35:36.838]                 removed <- setdiff(old_names, names)
[13:35:36.838]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:36.838]                   envs[common]]
[13:35:36.838]                 NAMES <- toupper(changed)
[13:35:36.838]                 args <- list()
[13:35:36.838]                 for (kk in seq_along(NAMES)) {
[13:35:36.838]                   name <- changed[[kk]]
[13:35:36.838]                   NAME <- NAMES[[kk]]
[13:35:36.838]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:36.838]                     next
[13:35:36.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:36.838]                 }
[13:35:36.838]                 NAMES <- toupper(added)
[13:35:36.838]                 for (kk in seq_along(NAMES)) {
[13:35:36.838]                   name <- added[[kk]]
[13:35:36.838]                   NAME <- NAMES[[kk]]
[13:35:36.838]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:36.838]                     next
[13:35:36.838]                   args[[name]] <- ""
[13:35:36.838]                 }
[13:35:36.838]                 NAMES <- toupper(removed)
[13:35:36.838]                 for (kk in seq_along(NAMES)) {
[13:35:36.838]                   name <- removed[[kk]]
[13:35:36.838]                   NAME <- NAMES[[kk]]
[13:35:36.838]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:36.838]                     next
[13:35:36.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:36.838]                 }
[13:35:36.838]                 if (length(args) > 0) 
[13:35:36.838]                   base::do.call(base::Sys.setenv, args = args)
[13:35:36.838]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:36.838]             }
[13:35:36.838]             else {
[13:35:36.838]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:36.838]             }
[13:35:36.838]             {
[13:35:36.838]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:36.838]                   0L) {
[13:35:36.838]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:36.838]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:36.838]                   base::options(opts)
[13:35:36.838]                 }
[13:35:36.838]                 {
[13:35:36.838]                   {
[13:35:36.838]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:36.838]                     NULL
[13:35:36.838]                   }
[13:35:36.838]                   options(future.plan = NULL)
[13:35:36.838]                   if (is.na(NA_character_)) 
[13:35:36.838]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:36.838]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:36.838]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:36.838]                     .init = FALSE)
[13:35:36.838]                 }
[13:35:36.838]             }
[13:35:36.838]         }
[13:35:36.838]     })
[13:35:36.838]     if (FALSE) {
[13:35:36.838]         base::sink(type = "output", split = FALSE)
[13:35:36.838]         if (NA) {
[13:35:36.838]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:36.838]         }
[13:35:36.838]         else {
[13:35:36.838]             ...future.result["stdout"] <- base::list(NULL)
[13:35:36.838]         }
[13:35:36.838]         base::close(...future.stdout)
[13:35:36.838]         ...future.stdout <- NULL
[13:35:36.838]     }
[13:35:36.838]     ...future.result$conditions <- ...future.conditions
[13:35:36.838]     ...future.result$finished <- base::Sys.time()
[13:35:36.838]     ...future.result
[13:35:36.838] }
[13:35:36.841] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[13:35:36.841] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[13:35:36.842] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[13:35:36.842] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[13:35:36.842] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[13:35:36.842] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[13:35:36.842] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[13:35:36.843] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:35:36.843] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:35:36.843] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:35:36.843] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:35:36.843] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[13:35:36.844] MultisessionFuture started
[13:35:36.844] - Launch lazy future ... done
[13:35:36.844] run() for ‘MultisessionFuture’ ... done
[13:35:36.844] Created future:
[13:35:36.844] MultisessionFuture:
[13:35:36.844] Label: ‘future_mapply-2’
[13:35:36.844] Expression:
[13:35:36.844] {
[13:35:36.844]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:36.844]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:36.844]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:36.844]         on.exit(options(oopts), add = TRUE)
[13:35:36.844]     }
[13:35:36.844]     {
[13:35:36.844]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[13:35:36.844]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[13:35:36.844]         do.call(mapply, args = args)
[13:35:36.844]     }
[13:35:36.844] }
[13:35:36.844] Lazy evaluation: FALSE
[13:35:36.844] Asynchronous evaluation: TRUE
[13:35:36.844] Local evaluation: TRUE
[13:35:36.844] Environment: R_GlobalEnv
[13:35:36.844] Capture standard output: NA
[13:35:36.844] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:36.844] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:36.844] Packages: <none>
[13:35:36.844] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:36.844] Resolved: FALSE
[13:35:36.844] Value: <not collected>
[13:35:36.844] Conditions captured: <none>
[13:35:36.844] Early signaling: FALSE
[13:35:36.844] Owner process: 143a613a-6649-513b-fabd-28ac6212967e
[13:35:36.844] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:36.856] Chunk #2 of 2 ... DONE
[13:35:36.856] Launching 2 futures (chunks) ... DONE
[13:35:36.856] Resolving 2 futures (chunks) ...
[13:35:36.856] resolve() on list ...
[13:35:36.856]  recursive: 0
[13:35:36.856]  length: 2
[13:35:36.856] 
[13:35:36.898] receiveMessageFromWorker() for ClusterFuture ...
[13:35:36.898] - Validating connection of MultisessionFuture
[13:35:36.898] - received message: FutureResult
[13:35:36.898] - Received FutureResult
[13:35:36.899] - Erased future from FutureRegistry
[13:35:36.899] result() for ClusterFuture ...
[13:35:36.899] - result already collected: FutureResult
[13:35:36.899] result() for ClusterFuture ... done
[13:35:36.899] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:36.899] Future #2
[13:35:36.899] result() for ClusterFuture ...
[13:35:36.899] - result already collected: FutureResult
[13:35:36.899] result() for ClusterFuture ... done
[13:35:36.899] result() for ClusterFuture ...
[13:35:36.899] - result already collected: FutureResult
[13:35:36.899] result() for ClusterFuture ... done
[13:35:36.900] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:35:36.900] - nx: 2
[13:35:36.900] - relay: TRUE
[13:35:36.900] - stdout: TRUE
[13:35:36.900] - signal: TRUE
[13:35:36.900] - resignal: FALSE
[13:35:36.900] - force: TRUE
[13:35:36.900] - relayed: [n=2] FALSE, FALSE
[13:35:36.900] - queued futures: [n=2] FALSE, FALSE
[13:35:36.900]  - until=1
[13:35:36.900]  - relaying element #1
[13:35:36.901] - relayed: [n=2] FALSE, FALSE
[13:35:36.901] - queued futures: [n=2] FALSE, TRUE
[13:35:36.901] signalConditionsASAP(NULL, pos=2) ... done
[13:35:36.901]  length: 1 (resolved future 2)
[13:35:37.353] receiveMessageFromWorker() for ClusterFuture ...
[13:35:37.353] - Validating connection of MultisessionFuture
[13:35:37.353] - received message: FutureResult
[13:35:37.354] - Received FutureResult
[13:35:37.354] - Erased future from FutureRegistry
[13:35:37.354] result() for ClusterFuture ...
[13:35:37.354] - result already collected: FutureResult
[13:35:37.354] result() for ClusterFuture ... done
[13:35:37.354] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:37.354] Future #1
[13:35:37.354] result() for ClusterFuture ...
[13:35:37.354] - result already collected: FutureResult
[13:35:37.354] result() for ClusterFuture ... done
[13:35:37.355] result() for ClusterFuture ...
[13:35:37.355] - result already collected: FutureResult
[13:35:37.355] result() for ClusterFuture ... done
[13:35:37.355] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:35:37.355] - nx: 2
[13:35:37.355] - relay: TRUE
[13:35:37.355] - stdout: TRUE
[13:35:37.355] - signal: TRUE
[13:35:37.355] - resignal: FALSE
[13:35:37.355] - force: TRUE
[13:35:37.355] - relayed: [n=2] FALSE, FALSE
[13:35:37.356] - queued futures: [n=2] FALSE, TRUE
[13:35:37.356]  - until=1
[13:35:37.356]  - relaying element #1
[13:35:37.356] result() for ClusterFuture ...
[13:35:37.356] - result already collected: FutureResult
[13:35:37.356] result() for ClusterFuture ... done
[13:35:37.356] result() for ClusterFuture ...
[13:35:37.356] - result already collected: FutureResult
[13:35:37.356] result() for ClusterFuture ... done
[13:35:37.356] result() for ClusterFuture ...
[13:35:37.356] - result already collected: FutureResult
[13:35:37.356] result() for ClusterFuture ... done
[13:35:37.357] result() for ClusterFuture ...
[13:35:37.357] - result already collected: FutureResult
[13:35:37.357] result() for ClusterFuture ... done
[13:35:37.357] - relayed: [n=2] TRUE, FALSE
[13:35:37.357] - queued futures: [n=2] TRUE, TRUE
[13:35:37.357] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:35:37.357]  length: 0 (resolved future 1)
[13:35:37.357] Relaying remaining futures
[13:35:37.357] signalConditionsASAP(NULL, pos=0) ...
[13:35:37.357] - nx: 2
[13:35:37.357] - relay: TRUE
[13:35:37.357] - stdout: TRUE
[13:35:37.358] - signal: TRUE
[13:35:37.358] - resignal: FALSE
[13:35:37.358] - force: TRUE
[13:35:37.358] - relayed: [n=2] TRUE, FALSE
[13:35:37.358] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:37.358]  - relaying element #2
[13:35:37.358] result() for ClusterFuture ...
[13:35:37.358] - result already collected: FutureResult
[13:35:37.358] result() for ClusterFuture ... done
[13:35:37.358] result() for ClusterFuture ...
[13:35:37.358] - result already collected: FutureResult
[13:35:37.359] result() for ClusterFuture ... done
[13:35:37.359] result() for ClusterFuture ...
[13:35:37.359] - result already collected: FutureResult
[13:35:37.359] result() for ClusterFuture ... done
[13:35:37.359] result() for ClusterFuture ...
[13:35:37.359] - result already collected: FutureResult
[13:35:37.359] result() for ClusterFuture ... done
[13:35:37.359] - relayed: [n=2] TRUE, TRUE
[13:35:37.359] - queued futures: [n=2] TRUE, TRUE
[13:35:37.359] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[13:35:37.359] resolve() on list ... DONE
[13:35:37.359] result() for ClusterFuture ...
[13:35:37.360] - result already collected: FutureResult
[13:35:37.360] result() for ClusterFuture ... done
[13:35:37.360] result() for ClusterFuture ...
[13:35:37.360] - result already collected: FutureResult
[13:35:37.360] result() for ClusterFuture ... done
[13:35:37.360] result() for ClusterFuture ...
[13:35:37.360] - result already collected: FutureResult
[13:35:37.360] result() for ClusterFuture ... done
[13:35:37.360] result() for ClusterFuture ...
[13:35:37.360] - result already collected: FutureResult
[13:35:37.360] result() for ClusterFuture ... done
[13:35:37.361]  - Number of value chunks collected: 2
[13:35:37.361] Resolving 2 futures (chunks) ... DONE
[13:35:37.361] Reducing values from 2 chunks ...
[13:35:37.361]  - Number of values collected after concatenation: 2
[13:35:37.361]  - Number of values expected: 2
[13:35:37.361] Reducing values from 2 chunks ... DONE
[13:35:37.361] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 2 cores ... DONE
> 
> message("*** future_*apply() and 'future.stdout' ... DONE")
*** future_*apply() and 'future.stdout' ... DONE
> 
> source("incl/end.R")
[13:35:37.362] plan(): Setting new future strategy stack:
[13:35:37.362] List of future strategies:
[13:35:37.362] 1. FutureStrategy:
[13:35:37.362]    - args: function (..., envir = parent.frame())
[13:35:37.362]    - tweaked: FALSE
[13:35:37.362]    - call: future::plan(oplan)
[13:35:37.363] plan(): nbrOfWorkers() = 1
> 
